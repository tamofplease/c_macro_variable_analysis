<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/PolarDB-for-PostgreSQL/contrib/postgres_fdw/deparse.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * deparse.c
 *		  Query deparser for postgres_fdw
 *
 * This file includes functions that examine query WHERE clauses to see
 * whether they're safe to send to the remote server for execution, as
 * well as functions to construct the query text to be sent.  The latter
 * functionality is annoyingly duplicative of ruleutils.c, but there are
 * enough special considerations that it seems best to keep this separate.
 * One saving grace is that we only need deparse logic for node types that
 * we consider safe to send.
 *
 * We assume that the remote session's search_path is exactly "pg_catalog",
 * and thus we need schema-qualify all and only names outside pg_catalog.
 *
 * We do not consider that it is ever safe to send COLLATE expressions to
 * the remote server: it might not have the same collation names we do.
 * (Later we might consider it safe to send COLLATE "C", but even that would
 * fail on old remote servers.)  An expression is considered safe to send
 * only if all operator/function input collations used in it are traceable to
 * Var(s) of the foreign table.  That implies that if the remote server gets
 * a different answer than we do, the foreign table's columns are not marked
 * with collations that match the remote table's columns, which we can
 * consider to be user error.
 *
 * Portions Copyright (c) 2012-2018, PostgreSQL Global Development Group
 *
 * IDENTIFICATION
 *		  contrib/postgres_fdw/deparse.c
 *
 *-------------------------------------------------------------------------
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres_fdw.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/heapam.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/htup_details.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/sysattr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_aggregate.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_collation.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_namespace.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_operator.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_proc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_type.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/defrem.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/makefuncs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/nodeFuncs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/plannodes.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/clauses.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/prep.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/tlist.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/var.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parsetree.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/builtins.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/lsyscache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/rel.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/syscache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/typcache.h"</cpp:file></cpp:include>


<comment type="block">/*
 * Global context for foreign_expr_walker's search of an expression tree.
 */</comment>
<typedef>typedef <type><struct>struct <name>foreign_glob_cxt</name>
<block>{
	<decl_stmt><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl>;</decl_stmt>			<comment type="block">/* global planner state */</comment>
	<decl_stmt><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>foreignrel</name></decl>;</decl_stmt>		<comment type="block">/* the foreign relation we are planning for */</comment>
	<decl_stmt><decl><type><name>Relids</name></type>		<name>relids</name></decl>;</decl_stmt>			<comment type="block">/* relids of base relations in the underlying
								 * scan */</comment>
}</block></struct></type> <name>foreign_glob_cxt</name>;</typedef>

<comment type="block">/*
 * Local (per-tree-level) context for foreign_expr_walker's search.
 * This is concerned with identifying collations used in the expression.
 */</comment>
<typedef>typedef <type><enum>enum
<block>{
	<decl><name>FDW_COLLATE_NONE</name></decl>,			<comment type="block">/* expression is of a noncollatable type, or
								 * it has default collation that is not
								 * traceable to a foreign Var */</comment>
	<decl><name>FDW_COLLATE_SAFE</name></decl>,			<comment type="block">/* collation derives from a foreign Var */</comment>
	<decl><name>FDW_COLLATE_UNSAFE</name></decl>			<comment type="block">/* collation is non-default and derives from
								 * something other than a foreign Var */</comment>
}</block></enum></type> <name>FDWCollateState</name>;</typedef>

<typedef>typedef <type><struct>struct <name>foreign_loc_cxt</name>
<block>{
	<decl_stmt><decl><type><name>Oid</name></type>			<name>collation</name></decl>;</decl_stmt>		<comment type="block">/* OID of current collation, if any */</comment>
	<decl_stmt><decl><type><name>FDWCollateState</name></type> <name>state</name></decl>;</decl_stmt>		<comment type="block">/* state of current collation choice */</comment>
}</block></struct></type> <name>foreign_loc_cxt</name>;</typedef>

<comment type="block">/*
 * Context for deparseExpr
 */</comment>
<typedef>typedef <type><struct>struct <name>deparse_expr_cxt</name>
<block>{
	<decl_stmt><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl>;</decl_stmt>			<comment type="block">/* global planner state */</comment>
	<decl_stmt><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>foreignrel</name></decl>;</decl_stmt>		<comment type="block">/* the foreign relation we are planning for */</comment>
	<decl_stmt><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>scanrel</name></decl>;</decl_stmt>		<comment type="block">/* the underlying scan relation. Same as
								 * foreignrel, when that represents a join or
								 * a base relation. */</comment>
	<decl_stmt><decl><type><name>StringInfo</name></type>	<name>buf</name></decl>;</decl_stmt>			<comment type="block">/* output buffer to append to */</comment>
	<decl_stmt><decl><type><name>List</name>	  <modifier>*</modifier><modifier>*</modifier></type><name>params_list</name></decl>;</decl_stmt>	<comment type="block">/* exprs that will become remote Params */</comment>
}</block></struct></type> <name>deparse_expr_cxt</name>;</typedef>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>REL_ALIAS_PREFIX</name></cpp:macro>	<cpp:value>"r"</cpp:value></cpp:define>
<comment type="block">/* Handy macro to add relation name qualification */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ADD_REL_QUALIFIER</name><parameter_list>(<parameter><type><name>buf</name></type></parameter>, <parameter><type><name>varno</name></type></parameter>)</parameter_list></cpp:macro>	\
		<cpp:value>appendStringInfo((buf), "%s%d.", REL_ALIAS_PREFIX, (varno))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SUBQUERY_REL_ALIAS_PREFIX</name></cpp:macro>	<cpp:value>"s"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SUBQUERY_COL_ALIAS_PREFIX</name></cpp:macro>	<cpp:value>"c"</cpp:value></cpp:define>

<comment type="block">/*
 * Functions to determine whether an expression can be evaluated safely on
 * remote server.
 */</comment>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>foreign_expr_walker</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>,
					<parameter><decl><type><name>foreign_glob_cxt</name> <modifier>*</modifier></type><name>glob_cxt</name></decl></parameter>,
					<parameter><decl><type><name>foreign_loc_cxt</name> <modifier>*</modifier></type><name>outer_cxt</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>deparse_type_name</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>type_oid</name></decl></parameter>, <parameter><decl><type><name>int32</name></type> <name>typemod</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/*
 * Functions to construct string representation of a node tree.
 */</comment>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>deparseTargetList</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>buf</name></decl></parameter>,
				  <parameter><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name></decl></parameter>,
				  <parameter><decl><type><name>Index</name></type> <name>rtindex</name></decl></parameter>,
				  <parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>,
				  <parameter><decl><type><name>bool</name></type> <name>is_returning</name></decl></parameter>,
				  <parameter><decl><type><name>Bitmapset</name> <modifier>*</modifier></type><name>attrs_used</name></decl></parameter>,
				  <parameter><decl><type><name>bool</name></type> <name>qualify_col</name></decl></parameter>,
				  <parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>retrieved_attrs</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>deparseExplicitTargetList</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>tlist</name></decl></parameter>,
						  <parameter><decl><type><name>bool</name></type> <name>is_returning</name></decl></parameter>,
						  <parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>retrieved_attrs</name></decl></parameter>,
						  <parameter><decl><type><name>deparse_expr_cxt</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>deparseSubqueryTargetList</name><parameter_list>(<parameter><decl><type><name>deparse_expr_cxt</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>deparseReturningList</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>buf</name></decl></parameter>, <parameter><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name></decl></parameter>,
					 <parameter><decl><type><name>Index</name></type> <name>rtindex</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>,
					 <parameter><decl><type><name>bool</name></type> <name>trig_after_row</name></decl></parameter>,
					 <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>returningList</name></decl></parameter>,
					 <parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>retrieved_attrs</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>deparseColumnRef</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>buf</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>varno</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>varattno</name></decl></parameter>,
				 <parameter><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>qualify_col</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>deparseRelation</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>buf</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>deparseExpr</name><parameter_list>(<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>expr</name></decl></parameter>, <parameter><decl><type><name>deparse_expr_cxt</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>deparseVar</name><parameter_list>(<parameter><decl><type><name>Var</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>deparse_expr_cxt</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>deparseConst</name><parameter_list>(<parameter><decl><type><name>Const</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>deparse_expr_cxt</name> <modifier>*</modifier></type><name>context</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>showtype</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>deparseParam</name><parameter_list>(<parameter><decl><type><name>Param</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>deparse_expr_cxt</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>deparseArrayRef</name><parameter_list>(<parameter><decl><type><name>ArrayRef</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>deparse_expr_cxt</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>deparseFuncExpr</name><parameter_list>(<parameter><decl><type><name>FuncExpr</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>deparse_expr_cxt</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>deparseOpExpr</name><parameter_list>(<parameter><decl><type><name>OpExpr</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>deparse_expr_cxt</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>deparseOperatorName</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>buf</name></decl></parameter>, <parameter><decl><type><name>Form_pg_operator</name></type> <name>opform</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>deparseDistinctExpr</name><parameter_list>(<parameter><decl><type><name>DistinctExpr</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>deparse_expr_cxt</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>deparseScalarArrayOpExpr</name><parameter_list>(<parameter><decl><type><name>ScalarArrayOpExpr</name> <modifier>*</modifier></type><name>node</name></decl></parameter>,
						 <parameter><decl><type><name>deparse_expr_cxt</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>deparseRelabelType</name><parameter_list>(<parameter><decl><type><name>RelabelType</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>deparse_expr_cxt</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>deparseBoolExpr</name><parameter_list>(<parameter><decl><type><name>BoolExpr</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>deparse_expr_cxt</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>deparseNullTest</name><parameter_list>(<parameter><decl><type><name>NullTest</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>deparse_expr_cxt</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>deparseArrayExpr</name><parameter_list>(<parameter><decl><type><name>ArrayExpr</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>deparse_expr_cxt</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>printRemoteParam</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>paramindex</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>paramtype</name></decl></parameter>, <parameter><decl><type><name>int32</name></type> <name>paramtypmod</name></decl></parameter>,
				 <parameter><decl><type><name>deparse_expr_cxt</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>printRemotePlaceholder</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>paramtype</name></decl></parameter>, <parameter><decl><type><name>int32</name></type> <name>paramtypmod</name></decl></parameter>,
					   <parameter><decl><type><name>deparse_expr_cxt</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>deparseSelectSql</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>tlist</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>is_subquery</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>retrieved_attrs</name></decl></parameter>,
				 <parameter><decl><type><name>deparse_expr_cxt</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>deparseLockingClause</name><parameter_list>(<parameter><decl><type><name>deparse_expr_cxt</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>appendOrderByClause</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>pathkeys</name></decl></parameter>, <parameter><decl><type><name>deparse_expr_cxt</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>appendConditions</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>exprs</name></decl></parameter>, <parameter><decl><type><name>deparse_expr_cxt</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>deparseFromExprForRel</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>buf</name></decl></parameter>, <parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
					  <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>foreignrel</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>use_alias</name></decl></parameter>,
					  <parameter><decl><type><name>Index</name></type> <name>ignore_rel</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>ignore_conds</name></decl></parameter>,
					  <parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>params_list</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>deparseFromExpr</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>quals</name></decl></parameter>, <parameter><decl><type><name>deparse_expr_cxt</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>deparseRangeTblRef</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>buf</name></decl></parameter>, <parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
				   <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>foreignrel</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>make_subquery</name></decl></parameter>,
				   <parameter><decl><type><name>Index</name></type> <name>ignore_rel</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>ignore_conds</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>params_list</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>deparseAggref</name><parameter_list>(<parameter><decl><type><name>Aggref</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>deparse_expr_cxt</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>appendGroupByClause</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>tlist</name></decl></parameter>, <parameter><decl><type><name>deparse_expr_cxt</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>appendAggOrderBy</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>orderList</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>targetList</name></decl></parameter>,
				 <parameter><decl><type><name>deparse_expr_cxt</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>appendFunctionName</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>funcid</name></decl></parameter>, <parameter><decl><type><name>deparse_expr_cxt</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type><name>deparseSortGroupClause</name><parameter_list>(<parameter><decl><type><name>Index</name></type> <name>ref</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>tlist</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>force_colno</name></decl></parameter>,
					   <parameter><decl><type><name>deparse_expr_cxt</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/*
 * Helper functions
 */</comment>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>is_subquery_var</name><parameter_list>(<parameter><decl><type><name>Var</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>foreignrel</name></decl></parameter>,
				<parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>relno</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>colno</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>get_relation_column_alias_ids</name><parameter_list>(<parameter><decl><type><name>Var</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>foreignrel</name></decl></parameter>,
							  <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>relno</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>colno</name></decl></parameter>)</parameter_list>;</function_decl>


<comment type="block">/*
 * Examine each qual clause in input_conds, and classify them into two groups,
 * which are returned as two lists:
 *	- remote_conds contains expressions that can be evaluated remotely
 *	- local_conds contains expressions that can't be evaluated remotely
 */</comment>
<function><type><name>void</name></type>
<name>classifyConditions</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
				   <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>baserel</name></decl></parameter>,
				   <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>input_conds</name></decl></parameter>,
				   <parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>remote_conds</name></decl></parameter>,
				   <parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>local_conds</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

	<expr_stmt><expr><operator>*</operator><name>remote_conds</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>local_conds</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>

	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>input_conds</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>RestrictInfo</name> <modifier>*</modifier></type><name>ri</name> <init>= <expr><call><name>lfirst_node</name><argument_list>(<argument><expr><name>RestrictInfo</name></expr></argument>, <argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>is_foreign_expr</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>baserel</name></expr></argument>, <argument><expr><name><name>ri</name><operator>-&gt;</operator><name>clause</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><operator>*</operator><name>remote_conds</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><operator>*</operator><name>remote_conds</name></expr></argument>, <argument><expr><name>ri</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><operator>*</operator><name>local_conds</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><operator>*</operator><name>local_conds</name></expr></argument>, <argument><expr><name>ri</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block>
</block_content>}</block></function>

<comment type="block">/*
 * Returns true if given expr is safe to evaluate on the foreign server.
 */</comment>
<function><type><name>bool</name></type>
<name>is_foreign_expr</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
				<parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>baserel</name></decl></parameter>,
				<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>expr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>foreign_glob_cxt</name></type> <name>glob_cxt</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>foreign_loc_cxt</name></type> <name>loc_cxt</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PgFdwRelationInfo</name> <modifier>*</modifier></type><name>fpinfo</name> <init>= <expr><operator>(</operator><name>PgFdwRelationInfo</name> <operator>*</operator><operator>)</operator> <operator>(</operator><name><name>baserel</name><operator>-&gt;</operator><name>fdw_private</name></name><operator>)</operator></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * Check that the expression consists of nodes that are safe to execute
	 * remotely.
	 */</comment>
	<expr_stmt><expr><name><name>glob_cxt</name><operator>.</operator><name>root</name></name> <operator>=</operator> <name>root</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>glob_cxt</name><operator>.</operator><name>foreignrel</name></name> <operator>=</operator> <name>baserel</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * For an upper relation, use relids from its underneath scan relation,
	 * because the upperrel's own relids currently aren't set to anything
	 * meaningful by the core code.  For other relation, use their own relids.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>IS_UPPER_REL</name><argument_list>(<argument><expr><name>baserel</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>glob_cxt</name><operator>.</operator><name>relids</name></name> <operator>=</operator> <name><name>fpinfo</name><operator>-&gt;</operator><name>outerrel</name><operator>-&gt;</operator><name>relids</name></name></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>glob_cxt</name><operator>.</operator><name>relids</name></name> <operator>=</operator> <name><name>baserel</name><operator>-&gt;</operator><name>relids</name></name></expr>;</expr_stmt></block_content></block></else></if_stmt>
	<expr_stmt><expr><name><name>loc_cxt</name><operator>.</operator><name>collation</name></name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>loc_cxt</name><operator>.</operator><name>state</name></name> <operator>=</operator> <name>FDW_COLLATE_NONE</name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>foreign_expr_walker</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>expr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>glob_cxt</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>loc_cxt</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * If the expression has a valid collation that does not arise from a
	 * foreign var, the expression can not be sent over.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>loc_cxt</name><operator>.</operator><name>state</name></name> <operator>==</operator> <name>FDW_COLLATE_UNSAFE</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * An expression which includes any mutable functions can't be sent over
	 * because its result is not stable.  For example, sending now() remote
	 * side could cause confusion from clock offsets.  Future versions might
	 * be able to make this choice with more granularity.  (We check this last
	 * because it requires a lot of expensive catalog lookups.)
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>contain_mutable_functions</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>expr</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* OK to evaluate on the remote server */</comment>
	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Check if expression is safe to execute remotely, and return true if so.
 *
 * In addition, *outer_cxt is updated with collation information.
 *
 * We must check that the expression contains only node types we can deparse,
 * that all types/functions/operators are safe to send (they are "shippable"),
 * and that all collations used in the expression derive from Vars of the
 * foreign table.  Because of the latter, the logic is pretty close to
 * assign_collations_walker() in parse_collate.c, though we can assume here
 * that the given expression is valid.  Note function mutability is not
 * currently considered here.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>foreign_expr_walker</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>,
					<parameter><decl><type><name>foreign_glob_cxt</name> <modifier>*</modifier></type><name>glob_cxt</name></decl></parameter>,
					<parameter><decl><type><name>foreign_loc_cxt</name> <modifier>*</modifier></type><name>outer_cxt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type>		<name>check_type</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PgFdwRelationInfo</name> <modifier>*</modifier></type><name>fpinfo</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>foreign_loc_cxt</name></type> <name>inner_cxt</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>collation</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>FDWCollateState</name></type> <name>state</name></decl>;</decl_stmt>

	<comment type="block">/* Need do nothing for empty subexpressions */</comment>
	<if_stmt><if>if <condition>(<expr><name>node</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* May need server info from baserel's fdw_private struct */</comment>
	<expr_stmt><expr><name>fpinfo</name> <operator>=</operator> <operator>(</operator><name>PgFdwRelationInfo</name> <operator>*</operator><operator>)</operator> <operator>(</operator><name><name>glob_cxt</name><operator>-&gt;</operator><name>foreignrel</name><operator>-&gt;</operator><name>fdw_private</name></name><operator>)</operator></expr>;</expr_stmt>

	<comment type="block">/* Set up inner_cxt for possible recursion to child nodes */</comment>
	<expr_stmt><expr><name><name>inner_cxt</name><operator>.</operator><name>collation</name></name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>inner_cxt</name><operator>.</operator><name>state</name></name> <operator>=</operator> <name>FDW_COLLATE_NONE</name></expr>;</expr_stmt>

	<switch>switch <condition>(<expr><call><name>nodeTag</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>T_Var</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>Var</name>		   <modifier>*</modifier></type><name>var</name> <init>= <expr><operator>(</operator><name>Var</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

				<comment type="block">/*
				 * If the Var is from the foreign table, we consider its
				 * collation (if any) safe to use.  If it is from another
				 * table, we treat its collation the same way as we would a
				 * Param's collation, ie it's not safe for it to have a
				 * non-default collation.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><call><name>bms_is_member</name><argument_list>(<argument><expr><name><name>var</name><operator>-&gt;</operator><name>varno</name></name></expr></argument>, <argument><expr><name><name>glob_cxt</name><operator>-&gt;</operator><name>relids</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
					<name><name>var</name><operator>-&gt;</operator><name>varlevelsup</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/* Var belongs to foreign table */</comment>

					<comment type="block">/*
					 * System columns other than ctid and oid should not be
					 * sent to the remote, since we don't make any effort to
					 * ensure that local and remote values match (tableoid, in
					 * particular, almost certainly doesn't match).
					 */</comment>
					<if_stmt><if>if <condition>(<expr><name><name>var</name><operator>-&gt;</operator><name>varattno</name></name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
						<name><name>var</name><operator>-&gt;</operator><name>varattno</name></name> <operator>!=</operator> <name>SelfItemPointerAttributeNumber</name> <operator>&amp;&amp;</operator>
						<name><name>var</name><operator>-&gt;</operator><name>varattno</name></name> <operator>!=</operator> <name>ObjectIdAttributeNumber</name></expr>)</condition><block type="pseudo"><block_content>
						<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

					<comment type="block">/* Else check the collation */</comment>
					<expr_stmt><expr><name>collation</name> <operator>=</operator> <name><name>var</name><operator>-&gt;</operator><name>varcollid</name></name></expr>;</expr_stmt>
					<expr_stmt><expr><name>state</name> <operator>=</operator> <ternary><condition><expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>collation</name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><name>FDW_COLLATE_SAFE</name></expr> </then><else>: <expr><name>FDW_COLLATE_NONE</name></expr></else></ternary></expr>;</expr_stmt>
				</block_content>}</block></if>
				<else>else
				<block>{<block_content>
					<comment type="block">/* Var belongs to some other table */</comment>
					<expr_stmt><expr><name>collation</name> <operator>=</operator> <name><name>var</name><operator>-&gt;</operator><name>varcollid</name></name></expr>;</expr_stmt>
					<if_stmt><if>if <condition>(<expr><name>collation</name> <operator>==</operator> <name>InvalidOid</name> <operator>||</operator>
						<name>collation</name> <operator>==</operator> <name>DEFAULT_COLLATION_OID</name></expr>)</condition>
					<block>{<block_content>
						<comment type="block">/*
						 * It's noncollatable, or it's safe to combine with a
						 * collatable foreign Var, so set state to NONE.
						 */</comment>
						<expr_stmt><expr><name>state</name> <operator>=</operator> <name>FDW_COLLATE_NONE</name></expr>;</expr_stmt>
					</block_content>}</block></if>
					<else>else
					<block>{<block_content>
						<comment type="block">/*
						 * Do not fail right away, since the Var might appear
						 * in a collation-insensitive context.
						 */</comment>
						<expr_stmt><expr><name>state</name> <operator>=</operator> <name>FDW_COLLATE_UNSAFE</name></expr>;</expr_stmt>
					</block_content>}</block></else></if_stmt>
				</block_content>}</block></else></if_stmt>
			</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>T_Const</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>Const</name>	   <modifier>*</modifier></type><name>c</name> <init>= <expr><operator>(</operator><name>Const</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

				<comment type="block">/*
				 * If the constant has nondefault collation, either it's of a
				 * non-builtin type, or it reflects folding of a CollateExpr.
				 * It's unsafe to send to the remote unless it's used in a
				 * non-collation-sensitive context.
				 */</comment>
				<expr_stmt><expr><name>collation</name> <operator>=</operator> <name><name>c</name><operator>-&gt;</operator><name>constcollid</name></name></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name>collation</name> <operator>==</operator> <name>InvalidOid</name> <operator>||</operator>
					<name>collation</name> <operator>==</operator> <name>DEFAULT_COLLATION_OID</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>state</name> <operator>=</operator> <name>FDW_COLLATE_NONE</name></expr>;</expr_stmt></block_content></block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><name>state</name> <operator>=</operator> <name>FDW_COLLATE_UNSAFE</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
			</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>T_Param</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>Param</name>	   <modifier>*</modifier></type><name>p</name> <init>= <expr><operator>(</operator><name>Param</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

				<comment type="block">/*
				 * If it's a MULTIEXPR Param, punt.  We can't tell from here
				 * whether the referenced sublink/subplan contains any remote
				 * Vars; if it does, handling that is too complicated to
				 * consider supporting at present.  Fortunately, MULTIEXPR
				 * Params are not reduced to plain PARAM_EXEC until the end of
				 * planning, so we can easily detect this case.  (Normal
				 * PARAM_EXEC Params are safe to ship because their values
				 * come from somewhere else in the plan tree; but a MULTIEXPR
				 * references a sub-select elsewhere in the same targetlist,
				 * so we'd be on the hook to evaluate it somehow if we wanted
				 * to handle such cases as direct foreign updates.)
				 */</comment>
				<if_stmt><if>if <condition>(<expr><name><name>p</name><operator>-&gt;</operator><name>paramkind</name></name> <operator>==</operator> <name>PARAM_MULTIEXPR</name></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

				<comment type="block">/*
				 * Collation rule is same as for Consts and non-foreign Vars.
				 */</comment>
				<expr_stmt><expr><name>collation</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>paramcollid</name></name></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name>collation</name> <operator>==</operator> <name>InvalidOid</name> <operator>||</operator>
					<name>collation</name> <operator>==</operator> <name>DEFAULT_COLLATION_OID</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>state</name> <operator>=</operator> <name>FDW_COLLATE_NONE</name></expr>;</expr_stmt></block_content></block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><name>state</name> <operator>=</operator> <name>FDW_COLLATE_UNSAFE</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
			</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>T_ArrayRef</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>ArrayRef</name>   <modifier>*</modifier></type><name>ar</name> <init>= <expr><operator>(</operator><name>ArrayRef</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

				<comment type="block">/* Assignment should not be in restrictions. */</comment>
				<if_stmt><if>if <condition>(<expr><name><name>ar</name><operator>-&gt;</operator><name>refassgnexpr</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

				<comment type="block">/*
				 * Recurse to remaining subexpressions.  Since the array
				 * subscripts must yield (noncollatable) integers, they won't
				 * affect the inner_cxt state.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>foreign_expr_walker</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>ar</name><operator>-&gt;</operator><name>refupperindexpr</name></name></expr></argument>,
										 <argument><expr><name>glob_cxt</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>inner_cxt</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>foreign_expr_walker</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>ar</name><operator>-&gt;</operator><name>reflowerindexpr</name></name></expr></argument>,
										 <argument><expr><name>glob_cxt</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>inner_cxt</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>foreign_expr_walker</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>ar</name><operator>-&gt;</operator><name>refexpr</name></name></expr></argument>,
										 <argument><expr><name>glob_cxt</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>inner_cxt</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

				<comment type="block">/*
				 * Array subscripting should yield same collation as input,
				 * but for safety use same logic as for function nodes.
				 */</comment>
				<expr_stmt><expr><name>collation</name> <operator>=</operator> <name><name>ar</name><operator>-&gt;</operator><name>refcollid</name></name></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name>collation</name> <operator>==</operator> <name>InvalidOid</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>state</name> <operator>=</operator> <name>FDW_COLLATE_NONE</name></expr>;</expr_stmt></block_content></block></if>
				<if type="elseif">else if <condition>(<expr><name><name>inner_cxt</name><operator>.</operator><name>state</name></name> <operator>==</operator> <name>FDW_COLLATE_SAFE</name> <operator>&amp;&amp;</operator>
						 <name>collation</name> <operator>==</operator> <name><name>inner_cxt</name><operator>.</operator><name>collation</name></name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>state</name> <operator>=</operator> <name>FDW_COLLATE_SAFE</name></expr>;</expr_stmt></block_content></block></if>
				<if type="elseif">else if <condition>(<expr><name>collation</name> <operator>==</operator> <name>DEFAULT_COLLATION_OID</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>state</name> <operator>=</operator> <name>FDW_COLLATE_NONE</name></expr>;</expr_stmt></block_content></block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><name>state</name> <operator>=</operator> <name>FDW_COLLATE_UNSAFE</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
			</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>T_FuncExpr</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>FuncExpr</name>   <modifier>*</modifier></type><name>fe</name> <init>= <expr><operator>(</operator><name>FuncExpr</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

				<comment type="block">/*
				 * If function used by the expression is not shippable, it
				 * can't be sent to remote because it might have incompatible
				 * semantics on remote side.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>is_shippable</name><argument_list>(<argument><expr><name><name>fe</name><operator>-&gt;</operator><name>funcid</name></name></expr></argument>, <argument><expr><name>ProcedureRelationId</name></expr></argument>, <argument><expr><name>fpinfo</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

				<comment type="block">/*
				 * Recurse to input subexpressions.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>foreign_expr_walker</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>fe</name><operator>-&gt;</operator><name>args</name></name></expr></argument>,
										 <argument><expr><name>glob_cxt</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>inner_cxt</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

				<comment type="block">/*
				 * If function's input collation is not derived from a foreign
				 * Var, it can't be sent to remote.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><name><name>fe</name><operator>-&gt;</operator><name>inputcollid</name></name> <operator>==</operator> <name>InvalidOid</name></expr>)</condition><block type="pseudo"><block_content>
					 <comment type="block">/* OK, inputs are all noncollatable */</comment> <empty_stmt>;</empty_stmt></block_content></block></if>
				<if type="elseif">else if <condition>(<expr><name><name>inner_cxt</name><operator>.</operator><name>state</name></name> <operator>!=</operator> <name>FDW_COLLATE_SAFE</name> <operator>||</operator>
						 <name><name>fe</name><operator>-&gt;</operator><name>inputcollid</name></name> <operator>!=</operator> <name><name>inner_cxt</name><operator>.</operator><name>collation</name></name></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

				<comment type="block">/*
				 * Detect whether node is introducing a collation not derived
				 * from a foreign Var.  (If so, we just mark it unsafe for now
				 * rather than immediately returning false, since the parent
				 * node might not care.)
				 */</comment>
				<expr_stmt><expr><name>collation</name> <operator>=</operator> <name><name>fe</name><operator>-&gt;</operator><name>funccollid</name></name></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name>collation</name> <operator>==</operator> <name>InvalidOid</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>state</name> <operator>=</operator> <name>FDW_COLLATE_NONE</name></expr>;</expr_stmt></block_content></block></if>
				<if type="elseif">else if <condition>(<expr><name><name>inner_cxt</name><operator>.</operator><name>state</name></name> <operator>==</operator> <name>FDW_COLLATE_SAFE</name> <operator>&amp;&amp;</operator>
						 <name>collation</name> <operator>==</operator> <name><name>inner_cxt</name><operator>.</operator><name>collation</name></name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>state</name> <operator>=</operator> <name>FDW_COLLATE_SAFE</name></expr>;</expr_stmt></block_content></block></if>
				<if type="elseif">else if <condition>(<expr><name>collation</name> <operator>==</operator> <name>DEFAULT_COLLATION_OID</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>state</name> <operator>=</operator> <name>FDW_COLLATE_NONE</name></expr>;</expr_stmt></block_content></block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><name>state</name> <operator>=</operator> <name>FDW_COLLATE_UNSAFE</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
			</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>T_OpExpr</name></expr>:</case>
		<case>case <expr><name>T_DistinctExpr</name></expr>:</case>	<comment type="block">/* struct-equivalent to OpExpr */</comment>
			<block>{<block_content>
				<decl_stmt><decl><type><name>OpExpr</name>	   <modifier>*</modifier></type><name>oe</name> <init>= <expr><operator>(</operator><name>OpExpr</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

				<comment type="block">/*
				 * Similarly, only shippable operators can be sent to remote.
				 * (If the operator is shippable, we assume its underlying
				 * function is too.)
				 */</comment>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>is_shippable</name><argument_list>(<argument><expr><name><name>oe</name><operator>-&gt;</operator><name>opno</name></name></expr></argument>, <argument><expr><name>OperatorRelationId</name></expr></argument>, <argument><expr><name>fpinfo</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

				<comment type="block">/*
				 * Recurse to input subexpressions.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>foreign_expr_walker</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>oe</name><operator>-&gt;</operator><name>args</name></name></expr></argument>,
										 <argument><expr><name>glob_cxt</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>inner_cxt</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

				<comment type="block">/*
				 * If operator's input collation is not derived from a foreign
				 * Var, it can't be sent to remote.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><name><name>oe</name><operator>-&gt;</operator><name>inputcollid</name></name> <operator>==</operator> <name>InvalidOid</name></expr>)</condition><block type="pseudo"><block_content>
					 <comment type="block">/* OK, inputs are all noncollatable */</comment> <empty_stmt>;</empty_stmt></block_content></block></if>
				<if type="elseif">else if <condition>(<expr><name><name>inner_cxt</name><operator>.</operator><name>state</name></name> <operator>!=</operator> <name>FDW_COLLATE_SAFE</name> <operator>||</operator>
						 <name><name>oe</name><operator>-&gt;</operator><name>inputcollid</name></name> <operator>!=</operator> <name><name>inner_cxt</name><operator>.</operator><name>collation</name></name></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

				<comment type="block">/* Result-collation handling is same as for functions */</comment>
				<expr_stmt><expr><name>collation</name> <operator>=</operator> <name><name>oe</name><operator>-&gt;</operator><name>opcollid</name></name></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name>collation</name> <operator>==</operator> <name>InvalidOid</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>state</name> <operator>=</operator> <name>FDW_COLLATE_NONE</name></expr>;</expr_stmt></block_content></block></if>
				<if type="elseif">else if <condition>(<expr><name><name>inner_cxt</name><operator>.</operator><name>state</name></name> <operator>==</operator> <name>FDW_COLLATE_SAFE</name> <operator>&amp;&amp;</operator>
						 <name>collation</name> <operator>==</operator> <name><name>inner_cxt</name><operator>.</operator><name>collation</name></name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>state</name> <operator>=</operator> <name>FDW_COLLATE_SAFE</name></expr>;</expr_stmt></block_content></block></if>
				<if type="elseif">else if <condition>(<expr><name>collation</name> <operator>==</operator> <name>DEFAULT_COLLATION_OID</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>state</name> <operator>=</operator> <name>FDW_COLLATE_NONE</name></expr>;</expr_stmt></block_content></block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><name>state</name> <operator>=</operator> <name>FDW_COLLATE_UNSAFE</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
			</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>T_ScalarArrayOpExpr</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>ScalarArrayOpExpr</name> <modifier>*</modifier></type><name>oe</name> <init>= <expr><operator>(</operator><name>ScalarArrayOpExpr</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

				<comment type="block">/*
				 * Again, only shippable operators can be sent to remote.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>is_shippable</name><argument_list>(<argument><expr><name><name>oe</name><operator>-&gt;</operator><name>opno</name></name></expr></argument>, <argument><expr><name>OperatorRelationId</name></expr></argument>, <argument><expr><name>fpinfo</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

				<comment type="block">/*
				 * Recurse to input subexpressions.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>foreign_expr_walker</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>oe</name><operator>-&gt;</operator><name>args</name></name></expr></argument>,
										 <argument><expr><name>glob_cxt</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>inner_cxt</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

				<comment type="block">/*
				 * If operator's input collation is not derived from a foreign
				 * Var, it can't be sent to remote.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><name><name>oe</name><operator>-&gt;</operator><name>inputcollid</name></name> <operator>==</operator> <name>InvalidOid</name></expr>)</condition><block type="pseudo"><block_content>
					 <comment type="block">/* OK, inputs are all noncollatable */</comment> <empty_stmt>;</empty_stmt></block_content></block></if>
				<if type="elseif">else if <condition>(<expr><name><name>inner_cxt</name><operator>.</operator><name>state</name></name> <operator>!=</operator> <name>FDW_COLLATE_SAFE</name> <operator>||</operator>
						 <name><name>oe</name><operator>-&gt;</operator><name>inputcollid</name></name> <operator>!=</operator> <name><name>inner_cxt</name><operator>.</operator><name>collation</name></name></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

				<comment type="block">/* Output is always boolean and so noncollatable. */</comment>
				<expr_stmt><expr><name>collation</name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>state</name> <operator>=</operator> <name>FDW_COLLATE_NONE</name></expr>;</expr_stmt>
			</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>T_RelabelType</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>RelabelType</name> <modifier>*</modifier></type><name>r</name> <init>= <expr><operator>(</operator><name>RelabelType</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

				<comment type="block">/*
				 * Recurse to input subexpression.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>foreign_expr_walker</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>r</name><operator>-&gt;</operator><name>arg</name></name></expr></argument>,
										 <argument><expr><name>glob_cxt</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>inner_cxt</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

				<comment type="block">/*
				 * RelabelType must not introduce a collation not derived from
				 * an input foreign Var (same logic as for a real function).
				 */</comment>
				<expr_stmt><expr><name>collation</name> <operator>=</operator> <name><name>r</name><operator>-&gt;</operator><name>resultcollid</name></name></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name>collation</name> <operator>==</operator> <name>InvalidOid</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>state</name> <operator>=</operator> <name>FDW_COLLATE_NONE</name></expr>;</expr_stmt></block_content></block></if>
				<if type="elseif">else if <condition>(<expr><name><name>inner_cxt</name><operator>.</operator><name>state</name></name> <operator>==</operator> <name>FDW_COLLATE_SAFE</name> <operator>&amp;&amp;</operator>
						 <name>collation</name> <operator>==</operator> <name><name>inner_cxt</name><operator>.</operator><name>collation</name></name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>state</name> <operator>=</operator> <name>FDW_COLLATE_SAFE</name></expr>;</expr_stmt></block_content></block></if>
				<if type="elseif">else if <condition>(<expr><name>collation</name> <operator>==</operator> <name>DEFAULT_COLLATION_OID</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>state</name> <operator>=</operator> <name>FDW_COLLATE_NONE</name></expr>;</expr_stmt></block_content></block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><name>state</name> <operator>=</operator> <name>FDW_COLLATE_UNSAFE</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
			</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>T_BoolExpr</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>BoolExpr</name>   <modifier>*</modifier></type><name>b</name> <init>= <expr><operator>(</operator><name>BoolExpr</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

				<comment type="block">/*
				 * Recurse to input subexpressions.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>foreign_expr_walker</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>b</name><operator>-&gt;</operator><name>args</name></name></expr></argument>,
										 <argument><expr><name>glob_cxt</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>inner_cxt</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

				<comment type="block">/* Output is always boolean and so noncollatable. */</comment>
				<expr_stmt><expr><name>collation</name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>state</name> <operator>=</operator> <name>FDW_COLLATE_NONE</name></expr>;</expr_stmt>
			</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>T_NullTest</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>NullTest</name>   <modifier>*</modifier></type><name>nt</name> <init>= <expr><operator>(</operator><name>NullTest</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

				<comment type="block">/*
				 * Recurse to input subexpressions.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>foreign_expr_walker</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>nt</name><operator>-&gt;</operator><name>arg</name></name></expr></argument>,
										 <argument><expr><name>glob_cxt</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>inner_cxt</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

				<comment type="block">/* Output is always boolean and so noncollatable. */</comment>
				<expr_stmt><expr><name>collation</name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>state</name> <operator>=</operator> <name>FDW_COLLATE_NONE</name></expr>;</expr_stmt>
			</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>T_ArrayExpr</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>ArrayExpr</name>  <modifier>*</modifier></type><name>a</name> <init>= <expr><operator>(</operator><name>ArrayExpr</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

				<comment type="block">/*
				 * Recurse to input subexpressions.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>foreign_expr_walker</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>a</name><operator>-&gt;</operator><name>elements</name></name></expr></argument>,
										 <argument><expr><name>glob_cxt</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>inner_cxt</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

				<comment type="block">/*
				 * ArrayExpr must not introduce a collation not derived from
				 * an input foreign Var (same logic as for a function).
				 */</comment>
				<expr_stmt><expr><name>collation</name> <operator>=</operator> <name><name>a</name><operator>-&gt;</operator><name>array_collid</name></name></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name>collation</name> <operator>==</operator> <name>InvalidOid</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>state</name> <operator>=</operator> <name>FDW_COLLATE_NONE</name></expr>;</expr_stmt></block_content></block></if>
				<if type="elseif">else if <condition>(<expr><name><name>inner_cxt</name><operator>.</operator><name>state</name></name> <operator>==</operator> <name>FDW_COLLATE_SAFE</name> <operator>&amp;&amp;</operator>
						 <name>collation</name> <operator>==</operator> <name><name>inner_cxt</name><operator>.</operator><name>collation</name></name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>state</name> <operator>=</operator> <name>FDW_COLLATE_SAFE</name></expr>;</expr_stmt></block_content></block></if>
				<if type="elseif">else if <condition>(<expr><name>collation</name> <operator>==</operator> <name>DEFAULT_COLLATION_OID</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>state</name> <operator>=</operator> <name>FDW_COLLATE_NONE</name></expr>;</expr_stmt></block_content></block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><name>state</name> <operator>=</operator> <name>FDW_COLLATE_UNSAFE</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
			</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>T_List</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>l</name> <init>= <expr><operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

				<comment type="block">/*
				 * Recurse to component subexpressions.
				 */</comment>
				<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>l</argument>)</argument_list></macro>
				<block>{<block_content>
					<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>foreign_expr_walker</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></argument>,
											 <argument><expr><name>glob_cxt</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>inner_cxt</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
						<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
				</block_content>}</block>

				<comment type="block">/*
				 * When processing a list, collation state just bubbles up
				 * from the list elements.
				 */</comment>
				<expr_stmt><expr><name>collation</name> <operator>=</operator> <name><name>inner_cxt</name><operator>.</operator><name>collation</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><name>state</name> <operator>=</operator> <name><name>inner_cxt</name><operator>.</operator><name>state</name></name></expr>;</expr_stmt>

				<comment type="block">/* Don't apply exprType() to the list. */</comment>
				<expr_stmt><expr><name>check_type</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>T_Aggref</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>Aggref</name>	   <modifier>*</modifier></type><name>agg</name> <init>= <expr><operator>(</operator><name>Aggref</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

				<comment type="block">/* Not safe to pushdown when not in grouping context */</comment>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IS_UPPER_REL</name><argument_list>(<argument><expr><name><name>glob_cxt</name><operator>-&gt;</operator><name>foreignrel</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

				<comment type="block">/* Only non-split aggregates are pushable. */</comment>
				<if_stmt><if>if <condition>(<expr><name><name>agg</name><operator>-&gt;</operator><name>aggsplit</name></name> <operator>!=</operator> <name>AGGSPLIT_SIMPLE</name></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

				<comment type="block">/* As usual, it must be shippable. */</comment>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>is_shippable</name><argument_list>(<argument><expr><name><name>agg</name><operator>-&gt;</operator><name>aggfnoid</name></name></expr></argument>, <argument><expr><name>ProcedureRelationId</name></expr></argument>, <argument><expr><name>fpinfo</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

				<comment type="block">/*
				 * Recurse to input args. aggdirectargs, aggorder and
				 * aggdistinct are all present in args, so no need to check
				 * their shippability explicitly.
				 */</comment>
				<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>agg-&gt;args</argument>)</argument_list></macro>
				<block>{<block_content>
					<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>n</name> <init>= <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

					<comment type="block">/* If TargetEntry, extract the expression from it */</comment>
					<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr><name>TargetEntry</name></expr></argument>)</argument_list></call></expr>)</condition>
					<block>{<block_content>
						<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>tle</name> <init>= <expr><operator>(</operator><name>TargetEntry</name> <operator>*</operator><operator>)</operator> <name>n</name></expr></init></decl>;</decl_stmt>

						<expr_stmt><expr><name>n</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>tle</name><operator>-&gt;</operator><name>expr</name></name></expr>;</expr_stmt>
					</block_content>}</block></if></if_stmt>

					<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>foreign_expr_walker</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr><name>glob_cxt</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>inner_cxt</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
						<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
				</block_content>}</block>

				<comment type="block">/*
				 * For aggorder elements, check whether the sort operator, if
				 * specified, is shippable or not.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><name><name>agg</name><operator>-&gt;</operator><name>aggorder</name></name></expr>)</condition>
				<block>{<block_content>
					<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

					<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>agg-&gt;aggorder</argument>)</argument_list></macro>
					<block>{<block_content>
						<decl_stmt><decl><type><name>SortGroupClause</name> <modifier>*</modifier></type><name>srt</name> <init>= <expr><operator>(</operator><name>SortGroupClause</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
						<decl_stmt><decl><type><name>Oid</name></type>			<name>sortcoltype</name></decl>;</decl_stmt>
						<decl_stmt><decl><type><name>TypeCacheEntry</name> <modifier>*</modifier></type><name>typentry</name></decl>;</decl_stmt>
						<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>tle</name></decl>;</decl_stmt>

						<expr_stmt><expr><name>tle</name> <operator>=</operator> <call><name>get_sortgroupref_tle</name><argument_list>(<argument><expr><name><name>srt</name><operator>-&gt;</operator><name>tleSortGroupRef</name></name></expr></argument>,
												   <argument><expr><name><name>agg</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><name>sortcoltype</name> <operator>=</operator> <call><name>exprType</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>tle</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><name>typentry</name> <operator>=</operator> <call><name>lookup_type_cache</name><argument_list>(<argument><expr><name>sortcoltype</name></expr></argument>,
													 <argument><expr><name>TYPECACHE_LT_OPR</name> <operator>|</operator> <name>TYPECACHE_GT_OPR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<comment type="block">/* Check shippability of non-default sort operator. */</comment>
						<if_stmt><if>if <condition>(<expr><name><name>srt</name><operator>-&gt;</operator><name>sortop</name></name> <operator>!=</operator> <name><name>typentry</name><operator>-&gt;</operator><name>lt_opr</name></name> <operator>&amp;&amp;</operator>
							<name><name>srt</name><operator>-&gt;</operator><name>sortop</name></name> <operator>!=</operator> <name><name>typentry</name><operator>-&gt;</operator><name>gt_opr</name></name> <operator>&amp;&amp;</operator>
							<operator>!</operator><call><name>is_shippable</name><argument_list>(<argument><expr><name><name>srt</name><operator>-&gt;</operator><name>sortop</name></name></expr></argument>, <argument><expr><name>OperatorRelationId</name></expr></argument>,
										  <argument><expr><name>fpinfo</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
							<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
					</block_content>}</block>
				</block_content>}</block></if></if_stmt>

				<comment type="block">/* Check aggregate filter */</comment>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>foreign_expr_walker</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>agg</name><operator>-&gt;</operator><name>aggfilter</name></name></expr></argument>,
										 <argument><expr><name>glob_cxt</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>inner_cxt</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

				<comment type="block">/*
				 * If aggregate's input collation is not derived from a
				 * foreign Var, it can't be sent to remote.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><name><name>agg</name><operator>-&gt;</operator><name>inputcollid</name></name> <operator>==</operator> <name>InvalidOid</name></expr>)</condition><block type="pseudo"><block_content>
					 <comment type="block">/* OK, inputs are all noncollatable */</comment> <empty_stmt>;</empty_stmt></block_content></block></if>
				<if type="elseif">else if <condition>(<expr><name><name>inner_cxt</name><operator>.</operator><name>state</name></name> <operator>!=</operator> <name>FDW_COLLATE_SAFE</name> <operator>||</operator>
						 <name><name>agg</name><operator>-&gt;</operator><name>inputcollid</name></name> <operator>!=</operator> <name><name>inner_cxt</name><operator>.</operator><name>collation</name></name></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

				<comment type="block">/*
				 * Detect whether node is introducing a collation not derived
				 * from a foreign Var.  (If so, we just mark it unsafe for now
				 * rather than immediately returning false, since the parent
				 * node might not care.)
				 */</comment>
				<expr_stmt><expr><name>collation</name> <operator>=</operator> <name><name>agg</name><operator>-&gt;</operator><name>aggcollid</name></name></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name>collation</name> <operator>==</operator> <name>InvalidOid</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>state</name> <operator>=</operator> <name>FDW_COLLATE_NONE</name></expr>;</expr_stmt></block_content></block></if>
				<if type="elseif">else if <condition>(<expr><name><name>inner_cxt</name><operator>.</operator><name>state</name></name> <operator>==</operator> <name>FDW_COLLATE_SAFE</name> <operator>&amp;&amp;</operator>
						 <name>collation</name> <operator>==</operator> <name><name>inner_cxt</name><operator>.</operator><name>collation</name></name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>state</name> <operator>=</operator> <name>FDW_COLLATE_SAFE</name></expr>;</expr_stmt></block_content></block></if>
				<if type="elseif">else if <condition>(<expr><name>collation</name> <operator>==</operator> <name>DEFAULT_COLLATION_OID</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>state</name> <operator>=</operator> <name>FDW_COLLATE_NONE</name></expr>;</expr_stmt></block_content></block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><name>state</name> <operator>=</operator> <name>FDW_COLLATE_UNSAFE</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
			</block_content>}</block>
			<break>break;</break>
		<default>default:</default>

			<comment type="block">/*
			 * If it's anything else, assume it's unsafe.  This list can be
			 * expanded later, but don't forget to add deparse support below.
			 */</comment>
			<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></switch>

	<comment type="block">/*
	 * If result type of given expression is not shippable, it can't be sent
	 * to remote because it might have incompatible semantics on remote side.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>check_type</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>is_shippable</name><argument_list>(<argument><expr><call><name>exprType</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>TypeRelationId</name></expr></argument>, <argument><expr><name>fpinfo</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Now, merge my collation information into my parent's state.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>state</name> <operator>&gt;</operator> <name><name>outer_cxt</name><operator>-&gt;</operator><name>state</name></name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Override previous parent state */</comment>
		<expr_stmt><expr><name><name>outer_cxt</name><operator>-&gt;</operator><name>collation</name></name> <operator>=</operator> <name>collation</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>outer_cxt</name><operator>-&gt;</operator><name>state</name></name> <operator>=</operator> <name>state</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>state</name> <operator>==</operator> <name><name>outer_cxt</name><operator>-&gt;</operator><name>state</name></name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Merge, or detect error if there's a collation conflict */</comment>
		<switch>switch <condition>(<expr><name>state</name></expr>)</condition>
		<block>{<block_content>
			<case>case <expr><name>FDW_COLLATE_NONE</name></expr>:</case>
				<comment type="block">/* Nothing + nothing is still nothing */</comment>
				<break>break;</break>
			<case>case <expr><name>FDW_COLLATE_SAFE</name></expr>:</case>
				<if_stmt><if>if <condition>(<expr><name>collation</name> <operator>!=</operator> <name><name>outer_cxt</name><operator>-&gt;</operator><name>collation</name></name></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/*
					 * Non-default collation always beats default.
					 */</comment>
					<if_stmt><if>if <condition>(<expr><name><name>outer_cxt</name><operator>-&gt;</operator><name>collation</name></name> <operator>==</operator> <name>DEFAULT_COLLATION_OID</name></expr>)</condition>
					<block>{<block_content>
						<comment type="block">/* Override previous parent state */</comment>
						<expr_stmt><expr><name><name>outer_cxt</name><operator>-&gt;</operator><name>collation</name></name> <operator>=</operator> <name>collation</name></expr>;</expr_stmt>
					</block_content>}</block></if>
					<if type="elseif">else if <condition>(<expr><name>collation</name> <operator>!=</operator> <name>DEFAULT_COLLATION_OID</name></expr>)</condition>
					<block>{<block_content>
						<comment type="block">/*
						 * Conflict; show state as indeterminate.  We don't
						 * want to "return false" right away, since parent
						 * node might not care about collation.
						 */</comment>
						<expr_stmt><expr><name><name>outer_cxt</name><operator>-&gt;</operator><name>state</name></name> <operator>=</operator> <name>FDW_COLLATE_UNSAFE</name></expr>;</expr_stmt>
					</block_content>}</block></if></if_stmt>
				</block_content>}</block></if></if_stmt>
				<break>break;</break>
			<case>case <expr><name>FDW_COLLATE_UNSAFE</name></expr>:</case>
				<comment type="block">/* We're still conflicted ... */</comment>
				<break>break;</break>
		</block_content>}</block></switch>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* It looks OK */</comment>
	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Returns true if given expr is something we'd have to send the value of
 * to the foreign server.
 *
 * This should return true when the expression is a shippable node that
 * deparseExpr would add to context-&gt;params_list.  Note that we don't care
 * if the expression *contains* such a node, only whether one appears at top
 * level.  We need this to detect cases where setrefs.c would recognize a
 * false match between an fdw_exprs item (which came from the params_list)
 * and an entry in fdw_scan_tlist (which we're considering putting the given
 * expression into).
 */</comment>
<function><type><name>bool</name></type>
<name>is_foreign_param</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
				 <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>baserel</name></decl></parameter>,
				 <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>expr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>expr</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<switch>switch <condition>(<expr><call><name>nodeTag</name><argument_list>(<argument><expr><name>expr</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>T_Var</name></expr>:</case>
			<block>{<block_content>
				<comment type="block">/* It would have to be sent unless it's a foreign Var */</comment>
				<decl_stmt><decl><type><name>Var</name>		   <modifier>*</modifier></type><name>var</name> <init>= <expr><operator>(</operator><name>Var</name> <operator>*</operator><operator>)</operator> <name>expr</name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>PgFdwRelationInfo</name> <modifier>*</modifier></type><name>fpinfo</name> <init>= <expr><operator>(</operator><name>PgFdwRelationInfo</name> <operator>*</operator><operator>)</operator> <operator>(</operator><name><name>baserel</name><operator>-&gt;</operator><name>fdw_private</name></name><operator>)</operator></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>Relids</name></type>		<name>relids</name></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><call><name>IS_UPPER_REL</name><argument_list>(<argument><expr><name>baserel</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>relids</name> <operator>=</operator> <name><name>fpinfo</name><operator>-&gt;</operator><name>outerrel</name><operator>-&gt;</operator><name>relids</name></name></expr>;</expr_stmt></block_content></block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><name>relids</name> <operator>=</operator> <name><name>baserel</name><operator>-&gt;</operator><name>relids</name></name></expr>;</expr_stmt></block_content></block></else></if_stmt>

				<if_stmt><if>if <condition>(<expr><call><name>bms_is_member</name><argument_list>(<argument><expr><name><name>var</name><operator>-&gt;</operator><name>varno</name></name></expr></argument>, <argument><expr><name>relids</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name><name>var</name><operator>-&gt;</operator><name>varlevelsup</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>false</name></expr>;</return></block_content></block></if>	<comment type="block">/* foreign Var, so not a param */</comment>
				<else>else<block type="pseudo"><block_content>
					<return>return <expr><name>true</name></expr>;</return></block_content></block></else></if_stmt>	<comment type="block">/* it'd have to be a param */</comment>
				<break>break;</break>
			</block_content>}</block>
		<case>case <expr><name>T_Param</name></expr>:</case>
			<comment type="block">/* Params always have to be sent to the foreign server */</comment>
			<return>return <expr><name>true</name></expr>;</return>
		<default>default:</default>
			<break>break;</break>
	</block_content>}</block></switch>
	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Convert type OID + typmod info into a type name we can ship to the remote
 * server.  Someplace else had better have verified that this type name is
 * expected to be known on the remote end.
 *
 * This is almost just format_type_with_typemod(), except that if left to its
 * own devices, that function will make schema-qualification decisions based
 * on the local search_path, which is wrong.  We must schema-qualify all
 * type names that are not in pg_catalog.  We assume here that built-in types
 * are all in pg_catalog and need not be qualified; otherwise, qualify.
 */</comment>
<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type>
<name>deparse_type_name</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>type_oid</name></decl></parameter>, <parameter><decl><type><name>int32</name></type> <name>typemod</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bits16</name></type>		<name>flags</name> <init>= <expr><name>FORMAT_TYPE_TYPEMOD_GIVEN</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>is_builtin</name><argument_list>(<argument><expr><name>type_oid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>flags</name> <operator>|=</operator> <name>FORMAT_TYPE_FORCE_QUALIFY</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><call><name>format_type_extended</name><argument_list>(<argument><expr><name>type_oid</name></expr></argument>, <argument><expr><name>typemod</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Build the targetlist for given relation to be deparsed as SELECT clause.
 *
 * The output targetlist contains the columns that need to be fetched from the
 * foreign server for the given relation.  If foreignrel is an upper relation,
 * then the output targetlist can also contain expressions to be evaluated on
 * foreign server.
 */</comment>
<function><type><name>List</name> <modifier>*</modifier></type>
<name>build_tlist_to_deparse</name><parameter_list>(<parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>foreignrel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>tlist</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PgFdwRelationInfo</name> <modifier>*</modifier></type><name>fpinfo</name> <init>= <expr><operator>(</operator><name>PgFdwRelationInfo</name> <operator>*</operator><operator>)</operator> <name><name>foreignrel</name><operator>-&gt;</operator><name>fdw_private</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * For an upper relation, we have already built the target list while
	 * checking shippability, so just return that.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>IS_UPPER_REL</name><argument_list>(<argument><expr><name>foreignrel</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name><name>fpinfo</name><operator>-&gt;</operator><name>grouped_tlist</name></name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * We require columns specified in foreignrel-&gt;reltarget-&gt;exprs and those
	 * required for evaluating the local conditions.
	 */</comment>
	<expr_stmt><expr><name>tlist</name> <operator>=</operator> <call><name>add_to_flat_tlist</name><argument_list>(<argument><expr><name>tlist</name></expr></argument>,
							  <argument><expr><call><name>pull_var_clause</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>foreignrel</name><operator>-&gt;</operator><name>reltarget</name><operator>-&gt;</operator><name>exprs</name></name></expr></argument>,
											  <argument><expr><name>PVC_RECURSE_PLACEHOLDERS</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>fpinfo-&gt;local_conds</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>RestrictInfo</name> <modifier>*</modifier></type><name>rinfo</name> <init>= <expr><call><name>lfirst_node</name><argument_list>(<argument><expr><name>RestrictInfo</name></expr></argument>, <argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>tlist</name> <operator>=</operator> <call><name>add_to_flat_tlist</name><argument_list>(<argument><expr><name>tlist</name></expr></argument>,
								  <argument><expr><call><name>pull_var_clause</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>rinfo</name><operator>-&gt;</operator><name>clause</name></name></expr></argument>,
												  <argument><expr><name>PVC_RECURSE_PLACEHOLDERS</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<return>return <expr><name>tlist</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Deparse SELECT statement for given relation into buf.
 *
 * tlist contains the list of desired columns to be fetched from foreign server.
 * For a base relation fpinfo-&gt;attrs_used is used to construct SELECT clause,
 * hence the tlist is ignored for a base relation.
 *
 * remote_conds is the list of conditions to be deparsed into the WHERE clause
 * (or, in the case of upper relations, into the HAVING clause).
 *
 * If params_list is not NULL, it receives a list of Params and other-relation
 * Vars used in the clauses; these values must be transmitted to the remote
 * server as parameter values.
 *
 * If params_list is NULL, we're generating the query for EXPLAIN purposes,
 * so Params and other-relation Vars should be replaced by dummy values.
 *
 * pathkeys is the list of pathkeys to order the result by.
 *
 * is_subquery is the flag to indicate whether to deparse the specified
 * relation as a subquery.
 *
 * List of columns selected is returned in retrieved_attrs.
 */</comment>
<function><type><name>void</name></type>
<name>deparseSelectStmtForRel</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>buf</name></decl></parameter>, <parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>rel</name></decl></parameter>,
						<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>tlist</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>remote_conds</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>pathkeys</name></decl></parameter>,
						<parameter><decl><type><name>bool</name></type> <name>is_subquery</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>retrieved_attrs</name></decl></parameter>,
						<parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>params_list</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>deparse_expr_cxt</name></type> <name>context</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PgFdwRelationInfo</name> <modifier>*</modifier></type><name>fpinfo</name> <init>= <expr><operator>(</operator><name>PgFdwRelationInfo</name> <operator>*</operator><operator>)</operator> <name><name>rel</name><operator>-&gt;</operator><name>fdw_private</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>quals</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * We handle relations for foreign tables, joins between those and upper
	 * relations.
	 */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>IS_JOIN_REL</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>IS_SIMPLE_REL</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>IS_UPPER_REL</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Fill portions of context common to upper, join and base relation */</comment>
	<expr_stmt><expr><name><name>context</name><operator>.</operator><name>buf</name></name> <operator>=</operator> <name>buf</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>context</name><operator>.</operator><name>root</name></name> <operator>=</operator> <name>root</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>context</name><operator>.</operator><name>foreignrel</name></name> <operator>=</operator> <name>rel</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>context</name><operator>.</operator><name>scanrel</name></name> <operator>=</operator> <ternary><condition><expr><call><name>IS_UPPER_REL</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><name><name>fpinfo</name><operator>-&gt;</operator><name>outerrel</name></name></expr> </then><else>: <expr><name>rel</name></expr></else></ternary></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>context</name><operator>.</operator><name>params_list</name></name> <operator>=</operator> <name>params_list</name></expr>;</expr_stmt>

	<comment type="block">/* Construct SELECT clause */</comment>
	<expr_stmt><expr><call><name>deparseSelectSql</name><argument_list>(<argument><expr><name>tlist</name></expr></argument>, <argument><expr><name>is_subquery</name></expr></argument>, <argument><expr><name>retrieved_attrs</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * For upper relations, the WHERE clause is built from the remote
	 * conditions of the underlying scan relation; otherwise, we can use the
	 * supplied list of remote conditions directly.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>IS_UPPER_REL</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>PgFdwRelationInfo</name> <modifier>*</modifier></type><name>ofpinfo</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>ofpinfo</name> <operator>=</operator> <operator>(</operator><name>PgFdwRelationInfo</name> <operator>*</operator><operator>)</operator> <name><name>fpinfo</name><operator>-&gt;</operator><name>outerrel</name><operator>-&gt;</operator><name>fdw_private</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>quals</name> <operator>=</operator> <name><name>ofpinfo</name><operator>-&gt;</operator><name>remote_conds</name></name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>quals</name> <operator>=</operator> <name>remote_conds</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/* Construct FROM and WHERE clauses */</comment>
	<expr_stmt><expr><call><name>deparseFromExpr</name><argument_list>(<argument><expr><name>quals</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>IS_UPPER_REL</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Append GROUP BY clause */</comment>
		<expr_stmt><expr><call><name>appendGroupByClause</name><argument_list>(<argument><expr><name>tlist</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Append HAVING clause */</comment>
		<if_stmt><if>if <condition>(<expr><name>remote_conds</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">" HAVING "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>appendConditions</name><argument_list>(<argument><expr><name>remote_conds</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Add ORDER BY clause if we found any useful pathkeys */</comment>
	<if_stmt><if>if <condition>(<expr><name>pathkeys</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendOrderByClause</name><argument_list>(<argument><expr><name>pathkeys</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Add any necessary FOR UPDATE/SHARE. */</comment>
	<expr_stmt><expr><call><name>deparseLockingClause</name><argument_list>(<argument><expr><operator>&amp;</operator><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Construct a simple SELECT statement that retrieves desired columns
 * of the specified foreign table, and append it to "buf".  The output
 * contains just "SELECT ... ".
 *
 * We also create an integer List of the columns being retrieved, which is
 * returned to *retrieved_attrs, unless we deparse the specified relation
 * as a subquery.
 *
 * tlist is the list of desired columns.  is_subquery is the flag to
 * indicate whether to deparse the specified relation as a subquery.
 * Read prologue of deparseSelectStmtForRel() for details.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>deparseSelectSql</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>tlist</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>is_subquery</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>retrieved_attrs</name></decl></parameter>,
				 <parameter><decl><type><name>deparse_expr_cxt</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>StringInfo</name></type>	<name>buf</name> <init>= <expr><name><name>context</name><operator>-&gt;</operator><name>buf</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>foreignrel</name> <init>= <expr><name><name>context</name><operator>-&gt;</operator><name>foreignrel</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name> <init>= <expr><name><name>context</name><operator>-&gt;</operator><name>root</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PgFdwRelationInfo</name> <modifier>*</modifier></type><name>fpinfo</name> <init>= <expr><operator>(</operator><name>PgFdwRelationInfo</name> <operator>*</operator><operator>)</operator> <name><name>foreignrel</name><operator>-&gt;</operator><name>fdw_private</name></name></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * Construct SELECT list
	 */</comment>
	<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"SELECT "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>is_subquery</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * For a relation that is deparsed as a subquery, emit expressions
		 * specified in the relation's reltarget.  Note that since this is for
		 * the subquery, no need to care about *retrieved_attrs.
		 */</comment>
		<expr_stmt><expr><call><name>deparseSubqueryTargetList</name><argument_list>(<argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>IS_JOIN_REL</name><argument_list>(<argument><expr><name>foreignrel</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>IS_UPPER_REL</name><argument_list>(<argument><expr><name>foreignrel</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * For a join or upper relation the input tlist gives the list of
		 * columns required to be fetched from the foreign server.
		 */</comment>
		<expr_stmt><expr><call><name>deparseExplicitTargetList</name><argument_list>(<argument><expr><name>tlist</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>retrieved_attrs</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/*
		 * For a base relation fpinfo-&gt;attrs_used gives the list of columns
		 * required to be fetched from the foreign server.
		 */</comment>
		<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name> <init>= <expr><call><name>planner_rt_fetch</name><argument_list>(<argument><expr><name><name>foreignrel</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>, <argument><expr><name>root</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/*
		 * Core code already has some lock on each rel being planned, so we
		 * can use NoLock here.
		 */</comment>
		<decl_stmt><decl><type><name>Relation</name></type>	<name>rel</name> <init>= <expr><call><name>heap_open</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>deparseTargetList</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>rte</name></expr></argument>, <argument><expr><name><name>foreignrel</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
						  <argument><expr><name><name>fpinfo</name><operator>-&gt;</operator><name>attrs_used</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>retrieved_attrs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Construct a FROM clause and, if needed, a WHERE clause, and append those to
 * "buf".
 *
 * quals is the list of clauses to be included in the WHERE clause.
 * (These may or may not include RestrictInfo decoration.)
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>deparseFromExpr</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>quals</name></decl></parameter>, <parameter><decl><type><name>deparse_expr_cxt</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>StringInfo</name></type>	<name>buf</name> <init>= <expr><name><name>context</name><operator>-&gt;</operator><name>buf</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>scanrel</name> <init>= <expr><name><name>context</name><operator>-&gt;</operator><name>scanrel</name></name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* For upper relations, scanrel must be either a joinrel or a baserel */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>IS_UPPER_REL</name><argument_list>(<argument><expr><name><name>context</name><operator>-&gt;</operator><name>foreignrel</name></name></expr></argument>)</argument_list></call> <operator>||</operator>
		   <call><name>IS_JOIN_REL</name><argument_list>(<argument><expr><name>scanrel</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>IS_SIMPLE_REL</name><argument_list>(<argument><expr><name>scanrel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Construct FROM clause */</comment>
	<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">" FROM "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>deparseFromExprForRel</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name><name>context</name><operator>-&gt;</operator><name>root</name></name></expr></argument>, <argument><expr><name>scanrel</name></expr></argument>,
						  <argument><expr><operator>(</operator><call><name>bms_num_members</name><argument_list>(<argument><expr><name><name>scanrel</name><operator>-&gt;</operator><name>relids</name></name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">1</literal><operator>)</operator></expr></argument>,
						  <argument><expr><operator>(</operator><name>Index</name><operator>)</operator> <literal type="number">0</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name><name>context</name><operator>-&gt;</operator><name>params_list</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Construct WHERE clause */</comment>
	<if_stmt><if>if <condition>(<expr><name>quals</name> <operator>!=</operator> <name>NIL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">" WHERE "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>appendConditions</name><argument_list>(<argument><expr><name>quals</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Emit a target list that retrieves the columns specified in attrs_used.
 * This is used for both SELECT and RETURNING targetlists; the is_returning
 * parameter is true only for a RETURNING targetlist.
 *
 * The tlist text is appended to buf, and we also create an integer List
 * of the columns being retrieved, which is returned to *retrieved_attrs.
 *
 * If qualify_col is true, add relation alias before the column name.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>deparseTargetList</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>buf</name></decl></parameter>,
				  <parameter><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name></decl></parameter>,
				  <parameter><decl><type><name>Index</name></type> <name>rtindex</name></decl></parameter>,
				  <parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>,
				  <parameter><decl><type><name>bool</name></type> <name>is_returning</name></decl></parameter>,
				  <parameter><decl><type><name>Bitmapset</name> <modifier>*</modifier></type><name>attrs_used</name></decl></parameter>,
				  <parameter><decl><type><name>bool</name></type> <name>qualify_col</name></decl></parameter>,
				  <parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>retrieved_attrs</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TupleDesc</name></type>	<name>tupdesc</name> <init>= <expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>have_wholerow</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>first</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<expr_stmt><expr><operator>*</operator><name>retrieved_attrs</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>

	<comment type="block">/* If there's a whole-row reference, we'll need all the columns. */</comment>
	<expr_stmt><expr><name>have_wholerow</name> <operator>=</operator> <call><name>bms_is_member</name><argument_list>(<argument><expr><literal type="number">0</literal> <operator>-</operator> <name>FirstLowInvalidHeapAttributeNumber</name></expr></argument>,
								  <argument><expr><name>attrs_used</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>first</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;=</operator> <name><name>tupdesc</name><operator>-&gt;</operator><name>natts</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>attr</name> <init>= <expr><call><name>TupleDescAttr</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><name>i</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/* Ignore dropped attributes. */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>attr</name><operator>-&gt;</operator><name>attisdropped</name></name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>have_wholerow</name> <operator>||</operator>
			<call><name>bms_is_member</name><argument_list>(<argument><expr><name>i</name> <operator>-</operator> <name>FirstLowInvalidHeapAttributeNumber</name></expr></argument>,
						  <argument><expr><name>attrs_used</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>first</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">", "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<if type="elseif">else if <condition>(<expr><name>is_returning</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">" RETURNING "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><name>first</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>deparseColumnRef</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>rtindex</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>rte</name></expr></argument>, <argument><expr><name>qualify_col</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><operator>*</operator><name>retrieved_attrs</name> <operator>=</operator> <call><name>lappend_int</name><argument_list>(<argument><expr><operator>*</operator><name>retrieved_attrs</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>

	<comment type="block">/*
	 * Add ctid and oid if needed.  We currently don't support retrieving any
	 * other system columns.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>bms_is_member</name><argument_list>(<argument><expr><name>SelfItemPointerAttributeNumber</name> <operator>-</operator> <name>FirstLowInvalidHeapAttributeNumber</name></expr></argument>,
					  <argument><expr><name>attrs_used</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>first</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">", "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><name>is_returning</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">" RETURNING "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>first</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>qualify_col</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ADD_REL_QUALIFIER</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>rtindex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"ctid"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><operator>*</operator><name>retrieved_attrs</name> <operator>=</operator> <call><name>lappend_int</name><argument_list>(<argument><expr><operator>*</operator><name>retrieved_attrs</name></expr></argument>,
									   <argument><expr><name>SelfItemPointerAttributeNumber</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>bms_is_member</name><argument_list>(<argument><expr><name>ObjectIdAttributeNumber</name> <operator>-</operator> <name>FirstLowInvalidHeapAttributeNumber</name></expr></argument>,
					  <argument><expr><name>attrs_used</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>first</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">", "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><name>is_returning</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">" RETURNING "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>first</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>qualify_col</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ADD_REL_QUALIFIER</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>rtindex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"oid"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><operator>*</operator><name>retrieved_attrs</name> <operator>=</operator> <call><name>lappend_int</name><argument_list>(<argument><expr><operator>*</operator><name>retrieved_attrs</name></expr></argument>,
									   <argument><expr><name>ObjectIdAttributeNumber</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Don't generate bad syntax if no undropped columns */</comment>
	<if_stmt><if>if <condition>(<expr><name>first</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>is_returning</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"NULL"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Deparse the appropriate locking clause (FOR UPDATE or FOR SHARE) for a
 * given relation (context-&gt;scanrel).
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>deparseLockingClause</name><parameter_list>(<parameter><decl><type><name>deparse_expr_cxt</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>StringInfo</name></type>	<name>buf</name> <init>= <expr><name><name>context</name><operator>-&gt;</operator><name>buf</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name> <init>= <expr><name><name>context</name><operator>-&gt;</operator><name>root</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>rel</name> <init>= <expr><name><name>context</name><operator>-&gt;</operator><name>scanrel</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PgFdwRelationInfo</name> <modifier>*</modifier></type><name>fpinfo</name> <init>= <expr><operator>(</operator><name>PgFdwRelationInfo</name> <operator>*</operator><operator>)</operator> <name><name>rel</name><operator>-&gt;</operator><name>fdw_private</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>relid</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

	<while>while <condition>(<expr><operator>(</operator><name>relid</name> <operator>=</operator> <call><name>bms_next_member</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>relids</name></name></expr></argument>, <argument><expr><name>relid</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Ignore relation if it appears in a lower subquery.  Locking clause
		 * for such a relation is included in the subquery if necessary.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>bms_is_member</name><argument_list>(<argument><expr><name>relid</name></expr></argument>, <argument><expr><name><name>fpinfo</name><operator>-&gt;</operator><name>lower_subquery_rels</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * Add FOR UPDATE/SHARE if appropriate.  We apply locking during the
		 * initial row fetch, rather than later on as is done for local
		 * tables. The extra roundtrips involved in trying to duplicate the
		 * local semantics exactly don't seem worthwhile (see also comments
		 * for RowMarkType).
		 *
		 * Note: because we actually run the query as a cursor, this assumes
		 * that DECLARE CURSOR ... FOR UPDATE is supported, which it isn't
		 * before 8.3.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>relid</name> <operator>==</operator> <name><name>root</name><operator>-&gt;</operator><name>parse</name><operator>-&gt;</operator><name>resultRelation</name></name> <operator>&amp;&amp;</operator>
			<operator>(</operator><name><name>root</name><operator>-&gt;</operator><name>parse</name><operator>-&gt;</operator><name>commandType</name></name> <operator>==</operator> <name>CMD_UPDATE</name> <operator>||</operator>
			 <name><name>root</name><operator>-&gt;</operator><name>parse</name><operator>-&gt;</operator><name>commandType</name></name> <operator>==</operator> <name>CMD_DELETE</name><operator>)</operator></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Relation is UPDATE/DELETE target, so use FOR UPDATE */</comment>
			<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">" FOR UPDATE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* Add the relation alias if we are here for a join relation */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>IS_JOIN_REL</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">" OF %s%d"</literal></expr></argument>, <argument><expr><name>REL_ALIAS_PREFIX</name></expr></argument>, <argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<decl_stmt><decl><type><name>PlanRowMark</name> <modifier>*</modifier></type><name>rc</name> <init>= <expr><call><name>get_plan_rowmark</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>rowMarks</name></name></expr></argument>, <argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name>rc</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/*
				 * Relation is specified as a FOR UPDATE/SHARE target, so
				 * handle that.  (But we could also see LCS_NONE, meaning this
				 * isn't a target relation after all.)
				 *
				 * For now, just ignore any [NO] KEY specification, since (a)
				 * it's not clear what that means for a remote table that we
				 * don't have complete information about, and (b) it wouldn't
				 * work anyway on older remote servers.  Likewise, we don't
				 * worry about NOWAIT.
				 */</comment>
				<switch>switch <condition>(<expr><name><name>rc</name><operator>-&gt;</operator><name>strength</name></name></expr>)</condition>
				<block>{<block_content>
					<case>case <expr><name>LCS_NONE</name></expr>:</case>
						<comment type="block">/* No locking needed */</comment>
						<break>break;</break>
					<case>case <expr><name>LCS_FORKEYSHARE</name></expr>:</case>
					<case>case <expr><name>LCS_FORSHARE</name></expr>:</case>
						<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">" FOR SHARE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<break>break;</break>
					<case>case <expr><name>LCS_FORNOKEYUPDATE</name></expr>:</case>
					<case>case <expr><name>LCS_FORUPDATE</name></expr>:</case>
						<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">" FOR UPDATE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<break>break;</break>
				</block_content>}</block></switch>

				<comment type="block">/* Add the relation alias if we are here for a join relation */</comment>
				<if_stmt><if>if <condition>(<expr><call><name>bms_num_members</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>relids</name></name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator>
					<name><name>rc</name><operator>-&gt;</operator><name>strength</name></name> <operator>!=</operator> <name>LCS_NONE</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">" OF %s%d"</literal></expr></argument>, <argument><expr><name>REL_ALIAS_PREFIX</name></expr></argument>, <argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></while>
</block_content>}</block></function>

<comment type="block">/*
 * Deparse conditions from the provided list and append them to buf.
 *
 * The conditions in the list are assumed to be ANDed. This function is used to
 * deparse WHERE clauses, JOIN .. ON clauses and HAVING clauses.
 *
 * Depending on the caller, the list elements might be either RestrictInfos
 * or bare clauses.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>appendConditions</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>exprs</name></decl></parameter>, <parameter><decl><type><name>deparse_expr_cxt</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>nestlevel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>is_first</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>StringInfo</name></type>	<name>buf</name> <init>= <expr><name><name>context</name><operator>-&gt;</operator><name>buf</name></name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* Make sure any constants in the exprs are printed portably */</comment>
	<expr_stmt><expr><name>nestlevel</name> <operator>=</operator> <call><name>set_transmission_modes</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>exprs</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Expr</name>	   <modifier>*</modifier></type><name>expr</name> <init>= <expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/* Extract clause from RestrictInfo, if required */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>expr</name></expr></argument>, <argument><expr><name>RestrictInfo</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>expr</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>RestrictInfo</name> <operator>*</operator><operator>)</operator> <name>expr</name><operator>)</operator><operator>-&gt;</operator><name>clause</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/* Connect expressions with "AND" and parenthesize each condition. */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>is_first</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">" AND "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="char">'('</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>deparseExpr</name><argument_list>(<argument><expr><name>expr</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="char">')'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>is_first</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	</block_content>}</block>

	<expr_stmt><expr><call><name>reset_transmission_modes</name><argument_list>(<argument><expr><name>nestlevel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Output join name for given join type */</comment>
<function><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>
<name>get_jointype_name</name><parameter_list>(<parameter><decl><type><name>JoinType</name></type> <name>jointype</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<switch>switch <condition>(<expr><name>jointype</name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>JOIN_INNER</name></expr>:</case>
			<return>return <expr><literal type="string">"INNER"</literal></expr>;</return>

		<case>case <expr><name>JOIN_LEFT</name></expr>:</case>
			<return>return <expr><literal type="string">"LEFT"</literal></expr>;</return>

		<case>case <expr><name>JOIN_RIGHT</name></expr>:</case>
			<return>return <expr><literal type="string">"RIGHT"</literal></expr>;</return>

		<case>case <expr><name>JOIN_FULL</name></expr>:</case>
			<return>return <expr><literal type="string">"FULL"</literal></expr>;</return>

		<default>default:</default>
			<comment type="block">/* Shouldn't come here, but protect from buggy code. */</comment>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unsupported join type %d"</literal></expr></argument>, <argument><expr><name>jointype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></switch>

	<comment type="block">/* Keep compiler happy */</comment>
	<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Deparse given targetlist and append it to context-&gt;buf.
 *
 * tlist is list of TargetEntry's which in turn contain Var nodes.
 *
 * retrieved_attrs is the list of continuously increasing integers starting
 * from 1. It has same number of entries as tlist.
 *
 * This is used for both SELECT and RETURNING targetlists; the is_returning
 * parameter is true only for a RETURNING targetlist.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>deparseExplicitTargetList</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>tlist</name></decl></parameter>,
						  <parameter><decl><type><name>bool</name></type> <name>is_returning</name></decl></parameter>,
						  <parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>retrieved_attrs</name></decl></parameter>,
						  <parameter><decl><type><name>deparse_expr_cxt</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>StringInfo</name></type>	<name>buf</name> <init>= <expr><name><name>context</name><operator>-&gt;</operator><name>buf</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><operator>*</operator><name>retrieved_attrs</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>

	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>tlist</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>tle</name> <init>= <expr><call><name>lfirst_node</name><argument_list>(<argument><expr><name>TargetEntry</name></expr></argument>, <argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>i</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">", "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><name>is_returning</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">" RETURNING "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>deparseExpr</name><argument_list>(<argument><expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name><name>tle</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><operator>*</operator><name>retrieved_attrs</name> <operator>=</operator> <call><name>lappend_int</name><argument_list>(<argument><expr><operator>*</operator><name>retrieved_attrs</name></expr></argument>, <argument><expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block>

	<if_stmt><if>if <condition>(<expr><name>i</name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>!</operator><name>is_returning</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"NULL"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Emit expressions specified in the given relation's reltarget.
 *
 * This is used for deparsing the given relation as a subquery.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>deparseSubqueryTargetList</name><parameter_list>(<parameter><decl><type><name>deparse_expr_cxt</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>StringInfo</name></type>	<name>buf</name> <init>= <expr><name><name>context</name><operator>-&gt;</operator><name>buf</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>foreignrel</name> <init>= <expr><name><name>context</name><operator>-&gt;</operator><name>foreignrel</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>first</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

	<comment type="block">/* Should only be called in these cases. */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>IS_SIMPLE_REL</name><argument_list>(<argument><expr><name>foreignrel</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>IS_JOIN_REL</name><argument_list>(<argument><expr><name>foreignrel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>first</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>foreignrel-&gt;reltarget-&gt;exprs</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>node</name> <init>= <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>first</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">", "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>first</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>deparseExpr</name><argument_list>(<argument><expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<comment type="block">/* Don't generate bad syntax if no expressions */</comment>
	<if_stmt><if>if <condition>(<expr><name>first</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"NULL"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Construct FROM clause for given relation
 *
 * The function constructs ... JOIN ... ON ... for join relation. For a base
 * relation it just returns schema-qualified tablename, with the appropriate
 * alias if so requested.
 *
 * 'ignore_rel' is either zero or the RT index of a target relation.  In the
 * latter case the function constructs FROM clause of UPDATE or USING clause
 * of DELETE; it deparses the join relation as if the relation never contained
 * the target relation, and creates a List of conditions to be deparsed into
 * the top-level WHERE clause, which is returned to *ignore_conds.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>deparseFromExprForRel</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>buf</name></decl></parameter>, <parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>foreignrel</name></decl></parameter>,
					  <parameter><decl><type><name>bool</name></type> <name>use_alias</name></decl></parameter>, <parameter><decl><type><name>Index</name></type> <name>ignore_rel</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>ignore_conds</name></decl></parameter>,
					  <parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>params_list</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PgFdwRelationInfo</name> <modifier>*</modifier></type><name>fpinfo</name> <init>= <expr><operator>(</operator><name>PgFdwRelationInfo</name> <operator>*</operator><operator>)</operator> <name><name>foreignrel</name><operator>-&gt;</operator><name>fdw_private</name></name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>IS_JOIN_REL</name><argument_list>(<argument><expr><name>foreignrel</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>StringInfoData</name></type> <name>join_sql_o</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>StringInfoData</name></type> <name>join_sql_i</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>outerrel</name> <init>= <expr><name><name>fpinfo</name><operator>-&gt;</operator><name>outerrel</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>innerrel</name> <init>= <expr><name><name>fpinfo</name><operator>-&gt;</operator><name>innerrel</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>outerrel_is_target</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>innerrel_is_target</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>ignore_rel</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <call><name>bms_is_member</name><argument_list>(<argument><expr><name>ignore_rel</name></expr></argument>, <argument><expr><name><name>foreignrel</name><operator>-&gt;</operator><name>relids</name></name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * If this is an inner join, add joinclauses to *ignore_conds and
			 * set it to empty so that those can be deparsed into the WHERE
			 * clause.  Note that since the target relation can never be
			 * within the nullable side of an outer join, those could safely
			 * be pulled up into the WHERE clause (see foreign_join_ok()).
			 * Note also that since the target relation is only inner-joined
			 * to any other relation in the query, all conditions in the join
			 * tree mentioning the target relation could be deparsed into the
			 * WHERE clause by doing this recursively.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>fpinfo</name><operator>-&gt;</operator><name>jointype</name></name> <operator>==</operator> <name>JOIN_INNER</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><operator>*</operator><name>ignore_conds</name> <operator>=</operator> <call><name>list_concat</name><argument_list>(<argument><expr><operator>*</operator><name>ignore_conds</name></expr></argument>,
											<argument><expr><call><name>list_copy</name><argument_list>(<argument><expr><name><name>fpinfo</name><operator>-&gt;</operator><name>joinclauses</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>fpinfo</name><operator>-&gt;</operator><name>joinclauses</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/*
			 * Check if either of the input relations is the target relation.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>outerrel</name><operator>-&gt;</operator><name>relid</name></name> <operator>==</operator> <name>ignore_rel</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>outerrel_is_target</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if>
			<if type="elseif">else if <condition>(<expr><name><name>innerrel</name><operator>-&gt;</operator><name>relid</name></name> <operator>==</operator> <name>ignore_rel</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>innerrel_is_target</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* Deparse outer relation if not the target relation. */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>outerrel_is_target</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>initStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>join_sql_o</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>deparseRangeTblRef</name><argument_list>(<argument><expr><operator>&amp;</operator><name>join_sql_o</name></expr></argument>, <argument><expr><name>root</name></expr></argument>, <argument><expr><name>outerrel</name></expr></argument>,
							   <argument><expr><name><name>fpinfo</name><operator>-&gt;</operator><name>make_outerrel_subquery</name></name></expr></argument>,
							   <argument><expr><name>ignore_rel</name></expr></argument>, <argument><expr><name>ignore_conds</name></expr></argument>, <argument><expr><name>params_list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * If inner relation is the target relation, skip deparsing it.
			 * Note that since the join of the target relation with any other
			 * relation in the query is an inner join and can never be within
			 * the nullable side of an outer join, the join could be
			 * interchanged with higher-level joins (cf. identity 1 on outer
			 * join reordering shown in src/backend/optimizer/README), which
			 * means it's safe to skip the target-relation deparsing here.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name>innerrel_is_target</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>fpinfo</name><operator>-&gt;</operator><name>jointype</name></name> <operator>==</operator> <name>JOIN_INNER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>fpinfo</name><operator>-&gt;</operator><name>joinclauses</name></name> <operator>==</operator> <name>NIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name><name>join_sql_o</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return;</return>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* Deparse inner relation if not the target relation. */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>innerrel_is_target</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>initStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>join_sql_i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>deparseRangeTblRef</name><argument_list>(<argument><expr><operator>&amp;</operator><name>join_sql_i</name></expr></argument>, <argument><expr><name>root</name></expr></argument>, <argument><expr><name>innerrel</name></expr></argument>,
							   <argument><expr><name><name>fpinfo</name><operator>-&gt;</operator><name>make_innerrel_subquery</name></name></expr></argument>,
							   <argument><expr><name>ignore_rel</name></expr></argument>, <argument><expr><name>ignore_conds</name></expr></argument>, <argument><expr><name>params_list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * If outer relation is the target relation, skip deparsing it.
			 * See the above note about safety.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name>outerrel_is_target</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>fpinfo</name><operator>-&gt;</operator><name>jointype</name></name> <operator>==</operator> <name>JOIN_INNER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>fpinfo</name><operator>-&gt;</operator><name>joinclauses</name></name> <operator>==</operator> <name>NIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name><name>join_sql_i</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return;</return>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* Neither of the relations is the target relation. */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>outerrel_is_target</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>innerrel_is_target</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * For a join relation FROM clause entry is deparsed as
		 *
		 * ((outer relation) &lt;join type&gt; (inner relation) ON (joinclauses))
		 */</comment>
		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"(%s %s JOIN %s ON "</literal></expr></argument>, <argument><expr><name><name>join_sql_o</name><operator>.</operator><name>data</name></name></expr></argument>,
						 <argument><expr><call><name>get_jointype_name</name><argument_list>(<argument><expr><name><name>fpinfo</name><operator>-&gt;</operator><name>jointype</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>join_sql_i</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Append join clause; (TRUE) if no join clause */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>fpinfo</name><operator>-&gt;</operator><name>joinclauses</name></name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>deparse_expr_cxt</name></type> <name>context</name></decl>;</decl_stmt>

			<expr_stmt><expr><name><name>context</name><operator>.</operator><name>buf</name></name> <operator>=</operator> <name>buf</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>context</name><operator>.</operator><name>foreignrel</name></name> <operator>=</operator> <name>foreignrel</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>context</name><operator>.</operator><name>scanrel</name></name> <operator>=</operator> <name>foreignrel</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>context</name><operator>.</operator><name>root</name></name> <operator>=</operator> <name>root</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>context</name><operator>.</operator><name>params_list</name></name> <operator>=</operator> <name>params_list</name></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="char">'('</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>appendConditions</name><argument_list>(<argument><expr><name><name>fpinfo</name><operator>-&gt;</operator><name>joinclauses</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="char">')'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"(TRUE)"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<comment type="block">/* End the FROM clause entry. */</comment>
		<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="char">')'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name> <init>= <expr><call><name>planner_rt_fetch</name><argument_list>(<argument><expr><name><name>foreignrel</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>, <argument><expr><name>root</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/*
		 * Core code already has some lock on each rel being planned, so we
		 * can use NoLock here.
		 */</comment>
		<decl_stmt><decl><type><name>Relation</name></type>	<name>rel</name> <init>= <expr><call><name>heap_open</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>deparseRelation</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Add a unique alias to avoid any conflict in relation names due to
		 * pulled up subqueries in the query being built for a pushed down
		 * join.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>use_alias</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">" %s%d"</literal></expr></argument>, <argument><expr><name>REL_ALIAS_PREFIX</name></expr></argument>, <argument><expr><name><name>foreignrel</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Append FROM clause entry for the given relation into buf.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>deparseRangeTblRef</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>buf</name></decl></parameter>, <parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>foreignrel</name></decl></parameter>,
				   <parameter><decl><type><name>bool</name></type> <name>make_subquery</name></decl></parameter>, <parameter><decl><type><name>Index</name></type> <name>ignore_rel</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>ignore_conds</name></decl></parameter>,
				   <parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>params_list</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PgFdwRelationInfo</name> <modifier>*</modifier></type><name>fpinfo</name> <init>= <expr><operator>(</operator><name>PgFdwRelationInfo</name> <operator>*</operator><operator>)</operator> <name><name>foreignrel</name><operator>-&gt;</operator><name>fdw_private</name></name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* Should only be called in these cases. */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>IS_SIMPLE_REL</name><argument_list>(<argument><expr><name>foreignrel</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>IS_JOIN_REL</name><argument_list>(<argument><expr><name>foreignrel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>fpinfo</name><operator>-&gt;</operator><name>local_conds</name></name> <operator>==</operator> <name>NIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* If make_subquery is true, deparse the relation as a subquery. */</comment>
	<if_stmt><if>if <condition>(<expr><name>make_subquery</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>retrieved_attrs</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>ncols</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * The given relation shouldn't contain the target relation, because
		 * this should only happen for input relations for a full join, and
		 * such relations can never contain an UPDATE/DELETE target.
		 */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>ignore_rel</name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
			   <operator>!</operator><call><name>bms_is_member</name><argument_list>(<argument><expr><name>ignore_rel</name></expr></argument>, <argument><expr><name><name>foreignrel</name><operator>-&gt;</operator><name>relids</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Deparse the subquery representing the relation. */</comment>
		<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="char">'('</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>deparseSelectStmtForRel</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>root</name></expr></argument>, <argument><expr><name>foreignrel</name></expr></argument>, <argument><expr><name>NIL</name></expr></argument>,
								<argument><expr><name><name>fpinfo</name><operator>-&gt;</operator><name>remote_conds</name></name></expr></argument>, <argument><expr><name>NIL</name></expr></argument>, <argument><expr><name>true</name></expr></argument>,
								<argument><expr><operator>&amp;</operator><name>retrieved_attrs</name></expr></argument>, <argument><expr><name>params_list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="char">')'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Append the relation alias. */</comment>
		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">" %s%d"</literal></expr></argument>, <argument><expr><name>SUBQUERY_REL_ALIAS_PREFIX</name></expr></argument>,
						 <argument><expr><name><name>fpinfo</name><operator>-&gt;</operator><name>relation_index</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Append the column aliases if needed.  Note that the subquery emits
		 * expressions specified in the relation's reltarget (see
		 * deparseSubqueryTargetList).
		 */</comment>
		<expr_stmt><expr><name>ncols</name> <operator>=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>foreignrel</name><operator>-&gt;</operator><name>reltarget</name><operator>-&gt;</operator><name>exprs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>ncols</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="char">'('</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;=</operator> <name>ncols</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name>i</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">", "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

				<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"%s%d"</literal></expr></argument>, <argument><expr><name>SUBQUERY_COL_ALIAS_PREFIX</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></for>
			<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="char">')'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>deparseFromExprForRel</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>root</name></expr></argument>, <argument><expr><name>foreignrel</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>ignore_rel</name></expr></argument>,
							  <argument><expr><name>ignore_conds</name></expr></argument>, <argument><expr><name>params_list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * deparse remote INSERT statement
 *
 * The statement text is appended to buf, and we also create an integer List
 * of the columns being retrieved by RETURNING (if any), which is returned
 * to *retrieved_attrs.
 */</comment>
<function><type><name>void</name></type>
<name>deparseInsertSql</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>buf</name></decl></parameter>, <parameter><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name></decl></parameter>,
				 <parameter><decl><type><name>Index</name></type> <name>rtindex</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>,
				 <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>targetAttrs</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>doNothing</name></decl></parameter>,
				 <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>returningList</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>retrieved_attrs</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>AttrNumber</name></type>	<name>pindex</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>first</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"INSERT INTO "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>deparseRelation</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>targetAttrs</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="char">'('</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>first</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>targetAttrs</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>int</name></type>			<name>attnum</name> <init>= <expr><call><name>lfirst_int</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>first</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">", "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><name>first</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>deparseColumnRef</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>rtindex</name></expr></argument>, <argument><expr><name>attnum</name></expr></argument>, <argument><expr><name>rte</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>

		<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">") VALUES ("</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>pindex</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name>first</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>targetAttrs</argument>)</argument_list></macro>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>first</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">", "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><name>first</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"$%d"</literal></expr></argument>, <argument><expr><name>pindex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>pindex</name><operator>++</operator></expr>;</expr_stmt>
		</block_content>}</block>

		<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="char">')'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">" DEFAULT VALUES"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>doNothing</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">" ON CONFLICT DO NOTHING"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>deparseReturningList</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>rte</name></expr></argument>, <argument><expr><name>rtindex</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>,
						 <argument><expr><name><name>rel</name><operator>-&gt;</operator><name>trigdesc</name></name> <operator>&amp;&amp;</operator> <name><name>rel</name><operator>-&gt;</operator><name>trigdesc</name><operator>-&gt;</operator><name>trig_insert_after_row</name></name></expr></argument>,
						 <argument><expr><name>returningList</name></expr></argument>, <argument><expr><name>retrieved_attrs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * deparse remote UPDATE statement
 *
 * The statement text is appended to buf, and we also create an integer List
 * of the columns being retrieved by RETURNING (if any), which is returned
 * to *retrieved_attrs.
 */</comment>
<function><type><name>void</name></type>
<name>deparseUpdateSql</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>buf</name></decl></parameter>, <parameter><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name></decl></parameter>,
				 <parameter><decl><type><name>Index</name></type> <name>rtindex</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>,
				 <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>targetAttrs</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>returningList</name></decl></parameter>,
				 <parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>retrieved_attrs</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>AttrNumber</name></type>	<name>pindex</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>first</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"UPDATE "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>deparseRelation</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">" SET "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>pindex</name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt>					<comment type="block">/* ctid is always the first param */</comment>
	<expr_stmt><expr><name>first</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>targetAttrs</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>attnum</name> <init>= <expr><call><name>lfirst_int</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>first</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">", "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>first</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>deparseColumnRef</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>rtindex</name></expr></argument>, <argument><expr><name>attnum</name></expr></argument>, <argument><expr><name>rte</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">" = $%d"</literal></expr></argument>, <argument><expr><name>pindex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>pindex</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block>
	<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">" WHERE ctid = $1"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>deparseReturningList</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>rte</name></expr></argument>, <argument><expr><name>rtindex</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>,
						 <argument><expr><name><name>rel</name><operator>-&gt;</operator><name>trigdesc</name></name> <operator>&amp;&amp;</operator> <name><name>rel</name><operator>-&gt;</operator><name>trigdesc</name><operator>-&gt;</operator><name>trig_update_after_row</name></name></expr></argument>,
						 <argument><expr><name>returningList</name></expr></argument>, <argument><expr><name>retrieved_attrs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * deparse remote UPDATE statement
 *
 * 'buf' is the output buffer to append the statement to
 * 'rtindex' is the RT index of the associated target relation
 * 'rel' is the relation descriptor for the target relation
 * 'foreignrel' is the RelOptInfo for the target relation or the join relation
 *		containing all base relations in the query
 * 'targetlist' is the tlist of the underlying foreign-scan plan node
 * 'targetAttrs' is the target columns of the UPDATE
 * 'remote_conds' is the qual clauses that must be evaluated remotely
 * '*params_list' is an output list of exprs that will become remote Params
 * 'returningList' is the RETURNING targetlist
 * '*retrieved_attrs' is an output list of integers of columns being retrieved
 *		by RETURNING (if any)
 */</comment>
<function><type><name>void</name></type>
<name>deparseDirectUpdateSql</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>buf</name></decl></parameter>, <parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
					   <parameter><decl><type><name>Index</name></type> <name>rtindex</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>,
					   <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>foreignrel</name></decl></parameter>,
					   <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>targetlist</name></decl></parameter>,
					   <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>targetAttrs</name></decl></parameter>,
					   <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>remote_conds</name></decl></parameter>,
					   <parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>params_list</name></decl></parameter>,
					   <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>returningList</name></decl></parameter>,
					   <parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>retrieved_attrs</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>deparse_expr_cxt</name></type> <name>context</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>nestlevel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>first</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name> <init>= <expr><call><name>planner_rt_fetch</name><argument_list>(<argument><expr><name>rtindex</name></expr></argument>, <argument><expr><name>root</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/* Set up context struct for recursion */</comment>
	<expr_stmt><expr><name><name>context</name><operator>.</operator><name>root</name></name> <operator>=</operator> <name>root</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>context</name><operator>.</operator><name>foreignrel</name></name> <operator>=</operator> <name>foreignrel</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>context</name><operator>.</operator><name>scanrel</name></name> <operator>=</operator> <name>foreignrel</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>context</name><operator>.</operator><name>buf</name></name> <operator>=</operator> <name>buf</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>context</name><operator>.</operator><name>params_list</name></name> <operator>=</operator> <name>params_list</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"UPDATE "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>deparseRelation</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>foreignrel</name><operator>-&gt;</operator><name>reloptkind</name></name> <operator>==</operator> <name>RELOPT_JOINREL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">" %s%d"</literal></expr></argument>, <argument><expr><name>REL_ALIAS_PREFIX</name></expr></argument>, <argument><expr><name>rtindex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">" SET "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Make sure any constants in the exprs are printed portably */</comment>
	<expr_stmt><expr><name>nestlevel</name> <operator>=</operator> <call><name>set_transmission_modes</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>first</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>targetAttrs</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>attnum</name> <init>= <expr><call><name>lfirst_int</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>tle</name> <init>= <expr><call><name>get_tle_by_resno</name><argument_list>(<argument><expr><name>targetlist</name></expr></argument>, <argument><expr><name>attnum</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>tle</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"attribute number %d not found in UPDATE targetlist"</literal></expr></argument>,
				 <argument><expr><name>attnum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>first</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">", "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>first</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>deparseColumnRef</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>rtindex</name></expr></argument>, <argument><expr><name>attnum</name></expr></argument>, <argument><expr><name>rte</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">" = "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>deparseExpr</name><argument_list>(<argument><expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name><name>tle</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<expr_stmt><expr><call><name>reset_transmission_modes</name><argument_list>(<argument><expr><name>nestlevel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>foreignrel</name><operator>-&gt;</operator><name>reloptkind</name></name> <operator>==</operator> <name>RELOPT_JOINREL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>ignore_conds</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">" FROM "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>deparseFromExprForRel</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>root</name></expr></argument>, <argument><expr><name>foreignrel</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>rtindex</name></expr></argument>,
							  <argument><expr><operator>&amp;</operator><name>ignore_conds</name></expr></argument>, <argument><expr><name>params_list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>remote_conds</name> <operator>=</operator> <call><name>list_concat</name><argument_list>(<argument><expr><name>remote_conds</name></expr></argument>, <argument><expr><name>ignore_conds</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>remote_conds</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">" WHERE "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>appendConditions</name><argument_list>(<argument><expr><name>remote_conds</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>foreignrel</name><operator>-&gt;</operator><name>reloptkind</name></name> <operator>==</operator> <name>RELOPT_JOINREL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>deparseExplicitTargetList</name><argument_list>(<argument><expr><name>returningList</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>retrieved_attrs</name></expr></argument>,
								  <argument><expr><operator>&amp;</operator><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>deparseReturningList</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>rte</name></expr></argument>, <argument><expr><name>rtindex</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
							 <argument><expr><name>returningList</name></expr></argument>, <argument><expr><name>retrieved_attrs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * deparse remote DELETE statement
 *
 * The statement text is appended to buf, and we also create an integer List
 * of the columns being retrieved by RETURNING (if any), which is returned
 * to *retrieved_attrs.
 */</comment>
<function><type><name>void</name></type>
<name>deparseDeleteSql</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>buf</name></decl></parameter>, <parameter><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name></decl></parameter>,
				 <parameter><decl><type><name>Index</name></type> <name>rtindex</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>,
				 <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>returningList</name></decl></parameter>,
				 <parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>retrieved_attrs</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"DELETE FROM "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>deparseRelation</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">" WHERE ctid = $1"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>deparseReturningList</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>rte</name></expr></argument>, <argument><expr><name>rtindex</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>,
						 <argument><expr><name><name>rel</name><operator>-&gt;</operator><name>trigdesc</name></name> <operator>&amp;&amp;</operator> <name><name>rel</name><operator>-&gt;</operator><name>trigdesc</name><operator>-&gt;</operator><name>trig_delete_after_row</name></name></expr></argument>,
						 <argument><expr><name>returningList</name></expr></argument>, <argument><expr><name>retrieved_attrs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * deparse remote DELETE statement
 *
 * 'buf' is the output buffer to append the statement to
 * 'rtindex' is the RT index of the associated target relation
 * 'rel' is the relation descriptor for the target relation
 * 'foreignrel' is the RelOptInfo for the target relation or the join relation
 *		containing all base relations in the query
 * 'remote_conds' is the qual clauses that must be evaluated remotely
 * '*params_list' is an output list of exprs that will become remote Params
 * 'returningList' is the RETURNING targetlist
 * '*retrieved_attrs' is an output list of integers of columns being retrieved
 *		by RETURNING (if any)
 */</comment>
<function><type><name>void</name></type>
<name>deparseDirectDeleteSql</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>buf</name></decl></parameter>, <parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
					   <parameter><decl><type><name>Index</name></type> <name>rtindex</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>,
					   <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>foreignrel</name></decl></parameter>,
					   <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>remote_conds</name></decl></parameter>,
					   <parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>params_list</name></decl></parameter>,
					   <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>returningList</name></decl></parameter>,
					   <parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>retrieved_attrs</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>deparse_expr_cxt</name></type> <name>context</name></decl>;</decl_stmt>

	<comment type="block">/* Set up context struct for recursion */</comment>
	<expr_stmt><expr><name><name>context</name><operator>.</operator><name>root</name></name> <operator>=</operator> <name>root</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>context</name><operator>.</operator><name>foreignrel</name></name> <operator>=</operator> <name>foreignrel</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>context</name><operator>.</operator><name>scanrel</name></name> <operator>=</operator> <name>foreignrel</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>context</name><operator>.</operator><name>buf</name></name> <operator>=</operator> <name>buf</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>context</name><operator>.</operator><name>params_list</name></name> <operator>=</operator> <name>params_list</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"DELETE FROM "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>deparseRelation</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>foreignrel</name><operator>-&gt;</operator><name>reloptkind</name></name> <operator>==</operator> <name>RELOPT_JOINREL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">" %s%d"</literal></expr></argument>, <argument><expr><name>REL_ALIAS_PREFIX</name></expr></argument>, <argument><expr><name>rtindex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>foreignrel</name><operator>-&gt;</operator><name>reloptkind</name></name> <operator>==</operator> <name>RELOPT_JOINREL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>ignore_conds</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">" USING "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>deparseFromExprForRel</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>root</name></expr></argument>, <argument><expr><name>foreignrel</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>rtindex</name></expr></argument>,
							  <argument><expr><operator>&amp;</operator><name>ignore_conds</name></expr></argument>, <argument><expr><name>params_list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>remote_conds</name> <operator>=</operator> <call><name>list_concat</name><argument_list>(<argument><expr><name>remote_conds</name></expr></argument>, <argument><expr><name>ignore_conds</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>remote_conds</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">" WHERE "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>appendConditions</name><argument_list>(<argument><expr><name>remote_conds</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>foreignrel</name><operator>-&gt;</operator><name>reloptkind</name></name> <operator>==</operator> <name>RELOPT_JOINREL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>deparseExplicitTargetList</name><argument_list>(<argument><expr><name>returningList</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>retrieved_attrs</name></expr></argument>,
								  <argument><expr><operator>&amp;</operator><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>deparseReturningList</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><call><name>planner_rt_fetch</name><argument_list>(<argument><expr><name>rtindex</name></expr></argument>, <argument><expr><name>root</name></expr></argument>)</argument_list></call></expr></argument>,
							 <argument><expr><name>rtindex</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
							 <argument><expr><name>returningList</name></expr></argument>, <argument><expr><name>retrieved_attrs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Add a RETURNING clause, if needed, to an INSERT/UPDATE/DELETE.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>deparseReturningList</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>buf</name></decl></parameter>, <parameter><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name></decl></parameter>,
					 <parameter><decl><type><name>Index</name></type> <name>rtindex</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>,
					 <parameter><decl><type><name>bool</name></type> <name>trig_after_row</name></decl></parameter>,
					 <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>returningList</name></decl></parameter>,
					 <parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>retrieved_attrs</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Bitmapset</name>  <modifier>*</modifier></type><name>attrs_used</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>trig_after_row</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* whole-row reference acquires all non-system columns */</comment>
		<expr_stmt><expr><name>attrs_used</name> <operator>=</operator>
			<call><name>bms_make_singleton</name><argument_list>(<argument><expr><literal type="number">0</literal> <operator>-</operator> <name>FirstLowInvalidHeapAttributeNumber</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>returningList</name> <operator>!=</operator> <name>NIL</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * We need the attrs, non-system and system, mentioned in the local
		 * query's RETURNING list.
		 */</comment>
		<expr_stmt><expr><call><name>pull_varattnos</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>returningList</name></expr></argument>, <argument><expr><name>rtindex</name></expr></argument>,
					   <argument><expr><operator>&amp;</operator><name>attrs_used</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>attrs_used</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>deparseTargetList</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>rte</name></expr></argument>, <argument><expr><name>rtindex</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>attrs_used</name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
						  <argument><expr><name>retrieved_attrs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><operator>*</operator><name>retrieved_attrs</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Construct SELECT statement to acquire size in blocks of given relation.
 *
 * Note: we use local definition of block size, not remote definition.
 * This is perhaps debatable.
 *
 * Note: pg_relation_size() exists in 8.1 and later.
 */</comment>
<function><type><name>void</name></type>
<name>deparseAnalyzeSizeSql</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>buf</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>StringInfoData</name></type> <name>relname</name></decl>;</decl_stmt>

	<comment type="block">/* We'll need the remote relation name as a literal. */</comment>
	<expr_stmt><expr><call><name>initStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>relname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>deparseRelation</name><argument_list>(<argument><expr><operator>&amp;</operator><name>relname</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"SELECT pg_catalog.pg_relation_size("</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>deparseStringLiteral</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name><name>relname</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"::pg_catalog.regclass) / %d"</literal></expr></argument>, <argument><expr><name>BLCKSZ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Construct SELECT statement to acquire sample rows of given relation.
 *
 * SELECT command is appended to buf, and list of columns retrieved
 * is returned to *retrieved_attrs.
 */</comment>
<function><type><name>void</name></type>
<name>deparseAnalyzeSql</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>buf</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>retrieved_attrs</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>relid</name> <init>= <expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleDesc</name></type>	<name>tupdesc</name> <init>= <expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>colname</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>options</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>first</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><operator>*</operator><name>retrieved_attrs</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"SELECT "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>tupdesc</name><operator>-&gt;</operator><name>natts</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<comment type="block">/* Ignore dropped columns. */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>TupleDescAttr</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>attisdropped</name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>first</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">", "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>first</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

		<comment type="block">/* Use attribute name or column_name option. */</comment>
		<expr_stmt><expr><name>colname</name> <operator>=</operator> <call><name>NameStr</name><argument_list>(<argument><expr><call><name>TupleDescAttr</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>attname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>options</name> <operator>=</operator> <call><name>GetForeignColumnOptions</name><argument_list>(<argument><expr><name>relid</name></expr></argument>, <argument><expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>options</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>DefElem</name>    <modifier>*</modifier></type><name>def</name> <init>= <expr><operator>(</operator><name>DefElem</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>def</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>, <argument><expr><literal type="string">"column_name"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>colname</name> <operator>=</operator> <call><name>defGetString</name><argument_list>(<argument><expr><name>def</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block>

		<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><call><name>quote_identifier</name><argument_list>(<argument><expr><name>colname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><operator>*</operator><name>retrieved_attrs</name> <operator>=</operator> <call><name>lappend_int</name><argument_list>(<argument><expr><operator>*</operator><name>retrieved_attrs</name></expr></argument>, <argument><expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<comment type="block">/* Don't generate bad syntax for zero-column relation. */</comment>
	<if_stmt><if>if <condition>(<expr><name>first</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"NULL"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Construct FROM clause
	 */</comment>
	<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">" FROM "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>deparseRelation</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Construct name to use for given column, and emit it into buf.
 * If it has a column_name FDW option, use that instead of attribute name.
 *
 * If qualify_col is true, qualify column name with the alias of relation.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>deparseColumnRef</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>buf</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>varno</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>varattno</name></decl></parameter>, <parameter><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name></decl></parameter>,
				 <parameter><decl><type><name>bool</name></type> <name>qualify_col</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* We support fetching the remote side's CTID and OID. */</comment>
	<if_stmt><if>if <condition>(<expr><name>varattno</name> <operator>==</operator> <name>SelfItemPointerAttributeNumber</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>qualify_col</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ADD_REL_QUALIFIER</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>varno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"ctid"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>varattno</name> <operator>==</operator> <name>ObjectIdAttributeNumber</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>qualify_col</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ADD_REL_QUALIFIER</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>varno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"oid"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>varattno</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * All other system attributes are fetched as 0, except for table OID,
		 * which is fetched as the local table OID.  However, we must be
		 * careful; the table could be beneath an outer join, in which case it
		 * must go to NULL whenever the rest of the row does.
		 */</comment>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>fetchval</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>varattno</name> <operator>==</operator> <name>TableOidAttributeNumber</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>fetchval</name> <operator>=</operator> <name><name>rte</name><operator>-&gt;</operator><name>relid</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>qualify_col</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"CASE WHEN ("</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>ADD_REL_QUALIFIER</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>varno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"*)::text IS NOT NULL THEN %u END"</literal></expr></argument>, <argument><expr><name>fetchval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"%u"</literal></expr></argument>, <argument><expr><name>fetchval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>varattno</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Whole row reference */</comment>
		<decl_stmt><decl><type><name>Relation</name></type>	<name>rel</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Bitmapset</name>  <modifier>*</modifier></type><name>attrs_used</name></decl>;</decl_stmt>

		<comment type="block">/* Required only to be passed down to deparseTargetList(). */</comment>
		<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>retrieved_attrs</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * The lock on the relation will be held by upper callers, so it's
		 * fine to open it with no lock here.
		 */</comment>
		<expr_stmt><expr><name>rel</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * The local name of the foreign table can not be recognized by the
		 * foreign server and the table it references on foreign server might
		 * have different column ordering or different columns than those
		 * declared locally. Hence we have to deparse whole-row reference as
		 * ROW(columns referenced locally). Construct this by deparsing a
		 * "whole row" attribute.
		 */</comment>
		<expr_stmt><expr><name>attrs_used</name> <operator>=</operator> <call><name>bms_add_member</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>,
									<argument><expr><literal type="number">0</literal> <operator>-</operator> <name>FirstLowInvalidHeapAttributeNumber</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * In case the whole-row reference is under an outer join then it has
		 * to go NULL whenever the rest of the row goes NULL. Deparsing a join
		 * query would always involve multiple relations, thus qualify_col
		 * would be true.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>qualify_col</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"CASE WHEN ("</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>ADD_REL_QUALIFIER</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>varno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"*)::text IS NOT NULL THEN "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"ROW("</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>deparseTargetList</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>rte</name></expr></argument>, <argument><expr><name>varno</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>attrs_used</name></expr></argument>, <argument><expr><name>qualify_col</name></expr></argument>,
						  <argument><expr><operator>&amp;</operator><name>retrieved_attrs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="char">')'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Complete the CASE WHEN statement started above. */</comment>
		<if_stmt><if>if <condition>(<expr><name>qualify_col</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">" END"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>bms_free</name><argument_list>(<argument><expr><name>attrs_used</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>colname</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>options</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

		<comment type="block">/* varno must not be any of OUTER_VAR, INNER_VAR and INDEX_VAR. */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>IS_SPECIAL_VARNO</name><argument_list>(<argument><expr><name>varno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * If it's a column of a foreign table, and it has the column_name FDW
		 * option, use that value.
		 */</comment>
		<expr_stmt><expr><name>options</name> <operator>=</operator> <call><name>GetForeignColumnOptions</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>, <argument><expr><name>varattno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>options</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>DefElem</name>    <modifier>*</modifier></type><name>def</name> <init>= <expr><operator>(</operator><name>DefElem</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>def</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>, <argument><expr><literal type="string">"column_name"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>colname</name> <operator>=</operator> <call><name>defGetString</name><argument_list>(<argument><expr><name>def</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block>

		<comment type="block">/*
		 * If it's a column of a regular table or it doesn't have column_name
		 * FDW option, use attribute name.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>colname</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>colname</name> <operator>=</operator> <call><name>get_attname</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>, <argument><expr><name>varattno</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>qualify_col</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ADD_REL_QUALIFIER</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>varno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><call><name>quote_identifier</name><argument_list>(<argument><expr><name>colname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Append remote name of specified foreign table to buf.
 * Use value of table_name FDW option (if any) instead of relation's name.
 * Similarly, schema_name FDW option overrides schema name.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>deparseRelation</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>buf</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ForeignTable</name> <modifier>*</modifier></type><name>table</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>nspname</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>relname</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

	<comment type="block">/* obtain additional catalog information. */</comment>
	<expr_stmt><expr><name>table</name> <operator>=</operator> <call><name>GetForeignTable</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Use value of FDW options if any, instead of the name of object itself.
	 */</comment>
	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>table-&gt;options</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>DefElem</name>    <modifier>*</modifier></type><name>def</name> <init>= <expr><operator>(</operator><name>DefElem</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>def</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>, <argument><expr><literal type="string">"schema_name"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>nspname</name> <operator>=</operator> <call><name>defGetString</name><argument_list>(<argument><expr><name>def</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>def</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>, <argument><expr><literal type="string">"table_name"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>relname</name> <operator>=</operator> <call><name>defGetString</name><argument_list>(<argument><expr><name>def</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block>

	<comment type="block">/*
	 * Note: we could skip printing the schema name if it's pg_catalog, but
	 * that doesn't seem worth the trouble.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>nspname</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>nspname</name> <operator>=</operator> <call><name>get_namespace_name</name><argument_list>(<argument><expr><call><name>RelationGetNamespace</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>relname</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>relname</name> <operator>=</operator> <call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"%s.%s"</literal></expr></argument>,
					 <argument><expr><call><name>quote_identifier</name><argument_list>(<argument><expr><name>nspname</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>quote_identifier</name><argument_list>(<argument><expr><name>relname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Append a SQL string literal representing "val" to buf.
 */</comment>
<function><type><name>void</name></type>
<name>deparseStringLiteral</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>buf</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>val</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>valptr</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Rather than making assumptions about the remote server's value of
	 * standard_conforming_strings, always use E'foo' syntax if there are any
	 * backslashes.  This will fail on remote servers before 8.1, but those
	 * are long out of support.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>strchr</name><argument_list>(<argument><expr><name>val</name></expr></argument>, <argument><expr><literal type="char">'\\'</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>ESCAPE_STRING_SYNTAX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="char">'\''</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>valptr</name> <operator>=</operator> <name>val</name></expr>;</init> <condition><expr><operator>*</operator><name>valptr</name></expr>;</condition> <incr><expr><name>valptr</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name></type>		<name>ch</name> <init>= <expr><operator>*</operator><name>valptr</name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>SQL_STR_DOUBLE</name><argument_list>(<argument><expr><name>ch</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>ch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>ch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>
	<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="char">'\''</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Deparse given expression into context-&gt;buf.
 *
 * This function must support all the same node types that foreign_expr_walker
 * accepts.
 *
 * Note: unlike ruleutils.c, we just use a simple hard-wired parenthesization
 * scheme: anything more complex than a Var, Const, function call or cast
 * should be self-parenthesized.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>deparseExpr</name><parameter_list>(<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>deparse_expr_cxt</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>node</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<switch>switch <condition>(<expr><call><name>nodeTag</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>T_Var</name></expr>:</case>
			<expr_stmt><expr><call><name>deparseVar</name><argument_list>(<argument><expr><operator>(</operator><name>Var</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_Const</name></expr>:</case>
			<expr_stmt><expr><call><name>deparseConst</name><argument_list>(<argument><expr><operator>(</operator><name>Const</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>, <argument><expr><name>context</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_Param</name></expr>:</case>
			<expr_stmt><expr><call><name>deparseParam</name><argument_list>(<argument><expr><operator>(</operator><name>Param</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_ArrayRef</name></expr>:</case>
			<expr_stmt><expr><call><name>deparseArrayRef</name><argument_list>(<argument><expr><operator>(</operator><name>ArrayRef</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_FuncExpr</name></expr>:</case>
			<expr_stmt><expr><call><name>deparseFuncExpr</name><argument_list>(<argument><expr><operator>(</operator><name>FuncExpr</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_OpExpr</name></expr>:</case>
			<expr_stmt><expr><call><name>deparseOpExpr</name><argument_list>(<argument><expr><operator>(</operator><name>OpExpr</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_DistinctExpr</name></expr>:</case>
			<expr_stmt><expr><call><name>deparseDistinctExpr</name><argument_list>(<argument><expr><operator>(</operator><name>DistinctExpr</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_ScalarArrayOpExpr</name></expr>:</case>
			<expr_stmt><expr><call><name>deparseScalarArrayOpExpr</name><argument_list>(<argument><expr><operator>(</operator><name>ScalarArrayOpExpr</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_RelabelType</name></expr>:</case>
			<expr_stmt><expr><call><name>deparseRelabelType</name><argument_list>(<argument><expr><operator>(</operator><name>RelabelType</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_BoolExpr</name></expr>:</case>
			<expr_stmt><expr><call><name>deparseBoolExpr</name><argument_list>(<argument><expr><operator>(</operator><name>BoolExpr</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_NullTest</name></expr>:</case>
			<expr_stmt><expr><call><name>deparseNullTest</name><argument_list>(<argument><expr><operator>(</operator><name>NullTest</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_ArrayExpr</name></expr>:</case>
			<expr_stmt><expr><call><name>deparseArrayExpr</name><argument_list>(<argument><expr><operator>(</operator><name>ArrayExpr</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_Aggref</name></expr>:</case>
			<expr_stmt><expr><call><name>deparseAggref</name><argument_list>(<argument><expr><operator>(</operator><name>Aggref</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<default>default:</default>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unsupported expression type for deparse: %d"</literal></expr></argument>,
				 <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <call><name>nodeTag</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
	</block_content>}</block></switch>
</block_content>}</block></function>

<comment type="block">/*
 * Deparse given Var node into context-&gt;buf.
 *
 * If the Var belongs to the foreign relation, just print its remote name.
 * Otherwise, it's effectively a Param (and will in fact be a Param at
 * run time).  Handle it the same way we handle plain Params --- see
 * deparseParam for comments.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>deparseVar</name><parameter_list>(<parameter><decl><type><name>Var</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>deparse_expr_cxt</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Relids</name></type>		<name>relids</name> <init>= <expr><name><name>context</name><operator>-&gt;</operator><name>scanrel</name><operator>-&gt;</operator><name>relids</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>relno</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>colno</name></decl>;</decl_stmt>

	<comment type="block">/* Qualify columns when multiple relations are involved. */</comment>
	<decl_stmt><decl><type><name>bool</name></type>		<name>qualify_col</name> <init>= <expr><operator>(</operator><call><name>bms_num_members</name><argument_list>(<argument><expr><name>relids</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">1</literal><operator>)</operator></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * If the Var belongs to the foreign relation that is deparsed as a
	 * subquery, use the relation and column alias to the Var provided by the
	 * subquery, instead of the remote name.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>is_subquery_var</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name><name>context</name><operator>-&gt;</operator><name>scanrel</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>relno</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>colno</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name><name>context</name><operator>-&gt;</operator><name>buf</name></name></expr></argument>, <argument><expr><literal type="string">"%s%d.%s%d"</literal></expr></argument>,
						 <argument><expr><name>SUBQUERY_REL_ALIAS_PREFIX</name></expr></argument>, <argument><expr><name>relno</name></expr></argument>,
						 <argument><expr><name>SUBQUERY_COL_ALIAS_PREFIX</name></expr></argument>, <argument><expr><name>colno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>bms_is_member</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>varno</name></name></expr></argument>, <argument><expr><name>relids</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name><name>node</name><operator>-&gt;</operator><name>varlevelsup</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>deparseColumnRef</name><argument_list>(<argument><expr><name><name>context</name><operator>-&gt;</operator><name>buf</name></name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>varno</name></name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>varattno</name></name></expr></argument>,
						 <argument><expr><call><name>planner_rt_fetch</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>varno</name></name></expr></argument>, <argument><expr><name><name>context</name><operator>-&gt;</operator><name>root</name></name></expr></argument>)</argument_list></call></expr></argument>,
						 <argument><expr><name>qualify_col</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* Treat like a Param */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>context</name><operator>-&gt;</operator><name>params_list</name></name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>int</name></type>			<name>pindex</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

			<comment type="block">/* find its index in params_list */</comment>
			<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>*context-&gt;params_list</argument>)</argument_list></macro>
			<block>{<block_content>
				<expr_stmt><expr><name>pindex</name><operator>++</operator></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><call><name>equal</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<break>break;</break></block_content></block></if></if_stmt>
			</block_content>}</block>
			<if_stmt><if>if <condition>(<expr><name>lc</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* not in list, so add it */</comment>
				<expr_stmt><expr><name>pindex</name><operator>++</operator></expr>;</expr_stmt>
				<expr_stmt><expr><operator>*</operator><name><name>context</name><operator>-&gt;</operator><name>params_list</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><operator>*</operator><name><name>context</name><operator>-&gt;</operator><name>params_list</name></name></expr></argument>, <argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<expr_stmt><expr><call><name>printRemoteParam</name><argument_list>(<argument><expr><name>pindex</name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>vartype</name></name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>vartypmod</name></name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><call><name>printRemotePlaceholder</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>vartype</name></name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>vartypmod</name></name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Deparse given constant value into context-&gt;buf.
 *
 * This function has to be kept in sync with ruleutils.c's get_const_expr.
 * As for that function, showtype can be -1 to never show "::typename" decoration,
 * or +1 to always show it, or 0 to show it only if the constant wouldn't be assumed
 * to be the right type by default.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>deparseConst</name><parameter_list>(<parameter><decl><type><name>Const</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>deparse_expr_cxt</name> <modifier>*</modifier></type><name>context</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>showtype</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>StringInfo</name></type>	<name>buf</name> <init>= <expr><name><name>context</name><operator>-&gt;</operator><name>buf</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>typoutput</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>typIsVarlena</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>extval</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>isfloat</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>needlabel</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>constisnull</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"NULL"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>showtype</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"::%s"</literal></expr></argument>,
							 <argument><expr><call><name>deparse_type_name</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>consttype</name></name></expr></argument>,
											   <argument><expr><name><name>node</name><operator>-&gt;</operator><name>consttypmod</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>getTypeOutputInfo</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>consttype</name></name></expr></argument>,
					  <argument><expr><operator>&amp;</operator><name>typoutput</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>typIsVarlena</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>extval</name> <operator>=</operator> <call><name>OidOutputFunctionCall</name><argument_list>(<argument><expr><name>typoutput</name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>constvalue</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<switch>switch <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>consttype</name></name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>INT2OID</name></expr>:</case>
		<case>case <expr><name>INT4OID</name></expr>:</case>
		<case>case <expr><name>INT8OID</name></expr>:</case>
		<case>case <expr><name>OIDOID</name></expr>:</case>
		<case>case <expr><name>FLOAT4OID</name></expr>:</case>
		<case>case <expr><name>FLOAT8OID</name></expr>:</case>
		<case>case <expr><name>NUMERICOID</name></expr>:</case>
			<block>{<block_content>
				<comment type="block">/*
				 * No need to quote unless it's a special value such as 'NaN'.
				 * See comments in get_const_expr().
				 */</comment>
				<if_stmt><if>if <condition>(<expr><call><name>strspn</name><argument_list>(<argument><expr><name>extval</name></expr></argument>, <argument><expr><literal type="string">"0123456789+-eE."</literal></expr></argument>)</argument_list></call> <operator>==</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>extval</name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<if_stmt><if>if <condition>(<expr><name><name>extval</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'+'</literal> <operator>||</operator> <name><name>extval</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'-'</literal></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"(%s)"</literal></expr></argument>, <argument><expr><name>extval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
					<else>else<block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>extval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
					<if_stmt><if>if <condition>(<expr><call><name>strcspn</name><argument_list>(<argument><expr><name>extval</name></expr></argument>, <argument><expr><literal type="string">"eE."</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>extval</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><name>isfloat</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt> <comment type="block">/* it looks like a float */</comment>
				</block_content>}</block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"'%s'"</literal></expr></argument>, <argument><expr><name>extval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
			</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>BITOID</name></expr>:</case>
		<case>case <expr><name>VARBITOID</name></expr>:</case>
			<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"B'%s'"</literal></expr></argument>, <argument><expr><name>extval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>BOOLOID</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>extval</name></expr></argument>, <argument><expr><literal type="string">"t"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"true"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"false"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
			<break>break;</break>
		<default>default:</default>
			<expr_stmt><expr><call><name>deparseStringLiteral</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>extval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
	</block_content>}</block></switch>

	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>extval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>showtype</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * For showtype == 0, append ::typename unless the constant will be
	 * implicitly typed as the right type when it is read in.
	 *
	 * XXX this code has to be kept in sync with the behavior of the parser,
	 * especially make_const.
	 */</comment>
	<switch>switch <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>consttype</name></name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>BOOLOID</name></expr>:</case>
		<case>case <expr><name>INT4OID</name></expr>:</case>
		<case>case <expr><name>UNKNOWNOID</name></expr>:</case>
			<expr_stmt><expr><name>needlabel</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>NUMERICOID</name></expr>:</case>
			<expr_stmt><expr><name>needlabel</name> <operator>=</operator> <operator>!</operator><name>isfloat</name> <operator>||</operator> <operator>(</operator><name><name>node</name><operator>-&gt;</operator><name>consttypmod</name></name> <operator>&gt;=</operator> <literal type="number">0</literal><operator>)</operator></expr>;</expr_stmt>
			<break>break;</break>
		<default>default:</default>
			<expr_stmt><expr><name>needlabel</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<break>break;</break>
	</block_content>}</block></switch>
	<if_stmt><if>if <condition>(<expr><name>needlabel</name> <operator>||</operator> <name>showtype</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"::%s"</literal></expr></argument>,
						 <argument><expr><call><name>deparse_type_name</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>consttype</name></name></expr></argument>,
										   <argument><expr><name><name>node</name><operator>-&gt;</operator><name>consttypmod</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Deparse given Param node.
 *
 * If we're generating the query "for real", add the Param to
 * context-&gt;params_list if it's not already present, and then use its index
 * in that list as the remote parameter number.  During EXPLAIN, there's
 * no need to identify a parameter number.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>deparseParam</name><parameter_list>(<parameter><decl><type><name>Param</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>deparse_expr_cxt</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name><name>context</name><operator>-&gt;</operator><name>params_list</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>pindex</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

		<comment type="block">/* find its index in params_list */</comment>
		<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>*context-&gt;params_list</argument>)</argument_list></macro>
		<block>{<block_content>
			<expr_stmt><expr><name>pindex</name><operator>++</operator></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><call><name>equal</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<break>break;</break></block_content></block></if></if_stmt>
		</block_content>}</block>
		<if_stmt><if>if <condition>(<expr><name>lc</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* not in list, so add it */</comment>
			<expr_stmt><expr><name>pindex</name><operator>++</operator></expr>;</expr_stmt>
			<expr_stmt><expr><operator>*</operator><name><name>context</name><operator>-&gt;</operator><name>params_list</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><operator>*</operator><name><name>context</name><operator>-&gt;</operator><name>params_list</name></name></expr></argument>, <argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>printRemoteParam</name><argument_list>(<argument><expr><name>pindex</name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>paramtype</name></name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>paramtypmod</name></name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>printRemotePlaceholder</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>paramtype</name></name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>paramtypmod</name></name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Deparse an array subscript expression.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>deparseArrayRef</name><parameter_list>(<parameter><decl><type><name>ArrayRef</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>deparse_expr_cxt</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>StringInfo</name></type>	<name>buf</name> <init>= <expr><name><name>context</name><operator>-&gt;</operator><name>buf</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lowlist_item</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>uplist_item</name></decl>;</decl_stmt>

	<comment type="block">/* Always parenthesize the expression. */</comment>
	<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="char">'('</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Deparse referenced array expression first.  If that expression includes
	 * a cast, we have to parenthesize to prevent the array subscript from
	 * being taken as typename decoration.  We can avoid that in the typical
	 * case of subscripting a Var, but otherwise do it.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>refexpr</name></name></expr></argument>, <argument><expr><name>Var</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>deparseExpr</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>refexpr</name></name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="char">'('</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>deparseExpr</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>refexpr</name></name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="char">')'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/* Deparse subscript expressions. */</comment>
	<expr_stmt><expr><name>lowlist_item</name> <operator>=</operator> <call><name>list_head</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>reflowerindexpr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>	<comment type="block">/* could be NULL */</comment>
	<macro><name>foreach</name><argument_list>(<argument>uplist_item</argument>, <argument>node-&gt;refupperindexpr</argument>)</argument_list></macro>
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="char">'['</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>lowlist_item</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>deparseExpr</name><argument_list>(<argument><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lowlist_item</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="char">':'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>lowlist_item</name> <operator>=</operator> <call><name>lnext</name><argument_list>(<argument><expr><name>lowlist_item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><call><name>deparseExpr</name><argument_list>(<argument><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>uplist_item</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="char">']'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="char">')'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Deparse a function call.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>deparseFuncExpr</name><parameter_list>(<parameter><decl><type><name>FuncExpr</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>deparse_expr_cxt</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>StringInfo</name></type>	<name>buf</name> <init>= <expr><name><name>context</name><operator>-&gt;</operator><name>buf</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>use_variadic</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>first</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>arg</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * If the function call came from an implicit coercion, then just show the
	 * first argument.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>funcformat</name></name> <operator>==</operator> <name>COERCE_IMPLICIT_CAST</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>deparseExpr</name><argument_list>(<argument><expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <call><name>linitial</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * If the function call came from a cast, then show the first argument
	 * plus an explicit cast operation.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>funcformat</name></name> <operator>==</operator> <name>COERCE_EXPLICIT_CAST</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>rettype</name> <init>= <expr><name><name>node</name><operator>-&gt;</operator><name>funcresulttype</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int32</name></type>		<name>coercedTypmod</name></decl>;</decl_stmt>

		<comment type="block">/* Get the typmod if this is a length-coercion function */</comment>
		<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>exprIsLengthCoercion</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>coercedTypmod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>deparseExpr</name><argument_list>(<argument><expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <call><name>linitial</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"::%s"</literal></expr></argument>,
						 <argument><expr><call><name>deparse_type_name</name><argument_list>(<argument><expr><name>rettype</name></expr></argument>, <argument><expr><name>coercedTypmod</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Check if need to print VARIADIC (cf. ruleutils.c) */</comment>
	<expr_stmt><expr><name>use_variadic</name> <operator>=</operator> <name><name>node</name><operator>-&gt;</operator><name>funcvariadic</name></name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Normal function: display as proname(args).
	 */</comment>
	<expr_stmt><expr><call><name>appendFunctionName</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>funcid</name></name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="char">'('</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* ... and all the arguments */</comment>
	<expr_stmt><expr><name>first</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<macro><name>foreach</name><argument_list>(<argument>arg</argument>, <argument>node-&gt;args</argument>)</argument_list></macro>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>first</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">", "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name>use_variadic</name> <operator>&amp;&amp;</operator> <call><name>lnext</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"VARIADIC "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>deparseExpr</name><argument_list>(<argument><expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>first</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	</block_content>}</block>
	<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="char">')'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Deparse given operator expression.   To avoid problems around
 * priority of operations, we always parenthesize the arguments.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>deparseOpExpr</name><parameter_list>(<parameter><decl><type><name>OpExpr</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>deparse_expr_cxt</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>StringInfo</name></type>	<name>buf</name> <init>= <expr><name><name>context</name><operator>-&gt;</operator><name>buf</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Form_pg_operator</name></type> <name>form</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name>oprkind</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>arg</name></decl>;</decl_stmt>

	<comment type="block">/* Retrieve information about the operator from system catalog. */</comment>
	<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>OPEROID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>opno</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for operator %u"</literal></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>opno</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>form</name> <operator>=</operator> <operator>(</operator><name>Form_pg_operator</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>oprkind</name> <operator>=</operator> <name><name>form</name><operator>-&gt;</operator><name>oprkind</name></name></expr>;</expr_stmt>

	<comment type="block">/* Sanity check. */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>(</operator><name>oprkind</name> <operator>==</operator> <literal type="char">'r'</literal> <operator>&amp;&amp;</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal><operator>)</operator> <operator>||</operator>
		   <operator>(</operator><name>oprkind</name> <operator>==</operator> <literal type="char">'l'</literal> <operator>&amp;&amp;</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal><operator>)</operator> <operator>||</operator>
		   <operator>(</operator><name>oprkind</name> <operator>==</operator> <literal type="char">'b'</literal> <operator>&amp;&amp;</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">2</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Always parenthesize the expression. */</comment>
	<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="char">'('</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Deparse left operand. */</comment>
	<if_stmt><if>if <condition>(<expr><name>oprkind</name> <operator>==</operator> <literal type="char">'r'</literal> <operator>||</operator> <name>oprkind</name> <operator>==</operator> <literal type="char">'b'</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>arg</name> <operator>=</operator> <call><name>list_head</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>deparseExpr</name><argument_list>(<argument><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="char">' '</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Deparse operator name. */</comment>
	<expr_stmt><expr><call><name>deparseOperatorName</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>form</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Deparse right operand. */</comment>
	<if_stmt><if>if <condition>(<expr><name>oprkind</name> <operator>==</operator> <literal type="char">'l'</literal> <operator>||</operator> <name>oprkind</name> <operator>==</operator> <literal type="char">'b'</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>arg</name> <operator>=</operator> <call><name>list_tail</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="char">' '</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>deparseExpr</name><argument_list>(<argument><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="char">')'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Print the name of an operator.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>deparseOperatorName</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>buf</name></decl></parameter>, <parameter><decl><type><name>Form_pg_operator</name></type> <name>opform</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>opname</name></decl>;</decl_stmt>

	<comment type="block">/* opname is not a SQL identifier, so we should not quote it. */</comment>
	<expr_stmt><expr><name>opname</name> <operator>=</operator> <call><name>NameStr</name><argument_list>(<argument><expr><name><name>opform</name><operator>-&gt;</operator><name>oprname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Print schema name only if it's not pg_catalog */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>opform</name><operator>-&gt;</operator><name>oprnamespace</name></name> <operator>!=</operator> <name>PG_CATALOG_NAMESPACE</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>opnspname</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>opnspname</name> <operator>=</operator> <call><name>get_namespace_name</name><argument_list>(<argument><expr><name><name>opform</name><operator>-&gt;</operator><name>oprnamespace</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* Print fully qualified operator name. */</comment>
		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"OPERATOR(%s.%s)"</literal></expr></argument>,
						 <argument><expr><call><name>quote_identifier</name><argument_list>(<argument><expr><name>opnspname</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>opname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* Just print operator name. */</comment>
		<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>opname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Deparse IS DISTINCT FROM.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>deparseDistinctExpr</name><parameter_list>(<parameter><decl><type><name>DistinctExpr</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>deparse_expr_cxt</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>StringInfo</name></type>	<name>buf</name> <init>= <expr><name><name>context</name><operator>-&gt;</operator><name>buf</name></name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="char">'('</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>deparseExpr</name><argument_list>(<argument><expr><call><name>linitial</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">" IS DISTINCT FROM "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>deparseExpr</name><argument_list>(<argument><expr><call><name>lsecond</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="char">')'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Deparse given ScalarArrayOpExpr expression.  To avoid problems
 * around priority of operations, we always parenthesize the arguments.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>deparseScalarArrayOpExpr</name><parameter_list>(<parameter><decl><type><name>ScalarArrayOpExpr</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>deparse_expr_cxt</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>StringInfo</name></type>	<name>buf</name> <init>= <expr><name><name>context</name><operator>-&gt;</operator><name>buf</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Form_pg_operator</name></type> <name>form</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Expr</name>	   <modifier>*</modifier></type><name>arg1</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Expr</name>	   <modifier>*</modifier></type><name>arg2</name></decl>;</decl_stmt>

	<comment type="block">/* Retrieve information about the operator from system catalog. */</comment>
	<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>OPEROID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>opno</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for operator %u"</literal></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>opno</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>form</name> <operator>=</operator> <operator>(</operator><name>Form_pg_operator</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Sanity check. */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Always parenthesize the expression. */</comment>
	<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="char">'('</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Deparse left operand. */</comment>
	<expr_stmt><expr><name>arg1</name> <operator>=</operator> <call><name>linitial</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>deparseExpr</name><argument_list>(<argument><expr><name>arg1</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="char">' '</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Deparse operator name plus decoration. */</comment>
	<expr_stmt><expr><call><name>deparseOperatorName</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>form</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">" %s ("</literal></expr></argument>, <argument><expr><ternary><condition><expr><name><name>node</name><operator>-&gt;</operator><name>useOr</name></name></expr> ?</condition><then> <expr><literal type="string">"ANY"</literal></expr> </then><else>: <expr><literal type="string">"ALL"</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Deparse right operand. */</comment>
	<expr_stmt><expr><name>arg2</name> <operator>=</operator> <call><name>lsecond</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>deparseExpr</name><argument_list>(<argument><expr><name>arg2</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="char">')'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Always parenthesize the expression. */</comment>
	<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="char">')'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Deparse a RelabelType (binary-compatible cast) node.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>deparseRelabelType</name><parameter_list>(<parameter><decl><type><name>RelabelType</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>deparse_expr_cxt</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>deparseExpr</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>arg</name></name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>relabelformat</name></name> <operator>!=</operator> <name>COERCE_IMPLICIT_CAST</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name><name>context</name><operator>-&gt;</operator><name>buf</name></name></expr></argument>, <argument><expr><literal type="string">"::%s"</literal></expr></argument>,
						 <argument><expr><call><name>deparse_type_name</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>resulttype</name></name></expr></argument>,
										   <argument><expr><name><name>node</name><operator>-&gt;</operator><name>resulttypmod</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Deparse a BoolExpr node.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>deparseBoolExpr</name><parameter_list>(<parameter><decl><type><name>BoolExpr</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>deparse_expr_cxt</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>StringInfo</name></type>	<name>buf</name> <init>= <expr><name><name>context</name><operator>-&gt;</operator><name>buf</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>op</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>		<comment type="block">/* keep compiler quiet */</comment>
	<decl_stmt><decl><type><name>bool</name></type>		<name>first</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

	<switch>switch <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>boolop</name></name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>AND_EXPR</name></expr>:</case>
			<expr_stmt><expr><name>op</name> <operator>=</operator> <literal type="string">"AND"</literal></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>OR_EXPR</name></expr>:</case>
			<expr_stmt><expr><name>op</name> <operator>=</operator> <literal type="string">"OR"</literal></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>NOT_EXPR</name></expr>:</case>
			<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"(NOT "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>deparseExpr</name><argument_list>(<argument><expr><call><name>linitial</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="char">')'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return;</return>
	</block_content>}</block></switch>

	<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="char">'('</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>first</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>node-&gt;args</argument>)</argument_list></macro>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>first</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">" %s "</literal></expr></argument>, <argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>deparseExpr</name><argument_list>(<argument><expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>first</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	</block_content>}</block>
	<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="char">')'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Deparse IS [NOT] NULL expression.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>deparseNullTest</name><parameter_list>(<parameter><decl><type><name>NullTest</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>deparse_expr_cxt</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>StringInfo</name></type>	<name>buf</name> <init>= <expr><name><name>context</name><operator>-&gt;</operator><name>buf</name></name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="char">'('</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>deparseExpr</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>arg</name></name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * For scalar inputs, we prefer to print as IS [NOT] NULL, which is
	 * shorter and traditional.  If it's a rowtype input but we're applying a
	 * scalar test, must print IS [NOT] DISTINCT FROM NULL to be semantically
	 * correct.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>argisrow</name></name> <operator>||</operator> <operator>!</operator><call><name>type_is_rowtype</name><argument_list>(<argument><expr><call><name>exprType</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>node</name><operator>-&gt;</operator><name>arg</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>nulltesttype</name></name> <operator>==</operator> <name>IS_NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">" IS NULL)"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">" IS NOT NULL)"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>nulltesttype</name></name> <operator>==</operator> <name>IS_NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">" IS NOT DISTINCT FROM NULL)"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">" IS DISTINCT FROM NULL)"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Deparse ARRAY[...] construct.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>deparseArrayExpr</name><parameter_list>(<parameter><decl><type><name>ArrayExpr</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>deparse_expr_cxt</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>StringInfo</name></type>	<name>buf</name> <init>= <expr><name><name>context</name><operator>-&gt;</operator><name>buf</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>first</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"ARRAY["</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>node-&gt;elements</argument>)</argument_list></macro>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>first</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">", "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>deparseExpr</name><argument_list>(<argument><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>first</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	</block_content>}</block>
	<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="char">']'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* If the array is empty, we need an explicit cast to the array type. */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>elements</name></name> <operator>==</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"::%s"</literal></expr></argument>,
						 <argument><expr><call><name>deparse_type_name</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>array_typeid</name></name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Deparse an Aggref node.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>deparseAggref</name><parameter_list>(<parameter><decl><type><name>Aggref</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>deparse_expr_cxt</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>StringInfo</name></type>	<name>buf</name> <init>= <expr><name><name>context</name><operator>-&gt;</operator><name>buf</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>use_variadic</name></decl>;</decl_stmt>

	<comment type="block">/* Only basic, non-split aggregation accepted. */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>aggsplit</name></name> <operator>==</operator> <name>AGGSPLIT_SIMPLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Check if need to print VARIADIC (cf. ruleutils.c) */</comment>
	<expr_stmt><expr><name>use_variadic</name> <operator>=</operator> <name><name>node</name><operator>-&gt;</operator><name>aggvariadic</name></name></expr>;</expr_stmt>

	<comment type="block">/* Find aggregate name from aggfnoid which is a pg_proc entry */</comment>
	<expr_stmt><expr><call><name>appendFunctionName</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>aggfnoid</name></name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="char">'('</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Add DISTINCT */</comment>
	<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><ternary><condition><expr><operator>(</operator><name><name>node</name><operator>-&gt;</operator><name>aggdistinct</name></name> <operator>!=</operator> <name>NIL</name><operator>)</operator></expr> ?</condition><then> <expr><literal type="string">"DISTINCT "</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>AGGKIND_IS_ORDERED_SET</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>aggkind</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Add WITHIN GROUP (ORDER BY ..) */</comment>
		<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>arg</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>first</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name><name>node</name><operator>-&gt;</operator><name>aggvariadic</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>aggorder</name></name> <operator>!=</operator> <name>NIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<macro><name>foreach</name><argument_list>(<argument>arg</argument>, <argument>node-&gt;aggdirectargs</argument>)</argument_list></macro>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>first</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">", "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><name>first</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>deparseExpr</name><argument_list>(<argument><expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>

		<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">") WITHIN GROUP (ORDER BY "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>appendAggOrderBy</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>aggorder</name></name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>args</name></name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* aggstar can be set only in zero-argument aggregates */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>aggstar</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="char">'*'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else
		<block>{<block_content>
			<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>arg</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>bool</name></type>		<name>first</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>

			<comment type="block">/* Add all the arguments */</comment>
			<macro><name>foreach</name><argument_list>(<argument>arg</argument>, <argument>node-&gt;args</argument>)</argument_list></macro>
			<block>{<block_content>
				<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>tle</name> <init>= <expr><operator>(</operator><name>TargetEntry</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>n</name> <init>= <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>tle</name><operator>-&gt;</operator><name>expr</name></name></expr></init></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><name><name>tle</name><operator>-&gt;</operator><name>resjunk</name></name></expr>)</condition><block type="pseudo"><block_content>
					<continue>continue;</continue></block_content></block></if></if_stmt>

				<if_stmt><if>if <condition>(<expr><operator>!</operator><name>first</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">", "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<expr_stmt><expr><name>first</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

				<comment type="block">/* Add VARIADIC */</comment>
				<if_stmt><if>if <condition>(<expr><name>use_variadic</name> <operator>&amp;&amp;</operator> <call><name>lnext</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"VARIADIC "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

				<expr_stmt><expr><call><name>deparseExpr</name><argument_list>(<argument><expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>n</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block>
		</block_content>}</block></else></if_stmt>

		<comment type="block">/* Add ORDER BY */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>aggorder</name></name> <operator>!=</operator> <name>NIL</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">" ORDER BY "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>appendAggOrderBy</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>aggorder</name></name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>args</name></name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/* Add FILTER (WHERE ..) */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>aggfilter</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">") FILTER (WHERE "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>deparseExpr</name><argument_list>(<argument><expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name><name>node</name><operator>-&gt;</operator><name>aggfilter</name></name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="char">')'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Append ORDER BY within aggregate function.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>appendAggOrderBy</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>orderList</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>targetList</name></decl></parameter>, <parameter><decl><type><name>deparse_expr_cxt</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>StringInfo</name></type>	<name>buf</name> <init>= <expr><name><name>context</name><operator>-&gt;</operator><name>buf</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>first</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>

	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>orderList</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>SortGroupClause</name> <modifier>*</modifier></type><name>srt</name> <init>= <expr><operator>(</operator><name>SortGroupClause</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>sortexpr</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>sortcoltype</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>TypeCacheEntry</name> <modifier>*</modifier></type><name>typentry</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>first</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">", "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>first</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

		<expr_stmt><expr><name>sortexpr</name> <operator>=</operator> <call><name>deparseSortGroupClause</name><argument_list>(<argument><expr><name><name>srt</name><operator>-&gt;</operator><name>tleSortGroupRef</name></name></expr></argument>, <argument><expr><name>targetList</name></expr></argument>,
										  <argument><expr><name>false</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>sortcoltype</name> <operator>=</operator> <call><name>exprType</name><argument_list>(<argument><expr><name>sortexpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* See whether operator is default &lt; or &gt; for datatype */</comment>
		<expr_stmt><expr><name>typentry</name> <operator>=</operator> <call><name>lookup_type_cache</name><argument_list>(<argument><expr><name>sortcoltype</name></expr></argument>,
									 <argument><expr><name>TYPECACHE_LT_OPR</name> <operator>|</operator> <name>TYPECACHE_GT_OPR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>srt</name><operator>-&gt;</operator><name>sortop</name></name> <operator>==</operator> <name><name>typentry</name><operator>-&gt;</operator><name>lt_opr</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">" ASC"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><name><name>srt</name><operator>-&gt;</operator><name>sortop</name></name> <operator>==</operator> <name><name>typentry</name><operator>-&gt;</operator><name>gt_opr</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">" DESC"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else
		<block>{<block_content>
			<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>opertup</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Form_pg_operator</name></type> <name>operform</name></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">" USING "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* Append operator name. */</comment>
			<expr_stmt><expr><name>opertup</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>OPEROID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name><name>srt</name><operator>-&gt;</operator><name>sortop</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>opertup</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for operator %u"</literal></expr></argument>, <argument><expr><name><name>srt</name><operator>-&gt;</operator><name>sortop</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><name>operform</name> <operator>=</operator> <operator>(</operator><name>Form_pg_operator</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>opertup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>deparseOperatorName</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>operform</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>opertup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>srt</name><operator>-&gt;</operator><name>nulls_first</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">" NULLS FIRST"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">" NULLS LAST"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block>
</block_content>}</block></function>

<comment type="block">/*
 * Print the representation of a parameter to be sent to the remote side.
 *
 * Note: we always label the Param's type explicitly rather than relying on
 * transmitting a numeric type OID in PQexecParams().  This allows us to
 * avoid assuming that types have the same OIDs on the remote side as they
 * do locally --- they need only have the same names.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>printRemoteParam</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>paramindex</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>paramtype</name></decl></parameter>, <parameter><decl><type><name>int32</name></type> <name>paramtypmod</name></decl></parameter>,
				 <parameter><decl><type><name>deparse_expr_cxt</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>StringInfo</name></type>	<name>buf</name> <init>= <expr><name><name>context</name><operator>-&gt;</operator><name>buf</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>ptypename</name> <init>= <expr><call><name>deparse_type_name</name><argument_list>(<argument><expr><name>paramtype</name></expr></argument>, <argument><expr><name>paramtypmod</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"$%d::%s"</literal></expr></argument>, <argument><expr><name>paramindex</name></expr></argument>, <argument><expr><name>ptypename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Print the representation of a placeholder for a parameter that will be
 * sent to the remote side at execution time.
 *
 * This is used when we're just trying to EXPLAIN the remote query.
 * We don't have the actual value of the runtime parameter yet, and we don't
 * want the remote planner to generate a plan that depends on such a value
 * anyway.  Thus, we can't do something simple like "$1::paramtype".
 * Instead, we emit "((SELECT null::paramtype)::paramtype)".
 * In all extant versions of Postgres, the planner will see that as an unknown
 * constant value, which is what we want.  This might need adjustment if we
 * ever make the planner flatten scalar subqueries.  Note: the reason for the
 * apparently useless outer cast is to ensure that the representation as a
 * whole will be parsed as an a_expr and not a select_with_parens; the latter
 * would do the wrong thing in the context "x = ANY(...)".
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>printRemotePlaceholder</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>paramtype</name></decl></parameter>, <parameter><decl><type><name>int32</name></type> <name>paramtypmod</name></decl></parameter>,
					   <parameter><decl><type><name>deparse_expr_cxt</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>StringInfo</name></type>	<name>buf</name> <init>= <expr><name><name>context</name><operator>-&gt;</operator><name>buf</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>ptypename</name> <init>= <expr><call><name>deparse_type_name</name><argument_list>(<argument><expr><name>paramtype</name></expr></argument>, <argument><expr><name>paramtypmod</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"((SELECT null::%s)::%s)"</literal></expr></argument>, <argument><expr><name>ptypename</name></expr></argument>, <argument><expr><name>ptypename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Deparse GROUP BY clause.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>appendGroupByClause</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>tlist</name></decl></parameter>, <parameter><decl><type><name>deparse_expr_cxt</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>StringInfo</name></type>	<name>buf</name> <init>= <expr><name><name>context</name><operator>-&gt;</operator><name>buf</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Query</name>	   <modifier>*</modifier></type><name>query</name> <init>= <expr><name><name>context</name><operator>-&gt;</operator><name>root</name><operator>-&gt;</operator><name>parse</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>first</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* Nothing to be done, if there's no GROUP BY clause in the query. */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>query</name><operator>-&gt;</operator><name>groupClause</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">" GROUP BY "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Queries with grouping sets are not pushed down, so we don't expect
	 * grouping sets here.
	 */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name><name>query</name><operator>-&gt;</operator><name>groupingSets</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>query-&gt;groupClause</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>SortGroupClause</name> <modifier>*</modifier></type><name>grp</name> <init>= <expr><operator>(</operator><name>SortGroupClause</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>first</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">", "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>first</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>deparseSortGroupClause</name><argument_list>(<argument><expr><name><name>grp</name><operator>-&gt;</operator><name>tleSortGroupRef</name></name></expr></argument>, <argument><expr><name>tlist</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
</block_content>}</block></function>

<comment type="block">/*
 * Deparse ORDER BY clause according to the given pathkeys for given base
 * relation. From given pathkeys expressions belonging entirely to the given
 * base relation are obtained and deparsed.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>appendOrderByClause</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>pathkeys</name></decl></parameter>, <parameter><decl><type><name>deparse_expr_cxt</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lcell</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>nestlevel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>delim</name> <init>= <expr><literal type="string">" "</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>baserel</name> <init>= <expr><name><name>context</name><operator>-&gt;</operator><name>scanrel</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>StringInfo</name></type>	<name>buf</name> <init>= <expr><name><name>context</name><operator>-&gt;</operator><name>buf</name></name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* Make sure any constants in the exprs are printed portably */</comment>
	<expr_stmt><expr><name>nestlevel</name> <operator>=</operator> <call><name>set_transmission_modes</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">" ORDER BY"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<macro><name>foreach</name><argument_list>(<argument>lcell</argument>, <argument>pathkeys</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>PathKey</name>    <modifier>*</modifier></type><name>pathkey</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lcell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Expr</name>	   <modifier>*</modifier></type><name>em_expr</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>em_expr</name> <operator>=</operator> <call><name>find_em_expr_for_rel</name><argument_list>(<argument><expr><name><name>pathkey</name><operator>-&gt;</operator><name>pk_eclass</name></name></expr></argument>, <argument><expr><name>baserel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>em_expr</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>delim</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>deparseExpr</name><argument_list>(<argument><expr><name>em_expr</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>pathkey</name><operator>-&gt;</operator><name>pk_strategy</name></name> <operator>==</operator> <name>BTLessStrategyNumber</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">" ASC"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">" DESC"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>pathkey</name><operator>-&gt;</operator><name>pk_nulls_first</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">" NULLS FIRST"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">" NULLS LAST"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<expr_stmt><expr><name>delim</name> <operator>=</operator> <literal type="string">", "</literal></expr>;</expr_stmt>
	</block_content>}</block>
	<expr_stmt><expr><call><name>reset_transmission_modes</name><argument_list>(<argument><expr><name>nestlevel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * appendFunctionName
 *		Deparses function name from given function oid.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>appendFunctionName</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>funcid</name></decl></parameter>, <parameter><decl><type><name>deparse_expr_cxt</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>StringInfo</name></type>	<name>buf</name> <init>= <expr><name><name>context</name><operator>-&gt;</operator><name>buf</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>proctup</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Form_pg_proc</name></type> <name>procform</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>proname</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>proctup</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>PROCOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>funcid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>proctup</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for function %u"</literal></expr></argument>, <argument><expr><name>funcid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>procform</name> <operator>=</operator> <operator>(</operator><name>Form_pg_proc</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>proctup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Print schema name only if it's not pg_catalog */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>procform</name><operator>-&gt;</operator><name>pronamespace</name></name> <operator>!=</operator> <name>PG_CATALOG_NAMESPACE</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>schemaname</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>schemaname</name> <operator>=</operator> <call><name>get_namespace_name</name><argument_list>(<argument><expr><name><name>procform</name><operator>-&gt;</operator><name>pronamespace</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"%s."</literal></expr></argument>, <argument><expr><call><name>quote_identifier</name><argument_list>(<argument><expr><name>schemaname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Always print the function name */</comment>
	<expr_stmt><expr><name>proname</name> <operator>=</operator> <call><name>NameStr</name><argument_list>(<argument><expr><name><name>procform</name><operator>-&gt;</operator><name>proname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><call><name>quote_identifier</name><argument_list>(<argument><expr><name>proname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>proctup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Appends a sort or group clause.
 *
 * Like get_rule_sortgroupclause(), returns the expression tree, so caller
 * need not find it again.
 */</comment>
<function><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type>
<name>deparseSortGroupClause</name><parameter_list>(<parameter><decl><type><name>Index</name></type> <name>ref</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>tlist</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>force_colno</name></decl></parameter>,
					   <parameter><decl><type><name>deparse_expr_cxt</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>StringInfo</name></type>	<name>buf</name> <init>= <expr><name><name>context</name><operator>-&gt;</operator><name>buf</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>tle</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Expr</name>	   <modifier>*</modifier></type><name>expr</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>tle</name> <operator>=</operator> <call><name>get_sortgroupref_tle</name><argument_list>(<argument><expr><name>ref</name></expr></argument>, <argument><expr><name>tlist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>expr</name> <operator>=</operator> <name><name>tle</name><operator>-&gt;</operator><name>expr</name></name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>force_colno</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Use column-number form when requested by caller. */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name><name>tle</name><operator>-&gt;</operator><name>resjunk</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"%d"</literal></expr></argument>, <argument><expr><name><name>tle</name><operator>-&gt;</operator><name>resno</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>expr</name> <operator>&amp;&amp;</operator> <call><name>IsA</name><argument_list>(<argument><expr><name>expr</name></expr></argument>, <argument><expr><name>Const</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Force a typecast here so that we don't emit something like "GROUP
		 * BY 2", which will be misconstrued as a column position rather than
		 * a constant.
		 */</comment>
		<expr_stmt><expr><call><name>deparseConst</name><argument_list>(<argument><expr><operator>(</operator><name>Const</name> <operator>*</operator><operator>)</operator> <name>expr</name></expr></argument>, <argument><expr><name>context</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><operator>!</operator><name>expr</name> <operator>||</operator> <call><name>IsA</name><argument_list>(<argument><expr><name>expr</name></expr></argument>, <argument><expr><name>Var</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>deparseExpr</name><argument_list>(<argument><expr><name>expr</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* Always parenthesize the expression. */</comment>
		<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="char">'('</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>deparseExpr</name><argument_list>(<argument><expr><name>expr</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="char">')'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>expr</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * Returns true if given Var is deparsed as a subquery output column, in
 * which case, *relno and *colno are set to the IDs for the relation and
 * column alias to the Var provided by the subquery.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>is_subquery_var</name><parameter_list>(<parameter><decl><type><name>Var</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>foreignrel</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>relno</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>colno</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PgFdwRelationInfo</name> <modifier>*</modifier></type><name>fpinfo</name> <init>= <expr><operator>(</operator><name>PgFdwRelationInfo</name> <operator>*</operator><operator>)</operator> <name><name>foreignrel</name><operator>-&gt;</operator><name>fdw_private</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>outerrel</name> <init>= <expr><name><name>fpinfo</name><operator>-&gt;</operator><name>outerrel</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>innerrel</name> <init>= <expr><name><name>fpinfo</name><operator>-&gt;</operator><name>innerrel</name></name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* Should only be called in these cases. */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>IS_SIMPLE_REL</name><argument_list>(<argument><expr><name>foreignrel</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>IS_JOIN_REL</name><argument_list>(<argument><expr><name>foreignrel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If the given relation isn't a join relation, it doesn't have any lower
	 * subqueries, so the Var isn't a subquery output column.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IS_JOIN_REL</name><argument_list>(<argument><expr><name>foreignrel</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * If the Var doesn't belong to any lower subqueries, it isn't a subquery
	 * output column.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>bms_is_member</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>varno</name></name></expr></argument>, <argument><expr><name><name>fpinfo</name><operator>-&gt;</operator><name>lower_subquery_rels</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>bms_is_member</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>varno</name></name></expr></argument>, <argument><expr><name><name>outerrel</name><operator>-&gt;</operator><name>relids</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * If outer relation is deparsed as a subquery, the Var is an output
		 * column of the subquery; get the IDs for the relation/column alias.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>fpinfo</name><operator>-&gt;</operator><name>make_outerrel_subquery</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>get_relation_column_alias_ids</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>outerrel</name></expr></argument>, <argument><expr><name>relno</name></expr></argument>, <argument><expr><name>colno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>true</name></expr>;</return>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* Otherwise, recurse into the outer relation. */</comment>
		<return>return <expr><call><name>is_subquery_var</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>outerrel</name></expr></argument>, <argument><expr><name>relno</name></expr></argument>, <argument><expr><name>colno</name></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>bms_is_member</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>varno</name></name></expr></argument>, <argument><expr><name><name>innerrel</name><operator>-&gt;</operator><name>relids</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * If inner relation is deparsed as a subquery, the Var is an output
		 * column of the subquery; get the IDs for the relation/column alias.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>fpinfo</name><operator>-&gt;</operator><name>make_innerrel_subquery</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>get_relation_column_alias_ids</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>innerrel</name></expr></argument>, <argument><expr><name>relno</name></expr></argument>, <argument><expr><name>colno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>true</name></expr>;</return>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* Otherwise, recurse into the inner relation. */</comment>
		<return>return <expr><call><name>is_subquery_var</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>innerrel</name></expr></argument>, <argument><expr><name>relno</name></expr></argument>, <argument><expr><name>colno</name></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Get the IDs for the relation and column alias to given Var belonging to
 * given relation, which are returned into *relno and *colno.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>get_relation_column_alias_ids</name><parameter_list>(<parameter><decl><type><name>Var</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>foreignrel</name></decl></parameter>,
							  <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>relno</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>colno</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PgFdwRelationInfo</name> <modifier>*</modifier></type><name>fpinfo</name> <init>= <expr><operator>(</operator><name>PgFdwRelationInfo</name> <operator>*</operator><operator>)</operator> <name><name>foreignrel</name><operator>-&gt;</operator><name>fdw_private</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

	<comment type="block">/* Get the relation alias ID */</comment>
	<expr_stmt><expr><operator>*</operator><name>relno</name> <operator>=</operator> <name><name>fpinfo</name><operator>-&gt;</operator><name>relation_index</name></name></expr>;</expr_stmt>

	<comment type="block">/* Get the column alias ID */</comment>
	<expr_stmt><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>foreignrel-&gt;reltarget-&gt;exprs</argument>)</argument_list></macro>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>equal</name><argument_list>(<argument><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><operator>*</operator><name>colno</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
			<return>return;</return>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block>

	<comment type="block">/* Shouldn't get here */</comment>
	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unexpected expression in subquery output"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
</unit>
