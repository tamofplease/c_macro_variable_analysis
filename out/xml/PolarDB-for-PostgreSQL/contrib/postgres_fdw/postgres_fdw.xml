<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/PolarDB-for-PostgreSQL/contrib/postgres_fdw/postgres_fdw.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * postgres_fdw.c
 *		  Foreign-data wrapper for remote PostgreSQL servers
 *
 * Portions Copyright (c) 2012-2018, PostgreSQL Global Development Group
 *
 * IDENTIFICATION
 *		  contrib/postgres_fdw/postgres_fdw.c
 *
 *-------------------------------------------------------------------------
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres_fdw.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/htup_details.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/sysattr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_class.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/defrem.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/explain.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/vacuum.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"foreign/fdwapi.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"funcapi.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/makefuncs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/nodeFuncs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/cost.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/clauses.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/pathnode.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/paths.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/planmain.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/restrictinfo.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/var.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/tlist.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parsetree.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/builtins.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/guc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/lsyscache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/memutils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/rel.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/sampling.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/selfuncs.h"</cpp:file></cpp:include>

<expr_stmt><expr><name>PG_MODULE_MAGIC</name></expr>;</expr_stmt>

<comment type="block">/* Default CPU cost to start up a foreign query. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DEFAULT_FDW_STARTUP_COST</name></cpp:macro>	<cpp:value>100.0</cpp:value></cpp:define>

<comment type="block">/* Default CPU cost to process 1 row (above and beyond cpu_tuple_cost). */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DEFAULT_FDW_TUPLE_COST</name></cpp:macro>		<cpp:value>0.01</cpp:value></cpp:define>

<comment type="block">/* If no remote estimates, assume a sort costs 20% extra */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DEFAULT_FDW_SORT_MULTIPLIER</name></cpp:macro> <cpp:value>1.2</cpp:value></cpp:define>

<comment type="block">/*
 * Indexes of FDW-private information stored in fdw_private lists.
 *
 * These items are indexed with the enum FdwScanPrivateIndex, so an item
 * can be fetched with list_nth().  For example, to get the SELECT statement:
 *		sql = strVal(list_nth(fdw_private, FdwScanPrivateSelectSql));
 */</comment>
<enum>enum <name>FdwScanPrivateIndex</name>
<block>{
	<comment type="block">/* SQL statement to execute remotely (as a String node) */</comment>
	<decl><name>FdwScanPrivateSelectSql</name></decl>,
	<comment type="block">/* Integer list of attribute numbers retrieved by the SELECT */</comment>
	<decl><name>FdwScanPrivateRetrievedAttrs</name></decl>,
	<comment type="block">/* Integer representing the desired fetch_size */</comment>
	<decl><name>FdwScanPrivateFetchSize</name></decl>,

	<comment type="block">/*
	 * String describing join i.e. names of relations being joined and types
	 * of join, added when the scan is join
	 */</comment>
	<decl><name>FdwScanPrivateRelations</name></decl>
}</block>;</enum>

<comment type="block">/*
 * Similarly, this enum describes what's kept in the fdw_private list for
 * a ModifyTable node referencing a postgres_fdw foreign table.  We store:
 *
 * 1) INSERT/UPDATE/DELETE statement text to be sent to the remote server
 * 2) Integer list of target attribute numbers for INSERT/UPDATE
 *	  (NIL for a DELETE)
 * 3) Boolean flag showing if the remote query has a RETURNING clause
 * 4) Integer list of attribute numbers retrieved by RETURNING, if any
 */</comment>
<enum>enum <name>FdwModifyPrivateIndex</name>
<block>{
	<comment type="block">/* SQL statement to execute remotely (as a String node) */</comment>
	<decl><name>FdwModifyPrivateUpdateSql</name></decl>,
	<comment type="block">/* Integer list of target attribute numbers for INSERT/UPDATE */</comment>
	<decl><name>FdwModifyPrivateTargetAttnums</name></decl>,
	<comment type="block">/* has-returning flag (as an integer Value node) */</comment>
	<decl><name>FdwModifyPrivateHasReturning</name></decl>,
	<comment type="block">/* Integer list of attribute numbers retrieved by RETURNING */</comment>
	<decl><name>FdwModifyPrivateRetrievedAttrs</name></decl>
}</block>;</enum>

<comment type="block">/*
 * Similarly, this enum describes what's kept in the fdw_private list for
 * a ForeignScan node that modifies a foreign table directly.  We store:
 *
 * 1) UPDATE/DELETE statement text to be sent to the remote server
 * 2) Boolean flag showing if the remote query has a RETURNING clause
 * 3) Integer list of attribute numbers retrieved by RETURNING, if any
 * 4) Boolean flag showing if we set the command es_processed
 */</comment>
<enum>enum <name>FdwDirectModifyPrivateIndex</name>
<block>{
	<comment type="block">/* SQL statement to execute remotely (as a String node) */</comment>
	<decl><name>FdwDirectModifyPrivateUpdateSql</name></decl>,
	<comment type="block">/* has-returning flag (as an integer Value node) */</comment>
	<decl><name>FdwDirectModifyPrivateHasReturning</name></decl>,
	<comment type="block">/* Integer list of attribute numbers retrieved by RETURNING */</comment>
	<decl><name>FdwDirectModifyPrivateRetrievedAttrs</name></decl>,
	<comment type="block">/* set-processed flag (as an integer Value node) */</comment>
	<decl><name>FdwDirectModifyPrivateSetProcessed</name></decl>
}</block>;</enum>

<comment type="block">/*
 * Execution state of a foreign scan using postgres_fdw.
 */</comment>
<typedef>typedef <type><struct>struct <name>PgFdwScanState</name>
<block>{
	<decl_stmt><decl><type><name>Relation</name></type>	<name>rel</name></decl>;</decl_stmt>			<comment type="block">/* relcache entry for the foreign table. NULL
								 * for a foreign join scan. */</comment>
	<decl_stmt><decl><type><name>TupleDesc</name></type>	<name>tupdesc</name></decl>;</decl_stmt>		<comment type="block">/* tuple descriptor of scan */</comment>
	<decl_stmt><decl><type><name>AttInMetadata</name> <modifier>*</modifier></type><name>attinmeta</name></decl>;</decl_stmt>	<comment type="block">/* attribute datatype conversion metadata */</comment>

	<comment type="block">/* extracted fdw_private data */</comment>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>query</name></decl>;</decl_stmt>			<comment type="block">/* text of SELECT command */</comment>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>retrieved_attrs</name></decl>;</decl_stmt>	<comment type="block">/* list of retrieved attribute numbers */</comment>

	<comment type="block">/* for remote query execution */</comment>
	<decl_stmt><decl><type><name>PGconn</name>	   <modifier>*</modifier></type><name>conn</name></decl>;</decl_stmt>			<comment type="block">/* connection for the scan */</comment>
	<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>cursor_number</name></decl>;</decl_stmt> <comment type="block">/* quasi-unique ID for my cursor */</comment>
	<decl_stmt><decl><type><name>bool</name></type>		<name>cursor_exists</name></decl>;</decl_stmt>	<comment type="block">/* have we created the cursor? */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>numParams</name></decl>;</decl_stmt>		<comment type="block">/* number of parameters passed to query */</comment>
	<decl_stmt><decl><type><name>FmgrInfo</name>   <modifier>*</modifier></type><name>param_flinfo</name></decl>;</decl_stmt>	<comment type="block">/* output conversion functions for them */</comment>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>param_exprs</name></decl>;</decl_stmt>	<comment type="block">/* executable expressions for param values */</comment>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>param_values</name></decl>;</decl_stmt>	<comment type="block">/* textual values of query parameters */</comment>

	<comment type="block">/* for storing result tuples */</comment>
	<decl_stmt><decl><type><name>HeapTuple</name>  <modifier>*</modifier></type><name>tuples</name></decl>;</decl_stmt>			<comment type="block">/* array of currently-retrieved tuples */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>num_tuples</name></decl>;</decl_stmt>		<comment type="block">/* # of tuples in array */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>next_tuple</name></decl>;</decl_stmt>		<comment type="block">/* index of next one to return */</comment>

	<comment type="block">/* batch-level state, for optimizing rewinds and avoiding useless fetch */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>fetch_ct_2</name></decl>;</decl_stmt>		<comment type="block">/* Min(# of fetches done, 2) */</comment>
	<decl_stmt><decl><type><name>bool</name></type>		<name>eof_reached</name></decl>;</decl_stmt>	<comment type="block">/* true if last fetch reached EOF */</comment>

	<comment type="block">/* working memory contexts */</comment>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>batch_cxt</name></decl>;</decl_stmt>	<comment type="block">/* context holding current batch of tuples */</comment>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>temp_cxt</name></decl>;</decl_stmt>		<comment type="block">/* context for per-tuple temporary data */</comment>

	<decl_stmt><decl><type><name>int</name></type>			<name>fetch_size</name></decl>;</decl_stmt>		<comment type="block">/* number of tuples per fetch */</comment>
}</block></struct></type> <name>PgFdwScanState</name>;</typedef>

<comment type="block">/*
 * Execution state of a foreign insert/update/delete operation.
 */</comment>
<typedef>typedef <type><struct>struct <name>PgFdwModifyState</name>
<block>{
	<decl_stmt><decl><type><name>Relation</name></type>	<name>rel</name></decl>;</decl_stmt>			<comment type="block">/* relcache entry for the foreign table */</comment>
	<decl_stmt><decl><type><name>AttInMetadata</name> <modifier>*</modifier></type><name>attinmeta</name></decl>;</decl_stmt>	<comment type="block">/* attribute datatype conversion metadata */</comment>

	<comment type="block">/* for remote query execution */</comment>
	<decl_stmt><decl><type><name>PGconn</name>	   <modifier>*</modifier></type><name>conn</name></decl>;</decl_stmt>			<comment type="block">/* connection for the scan */</comment>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>p_name</name></decl>;</decl_stmt>			<comment type="block">/* name of prepared statement, if created */</comment>

	<comment type="block">/* extracted fdw_private data */</comment>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>query</name></decl>;</decl_stmt>			<comment type="block">/* text of INSERT/UPDATE/DELETE command */</comment>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>target_attrs</name></decl>;</decl_stmt>	<comment type="block">/* list of target attribute numbers */</comment>
	<decl_stmt><decl><type><name>bool</name></type>		<name>has_returning</name></decl>;</decl_stmt>	<comment type="block">/* is there a RETURNING clause? */</comment>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>retrieved_attrs</name></decl>;</decl_stmt>	<comment type="block">/* attr numbers retrieved by RETURNING */</comment>

	<comment type="block">/* info about parameters for prepared statement */</comment>
	<decl_stmt><decl><type><name>AttrNumber</name></type>	<name>ctidAttno</name></decl>;</decl_stmt>		<comment type="block">/* attnum of input resjunk ctid column */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>p_nums</name></decl>;</decl_stmt>			<comment type="block">/* number of parameters to transmit */</comment>
	<decl_stmt><decl><type><name>FmgrInfo</name>   <modifier>*</modifier></type><name>p_flinfo</name></decl>;</decl_stmt>		<comment type="block">/* output conversion functions for them */</comment>

	<comment type="block">/* working memory context */</comment>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>temp_cxt</name></decl>;</decl_stmt>		<comment type="block">/* context for per-tuple temporary data */</comment>

	<comment type="block">/* for update row movement if subplan result rel */</comment>
	<decl_stmt><decl><type><name><name>struct</name> <name>PgFdwModifyState</name></name> <modifier>*</modifier></type><name>aux_fmstate</name></decl>;</decl_stmt>	<comment type="block">/* foreign-insert state, if
											 * created */</comment>
}</block></struct></type> <name>PgFdwModifyState</name>;</typedef>

<comment type="block">/*
 * Execution state of a foreign scan that modifies a foreign table directly.
 */</comment>
<typedef>typedef <type><struct>struct <name>PgFdwDirectModifyState</name>
<block>{
	<decl_stmt><decl><type><name>Relation</name></type>	<name>rel</name></decl>;</decl_stmt>			<comment type="block">/* relcache entry for the foreign table */</comment>
	<decl_stmt><decl><type><name>AttInMetadata</name> <modifier>*</modifier></type><name>attinmeta</name></decl>;</decl_stmt>	<comment type="block">/* attribute datatype conversion metadata */</comment>

	<comment type="block">/* extracted fdw_private data */</comment>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>query</name></decl>;</decl_stmt>			<comment type="block">/* text of UPDATE/DELETE command */</comment>
	<decl_stmt><decl><type><name>bool</name></type>		<name>has_returning</name></decl>;</decl_stmt>	<comment type="block">/* is there a RETURNING clause? */</comment>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>retrieved_attrs</name></decl>;</decl_stmt>	<comment type="block">/* attr numbers retrieved by RETURNING */</comment>
	<decl_stmt><decl><type><name>bool</name></type>		<name>set_processed</name></decl>;</decl_stmt>	<comment type="block">/* do we set the command es_processed? */</comment>

	<comment type="block">/* for remote query execution */</comment>
	<decl_stmt><decl><type><name>PGconn</name>	   <modifier>*</modifier></type><name>conn</name></decl>;</decl_stmt>			<comment type="block">/* connection for the update */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>numParams</name></decl>;</decl_stmt>		<comment type="block">/* number of parameters passed to query */</comment>
	<decl_stmt><decl><type><name>FmgrInfo</name>   <modifier>*</modifier></type><name>param_flinfo</name></decl>;</decl_stmt>	<comment type="block">/* output conversion functions for them */</comment>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>param_exprs</name></decl>;</decl_stmt>	<comment type="block">/* executable expressions for param values */</comment>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>param_values</name></decl>;</decl_stmt>	<comment type="block">/* textual values of query parameters */</comment>

	<comment type="block">/* for storing result tuples */</comment>
	<decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>			<comment type="block">/* result for query */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>num_tuples</name></decl>;</decl_stmt>		<comment type="block">/* # of result tuples */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>next_tuple</name></decl>;</decl_stmt>		<comment type="block">/* index of next one to return */</comment>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>resultRel</name></decl>;</decl_stmt>		<comment type="block">/* relcache entry for the target relation */</comment>
	<decl_stmt><decl><type><name>AttrNumber</name> <modifier>*</modifier></type><name>attnoMap</name></decl>;</decl_stmt>		<comment type="block">/* array of attnums of input user columns */</comment>
	<decl_stmt><decl><type><name>AttrNumber</name></type>	<name>ctidAttno</name></decl>;</decl_stmt>		<comment type="block">/* attnum of input ctid column */</comment>
	<decl_stmt><decl><type><name>AttrNumber</name></type>	<name>oidAttno</name></decl>;</decl_stmt>		<comment type="block">/* attnum of input oid column */</comment>
	<decl_stmt><decl><type><name>bool</name></type>		<name>hasSystemCols</name></decl>;</decl_stmt>	<comment type="block">/* are there system columns of resultRel? */</comment>

	<comment type="block">/* working memory context */</comment>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>temp_cxt</name></decl>;</decl_stmt>		<comment type="block">/* context for per-tuple temporary data */</comment>
}</block></struct></type> <name>PgFdwDirectModifyState</name>;</typedef>

<comment type="block">/*
 * Workspace for analyzing a foreign table.
 */</comment>
<typedef>typedef <type><struct>struct <name>PgFdwAnalyzeState</name>
<block>{
	<decl_stmt><decl><type><name>Relation</name></type>	<name>rel</name></decl>;</decl_stmt>			<comment type="block">/* relcache entry for the foreign table */</comment>
	<decl_stmt><decl><type><name>AttInMetadata</name> <modifier>*</modifier></type><name>attinmeta</name></decl>;</decl_stmt>	<comment type="block">/* attribute datatype conversion metadata */</comment>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>retrieved_attrs</name></decl>;</decl_stmt>	<comment type="block">/* attr numbers retrieved by query */</comment>

	<comment type="block">/* collected sample rows */</comment>
	<decl_stmt><decl><type><name>HeapTuple</name>  <modifier>*</modifier></type><name>rows</name></decl>;</decl_stmt>			<comment type="block">/* array of size targrows */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>targrows</name></decl>;</decl_stmt>		<comment type="block">/* target # of sample rows */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>numrows</name></decl>;</decl_stmt>		<comment type="block">/* # of sample rows collected */</comment>

	<comment type="block">/* for random sampling */</comment>
	<decl_stmt><decl><type><name>double</name></type>		<name>samplerows</name></decl>;</decl_stmt>		<comment type="block">/* # of rows fetched */</comment>
	<decl_stmt><decl><type><name>double</name></type>		<name>rowstoskip</name></decl>;</decl_stmt>		<comment type="block">/* # of rows to skip before next sample */</comment>
	<decl_stmt><decl><type><name>ReservoirStateData</name></type> <name>rstate</name></decl>;</decl_stmt>	<comment type="block">/* state for reservoir sampling */</comment>

	<comment type="block">/* working memory contexts */</comment>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>anl_cxt</name></decl>;</decl_stmt>		<comment type="block">/* context for per-analyze lifespan data */</comment>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>temp_cxt</name></decl>;</decl_stmt>		<comment type="block">/* context for per-tuple temporary data */</comment>
}</block></struct></type> <name>PgFdwAnalyzeState</name>;</typedef>

<comment type="block">/*
 * Identify the attribute where data conversion fails.
 */</comment>
<typedef>typedef <type><struct>struct <name>ConversionLocation</name>
<block>{
	<decl_stmt><decl><type><name>Relation</name></type>	<name>rel</name></decl>;</decl_stmt>			<comment type="block">/* foreign table's relcache entry. */</comment>
	<decl_stmt><decl><type><name>AttrNumber</name></type>	<name>cur_attno</name></decl>;</decl_stmt>		<comment type="block">/* attribute number being processed, or 0 */</comment>

	<comment type="block">/*
	 * In case of foreign join push down, fdw_scan_tlist is used to identify
	 * the Var node corresponding to the error location and
	 * fsstate-&gt;ss.ps.state gives access to the RTEs of corresponding relation
	 * to get the relation name and attribute name.
	 */</comment>
	<decl_stmt><decl><type><name>ForeignScanState</name> <modifier>*</modifier></type><name>fsstate</name></decl>;</decl_stmt>
}</block></struct></type> <name>ConversionLocation</name>;</typedef>

<comment type="block">/* Callback argument for ec_member_matches_foreign */</comment>
<typedef>typedef <type><struct>struct
<block>{
	<decl_stmt><decl><type><name>Expr</name>	   <modifier>*</modifier></type><name>current</name></decl>;</decl_stmt>		<comment type="block">/* current expr, or NULL if not yet found */</comment>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>already_used</name></decl>;</decl_stmt>	<comment type="block">/* expressions already dealt with */</comment>
}</block></struct></type> <name>ec_member_foreign_arg</name>;</typedef>

<comment type="block">/*
 * SQL functions
 */</comment>
<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>postgres_fdw_handler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/*
 * FDW callback routines
 */</comment>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>postgresGetForeignRelSize</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
						  <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>baserel</name></decl></parameter>,
						  <parameter><decl><type><name>Oid</name></type> <name>foreigntableid</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>postgresGetForeignPaths</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
						<parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>baserel</name></decl></parameter>,
						<parameter><decl><type><name>Oid</name></type> <name>foreigntableid</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>ForeignScan</name> <modifier>*</modifier></type><name>postgresGetForeignPlan</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
					   <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>foreignrel</name></decl></parameter>,
					   <parameter><decl><type><name>Oid</name></type> <name>foreigntableid</name></decl></parameter>,
					   <parameter><decl><type><name>ForeignPath</name> <modifier>*</modifier></type><name>best_path</name></decl></parameter>,
					   <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>tlist</name></decl></parameter>,
					   <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>scan_clauses</name></decl></parameter>,
					   <parameter><decl><type><name>Plan</name> <modifier>*</modifier></type><name>outer_plan</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>postgresBeginForeignScan</name><parameter_list>(<parameter><decl><type><name>ForeignScanState</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>eflags</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>TupleTableSlot</name> <modifier>*</modifier></type><name>postgresIterateForeignScan</name><parameter_list>(<parameter><decl><type><name>ForeignScanState</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>postgresReScanForeignScan</name><parameter_list>(<parameter><decl><type><name>ForeignScanState</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>postgresEndForeignScan</name><parameter_list>(<parameter><decl><type><name>ForeignScanState</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>postgresAddForeignUpdateTargets</name><parameter_list>(<parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>parsetree</name></decl></parameter>,
								<parameter><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>target_rte</name></decl></parameter>,
								<parameter><decl><type><name>Relation</name></type> <name>target_relation</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type><name>postgresPlanForeignModify</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
						  <parameter><decl><type><name>ModifyTable</name> <modifier>*</modifier></type><name>plan</name></decl></parameter>,
						  <parameter><decl><type><name>Index</name></type> <name>resultRelation</name></decl></parameter>,
						  <parameter><decl><type><name>int</name></type> <name>subplan_index</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>postgresBeginForeignModify</name><parameter_list>(<parameter><decl><type><name>ModifyTableState</name> <modifier>*</modifier></type><name>mtstate</name></decl></parameter>,
						   <parameter><decl><type><name>ResultRelInfo</name> <modifier>*</modifier></type><name>resultRelInfo</name></decl></parameter>,
						   <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>fdw_private</name></decl></parameter>,
						   <parameter><decl><type><name>int</name></type> <name>subplan_index</name></decl></parameter>,
						   <parameter><decl><type><name>int</name></type> <name>eflags</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>TupleTableSlot</name> <modifier>*</modifier></type><name>postgresExecForeignInsert</name><parameter_list>(<parameter><decl><type><name>EState</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>,
						  <parameter><decl><type><name>ResultRelInfo</name> <modifier>*</modifier></type><name>resultRelInfo</name></decl></parameter>,
						  <parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl></parameter>,
						  <parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>planSlot</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>TupleTableSlot</name> <modifier>*</modifier></type><name>postgresExecForeignUpdate</name><parameter_list>(<parameter><decl><type><name>EState</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>,
						  <parameter><decl><type><name>ResultRelInfo</name> <modifier>*</modifier></type><name>resultRelInfo</name></decl></parameter>,
						  <parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl></parameter>,
						  <parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>planSlot</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>TupleTableSlot</name> <modifier>*</modifier></type><name>postgresExecForeignDelete</name><parameter_list>(<parameter><decl><type><name>EState</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>,
						  <parameter><decl><type><name>ResultRelInfo</name> <modifier>*</modifier></type><name>resultRelInfo</name></decl></parameter>,
						  <parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl></parameter>,
						  <parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>planSlot</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>postgresEndForeignModify</name><parameter_list>(<parameter><decl><type><name>EState</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>,
						 <parameter><decl><type><name>ResultRelInfo</name> <modifier>*</modifier></type><name>resultRelInfo</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>postgresBeginForeignInsert</name><parameter_list>(<parameter><decl><type><name>ModifyTableState</name> <modifier>*</modifier></type><name>mtstate</name></decl></parameter>,
						   <parameter><decl><type><name>ResultRelInfo</name> <modifier>*</modifier></type><name>resultRelInfo</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>postgresEndForeignInsert</name><parameter_list>(<parameter><decl><type><name>EState</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>,
						 <parameter><decl><type><name>ResultRelInfo</name> <modifier>*</modifier></type><name>resultRelInfo</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type>	<name>postgresIsForeignRelUpdatable</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>postgresPlanDirectModify</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
						 <parameter><decl><type><name>ModifyTable</name> <modifier>*</modifier></type><name>plan</name></decl></parameter>,
						 <parameter><decl><type><name>Index</name></type> <name>resultRelation</name></decl></parameter>,
						 <parameter><decl><type><name>int</name></type> <name>subplan_index</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>postgresBeginDirectModify</name><parameter_list>(<parameter><decl><type><name>ForeignScanState</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>eflags</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>TupleTableSlot</name> <modifier>*</modifier></type><name>postgresIterateDirectModify</name><parameter_list>(<parameter><decl><type><name>ForeignScanState</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>postgresEndDirectModify</name><parameter_list>(<parameter><decl><type><name>ForeignScanState</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>postgresExplainForeignScan</name><parameter_list>(<parameter><decl><type><name>ForeignScanState</name> <modifier>*</modifier></type><name>node</name></decl></parameter>,
						   <parameter><decl><type><name>ExplainState</name> <modifier>*</modifier></type><name>es</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>postgresExplainForeignModify</name><parameter_list>(<parameter><decl><type><name>ModifyTableState</name> <modifier>*</modifier></type><name>mtstate</name></decl></parameter>,
							 <parameter><decl><type><name>ResultRelInfo</name> <modifier>*</modifier></type><name>rinfo</name></decl></parameter>,
							 <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>fdw_private</name></decl></parameter>,
							 <parameter><decl><type><name>int</name></type> <name>subplan_index</name></decl></parameter>,
							 <parameter><decl><type><name>ExplainState</name> <modifier>*</modifier></type><name>es</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>postgresExplainDirectModify</name><parameter_list>(<parameter><decl><type><name>ForeignScanState</name> <modifier>*</modifier></type><name>node</name></decl></parameter>,
							<parameter><decl><type><name>ExplainState</name> <modifier>*</modifier></type><name>es</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>postgresAnalyzeForeignTable</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>relation</name></decl></parameter>,
							<parameter><decl><type><name>AcquireSampleRowsFunc</name> <modifier>*</modifier></type><name>func</name></decl></parameter>,
							<parameter><decl><type><name>BlockNumber</name> <modifier>*</modifier></type><name>totalpages</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type><name>postgresImportForeignSchema</name><parameter_list>(<parameter><decl><type><name>ImportForeignSchemaStmt</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>,
							<parameter><decl><type><name>Oid</name></type> <name>serverOid</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>postgresGetForeignJoinPaths</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
							<parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>joinrel</name></decl></parameter>,
							<parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>outerrel</name></decl></parameter>,
							<parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>innerrel</name></decl></parameter>,
							<parameter><decl><type><name>JoinType</name></type> <name>jointype</name></decl></parameter>,
							<parameter><decl><type><name>JoinPathExtraData</name> <modifier>*</modifier></type><name>extra</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>postgresRecheckForeignScan</name><parameter_list>(<parameter><decl><type><name>ForeignScanState</name> <modifier>*</modifier></type><name>node</name></decl></parameter>,
						   <parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>postgresGetForeignUpperPaths</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
							 <parameter><decl><type><name>UpperRelationKind</name></type> <name>stage</name></decl></parameter>,
							 <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>input_rel</name></decl></parameter>,
							 <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>output_rel</name></decl></parameter>,
							 <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>extra</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/*
 * Helper functions
 */</comment>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>estimate_path_cost_size</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
						<parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>foreignrel</name></decl></parameter>,
						<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>param_join_conds</name></decl></parameter>,
						<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>pathkeys</name></decl></parameter>,
						<parameter><decl><type><name>double</name> <modifier>*</modifier></type><name>p_rows</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>p_width</name></decl></parameter>,
						<parameter><decl><type><name>Cost</name> <modifier>*</modifier></type><name>p_startup_cost</name></decl></parameter>, <parameter><decl><type><name>Cost</name> <modifier>*</modifier></type><name>p_total_cost</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>get_remote_estimate</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>sql</name></decl></parameter>,
					<parameter><decl><type><name>PGconn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>,
					<parameter><decl><type><name>double</name> <modifier>*</modifier></type><name>rows</name></decl></parameter>,
					<parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>width</name></decl></parameter>,
					<parameter><decl><type><name>Cost</name> <modifier>*</modifier></type><name>startup_cost</name></decl></parameter>,
					<parameter><decl><type><name>Cost</name> <modifier>*</modifier></type><name>total_cost</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>ec_member_matches_foreign</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>rel</name></decl></parameter>,
						  <parameter><decl><type><name>EquivalenceClass</name> <modifier>*</modifier></type><name>ec</name></decl></parameter>, <parameter><decl><type><name>EquivalenceMember</name> <modifier>*</modifier></type><name>em</name></decl></parameter>,
						  <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>create_cursor</name><parameter_list>(<parameter><decl><type><name>ForeignScanState</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>fetch_more_data</name><parameter_list>(<parameter><decl><type><name>ForeignScanState</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>close_cursor</name><parameter_list>(<parameter><decl><type><name>PGconn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>cursor_number</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>PgFdwModifyState</name> <modifier>*</modifier></type><name>create_foreign_modify</name><parameter_list>(<parameter><decl><type><name>EState</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>,
					  <parameter><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name></decl></parameter>,
					  <parameter><decl><type><name>ResultRelInfo</name> <modifier>*</modifier></type><name>resultRelInfo</name></decl></parameter>,
					  <parameter><decl><type><name>CmdType</name></type> <name>operation</name></decl></parameter>,
					  <parameter><decl><type><name>Plan</name> <modifier>*</modifier></type><name>subplan</name></decl></parameter>,
					  <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>query</name></decl></parameter>,
					  <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>target_attrs</name></decl></parameter>,
					  <parameter><decl><type><name>bool</name></type> <name>has_returning</name></decl></parameter>,
					  <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>retrieved_attrs</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>prepare_foreign_modify</name><parameter_list>(<parameter><decl><type><name>PgFdwModifyState</name> <modifier>*</modifier></type><name>fmstate</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>convert_prep_stmt_params</name><parameter_list>(<parameter><decl><type><name>PgFdwModifyState</name> <modifier>*</modifier></type><name>fmstate</name></decl></parameter>,
						 <parameter><decl><type><name>ItemPointer</name></type> <name>tupleid</name></decl></parameter>,
						 <parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>store_returning_result</name><parameter_list>(<parameter><decl><type><name>PgFdwModifyState</name> <modifier>*</modifier></type><name>fmstate</name></decl></parameter>,
					   <parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl></parameter>, <parameter><decl><type><name>PGresult</name> <modifier>*</modifier></type><name>res</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>finish_foreign_modify</name><parameter_list>(<parameter><decl><type><name>PgFdwModifyState</name> <modifier>*</modifier></type><name>fmstate</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type><name>build_remote_returning</name><parameter_list>(<parameter><decl><type><name>Index</name></type> <name>rtindex</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>,
					   <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>returningList</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>rebuild_fdw_scan_tlist</name><parameter_list>(<parameter><decl><type><name>ForeignScan</name> <modifier>*</modifier></type><name>fscan</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>tlist</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>execute_dml_stmt</name><parameter_list>(<parameter><decl><type><name>ForeignScanState</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>TupleTableSlot</name> <modifier>*</modifier></type><name>get_returning_data</name><parameter_list>(<parameter><decl><type><name>ForeignScanState</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>init_returning_filter</name><parameter_list>(<parameter><decl><type><name>PgFdwDirectModifyState</name> <modifier>*</modifier></type><name>dmstate</name></decl></parameter>,
					  <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>fdw_scan_tlist</name></decl></parameter>,
					  <parameter><decl><type><name>Index</name></type> <name>rtindex</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>TupleTableSlot</name> <modifier>*</modifier></type><name>apply_returning_filter</name><parameter_list>(<parameter><decl><type><name>PgFdwDirectModifyState</name> <modifier>*</modifier></type><name>dmstate</name></decl></parameter>,
					   <parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl></parameter>,
					   <parameter><decl><type><name>EState</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>prepare_query_params</name><parameter_list>(<parameter><decl><type><name>PlanState</name> <modifier>*</modifier></type><name>node</name></decl></parameter>,
					 <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>fdw_exprs</name></decl></parameter>,
					 <parameter><decl><type><name>int</name></type> <name>numParams</name></decl></parameter>,
					 <parameter><decl><type><name>FmgrInfo</name> <modifier>*</modifier><modifier>*</modifier></type><name>param_flinfo</name></decl></parameter>,
					 <parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>param_exprs</name></decl></parameter>,
					 <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier><modifier>*</modifier></type><name>param_values</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>process_query_params</name><parameter_list>(<parameter><decl><type><name>ExprContext</name> <modifier>*</modifier></type><name>econtext</name></decl></parameter>,
					 <parameter><decl><type><name>FmgrInfo</name> <modifier>*</modifier></type><name>param_flinfo</name></decl></parameter>,
					 <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>param_exprs</name></decl></parameter>,
					 <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>param_values</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>postgresAcquireSampleRowsFunc</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>relation</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>elevel</name></decl></parameter>,
							  <parameter><decl><type><name>HeapTuple</name> <modifier>*</modifier></type><name>rows</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>targrows</name></decl></parameter>,
							  <parameter><decl><type><name>double</name> <modifier>*</modifier></type><name>totalrows</name></decl></parameter>,
							  <parameter><decl><type><name>double</name> <modifier>*</modifier></type><name>totaldeadrows</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>analyze_row_processor</name><parameter_list>(<parameter><decl><type><name>PGresult</name> <modifier>*</modifier></type><name>res</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>row</name></decl></parameter>,
					  <parameter><decl><type><name>PgFdwAnalyzeState</name> <modifier>*</modifier></type><name>astate</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>HeapTuple</name></type> <name>make_tuple_from_result_row</name><parameter_list>(<parameter><decl><type><name>PGresult</name> <modifier>*</modifier></type><name>res</name></decl></parameter>,
						   <parameter><decl><type><name>int</name></type> <name>row</name></decl></parameter>,
						   <parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>,
						   <parameter><decl><type><name>AttInMetadata</name> <modifier>*</modifier></type><name>attinmeta</name></decl></parameter>,
						   <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>retrieved_attrs</name></decl></parameter>,
						   <parameter><decl><type><name>ForeignScanState</name> <modifier>*</modifier></type><name>fsstate</name></decl></parameter>,
						   <parameter><decl><type><name>MemoryContext</name></type> <name>temp_context</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>conversion_error_callback</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>foreign_join_ok</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>joinrel</name></decl></parameter>,
				<parameter><decl><type><name>JoinType</name></type> <name>jointype</name></decl></parameter>, <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>outerrel</name></decl></parameter>, <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>innerrel</name></decl></parameter>,
				<parameter><decl><type><name>JoinPathExtraData</name> <modifier>*</modifier></type><name>extra</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>foreign_grouping_ok</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>grouped_rel</name></decl></parameter>,
					<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>havingQual</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type><name>get_useful_pathkeys_for_relation</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
								 <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>rel</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type><name>get_useful_ecs_for_relation</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>rel</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>add_paths_with_pathkeys_for_rel</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>rel</name></decl></parameter>,
								<parameter><decl><type><name>Path</name> <modifier>*</modifier></type><name>epq_path</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>add_foreign_grouping_paths</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
						   <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>input_rel</name></decl></parameter>,
						   <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>grouped_rel</name></decl></parameter>,
						   <parameter><decl><type><name>GroupPathExtraData</name> <modifier>*</modifier></type><name>extra</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>apply_server_options</name><parameter_list>(<parameter><decl><type><name>PgFdwRelationInfo</name> <modifier>*</modifier></type><name>fpinfo</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>apply_table_options</name><parameter_list>(<parameter><decl><type><name>PgFdwRelationInfo</name> <modifier>*</modifier></type><name>fpinfo</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>merge_fdw_options</name><parameter_list>(<parameter><decl><type><name>PgFdwRelationInfo</name> <modifier>*</modifier></type><name>fpinfo</name></decl></parameter>,
				  <parameter><decl><type><specifier>const</specifier> <name>PgFdwRelationInfo</name> <modifier>*</modifier></type><name>fpinfo_o</name></decl></parameter>,
				  <parameter><decl><type><specifier>const</specifier> <name>PgFdwRelationInfo</name> <modifier>*</modifier></type><name>fpinfo_i</name></decl></parameter>)</parameter_list>;</function_decl>


<comment type="block">/*
 * Foreign-data wrapper handler function: return a struct with pointers
 * to my callback routines.
 */</comment>
<function><type><name>Datum</name></type>
<name>postgres_fdw_handler</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>FdwRoutine</name> <modifier>*</modifier></type><name>routine</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>FdwRoutine</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/* Functions for scanning foreign tables */</comment>
	<expr_stmt><expr><name><name>routine</name><operator>-&gt;</operator><name>GetForeignRelSize</name></name> <operator>=</operator> <name>postgresGetForeignRelSize</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>routine</name><operator>-&gt;</operator><name>GetForeignPaths</name></name> <operator>=</operator> <name>postgresGetForeignPaths</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>routine</name><operator>-&gt;</operator><name>GetForeignPlan</name></name> <operator>=</operator> <name>postgresGetForeignPlan</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>routine</name><operator>-&gt;</operator><name>BeginForeignScan</name></name> <operator>=</operator> <name>postgresBeginForeignScan</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>routine</name><operator>-&gt;</operator><name>IterateForeignScan</name></name> <operator>=</operator> <name>postgresIterateForeignScan</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>routine</name><operator>-&gt;</operator><name>ReScanForeignScan</name></name> <operator>=</operator> <name>postgresReScanForeignScan</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>routine</name><operator>-&gt;</operator><name>EndForeignScan</name></name> <operator>=</operator> <name>postgresEndForeignScan</name></expr>;</expr_stmt>

	<comment type="block">/* Functions for updating foreign tables */</comment>
	<expr_stmt><expr><name><name>routine</name><operator>-&gt;</operator><name>AddForeignUpdateTargets</name></name> <operator>=</operator> <name>postgresAddForeignUpdateTargets</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>routine</name><operator>-&gt;</operator><name>PlanForeignModify</name></name> <operator>=</operator> <name>postgresPlanForeignModify</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>routine</name><operator>-&gt;</operator><name>BeginForeignModify</name></name> <operator>=</operator> <name>postgresBeginForeignModify</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>routine</name><operator>-&gt;</operator><name>ExecForeignInsert</name></name> <operator>=</operator> <name>postgresExecForeignInsert</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>routine</name><operator>-&gt;</operator><name>ExecForeignUpdate</name></name> <operator>=</operator> <name>postgresExecForeignUpdate</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>routine</name><operator>-&gt;</operator><name>ExecForeignDelete</name></name> <operator>=</operator> <name>postgresExecForeignDelete</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>routine</name><operator>-&gt;</operator><name>EndForeignModify</name></name> <operator>=</operator> <name>postgresEndForeignModify</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>routine</name><operator>-&gt;</operator><name>BeginForeignInsert</name></name> <operator>=</operator> <name>postgresBeginForeignInsert</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>routine</name><operator>-&gt;</operator><name>EndForeignInsert</name></name> <operator>=</operator> <name>postgresEndForeignInsert</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>routine</name><operator>-&gt;</operator><name>IsForeignRelUpdatable</name></name> <operator>=</operator> <name>postgresIsForeignRelUpdatable</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>routine</name><operator>-&gt;</operator><name>PlanDirectModify</name></name> <operator>=</operator> <name>postgresPlanDirectModify</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>routine</name><operator>-&gt;</operator><name>BeginDirectModify</name></name> <operator>=</operator> <name>postgresBeginDirectModify</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>routine</name><operator>-&gt;</operator><name>IterateDirectModify</name></name> <operator>=</operator> <name>postgresIterateDirectModify</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>routine</name><operator>-&gt;</operator><name>EndDirectModify</name></name> <operator>=</operator> <name>postgresEndDirectModify</name></expr>;</expr_stmt>

	<comment type="block">/* Function for EvalPlanQual rechecks */</comment>
	<expr_stmt><expr><name><name>routine</name><operator>-&gt;</operator><name>RecheckForeignScan</name></name> <operator>=</operator> <name>postgresRecheckForeignScan</name></expr>;</expr_stmt>
	<comment type="block">/* Support functions for EXPLAIN */</comment>
	<expr_stmt><expr><name><name>routine</name><operator>-&gt;</operator><name>ExplainForeignScan</name></name> <operator>=</operator> <name>postgresExplainForeignScan</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>routine</name><operator>-&gt;</operator><name>ExplainForeignModify</name></name> <operator>=</operator> <name>postgresExplainForeignModify</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>routine</name><operator>-&gt;</operator><name>ExplainDirectModify</name></name> <operator>=</operator> <name>postgresExplainDirectModify</name></expr>;</expr_stmt>

	<comment type="block">/* Support functions for ANALYZE */</comment>
	<expr_stmt><expr><name><name>routine</name><operator>-&gt;</operator><name>AnalyzeForeignTable</name></name> <operator>=</operator> <name>postgresAnalyzeForeignTable</name></expr>;</expr_stmt>

	<comment type="block">/* Support functions for IMPORT FOREIGN SCHEMA */</comment>
	<expr_stmt><expr><name><name>routine</name><operator>-&gt;</operator><name>ImportForeignSchema</name></name> <operator>=</operator> <name>postgresImportForeignSchema</name></expr>;</expr_stmt>

	<comment type="block">/* Support functions for join push-down */</comment>
	<expr_stmt><expr><name><name>routine</name><operator>-&gt;</operator><name>GetForeignJoinPaths</name></name> <operator>=</operator> <name>postgresGetForeignJoinPaths</name></expr>;</expr_stmt>

	<comment type="block">/* Support functions for upper relation push-down */</comment>
	<expr_stmt><expr><name><name>routine</name><operator>-&gt;</operator><name>GetForeignUpperPaths</name></name> <operator>=</operator> <name>postgresGetForeignUpperPaths</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_POINTER</name><argument_list>(<argument><expr><name>routine</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * postgresGetForeignRelSize
 *		Estimate # of rows and width of the result of the scan
 *
 * We should consider the effect of all baserestrictinfo clauses here, but
 * not any join clauses.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>postgresGetForeignRelSize</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
						  <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>baserel</name></decl></parameter>,
						  <parameter><decl><type><name>Oid</name></type> <name>foreigntableid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PgFdwRelationInfo</name> <modifier>*</modifier></type><name>fpinfo</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name> <init>= <expr><call><name>planner_rt_fetch</name><argument_list>(<argument><expr><name><name>baserel</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>, <argument><expr><name>root</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>namespace</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>relname</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>refname</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * We use PgFdwRelationInfo to pass various information to subsequent
	 * functions.
	 */</comment>
	<expr_stmt><expr><name>fpinfo</name> <operator>=</operator> <operator>(</operator><name>PgFdwRelationInfo</name> <operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>PgFdwRelationInfo</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>baserel</name><operator>-&gt;</operator><name>fdw_private</name></name> <operator>=</operator> <operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>fpinfo</name></expr>;</expr_stmt>

	<comment type="block">/* Base foreign tables need to be pushed down always. */</comment>
	<expr_stmt><expr><name><name>fpinfo</name><operator>-&gt;</operator><name>pushdown_safe</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

	<comment type="block">/* Look up foreign-table catalog info. */</comment>
	<expr_stmt><expr><name><name>fpinfo</name><operator>-&gt;</operator><name>table</name></name> <operator>=</operator> <call><name>GetForeignTable</name><argument_list>(<argument><expr><name>foreigntableid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fpinfo</name><operator>-&gt;</operator><name>server</name></name> <operator>=</operator> <call><name>GetForeignServer</name><argument_list>(<argument><expr><name><name>fpinfo</name><operator>-&gt;</operator><name>table</name><operator>-&gt;</operator><name>serverid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Extract user-settable option values.  Note that per-table setting of
	 * use_remote_estimate overrides per-server setting.
	 */</comment>
	<expr_stmt><expr><name><name>fpinfo</name><operator>-&gt;</operator><name>use_remote_estimate</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fpinfo</name><operator>-&gt;</operator><name>fdw_startup_cost</name></name> <operator>=</operator> <name>DEFAULT_FDW_STARTUP_COST</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fpinfo</name><operator>-&gt;</operator><name>fdw_tuple_cost</name></name> <operator>=</operator> <name>DEFAULT_FDW_TUPLE_COST</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fpinfo</name><operator>-&gt;</operator><name>shippable_extensions</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fpinfo</name><operator>-&gt;</operator><name>fetch_size</name></name> <operator>=</operator> <literal type="number">100</literal></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>apply_server_options</name><argument_list>(<argument><expr><name>fpinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>apply_table_options</name><argument_list>(<argument><expr><name>fpinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If the table or the server is configured to use remote estimates,
	 * identify which user to do remote access as during planning.  This
	 * should match what ExecCheckRTEPerms() does.  If we fail due to lack of
	 * permissions, the query would have failed at runtime anyway.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>fpinfo</name><operator>-&gt;</operator><name>use_remote_estimate</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>userid</name> <init>= <expr><ternary><condition><expr><name><name>rte</name><operator>-&gt;</operator><name>checkAsUser</name></name></expr> ?</condition><then> <expr><name><name>rte</name><operator>-&gt;</operator><name>checkAsUser</name></name></expr> </then><else>: <expr><call><name>GetUserId</name><argument_list>()</argument_list></call></expr></else></ternary></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>fpinfo</name><operator>-&gt;</operator><name>user</name></name> <operator>=</operator> <call><name>GetUserMapping</name><argument_list>(<argument><expr><name>userid</name></expr></argument>, <argument><expr><name><name>fpinfo</name><operator>-&gt;</operator><name>server</name><operator>-&gt;</operator><name>serverid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>fpinfo</name><operator>-&gt;</operator><name>user</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/*
	 * Identify which baserestrictinfo clauses can be sent to the remote
	 * server and which can't.
	 */</comment>
	<expr_stmt><expr><call><name>classifyConditions</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>baserel</name></expr></argument>, <argument><expr><name><name>baserel</name><operator>-&gt;</operator><name>baserestrictinfo</name></name></expr></argument>,
					   <argument><expr><operator>&amp;</operator><name><name>fpinfo</name><operator>-&gt;</operator><name>remote_conds</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>fpinfo</name><operator>-&gt;</operator><name>local_conds</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Identify which attributes will need to be retrieved from the remote
	 * server.  These include all attrs needed for joins or final output, plus
	 * all attrs used in the local_conds.  (Note: if we end up using a
	 * parameterized scan, it's possible that some of the join clauses will be
	 * sent to the remote and thus we wouldn't really need to retrieve the
	 * columns used in them.  Doesn't seem worth detecting that case though.)
	 */</comment>
	<expr_stmt><expr><name><name>fpinfo</name><operator>-&gt;</operator><name>attrs_used</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pull_varattnos</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>baserel</name><operator>-&gt;</operator><name>reltarget</name><operator>-&gt;</operator><name>exprs</name></name></expr></argument>, <argument><expr><name><name>baserel</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>,
				   <argument><expr><operator>&amp;</operator><name><name>fpinfo</name><operator>-&gt;</operator><name>attrs_used</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>fpinfo-&gt;local_conds</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>RestrictInfo</name> <modifier>*</modifier></type><name>rinfo</name> <init>= <expr><call><name>lfirst_node</name><argument_list>(<argument><expr><name>RestrictInfo</name></expr></argument>, <argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>pull_varattnos</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>rinfo</name><operator>-&gt;</operator><name>clause</name></name></expr></argument>, <argument><expr><name><name>baserel</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>,
					   <argument><expr><operator>&amp;</operator><name><name>fpinfo</name><operator>-&gt;</operator><name>attrs_used</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<comment type="block">/*
	 * Compute the selectivity and cost of the local_conds, so we don't have
	 * to do it over again for each path.  The best we can do for these
	 * conditions is to estimate selectivity on the basis of local statistics.
	 */</comment>
	<expr_stmt><expr><name><name>fpinfo</name><operator>-&gt;</operator><name>local_conds_sel</name></name> <operator>=</operator> <call><name>clauselist_selectivity</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
													 <argument><expr><name><name>fpinfo</name><operator>-&gt;</operator><name>local_conds</name></name></expr></argument>,
													 <argument><expr><name><name>baserel</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>,
													 <argument><expr><name>JOIN_INNER</name></expr></argument>,
													 <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>cost_qual_eval</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>fpinfo</name><operator>-&gt;</operator><name>local_conds_cost</name></name></expr></argument>, <argument><expr><name><name>fpinfo</name><operator>-&gt;</operator><name>local_conds</name></name></expr></argument>, <argument><expr><name>root</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Set cached relation costs to some negative value, so that we can detect
	 * when they are set to some sensible costs during one (usually the first)
	 * of the calls to estimate_path_cost_size().
	 */</comment>
	<expr_stmt><expr><name><name>fpinfo</name><operator>-&gt;</operator><name>rel_startup_cost</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fpinfo</name><operator>-&gt;</operator><name>rel_total_cost</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>

	<comment type="block">/*
	 * If the table or the server is configured to use remote estimates,
	 * connect to the foreign server and execute EXPLAIN to estimate the
	 * number of rows selected by the restriction clauses, as well as the
	 * average row width.  Otherwise, estimate using whatever statistics we
	 * have locally, in a way similar to ordinary tables.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>fpinfo</name><operator>-&gt;</operator><name>use_remote_estimate</name></name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Get cost/size estimates with help of remote server.  Save the
		 * values in fpinfo so we don't need to do it again to generate the
		 * basic foreign path.
		 */</comment>
		<expr_stmt><expr><call><name>estimate_path_cost_size</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>baserel</name></expr></argument>, <argument><expr><name>NIL</name></expr></argument>, <argument><expr><name>NIL</name></expr></argument>,
								<argument><expr><operator>&amp;</operator><name><name>fpinfo</name><operator>-&gt;</operator><name>rows</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>fpinfo</name><operator>-&gt;</operator><name>width</name></name></expr></argument>,
								<argument><expr><operator>&amp;</operator><name><name>fpinfo</name><operator>-&gt;</operator><name>startup_cost</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>fpinfo</name><operator>-&gt;</operator><name>total_cost</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Report estimated baserel size to planner. */</comment>
		<expr_stmt><expr><name><name>baserel</name><operator>-&gt;</operator><name>rows</name></name> <operator>=</operator> <name><name>fpinfo</name><operator>-&gt;</operator><name>rows</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>baserel</name><operator>-&gt;</operator><name>reltarget</name><operator>-&gt;</operator><name>width</name></name> <operator>=</operator> <name><name>fpinfo</name><operator>-&gt;</operator><name>width</name></name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/*
		 * If the foreign table has never been ANALYZEd, it will have relpages
		 * and reltuples equal to zero, which most likely has nothing to do
		 * with reality.  We can't do a whole lot about that if we're not
		 * allowed to consult the remote server, but we can use a hack similar
		 * to plancat.c's treatment of empty relations: use a minimum size
		 * estimate of 10 pages, and divide by the column-datatype-based width
		 * estimate to get the corresponding number of tuples.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>baserel</name><operator>-&gt;</operator><name>pages</name></name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>baserel</name><operator>-&gt;</operator><name>tuples</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>baserel</name><operator>-&gt;</operator><name>pages</name></name> <operator>=</operator> <literal type="number">10</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>baserel</name><operator>-&gt;</operator><name>tuples</name></name> <operator>=</operator>
				<operator>(</operator><literal type="number">10</literal> <operator>*</operator> <name>BLCKSZ</name> <operator>*</operator> <literal type="number">1.0</literal><operator>)</operator> <operator>/</operator> <operator>(</operator><name><name>baserel</name><operator>-&gt;</operator><name>reltarget</name><operator>-&gt;</operator><name>width</name></name> <operator>+</operator>
								 <call><name>MAXALIGN</name><argument_list>(<argument><expr><name>SizeofHeapTupleHeader</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* Estimate baserel size as best we can with local statistics. */</comment>
		<expr_stmt><expr><call><name>set_baserel_size_estimates</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>baserel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Fill in basically-bogus cost estimates for use later. */</comment>
		<expr_stmt><expr><call><name>estimate_path_cost_size</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>baserel</name></expr></argument>, <argument><expr><name>NIL</name></expr></argument>, <argument><expr><name>NIL</name></expr></argument>,
								<argument><expr><operator>&amp;</operator><name><name>fpinfo</name><operator>-&gt;</operator><name>rows</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>fpinfo</name><operator>-&gt;</operator><name>width</name></name></expr></argument>,
								<argument><expr><operator>&amp;</operator><name><name>fpinfo</name><operator>-&gt;</operator><name>startup_cost</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>fpinfo</name><operator>-&gt;</operator><name>total_cost</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/*
	 * Set the name of relation in fpinfo, while we are constructing it here.
	 * It will be used to build the string describing the join relation in
	 * EXPLAIN output. We can't know whether VERBOSE option is specified or
	 * not, so always schema-qualify the foreign table name.
	 */</comment>
	<expr_stmt><expr><name><name>fpinfo</name><operator>-&gt;</operator><name>relation_name</name></name> <operator>=</operator> <call><name>makeStringInfo</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>namespace</name> <operator>=</operator> <call><name>get_namespace_name</name><argument_list>(<argument><expr><call><name>get_rel_namespace</name><argument_list>(<argument><expr><name>foreigntableid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>relname</name> <operator>=</operator> <call><name>get_rel_name</name><argument_list>(<argument><expr><name>foreigntableid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>refname</name> <operator>=</operator> <name><name>rte</name><operator>-&gt;</operator><name>eref</name><operator>-&gt;</operator><name>aliasname</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name><name>fpinfo</name><operator>-&gt;</operator><name>relation_name</name></name></expr></argument>, <argument><expr><literal type="string">"%s.%s"</literal></expr></argument>,
					 <argument><expr><call><name>quote_identifier</name><argument_list>(<argument><expr><name>namespace</name></expr></argument>)</argument_list></call></expr></argument>,
					 <argument><expr><call><name>quote_identifier</name><argument_list>(<argument><expr><name>relname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>*</operator><name>refname</name> <operator>&amp;&amp;</operator> <call><name>strcmp</name><argument_list>(<argument><expr><name>refname</name></expr></argument>, <argument><expr><name>relname</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name><name>fpinfo</name><operator>-&gt;</operator><name>relation_name</name></name></expr></argument>, <argument><expr><literal type="string">" %s"</literal></expr></argument>,
						 <argument><expr><call><name>quote_identifier</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>eref</name><operator>-&gt;</operator><name>aliasname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* No outer and inner relations. */</comment>
	<expr_stmt><expr><name><name>fpinfo</name><operator>-&gt;</operator><name>make_outerrel_subquery</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fpinfo</name><operator>-&gt;</operator><name>make_innerrel_subquery</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fpinfo</name><operator>-&gt;</operator><name>lower_subquery_rels</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<comment type="block">/* Set the relation index. */</comment>
	<expr_stmt><expr><name><name>fpinfo</name><operator>-&gt;</operator><name>relation_index</name></name> <operator>=</operator> <name><name>baserel</name><operator>-&gt;</operator><name>relid</name></name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * get_useful_ecs_for_relation
 *		Determine which EquivalenceClasses might be involved in useful
 *		orderings of this relation.
 *
 * This function is in some respects a mirror image of the core function
 * pathkeys_useful_for_merging: for a regular table, we know what indexes
 * we have and want to test whether any of them are useful.  For a foreign
 * table, we don't know what indexes are present on the remote side but
 * want to speculate about which ones we'd like to use if they existed.
 *
 * This function returns a list of potentially-useful equivalence classes,
 * but it does not guarantee that an EquivalenceMember exists which contains
 * Vars only from the given relation.  For example, given ft1 JOIN t1 ON
 * ft1.x + t1.x = 0, this function will say that the equivalence class
 * containing ft1.x + t1.x is potentially useful.  Supposing ft1 is remote and
 * t1 is local (or on a different server), it will turn out that no useful
 * ORDER BY clause can be generated.  It's not our job to figure that out
 * here; we're only interested in identifying relevant ECs.
 */</comment>
<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>get_useful_ecs_for_relation</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>rel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>useful_eclass_list</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relids</name></type>		<name>relids</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * First, consider whether any active EC is potentially useful for a merge
	 * join against this relation.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>rel</name><operator>-&gt;</operator><name>has_eclass_joins</name></name></expr>)</condition>
	<block>{<block_content>
		<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>root-&gt;eq_classes</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>EquivalenceClass</name> <modifier>*</modifier></type><name>cur_ec</name> <init>= <expr><operator>(</operator><name>EquivalenceClass</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>eclass_useful_for_merging</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>cur_ec</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>useful_eclass_list</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>useful_eclass_list</name></expr></argument>, <argument><expr><name>cur_ec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Next, consider whether there are any non-EC derivable join clauses that
	 * are merge-joinable.  If the joininfo list is empty, we can exit
	 * quickly.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>rel</name><operator>-&gt;</operator><name>joininfo</name></name> <operator>==</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>useful_eclass_list</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* If this is a child rel, we must use the topmost parent rel to search. */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>IS_OTHER_REL</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>bms_is_empty</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>top_parent_relids</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>relids</name> <operator>=</operator> <name><name>rel</name><operator>-&gt;</operator><name>top_parent_relids</name></name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>relids</name> <operator>=</operator> <name><name>rel</name><operator>-&gt;</operator><name>relids</name></name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/* Check each join clause in turn. */</comment>
	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>rel-&gt;joininfo</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>RestrictInfo</name> <modifier>*</modifier></type><name>restrictinfo</name> <init>= <expr><operator>(</operator><name>RestrictInfo</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/* Consider only mergejoinable clauses */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>restrictinfo</name><operator>-&gt;</operator><name>mergeopfamilies</name></name> <operator>==</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<comment type="block">/* Make sure we've got canonical ECs. */</comment>
		<expr_stmt><expr><call><name>update_mergeclause_eclasses</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>restrictinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * restrictinfo-&gt;mergeopfamilies != NIL is sufficient to guarantee
		 * that left_ec and right_ec will be initialized, per comments in
		 * distribute_qual_to_rels.
		 *
		 * We want to identify which side of this merge-joinable clause
		 * contains columns from the relation produced by this RelOptInfo. We
		 * test for overlap, not containment, because there could be extra
		 * relations on either side.  For example, suppose we've got something
		 * like ((A JOIN B ON A.x = B.x) JOIN C ON A.y = C.y) LEFT JOIN D ON
		 * A.y = D.y.  The input rel might be the joinrel between A and B, and
		 * we'll consider the join clause A.y = D.y. relids contains a
		 * relation not involved in the join class (B) and the equivalence
		 * class for the left-hand side of the clause contains a relation not
		 * involved in the input rel (C).  Despite the fact that we have only
		 * overlap and not containment in either direction, A.y is potentially
		 * useful as a sort column.
		 *
		 * Note that it's even possible that relids overlaps neither side of
		 * the join clause.  For example, consider A LEFT JOIN B ON A.x = B.x
		 * AND A.x = 1.  The clause A.x = 1 will appear in B's joininfo list,
		 * but overlaps neither side of B.  In that case, we just skip this
		 * join clause, since it doesn't suggest a useful sort order for this
		 * relation.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>bms_overlap</name><argument_list>(<argument><expr><name>relids</name></expr></argument>, <argument><expr><name><name>restrictinfo</name><operator>-&gt;</operator><name>right_ec</name><operator>-&gt;</operator><name>ec_relids</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>useful_eclass_list</name> <operator>=</operator> <call><name>list_append_unique_ptr</name><argument_list>(<argument><expr><name>useful_eclass_list</name></expr></argument>,
														<argument><expr><name><name>restrictinfo</name><operator>-&gt;</operator><name>right_ec</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><call><name>bms_overlap</name><argument_list>(<argument><expr><name>relids</name></expr></argument>, <argument><expr><name><name>restrictinfo</name><operator>-&gt;</operator><name>left_ec</name><operator>-&gt;</operator><name>ec_relids</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>useful_eclass_list</name> <operator>=</operator> <call><name>list_append_unique_ptr</name><argument_list>(<argument><expr><name>useful_eclass_list</name></expr></argument>,
														<argument><expr><name><name>restrictinfo</name><operator>-&gt;</operator><name>left_ec</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block>

	<return>return <expr><name>useful_eclass_list</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * get_useful_pathkeys_for_relation
 *		Determine which orderings of a relation might be useful.
 *
 * Getting data in sorted order can be useful either because the requested
 * order matches the final output ordering for the overall query we're
 * planning, or because it enables an efficient merge join.  Here, we try
 * to figure out which pathkeys to consider.
 */</comment>
<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>get_useful_pathkeys_for_relation</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>rel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>useful_pathkeys_list</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>useful_eclass_list</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PgFdwRelationInfo</name> <modifier>*</modifier></type><name>fpinfo</name> <init>= <expr><operator>(</operator><name>PgFdwRelationInfo</name> <operator>*</operator><operator>)</operator> <name><name>rel</name><operator>-&gt;</operator><name>fdw_private</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>EquivalenceClass</name> <modifier>*</modifier></type><name>query_ec</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Pushing the query_pathkeys to the remote server is always worth
	 * considering, because it might let us avoid a local sort.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>root</name><operator>-&gt;</operator><name>query_pathkeys</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>bool</name></type>		<name>query_pathkeys_ok</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>

		<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>root-&gt;query_pathkeys</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>PathKey</name>    <modifier>*</modifier></type><name>pathkey</name> <init>= <expr><operator>(</operator><name>PathKey</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>EquivalenceClass</name> <modifier>*</modifier></type><name>pathkey_ec</name> <init>= <expr><name><name>pathkey</name><operator>-&gt;</operator><name>pk_eclass</name></name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Expr</name>	   <modifier>*</modifier></type><name>em_expr</name></decl>;</decl_stmt>

			<comment type="block">/*
			 * The planner and executor don't have any clever strategy for
			 * taking data sorted by a prefix of the query's pathkeys and
			 * getting it to be sorted by all of those pathkeys. We'll just
			 * end up resorting the entire data set.  So, unless we can push
			 * down all of the query pathkeys, forget it.
			 *
			 * is_foreign_expr would detect volatile expressions as well, but
			 * checking ec_has_volatile here saves some cycles.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>pathkey_ec</name><operator>-&gt;</operator><name>ec_has_volatile</name></name> <operator>||</operator>
				<operator>!</operator><operator>(</operator><name>em_expr</name> <operator>=</operator> <call><name>find_em_expr_for_rel</name><argument_list>(<argument><expr><name>pathkey_ec</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>||</operator>
				<operator>!</operator><call><name>is_foreign_expr</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><name>em_expr</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>query_pathkeys_ok</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block>

		<if_stmt><if>if <condition>(<expr><name>query_pathkeys_ok</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>useful_pathkeys_list</name> <operator>=</operator> <call><name>list_make1</name><argument_list>(<argument><expr><call><name>list_copy</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>query_pathkeys</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Even if we're not using remote estimates, having the remote side do the
	 * sort generally won't be any worse than doing it locally, and it might
	 * be much better if the remote side can generate data in the right order
	 * without needing a sort at all.  However, what we're going to do next is
	 * try to generate pathkeys that seem promising for possible merge joins,
	 * and that's more speculative.  A wrong choice might hurt quite a bit, so
	 * bail out if we can't use remote estimates.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>fpinfo</name><operator>-&gt;</operator><name>use_remote_estimate</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>useful_pathkeys_list</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* Get the list of interesting EquivalenceClasses. */</comment>
	<expr_stmt><expr><name>useful_eclass_list</name> <operator>=</operator> <call><name>get_useful_ecs_for_relation</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Extract unique EC for query, if any, so we don't consider it again. */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>query_pathkeys</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>PathKey</name>    <modifier>*</modifier></type><name>query_pathkey</name> <init>= <expr><call><name>linitial</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>query_pathkeys</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>query_ec</name> <operator>=</operator> <name><name>query_pathkey</name><operator>-&gt;</operator><name>pk_eclass</name></name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * As a heuristic, the only pathkeys we consider here are those of length
	 * one.  It's surely possible to consider more, but since each one we
	 * choose to consider will generate a round-trip to the remote side, we
	 * need to be a bit cautious here.  It would sure be nice to have a local
	 * cache of information about remote index definitions...
	 */</comment>
	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>useful_eclass_list</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>EquivalenceClass</name> <modifier>*</modifier></type><name>cur_ec</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Expr</name>	   <modifier>*</modifier></type><name>em_expr</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>PathKey</name>    <modifier>*</modifier></type><name>pathkey</name></decl>;</decl_stmt>

		<comment type="block">/* If redundant with what we did above, skip it. */</comment>
		<if_stmt><if>if <condition>(<expr><name>cur_ec</name> <operator>==</operator> <name>query_ec</name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<comment type="block">/* If no pushable expression for this rel, skip it. */</comment>
		<expr_stmt><expr><name>em_expr</name> <operator>=</operator> <call><name>find_em_expr_for_rel</name><argument_list>(<argument><expr><name>cur_ec</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>em_expr</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <operator>!</operator><call><name>is_foreign_expr</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><name>em_expr</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<comment type="block">/* Looks like we can generate a pathkey, so let's do it. */</comment>
		<expr_stmt><expr><name>pathkey</name> <operator>=</operator> <call><name>make_canonical_pathkey</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>cur_ec</name></expr></argument>,
										 <argument><expr><call><name>linitial_oid</name><argument_list>(<argument><expr><name><name>cur_ec</name><operator>-&gt;</operator><name>ec_opfamilies</name></name></expr></argument>)</argument_list></call></expr></argument>,
										 <argument><expr><name>BTLessStrategyNumber</name></expr></argument>,
										 <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>useful_pathkeys_list</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>useful_pathkeys_list</name></expr></argument>,
									   <argument><expr><call><name>list_make1</name><argument_list>(<argument><expr><name>pathkey</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<return>return <expr><name>useful_pathkeys_list</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * postgresGetForeignPaths
 *		Create possible scan paths for a scan on the foreign table
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>postgresGetForeignPaths</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
						<parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>baserel</name></decl></parameter>,
						<parameter><decl><type><name>Oid</name></type> <name>foreigntableid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PgFdwRelationInfo</name> <modifier>*</modifier></type><name>fpinfo</name> <init>= <expr><operator>(</operator><name>PgFdwRelationInfo</name> <operator>*</operator><operator>)</operator> <name><name>baserel</name><operator>-&gt;</operator><name>fdw_private</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ForeignPath</name> <modifier>*</modifier></type><name>path</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>ppi_list</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Create simplest ForeignScan path node and add it to baserel.  This path
	 * corresponds to SeqScan path of regular tables (though depending on what
	 * baserestrict conditions we were able to send to remote, there might
	 * actually be an indexscan happening there).  We already did all the work
	 * to estimate cost and size of this path.
	 *
	 * Although this path uses no join clauses, it could still have required
	 * parameterization due to LATERAL refs in its tlist.
	 */</comment>
	<expr_stmt><expr><name>path</name> <operator>=</operator> <call><name>create_foreignscan_path</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>baserel</name></expr></argument>,
								   <argument><expr><name>NULL</name></expr></argument>,	<comment type="block">/* default pathtarget */</comment>
								   <argument><expr><name><name>fpinfo</name><operator>-&gt;</operator><name>rows</name></name></expr></argument>,
								   <argument><expr><name><name>fpinfo</name><operator>-&gt;</operator><name>startup_cost</name></name></expr></argument>,
								   <argument><expr><name><name>fpinfo</name><operator>-&gt;</operator><name>total_cost</name></name></expr></argument>,
								   <argument><expr><name>NIL</name></expr></argument>, <comment type="block">/* no pathkeys */</comment>
								   <argument><expr><name><name>baserel</name><operator>-&gt;</operator><name>lateral_relids</name></name></expr></argument>,
								   <argument><expr><name>NULL</name></expr></argument>,	<comment type="block">/* no extra plan */</comment>
								   <argument><expr><name>NIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>	<comment type="block">/* no fdw_private list */</comment>
	<expr_stmt><expr><call><name>add_path</name><argument_list>(<argument><expr><name>baserel</name></expr></argument>, <argument><expr><operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator> <name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Add paths with pathkeys */</comment>
	<expr_stmt><expr><call><name>add_paths_with_pathkeys_for_rel</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>baserel</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If we're not using remote estimates, stop here.  We have no way to
	 * estimate whether any join clauses would be worth sending across, so
	 * don't bother building parameterized paths.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>fpinfo</name><operator>-&gt;</operator><name>use_remote_estimate</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Thumb through all join clauses for the rel to identify which outer
	 * relations could supply one or more safe-to-send-to-remote join clauses.
	 * We'll build a parameterized path for each such outer relation.
	 *
	 * It's convenient to manage this by representing each candidate outer
	 * relation by the ParamPathInfo node for it.  We can then use the
	 * ppi_clauses list in the ParamPathInfo node directly as a list of the
	 * interesting join clauses for that rel.  This takes care of the
	 * possibility that there are multiple safe join clauses for such a rel,
	 * and also ensures that we account for unsafe join clauses that we'll
	 * still have to enforce locally (since the parameterized-path machinery
	 * insists that we handle all movable clauses).
	 */</comment>
	<expr_stmt><expr><name>ppi_list</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>baserel-&gt;joininfo</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>RestrictInfo</name> <modifier>*</modifier></type><name>rinfo</name> <init>= <expr><operator>(</operator><name>RestrictInfo</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Relids</name></type>		<name>required_outer</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ParamPathInfo</name> <modifier>*</modifier></type><name>param_info</name></decl>;</decl_stmt>

		<comment type="block">/* Check if clause can be moved to this rel */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>join_clause_is_movable_to</name><argument_list>(<argument><expr><name>rinfo</name></expr></argument>, <argument><expr><name>baserel</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<comment type="block">/* See if it is safe to send to remote */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>is_foreign_expr</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>baserel</name></expr></argument>, <argument><expr><name><name>rinfo</name><operator>-&gt;</operator><name>clause</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<comment type="block">/* Calculate required outer rels for the resulting path */</comment>
		<expr_stmt><expr><name>required_outer</name> <operator>=</operator> <call><name>bms_union</name><argument_list>(<argument><expr><name><name>rinfo</name><operator>-&gt;</operator><name>clause_relids</name></name></expr></argument>,
								   <argument><expr><name><name>baserel</name><operator>-&gt;</operator><name>lateral_relids</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* We do not want the foreign rel itself listed in required_outer */</comment>
		<expr_stmt><expr><name>required_outer</name> <operator>=</operator> <call><name>bms_del_member</name><argument_list>(<argument><expr><name>required_outer</name></expr></argument>, <argument><expr><name><name>baserel</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * required_outer probably can't be empty here, but if it were, we
		 * couldn't make a parameterized path.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>bms_is_empty</name><argument_list>(<argument><expr><name>required_outer</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<comment type="block">/* Get the ParamPathInfo */</comment>
		<expr_stmt><expr><name>param_info</name> <operator>=</operator> <call><name>get_baserel_parampathinfo</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>baserel</name></expr></argument>,
											   <argument><expr><name>required_outer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>param_info</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Add it to list unless we already have it.  Testing pointer equality
		 * is OK since get_baserel_parampathinfo won't make duplicates.
		 */</comment>
		<expr_stmt><expr><name>ppi_list</name> <operator>=</operator> <call><name>list_append_unique_ptr</name><argument_list>(<argument><expr><name>ppi_list</name></expr></argument>, <argument><expr><name>param_info</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<comment type="block">/*
	 * The above scan examined only "generic" join clauses, not those that
	 * were absorbed into EquivalenceClauses.  See if we can make anything out
	 * of EquivalenceClauses.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>baserel</name><operator>-&gt;</operator><name>has_eclass_joins</name></name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * We repeatedly scan the eclass list looking for column references
		 * (or expressions) belonging to the foreign rel.  Each time we find
		 * one, we generate a list of equivalence joinclauses for it, and then
		 * see if any are safe to send to the remote.  Repeat till there are
		 * no more candidate EC members.
		 */</comment>
		<decl_stmt><decl><type><name>ec_member_foreign_arg</name></type> <name>arg</name></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>arg</name><operator>.</operator><name>already_used</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
		<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>clauses</name></decl>;</decl_stmt>

			<comment type="block">/* Make clauses, skipping any that join to lateral_referencers */</comment>
			<expr_stmt><expr><name><name>arg</name><operator>.</operator><name>current</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>clauses</name> <operator>=</operator> <call><name>generate_implied_equalities_for_column</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
															 <argument><expr><name>baserel</name></expr></argument>,
															 <argument><expr><name>ec_member_matches_foreign</name></expr></argument>,
															 <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>arg</name></expr></argument>,
															 <argument><expr><name><name>baserel</name><operator>-&gt;</operator><name>lateral_referencers</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* Done if there are no more expressions in the foreign rel */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>arg</name><operator>.</operator><name>current</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>clauses</name> <operator>==</operator> <name>NIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/* Scan the extracted join clauses */</comment>
			<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>clauses</argument>)</argument_list></macro>
			<block>{<block_content>
				<decl_stmt><decl><type><name>RestrictInfo</name> <modifier>*</modifier></type><name>rinfo</name> <init>= <expr><operator>(</operator><name>RestrictInfo</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>Relids</name></type>		<name>required_outer</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>ParamPathInfo</name> <modifier>*</modifier></type><name>param_info</name></decl>;</decl_stmt>

				<comment type="block">/* Check if clause can be moved to this rel */</comment>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>join_clause_is_movable_to</name><argument_list>(<argument><expr><name>rinfo</name></expr></argument>, <argument><expr><name>baserel</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<continue>continue;</continue></block_content></block></if></if_stmt>

				<comment type="block">/* See if it is safe to send to remote */</comment>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>is_foreign_expr</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>baserel</name></expr></argument>, <argument><expr><name><name>rinfo</name><operator>-&gt;</operator><name>clause</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<continue>continue;</continue></block_content></block></if></if_stmt>

				<comment type="block">/* Calculate required outer rels for the resulting path */</comment>
				<expr_stmt><expr><name>required_outer</name> <operator>=</operator> <call><name>bms_union</name><argument_list>(<argument><expr><name><name>rinfo</name><operator>-&gt;</operator><name>clause_relids</name></name></expr></argument>,
										   <argument><expr><name><name>baserel</name><operator>-&gt;</operator><name>lateral_relids</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>required_outer</name> <operator>=</operator> <call><name>bms_del_member</name><argument_list>(<argument><expr><name>required_outer</name></expr></argument>, <argument><expr><name><name>baserel</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><call><name>bms_is_empty</name><argument_list>(<argument><expr><name>required_outer</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<continue>continue;</continue></block_content></block></if></if_stmt>

				<comment type="block">/* Get the ParamPathInfo */</comment>
				<expr_stmt><expr><name>param_info</name> <operator>=</operator> <call><name>get_baserel_parampathinfo</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>baserel</name></expr></argument>,
													   <argument><expr><name>required_outer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>param_info</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/* Add it to list unless we already have it */</comment>
				<expr_stmt><expr><name>ppi_list</name> <operator>=</operator> <call><name>list_append_unique_ptr</name><argument_list>(<argument><expr><name>ppi_list</name></expr></argument>, <argument><expr><name>param_info</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block>

			<comment type="block">/* Try again, now ignoring the expression we found this time */</comment>
			<expr_stmt><expr><name><name>arg</name><operator>.</operator><name>already_used</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>arg</name><operator>.</operator><name>already_used</name></name></expr></argument>, <argument><expr><name><name>arg</name><operator>.</operator><name>current</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></for>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Now build a path for each useful outer relation.
	 */</comment>
	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>ppi_list</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ParamPathInfo</name> <modifier>*</modifier></type><name>param_info</name> <init>= <expr><operator>(</operator><name>ParamPathInfo</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>double</name></type>		<name>rows</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>width</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Cost</name></type>		<name>startup_cost</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Cost</name></type>		<name>total_cost</name></decl>;</decl_stmt>

		<comment type="block">/* Get a cost estimate from the remote */</comment>
		<expr_stmt><expr><call><name>estimate_path_cost_size</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>baserel</name></expr></argument>,
								<argument><expr><name><name>param_info</name><operator>-&gt;</operator><name>ppi_clauses</name></name></expr></argument>, <argument><expr><name>NIL</name></expr></argument>,
								<argument><expr><operator>&amp;</operator><name>rows</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>width</name></expr></argument>,
								<argument><expr><operator>&amp;</operator><name>startup_cost</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>total_cost</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * ppi_rows currently won't get looked at by anything, but still we
		 * may as well ensure that it matches our idea of the rowcount.
		 */</comment>
		<expr_stmt><expr><name><name>param_info</name><operator>-&gt;</operator><name>ppi_rows</name></name> <operator>=</operator> <name>rows</name></expr>;</expr_stmt>

		<comment type="block">/* Make the path */</comment>
		<expr_stmt><expr><name>path</name> <operator>=</operator> <call><name>create_foreignscan_path</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>baserel</name></expr></argument>,
									   <argument><expr><name>NULL</name></expr></argument>,	<comment type="block">/* default pathtarget */</comment>
									   <argument><expr><name>rows</name></expr></argument>,
									   <argument><expr><name>startup_cost</name></expr></argument>,
									   <argument><expr><name>total_cost</name></expr></argument>,
									   <argument><expr><name>NIL</name></expr></argument>, <comment type="block">/* no pathkeys */</comment>
									   <argument><expr><name><name>param_info</name><operator>-&gt;</operator><name>ppi_req_outer</name></name></expr></argument>,
									   <argument><expr><name>NULL</name></expr></argument>,
									   <argument><expr><name>NIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>	<comment type="block">/* no fdw_private list */</comment>
		<expr_stmt><expr><call><name>add_path</name><argument_list>(<argument><expr><name>baserel</name></expr></argument>, <argument><expr><operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator> <name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
</block_content>}</block></function>

<comment type="block">/*
 * postgresGetForeignPlan
 *		Create ForeignScan plan node which implements selected best path
 */</comment>
<function><type><specifier>static</specifier> <name>ForeignScan</name> <modifier>*</modifier></type>
<name>postgresGetForeignPlan</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
					   <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>foreignrel</name></decl></parameter>,
					   <parameter><decl><type><name>Oid</name></type> <name>foreigntableid</name></decl></parameter>,
					   <parameter><decl><type><name>ForeignPath</name> <modifier>*</modifier></type><name>best_path</name></decl></parameter>,
					   <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>tlist</name></decl></parameter>,
					   <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>scan_clauses</name></decl></parameter>,
					   <parameter><decl><type><name>Plan</name> <modifier>*</modifier></type><name>outer_plan</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PgFdwRelationInfo</name> <modifier>*</modifier></type><name>fpinfo</name> <init>= <expr><operator>(</operator><name>PgFdwRelationInfo</name> <operator>*</operator><operator>)</operator> <name><name>foreignrel</name><operator>-&gt;</operator><name>fdw_private</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Index</name></type>		<name>scan_relid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>fdw_private</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>remote_exprs</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>local_exprs</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>params_list</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>fdw_scan_tlist</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>fdw_recheck_quals</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>retrieved_attrs</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>StringInfoData</name></type> <name>sql</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>IS_SIMPLE_REL</name><argument_list>(<argument><expr><name>foreignrel</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * For base relations, set scan_relid as the relid of the relation.
		 */</comment>
		<expr_stmt><expr><name>scan_relid</name> <operator>=</operator> <name><name>foreignrel</name><operator>-&gt;</operator><name>relid</name></name></expr>;</expr_stmt>

		<comment type="block">/*
		 * In a base-relation scan, we must apply the given scan_clauses.
		 *
		 * Separate the scan_clauses into those that can be executed remotely
		 * and those that can't.  baserestrictinfo clauses that were
		 * previously determined to be safe or unsafe by classifyConditions
		 * are found in fpinfo-&gt;remote_conds and fpinfo-&gt;local_conds. Anything
		 * else in the scan_clauses list will be a join clause, which we have
		 * to check for remote-safety.
		 *
		 * Note: the join clauses we see here should be the exact same ones
		 * previously examined by postgresGetForeignPaths.  Possibly it'd be
		 * worth passing forward the classification work done then, rather
		 * than repeating it here.
		 *
		 * This code must match "extract_actual_clauses(scan_clauses, false)"
		 * except for the additional decision about remote versus local
		 * execution.
		 */</comment>
		<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>scan_clauses</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>RestrictInfo</name> <modifier>*</modifier></type><name>rinfo</name> <init>= <expr><call><name>lfirst_node</name><argument_list>(<argument><expr><name>RestrictInfo</name></expr></argument>, <argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<comment type="block">/* Ignore any pseudoconstants, they're dealt with elsewhere */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>rinfo</name><operator>-&gt;</operator><name>pseudoconstant</name></name></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>list_member_ptr</name><argument_list>(<argument><expr><name><name>fpinfo</name><operator>-&gt;</operator><name>remote_conds</name></name></expr></argument>, <argument><expr><name>rinfo</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>remote_exprs</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>remote_exprs</name></expr></argument>, <argument><expr><name><name>rinfo</name><operator>-&gt;</operator><name>clause</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<if type="elseif">else if <condition>(<expr><call><name>list_member_ptr</name><argument_list>(<argument><expr><name><name>fpinfo</name><operator>-&gt;</operator><name>local_conds</name></name></expr></argument>, <argument><expr><name>rinfo</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>local_exprs</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>local_exprs</name></expr></argument>, <argument><expr><name><name>rinfo</name><operator>-&gt;</operator><name>clause</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<if type="elseif">else if <condition>(<expr><call><name>is_foreign_expr</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>foreignrel</name></expr></argument>, <argument><expr><name><name>rinfo</name><operator>-&gt;</operator><name>clause</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>remote_exprs</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>remote_exprs</name></expr></argument>, <argument><expr><name><name>rinfo</name><operator>-&gt;</operator><name>clause</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name>local_exprs</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>local_exprs</name></expr></argument>, <argument><expr><name><name>rinfo</name><operator>-&gt;</operator><name>clause</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
		</block_content>}</block>

		<comment type="block">/*
		 * For a base-relation scan, we have to support EPQ recheck, which
		 * should recheck all the remote quals.
		 */</comment>
		<expr_stmt><expr><name>fdw_recheck_quals</name> <operator>=</operator> <name>remote_exprs</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/*
		 * Join relation or upper relation - set scan_relid to 0.
		 */</comment>
		<expr_stmt><expr><name>scan_relid</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

		<comment type="block">/*
		 * For a join rel, baserestrictinfo is NIL and we are not considering
		 * parameterization right now, so there should be no scan_clauses for
		 * a joinrel or an upper rel either.
		 */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>scan_clauses</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Instead we get the conditions to apply from the fdw_private
		 * structure.
		 */</comment>
		<expr_stmt><expr><name>remote_exprs</name> <operator>=</operator> <call><name>extract_actual_clauses</name><argument_list>(<argument><expr><name><name>fpinfo</name><operator>-&gt;</operator><name>remote_conds</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>local_exprs</name> <operator>=</operator> <call><name>extract_actual_clauses</name><argument_list>(<argument><expr><name><name>fpinfo</name><operator>-&gt;</operator><name>local_conds</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * We leave fdw_recheck_quals empty in this case, since we never need
		 * to apply EPQ recheck clauses.  In the case of a joinrel, EPQ
		 * recheck is handled elsewhere --- see postgresGetForeignJoinPaths().
		 * If we're planning an upperrel (ie, remote grouping or aggregation)
		 * then there's no EPQ to do because SELECT FOR UPDATE wouldn't be
		 * allowed, and indeed we *can't* put the remote clauses into
		 * fdw_recheck_quals because the unaggregated Vars won't be available
		 * locally.
		 */</comment>

		<comment type="block">/* Build the list of columns to be fetched from the foreign server. */</comment>
		<expr_stmt><expr><name>fdw_scan_tlist</name> <operator>=</operator> <call><name>build_tlist_to_deparse</name><argument_list>(<argument><expr><name>foreignrel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Ensure that the outer plan produces a tuple whose descriptor
		 * matches our scan tuple slot.  Also, remove the local conditions
		 * from outer plan's quals, lest they be evaluated twice, once by the
		 * local plan and once by the scan.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>outer_plan</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

			<comment type="block">/*
			 * Right now, we only consider grouping and aggregation beyond
			 * joins. Queries involving aggregates or grouping do not require
			 * EPQ mechanism, hence should not have an outer plan here.
			 */</comment>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>IS_UPPER_REL</name><argument_list>(<argument><expr><name>foreignrel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * First, update the plan's qual list if possible.  In some cases
			 * the quals might be enforced below the topmost plan level, in
			 * which case we'll fail to remove them; it's not worth working
			 * harder than this.
			 */</comment>
			<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>local_exprs</argument>)</argument_list></macro>
			<block>{<block_content>
				<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>qual</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><name><name>outer_plan</name><operator>-&gt;</operator><name>qual</name></name> <operator>=</operator> <call><name>list_delete</name><argument_list>(<argument><expr><name><name>outer_plan</name><operator>-&gt;</operator><name>qual</name></name></expr></argument>, <argument><expr><name>qual</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/*
				 * For an inner join the local conditions of foreign scan plan
				 * can be part of the joinquals as well.  (They might also be
				 * in the mergequals or hashquals, but we can't touch those
				 * without breaking the plan.)
				 */</comment>
				<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>outer_plan</name></expr></argument>, <argument><expr><name>NestLoop</name></expr></argument>)</argument_list></call> <operator>||</operator>
					<call><name>IsA</name><argument_list>(<argument><expr><name>outer_plan</name></expr></argument>, <argument><expr><name>MergeJoin</name></expr></argument>)</argument_list></call> <operator>||</operator>
					<call><name>IsA</name><argument_list>(<argument><expr><name>outer_plan</name></expr></argument>, <argument><expr><name>HashJoin</name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<decl_stmt><decl><type><name>Join</name>	   <modifier>*</modifier></type><name>join_plan</name> <init>= <expr><operator>(</operator><name>Join</name> <operator>*</operator><operator>)</operator> <name>outer_plan</name></expr></init></decl>;</decl_stmt>

					<if_stmt><if>if <condition>(<expr><name><name>join_plan</name><operator>-&gt;</operator><name>jointype</name></name> <operator>==</operator> <name>JOIN_INNER</name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><name><name>join_plan</name><operator>-&gt;</operator><name>joinqual</name></name> <operator>=</operator> <call><name>list_delete</name><argument_list>(<argument><expr><name><name>join_plan</name><operator>-&gt;</operator><name>joinqual</name></name></expr></argument>,
														  <argument><expr><name>qual</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block>

			<comment type="block">/*
			 * Now fix the subplan's tlist --- this might result in inserting
			 * a Result node atop the plan tree.
			 */</comment>
			<expr_stmt><expr><name>outer_plan</name> <operator>=</operator> <call><name>change_plan_targetlist</name><argument_list>(<argument><expr><name>outer_plan</name></expr></argument>, <argument><expr><name>fdw_scan_tlist</name></expr></argument>,
												<argument><expr><name><name>best_path</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>parallel_safe</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/*
	 * Build the query string to be sent for execution, and identify
	 * expressions to be sent as parameters.
	 */</comment>
	<expr_stmt><expr><call><name>initStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>deparseSelectStmtForRel</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sql</name></expr></argument>, <argument><expr><name>root</name></expr></argument>, <argument><expr><name>foreignrel</name></expr></argument>, <argument><expr><name>fdw_scan_tlist</name></expr></argument>,
							<argument><expr><name>remote_exprs</name></expr></argument>, <argument><expr><name><name>best_path</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>pathkeys</name></name></expr></argument>,
							<argument><expr><name>false</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>retrieved_attrs</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>params_list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Remember remote_exprs for possible use by postgresPlanDirectModify */</comment>
	<expr_stmt><expr><name><name>fpinfo</name><operator>-&gt;</operator><name>final_remote_exprs</name></name> <operator>=</operator> <name>remote_exprs</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Build the fdw_private list that will be available to the executor.
	 * Items in the list must match order in enum FdwScanPrivateIndex.
	 */</comment>
	<expr_stmt><expr><name>fdw_private</name> <operator>=</operator> <call><name>list_make3</name><argument_list>(<argument><expr><call><name>makeString</name><argument_list>(<argument><expr><name><name>sql</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr></argument>,
							 <argument><expr><name>retrieved_attrs</name></expr></argument>,
							 <argument><expr><call><name>makeInteger</name><argument_list>(<argument><expr><name><name>fpinfo</name><operator>-&gt;</operator><name>fetch_size</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>IS_JOIN_REL</name><argument_list>(<argument><expr><name>foreignrel</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>IS_UPPER_REL</name><argument_list>(<argument><expr><name>foreignrel</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>fdw_private</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>fdw_private</name></expr></argument>,
							  <argument><expr><call><name>makeString</name><argument_list>(<argument><expr><name><name>fpinfo</name><operator>-&gt;</operator><name>relation_name</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Create the ForeignScan node for the given relation.
	 *
	 * Note that the remote parameter expressions are stored in the fdw_exprs
	 * field of the finished plan node; we can't keep them in private state
	 * because then they wouldn't be subject to later planner processing.
	 */</comment>
	<return>return <expr><call><name>make_foreignscan</name><argument_list>(<argument><expr><name>tlist</name></expr></argument>,
							<argument><expr><name>local_exprs</name></expr></argument>,
							<argument><expr><name>scan_relid</name></expr></argument>,
							<argument><expr><name>params_list</name></expr></argument>,
							<argument><expr><name>fdw_private</name></expr></argument>,
							<argument><expr><name>fdw_scan_tlist</name></expr></argument>,
							<argument><expr><name>fdw_recheck_quals</name></expr></argument>,
							<argument><expr><name>outer_plan</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * postgresBeginForeignScan
 *		Initiate an executor scan of a foreign PostgreSQL table.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>postgresBeginForeignScan</name><parameter_list>(<parameter><decl><type><name>ForeignScanState</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>eflags</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ForeignScan</name> <modifier>*</modifier></type><name>fsplan</name> <init>= <expr><operator>(</operator><name>ForeignScan</name> <operator>*</operator><operator>)</operator> <name><name>node</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ps</name><operator>.</operator><name>plan</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>EState</name>	   <modifier>*</modifier></type><name>estate</name> <init>= <expr><name><name>node</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ps</name><operator>.</operator><name>state</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PgFdwScanState</name> <modifier>*</modifier></type><name>fsstate</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>userid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ForeignTable</name> <modifier>*</modifier></type><name>table</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>UserMapping</name> <modifier>*</modifier></type><name>user</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>rtindex</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>numParams</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Do nothing in EXPLAIN (no ANALYZE) case.  node-&gt;fdw_state stays NULL.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>eflags</name> <operator>&amp;</operator> <name>EXEC_FLAG_EXPLAIN_ONLY</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * We'll save private state in node-&gt;fdw_state.
	 */</comment>
	<expr_stmt><expr><name>fsstate</name> <operator>=</operator> <operator>(</operator><name>PgFdwScanState</name> <operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>PgFdwScanState</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>fdw_state</name></name> <operator>=</operator> <operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>fsstate</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Identify which user to do the remote access as.  This should match what
	 * ExecCheckRTEPerms() does.  In case of a join or aggregate, use the
	 * lowest-numbered member RTE as a representative; we would get the same
	 * result from any.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>fsplan</name><operator>-&gt;</operator><name>scan</name><operator>.</operator><name>scanrelid</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>rtindex</name> <operator>=</operator> <name><name>fsplan</name><operator>-&gt;</operator><name>scan</name><operator>.</operator><name>scanrelid</name></name></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>rtindex</name> <operator>=</operator> <call><name>bms_next_member</name><argument_list>(<argument><expr><name><name>fsplan</name><operator>-&gt;</operator><name>fs_relids</name></name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	<expr_stmt><expr><name>rte</name> <operator>=</operator> <call><name>rt_fetch</name><argument_list>(<argument><expr><name>rtindex</name></expr></argument>, <argument><expr><name><name>estate</name><operator>-&gt;</operator><name>es_range_table</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>userid</name> <operator>=</operator> <ternary><condition><expr><name><name>rte</name><operator>-&gt;</operator><name>checkAsUser</name></name></expr> ?</condition><then> <expr><name><name>rte</name><operator>-&gt;</operator><name>checkAsUser</name></name></expr> </then><else>: <expr><call><name>GetUserId</name><argument_list>()</argument_list></call></expr></else></ternary></expr>;</expr_stmt>

	<comment type="block">/* Get info about foreign table. */</comment>
	<expr_stmt><expr><name>table</name> <operator>=</operator> <call><name>GetForeignTable</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>user</name> <operator>=</operator> <call><name>GetUserMapping</name><argument_list>(<argument><expr><name>userid</name></expr></argument>, <argument><expr><name><name>table</name><operator>-&gt;</operator><name>serverid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Get connection to the foreign server.  Connection manager will
	 * establish new connection if necessary.
	 */</comment>
	<expr_stmt><expr><name><name>fsstate</name><operator>-&gt;</operator><name>conn</name></name> <operator>=</operator> <call><name>GetConnection</name><argument_list>(<argument><expr><name>user</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Assign a unique ID for my cursor */</comment>
	<expr_stmt><expr><name><name>fsstate</name><operator>-&gt;</operator><name>cursor_number</name></name> <operator>=</operator> <call><name>GetCursorNumber</name><argument_list>(<argument><expr><name><name>fsstate</name><operator>-&gt;</operator><name>conn</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fsstate</name><operator>-&gt;</operator><name>cursor_exists</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<comment type="block">/* Get private info created by planner functions. */</comment>
	<expr_stmt><expr><name><name>fsstate</name><operator>-&gt;</operator><name>query</name></name> <operator>=</operator> <call><name>strVal</name><argument_list>(<argument><expr><call><name>list_nth</name><argument_list>(<argument><expr><name><name>fsplan</name><operator>-&gt;</operator><name>fdw_private</name></name></expr></argument>,
									 <argument><expr><name>FdwScanPrivateSelectSql</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fsstate</name><operator>-&gt;</operator><name>retrieved_attrs</name></name> <operator>=</operator> <operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator> <call><name>list_nth</name><argument_list>(<argument><expr><name><name>fsplan</name><operator>-&gt;</operator><name>fdw_private</name></name></expr></argument>,
												 <argument><expr><name>FdwScanPrivateRetrievedAttrs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fsstate</name><operator>-&gt;</operator><name>fetch_size</name></name> <operator>=</operator> <call><name>intVal</name><argument_list>(<argument><expr><call><name>list_nth</name><argument_list>(<argument><expr><name><name>fsplan</name><operator>-&gt;</operator><name>fdw_private</name></name></expr></argument>,
										  <argument><expr><name>FdwScanPrivateFetchSize</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Create contexts for batches of tuples and per-tuple temp workspace. */</comment>
	<expr_stmt><expr><name><name>fsstate</name><operator>-&gt;</operator><name>batch_cxt</name></name> <operator>=</operator> <call><name>AllocSetContextCreate</name><argument_list>(<argument><expr><name><name>estate</name><operator>-&gt;</operator><name>es_query_cxt</name></name></expr></argument>,
											   <argument><expr><literal type="string">"postgres_fdw tuple data"</literal></expr></argument>,
											   <argument><expr><name>ALLOCSET_DEFAULT_SIZES</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fsstate</name><operator>-&gt;</operator><name>temp_cxt</name></name> <operator>=</operator> <call><name>AllocSetContextCreate</name><argument_list>(<argument><expr><name><name>estate</name><operator>-&gt;</operator><name>es_query_cxt</name></name></expr></argument>,
											  <argument><expr><literal type="string">"postgres_fdw temporary data"</literal></expr></argument>,
											  <argument><expr><name>ALLOCSET_SMALL_SIZES</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Get info we'll need for converting data fetched from the foreign server
	 * into local representation and error reporting during that process.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>fsplan</name><operator>-&gt;</operator><name>scan</name><operator>.</operator><name>scanrelid</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>fsstate</name><operator>-&gt;</operator><name>rel</name></name> <operator>=</operator> <name><name>node</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ss_currentRelation</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>fsstate</name><operator>-&gt;</operator><name>tupdesc</name></name> <operator>=</operator> <call><name>RelationGetDescr</name><argument_list>(<argument><expr><name><name>fsstate</name><operator>-&gt;</operator><name>rel</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name><name>fsstate</name><operator>-&gt;</operator><name>rel</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>fsstate</name><operator>-&gt;</operator><name>tupdesc</name></name> <operator>=</operator> <name><name>node</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ss_ScanTupleSlot</name><operator>-&gt;</operator><name>tts_tupleDescriptor</name></name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><name><name>fsstate</name><operator>-&gt;</operator><name>attinmeta</name></name> <operator>=</operator> <call><name>TupleDescGetAttInMetadata</name><argument_list>(<argument><expr><name><name>fsstate</name><operator>-&gt;</operator><name>tupdesc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Prepare for processing of parameters used in remote query, if any.
	 */</comment>
	<expr_stmt><expr><name>numParams</name> <operator>=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>fsplan</name><operator>-&gt;</operator><name>fdw_exprs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fsstate</name><operator>-&gt;</operator><name>numParams</name></name> <operator>=</operator> <name>numParams</name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>numParams</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>prepare_query_params</name><argument_list>(<argument><expr><operator>(</operator><name>PlanState</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>,
							 <argument><expr><name><name>fsplan</name><operator>-&gt;</operator><name>fdw_exprs</name></name></expr></argument>,
							 <argument><expr><name>numParams</name></expr></argument>,
							 <argument><expr><operator>&amp;</operator><name><name>fsstate</name><operator>-&gt;</operator><name>param_flinfo</name></name></expr></argument>,
							 <argument><expr><operator>&amp;</operator><name><name>fsstate</name><operator>-&gt;</operator><name>param_exprs</name></name></expr></argument>,
							 <argument><expr><operator>&amp;</operator><name><name>fsstate</name><operator>-&gt;</operator><name>param_values</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * postgresIterateForeignScan
 *		Retrieve next row from the result set, or clear tuple slot to indicate
 *		EOF.
 */</comment>
<function><type><specifier>static</specifier> <name>TupleTableSlot</name> <modifier>*</modifier></type>
<name>postgresIterateForeignScan</name><parameter_list>(<parameter><decl><type><name>ForeignScanState</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PgFdwScanState</name> <modifier>*</modifier></type><name>fsstate</name> <init>= <expr><operator>(</operator><name>PgFdwScanState</name> <operator>*</operator><operator>)</operator> <name><name>node</name><operator>-&gt;</operator><name>fdw_state</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name> <init>= <expr><name><name>node</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ss_ScanTupleSlot</name></name></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * If this is the first call after Begin or ReScan, we need to create the
	 * cursor on the remote side.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>fsstate</name><operator>-&gt;</operator><name>cursor_exists</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>create_cursor</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Get some more tuples, if we've run out.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>fsstate</name><operator>-&gt;</operator><name>next_tuple</name></name> <operator>&gt;=</operator> <name><name>fsstate</name><operator>-&gt;</operator><name>num_tuples</name></name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* No point in another fetch if we already detected EOF, though. */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>fsstate</name><operator>-&gt;</operator><name>eof_reached</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>fetch_more_data</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<comment type="block">/* If we didn't get any tuples, must be end of data. */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>fsstate</name><operator>-&gt;</operator><name>next_tuple</name></name> <operator>&gt;=</operator> <name><name>fsstate</name><operator>-&gt;</operator><name>num_tuples</name></name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><call><name>ExecClearTuple</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Return the next tuple.
	 */</comment>
	<expr_stmt><expr><call><name>ExecStoreTuple</name><argument_list>(<argument><expr><name><name>fsstate</name><operator>-&gt;</operator><name>tuples</name><index>[<expr><name><name>fsstate</name><operator>-&gt;</operator><name>next_tuple</name></name><operator>++</operator></expr>]</index></name></expr></argument>,
				   <argument><expr><name>slot</name></expr></argument>,
				   <argument><expr><name>InvalidBuffer</name></expr></argument>,
				   <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>slot</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * postgresReScanForeignScan
 *		Restart the scan.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>postgresReScanForeignScan</name><parameter_list>(<parameter><decl><type><name>ForeignScanState</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PgFdwScanState</name> <modifier>*</modifier></type><name>fsstate</name> <init>= <expr><operator>(</operator><name>PgFdwScanState</name> <operator>*</operator><operator>)</operator> <name><name>node</name><operator>-&gt;</operator><name>fdw_state</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>sql</name><index>[<expr><literal type="number">64</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>

	<comment type="block">/* If we haven't created the cursor yet, nothing to do. */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>fsstate</name><operator>-&gt;</operator><name>cursor_exists</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * If any internal parameters affecting this node have changed, we'd
	 * better destroy and recreate the cursor.  Otherwise, rewinding it should
	 * be good enough.  If we've only fetched zero or one batch, we needn't
	 * even rewind the cursor, just rescan what we have.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ps</name><operator>.</operator><name>chgParam</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>fsstate</name><operator>-&gt;</operator><name>cursor_exists</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>sql</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>sql</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"CLOSE c%u"</literal></expr></argument>,
				 <argument><expr><name><name>fsstate</name><operator>-&gt;</operator><name>cursor_number</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name><name>fsstate</name><operator>-&gt;</operator><name>fetch_ct_2</name></name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>sql</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>sql</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"MOVE BACKWARD ALL IN c%u"</literal></expr></argument>,
				 <argument><expr><name><name>fsstate</name><operator>-&gt;</operator><name>cursor_number</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* Easy: just rescan what we already have in memory, if anything */</comment>
		<expr_stmt><expr><name><name>fsstate</name><operator>-&gt;</operator><name>next_tuple</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/*
	 * We don't use a PG_TRY block here, so be careful not to throw error
	 * without releasing the PGresult.
	 */</comment>
	<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>pgfdw_exec_query</name><argument_list>(<argument><expr><name><name>fsstate</name><operator>-&gt;</operator><name>conn</name></name></expr></argument>, <argument><expr><name>sql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>PQresultStatus</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>PGRES_COMMAND_OK</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>pgfdw_report_error</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><name>res</name></expr></argument>, <argument><expr><name><name>fsstate</name><operator>-&gt;</operator><name>conn</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>sql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Now force a fresh FETCH. */</comment>
	<expr_stmt><expr><name><name>fsstate</name><operator>-&gt;</operator><name>tuples</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fsstate</name><operator>-&gt;</operator><name>num_tuples</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fsstate</name><operator>-&gt;</operator><name>next_tuple</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fsstate</name><operator>-&gt;</operator><name>fetch_ct_2</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fsstate</name><operator>-&gt;</operator><name>eof_reached</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * postgresEndForeignScan
 *		Finish scanning foreign table and dispose objects used for this scan
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>postgresEndForeignScan</name><parameter_list>(<parameter><decl><type><name>ForeignScanState</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PgFdwScanState</name> <modifier>*</modifier></type><name>fsstate</name> <init>= <expr><operator>(</operator><name>PgFdwScanState</name> <operator>*</operator><operator>)</operator> <name><name>node</name><operator>-&gt;</operator><name>fdw_state</name></name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* if fsstate is NULL, we are in EXPLAIN; nothing to do */</comment>
	<if_stmt><if>if <condition>(<expr><name>fsstate</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/* Close the cursor if open, to prevent accumulation of cursors */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>fsstate</name><operator>-&gt;</operator><name>cursor_exists</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>close_cursor</name><argument_list>(<argument><expr><name><name>fsstate</name><operator>-&gt;</operator><name>conn</name></name></expr></argument>, <argument><expr><name><name>fsstate</name><operator>-&gt;</operator><name>cursor_number</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Release remote connection */</comment>
	<expr_stmt><expr><call><name>ReleaseConnection</name><argument_list>(<argument><expr><name><name>fsstate</name><operator>-&gt;</operator><name>conn</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fsstate</name><operator>-&gt;</operator><name>conn</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<comment type="block">/* MemoryContexts will be deleted automatically. */</comment>
</block_content>}</block></function>

<comment type="block">/*
 * postgresAddForeignUpdateTargets
 *		Add resjunk column(s) needed for update/delete on a foreign table
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>postgresAddForeignUpdateTargets</name><parameter_list>(<parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>parsetree</name></decl></parameter>,
								<parameter><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>target_rte</name></decl></parameter>,
								<parameter><decl><type><name>Relation</name></type> <name>target_relation</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Var</name>		   <modifier>*</modifier></type><name>var</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>attrname</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>tle</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * In postgres_fdw, what we need is the ctid, same as for a regular table.
	 */</comment>

	<comment type="block">/* Make a Var representing the desired value */</comment>
	<expr_stmt><expr><name>var</name> <operator>=</operator> <call><name>makeVar</name><argument_list>(<argument><expr><name><name>parsetree</name><operator>-&gt;</operator><name>resultRelation</name></name></expr></argument>,
				  <argument><expr><name>SelfItemPointerAttributeNumber</name></expr></argument>,
				  <argument><expr><name>TIDOID</name></expr></argument>,
				  <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>,
				  <argument><expr><name>InvalidOid</name></expr></argument>,
				  <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Wrap it in a resjunk TLE with the right name ... */</comment>
	<expr_stmt><expr><name>attrname</name> <operator>=</operator> <literal type="string">"ctid"</literal></expr>;</expr_stmt>

	<expr_stmt><expr><name>tle</name> <operator>=</operator> <call><name>makeTargetEntry</name><argument_list>(<argument><expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>var</name></expr></argument>,
						  <argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>parsetree</name><operator>-&gt;</operator><name>targetList</name></name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr></argument>,
						  <argument><expr><call><name>pstrdup</name><argument_list>(<argument><expr><name>attrname</name></expr></argument>)</argument_list></call></expr></argument>,
						  <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* ... and add it to the query's targetlist */</comment>
	<expr_stmt><expr><name><name>parsetree</name><operator>-&gt;</operator><name>targetList</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>parsetree</name><operator>-&gt;</operator><name>targetList</name></name></expr></argument>, <argument><expr><name>tle</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * postgresPlanForeignModify
 *		Plan an insert/update/delete operation on a foreign table
 */</comment>
<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>postgresPlanForeignModify</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
						  <parameter><decl><type><name>ModifyTable</name> <modifier>*</modifier></type><name>plan</name></decl></parameter>,
						  <parameter><decl><type><name>Index</name></type> <name>resultRelation</name></decl></parameter>,
						  <parameter><decl><type><name>int</name></type> <name>subplan_index</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>CmdType</name></type>		<name>operation</name> <init>= <expr><name><name>plan</name><operator>-&gt;</operator><name>operation</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name> <init>= <expr><call><name>planner_rt_fetch</name><argument_list>(<argument><expr><name>resultRelation</name></expr></argument>, <argument><expr><name>root</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>rel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>StringInfoData</name></type> <name>sql</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>targetAttrs</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>returningList</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>retrieved_attrs</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>doNothing</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>initStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Core code already has some lock on each rel being planned, so we can
	 * use NoLock here.
	 */</comment>
	<expr_stmt><expr><name>rel</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * In an INSERT, we transmit all columns that are defined in the foreign
	 * table.  In an UPDATE, if there are BEFORE ROW UPDATE triggers on the
	 * foreign table, we transmit all columns like INSERT; else we transmit
	 * only columns that were explicitly targets of the UPDATE, so as to avoid
	 * unnecessary data transmission.  (We can't do that for INSERT since we
	 * would miss sending default values for columns not listed in the source
	 * statement, and for UPDATE if there are BEFORE ROW UPDATE triggers since
	 * those triggers might change values for non-target columns, in which
	 * case we would miss sending changed values for those columns.)
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>operation</name> <operator>==</operator> <name>CMD_INSERT</name> <operator>||</operator>
		<operator>(</operator><name>operation</name> <operator>==</operator> <name>CMD_UPDATE</name> <operator>&amp;&amp;</operator>
		 <name><name>rel</name><operator>-&gt;</operator><name>trigdesc</name></name> <operator>&amp;&amp;</operator>
		 <name><name>rel</name><operator>-&gt;</operator><name>trigdesc</name><operator>-&gt;</operator><name>trig_update_before_row</name></name><operator>)</operator></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>TupleDesc</name></type>	<name>tupdesc</name> <init>= <expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>attnum</name></decl>;</decl_stmt>

		<for>for <control>(<init><expr><name>attnum</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>attnum</name> <operator>&lt;=</operator> <name><name>tupdesc</name><operator>-&gt;</operator><name>natts</name></name></expr>;</condition> <incr><expr><name>attnum</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>attr</name> <init>= <expr><call><name>TupleDescAttr</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><name>attnum</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>attr</name><operator>-&gt;</operator><name>attisdropped</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>targetAttrs</name> <operator>=</operator> <call><name>lappend_int</name><argument_list>(<argument><expr><name>targetAttrs</name></expr></argument>, <argument><expr><name>attnum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></for>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>operation</name> <operator>==</operator> <name>CMD_UPDATE</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>col</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>col</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
		<while>while <condition>(<expr><operator>(</operator><name>col</name> <operator>=</operator> <call><name>bms_next_member</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>updatedCols</name></name></expr></argument>, <argument><expr><name>col</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* bit numbers are offset by FirstLowInvalidHeapAttributeNumber */</comment>
			<decl_stmt><decl><type><name>AttrNumber</name></type>	<name>attno</name> <init>= <expr><name>col</name> <operator>+</operator> <name>FirstLowInvalidHeapAttributeNumber</name></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name>attno</name> <operator>&lt;=</operator> <name>InvalidAttrNumber</name></expr>)</condition><block type="pseudo"><block_content> <comment type="block">/* shouldn't happen */</comment>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"system-column update is not supported"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><name>targetAttrs</name> <operator>=</operator> <call><name>lappend_int</name><argument_list>(<argument><expr><name>targetAttrs</name></expr></argument>, <argument><expr><name>attno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></while>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Extract the relevant RETURNING list if any.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>plan</name><operator>-&gt;</operator><name>returningLists</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>returningList</name> <operator>=</operator> <operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator> <call><name>list_nth</name><argument_list>(<argument><expr><name><name>plan</name><operator>-&gt;</operator><name>returningLists</name></name></expr></argument>, <argument><expr><name>subplan_index</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * ON CONFLICT DO UPDATE and DO NOTHING case with inference specification
	 * should have already been rejected in the optimizer, as presently there
	 * is no way to recognize an arbiter index on a foreign table.  Only DO
	 * NOTHING is supported without an inference specification.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>plan</name><operator>-&gt;</operator><name>onConflictAction</name></name> <operator>==</operator> <name>ONCONFLICT_NOTHING</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>doNothing</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><name><name>plan</name><operator>-&gt;</operator><name>onConflictAction</name></name> <operator>!=</operator> <name>ONCONFLICT_NONE</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unexpected ON CONFLICT specification: %d"</literal></expr></argument>,
			 <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name><name>plan</name><operator>-&gt;</operator><name>onConflictAction</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Construct the SQL command string.
	 */</comment>
	<switch>switch <condition>(<expr><name>operation</name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>CMD_INSERT</name></expr>:</case>
			<expr_stmt><expr><call><name>deparseInsertSql</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sql</name></expr></argument>, <argument><expr><name>rte</name></expr></argument>, <argument><expr><name>resultRelation</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>,
							 <argument><expr><name>targetAttrs</name></expr></argument>, <argument><expr><name>doNothing</name></expr></argument>, <argument><expr><name>returningList</name></expr></argument>,
							 <argument><expr><operator>&amp;</operator><name>retrieved_attrs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>CMD_UPDATE</name></expr>:</case>
			<expr_stmt><expr><call><name>deparseUpdateSql</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sql</name></expr></argument>, <argument><expr><name>rte</name></expr></argument>, <argument><expr><name>resultRelation</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>,
							 <argument><expr><name>targetAttrs</name></expr></argument>, <argument><expr><name>returningList</name></expr></argument>,
							 <argument><expr><operator>&amp;</operator><name>retrieved_attrs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>CMD_DELETE</name></expr>:</case>
			<expr_stmt><expr><call><name>deparseDeleteSql</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sql</name></expr></argument>, <argument><expr><name>rte</name></expr></argument>, <argument><expr><name>resultRelation</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>,
							 <argument><expr><name>returningList</name></expr></argument>,
							 <argument><expr><operator>&amp;</operator><name>retrieved_attrs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<default>default:</default>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unexpected operation: %d"</literal></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name>operation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
	</block_content>}</block></switch>

	<expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Build the fdw_private list that will be available to the executor.
	 * Items in the list must match enum FdwModifyPrivateIndex, above.
	 */</comment>
	<return>return <expr><call><name>list_make4</name><argument_list>(<argument><expr><call><name>makeString</name><argument_list>(<argument><expr><name><name>sql</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr></argument>,
					  <argument><expr><name>targetAttrs</name></expr></argument>,
					  <argument><expr><call><name>makeInteger</name><argument_list>(<argument><expr><operator>(</operator><name>retrieved_attrs</name> <operator>!=</operator> <name>NIL</name><operator>)</operator></expr></argument>)</argument_list></call></expr></argument>,
					  <argument><expr><name>retrieved_attrs</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * postgresBeginForeignModify
 *		Begin an insert/update/delete operation on a foreign table
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>postgresBeginForeignModify</name><parameter_list>(<parameter><decl><type><name>ModifyTableState</name> <modifier>*</modifier></type><name>mtstate</name></decl></parameter>,
						   <parameter><decl><type><name>ResultRelInfo</name> <modifier>*</modifier></type><name>resultRelInfo</name></decl></parameter>,
						   <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>fdw_private</name></decl></parameter>,
						   <parameter><decl><type><name>int</name></type> <name>subplan_index</name></decl></parameter>,
						   <parameter><decl><type><name>int</name></type> <name>eflags</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PgFdwModifyState</name> <modifier>*</modifier></type><name>fmstate</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>query</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>target_attrs</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>has_returning</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>retrieved_attrs</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Do nothing in EXPLAIN (no ANALYZE) case.  resultRelInfo-&gt;ri_FdwState
	 * stays NULL.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>eflags</name> <operator>&amp;</operator> <name>EXEC_FLAG_EXPLAIN_ONLY</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/* Deconstruct fdw_private data. */</comment>
	<expr_stmt><expr><name>query</name> <operator>=</operator> <call><name>strVal</name><argument_list>(<argument><expr><call><name>list_nth</name><argument_list>(<argument><expr><name>fdw_private</name></expr></argument>,
							<argument><expr><name>FdwModifyPrivateUpdateSql</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>target_attrs</name> <operator>=</operator> <operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator> <call><name>list_nth</name><argument_list>(<argument><expr><name>fdw_private</name></expr></argument>,
									 <argument><expr><name>FdwModifyPrivateTargetAttnums</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>has_returning</name> <operator>=</operator> <call><name>intVal</name><argument_list>(<argument><expr><call><name>list_nth</name><argument_list>(<argument><expr><name>fdw_private</name></expr></argument>,
									<argument><expr><name>FdwModifyPrivateHasReturning</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>retrieved_attrs</name> <operator>=</operator> <operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator> <call><name>list_nth</name><argument_list>(<argument><expr><name>fdw_private</name></expr></argument>,
										<argument><expr><name>FdwModifyPrivateRetrievedAttrs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Find RTE. */</comment>
	<expr_stmt><expr><name>rte</name> <operator>=</operator> <call><name>rt_fetch</name><argument_list>(<argument><expr><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_RangeTableIndex</name></name></expr></argument>,
				   <argument><expr><name><name>mtstate</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>state</name><operator>-&gt;</operator><name>es_range_table</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Construct an execution state. */</comment>
	<expr_stmt><expr><name>fmstate</name> <operator>=</operator> <call><name>create_foreign_modify</name><argument_list>(<argument><expr><name><name>mtstate</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>state</name></name></expr></argument>,
									<argument><expr><name>rte</name></expr></argument>,
									<argument><expr><name>resultRelInfo</name></expr></argument>,
									<argument><expr><name><name>mtstate</name><operator>-&gt;</operator><name>operation</name></name></expr></argument>,
									<argument><expr><name><name>mtstate</name><operator>-&gt;</operator><name>mt_plans</name><index>[<expr><name>subplan_index</name></expr>]</index></name><operator>-&gt;</operator><name>plan</name></expr></argument>,
									<argument><expr><name>query</name></expr></argument>,
									<argument><expr><name>target_attrs</name></expr></argument>,
									<argument><expr><name>has_returning</name></expr></argument>,
									<argument><expr><name>retrieved_attrs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_FdwState</name></name> <operator>=</operator> <name>fmstate</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * postgresExecForeignInsert
 *		Insert one row into a foreign table
 */</comment>
<function><type><specifier>static</specifier> <name>TupleTableSlot</name> <modifier>*</modifier></type>
<name>postgresExecForeignInsert</name><parameter_list>(<parameter><decl><type><name>EState</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>,
						  <parameter><decl><type><name>ResultRelInfo</name> <modifier>*</modifier></type><name>resultRelInfo</name></decl></parameter>,
						  <parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl></parameter>,
						  <parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>planSlot</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PgFdwModifyState</name> <modifier>*</modifier></type><name>fmstate</name> <init>= <expr><operator>(</operator><name>PgFdwModifyState</name> <operator>*</operator><operator>)</operator> <name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_FdwState</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>p_values</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>n_rows</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * If the fmstate has aux_fmstate set, use the aux_fmstate (see
	 * postgresBeginForeignInsert())
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>fmstate</name><operator>-&gt;</operator><name>aux_fmstate</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>fmstate</name> <operator>=</operator> <name><name>fmstate</name><operator>-&gt;</operator><name>aux_fmstate</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Set up the prepared statement on the remote server, if we didn't yet */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>fmstate</name><operator>-&gt;</operator><name>p_name</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>prepare_foreign_modify</name><argument_list>(<argument><expr><name>fmstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Convert parameters needed by prepared statement to text form */</comment>
	<expr_stmt><expr><name>p_values</name> <operator>=</operator> <call><name>convert_prep_stmt_params</name><argument_list>(<argument><expr><name>fmstate</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Execute the prepared statement.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>PQsendQueryPrepared</name><argument_list>(<argument><expr><name><name>fmstate</name><operator>-&gt;</operator><name>conn</name></name></expr></argument>,
							 <argument><expr><name><name>fmstate</name><operator>-&gt;</operator><name>p_name</name></name></expr></argument>,
							 <argument><expr><name><name>fmstate</name><operator>-&gt;</operator><name>p_nums</name></name></expr></argument>,
							 <argument><expr><name>p_values</name></expr></argument>,
							 <argument><expr><name>NULL</name></expr></argument>,
							 <argument><expr><name>NULL</name></expr></argument>,
							 <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>pgfdw_report_error</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name><name>fmstate</name><operator>-&gt;</operator><name>conn</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name><name>fmstate</name><operator>-&gt;</operator><name>query</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Get the result, and check for success.
	 *
	 * We don't use a PG_TRY block here, so be careful not to throw error
	 * without releasing the PGresult.
	 */</comment>
	<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>pgfdw_get_result</name><argument_list>(<argument><expr><name><name>fmstate</name><operator>-&gt;</operator><name>conn</name></name></expr></argument>, <argument><expr><name><name>fmstate</name><operator>-&gt;</operator><name>query</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>PQresultStatus</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call> <operator>!=</operator>
		<operator>(</operator><ternary><condition><expr><name><name>fmstate</name><operator>-&gt;</operator><name>has_returning</name></name></expr> ?</condition><then> <expr><name>PGRES_TUPLES_OK</name></expr> </then><else>: <expr><name>PGRES_COMMAND_OK</name></expr></else></ternary><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>pgfdw_report_error</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><name>res</name></expr></argument>, <argument><expr><name><name>fmstate</name><operator>-&gt;</operator><name>conn</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name><name>fmstate</name><operator>-&gt;</operator><name>query</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Check number of rows affected, and fetch RETURNING tuple if any */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>fmstate</name><operator>-&gt;</operator><name>has_returning</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>n_rows</name> <operator>=</operator> <call><name>PQntuples</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>n_rows</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>store_returning_result</name><argument_list>(<argument><expr><name>fmstate</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>, <argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>n_rows</name> <operator>=</operator> <call><name>atoi</name><argument_list>(<argument><expr><call><name>PQcmdTuples</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/* And clean up */</comment>
	<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>MemoryContextReset</name><argument_list>(<argument><expr><name><name>fmstate</name><operator>-&gt;</operator><name>temp_cxt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Return NULL if nothing was inserted on the remote end */</comment>
	<return>return <expr><ternary><condition><expr><operator>(</operator><name>n_rows</name> <operator>&gt;</operator> <literal type="number">0</literal><operator>)</operator></expr> ?</condition><then> <expr><name>slot</name></expr> </then><else>: <expr><name>NULL</name></expr></else></ternary></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * postgresExecForeignUpdate
 *		Update one row in a foreign table
 */</comment>
<function><type><specifier>static</specifier> <name>TupleTableSlot</name> <modifier>*</modifier></type>
<name>postgresExecForeignUpdate</name><parameter_list>(<parameter><decl><type><name>EState</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>,
						  <parameter><decl><type><name>ResultRelInfo</name> <modifier>*</modifier></type><name>resultRelInfo</name></decl></parameter>,
						  <parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl></parameter>,
						  <parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>planSlot</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PgFdwModifyState</name> <modifier>*</modifier></type><name>fmstate</name> <init>= <expr><operator>(</operator><name>PgFdwModifyState</name> <operator>*</operator><operator>)</operator> <name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_FdwState</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type>		<name>datum</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>isNull</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>p_values</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>n_rows</name></decl>;</decl_stmt>

	<comment type="block">/* Set up the prepared statement on the remote server, if we didn't yet */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>fmstate</name><operator>-&gt;</operator><name>p_name</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>prepare_foreign_modify</name><argument_list>(<argument><expr><name>fmstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Get the ctid that was passed up as a resjunk column */</comment>
	<expr_stmt><expr><name>datum</name> <operator>=</operator> <call><name>ExecGetJunkAttribute</name><argument_list>(<argument><expr><name>planSlot</name></expr></argument>,
								 <argument><expr><name><name>fmstate</name><operator>-&gt;</operator><name>ctidAttno</name></name></expr></argument>,
								 <argument><expr><operator>&amp;</operator><name>isNull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* shouldn't ever get a null result... */</comment>
	<if_stmt><if>if <condition>(<expr><name>isNull</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"ctid is NULL"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Convert parameters needed by prepared statement to text form */</comment>
	<expr_stmt><expr><name>p_values</name> <operator>=</operator> <call><name>convert_prep_stmt_params</name><argument_list>(<argument><expr><name>fmstate</name></expr></argument>,
										<argument><expr><operator>(</operator><name>ItemPointer</name><operator>)</operator> <call><name>DatumGetPointer</name><argument_list>(<argument><expr><name>datum</name></expr></argument>)</argument_list></call></expr></argument>,
										<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Execute the prepared statement.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>PQsendQueryPrepared</name><argument_list>(<argument><expr><name><name>fmstate</name><operator>-&gt;</operator><name>conn</name></name></expr></argument>,
							 <argument><expr><name><name>fmstate</name><operator>-&gt;</operator><name>p_name</name></name></expr></argument>,
							 <argument><expr><name><name>fmstate</name><operator>-&gt;</operator><name>p_nums</name></name></expr></argument>,
							 <argument><expr><name>p_values</name></expr></argument>,
							 <argument><expr><name>NULL</name></expr></argument>,
							 <argument><expr><name>NULL</name></expr></argument>,
							 <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>pgfdw_report_error</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name><name>fmstate</name><operator>-&gt;</operator><name>conn</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name><name>fmstate</name><operator>-&gt;</operator><name>query</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Get the result, and check for success.
	 *
	 * We don't use a PG_TRY block here, so be careful not to throw error
	 * without releasing the PGresult.
	 */</comment>
	<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>pgfdw_get_result</name><argument_list>(<argument><expr><name><name>fmstate</name><operator>-&gt;</operator><name>conn</name></name></expr></argument>, <argument><expr><name><name>fmstate</name><operator>-&gt;</operator><name>query</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>PQresultStatus</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call> <operator>!=</operator>
		<operator>(</operator><ternary><condition><expr><name><name>fmstate</name><operator>-&gt;</operator><name>has_returning</name></name></expr> ?</condition><then> <expr><name>PGRES_TUPLES_OK</name></expr> </then><else>: <expr><name>PGRES_COMMAND_OK</name></expr></else></ternary><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>pgfdw_report_error</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><name>res</name></expr></argument>, <argument><expr><name><name>fmstate</name><operator>-&gt;</operator><name>conn</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name><name>fmstate</name><operator>-&gt;</operator><name>query</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Check number of rows affected, and fetch RETURNING tuple if any */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>fmstate</name><operator>-&gt;</operator><name>has_returning</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>n_rows</name> <operator>=</operator> <call><name>PQntuples</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>n_rows</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>store_returning_result</name><argument_list>(<argument><expr><name>fmstate</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>, <argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>n_rows</name> <operator>=</operator> <call><name>atoi</name><argument_list>(<argument><expr><call><name>PQcmdTuples</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/* And clean up */</comment>
	<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>MemoryContextReset</name><argument_list>(<argument><expr><name><name>fmstate</name><operator>-&gt;</operator><name>temp_cxt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Return NULL if nothing was updated on the remote end */</comment>
	<return>return <expr><ternary><condition><expr><operator>(</operator><name>n_rows</name> <operator>&gt;</operator> <literal type="number">0</literal><operator>)</operator></expr> ?</condition><then> <expr><name>slot</name></expr> </then><else>: <expr><name>NULL</name></expr></else></ternary></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * postgresExecForeignDelete
 *		Delete one row from a foreign table
 */</comment>
<function><type><specifier>static</specifier> <name>TupleTableSlot</name> <modifier>*</modifier></type>
<name>postgresExecForeignDelete</name><parameter_list>(<parameter><decl><type><name>EState</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>,
						  <parameter><decl><type><name>ResultRelInfo</name> <modifier>*</modifier></type><name>resultRelInfo</name></decl></parameter>,
						  <parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl></parameter>,
						  <parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>planSlot</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PgFdwModifyState</name> <modifier>*</modifier></type><name>fmstate</name> <init>= <expr><operator>(</operator><name>PgFdwModifyState</name> <operator>*</operator><operator>)</operator> <name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_FdwState</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type>		<name>datum</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>isNull</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>p_values</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>n_rows</name></decl>;</decl_stmt>

	<comment type="block">/* Set up the prepared statement on the remote server, if we didn't yet */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>fmstate</name><operator>-&gt;</operator><name>p_name</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>prepare_foreign_modify</name><argument_list>(<argument><expr><name>fmstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Get the ctid that was passed up as a resjunk column */</comment>
	<expr_stmt><expr><name>datum</name> <operator>=</operator> <call><name>ExecGetJunkAttribute</name><argument_list>(<argument><expr><name>planSlot</name></expr></argument>,
								 <argument><expr><name><name>fmstate</name><operator>-&gt;</operator><name>ctidAttno</name></name></expr></argument>,
								 <argument><expr><operator>&amp;</operator><name>isNull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* shouldn't ever get a null result... */</comment>
	<if_stmt><if>if <condition>(<expr><name>isNull</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"ctid is NULL"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Convert parameters needed by prepared statement to text form */</comment>
	<expr_stmt><expr><name>p_values</name> <operator>=</operator> <call><name>convert_prep_stmt_params</name><argument_list>(<argument><expr><name>fmstate</name></expr></argument>,
										<argument><expr><operator>(</operator><name>ItemPointer</name><operator>)</operator> <call><name>DatumGetPointer</name><argument_list>(<argument><expr><name>datum</name></expr></argument>)</argument_list></call></expr></argument>,
										<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Execute the prepared statement.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>PQsendQueryPrepared</name><argument_list>(<argument><expr><name><name>fmstate</name><operator>-&gt;</operator><name>conn</name></name></expr></argument>,
							 <argument><expr><name><name>fmstate</name><operator>-&gt;</operator><name>p_name</name></name></expr></argument>,
							 <argument><expr><name><name>fmstate</name><operator>-&gt;</operator><name>p_nums</name></name></expr></argument>,
							 <argument><expr><name>p_values</name></expr></argument>,
							 <argument><expr><name>NULL</name></expr></argument>,
							 <argument><expr><name>NULL</name></expr></argument>,
							 <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>pgfdw_report_error</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name><name>fmstate</name><operator>-&gt;</operator><name>conn</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name><name>fmstate</name><operator>-&gt;</operator><name>query</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Get the result, and check for success.
	 *
	 * We don't use a PG_TRY block here, so be careful not to throw error
	 * without releasing the PGresult.
	 */</comment>
	<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>pgfdw_get_result</name><argument_list>(<argument><expr><name><name>fmstate</name><operator>-&gt;</operator><name>conn</name></name></expr></argument>, <argument><expr><name><name>fmstate</name><operator>-&gt;</operator><name>query</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>PQresultStatus</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call> <operator>!=</operator>
		<operator>(</operator><ternary><condition><expr><name><name>fmstate</name><operator>-&gt;</operator><name>has_returning</name></name></expr> ?</condition><then> <expr><name>PGRES_TUPLES_OK</name></expr> </then><else>: <expr><name>PGRES_COMMAND_OK</name></expr></else></ternary><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>pgfdw_report_error</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><name>res</name></expr></argument>, <argument><expr><name><name>fmstate</name><operator>-&gt;</operator><name>conn</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name><name>fmstate</name><operator>-&gt;</operator><name>query</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Check number of rows affected, and fetch RETURNING tuple if any */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>fmstate</name><operator>-&gt;</operator><name>has_returning</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>n_rows</name> <operator>=</operator> <call><name>PQntuples</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>n_rows</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>store_returning_result</name><argument_list>(<argument><expr><name>fmstate</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>, <argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>n_rows</name> <operator>=</operator> <call><name>atoi</name><argument_list>(<argument><expr><call><name>PQcmdTuples</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/* And clean up */</comment>
	<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>MemoryContextReset</name><argument_list>(<argument><expr><name><name>fmstate</name><operator>-&gt;</operator><name>temp_cxt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Return NULL if nothing was deleted on the remote end */</comment>
	<return>return <expr><ternary><condition><expr><operator>(</operator><name>n_rows</name> <operator>&gt;</operator> <literal type="number">0</literal><operator>)</operator></expr> ?</condition><then> <expr><name>slot</name></expr> </then><else>: <expr><name>NULL</name></expr></else></ternary></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * postgresEndForeignModify
 *		Finish an insert/update/delete operation on a foreign table
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>postgresEndForeignModify</name><parameter_list>(<parameter><decl><type><name>EState</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>,
						 <parameter><decl><type><name>ResultRelInfo</name> <modifier>*</modifier></type><name>resultRelInfo</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PgFdwModifyState</name> <modifier>*</modifier></type><name>fmstate</name> <init>= <expr><operator>(</operator><name>PgFdwModifyState</name> <operator>*</operator><operator>)</operator> <name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_FdwState</name></name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* If fmstate is NULL, we are in EXPLAIN; nothing to do */</comment>
	<if_stmt><if>if <condition>(<expr><name>fmstate</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/* Destroy the execution state */</comment>
	<expr_stmt><expr><call><name>finish_foreign_modify</name><argument_list>(<argument><expr><name>fmstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * postgresBeginForeignInsert
 *		Begin an insert operation on a foreign table
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>postgresBeginForeignInsert</name><parameter_list>(<parameter><decl><type><name>ModifyTableState</name> <modifier>*</modifier></type><name>mtstate</name></decl></parameter>,
						   <parameter><decl><type><name>ResultRelInfo</name> <modifier>*</modifier></type><name>resultRelInfo</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PgFdwModifyState</name> <modifier>*</modifier></type><name>fmstate</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ModifyTable</name> <modifier>*</modifier></type><name>plan</name> <init>= <expr><call><name>castNode</name><argument_list>(<argument><expr><name>ModifyTable</name></expr></argument>, <argument><expr><name><name>mtstate</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>plan</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>EState</name>	   <modifier>*</modifier></type><name>estate</name> <init>= <expr><name><name>mtstate</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>state</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Index</name></type>		<name>resultRelation</name> <init>= <expr><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_RangeTableIndex</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>rel</name> <init>= <expr><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_RelationDesc</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleDesc</name></type>	<name>tupdesc</name> <init>= <expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>attnum</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>StringInfoData</name></type> <name>sql</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>targetAttrs</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>retrieved_attrs</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>doNothing</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * If the foreign table we are about to insert routed rows into is also
	 * an UPDATE subplan result rel that will be updated later, proceeding
	 * with the INSERT will result in the later UPDATE incorrectly modifying
	 * those routed rows, so prevent the INSERT --- it would be nice if we
	 * could handle this case; but for now, throw an error for safety.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>plan</name> <operator>&amp;&amp;</operator> <name><name>plan</name><operator>-&gt;</operator><name>operation</name></name> <operator>==</operator> <name>CMD_UPDATE</name> <operator>&amp;&amp;</operator>
		<operator>(</operator><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_usesFdwDirectModify</name></name> <operator>||</operator>
		 <name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_FdwState</name></name><operator>)</operator> <operator>&amp;&amp;</operator>
		<name>resultRelInfo</name> <operator>&gt;</operator> <name><name>mtstate</name><operator>-&gt;</operator><name>resultRelInfo</name></name> <operator>+</operator> <name><name>mtstate</name><operator>-&gt;</operator><name>mt_whichplan</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot route tuples into foreign table to be updated \"%s\""</literal></expr></argument>,
						<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>initStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* We transmit all columns that are defined in the foreign table. */</comment>
	<for>for <control>(<init><expr><name>attnum</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>attnum</name> <operator>&lt;=</operator> <name><name>tupdesc</name><operator>-&gt;</operator><name>natts</name></name></expr>;</condition> <incr><expr><name>attnum</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>attr</name> <init>= <expr><call><name>TupleDescAttr</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><name>attnum</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>attr</name><operator>-&gt;</operator><name>attisdropped</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>targetAttrs</name> <operator>=</operator> <call><name>lappend_int</name><argument_list>(<argument><expr><name>targetAttrs</name></expr></argument>, <argument><expr><name>attnum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></for>

	<comment type="block">/* Check if we add the ON CONFLICT clause to the remote query. */</comment>
	<if_stmt><if>if <condition>(<expr><name>plan</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>OnConflictAction</name></type> <name>onConflictAction</name> <init>= <expr><name><name>plan</name><operator>-&gt;</operator><name>onConflictAction</name></name></expr></init></decl>;</decl_stmt>

		<comment type="block">/* We only support DO NOTHING without an inference specification. */</comment>
		<if_stmt><if>if <condition>(<expr><name>onConflictAction</name> <operator>==</operator> <name>ONCONFLICT_NOTHING</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>doNothing</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><name>onConflictAction</name> <operator>!=</operator> <name>ONCONFLICT_NONE</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unexpected ON CONFLICT specification: %d"</literal></expr></argument>,
				 <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name>onConflictAction</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * If the foreign table is a partition, we need to create a new RTE
	 * describing the foreign table for use by deparseInsertSql and
	 * create_foreign_modify() below, after first copying the parent's RTE and
	 * modifying some fields to describe the foreign partition to work on.
	 * However, if this is invoked by UPDATE, the existing RTE may already
	 * correspond to this partition if it is one of the UPDATE subplan target
	 * rels; in that case, we can just use the existing RTE as-is.
	 */</comment>
	<expr_stmt><expr><name>rte</name> <operator>=</operator> <call><name>list_nth</name><argument_list>(<argument><expr><name><name>estate</name><operator>-&gt;</operator><name>es_range_table</name></name></expr></argument>, <argument><expr><name>resultRelation</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>rte</name><operator>-&gt;</operator><name>relid</name></name> <operator>!=</operator> <call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>rte</name> <operator>=</operator> <call><name>copyObject</name><argument_list>(<argument><expr><name>rte</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>rte</name><operator>-&gt;</operator><name>relid</name></name> <operator>=</operator> <call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>rte</name><operator>-&gt;</operator><name>relkind</name></name> <operator>=</operator> <name>RELKIND_FOREIGN_TABLE</name></expr>;</expr_stmt>

		<comment type="block">/*
		 * For UPDATE, we must use the RT index of the first subplan target
		 * rel's RTE, because the core code would have built expressions for
		 * the partition, such as RETURNING, using that RT index as varno of
		 * Vars contained in those expressions.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>plan</name> <operator>&amp;&amp;</operator> <name><name>plan</name><operator>-&gt;</operator><name>operation</name></name> <operator>==</operator> <name>CMD_UPDATE</name> <operator>&amp;&amp;</operator>
			<name>resultRelation</name> <operator>==</operator> <name><name>plan</name><operator>-&gt;</operator><name>nominalRelation</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>resultRelation</name> <operator>=</operator> <name><name>mtstate</name><operator>-&gt;</operator><name>resultRelInfo</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>ri_RangeTableIndex</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Construct the SQL command string. */</comment>
	<expr_stmt><expr><call><name>deparseInsertSql</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sql</name></expr></argument>, <argument><expr><name>rte</name></expr></argument>, <argument><expr><name>resultRelation</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><name>targetAttrs</name></expr></argument>, <argument><expr><name>doNothing</name></expr></argument>,
					 <argument><expr><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_returningList</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>retrieved_attrs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Construct an execution state. */</comment>
	<expr_stmt><expr><name>fmstate</name> <operator>=</operator> <call><name>create_foreign_modify</name><argument_list>(<argument><expr><name><name>mtstate</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>state</name></name></expr></argument>,
									<argument><expr><name>rte</name></expr></argument>,
									<argument><expr><name>resultRelInfo</name></expr></argument>,
									<argument><expr><name>CMD_INSERT</name></expr></argument>,
									<argument><expr><name>NULL</name></expr></argument>,
									<argument><expr><name><name>sql</name><operator>.</operator><name>data</name></name></expr></argument>,
									<argument><expr><name>targetAttrs</name></expr></argument>,
									<argument><expr><name>retrieved_attrs</name> <operator>!=</operator> <name>NIL</name></expr></argument>,
									<argument><expr><name>retrieved_attrs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If the given resultRelInfo already has PgFdwModifyState set, it means
	 * the foreign table is an UPDATE subplan result rel; in which case, store
	 * the resulting state into the aux_fmstate of the PgFdwModifyState.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_FdwState</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>plan</name> <operator>&amp;&amp;</operator> <name><name>plan</name><operator>-&gt;</operator><name>operation</name></name> <operator>==</operator> <name>CMD_UPDATE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_usesFdwDirectModify</name></name> <operator>==</operator> <name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><operator>(</operator><operator>(</operator><name>PgFdwModifyState</name> <operator>*</operator><operator>)</operator> <name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_FdwState</name></name><operator>)</operator><operator>-&gt;</operator><name>aux_fmstate</name> <operator>=</operator> <name>fmstate</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_FdwState</name></name> <operator>=</operator> <name>fmstate</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * postgresEndForeignInsert
 *		Finish an insert operation on a foreign table
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>postgresEndForeignInsert</name><parameter_list>(<parameter><decl><type><name>EState</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>,
						 <parameter><decl><type><name>ResultRelInfo</name> <modifier>*</modifier></type><name>resultRelInfo</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PgFdwModifyState</name> <modifier>*</modifier></type><name>fmstate</name> <init>= <expr><operator>(</operator><name>PgFdwModifyState</name> <operator>*</operator><operator>)</operator> <name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_FdwState</name></name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>fmstate</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If the fmstate has aux_fmstate set, get the aux_fmstate (see
	 * postgresBeginForeignInsert())
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>fmstate</name><operator>-&gt;</operator><name>aux_fmstate</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>fmstate</name> <operator>=</operator> <name><name>fmstate</name><operator>-&gt;</operator><name>aux_fmstate</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Destroy the execution state */</comment>
	<expr_stmt><expr><call><name>finish_foreign_modify</name><argument_list>(<argument><expr><name>fmstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * postgresIsForeignRelUpdatable
 *		Determine whether a foreign table supports INSERT, UPDATE and/or
 *		DELETE.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>postgresIsForeignRelUpdatable</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type>		<name>updatable</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ForeignTable</name> <modifier>*</modifier></type><name>table</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ForeignServer</name> <modifier>*</modifier></type><name>server</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * By default, all postgres_fdw foreign tables are assumed updatable. This
	 * can be overridden by a per-server setting, which in turn can be
	 * overridden by a per-table setting.
	 */</comment>
	<expr_stmt><expr><name>updatable</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>table</name> <operator>=</operator> <call><name>GetForeignTable</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>server</name> <operator>=</operator> <call><name>GetForeignServer</name><argument_list>(<argument><expr><name><name>table</name><operator>-&gt;</operator><name>serverid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>server-&gt;options</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>DefElem</name>    <modifier>*</modifier></type><name>def</name> <init>= <expr><operator>(</operator><name>DefElem</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>def</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>, <argument><expr><literal type="string">"updatable"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>updatable</name> <operator>=</operator> <call><name>defGetBoolean</name><argument_list>(<argument><expr><name>def</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block>
	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>table-&gt;options</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>DefElem</name>    <modifier>*</modifier></type><name>def</name> <init>= <expr><operator>(</operator><name>DefElem</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>def</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>, <argument><expr><literal type="string">"updatable"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>updatable</name> <operator>=</operator> <call><name>defGetBoolean</name><argument_list>(<argument><expr><name>def</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block>

	<comment type="block">/*
	 * Currently "updatable" means support for INSERT, UPDATE and DELETE.
	 */</comment>
	<return>return <expr><ternary><condition><expr><name>updatable</name></expr> ?</condition><then>
		<expr><operator>(</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <name>CMD_INSERT</name><operator>)</operator> <operator>|</operator> <operator>(</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <name>CMD_UPDATE</name><operator>)</operator> <operator>|</operator> <operator>(</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <name>CMD_DELETE</name><operator>)</operator></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * postgresRecheckForeignScan
 *		Execute a local join execution plan for a foreign join
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>postgresRecheckForeignScan</name><parameter_list>(<parameter><decl><type><name>ForeignScanState</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Index</name></type>		<name>scanrelid</name> <init>= <expr><operator>(</operator><operator>(</operator><name>Scan</name> <operator>*</operator><operator>)</operator> <name><name>node</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ps</name><operator>.</operator><name>plan</name></name><operator>)</operator><operator>-&gt;</operator><name>scanrelid</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PlanState</name>  <modifier>*</modifier></type><name>outerPlan</name> <init>= <expr><call><name>outerPlanState</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>

	<comment type="block">/* For base foreign relations, it suffices to set fdw_recheck_quals */</comment>
	<if_stmt><if>if <condition>(<expr><name>scanrelid</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>outerPlan</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Execute a local join execution plan */</comment>
	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>ExecProcNode</name><argument_list>(<argument><expr><name>outerPlan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>TupIsNull</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* Store result in the given slot */</comment>
	<expr_stmt><expr><call><name>ExecCopySlot</name><argument_list>(<argument><expr><name>slot</name></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * postgresPlanDirectModify
 *		Consider a direct foreign table modification
 *
 * Decide whether it is safe to modify a foreign table directly, and if so,
 * rewrite subplan accordingly.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>postgresPlanDirectModify</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
						 <parameter><decl><type><name>ModifyTable</name> <modifier>*</modifier></type><name>plan</name></decl></parameter>,
						 <parameter><decl><type><name>Index</name></type> <name>resultRelation</name></decl></parameter>,
						 <parameter><decl><type><name>int</name></type> <name>subplan_index</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>CmdType</name></type>		<name>operation</name> <init>= <expr><name><name>plan</name><operator>-&gt;</operator><name>operation</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Plan</name>	   <modifier>*</modifier></type><name>subplan</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>foreignrel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PgFdwRelationInfo</name> <modifier>*</modifier></type><name>fpinfo</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>rel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>StringInfoData</name></type> <name>sql</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ForeignScan</name> <modifier>*</modifier></type><name>fscan</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>targetAttrs</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>remote_exprs</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>params_list</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>returningList</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>retrieved_attrs</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * Decide whether it is safe to modify a foreign table directly.
	 */</comment>

	<comment type="block">/*
	 * The table modification must be an UPDATE or DELETE.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>operation</name> <operator>!=</operator> <name>CMD_UPDATE</name> <operator>&amp;&amp;</operator> <name>operation</name> <operator>!=</operator> <name>CMD_DELETE</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * It's unsafe to modify a foreign table directly if there are any local
	 * joins needed.
	 */</comment>
	<expr_stmt><expr><name>subplan</name> <operator>=</operator> <operator>(</operator><name>Plan</name> <operator>*</operator><operator>)</operator> <call><name>list_nth</name><argument_list>(<argument><expr><name><name>plan</name><operator>-&gt;</operator><name>plans</name></name></expr></argument>, <argument><expr><name>subplan_index</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name>subplan</name></expr></argument>, <argument><expr><name>ForeignScan</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>fscan</name> <operator>=</operator> <operator>(</operator><name>ForeignScan</name> <operator>*</operator><operator>)</operator> <name>subplan</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * It's unsafe to modify a foreign table directly if there are any quals
	 * that should be evaluated locally.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>subplan</name><operator>-&gt;</operator><name>qual</name></name> <operator>!=</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* Safe to fetch data about the target foreign rel */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>fscan</name><operator>-&gt;</operator><name>scan</name><operator>.</operator><name>scanrelid</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>foreignrel</name> <operator>=</operator> <call><name>find_join_rel</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name><name>fscan</name><operator>-&gt;</operator><name>fs_relids</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* We should have a rel for this foreign join. */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>foreignrel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>foreignrel</name> <operator>=</operator> <name><name>root</name><operator>-&gt;</operator><name>simple_rel_array</name><index>[<expr><name>resultRelation</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></else></if_stmt>
	<expr_stmt><expr><name>rte</name> <operator>=</operator> <name><name>root</name><operator>-&gt;</operator><name>simple_rte_array</name><index>[<expr><name>resultRelation</name></expr>]</index></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>fpinfo</name> <operator>=</operator> <operator>(</operator><name>PgFdwRelationInfo</name> <operator>*</operator><operator>)</operator> <name><name>foreignrel</name><operator>-&gt;</operator><name>fdw_private</name></name></expr>;</expr_stmt>

	<comment type="block">/*
	 * It's unsafe to update a foreign table directly, if any expressions to
	 * assign to the target columns are unsafe to evaluate remotely.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>operation</name> <operator>==</operator> <name>CMD_UPDATE</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>col</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * We transmit only columns that were explicitly targets of the
		 * UPDATE, so as to avoid unnecessary data transmission.
		 */</comment>
		<expr_stmt><expr><name>col</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
		<while>while <condition>(<expr><operator>(</operator><name>col</name> <operator>=</operator> <call><name>bms_next_member</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>updatedCols</name></name></expr></argument>, <argument><expr><name>col</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* bit numbers are offset by FirstLowInvalidHeapAttributeNumber */</comment>
			<decl_stmt><decl><type><name>AttrNumber</name></type>	<name>attno</name> <init>= <expr><name>col</name> <operator>+</operator> <name>FirstLowInvalidHeapAttributeNumber</name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>tle</name></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name>attno</name> <operator>&lt;=</operator> <name>InvalidAttrNumber</name></expr>)</condition><block type="pseudo"><block_content> <comment type="block">/* shouldn't happen */</comment>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"system-column update is not supported"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<expr_stmt><expr><name>tle</name> <operator>=</operator> <call><name>get_tle_by_resno</name><argument_list>(<argument><expr><name><name>subplan</name><operator>-&gt;</operator><name>targetlist</name></name></expr></argument>, <argument><expr><name>attno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>tle</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"attribute number %d not found in subplan targetlist"</literal></expr></argument>,
					 <argument><expr><name>attno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>is_foreign_expr</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>foreignrel</name></expr></argument>, <argument><expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name><name>tle</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

			<expr_stmt><expr><name>targetAttrs</name> <operator>=</operator> <call><name>lappend_int</name><argument_list>(<argument><expr><name>targetAttrs</name></expr></argument>, <argument><expr><name>attno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></while>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Ok, rewrite subplan so as to modify the foreign table directly.
	 */</comment>
	<expr_stmt><expr><call><name>initStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Core code already has some lock on each rel being planned, so we can
	 * use NoLock here.
	 */</comment>
	<expr_stmt><expr><name>rel</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Recall the qual clauses that must be evaluated remotely.  (These are
	 * bare clauses not RestrictInfos, but deparse.c's appendConditions()
	 * doesn't care.)
	 */</comment>
	<expr_stmt><expr><name>remote_exprs</name> <operator>=</operator> <name><name>fpinfo</name><operator>-&gt;</operator><name>final_remote_exprs</name></name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Extract the relevant RETURNING list if any.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>plan</name><operator>-&gt;</operator><name>returningLists</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>returningList</name> <operator>=</operator> <operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator> <call><name>list_nth</name><argument_list>(<argument><expr><name><name>plan</name><operator>-&gt;</operator><name>returningLists</name></name></expr></argument>, <argument><expr><name>subplan_index</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * When performing an UPDATE/DELETE .. RETURNING on a join directly,
		 * we fetch from the foreign server any Vars specified in RETURNING
		 * that refer not only to the target relation but to non-target
		 * relations.  So we'll deparse them into the RETURNING clause of the
		 * remote query; use a targetlist consisting of them instead, which
		 * will be adjusted to be new fdw_scan_tlist of the foreign-scan plan
		 * node below.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>fscan</name><operator>-&gt;</operator><name>scan</name><operator>.</operator><name>scanrelid</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>returningList</name> <operator>=</operator> <call><name>build_remote_returning</name><argument_list>(<argument><expr><name>resultRelation</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>,
												   <argument><expr><name>returningList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Construct the SQL command string.
	 */</comment>
	<switch>switch <condition>(<expr><name>operation</name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>CMD_UPDATE</name></expr>:</case>
			<expr_stmt><expr><call><name>deparseDirectUpdateSql</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sql</name></expr></argument>, <argument><expr><name>root</name></expr></argument>, <argument><expr><name>resultRelation</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>,
								   <argument><expr><name>foreignrel</name></expr></argument>,
								   <argument><expr><operator>(</operator><operator>(</operator><name>Plan</name> <operator>*</operator><operator>)</operator> <name>fscan</name><operator>)</operator><operator>-&gt;</operator><name>targetlist</name></expr></argument>,
								   <argument><expr><name>targetAttrs</name></expr></argument>,
								   <argument><expr><name>remote_exprs</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>params_list</name></expr></argument>,
								   <argument><expr><name>returningList</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>retrieved_attrs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>CMD_DELETE</name></expr>:</case>
			<expr_stmt><expr><call><name>deparseDirectDeleteSql</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sql</name></expr></argument>, <argument><expr><name>root</name></expr></argument>, <argument><expr><name>resultRelation</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>,
								   <argument><expr><name>foreignrel</name></expr></argument>,
								   <argument><expr><name>remote_exprs</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>params_list</name></expr></argument>,
								   <argument><expr><name>returningList</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>retrieved_attrs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<default>default:</default>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unexpected operation: %d"</literal></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name>operation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
	</block_content>}</block></switch>

	<comment type="block">/*
	 * Update the operation info.
	 */</comment>
	<expr_stmt><expr><name><name>fscan</name><operator>-&gt;</operator><name>operation</name></name> <operator>=</operator> <name>operation</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Update the fdw_exprs list that will be available to the executor.
	 */</comment>
	<expr_stmt><expr><name><name>fscan</name><operator>-&gt;</operator><name>fdw_exprs</name></name> <operator>=</operator> <name>params_list</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Update the fdw_private list that will be available to the executor.
	 * Items in the list must match enum FdwDirectModifyPrivateIndex, above.
	 */</comment>
	<expr_stmt><expr><name><name>fscan</name><operator>-&gt;</operator><name>fdw_private</name></name> <operator>=</operator> <call><name>list_make4</name><argument_list>(<argument><expr><call><name>makeString</name><argument_list>(<argument><expr><name><name>sql</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr></argument>,
									<argument><expr><call><name>makeInteger</name><argument_list>(<argument><expr><operator>(</operator><name>retrieved_attrs</name> <operator>!=</operator> <name>NIL</name><operator>)</operator></expr></argument>)</argument_list></call></expr></argument>,
									<argument><expr><name>retrieved_attrs</name></expr></argument>,
									<argument><expr><call><name>makeInteger</name><argument_list>(<argument><expr><name><name>plan</name><operator>-&gt;</operator><name>canSetTag</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Update the foreign-join-related fields.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>fscan</name><operator>-&gt;</operator><name>scan</name><operator>.</operator><name>scanrelid</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* No need for the outer subplan. */</comment>
		<expr_stmt><expr><name><name>fscan</name><operator>-&gt;</operator><name>scan</name><operator>.</operator><name>plan</name><operator>.</operator><name>lefttree</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

		<comment type="block">/* Build new fdw_scan_tlist if UPDATE/DELETE .. RETURNING. */</comment>
		<if_stmt><if>if <condition>(<expr><name>returningList</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>rebuild_fdw_scan_tlist</name><argument_list>(<argument><expr><name>fscan</name></expr></argument>, <argument><expr><name>returningList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * postgresBeginDirectModify
 *		Prepare a direct foreign table modification
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>postgresBeginDirectModify</name><parameter_list>(<parameter><decl><type><name>ForeignScanState</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>eflags</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ForeignScan</name> <modifier>*</modifier></type><name>fsplan</name> <init>= <expr><operator>(</operator><name>ForeignScan</name> <operator>*</operator><operator>)</operator> <name><name>node</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ps</name><operator>.</operator><name>plan</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>EState</name>	   <modifier>*</modifier></type><name>estate</name> <init>= <expr><name><name>node</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ps</name><operator>.</operator><name>state</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PgFdwDirectModifyState</name> <modifier>*</modifier></type><name>dmstate</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Index</name></type>		<name>rtindex</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>userid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ForeignTable</name> <modifier>*</modifier></type><name>table</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>UserMapping</name> <modifier>*</modifier></type><name>user</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>numParams</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Do nothing in EXPLAIN (no ANALYZE) case.  node-&gt;fdw_state stays NULL.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>eflags</name> <operator>&amp;</operator> <name>EXEC_FLAG_EXPLAIN_ONLY</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * We'll save private state in node-&gt;fdw_state.
	 */</comment>
	<expr_stmt><expr><name>dmstate</name> <operator>=</operator> <operator>(</operator><name>PgFdwDirectModifyState</name> <operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>PgFdwDirectModifyState</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>fdw_state</name></name> <operator>=</operator> <operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>dmstate</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Identify which user to do the remote access as.  This should match what
	 * ExecCheckRTEPerms() does.
	 */</comment>
	<expr_stmt><expr><name>rtindex</name> <operator>=</operator> <name><name>estate</name><operator>-&gt;</operator><name>es_result_relation_info</name><operator>-&gt;</operator><name>ri_RangeTableIndex</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>rte</name> <operator>=</operator> <call><name>rt_fetch</name><argument_list>(<argument><expr><name>rtindex</name></expr></argument>, <argument><expr><name><name>estate</name><operator>-&gt;</operator><name>es_range_table</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>userid</name> <operator>=</operator> <ternary><condition><expr><name><name>rte</name><operator>-&gt;</operator><name>checkAsUser</name></name></expr> ?</condition><then> <expr><name><name>rte</name><operator>-&gt;</operator><name>checkAsUser</name></name></expr> </then><else>: <expr><call><name>GetUserId</name><argument_list>()</argument_list></call></expr></else></ternary></expr>;</expr_stmt>

	<comment type="block">/* Get info about foreign table. */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>fsplan</name><operator>-&gt;</operator><name>scan</name><operator>.</operator><name>scanrelid</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>dmstate</name><operator>-&gt;</operator><name>rel</name></name> <operator>=</operator> <call><name>ExecOpenScanRelation</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name>rtindex</name></expr></argument>, <argument><expr><name>eflags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>dmstate</name><operator>-&gt;</operator><name>rel</name></name> <operator>=</operator> <name><name>node</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ss_currentRelation</name></name></expr>;</expr_stmt></block_content></block></else></if_stmt>
	<expr_stmt><expr><name>table</name> <operator>=</operator> <call><name>GetForeignTable</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name><name>dmstate</name><operator>-&gt;</operator><name>rel</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>user</name> <operator>=</operator> <call><name>GetUserMapping</name><argument_list>(<argument><expr><name>userid</name></expr></argument>, <argument><expr><name><name>table</name><operator>-&gt;</operator><name>serverid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Get connection to the foreign server.  Connection manager will
	 * establish new connection if necessary.
	 */</comment>
	<expr_stmt><expr><name><name>dmstate</name><operator>-&gt;</operator><name>conn</name></name> <operator>=</operator> <call><name>GetConnection</name><argument_list>(<argument><expr><name>user</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Update the foreign-join-related fields. */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>fsplan</name><operator>-&gt;</operator><name>scan</name><operator>.</operator><name>scanrelid</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Save info about foreign table. */</comment>
		<expr_stmt><expr><name><name>dmstate</name><operator>-&gt;</operator><name>resultRel</name></name> <operator>=</operator> <name><name>dmstate</name><operator>-&gt;</operator><name>rel</name></name></expr>;</expr_stmt>

		<comment type="block">/*
		 * Set dmstate-&gt;rel to NULL to teach get_returning_data() and
		 * make_tuple_from_result_row() that columns fetched from the remote
		 * server are described by fdw_scan_tlist of the foreign-scan plan
		 * node, not the tuple descriptor for the target relation.
		 */</comment>
		<expr_stmt><expr><name><name>dmstate</name><operator>-&gt;</operator><name>rel</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Initialize state variable */</comment>
	<expr_stmt><expr><name><name>dmstate</name><operator>-&gt;</operator><name>num_tuples</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>	<comment type="block">/* -1 means not set yet */</comment>

	<comment type="block">/* Get private info created by planner functions. */</comment>
	<expr_stmt><expr><name><name>dmstate</name><operator>-&gt;</operator><name>query</name></name> <operator>=</operator> <call><name>strVal</name><argument_list>(<argument><expr><call><name>list_nth</name><argument_list>(<argument><expr><name><name>fsplan</name><operator>-&gt;</operator><name>fdw_private</name></name></expr></argument>,
									 <argument><expr><name>FdwDirectModifyPrivateUpdateSql</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>dmstate</name><operator>-&gt;</operator><name>has_returning</name></name> <operator>=</operator> <call><name>intVal</name><argument_list>(<argument><expr><call><name>list_nth</name><argument_list>(<argument><expr><name><name>fsplan</name><operator>-&gt;</operator><name>fdw_private</name></name></expr></argument>,
											 <argument><expr><name>FdwDirectModifyPrivateHasReturning</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>dmstate</name><operator>-&gt;</operator><name>retrieved_attrs</name></name> <operator>=</operator> <operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator> <call><name>list_nth</name><argument_list>(<argument><expr><name><name>fsplan</name><operator>-&gt;</operator><name>fdw_private</name></name></expr></argument>,
												 <argument><expr><name>FdwDirectModifyPrivateRetrievedAttrs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>dmstate</name><operator>-&gt;</operator><name>set_processed</name></name> <operator>=</operator> <call><name>intVal</name><argument_list>(<argument><expr><call><name>list_nth</name><argument_list>(<argument><expr><name><name>fsplan</name><operator>-&gt;</operator><name>fdw_private</name></name></expr></argument>,
											 <argument><expr><name>FdwDirectModifyPrivateSetProcessed</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Create context for per-tuple temp workspace. */</comment>
	<expr_stmt><expr><name><name>dmstate</name><operator>-&gt;</operator><name>temp_cxt</name></name> <operator>=</operator> <call><name>AllocSetContextCreate</name><argument_list>(<argument><expr><name><name>estate</name><operator>-&gt;</operator><name>es_query_cxt</name></name></expr></argument>,
											  <argument><expr><literal type="string">"postgres_fdw temporary data"</literal></expr></argument>,
											  <argument><expr><name>ALLOCSET_SMALL_SIZES</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Prepare for input conversion of RETURNING results. */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>dmstate</name><operator>-&gt;</operator><name>has_returning</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>TupleDesc</name></type>	<name>tupdesc</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>fsplan</name><operator>-&gt;</operator><name>scan</name><operator>.</operator><name>scanrelid</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>tupdesc</name> <operator>=</operator> <name><name>node</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ss_ScanTupleSlot</name><operator>-&gt;</operator><name>tts_tupleDescriptor</name></name></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>tupdesc</name> <operator>=</operator> <call><name>RelationGetDescr</name><argument_list>(<argument><expr><name><name>dmstate</name><operator>-&gt;</operator><name>rel</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<expr_stmt><expr><name><name>dmstate</name><operator>-&gt;</operator><name>attinmeta</name></name> <operator>=</operator> <call><name>TupleDescGetAttInMetadata</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * When performing an UPDATE/DELETE .. RETURNING on a join directly,
		 * initialize a filter to extract an updated/deleted tuple from a scan
		 * tuple.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>fsplan</name><operator>-&gt;</operator><name>scan</name><operator>.</operator><name>scanrelid</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>init_returning_filter</name><argument_list>(<argument><expr><name>dmstate</name></expr></argument>, <argument><expr><name><name>fsplan</name><operator>-&gt;</operator><name>fdw_scan_tlist</name></name></expr></argument>, <argument><expr><name>rtindex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Prepare for processing of parameters used in remote query, if any.
	 */</comment>
	<expr_stmt><expr><name>numParams</name> <operator>=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>fsplan</name><operator>-&gt;</operator><name>fdw_exprs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>dmstate</name><operator>-&gt;</operator><name>numParams</name></name> <operator>=</operator> <name>numParams</name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>numParams</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>prepare_query_params</name><argument_list>(<argument><expr><operator>(</operator><name>PlanState</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>,
							 <argument><expr><name><name>fsplan</name><operator>-&gt;</operator><name>fdw_exprs</name></name></expr></argument>,
							 <argument><expr><name>numParams</name></expr></argument>,
							 <argument><expr><operator>&amp;</operator><name><name>dmstate</name><operator>-&gt;</operator><name>param_flinfo</name></name></expr></argument>,
							 <argument><expr><operator>&amp;</operator><name><name>dmstate</name><operator>-&gt;</operator><name>param_exprs</name></name></expr></argument>,
							 <argument><expr><operator>&amp;</operator><name><name>dmstate</name><operator>-&gt;</operator><name>param_values</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * postgresIterateDirectModify
 *		Execute a direct foreign table modification
 */</comment>
<function><type><specifier>static</specifier> <name>TupleTableSlot</name> <modifier>*</modifier></type>
<name>postgresIterateDirectModify</name><parameter_list>(<parameter><decl><type><name>ForeignScanState</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PgFdwDirectModifyState</name> <modifier>*</modifier></type><name>dmstate</name> <init>= <expr><operator>(</operator><name>PgFdwDirectModifyState</name> <operator>*</operator><operator>)</operator> <name><name>node</name><operator>-&gt;</operator><name>fdw_state</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>EState</name>	   <modifier>*</modifier></type><name>estate</name> <init>= <expr><name><name>node</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ps</name><operator>.</operator><name>state</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ResultRelInfo</name> <modifier>*</modifier></type><name>resultRelInfo</name> <init>= <expr><name><name>estate</name><operator>-&gt;</operator><name>es_result_relation_info</name></name></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * If this is the first call after Begin, execute the statement.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>dmstate</name><operator>-&gt;</operator><name>num_tuples</name></name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>execute_dml_stmt</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * If the local query doesn't specify RETURNING, just clear tuple slot.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_projectReturning</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name> <init>= <expr><name><name>node</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ss_ScanTupleSlot</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Instrumentation</name> <modifier>*</modifier></type><name>instr</name> <init>= <expr><name><name>node</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ps</name><operator>.</operator><name>instrument</name></name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name><name>dmstate</name><operator>-&gt;</operator><name>has_returning</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Increment the command es_processed count if necessary. */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>dmstate</name><operator>-&gt;</operator><name>set_processed</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>es_processed</name></name> <operator>+=</operator> <name><name>dmstate</name><operator>-&gt;</operator><name>num_tuples</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/* Increment the tuple count for EXPLAIN ANALYZE if necessary. */</comment>
		<if_stmt><if>if <condition>(<expr><name>instr</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>instr</name><operator>-&gt;</operator><name>tuplecount</name></name> <operator>+=</operator> <name><name>dmstate</name><operator>-&gt;</operator><name>num_tuples</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<return>return <expr><call><name>ExecClearTuple</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Get the next RETURNING tuple.
	 */</comment>
	<return>return <expr><call><name>get_returning_data</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * postgresEndDirectModify
 *		Finish a direct foreign table modification
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>postgresEndDirectModify</name><parameter_list>(<parameter><decl><type><name>ForeignScanState</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PgFdwDirectModifyState</name> <modifier>*</modifier></type><name>dmstate</name> <init>= <expr><operator>(</operator><name>PgFdwDirectModifyState</name> <operator>*</operator><operator>)</operator> <name><name>node</name><operator>-&gt;</operator><name>fdw_state</name></name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* if dmstate is NULL, we are in EXPLAIN; nothing to do */</comment>
	<if_stmt><if>if <condition>(<expr><name>dmstate</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/* Release PGresult */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>dmstate</name><operator>-&gt;</operator><name>result</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name><name>dmstate</name><operator>-&gt;</operator><name>result</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Release remote connection */</comment>
	<expr_stmt><expr><call><name>ReleaseConnection</name><argument_list>(<argument><expr><name><name>dmstate</name><operator>-&gt;</operator><name>conn</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>dmstate</name><operator>-&gt;</operator><name>conn</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<comment type="block">/* close the target relation. */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>dmstate</name><operator>-&gt;</operator><name>resultRel</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ExecCloseScanRelation</name><argument_list>(<argument><expr><name><name>dmstate</name><operator>-&gt;</operator><name>resultRel</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* MemoryContext will be deleted automatically. */</comment>
</block_content>}</block></function>

<comment type="block">/*
 * postgresExplainForeignScan
 *		Produce extra output for EXPLAIN of a ForeignScan on a foreign table
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>postgresExplainForeignScan</name><parameter_list>(<parameter><decl><type><name>ForeignScanState</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>ExplainState</name> <modifier>*</modifier></type><name>es</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>fdw_private</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>sql</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>relations</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>fdw_private</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>ForeignScan</name> <operator>*</operator><operator>)</operator> <name><name>node</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ps</name><operator>.</operator><name>plan</name></name><operator>)</operator><operator>-&gt;</operator><name>fdw_private</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Add names of relation handled by the foreign scan when the scan is a
	 * join
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name>fdw_private</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <name>FdwScanPrivateRelations</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>relations</name> <operator>=</operator> <call><name>strVal</name><argument_list>(<argument><expr><call><name>list_nth</name><argument_list>(<argument><expr><name>fdw_private</name></expr></argument>, <argument><expr><name>FdwScanPrivateRelations</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ExplainPropertyText</name><argument_list>(<argument><expr><literal type="string">"Relations"</literal></expr></argument>, <argument><expr><name>relations</name></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Add remote query, when VERBOSE option is specified.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>es</name><operator>-&gt;</operator><name>verbose</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>sql</name> <operator>=</operator> <call><name>strVal</name><argument_list>(<argument><expr><call><name>list_nth</name><argument_list>(<argument><expr><name>fdw_private</name></expr></argument>, <argument><expr><name>FdwScanPrivateSelectSql</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ExplainPropertyText</name><argument_list>(<argument><expr><literal type="string">"Remote SQL"</literal></expr></argument>, <argument><expr><name>sql</name></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * postgresExplainForeignModify
 *		Produce extra output for EXPLAIN of a ModifyTable on a foreign table
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>postgresExplainForeignModify</name><parameter_list>(<parameter><decl><type><name>ModifyTableState</name> <modifier>*</modifier></type><name>mtstate</name></decl></parameter>,
							 <parameter><decl><type><name>ResultRelInfo</name> <modifier>*</modifier></type><name>rinfo</name></decl></parameter>,
							 <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>fdw_private</name></decl></parameter>,
							 <parameter><decl><type><name>int</name></type> <name>subplan_index</name></decl></parameter>,
							 <parameter><decl><type><name>ExplainState</name> <modifier>*</modifier></type><name>es</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name><name>es</name><operator>-&gt;</operator><name>verbose</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>sql</name> <init>= <expr><call><name>strVal</name><argument_list>(<argument><expr><call><name>list_nth</name><argument_list>(<argument><expr><name>fdw_private</name></expr></argument>,
										  <argument><expr><name>FdwModifyPrivateUpdateSql</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>ExplainPropertyText</name><argument_list>(<argument><expr><literal type="string">"Remote SQL"</literal></expr></argument>, <argument><expr><name>sql</name></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * postgresExplainDirectModify
 *		Produce extra output for EXPLAIN of a ForeignScan that modifies a
 *		foreign table directly
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>postgresExplainDirectModify</name><parameter_list>(<parameter><decl><type><name>ForeignScanState</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>ExplainState</name> <modifier>*</modifier></type><name>es</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>fdw_private</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>sql</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>es</name><operator>-&gt;</operator><name>verbose</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>fdw_private</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>ForeignScan</name> <operator>*</operator><operator>)</operator> <name><name>node</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ps</name><operator>.</operator><name>plan</name></name><operator>)</operator><operator>-&gt;</operator><name>fdw_private</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>sql</name> <operator>=</operator> <call><name>strVal</name><argument_list>(<argument><expr><call><name>list_nth</name><argument_list>(<argument><expr><name>fdw_private</name></expr></argument>, <argument><expr><name>FdwDirectModifyPrivateUpdateSql</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ExplainPropertyText</name><argument_list>(<argument><expr><literal type="string">"Remote SQL"</literal></expr></argument>, <argument><expr><name>sql</name></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * estimate_path_cost_size
 *		Get cost and size estimates for a foreign scan on given foreign relation
 *		either a base relation or a join between foreign relations or an upper
 *		relation containing foreign relations.
 *
 * param_join_conds are the parameterization clauses with outer relations.
 * pathkeys specify the expected sort order if any for given path being costed.
 *
 * The function returns the cost and size estimates in p_rows, p_width,
 * p_startup_cost and p_total_cost variables.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>estimate_path_cost_size</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
						<parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>foreignrel</name></decl></parameter>,
						<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>param_join_conds</name></decl></parameter>,
						<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>pathkeys</name></decl></parameter>,
						<parameter><decl><type><name>double</name> <modifier>*</modifier></type><name>p_rows</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>p_width</name></decl></parameter>,
						<parameter><decl><type><name>Cost</name> <modifier>*</modifier></type><name>p_startup_cost</name></decl></parameter>, <parameter><decl><type><name>Cost</name> <modifier>*</modifier></type><name>p_total_cost</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PgFdwRelationInfo</name> <modifier>*</modifier></type><name>fpinfo</name> <init>= <expr><operator>(</operator><name>PgFdwRelationInfo</name> <operator>*</operator><operator>)</operator> <name><name>foreignrel</name><operator>-&gt;</operator><name>fdw_private</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type>		<name>rows</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type>		<name>retrieved_rows</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>width</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Cost</name></type>		<name>startup_cost</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Cost</name></type>		<name>total_cost</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Cost</name></type>		<name>cpu_per_tuple</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * If the table or the server is configured to use remote estimates,
	 * connect to the foreign server and execute EXPLAIN to estimate the
	 * number of rows selected by the restriction+join clauses.  Otherwise,
	 * estimate rows using whatever statistics we have locally, in a way
	 * similar to ordinary tables.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>fpinfo</name><operator>-&gt;</operator><name>use_remote_estimate</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>remote_param_join_conds</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>local_param_join_conds</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>StringInfoData</name></type> <name>sql</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>PGconn</name>	   <modifier>*</modifier></type><name>conn</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Selectivity</name></type> <name>local_sel</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>QualCost</name></type>	<name>local_cost</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>fdw_scan_tlist</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>remote_conds</name></decl>;</decl_stmt>

		<comment type="block">/* Required only to be passed to deparseSelectStmtForRel */</comment>
		<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>retrieved_attrs</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * param_join_conds might contain both clauses that are safe to send
		 * across, and clauses that aren't.
		 */</comment>
		<expr_stmt><expr><call><name>classifyConditions</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>foreignrel</name></expr></argument>, <argument><expr><name>param_join_conds</name></expr></argument>,
						   <argument><expr><operator>&amp;</operator><name>remote_param_join_conds</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>local_param_join_conds</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Build the list of columns to be fetched from the foreign server. */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>IS_JOIN_REL</name><argument_list>(<argument><expr><name>foreignrel</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>IS_UPPER_REL</name><argument_list>(<argument><expr><name>foreignrel</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>fdw_scan_tlist</name> <operator>=</operator> <call><name>build_tlist_to_deparse</name><argument_list>(<argument><expr><name>foreignrel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>fdw_scan_tlist</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<comment type="block">/*
		 * The complete list of remote conditions includes everything from
		 * baserestrictinfo plus any extra join_conds relevant to this
		 * particular path.
		 */</comment>
		<expr_stmt><expr><name>remote_conds</name> <operator>=</operator> <call><name>list_concat</name><argument_list>(<argument><expr><call><name>list_copy</name><argument_list>(<argument><expr><name>remote_param_join_conds</name></expr></argument>)</argument_list></call></expr></argument>,
								   <argument><expr><name><name>fpinfo</name><operator>-&gt;</operator><name>remote_conds</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Construct EXPLAIN query including the desired SELECT, FROM, and
		 * WHERE clauses. Params and other-relation Vars are replaced by dummy
		 * values, so don't request params_list.
		 */</comment>
		<expr_stmt><expr><call><name>initStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sql</name></expr></argument>, <argument><expr><literal type="string">"EXPLAIN "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>deparseSelectStmtForRel</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sql</name></expr></argument>, <argument><expr><name>root</name></expr></argument>, <argument><expr><name>foreignrel</name></expr></argument>, <argument><expr><name>fdw_scan_tlist</name></expr></argument>,
								<argument><expr><name>remote_conds</name></expr></argument>, <argument><expr><name>pathkeys</name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
								<argument><expr><operator>&amp;</operator><name>retrieved_attrs</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Get the remote estimate */</comment>
		<expr_stmt><expr><name>conn</name> <operator>=</operator> <call><name>GetConnection</name><argument_list>(<argument><expr><name><name>fpinfo</name><operator>-&gt;</operator><name>user</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>get_remote_estimate</name><argument_list>(<argument><expr><name><name>sql</name><operator>.</operator><name>data</name></name></expr></argument>, <argument><expr><name>conn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rows</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>width</name></expr></argument>,
							<argument><expr><operator>&amp;</operator><name>startup_cost</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>total_cost</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ReleaseConnection</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>retrieved_rows</name> <operator>=</operator> <name>rows</name></expr>;</expr_stmt>

		<comment type="block">/* Factor in the selectivity of the locally-checked quals */</comment>
		<expr_stmt><expr><name>local_sel</name> <operator>=</operator> <call><name>clauselist_selectivity</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
										   <argument><expr><name>local_param_join_conds</name></expr></argument>,
										   <argument><expr><name><name>foreignrel</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>,
										   <argument><expr><name>JOIN_INNER</name></expr></argument>,
										   <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>local_sel</name> <operator>*=</operator> <name><name>fpinfo</name><operator>-&gt;</operator><name>local_conds_sel</name></name></expr>;</expr_stmt>

		<expr_stmt><expr><name>rows</name> <operator>=</operator> <call><name>clamp_row_est</name><argument_list>(<argument><expr><name>rows</name> <operator>*</operator> <name>local_sel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Add in the eval cost of the locally-checked quals */</comment>
		<expr_stmt><expr><name>startup_cost</name> <operator>+=</operator> <name><name>fpinfo</name><operator>-&gt;</operator><name>local_conds_cost</name><operator>.</operator><name>startup</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>total_cost</name> <operator>+=</operator> <name><name>fpinfo</name><operator>-&gt;</operator><name>local_conds_cost</name><operator>.</operator><name>per_tuple</name></name> <operator>*</operator> <name>retrieved_rows</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>cost_qual_eval</name><argument_list>(<argument><expr><operator>&amp;</operator><name>local_cost</name></expr></argument>, <argument><expr><name>local_param_join_conds</name></expr></argument>, <argument><expr><name>root</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>startup_cost</name> <operator>+=</operator> <name><name>local_cost</name><operator>.</operator><name>startup</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>total_cost</name> <operator>+=</operator> <name><name>local_cost</name><operator>.</operator><name>per_tuple</name></name> <operator>*</operator> <name>retrieved_rows</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<decl_stmt><decl><type><name>Cost</name></type>		<name>run_cost</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

		<comment type="block">/*
		 * We don't support join conditions in this mode (hence, no
		 * parameterized paths can be made).
		 */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>param_join_conds</name> <operator>==</operator> <name>NIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Use rows/width estimates made by set_baserel_size_estimates() for
		 * base foreign relations and set_joinrel_size_estimates() for join
		 * between foreign relations.
		 */</comment>
		<expr_stmt><expr><name>rows</name> <operator>=</operator> <name><name>foreignrel</name><operator>-&gt;</operator><name>rows</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>width</name> <operator>=</operator> <name><name>foreignrel</name><operator>-&gt;</operator><name>reltarget</name><operator>-&gt;</operator><name>width</name></name></expr>;</expr_stmt>

		<comment type="block">/* Back into an estimate of the number of retrieved rows. */</comment>
		<expr_stmt><expr><name>retrieved_rows</name> <operator>=</operator> <call><name>clamp_row_est</name><argument_list>(<argument><expr><name>rows</name> <operator>/</operator> <name><name>fpinfo</name><operator>-&gt;</operator><name>local_conds_sel</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * We will come here again and again with different set of pathkeys
		 * that caller wants to cost. We don't need to calculate the cost of
		 * bare scan each time. Instead, use the costs if we have cached them
		 * already.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>fpinfo</name><operator>-&gt;</operator><name>rel_startup_cost</name></name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>fpinfo</name><operator>-&gt;</operator><name>rel_total_cost</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>startup_cost</name> <operator>=</operator> <name><name>fpinfo</name><operator>-&gt;</operator><name>rel_startup_cost</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name>run_cost</name> <operator>=</operator> <name><name>fpinfo</name><operator>-&gt;</operator><name>rel_total_cost</name></name> <operator>-</operator> <name><name>fpinfo</name><operator>-&gt;</operator><name>rel_startup_cost</name></name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><call><name>IS_JOIN_REL</name><argument_list>(<argument><expr><name>foreignrel</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>PgFdwRelationInfo</name> <modifier>*</modifier></type><name>fpinfo_i</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>PgFdwRelationInfo</name> <modifier>*</modifier></type><name>fpinfo_o</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>QualCost</name></type>	<name>join_cost</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>QualCost</name></type>	<name>remote_conds_cost</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>double</name></type>		<name>nrows</name></decl>;</decl_stmt>

			<comment type="block">/* For join we expect inner and outer relations set */</comment>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>fpinfo</name><operator>-&gt;</operator><name>innerrel</name></name> <operator>&amp;&amp;</operator> <name><name>fpinfo</name><operator>-&gt;</operator><name>outerrel</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name>fpinfo_i</name> <operator>=</operator> <operator>(</operator><name>PgFdwRelationInfo</name> <operator>*</operator><operator>)</operator> <name><name>fpinfo</name><operator>-&gt;</operator><name>innerrel</name><operator>-&gt;</operator><name>fdw_private</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name>fpinfo_o</name> <operator>=</operator> <operator>(</operator><name>PgFdwRelationInfo</name> <operator>*</operator><operator>)</operator> <name><name>fpinfo</name><operator>-&gt;</operator><name>outerrel</name><operator>-&gt;</operator><name>fdw_private</name></name></expr>;</expr_stmt>

			<comment type="block">/* Estimate of number of rows in cross product */</comment>
			<expr_stmt><expr><name>nrows</name> <operator>=</operator> <name><name>fpinfo_i</name><operator>-&gt;</operator><name>rows</name></name> <operator>*</operator> <name><name>fpinfo_o</name><operator>-&gt;</operator><name>rows</name></name></expr>;</expr_stmt>
			<comment type="block">/* Clamp retrieved rows estimate to at most size of cross product */</comment>
			<expr_stmt><expr><name>retrieved_rows</name> <operator>=</operator> <call><name>Min</name><argument_list>(<argument><expr><name>retrieved_rows</name></expr></argument>, <argument><expr><name>nrows</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * The cost of foreign join is estimated as cost of generating
			 * rows for the joining relations + cost for applying quals on the
			 * rows.
			 */</comment>

			<comment type="block">/*
			 * Calculate the cost of clauses pushed down to the foreign server
			 */</comment>
			<expr_stmt><expr><call><name>cost_qual_eval</name><argument_list>(<argument><expr><operator>&amp;</operator><name>remote_conds_cost</name></expr></argument>, <argument><expr><name><name>fpinfo</name><operator>-&gt;</operator><name>remote_conds</name></name></expr></argument>, <argument><expr><name>root</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* Calculate the cost of applying join clauses */</comment>
			<expr_stmt><expr><call><name>cost_qual_eval</name><argument_list>(<argument><expr><operator>&amp;</operator><name>join_cost</name></expr></argument>, <argument><expr><name><name>fpinfo</name><operator>-&gt;</operator><name>joinclauses</name></name></expr></argument>, <argument><expr><name>root</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * Startup cost includes startup cost of joining relations and the
			 * startup cost for join and other clauses. We do not include the
			 * startup cost specific to join strategy (e.g. setting up hash
			 * tables) since we do not know what strategy the foreign server
			 * is going to use.
			 */</comment>
			<expr_stmt><expr><name>startup_cost</name> <operator>=</operator> <name><name>fpinfo_i</name><operator>-&gt;</operator><name>rel_startup_cost</name></name> <operator>+</operator> <name><name>fpinfo_o</name><operator>-&gt;</operator><name>rel_startup_cost</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name>startup_cost</name> <operator>+=</operator> <name><name>join_cost</name><operator>.</operator><name>startup</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name>startup_cost</name> <operator>+=</operator> <name><name>remote_conds_cost</name><operator>.</operator><name>startup</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name>startup_cost</name> <operator>+=</operator> <name><name>fpinfo</name><operator>-&gt;</operator><name>local_conds_cost</name><operator>.</operator><name>startup</name></name></expr>;</expr_stmt>

			<comment type="block">/*
			 * Run time cost includes:
			 *
			 * 1. Run time cost (total_cost - startup_cost) of relations being
			 * joined
			 *
			 * 2. Run time cost of applying join clauses on the cross product
			 * of the joining relations.
			 *
			 * 3. Run time cost of applying pushed down other clauses on the
			 * result of join
			 *
			 * 4. Run time cost of applying nonpushable other clauses locally
			 * on the result fetched from the foreign server.
			 */</comment>
			<expr_stmt><expr><name>run_cost</name> <operator>=</operator> <name><name>fpinfo_i</name><operator>-&gt;</operator><name>rel_total_cost</name></name> <operator>-</operator> <name><name>fpinfo_i</name><operator>-&gt;</operator><name>rel_startup_cost</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name>run_cost</name> <operator>+=</operator> <name><name>fpinfo_o</name><operator>-&gt;</operator><name>rel_total_cost</name></name> <operator>-</operator> <name><name>fpinfo_o</name><operator>-&gt;</operator><name>rel_startup_cost</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name>run_cost</name> <operator>+=</operator> <name>nrows</name> <operator>*</operator> <name><name>join_cost</name><operator>.</operator><name>per_tuple</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name>nrows</name> <operator>=</operator> <call><name>clamp_row_est</name><argument_list>(<argument><expr><name>nrows</name> <operator>*</operator> <name><name>fpinfo</name><operator>-&gt;</operator><name>joinclause_sel</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>run_cost</name> <operator>+=</operator> <name>nrows</name> <operator>*</operator> <name><name>remote_conds_cost</name><operator>.</operator><name>per_tuple</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name>run_cost</name> <operator>+=</operator> <name><name>fpinfo</name><operator>-&gt;</operator><name>local_conds_cost</name><operator>.</operator><name>per_tuple</name></name> <operator>*</operator> <name>retrieved_rows</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><call><name>IS_UPPER_REL</name><argument_list>(<argument><expr><name>foreignrel</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>PgFdwRelationInfo</name> <modifier>*</modifier></type><name>ofpinfo</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>PathTarget</name> <modifier>*</modifier></type><name>ptarget</name> <init>= <expr><name><name>foreignrel</name><operator>-&gt;</operator><name>reltarget</name></name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>AggClauseCosts</name></type> <name>aggcosts</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>double</name></type>		<name>input_rows</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int</name></type>			<name>numGroupCols</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>double</name></type>		<name>numGroups</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

			<comment type="block">/* Make sure the core code set the pathtarget. */</comment>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>ptarget</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * This cost model is mixture of costing done for sorted and
			 * hashed aggregates in cost_agg().  We are not sure which
			 * strategy will be considered at remote side, thus for
			 * simplicity, we put all startup related costs in startup_cost
			 * and all finalization and run cost are added in total_cost.
			 *
			 * Also, core does not care about costing HAVING expressions and
			 * adding that to the costs.  So similarly, here too we are not
			 * considering remote and local conditions for costing.
			 */</comment>

			<expr_stmt><expr><name>ofpinfo</name> <operator>=</operator> <operator>(</operator><name>PgFdwRelationInfo</name> <operator>*</operator><operator>)</operator> <name><name>fpinfo</name><operator>-&gt;</operator><name>outerrel</name><operator>-&gt;</operator><name>fdw_private</name></name></expr>;</expr_stmt>

			<comment type="block">/* Get rows and width from input rel */</comment>
			<expr_stmt><expr><name>input_rows</name> <operator>=</operator> <name><name>ofpinfo</name><operator>-&gt;</operator><name>rows</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name>width</name> <operator>=</operator> <name><name>ofpinfo</name><operator>-&gt;</operator><name>width</name></name></expr>;</expr_stmt>

			<comment type="block">/* Collect statistics about aggregates for estimating costs. */</comment>
			<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><operator>&amp;</operator><name>aggcosts</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>AggClauseCosts</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>root</name><operator>-&gt;</operator><name>parse</name><operator>-&gt;</operator><name>hasAggs</name></name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>get_agg_clause_costs</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>fpinfo</name><operator>-&gt;</operator><name>grouped_tlist</name></name></expr></argument>,
									 <argument><expr><name>AGGSPLIT_SIMPLE</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>aggcosts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/*
				 * The cost of aggregates in the HAVING qual will be the same
				 * for each child as it is for the parent, so there's no need
				 * to use a translated version of havingQual.
				 */</comment>
				<expr_stmt><expr><call><name>get_agg_clause_costs</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>root</name><operator>-&gt;</operator><name>parse</name><operator>-&gt;</operator><name>havingQual</name></name></expr></argument>,
									 <argument><expr><name>AGGSPLIT_SIMPLE</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>aggcosts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/* Get number of grouping columns and possible number of groups */</comment>
			<expr_stmt><expr><name>numGroupCols</name> <operator>=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>parse</name><operator>-&gt;</operator><name>groupClause</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>numGroups</name> <operator>=</operator> <call><name>estimate_num_groups</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
											<argument><expr><call><name>get_sortgrouplist_exprs</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>parse</name><operator>-&gt;</operator><name>groupClause</name></name></expr></argument>,
																	<argument><expr><name><name>fpinfo</name><operator>-&gt;</operator><name>grouped_tlist</name></name></expr></argument>)</argument_list></call></expr></argument>,
											<argument><expr><name>input_rows</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * Number of rows expected from foreign server will be same as
			 * that of number of groups.
			 */</comment>
			<expr_stmt><expr><name>rows</name> <operator>=</operator> <name>retrieved_rows</name> <operator>=</operator> <name>numGroups</name></expr>;</expr_stmt>

			<comment type="block">/*-----
			 * Startup cost includes:
			 *	  1. Startup cost for underneath input relation
			 *	  2. Cost of performing aggregation, per cost_agg()
			 *	  3. Startup cost for PathTarget eval
			 *-----
			 */</comment>
			<expr_stmt><expr><name>startup_cost</name> <operator>=</operator> <name><name>ofpinfo</name><operator>-&gt;</operator><name>rel_startup_cost</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name>startup_cost</name> <operator>+=</operator> <name><name>aggcosts</name><operator>.</operator><name>transCost</name><operator>.</operator><name>startup</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name>startup_cost</name> <operator>+=</operator> <name><name>aggcosts</name><operator>.</operator><name>transCost</name><operator>.</operator><name>per_tuple</name></name> <operator>*</operator> <name>input_rows</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>startup_cost</name> <operator>+=</operator> <operator>(</operator><name>cpu_operator_cost</name> <operator>*</operator> <name>numGroupCols</name><operator>)</operator> <operator>*</operator> <name>input_rows</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>startup_cost</name> <operator>+=</operator> <name><name>ptarget</name><operator>-&gt;</operator><name>cost</name><operator>.</operator><name>startup</name></name></expr>;</expr_stmt>

			<comment type="block">/*-----
			 * Run time cost includes:
			 *	  1. Run time cost of underneath input relation
			 *	  2. Run time cost of performing aggregation, per cost_agg()
			 *	  3. PathTarget eval cost for each output row
			 *-----
			 */</comment>
			<expr_stmt><expr><name>run_cost</name> <operator>=</operator> <name><name>ofpinfo</name><operator>-&gt;</operator><name>rel_total_cost</name></name> <operator>-</operator> <name><name>ofpinfo</name><operator>-&gt;</operator><name>rel_startup_cost</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name>run_cost</name> <operator>+=</operator> <name><name>aggcosts</name><operator>.</operator><name>finalCost</name></name> <operator>*</operator> <name>numGroups</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>run_cost</name> <operator>+=</operator> <name>cpu_tuple_cost</name> <operator>*</operator> <name>numGroups</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>run_cost</name> <operator>+=</operator> <name><name>ptarget</name><operator>-&gt;</operator><name>cost</name><operator>.</operator><name>per_tuple</name></name> <operator>*</operator> <name>numGroups</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/* Clamp retrieved rows estimates to at most foreignrel-&gt;tuples. */</comment>
			<expr_stmt><expr><name>retrieved_rows</name> <operator>=</operator> <call><name>Min</name><argument_list>(<argument><expr><name>retrieved_rows</name></expr></argument>, <argument><expr><name><name>foreignrel</name><operator>-&gt;</operator><name>tuples</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * Cost as though this were a seqscan, which is pessimistic.  We
			 * effectively imagine the local_conds are being evaluated
			 * remotely, too.
			 */</comment>
			<expr_stmt><expr><name>startup_cost</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name>run_cost</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name>run_cost</name> <operator>+=</operator> <name>seq_page_cost</name> <operator>*</operator> <name><name>foreignrel</name><operator>-&gt;</operator><name>pages</name></name></expr>;</expr_stmt>

			<expr_stmt><expr><name>startup_cost</name> <operator>+=</operator> <name><name>foreignrel</name><operator>-&gt;</operator><name>baserestrictcost</name><operator>.</operator><name>startup</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name>cpu_per_tuple</name> <operator>=</operator> <name>cpu_tuple_cost</name> <operator>+</operator> <name><name>foreignrel</name><operator>-&gt;</operator><name>baserestrictcost</name><operator>.</operator><name>per_tuple</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name>run_cost</name> <operator>+=</operator> <name>cpu_per_tuple</name> <operator>*</operator> <name><name>foreignrel</name><operator>-&gt;</operator><name>tuples</name></name></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<comment type="block">/*
		 * Without remote estimates, we have no real way to estimate the cost
		 * of generating sorted output.  It could be free if the query plan
		 * the remote side would have chosen generates properly-sorted output
		 * anyway, but in most cases it will cost something.  Estimate a value
		 * high enough that we won't pick the sorted path when the ordering
		 * isn't locally useful, but low enough that we'll err on the side of
		 * pushing down the ORDER BY clause when it's useful to do so.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>pathkeys</name> <operator>!=</operator> <name>NIL</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>startup_cost</name> <operator>*=</operator> <name>DEFAULT_FDW_SORT_MULTIPLIER</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>run_cost</name> <operator>*=</operator> <name>DEFAULT_FDW_SORT_MULTIPLIER</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name>total_cost</name> <operator>=</operator> <name>startup_cost</name> <operator>+</operator> <name>run_cost</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/*
	 * Cache the costs for scans without any pathkeys or parameterization
	 * before adding the costs for transferring data from the foreign server.
	 * These costs are useful for costing the join between this relation and
	 * another foreign relation or to calculate the costs of paths with
	 * pathkeys for this relation, when the costs can not be obtained from the
	 * foreign server. This function will be called at least once for every
	 * foreign relation without pathkeys and parameterization.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>pathkeys</name> <operator>==</operator> <name>NIL</name> <operator>&amp;&amp;</operator> <name>param_join_conds</name> <operator>==</operator> <name>NIL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>fpinfo</name><operator>-&gt;</operator><name>rel_startup_cost</name></name> <operator>=</operator> <name>startup_cost</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>fpinfo</name><operator>-&gt;</operator><name>rel_total_cost</name></name> <operator>=</operator> <name>total_cost</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Add some additional cost factors to account for connection overhead
	 * (fdw_startup_cost), transferring data across the network
	 * (fdw_tuple_cost per retrieved row), and local manipulation of the data
	 * (cpu_tuple_cost per retrieved row).
	 */</comment>
	<expr_stmt><expr><name>startup_cost</name> <operator>+=</operator> <name><name>fpinfo</name><operator>-&gt;</operator><name>fdw_startup_cost</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>total_cost</name> <operator>+=</operator> <name><name>fpinfo</name><operator>-&gt;</operator><name>fdw_startup_cost</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>total_cost</name> <operator>+=</operator> <name><name>fpinfo</name><operator>-&gt;</operator><name>fdw_tuple_cost</name></name> <operator>*</operator> <name>retrieved_rows</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>total_cost</name> <operator>+=</operator> <name>cpu_tuple_cost</name> <operator>*</operator> <name>retrieved_rows</name></expr>;</expr_stmt>

	<comment type="block">/* Return results. */</comment>
	<expr_stmt><expr><operator>*</operator><name>p_rows</name> <operator>=</operator> <name>rows</name></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>p_width</name> <operator>=</operator> <name>width</name></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>p_startup_cost</name> <operator>=</operator> <name>startup_cost</name></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>p_total_cost</name> <operator>=</operator> <name>total_cost</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Estimate costs of executing a SQL statement remotely.
 * The given "sql" must be an EXPLAIN command.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>get_remote_estimate</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>sql</name></decl></parameter>, <parameter><decl><type><name>PGconn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>,
					<parameter><decl><type><name>double</name> <modifier>*</modifier></type><name>rows</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>width</name></decl></parameter>,
					<parameter><decl><type><name>Cost</name> <modifier>*</modifier></type><name>startup_cost</name></decl></parameter>, <parameter><decl><type><name>Cost</name> <modifier>*</modifier></type><name>total_cost</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier><specifier>volatile</specifier></type> <name>res</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* PGresult must be released before leaving this function. */</comment>
	<expr_stmt><expr><call><name>PG_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>line</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>n</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * Execute EXPLAIN remotely.
		 */</comment>
		<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>pgfdw_exec_query</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>sql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>PQresultStatus</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>PGRES_TUPLES_OK</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>pgfdw_report_error</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><name>res</name></expr></argument>, <argument><expr><name>conn</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>sql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * Extract cost numbers for topmost plan node.  Note we search for a
		 * left paren from the end of the line to avoid being confused by
		 * other uses of parentheses.
		 */</comment>
		<expr_stmt><expr><name>line</name> <operator>=</operator> <call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>strrchr</name><argument_list>(<argument><expr><name>line</name></expr></argument>, <argument><expr><literal type="char">'('</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>p</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"could not interpret EXPLAIN output: \"%s\""</literal></expr></argument>, <argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>sscanf</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="string">"(cost=%lf..%lf rows=%lf width=%d)"</literal></expr></argument>,
				   <argument><expr><name>startup_cost</name></expr></argument>, <argument><expr><name>total_cost</name></expr></argument>, <argument><expr><name>rows</name></expr></argument>, <argument><expr><name>width</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>n</name> <operator>!=</operator> <literal type="number">4</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"could not interpret EXPLAIN output: \"%s\""</literal></expr></argument>, <argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>res</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	</block_content>}</block>
	<expr_stmt><expr><call><name>PG_CATCH</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>res</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>PG_RE_THROW</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
	<expr_stmt><expr><call><name>PG_END_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Detect whether we want to process an EquivalenceClass member.
 *
 * This is a callback for use by generate_implied_equalities_for_column.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>ec_member_matches_foreign</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>rel</name></decl></parameter>,
						  <parameter><decl><type><name>EquivalenceClass</name> <modifier>*</modifier></type><name>ec</name></decl></parameter>, <parameter><decl><type><name>EquivalenceMember</name> <modifier>*</modifier></type><name>em</name></decl></parameter>,
						  <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ec_member_foreign_arg</name> <modifier>*</modifier></type><name>state</name> <init>= <expr><operator>(</operator><name>ec_member_foreign_arg</name> <operator>*</operator><operator>)</operator> <name>arg</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Expr</name>	   <modifier>*</modifier></type><name>expr</name> <init>= <expr><name><name>em</name><operator>-&gt;</operator><name>em_expr</name></name></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * If we've identified what we're processing in the current scan, we only
	 * want to match that expression.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>current</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><call><name>equal</name><argument_list>(<argument><expr><name>expr</name></expr></argument>, <argument><expr><name><name>state</name><operator>-&gt;</operator><name>current</name></name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Otherwise, ignore anything we've already processed.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>list_member</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>already_used</name></name></expr></argument>, <argument><expr><name>expr</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* This is the new target to process. */</comment>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>current</name></name> <operator>=</operator> <name>expr</name></expr>;</expr_stmt>
	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Create cursor for node's query with current parameter values.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>create_cursor</name><parameter_list>(<parameter><decl><type><name>ForeignScanState</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PgFdwScanState</name> <modifier>*</modifier></type><name>fsstate</name> <init>= <expr><operator>(</operator><name>PgFdwScanState</name> <operator>*</operator><operator>)</operator> <name><name>node</name><operator>-&gt;</operator><name>fdw_state</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ExprContext</name> <modifier>*</modifier></type><name>econtext</name> <init>= <expr><name><name>node</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ps</name><operator>.</operator><name>ps_ExprContext</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>numParams</name> <init>= <expr><name><name>fsstate</name><operator>-&gt;</operator><name>numParams</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>values</name> <init>= <expr><name><name>fsstate</name><operator>-&gt;</operator><name>param_values</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PGconn</name>	   <modifier>*</modifier></type><name>conn</name> <init>= <expr><name><name>fsstate</name><operator>-&gt;</operator><name>conn</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>StringInfoData</name></type> <name>buf</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Construct array of query parameter values in text format.  We do the
	 * conversions in the short-lived per-tuple context, so as not to cause a
	 * memory leak over repeated scans.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>numParams</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcontext</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>oldcontext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>econtext</name><operator>-&gt;</operator><name>ecxt_per_tuple_memory</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>process_query_params</name><argument_list>(<argument><expr><name>econtext</name></expr></argument>,
							 <argument><expr><name><name>fsstate</name><operator>-&gt;</operator><name>param_flinfo</name></name></expr></argument>,
							 <argument><expr><name><name>fsstate</name><operator>-&gt;</operator><name>param_exprs</name></name></expr></argument>,
							 <argument><expr><name>values</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Construct the DECLARE CURSOR command */</comment>
	<expr_stmt><expr><call><name>initStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"DECLARE c%u CURSOR FOR\n%s"</literal></expr></argument>,
					 <argument><expr><name><name>fsstate</name><operator>-&gt;</operator><name>cursor_number</name></name></expr></argument>, <argument><expr><name><name>fsstate</name><operator>-&gt;</operator><name>query</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Notice that we pass NULL for paramTypes, thus forcing the remote server
	 * to infer types for all parameters.  Since we explicitly cast every
	 * parameter (see deparse.c), the "inference" is trivial and will produce
	 * the desired result.  This allows us to avoid assuming that the remote
	 * server has the same OIDs we do for the parameters' types.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>PQsendQueryParams</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name><name>buf</name><operator>.</operator><name>data</name></name></expr></argument>, <argument><expr><name>numParams</name></expr></argument>,
						   <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>values</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>pgfdw_report_error</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>conn</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name><name>buf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Get the result, and check for success.
	 *
	 * We don't use a PG_TRY block here, so be careful not to throw error
	 * without releasing the PGresult.
	 */</comment>
	<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>pgfdw_get_result</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name><name>buf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>PQresultStatus</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>PGRES_COMMAND_OK</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>pgfdw_report_error</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><name>res</name></expr></argument>, <argument><expr><name>conn</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name><name>fsstate</name><operator>-&gt;</operator><name>query</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Mark the cursor as created, and show no tuples have been retrieved */</comment>
	<expr_stmt><expr><name><name>fsstate</name><operator>-&gt;</operator><name>cursor_exists</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fsstate</name><operator>-&gt;</operator><name>tuples</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fsstate</name><operator>-&gt;</operator><name>num_tuples</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fsstate</name><operator>-&gt;</operator><name>next_tuple</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fsstate</name><operator>-&gt;</operator><name>fetch_ct_2</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fsstate</name><operator>-&gt;</operator><name>eof_reached</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<comment type="block">/* Clean up */</comment>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>buf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Fetch some more rows from the node's cursor.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>fetch_more_data</name><parameter_list>(<parameter><decl><type><name>ForeignScanState</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PgFdwScanState</name> <modifier>*</modifier></type><name>fsstate</name> <init>= <expr><operator>(</operator><name>PgFdwScanState</name> <operator>*</operator><operator>)</operator> <name><name>node</name><operator>-&gt;</operator><name>fdw_state</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier><specifier>volatile</specifier></type> <name>res</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcontext</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * We'll store the tuples in the batch_cxt.  First, flush the previous
	 * batch.
	 */</comment>
	<expr_stmt><expr><name><name>fsstate</name><operator>-&gt;</operator><name>tuples</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>MemoryContextReset</name><argument_list>(<argument><expr><name><name>fsstate</name><operator>-&gt;</operator><name>batch_cxt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>oldcontext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>fsstate</name><operator>-&gt;</operator><name>batch_cxt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* PGresult must be released before leaving this function. */</comment>
	<expr_stmt><expr><call><name>PG_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<block>{<block_content>
		<decl_stmt><decl><type><name>PGconn</name>	   <modifier>*</modifier></type><name>conn</name> <init>= <expr><name><name>fsstate</name><operator>-&gt;</operator><name>conn</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name></type>		<name><name>sql</name><index>[<expr><literal type="number">64</literal></expr>]</index></name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>numrows</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>sql</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>sql</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"FETCH %d FROM c%u"</literal></expr></argument>,
				 <argument><expr><name><name>fsstate</name><operator>-&gt;</operator><name>fetch_size</name></name></expr></argument>, <argument><expr><name><name>fsstate</name><operator>-&gt;</operator><name>cursor_number</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>pgfdw_exec_query</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>sql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* On error, report the original query, not the FETCH. */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>PQresultStatus</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>PGRES_TUPLES_OK</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>pgfdw_report_error</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><name>res</name></expr></argument>, <argument><expr><name>conn</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name><name>fsstate</name><operator>-&gt;</operator><name>query</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/* Convert the data into HeapTuples */</comment>
		<expr_stmt><expr><name>numrows</name> <operator>=</operator> <call><name>PQntuples</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>fsstate</name><operator>-&gt;</operator><name>tuples</name></name> <operator>=</operator> <operator>(</operator><name>HeapTuple</name> <operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><name>numrows</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>HeapTuple</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>fsstate</name><operator>-&gt;</operator><name>num_tuples</name></name> <operator>=</operator> <name>numrows</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>fsstate</name><operator>-&gt;</operator><name>next_tuple</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>numrows</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>IsA</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ps</name><operator>.</operator><name>plan</name></name></expr></argument>, <argument><expr><name>ForeignScan</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name><name>fsstate</name><operator>-&gt;</operator><name>tuples</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator>
				<call><name>make_tuple_from_result_row</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>,
										   <argument><expr><name><name>fsstate</name><operator>-&gt;</operator><name>rel</name></name></expr></argument>,
										   <argument><expr><name><name>fsstate</name><operator>-&gt;</operator><name>attinmeta</name></name></expr></argument>,
										   <argument><expr><name><name>fsstate</name><operator>-&gt;</operator><name>retrieved_attrs</name></name></expr></argument>,
										   <argument><expr><name>node</name></expr></argument>,
										   <argument><expr><name><name>fsstate</name><operator>-&gt;</operator><name>temp_cxt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></for>

		<comment type="block">/* Update fetch_ct_2 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>fsstate</name><operator>-&gt;</operator><name>fetch_ct_2</name></name> <operator>&lt;</operator> <literal type="number">2</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>fsstate</name><operator>-&gt;</operator><name>fetch_ct_2</name></name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/* Must be EOF if we didn't get as many tuples as we asked for. */</comment>
		<expr_stmt><expr><name><name>fsstate</name><operator>-&gt;</operator><name>eof_reached</name></name> <operator>=</operator> <operator>(</operator><name>numrows</name> <operator>&lt;</operator> <name><name>fsstate</name><operator>-&gt;</operator><name>fetch_size</name></name><operator>)</operator></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>res</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	</block_content>}</block>
	<expr_stmt><expr><call><name>PG_CATCH</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>res</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>PG_RE_THROW</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
	<expr_stmt><expr><call><name>PG_END_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Force assorted GUC parameters to settings that ensure that we'll output
 * data values in a form that is unambiguous to the remote server.
 *
 * This is rather expensive and annoying to do once per row, but there's
 * little choice if we want to be sure values are transmitted accurately;
 * we can't leave the settings in place between rows for fear of affecting
 * user-visible computations.
 *
 * We use the equivalent of a function SET option to allow the settings to
 * persist only until the caller calls reset_transmission_modes().  If an
 * error is thrown in between, guc.c will take care of undoing the settings.
 *
 * The return value is the nestlevel that must be passed to
 * reset_transmission_modes() to undo things.
 */</comment>
<function><type><name>int</name></type>
<name>set_transmission_modes</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>nestlevel</name> <init>= <expr><call><name>NewGUCNestLevel</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * The values set here should match what pg_dump does.  See also
	 * configure_remote_session in connection.c.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>DateStyle</name> <operator>!=</operator> <name>USE_ISO_DATES</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>set_config_option</name><argument_list>(<argument><expr><literal type="string">"datestyle"</literal></expr></argument>, <argument><expr><literal type="string">"ISO"</literal></expr></argument>,
								 <argument><expr><name>PGC_USERSET</name></expr></argument>, <argument><expr><name>PGC_S_SESSION</name></expr></argument>,
								 <argument><expr><name>GUC_ACTION_SAVE</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>IntervalStyle</name> <operator>!=</operator> <name>INTSTYLE_POSTGRES</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>set_config_option</name><argument_list>(<argument><expr><literal type="string">"intervalstyle"</literal></expr></argument>, <argument><expr><literal type="string">"postgres"</literal></expr></argument>,
								 <argument><expr><name>PGC_USERSET</name></expr></argument>, <argument><expr><name>PGC_S_SESSION</name></expr></argument>,
								 <argument><expr><name>GUC_ACTION_SAVE</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>extra_float_digits</name> <operator>&lt;</operator> <literal type="number">3</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>set_config_option</name><argument_list>(<argument><expr><literal type="string">"extra_float_digits"</literal></expr></argument>, <argument><expr><literal type="string">"3"</literal></expr></argument>,
								 <argument><expr><name>PGC_USERSET</name></expr></argument>, <argument><expr><name>PGC_S_SESSION</name></expr></argument>,
								 <argument><expr><name>GUC_ACTION_SAVE</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>nestlevel</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Undo the effects of set_transmission_modes().
 */</comment>
<function><type><name>void</name></type>
<name>reset_transmission_modes</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>nestlevel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>AtEOXact_GUC</name><argument_list>(<argument><expr><name>true</name></expr></argument>, <argument><expr><name>nestlevel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Utility routine to close a cursor.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>close_cursor</name><parameter_list>(<parameter><decl><type><name>PGconn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>cursor_number</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>sql</name><index>[<expr><literal type="number">64</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>sql</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>sql</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"CLOSE c%u"</literal></expr></argument>, <argument><expr><name>cursor_number</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * We don't use a PG_TRY block here, so be careful not to throw error
	 * without releasing the PGresult.
	 */</comment>
	<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>pgfdw_exec_query</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>sql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>PQresultStatus</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>PGRES_COMMAND_OK</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>pgfdw_report_error</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><name>res</name></expr></argument>, <argument><expr><name>conn</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>sql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * create_foreign_modify
 *		Construct an execution state of a foreign insert/update/delete
 *		operation
 */</comment>
<function><type><specifier>static</specifier> <name>PgFdwModifyState</name> <modifier>*</modifier></type>
<name>create_foreign_modify</name><parameter_list>(<parameter><decl><type><name>EState</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>,
					  <parameter><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name></decl></parameter>,
					  <parameter><decl><type><name>ResultRelInfo</name> <modifier>*</modifier></type><name>resultRelInfo</name></decl></parameter>,
					  <parameter><decl><type><name>CmdType</name></type> <name>operation</name></decl></parameter>,
					  <parameter><decl><type><name>Plan</name> <modifier>*</modifier></type><name>subplan</name></decl></parameter>,
					  <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>query</name></decl></parameter>,
					  <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>target_attrs</name></decl></parameter>,
					  <parameter><decl><type><name>bool</name></type> <name>has_returning</name></decl></parameter>,
					  <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>retrieved_attrs</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PgFdwModifyState</name> <modifier>*</modifier></type><name>fmstate</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>rel</name> <init>= <expr><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_RelationDesc</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleDesc</name></type>	<name>tupdesc</name> <init>= <expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>userid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ForeignTable</name> <modifier>*</modifier></type><name>table</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>UserMapping</name> <modifier>*</modifier></type><name>user</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AttrNumber</name></type>	<name>n_params</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>typefnoid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>isvarlena</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

	<comment type="block">/* Begin constructing PgFdwModifyState. */</comment>
	<expr_stmt><expr><name>fmstate</name> <operator>=</operator> <operator>(</operator><name>PgFdwModifyState</name> <operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>PgFdwModifyState</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fmstate</name><operator>-&gt;</operator><name>rel</name></name> <operator>=</operator> <name>rel</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Identify which user to do the remote access as.  This should match what
	 * ExecCheckRTEPerms() does.
	 */</comment>
	<expr_stmt><expr><name>userid</name> <operator>=</operator> <ternary><condition><expr><name><name>rte</name><operator>-&gt;</operator><name>checkAsUser</name></name></expr> ?</condition><then> <expr><name><name>rte</name><operator>-&gt;</operator><name>checkAsUser</name></name></expr> </then><else>: <expr><call><name>GetUserId</name><argument_list>()</argument_list></call></expr></else></ternary></expr>;</expr_stmt>

	<comment type="block">/* Get info about foreign table. */</comment>
	<expr_stmt><expr><name>table</name> <operator>=</operator> <call><name>GetForeignTable</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>user</name> <operator>=</operator> <call><name>GetUserMapping</name><argument_list>(<argument><expr><name>userid</name></expr></argument>, <argument><expr><name><name>table</name><operator>-&gt;</operator><name>serverid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Open connection; report that we'll create a prepared statement. */</comment>
	<expr_stmt><expr><name><name>fmstate</name><operator>-&gt;</operator><name>conn</name></name> <operator>=</operator> <call><name>GetConnection</name><argument_list>(<argument><expr><name>user</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fmstate</name><operator>-&gt;</operator><name>p_name</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>		<comment type="block">/* prepared statement not made yet */</comment>

	<comment type="block">/* Set up remote query information. */</comment>
	<expr_stmt><expr><name><name>fmstate</name><operator>-&gt;</operator><name>query</name></name> <operator>=</operator> <name>query</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fmstate</name><operator>-&gt;</operator><name>target_attrs</name></name> <operator>=</operator> <name>target_attrs</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fmstate</name><operator>-&gt;</operator><name>has_returning</name></name> <operator>=</operator> <name>has_returning</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fmstate</name><operator>-&gt;</operator><name>retrieved_attrs</name></name> <operator>=</operator> <name>retrieved_attrs</name></expr>;</expr_stmt>

	<comment type="block">/* Create context for per-tuple temp workspace. */</comment>
	<expr_stmt><expr><name><name>fmstate</name><operator>-&gt;</operator><name>temp_cxt</name></name> <operator>=</operator> <call><name>AllocSetContextCreate</name><argument_list>(<argument><expr><name><name>estate</name><operator>-&gt;</operator><name>es_query_cxt</name></name></expr></argument>,
											  <argument><expr><literal type="string">"postgres_fdw temporary data"</literal></expr></argument>,
											  <argument><expr><name>ALLOCSET_SMALL_SIZES</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Prepare for input conversion of RETURNING results. */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>fmstate</name><operator>-&gt;</operator><name>has_returning</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>fmstate</name><operator>-&gt;</operator><name>attinmeta</name></name> <operator>=</operator> <call><name>TupleDescGetAttInMetadata</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Prepare for output conversion of parameters used in prepared stmt. */</comment>
	<expr_stmt><expr><name>n_params</name> <operator>=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>fmstate</name><operator>-&gt;</operator><name>target_attrs</name></name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fmstate</name><operator>-&gt;</operator><name>p_flinfo</name></name> <operator>=</operator> <operator>(</operator><name>FmgrInfo</name> <operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>FmgrInfo</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>n_params</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fmstate</name><operator>-&gt;</operator><name>p_nums</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>operation</name> <operator>==</operator> <name>CMD_UPDATE</name> <operator>||</operator> <name>operation</name> <operator>==</operator> <name>CMD_DELETE</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>subplan</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Find the ctid resjunk column in the subplan's result */</comment>
		<expr_stmt><expr><name><name>fmstate</name><operator>-&gt;</operator><name>ctidAttno</name></name> <operator>=</operator> <call><name>ExecFindJunkAttributeInTlist</name><argument_list>(<argument><expr><name><name>subplan</name><operator>-&gt;</operator><name>targetlist</name></name></expr></argument>,
														  <argument><expr><literal type="string">"ctid"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>AttributeNumberIsValid</name><argument_list>(<argument><expr><name><name>fmstate</name><operator>-&gt;</operator><name>ctidAttno</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"could not find junk ctid column"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/* First transmittable parameter will be ctid */</comment>
		<expr_stmt><expr><call><name>getTypeOutputInfo</name><argument_list>(<argument><expr><name>TIDOID</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>typefnoid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isvarlena</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>fmgr_info</name><argument_list>(<argument><expr><name>typefnoid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>fmstate</name><operator>-&gt;</operator><name>p_flinfo</name><index>[<expr><name><name>fmstate</name><operator>-&gt;</operator><name>p_nums</name></name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>fmstate</name><operator>-&gt;</operator><name>p_nums</name></name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>operation</name> <operator>==</operator> <name>CMD_INSERT</name> <operator>||</operator> <name>operation</name> <operator>==</operator> <name>CMD_UPDATE</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Set up for remaining transmittable parameters */</comment>
		<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>fmstate-&gt;target_attrs</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>int</name></type>			<name>attnum</name> <init>= <expr><call><name>lfirst_int</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>attr</name> <init>= <expr><call><name>TupleDescAttr</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><name>attnum</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name><name>attr</name><operator>-&gt;</operator><name>attisdropped</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>getTypeOutputInfo</name><argument_list>(<argument><expr><name><name>attr</name><operator>-&gt;</operator><name>atttypid</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>typefnoid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isvarlena</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>fmgr_info</name><argument_list>(<argument><expr><name>typefnoid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>fmstate</name><operator>-&gt;</operator><name>p_flinfo</name><index>[<expr><name><name>fmstate</name><operator>-&gt;</operator><name>p_nums</name></name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>fmstate</name><operator>-&gt;</operator><name>p_nums</name></name><operator>++</operator></expr>;</expr_stmt>
		</block_content>}</block>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>fmstate</name><operator>-&gt;</operator><name>p_nums</name></name> <operator>&lt;=</operator> <name>n_params</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Initialize auxiliary state */</comment>
	<expr_stmt><expr><name><name>fmstate</name><operator>-&gt;</operator><name>aux_fmstate</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<return>return <expr><name>fmstate</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * prepare_foreign_modify
 *		Establish a prepared statement for execution of INSERT/UPDATE/DELETE
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>prepare_foreign_modify</name><parameter_list>(<parameter><decl><type><name>PgFdwModifyState</name> <modifier>*</modifier></type><name>fmstate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>prep_name</name><index>[<expr><name>NAMEDATALEN</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>p_name</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>

	<comment type="block">/* Construct name we'll use for the prepared statement. */</comment>
	<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>prep_name</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>prep_name</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"pgsql_fdw_prep_%u"</literal></expr></argument>,
			 <argument><expr><call><name>GetPrepStmtNumber</name><argument_list>(<argument><expr><name><name>fmstate</name><operator>-&gt;</operator><name>conn</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>p_name</name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><name>prep_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * We intentionally do not specify parameter types here, but leave the
	 * remote server to derive them by default.  This avoids possible problems
	 * with the remote server using different type OIDs than we do.  All of
	 * the prepared statements we use in this module are simple enough that
	 * the remote server will make the right choices.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>PQsendPrepare</name><argument_list>(<argument><expr><name><name>fmstate</name><operator>-&gt;</operator><name>conn</name></name></expr></argument>,
					   <argument><expr><name>p_name</name></expr></argument>,
					   <argument><expr><name><name>fmstate</name><operator>-&gt;</operator><name>query</name></name></expr></argument>,
					   <argument><expr><literal type="number">0</literal></expr></argument>,
					   <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>pgfdw_report_error</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name><name>fmstate</name><operator>-&gt;</operator><name>conn</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name><name>fmstate</name><operator>-&gt;</operator><name>query</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Get the result, and check for success.
	 *
	 * We don't use a PG_TRY block here, so be careful not to throw error
	 * without releasing the PGresult.
	 */</comment>
	<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>pgfdw_get_result</name><argument_list>(<argument><expr><name><name>fmstate</name><operator>-&gt;</operator><name>conn</name></name></expr></argument>, <argument><expr><name><name>fmstate</name><operator>-&gt;</operator><name>query</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>PQresultStatus</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>PGRES_COMMAND_OK</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>pgfdw_report_error</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><name>res</name></expr></argument>, <argument><expr><name><name>fmstate</name><operator>-&gt;</operator><name>conn</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name><name>fmstate</name><operator>-&gt;</operator><name>query</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* This action shows that the prepare has been done. */</comment>
	<expr_stmt><expr><name><name>fmstate</name><operator>-&gt;</operator><name>p_name</name></name> <operator>=</operator> <name>p_name</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * convert_prep_stmt_params
 *		Create array of text strings representing parameter values
 *
 * tupleid is ctid to send, or NULL if none
 * slot is slot to get remaining parameters from, or NULL if none
 *
 * Data is constructed in temp_cxt; caller should reset that after use.
 */</comment>
<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type>
<name>convert_prep_stmt_params</name><parameter_list>(<parameter><decl><type><name>PgFdwModifyState</name> <modifier>*</modifier></type><name>fmstate</name></decl></parameter>,
						 <parameter><decl><type><name>ItemPointer</name></type> <name>tupleid</name></decl></parameter>,
						 <parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>p_values</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>pindex</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcontext</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>oldcontext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>fmstate</name><operator>-&gt;</operator><name>temp_cxt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>p_values</name> <operator>=</operator> <operator>(</operator><specifier>const</specifier> <name>char</name> <operator>*</operator><operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>char</name> <operator>*</operator></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>fmstate</name><operator>-&gt;</operator><name>p_nums</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* 1st parameter should be ctid, if it's in use */</comment>
	<if_stmt><if>if <condition>(<expr><name>tupleid</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* don't need set_transmission_modes for TID output */</comment>
		<expr_stmt><expr><name><name>p_values</name><index>[<expr><name>pindex</name></expr>]</index></name> <operator>=</operator> <call><name>OutputFunctionCall</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>fmstate</name><operator>-&gt;</operator><name>p_flinfo</name><index>[<expr><name>pindex</name></expr>]</index></name></expr></argument>,
											  <argument><expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>tupleid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>pindex</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* get following parameters from slot */</comment>
	<if_stmt><if>if <condition>(<expr><name>slot</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name><name>fmstate</name><operator>-&gt;</operator><name>target_attrs</name></name> <operator>!=</operator> <name>NIL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>nestlevel</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>nestlevel</name> <operator>=</operator> <call><name>set_transmission_modes</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>fmstate-&gt;target_attrs</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>int</name></type>			<name>attnum</name> <init>= <expr><call><name>lfirst_int</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Datum</name></type>		<name>value</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>bool</name></type>		<name>isnull</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>value</name> <operator>=</operator> <call><name>slot_getattr</name><argument_list>(<argument><expr><name>slot</name></expr></argument>, <argument><expr><name>attnum</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>isnull</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>p_values</name><index>[<expr><name>pindex</name></expr>]</index></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>p_values</name><index>[<expr><name>pindex</name></expr>]</index></name> <operator>=</operator> <call><name>OutputFunctionCall</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>fmstate</name><operator>-&gt;</operator><name>p_flinfo</name><index>[<expr><name>pindex</name></expr>]</index></name></expr></argument>,
													  <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
			<expr_stmt><expr><name>pindex</name><operator>++</operator></expr>;</expr_stmt>
		</block_content>}</block>

		<expr_stmt><expr><call><name>reset_transmission_modes</name><argument_list>(<argument><expr><name>nestlevel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>pindex</name> <operator>==</operator> <name><name>fmstate</name><operator>-&gt;</operator><name>p_nums</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>p_values</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * store_returning_result
 *		Store the result of a RETURNING clause
 *
 * On error, be sure to release the PGresult on the way out.  Callers do not
 * have PG_TRY blocks to ensure this happens.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>store_returning_result</name><parameter_list>(<parameter><decl><type><name>PgFdwModifyState</name> <modifier>*</modifier></type><name>fmstate</name></decl></parameter>,
					   <parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl></parameter>, <parameter><decl><type><name>PGresult</name> <modifier>*</modifier></type><name>res</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>PG_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<block>{<block_content>
		<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>newtup</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>newtup</name> <operator>=</operator> <call><name>make_tuple_from_result_row</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
											<argument><expr><name><name>fmstate</name><operator>-&gt;</operator><name>rel</name></name></expr></argument>,
											<argument><expr><name><name>fmstate</name><operator>-&gt;</operator><name>attinmeta</name></name></expr></argument>,
											<argument><expr><name><name>fmstate</name><operator>-&gt;</operator><name>retrieved_attrs</name></name></expr></argument>,
											<argument><expr><name>NULL</name></expr></argument>,
											<argument><expr><name><name>fmstate</name><operator>-&gt;</operator><name>temp_cxt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* tuple will be deleted when it is cleared from the slot */</comment>
		<expr_stmt><expr><call><name>ExecStoreTuple</name><argument_list>(<argument><expr><name>newtup</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>, <argument><expr><name>InvalidBuffer</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
	<expr_stmt><expr><call><name>PG_CATCH</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>res</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>PG_RE_THROW</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
	<expr_stmt><expr><call><name>PG_END_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * finish_foreign_modify
 *		Release resources for a foreign insert/update/delete operation
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>finish_foreign_modify</name><parameter_list>(<parameter><decl><type><name>PgFdwModifyState</name> <modifier>*</modifier></type><name>fmstate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>fmstate</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* If we created a prepared statement, destroy it */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>fmstate</name><operator>-&gt;</operator><name>p_name</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name></type>		<name><name>sql</name><index>[<expr><literal type="number">64</literal></expr>]</index></name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>sql</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>sql</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"DEALLOCATE %s"</literal></expr></argument>, <argument><expr><name><name>fmstate</name><operator>-&gt;</operator><name>p_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * We don't use a PG_TRY block here, so be careful not to throw error
		 * without releasing the PGresult.
		 */</comment>
		<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>pgfdw_exec_query</name><argument_list>(<argument><expr><name><name>fmstate</name><operator>-&gt;</operator><name>conn</name></name></expr></argument>, <argument><expr><name>sql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>PQresultStatus</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>PGRES_COMMAND_OK</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>pgfdw_report_error</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><name>res</name></expr></argument>, <argument><expr><name><name>fmstate</name><operator>-&gt;</operator><name>conn</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>sql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>fmstate</name><operator>-&gt;</operator><name>p_name</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Release remote connection */</comment>
	<expr_stmt><expr><call><name>ReleaseConnection</name><argument_list>(<argument><expr><name><name>fmstate</name><operator>-&gt;</operator><name>conn</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fmstate</name><operator>-&gt;</operator><name>conn</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * build_remote_returning
 *		Build a RETURNING targetlist of a remote query for performing an
 *		UPDATE/DELETE .. RETURNING on a join directly
 */</comment>
<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>build_remote_returning</name><parameter_list>(<parameter><decl><type><name>Index</name></type> <name>rtindex</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>returningList</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type>		<name>have_wholerow</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>tlist</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>vars</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>returningList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>vars</name> <operator>=</operator> <call><name>pull_var_clause</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>returningList</name></expr></argument>, <argument><expr><name>PVC_INCLUDE_PLACEHOLDERS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If there's a whole-row reference to the target relation, then we'll
	 * need all the columns of the relation.
	 */</comment>
	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>vars</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Var</name>		   <modifier>*</modifier></type><name>var</name> <init>= <expr><operator>(</operator><name>Var</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>var</name></expr></argument>, <argument><expr><name>Var</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
			<name><name>var</name><operator>-&gt;</operator><name>varno</name></name> <operator>==</operator> <name>rtindex</name> <operator>&amp;&amp;</operator>
			<name><name>var</name><operator>-&gt;</operator><name>varattno</name></name> <operator>==</operator> <name>InvalidAttrNumber</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>have_wholerow</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>

	<if_stmt><if>if <condition>(<expr><name>have_wholerow</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>TupleDesc</name></type>	<name>tupdesc</name> <init>= <expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;=</operator> <name><name>tupdesc</name><operator>-&gt;</operator><name>natts</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>attr</name> <init>= <expr><call><name>TupleDescAttr</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><name>i</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Var</name>		   <modifier>*</modifier></type><name>var</name></decl>;</decl_stmt>

			<comment type="block">/* Ignore dropped attributes. */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>attr</name><operator>-&gt;</operator><name>attisdropped</name></name></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>

			<expr_stmt><expr><name>var</name> <operator>=</operator> <call><name>makeVar</name><argument_list>(<argument><expr><name>rtindex</name></expr></argument>,
						  <argument><expr><name>i</name></expr></argument>,
						  <argument><expr><name><name>attr</name><operator>-&gt;</operator><name>atttypid</name></name></expr></argument>,
						  <argument><expr><name><name>attr</name><operator>-&gt;</operator><name>atttypmod</name></name></expr></argument>,
						  <argument><expr><name><name>attr</name><operator>-&gt;</operator><name>attcollation</name></name></expr></argument>,
						  <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name>tlist</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>tlist</name></expr></argument>,
							<argument><expr><call><name>makeTargetEntry</name><argument_list>(<argument><expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>var</name></expr></argument>,
											<argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name>tlist</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr></argument>,
											<argument><expr><name>NULL</name></expr></argument>,
											<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></for>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Now add any remaining columns to tlist. */</comment>
	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>vars</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Var</name>		   <modifier>*</modifier></type><name>var</name> <init>= <expr><operator>(</operator><name>Var</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/*
		 * No need for whole-row references to the target relation.  We don't
		 * need system columns other than ctid and oid either, since those are
		 * set locally.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>var</name></expr></argument>, <argument><expr><name>Var</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
			<name><name>var</name><operator>-&gt;</operator><name>varno</name></name> <operator>==</operator> <name>rtindex</name> <operator>&amp;&amp;</operator>
			<name><name>var</name><operator>-&gt;</operator><name>varattno</name></name> <operator>&lt;=</operator> <name>InvalidAttrNumber</name> <operator>&amp;&amp;</operator>
			<name><name>var</name><operator>-&gt;</operator><name>varattno</name></name> <operator>!=</operator> <name>SelfItemPointerAttributeNumber</name> <operator>&amp;&amp;</operator>
			<name><name>var</name><operator>-&gt;</operator><name>varattno</name></name> <operator>!=</operator> <name>ObjectIdAttributeNumber</name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>			<comment type="block">/* don't need it */</comment>

		<if_stmt><if>if <condition>(<expr><call><name>tlist_member</name><argument_list>(<argument><expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>var</name></expr></argument>, <argument><expr><name>tlist</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>			<comment type="block">/* already got it */</comment>

		<expr_stmt><expr><name>tlist</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>tlist</name></expr></argument>,
						<argument><expr><call><name>makeTargetEntry</name><argument_list>(<argument><expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>var</name></expr></argument>,
										<argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name>tlist</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr></argument>,
										<argument><expr><name>NULL</name></expr></argument>,
										<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<expr_stmt><expr><call><name>list_free</name><argument_list>(<argument><expr><name>vars</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>tlist</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * rebuild_fdw_scan_tlist
 *		Build new fdw_scan_tlist of given foreign-scan plan node from given
 *		tlist
 *
 * There might be columns that the fdw_scan_tlist of the given foreign-scan
 * plan node contains that the given tlist doesn't.  The fdw_scan_tlist would
 * have contained resjunk columns such as 'ctid' of the target relation and
 * 'wholerow' of non-target relations, but the tlist might not contain them,
 * for example.  So, adjust the tlist so it contains all the columns specified
 * in the fdw_scan_tlist; else setrefs.c will get confused.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>rebuild_fdw_scan_tlist</name><parameter_list>(<parameter><decl><type><name>ForeignScan</name> <modifier>*</modifier></type><name>fscan</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>tlist</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>new_tlist</name> <init>= <expr><name>tlist</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>old_tlist</name> <init>= <expr><name><name>fscan</name><operator>-&gt;</operator><name>fdw_scan_tlist</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>old_tlist</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>tle</name> <init>= <expr><operator>(</operator><name>TargetEntry</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>tlist_member</name><argument_list>(<argument><expr><name><name>tle</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>, <argument><expr><name>new_tlist</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>			<comment type="block">/* already got it */</comment>

		<expr_stmt><expr><name>new_tlist</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>new_tlist</name></expr></argument>,
							<argument><expr><call><name>makeTargetEntry</name><argument_list>(<argument><expr><name><name>tle</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>,
											<argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name>new_tlist</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr></argument>,
											<argument><expr><name>NULL</name></expr></argument>,
											<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
	<expr_stmt><expr><name><name>fscan</name><operator>-&gt;</operator><name>fdw_scan_tlist</name></name> <operator>=</operator> <name>new_tlist</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Execute a direct UPDATE/DELETE statement.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>execute_dml_stmt</name><parameter_list>(<parameter><decl><type><name>ForeignScanState</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PgFdwDirectModifyState</name> <modifier>*</modifier></type><name>dmstate</name> <init>= <expr><operator>(</operator><name>PgFdwDirectModifyState</name> <operator>*</operator><operator>)</operator> <name><name>node</name><operator>-&gt;</operator><name>fdw_state</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ExprContext</name> <modifier>*</modifier></type><name>econtext</name> <init>= <expr><name><name>node</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ps</name><operator>.</operator><name>ps_ExprContext</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>numParams</name> <init>= <expr><name><name>dmstate</name><operator>-&gt;</operator><name>numParams</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>values</name> <init>= <expr><name><name>dmstate</name><operator>-&gt;</operator><name>param_values</name></name></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * Construct array of query parameter values in text format.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>numParams</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>process_query_params</name><argument_list>(<argument><expr><name>econtext</name></expr></argument>,
							 <argument><expr><name><name>dmstate</name><operator>-&gt;</operator><name>param_flinfo</name></name></expr></argument>,
							 <argument><expr><name><name>dmstate</name><operator>-&gt;</operator><name>param_exprs</name></name></expr></argument>,
							 <argument><expr><name>values</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Notice that we pass NULL for paramTypes, thus forcing the remote server
	 * to infer types for all parameters.  Since we explicitly cast every
	 * parameter (see deparse.c), the "inference" is trivial and will produce
	 * the desired result.  This allows us to avoid assuming that the remote
	 * server has the same OIDs we do for the parameters' types.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>PQsendQueryParams</name><argument_list>(<argument><expr><name><name>dmstate</name><operator>-&gt;</operator><name>conn</name></name></expr></argument>, <argument><expr><name><name>dmstate</name><operator>-&gt;</operator><name>query</name></name></expr></argument>, <argument><expr><name>numParams</name></expr></argument>,
						   <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>values</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>pgfdw_report_error</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name><name>dmstate</name><operator>-&gt;</operator><name>conn</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name><name>dmstate</name><operator>-&gt;</operator><name>query</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Get the result, and check for success.
	 *
	 * We don't use a PG_TRY block here, so be careful not to throw error
	 * without releasing the PGresult.
	 */</comment>
	<expr_stmt><expr><name><name>dmstate</name><operator>-&gt;</operator><name>result</name></name> <operator>=</operator> <call><name>pgfdw_get_result</name><argument_list>(<argument><expr><name><name>dmstate</name><operator>-&gt;</operator><name>conn</name></name></expr></argument>, <argument><expr><name><name>dmstate</name><operator>-&gt;</operator><name>query</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>PQresultStatus</name><argument_list>(<argument><expr><name><name>dmstate</name><operator>-&gt;</operator><name>result</name></name></expr></argument>)</argument_list></call> <operator>!=</operator>
		<operator>(</operator><ternary><condition><expr><name><name>dmstate</name><operator>-&gt;</operator><name>has_returning</name></name></expr> ?</condition><then> <expr><name>PGRES_TUPLES_OK</name></expr> </then><else>: <expr><name>PGRES_COMMAND_OK</name></expr></else></ternary><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>pgfdw_report_error</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><name><name>dmstate</name><operator>-&gt;</operator><name>result</name></name></expr></argument>, <argument><expr><name><name>dmstate</name><operator>-&gt;</operator><name>conn</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>,
						   <argument><expr><name><name>dmstate</name><operator>-&gt;</operator><name>query</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Get the number of rows affected. */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>dmstate</name><operator>-&gt;</operator><name>has_returning</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>dmstate</name><operator>-&gt;</operator><name>num_tuples</name></name> <operator>=</operator> <call><name>PQntuples</name><argument_list>(<argument><expr><name><name>dmstate</name><operator>-&gt;</operator><name>result</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>dmstate</name><operator>-&gt;</operator><name>num_tuples</name></name> <operator>=</operator> <call><name>atoi</name><argument_list>(<argument><expr><call><name>PQcmdTuples</name><argument_list>(<argument><expr><name><name>dmstate</name><operator>-&gt;</operator><name>result</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Get the result of a RETURNING clause.
 */</comment>
<function><type><specifier>static</specifier> <name>TupleTableSlot</name> <modifier>*</modifier></type>
<name>get_returning_data</name><parameter_list>(<parameter><decl><type><name>ForeignScanState</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PgFdwDirectModifyState</name> <modifier>*</modifier></type><name>dmstate</name> <init>= <expr><operator>(</operator><name>PgFdwDirectModifyState</name> <operator>*</operator><operator>)</operator> <name><name>node</name><operator>-&gt;</operator><name>fdw_state</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>EState</name>	   <modifier>*</modifier></type><name>estate</name> <init>= <expr><name><name>node</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ps</name><operator>.</operator><name>state</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ResultRelInfo</name> <modifier>*</modifier></type><name>resultRelInfo</name> <init>= <expr><name><name>estate</name><operator>-&gt;</operator><name>es_result_relation_info</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name> <init>= <expr><name><name>node</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ss_ScanTupleSlot</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>resultSlot</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_projectReturning</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* If we didn't get any tuples, must be end of data. */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>dmstate</name><operator>-&gt;</operator><name>next_tuple</name></name> <operator>&gt;=</operator> <name><name>dmstate</name><operator>-&gt;</operator><name>num_tuples</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><call><name>ExecClearTuple</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* Increment the command es_processed count if necessary. */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>dmstate</name><operator>-&gt;</operator><name>set_processed</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>es_processed</name></name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Store a RETURNING tuple.  If has_returning is false, just emit a dummy
	 * tuple.  (has_returning is false when the local query is of the form
	 * "UPDATE/DELETE .. RETURNING 1" for example.)
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>dmstate</name><operator>-&gt;</operator><name>has_returning</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ExecStoreAllNullTuple</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>resultSlot</name> <operator>=</operator> <name>slot</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/*
		 * On error, be sure to release the PGresult on the way out.  Callers
		 * do not have PG_TRY blocks to ensure this happens.
		 */</comment>
		<expr_stmt><expr><call><name>PG_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<block>{<block_content>
			<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>newtup</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>newtup</name> <operator>=</operator> <call><name>make_tuple_from_result_row</name><argument_list>(<argument><expr><name><name>dmstate</name><operator>-&gt;</operator><name>result</name></name></expr></argument>,
												<argument><expr><name><name>dmstate</name><operator>-&gt;</operator><name>next_tuple</name></name></expr></argument>,
												<argument><expr><name><name>dmstate</name><operator>-&gt;</operator><name>rel</name></name></expr></argument>,
												<argument><expr><name><name>dmstate</name><operator>-&gt;</operator><name>attinmeta</name></name></expr></argument>,
												<argument><expr><name><name>dmstate</name><operator>-&gt;</operator><name>retrieved_attrs</name></name></expr></argument>,
												<argument><expr><name>node</name></expr></argument>,
												<argument><expr><name><name>dmstate</name><operator>-&gt;</operator><name>temp_cxt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>ExecStoreTuple</name><argument_list>(<argument><expr><name>newtup</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>, <argument><expr><name>InvalidBuffer</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>
		<expr_stmt><expr><call><name>PG_CATCH</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name><name>dmstate</name><operator>-&gt;</operator><name>result</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name><name>dmstate</name><operator>-&gt;</operator><name>result</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><call><name>PG_RE_THROW</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>
		<expr_stmt><expr><call><name>PG_END_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Get the updated/deleted tuple. */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>dmstate</name><operator>-&gt;</operator><name>rel</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>resultSlot</name> <operator>=</operator> <name>slot</name></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>resultSlot</name> <operator>=</operator> <call><name>apply_returning_filter</name><argument_list>(<argument><expr><name>dmstate</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>, <argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></else></if_stmt>
	<expr_stmt><expr><name><name>dmstate</name><operator>-&gt;</operator><name>next_tuple</name></name><operator>++</operator></expr>;</expr_stmt>

	<comment type="block">/* Make slot available for evaluation of the local query RETURNING list. */</comment>
	<expr_stmt><expr><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_projectReturning</name><operator>-&gt;</operator><name>pi_exprContext</name><operator>-&gt;</operator><name>ecxt_scantuple</name></name> <operator>=</operator>
		<name>resultSlot</name></expr>;</expr_stmt>

	<return>return <expr><name>slot</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Initialize a filter to extract an updated/deleted tuple from a scan tuple.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>init_returning_filter</name><parameter_list>(<parameter><decl><type><name>PgFdwDirectModifyState</name> <modifier>*</modifier></type><name>dmstate</name></decl></parameter>,
					  <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>fdw_scan_tlist</name></decl></parameter>,
					  <parameter><decl><type><name>Index</name></type> <name>rtindex</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TupleDesc</name></type>	<name>resultTupType</name> <init>= <expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name><name>dmstate</name><operator>-&gt;</operator><name>resultRel</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Calculate the mapping between the fdw_scan_tlist's entries and the
	 * result tuple's attributes.
	 *
	 * The "map" is an array of indexes of the result tuple's attributes in
	 * fdw_scan_tlist, i.e., one entry for every attribute of the result
	 * tuple.  We store zero for any attributes that don't have the
	 * corresponding entries in that list, marking that a NULL is needed in
	 * the result tuple.
	 *
	 * Also get the indexes of the entries for ctid and oid if any.
	 */</comment>
	<expr_stmt><expr><name><name>dmstate</name><operator>-&gt;</operator><name>attnoMap</name></name> <operator>=</operator> <operator>(</operator><name>AttrNumber</name> <operator>*</operator><operator>)</operator>
		<call><name>palloc0</name><argument_list>(<argument><expr><name><name>resultTupType</name><operator>-&gt;</operator><name>natts</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>AttrNumber</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>dmstate</name><operator>-&gt;</operator><name>ctidAttno</name></name> <operator>=</operator> <name><name>dmstate</name><operator>-&gt;</operator><name>oidAttno</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<expr_stmt><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>dmstate</name><operator>-&gt;</operator><name>hasSystemCols</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>fdw_scan_tlist</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>tle</name> <init>= <expr><operator>(</operator><name>TargetEntry</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Var</name>		   <modifier>*</modifier></type><name>var</name> <init>= <expr><operator>(</operator><name>Var</name> <operator>*</operator><operator>)</operator> <name><name>tle</name><operator>-&gt;</operator><name>expr</name></name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>IsA</name><argument_list>(<argument><expr><name>var</name></expr></argument>, <argument><expr><name>Var</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * If the Var is a column of the target relation to be retrieved from
		 * the foreign server, get the index of the entry.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>var</name><operator>-&gt;</operator><name>varno</name></name> <operator>==</operator> <name>rtindex</name> <operator>&amp;&amp;</operator>
			<call><name>list_member_int</name><argument_list>(<argument><expr><name><name>dmstate</name><operator>-&gt;</operator><name>retrieved_attrs</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>int</name></type>			<name>attrno</name> <init>= <expr><name><name>var</name><operator>-&gt;</operator><name>varattno</name></name></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name>attrno</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/*
				 * We don't retrieve system columns other than ctid and oid.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><name>attrno</name> <operator>==</operator> <name>SelfItemPointerAttributeNumber</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name><name>dmstate</name><operator>-&gt;</operator><name>ctidAttno</name></name> <operator>=</operator> <name>i</name></expr>;</expr_stmt></block_content></block></if>
				<if type="elseif">else if <condition>(<expr><name>attrno</name> <operator>==</operator> <name>ObjectIdAttributeNumber</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name><name>dmstate</name><operator>-&gt;</operator><name>oidAttno</name></name> <operator>=</operator> <name>i</name></expr>;</expr_stmt></block_content></block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
				<expr_stmt><expr><name><name>dmstate</name><operator>-&gt;</operator><name>hasSystemCols</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<comment type="block">/*
				 * We don't retrieve whole-row references to the target
				 * relation either.
				 */</comment>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>attrno</name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><name><name>dmstate</name><operator>-&gt;</operator><name>attnoMap</name><index>[<expr><name>attrno</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block>
</block_content>}</block></function>

<comment type="block">/*
 * Extract and return an updated/deleted tuple from a scan tuple.
 */</comment>
<function><type><specifier>static</specifier> <name>TupleTableSlot</name> <modifier>*</modifier></type>
<name>apply_returning_filter</name><parameter_list>(<parameter><decl><type><name>PgFdwDirectModifyState</name> <modifier>*</modifier></type><name>dmstate</name></decl></parameter>,
					   <parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl></parameter>,
					   <parameter><decl><type><name>EState</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TupleDesc</name></type>	<name>resultTupType</name> <init>= <expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name><name>dmstate</name><operator>-&gt;</operator><name>resultRel</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>resultSlot</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name>	   <modifier>*</modifier></type><name>values</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name>	   <modifier>*</modifier></type><name>isnull</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name>	   <modifier>*</modifier></type><name>old_values</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name>	   <modifier>*</modifier></type><name>old_isnull</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Use the trigger tuple slot as a place to store the result tuple.
	 */</comment>
	<expr_stmt><expr><name>resultSlot</name> <operator>=</operator> <name><name>estate</name><operator>-&gt;</operator><name>es_trig_tuple_slot</name></name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>resultSlot</name><operator>-&gt;</operator><name>tts_tupleDescriptor</name></name> <operator>!=</operator> <name>resultTupType</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ExecSetSlotDescriptor</name><argument_list>(<argument><expr><name>resultSlot</name></expr></argument>, <argument><expr><name>resultTupType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Extract all the values of the scan tuple.
	 */</comment>
	<expr_stmt><expr><call><name>slot_getallattrs</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>old_values</name> <operator>=</operator> <name><name>slot</name><operator>-&gt;</operator><name>tts_values</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>old_isnull</name> <operator>=</operator> <name><name>slot</name><operator>-&gt;</operator><name>tts_isnull</name></name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Prepare to build the result tuple.
	 */</comment>
	<expr_stmt><expr><call><name>ExecClearTuple</name><argument_list>(<argument><expr><name>resultSlot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>values</name> <operator>=</operator> <name><name>resultSlot</name><operator>-&gt;</operator><name>tts_values</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>isnull</name> <operator>=</operator> <name><name>resultSlot</name><operator>-&gt;</operator><name>tts_isnull</name></name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Transpose data into proper fields of the result tuple.
	 */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>resultTupType</name><operator>-&gt;</operator><name>natts</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>j</name> <init>= <expr><name><name>dmstate</name><operator>-&gt;</operator><name>attnoMap</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>j</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>values</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>Datum</name><operator>)</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>isnull</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><name><name>values</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>old_values</name><index>[<expr><name>j</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>isnull</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>old_isnull</name><index>[<expr><name>j</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></for>

	<comment type="block">/*
	 * Build the virtual tuple.
	 */</comment>
	<expr_stmt><expr><call><name>ExecStoreVirtualTuple</name><argument_list>(<argument><expr><name>resultSlot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If we have any system columns to return, install them.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>dmstate</name><operator>-&gt;</operator><name>hasSystemCols</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>resultTup</name> <init>= <expr><call><name>ExecMaterializeSlot</name><argument_list>(<argument><expr><name>resultSlot</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/* ctid */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>dmstate</name><operator>-&gt;</operator><name>ctidAttno</name></name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>ItemPointer</name></type> <name>ctid</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><name>ctid</name> <operator>=</operator> <operator>(</operator><name>ItemPointer</name><operator>)</operator> <call><name>DatumGetPointer</name><argument_list>(<argument><expr><name><name>old_values</name><index>[<expr><name><name>dmstate</name><operator>-&gt;</operator><name>ctidAttno</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>resultTup</name><operator>-&gt;</operator><name>t_self</name></name> <operator>=</operator> <operator>*</operator><name>ctid</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* oid */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>dmstate</name><operator>-&gt;</operator><name>oidAttno</name></name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Oid</name></type>			<name>oid</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><name>oid</name> <operator>=</operator> <call><name>DatumGetObjectId</name><argument_list>(<argument><expr><name><name>old_values</name><index>[<expr><name><name>dmstate</name><operator>-&gt;</operator><name>oidAttno</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>HeapTupleSetOid</name><argument_list>(<argument><expr><name>resultTup</name></expr></argument>, <argument><expr><name>oid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * And remaining columns
		 *
		 * Note: since we currently don't allow the target relation to appear
		 * on the nullable side of an outer join, any system columns wouldn't
		 * go to NULL.
		 *
		 * Note: no need to care about tableoid here because it will be
		 * initialized in ExecProcessReturning().
		 */</comment>
		<expr_stmt><expr><call><name>HeapTupleHeaderSetXmin</name><argument_list>(<argument><expr><name><name>resultTup</name><operator>-&gt;</operator><name>t_data</name></name></expr></argument>, <argument><expr><name>InvalidTransactionId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>HeapTupleHeaderSetXmax</name><argument_list>(<argument><expr><name><name>resultTup</name><operator>-&gt;</operator><name>t_data</name></name></expr></argument>, <argument><expr><name>InvalidTransactionId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>HeapTupleHeaderSetCmin</name><argument_list>(<argument><expr><name><name>resultTup</name><operator>-&gt;</operator><name>t_data</name></name></expr></argument>, <argument><expr><name>InvalidTransactionId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * And return the result tuple.
	 */</comment>
	<return>return <expr><name>resultSlot</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Prepare for processing of parameters used in remote query.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>prepare_query_params</name><parameter_list>(<parameter><decl><type><name>PlanState</name> <modifier>*</modifier></type><name>node</name></decl></parameter>,
					 <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>fdw_exprs</name></decl></parameter>,
					 <parameter><decl><type><name>int</name></type> <name>numParams</name></decl></parameter>,
					 <parameter><decl><type><name>FmgrInfo</name> <modifier>*</modifier><modifier>*</modifier></type><name>param_flinfo</name></decl></parameter>,
					 <parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>param_exprs</name></decl></parameter>,
					 <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier><modifier>*</modifier></type><name>param_values</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>numParams</name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Prepare for output conversion of parameters used in remote query. */</comment>
	<expr_stmt><expr><operator>*</operator><name>param_flinfo</name> <operator>=</operator> <operator>(</operator><name>FmgrInfo</name> <operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>FmgrInfo</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>numParams</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>fdw_exprs</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>param_expr</name> <init>= <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>typefnoid</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>isvarlena</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>getTypeOutputInfo</name><argument_list>(<argument><expr><call><name>exprType</name><argument_list>(<argument><expr><name>param_expr</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>typefnoid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isvarlena</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>fmgr_info</name><argument_list>(<argument><expr><name>typefnoid</name></expr></argument>, <argument><expr><operator>&amp;</operator><operator>(</operator><operator>*</operator><name>param_flinfo</name><operator>)</operator><index>[<expr><name>i</name></expr>]</index></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block>

	<comment type="block">/*
	 * Prepare remote-parameter expressions for evaluation.  (Note: in
	 * practice, we expect that all these expressions will be just Params, so
	 * we could possibly do something more efficient than using the full
	 * expression-eval machinery for this.  But probably there would be little
	 * benefit, and it'd require postgres_fdw to know more than is desirable
	 * about Param evaluation.)
	 */</comment>
	<expr_stmt><expr><operator>*</operator><name>param_exprs</name> <operator>=</operator> <call><name>ExecInitExprList</name><argument_list>(<argument><expr><name>fdw_exprs</name></expr></argument>, <argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Allocate buffer for text form of query parameters. */</comment>
	<expr_stmt><expr><operator>*</operator><name>param_values</name> <operator>=</operator> <operator>(</operator><specifier>const</specifier> <name>char</name> <operator>*</operator><operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><name>numParams</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>char</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Construct array of query parameter values in text format.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>process_query_params</name><parameter_list>(<parameter><decl><type><name>ExprContext</name> <modifier>*</modifier></type><name>econtext</name></decl></parameter>,
					 <parameter><decl><type><name>FmgrInfo</name> <modifier>*</modifier></type><name>param_flinfo</name></decl></parameter>,
					 <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>param_exprs</name></decl></parameter>,
					 <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>param_values</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>nestlevel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>nestlevel</name> <operator>=</operator> <call><name>set_transmission_modes</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>param_exprs</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ExprState</name>  <modifier>*</modifier></type><name>expr_state</name> <init>= <expr><operator>(</operator><name>ExprState</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Datum</name></type>		<name>expr_value</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>isNull</name></decl>;</decl_stmt>

		<comment type="block">/* Evaluate the parameter expression */</comment>
		<expr_stmt><expr><name>expr_value</name> <operator>=</operator> <call><name>ExecEvalExpr</name><argument_list>(<argument><expr><name>expr_state</name></expr></argument>, <argument><expr><name>econtext</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isNull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Get string representation of each parameter value by invoking
		 * type-specific output function, unless the value is null.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>isNull</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>param_values</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>param_values</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>OutputFunctionCall</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>param_flinfo</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>expr_value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block>

	<expr_stmt><expr><call><name>reset_transmission_modes</name><argument_list>(<argument><expr><name>nestlevel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * postgresAnalyzeForeignTable
 *		Test whether analyzing this foreign table is supported
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>postgresAnalyzeForeignTable</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>relation</name></decl></parameter>,
							<parameter><decl><type><name>AcquireSampleRowsFunc</name> <modifier>*</modifier></type><name>func</name></decl></parameter>,
							<parameter><decl><type><name>BlockNumber</name> <modifier>*</modifier></type><name>totalpages</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ForeignTable</name> <modifier>*</modifier></type><name>table</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>UserMapping</name> <modifier>*</modifier></type><name>user</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PGconn</name>	   <modifier>*</modifier></type><name>conn</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>StringInfoData</name></type> <name>sql</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier><specifier>volatile</specifier></type> <name>res</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* Return the row-analysis function pointer */</comment>
	<expr_stmt><expr><operator>*</operator><name>func</name> <operator>=</operator> <name>postgresAcquireSampleRowsFunc</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Now we have to get the number of pages.  It's annoying that the ANALYZE
	 * API requires us to return that now, because it forces some duplication
	 * of effort between this routine and postgresAcquireSampleRowsFunc.  But
	 * it's probably not worth redefining that API at this point.
	 */</comment>

	<comment type="block">/*
	 * Get the connection to use.  We do the remote access as the table's
	 * owner, even if the ANALYZE was started by some other user.
	 */</comment>
	<expr_stmt><expr><name>table</name> <operator>=</operator> <call><name>GetForeignTable</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>user</name> <operator>=</operator> <call><name>GetUserMapping</name><argument_list>(<argument><expr><name><name>relation</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relowner</name></name></expr></argument>, <argument><expr><name><name>table</name><operator>-&gt;</operator><name>serverid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>conn</name> <operator>=</operator> <call><name>GetConnection</name><argument_list>(<argument><expr><name>user</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Construct command to get page count for relation.
	 */</comment>
	<expr_stmt><expr><call><name>initStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>deparseAnalyzeSizeSql</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sql</name></expr></argument>, <argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* In what follows, do not risk leaking any PGresults. */</comment>
	<expr_stmt><expr><call><name>PG_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<block>{<block_content>
		<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>pgfdw_exec_query</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name><name>sql</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>PQresultStatus</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>PGRES_TUPLES_OK</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>pgfdw_report_error</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><name>res</name></expr></argument>, <argument><expr><name>conn</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name><name>sql</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>PQntuples</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">1</literal> <operator>||</operator> <call><name>PQnfields</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unexpected result from deparseAnalyzeSizeSql query"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><operator>*</operator><name>totalpages</name> <operator>=</operator> <call><name>strtoul</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">10</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>res</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	</block_content>}</block>
	<expr_stmt><expr><call><name>PG_CATCH</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>res</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>PG_RE_THROW</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
	<expr_stmt><expr><call><name>PG_END_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ReleaseConnection</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Acquire a random sample of rows from foreign table managed by postgres_fdw.
 *
 * We fetch the whole table from the remote side and pick out some sample rows.
 *
 * Selected rows are returned in the caller-allocated array rows[],
 * which must have at least targrows entries.
 * The actual number of rows selected is returned as the function result.
 * We also count the total number of rows in the table and return it into
 * *totalrows.  Note that *totaldeadrows is always set to 0.
 *
 * Note that the returned list of rows is not always in order by physical
 * position in the table.  Therefore, correlation estimates derived later
 * may be meaningless, but it's OK because we don't use the estimates
 * currently (the planner only pays attention to correlation for indexscans).
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>postgresAcquireSampleRowsFunc</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>relation</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>elevel</name></decl></parameter>,
							  <parameter><decl><type><name>HeapTuple</name> <modifier>*</modifier></type><name>rows</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>targrows</name></decl></parameter>,
							  <parameter><decl><type><name>double</name> <modifier>*</modifier></type><name>totalrows</name></decl></parameter>,
							  <parameter><decl><type><name>double</name> <modifier>*</modifier></type><name>totaldeadrows</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PgFdwAnalyzeState</name></type> <name>astate</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ForeignTable</name> <modifier>*</modifier></type><name>table</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ForeignServer</name> <modifier>*</modifier></type><name>server</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>UserMapping</name> <modifier>*</modifier></type><name>user</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PGconn</name>	   <modifier>*</modifier></type><name>conn</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>cursor_number</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>StringInfoData</name></type> <name>sql</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier><specifier>volatile</specifier></type> <name>res</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* Initialize workspace state */</comment>
	<expr_stmt><expr><name><name>astate</name><operator>.</operator><name>rel</name></name> <operator>=</operator> <name>relation</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>astate</name><operator>.</operator><name>attinmeta</name></name> <operator>=</operator> <call><name>TupleDescGetAttInMetadata</name><argument_list>(<argument><expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>astate</name><operator>.</operator><name>rows</name></name> <operator>=</operator> <name>rows</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>astate</name><operator>.</operator><name>targrows</name></name> <operator>=</operator> <name>targrows</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>astate</name><operator>.</operator><name>numrows</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>astate</name><operator>.</operator><name>samplerows</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>astate</name><operator>.</operator><name>rowstoskip</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>		<comment type="block">/* -1 means not set yet */</comment>
	<expr_stmt><expr><call><name>reservoir_init_selection_state</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>astate</name><operator>.</operator><name>rstate</name></name></expr></argument>, <argument><expr><name>targrows</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Remember ANALYZE context, and create a per-tuple temp context */</comment>
	<expr_stmt><expr><name><name>astate</name><operator>.</operator><name>anl_cxt</name></name> <operator>=</operator> <name>CurrentMemoryContext</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>astate</name><operator>.</operator><name>temp_cxt</name></name> <operator>=</operator> <call><name>AllocSetContextCreate</name><argument_list>(<argument><expr><name>CurrentMemoryContext</name></expr></argument>,
											<argument><expr><literal type="string">"postgres_fdw temporary data"</literal></expr></argument>,
											<argument><expr><name>ALLOCSET_SMALL_SIZES</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Get the connection to use.  We do the remote access as the table's
	 * owner, even if the ANALYZE was started by some other user.
	 */</comment>
	<expr_stmt><expr><name>table</name> <operator>=</operator> <call><name>GetForeignTable</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>server</name> <operator>=</operator> <call><name>GetForeignServer</name><argument_list>(<argument><expr><name><name>table</name><operator>-&gt;</operator><name>serverid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>user</name> <operator>=</operator> <call><name>GetUserMapping</name><argument_list>(<argument><expr><name><name>relation</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relowner</name></name></expr></argument>, <argument><expr><name><name>table</name><operator>-&gt;</operator><name>serverid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>conn</name> <operator>=</operator> <call><name>GetConnection</name><argument_list>(<argument><expr><name>user</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Construct cursor that retrieves whole rows from remote.
	 */</comment>
	<expr_stmt><expr><name>cursor_number</name> <operator>=</operator> <call><name>GetCursorNumber</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>initStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sql</name></expr></argument>, <argument><expr><literal type="string">"DECLARE c%u CURSOR FOR "</literal></expr></argument>, <argument><expr><name>cursor_number</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>deparseAnalyzeSql</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sql</name></expr></argument>, <argument><expr><name>relation</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>astate</name><operator>.</operator><name>retrieved_attrs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* In what follows, do not risk leaking any PGresults. */</comment>
	<expr_stmt><expr><call><name>PG_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<block>{<block_content>
		<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>pgfdw_exec_query</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name><name>sql</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>PQresultStatus</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>PGRES_COMMAND_OK</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>pgfdw_report_error</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><name>res</name></expr></argument>, <argument><expr><name>conn</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name><name>sql</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>res</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

		<comment type="block">/* Retrieve and process rows a batch at a time. */</comment>
		<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>char</name></type>		<name><name>fetch_sql</name><index>[<expr><literal type="number">64</literal></expr>]</index></name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int</name></type>			<name>fetch_size</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int</name></type>			<name>numrows</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

			<comment type="block">/* Allow users to cancel long query */</comment>
			<expr_stmt><expr><call><name>CHECK_FOR_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * XXX possible future improvement: if rowstoskip is large, we
			 * could issue a MOVE rather than physically fetching the rows,
			 * then just adjust rowstoskip and samplerows appropriately.
			 */</comment>

			<comment type="block">/* The fetch size is arbitrary, but shouldn't be enormous. */</comment>
			<expr_stmt><expr><name>fetch_size</name> <operator>=</operator> <literal type="number">100</literal></expr>;</expr_stmt>
			<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>server-&gt;options</argument>)</argument_list></macro>
			<block>{<block_content>
				<decl_stmt><decl><type><name>DefElem</name>    <modifier>*</modifier></type><name>def</name> <init>= <expr><operator>(</operator><name>DefElem</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>def</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>, <argument><expr><literal type="string">"fetch_size"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name>fetch_size</name> <operator>=</operator> <call><name>strtol</name><argument_list>(<argument><expr><call><name>defGetString</name><argument_list>(<argument><expr><name>def</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">10</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<break>break;</break>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block>
			<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>table-&gt;options</argument>)</argument_list></macro>
			<block>{<block_content>
				<decl_stmt><decl><type><name>DefElem</name>    <modifier>*</modifier></type><name>def</name> <init>= <expr><operator>(</operator><name>DefElem</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>def</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>, <argument><expr><literal type="string">"fetch_size"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name>fetch_size</name> <operator>=</operator> <call><name>strtol</name><argument_list>(<argument><expr><call><name>defGetString</name><argument_list>(<argument><expr><name>def</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">10</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<break>break;</break>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block>

			<comment type="block">/* Fetch some rows */</comment>
			<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>fetch_sql</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>fetch_sql</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"FETCH %d FROM c%u"</literal></expr></argument>,
					 <argument><expr><name>fetch_size</name></expr></argument>, <argument><expr><name>cursor_number</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>pgfdw_exec_query</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>fetch_sql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* On error, report the original query, not the FETCH. */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>PQresultStatus</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>PGRES_TUPLES_OK</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>pgfdw_report_error</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><name>res</name></expr></argument>, <argument><expr><name>conn</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name><name>sql</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<comment type="block">/* Process whatever we got. */</comment>
			<expr_stmt><expr><name>numrows</name> <operator>=</operator> <call><name>PQntuples</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>numrows</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>analyze_row_processor</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>astate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>

			<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>res</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

			<comment type="block">/* Must be EOF if we didn't get all the rows requested. */</comment>
			<if_stmt><if>if <condition>(<expr><name>numrows</name> <operator>&lt;</operator> <name>fetch_size</name></expr>)</condition><block type="pseudo"><block_content>
				<break>break;</break></block_content></block></if></if_stmt>
		</block_content>}</block></for>

		<comment type="block">/* Close the cursor, just to be tidy. */</comment>
		<expr_stmt><expr><call><name>close_cursor</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>cursor_number</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
	<expr_stmt><expr><call><name>PG_CATCH</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>res</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>PG_RE_THROW</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
	<expr_stmt><expr><call><name>PG_END_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ReleaseConnection</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* We assume that we have no dead tuple. */</comment>
	<expr_stmt><expr><operator>*</operator><name>totaldeadrows</name> <operator>=</operator> <literal type="number">0.0</literal></expr>;</expr_stmt>

	<comment type="block">/* We've retrieved all living tuples from foreign server. */</comment>
	<expr_stmt><expr><operator>*</operator><name>totalrows</name> <operator>=</operator> <name><name>astate</name><operator>.</operator><name>samplerows</name></name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Emit some interesting relation info
	 */</comment>
	<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>elevel</name></expr></argument>,
			<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"\"%s\": table contains %.0f rows, %d rows in sample"</literal></expr></argument>,
					<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr></argument>,
					<argument><expr><name><name>astate</name><operator>.</operator><name>samplerows</name></name></expr></argument>, <argument><expr><name><name>astate</name><operator>.</operator><name>numrows</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name><name>astate</name><operator>.</operator><name>numrows</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Collect sample rows from the result of query.
 *	 - Use all tuples in sample until target # of samples are collected.
 *	 - Subsequently, replace already-sampled tuples randomly.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>analyze_row_processor</name><parameter_list>(<parameter><decl><type><name>PGresult</name> <modifier>*</modifier></type><name>res</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>row</name></decl></parameter>, <parameter><decl><type><name>PgFdwAnalyzeState</name> <modifier>*</modifier></type><name>astate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>targrows</name> <init>= <expr><name><name>astate</name><operator>-&gt;</operator><name>targrows</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>pos</name></decl>;</decl_stmt>			<comment type="block">/* array index to store tuple in */</comment>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcontext</name></decl>;</decl_stmt>

	<comment type="block">/* Always increment sample row counter. */</comment>
	<expr_stmt><expr><name><name>astate</name><operator>-&gt;</operator><name>samplerows</name></name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

	<comment type="block">/*
	 * Determine the slot where this sample row should be stored.  Set pos to
	 * negative value to indicate the row should be skipped.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>astate</name><operator>-&gt;</operator><name>numrows</name></name> <operator>&lt;</operator> <name>targrows</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* First targrows rows are always included into the sample */</comment>
		<expr_stmt><expr><name>pos</name> <operator>=</operator> <name><name>astate</name><operator>-&gt;</operator><name>numrows</name></name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/*
		 * Now we start replacing tuples in the sample until we reach the end
		 * of the relation.  Same algorithm as in acquire_sample_rows in
		 * analyze.c; see Jeff Vitter's paper.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>astate</name><operator>-&gt;</operator><name>rowstoskip</name></name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>astate</name><operator>-&gt;</operator><name>rowstoskip</name></name> <operator>=</operator> <call><name>reservoir_get_next_S</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>astate</name><operator>-&gt;</operator><name>rstate</name></name></expr></argument>, <argument><expr><name><name>astate</name><operator>-&gt;</operator><name>samplerows</name></name></expr></argument>, <argument><expr><name>targrows</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>astate</name><operator>-&gt;</operator><name>rowstoskip</name></name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Choose a random reservoir element to replace. */</comment>
			<expr_stmt><expr><name>pos</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator> <operator>(</operator><name>targrows</name> <operator>*</operator> <call><name>sampler_random_fract</name><argument_list>(<argument><expr><name><name>astate</name><operator>-&gt;</operator><name>rstate</name><operator>.</operator><name>randstate</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>pos</name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>pos</name> <operator>&lt;</operator> <name>targrows</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>heap_freetuple</name><argument_list>(<argument><expr><name><name>astate</name><operator>-&gt;</operator><name>rows</name><index>[<expr><name>pos</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/* Skip this tuple. */</comment>
			<expr_stmt><expr><name>pos</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<expr_stmt><expr><name><name>astate</name><operator>-&gt;</operator><name>rowstoskip</name></name> <operator>-=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>pos</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Create sample tuple from current result row, and store it in the
		 * position determined above.  The tuple has to be created in anl_cxt.
		 */</comment>
		<expr_stmt><expr><name>oldcontext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>astate</name><operator>-&gt;</operator><name>anl_cxt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>astate</name><operator>-&gt;</operator><name>rows</name><index>[<expr><name>pos</name></expr>]</index></name> <operator>=</operator> <call><name>make_tuple_from_result_row</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>row</name></expr></argument>,
													   <argument><expr><name><name>astate</name><operator>-&gt;</operator><name>rel</name></name></expr></argument>,
													   <argument><expr><name><name>astate</name><operator>-&gt;</operator><name>attinmeta</name></name></expr></argument>,
													   <argument><expr><name><name>astate</name><operator>-&gt;</operator><name>retrieved_attrs</name></name></expr></argument>,
													   <argument><expr><name>NULL</name></expr></argument>,
													   <argument><expr><name><name>astate</name><operator>-&gt;</operator><name>temp_cxt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Import a foreign schema
 */</comment>
<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>postgresImportForeignSchema</name><parameter_list>(<parameter><decl><type><name>ImportForeignSchemaStmt</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>serverOid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>commands</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>import_collate</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>import_default</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>import_not_null</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ForeignServer</name> <modifier>*</modifier></type><name>server</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>UserMapping</name> <modifier>*</modifier></type><name>mapping</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PGconn</name>	   <modifier>*</modifier></type><name>conn</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>StringInfoData</name></type> <name>buf</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier><specifier>volatile</specifier></type> <name>res</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>numrows</name></decl>,
				<decl><type ref="prev"/><name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

	<comment type="block">/* Parse statement options */</comment>
	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>stmt-&gt;options</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>DefElem</name>    <modifier>*</modifier></type><name>def</name> <init>= <expr><operator>(</operator><name>DefElem</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>def</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>, <argument><expr><literal type="string">"import_collate"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>import_collate</name> <operator>=</operator> <call><name>defGetBoolean</name><argument_list>(<argument><expr><name>def</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>def</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>, <argument><expr><literal type="string">"import_default"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>import_default</name> <operator>=</operator> <call><name>defGetBoolean</name><argument_list>(<argument><expr><name>def</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>def</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>, <argument><expr><literal type="string">"import_not_null"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>import_not_null</name> <operator>=</operator> <call><name>defGetBoolean</name><argument_list>(<argument><expr><name>def</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FDW_INVALID_OPTION_NAME</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid option \"%s\""</literal></expr></argument>, <argument><expr><name><name>def</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block>

	<comment type="block">/*
	 * Get connection to the foreign server.  Connection manager will
	 * establish new connection if necessary.
	 */</comment>
	<expr_stmt><expr><name>server</name> <operator>=</operator> <call><name>GetForeignServer</name><argument_list>(<argument><expr><name>serverOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>mapping</name> <operator>=</operator> <call><name>GetUserMapping</name><argument_list>(<argument><expr><call><name>GetUserId</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name><name>server</name><operator>-&gt;</operator><name>serverid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>conn</name> <operator>=</operator> <call><name>GetConnection</name><argument_list>(<argument><expr><name>mapping</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Don't attempt to import collation if remote server hasn't got it */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>PQserverVersion</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">90100</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>import_collate</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Create workspace for strings */</comment>
	<expr_stmt><expr><call><name>initStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* In what follows, do not risk leaking any PGresults. */</comment>
	<expr_stmt><expr><call><name>PG_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<block>{<block_content>
		<comment type="block">/* Check that the schema really exists */</comment>
		<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"SELECT 1 FROM pg_catalog.pg_namespace WHERE nspname = "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>deparseStringLiteral</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>remote_schema</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>pgfdw_exec_query</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name><name>buf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>PQresultStatus</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>PGRES_TUPLES_OK</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>pgfdw_report_error</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><name>res</name></expr></argument>, <argument><expr><name>conn</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name><name>buf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>PQntuples</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FDW_SCHEMA_NOT_FOUND</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"schema \"%s\" is not present on foreign server \"%s\""</literal></expr></argument>,
							<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>remote_schema</name></name></expr></argument>, <argument><expr><name><name>server</name><operator>-&gt;</operator><name>servername</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>res</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>resetStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Fetch all table data from this schema, possibly restricted by
		 * EXCEPT or LIMIT TO.  (We don't actually need to pay any attention
		 * to EXCEPT/LIMIT TO here, because the core code will filter the
		 * statements we return according to those lists anyway.  But it
		 * should save a few cycles to not process excluded tables in the
		 * first place.)
		 *
		 * Ignore table data for partitions and only include the definitions
		 * of the root partitioned tables to allow access to the complete
		 * remote data set locally in the schema imported.
		 *
		 * Note: because we run the connection with search_path restricted to
		 * pg_catalog, the format_type() and pg_get_expr() outputs will always
		 * include a schema name for types/functions in other schemas, which
		 * is what we want.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>import_collate</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
								   <argument><expr><literal type="string">"SELECT relname, "</literal>
								   <literal type="string">"  attname, "</literal>
								   <literal type="string">"  format_type(atttypid, atttypmod), "</literal>
								   <literal type="string">"  attnotnull, "</literal>
								   <literal type="string">"  pg_get_expr(adbin, adrelid), "</literal>
								   <literal type="string">"  collname, "</literal>
								   <literal type="string">"  collnsp.nspname "</literal>
								   <literal type="string">"FROM pg_class c "</literal>
								   <literal type="string">"  JOIN pg_namespace n ON "</literal>
								   <literal type="string">"    relnamespace = n.oid "</literal>
								   <literal type="string">"  LEFT JOIN pg_attribute a ON "</literal>
								   <literal type="string">"    attrelid = c.oid AND attnum &gt; 0 "</literal>
								   <literal type="string">"      AND NOT attisdropped "</literal>
								   <literal type="string">"  LEFT JOIN pg_attrdef ad ON "</literal>
								   <literal type="string">"    adrelid = c.oid AND adnum = attnum "</literal>
								   <literal type="string">"  LEFT JOIN pg_collation coll ON "</literal>
								   <literal type="string">"    coll.oid = attcollation "</literal>
								   <literal type="string">"  LEFT JOIN pg_namespace collnsp ON "</literal>
								   <literal type="string">"    collnsp.oid = collnamespace "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
								   <argument><expr><literal type="string">"SELECT relname, "</literal>
								   <literal type="string">"  attname, "</literal>
								   <literal type="string">"  format_type(atttypid, atttypmod), "</literal>
								   <literal type="string">"  attnotnull, "</literal>
								   <literal type="string">"  pg_get_expr(adbin, adrelid), "</literal>
								   <literal type="string">"  NULL, NULL "</literal>
								   <literal type="string">"FROM pg_class c "</literal>
								   <literal type="string">"  JOIN pg_namespace n ON "</literal>
								   <literal type="string">"    relnamespace = n.oid "</literal>
								   <literal type="string">"  LEFT JOIN pg_attribute a ON "</literal>
								   <literal type="string">"    attrelid = c.oid AND attnum &gt; 0 "</literal>
								   <literal type="string">"      AND NOT attisdropped "</literal>
								   <literal type="string">"  LEFT JOIN pg_attrdef ad ON "</literal>
								   <literal type="string">"    adrelid = c.oid AND adnum = attnum "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
							   <argument><expr><literal type="string">"WHERE c.relkind IN ("</literal>
							   <call><name>CppAsString2</name><argument_list>(<argument><expr><name>RELKIND_RELATION</name></expr></argument>)</argument_list></call> <literal type="string">","</literal>
							   <call><name>CppAsString2</name><argument_list>(<argument><expr><name>RELKIND_VIEW</name></expr></argument>)</argument_list></call> <literal type="string">","</literal>
							   <call><name>CppAsString2</name><argument_list>(<argument><expr><name>RELKIND_FOREIGN_TABLE</name></expr></argument>)</argument_list></call> <literal type="string">","</literal>
							   <call><name>CppAsString2</name><argument_list>(<argument><expr><name>RELKIND_MATVIEW</name></expr></argument>)</argument_list></call> <literal type="string">","</literal>
							   <call><name>CppAsString2</name><argument_list>(<argument><expr><name>RELKIND_PARTITIONED_TABLE</name></expr></argument>)</argument_list></call> <literal type="string">") "</literal>
							   <literal type="string">"  AND n.nspname = "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>deparseStringLiteral</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>remote_schema</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Partitions are supported since Postgres 10 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>PQserverVersion</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <literal type="number">100000</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">" AND NOT c.relispartition "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/* Apply restrictions for LIMIT TO and EXCEPT */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>list_type</name></name> <operator>==</operator> <name>FDW_IMPORT_SCHEMA_LIMIT_TO</name> <operator>||</operator>
			<name><name>stmt</name><operator>-&gt;</operator><name>list_type</name></name> <operator>==</operator> <name>FDW_IMPORT_SCHEMA_EXCEPT</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>bool</name></type>		<name>first_item</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">" AND c.relname "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>list_type</name></name> <operator>==</operator> <name>FDW_IMPORT_SCHEMA_EXCEPT</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"NOT "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"IN ("</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* Append list of table names within IN clause */</comment>
			<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>stmt-&gt;table_list</argument>)</argument_list></macro>
			<block>{<block_content>
				<decl_stmt><decl><type><name>RangeVar</name>   <modifier>*</modifier></type><name>rv</name> <init>= <expr><operator>(</operator><name>RangeVar</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><name>first_item</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>first_item</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">", "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
				<expr_stmt><expr><call><name>deparseStringLiteral</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name><name>rv</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block>
			<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="char">')'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* Append ORDER BY at the end of query to ensure output ordering */</comment>
		<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">" ORDER BY c.relname, a.attnum"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Fetch the data */</comment>
		<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>pgfdw_exec_query</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name><name>buf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>PQresultStatus</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>PGRES_TUPLES_OK</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>pgfdw_report_error</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><name>res</name></expr></argument>, <argument><expr><name>conn</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name><name>buf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/* Process results */</comment>
		<expr_stmt><expr><name>numrows</name> <operator>=</operator> <call><name>PQntuples</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* note: incrementation of i happens in inner loop's while() test */</comment>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>numrows</name></expr>;</condition><incr/>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>tablename</name> <init>= <expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>bool</name></type>		<name>first_item</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>resetStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"CREATE FOREIGN TABLE %s (\n"</literal></expr></argument>,
							 <argument><expr><call><name>quote_identifier</name><argument_list>(<argument><expr><name>tablename</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* Scan all rows for this table */</comment>
			<do>do
			<block>{<block_content>
				<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>attname</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>typename</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>attnotnull</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>attdefault</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>collname</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>collnamespace</name></decl>;</decl_stmt>

				<comment type="block">/* If table has no columns, we'll see nulls here */</comment>
				<if_stmt><if>if <condition>(<expr><call><name>PQgetisnull</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<continue>continue;</continue></block_content></block></if></if_stmt>

				<expr_stmt><expr><name>attname</name> <operator>=</operator> <call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>typename</name> <operator>=</operator> <call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>attnotnull</name> <operator>=</operator> <call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>attdefault</name> <operator>=</operator> <ternary><condition><expr><call><name>PQgetisnull</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>NULL</name></expr> </then><else>:
					<expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr></else></ternary></expr>;</expr_stmt>
				<expr_stmt><expr><name>collname</name> <operator>=</operator> <ternary><condition><expr><call><name>PQgetisnull</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><literal type="number">5</literal></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>NULL</name></expr> </then><else>:
					<expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><literal type="number">5</literal></expr></argument>)</argument_list></call></expr></else></ternary></expr>;</expr_stmt>
				<expr_stmt><expr><name>collnamespace</name> <operator>=</operator> <ternary><condition><expr><call><name>PQgetisnull</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><literal type="number">6</literal></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>NULL</name></expr> </then><else>:
					<expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><literal type="number">6</literal></expr></argument>)</argument_list></call></expr></else></ternary></expr>;</expr_stmt>

				<if_stmt><if>if <condition>(<expr><name>first_item</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>first_item</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">",\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

				<comment type="block">/* Print column name and type */</comment>
				<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"  %s %s"</literal></expr></argument>,
								 <argument><expr><call><name>quote_identifier</name><argument_list>(<argument><expr><name>attname</name></expr></argument>)</argument_list></call></expr></argument>,
								 <argument><expr><name>typename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/*
				 * Add column_name option so that renaming the foreign table's
				 * column doesn't break the association to the underlying
				 * column.
				 */</comment>
				<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">" OPTIONS (column_name "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>deparseStringLiteral</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name>attname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="char">')'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/* Add COLLATE if needed */</comment>
				<if_stmt><if>if <condition>(<expr><name>import_collate</name> <operator>&amp;&amp;</operator> <name>collname</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name>collnamespace</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">" COLLATE %s.%s"</literal></expr></argument>,
									 <argument><expr><call><name>quote_identifier</name><argument_list>(<argument><expr><name>collnamespace</name></expr></argument>)</argument_list></call></expr></argument>,
									 <argument><expr><call><name>quote_identifier</name><argument_list>(<argument><expr><name>collname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

				<comment type="block">/* Add DEFAULT if needed */</comment>
				<if_stmt><if>if <condition>(<expr><name>import_default</name> <operator>&amp;&amp;</operator> <name>attdefault</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">" DEFAULT %s"</literal></expr></argument>, <argument><expr><name>attdefault</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

				<comment type="block">/* Add NOT NULL if needed */</comment>
				<if_stmt><if>if <condition>(<expr><name>import_not_null</name> <operator>&amp;&amp;</operator> <name><name>attnotnull</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'t'</literal></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">" NOT NULL"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block>
			while <condition>(<expr><operator>++</operator><name>i</name> <operator>&lt;</operator> <name>numrows</name> <operator>&amp;&amp;</operator>
				   <call><name>strcmp</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>tablename</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>;</do>

			<comment type="block">/*
			 * Add server name and table-level options.  We specify remote
			 * schema and table name as options (the latter to ensure that
			 * renaming the foreign table doesn't break the association).
			 */</comment>
			<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"\n) SERVER %s\nOPTIONS ("</literal></expr></argument>,
							 <argument><expr><call><name>quote_identifier</name><argument_list>(<argument><expr><name><name>server</name><operator>-&gt;</operator><name>servername</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"schema_name "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>deparseStringLiteral</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>remote_schema</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">", table_name "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>deparseStringLiteral</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name>tablename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">");"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name>commands</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>commands</name></expr></argument>, <argument><expr><call><name>pstrdup</name><argument_list>(<argument><expr><name><name>buf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></for>

		<comment type="block">/* Clean up */</comment>
		<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>res</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	</block_content>}</block>
	<expr_stmt><expr><call><name>PG_CATCH</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>res</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>PG_RE_THROW</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
	<expr_stmt><expr><call><name>PG_END_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ReleaseConnection</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>commands</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Assess whether the join between inner and outer relations can be pushed down
 * to the foreign server. As a side effect, save information we obtain in this
 * function to PgFdwRelationInfo passed in.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>foreign_join_ok</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>joinrel</name></decl></parameter>, <parameter><decl><type><name>JoinType</name></type> <name>jointype</name></decl></parameter>,
				<parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>outerrel</name></decl></parameter>, <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>innerrel</name></decl></parameter>,
				<parameter><decl><type><name>JoinPathExtraData</name> <modifier>*</modifier></type><name>extra</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PgFdwRelationInfo</name> <modifier>*</modifier></type><name>fpinfo</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PgFdwRelationInfo</name> <modifier>*</modifier></type><name>fpinfo_o</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PgFdwRelationInfo</name> <modifier>*</modifier></type><name>fpinfo_i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>joinclauses</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * We support pushing down INNER, LEFT, RIGHT and FULL OUTER joins.
	 * Constructing queries representing SEMI and ANTI joins is hard, hence
	 * not considered right now.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>jointype</name> <operator>!=</operator> <name>JOIN_INNER</name> <operator>&amp;&amp;</operator> <name>jointype</name> <operator>!=</operator> <name>JOIN_LEFT</name> <operator>&amp;&amp;</operator>
		<name>jointype</name> <operator>!=</operator> <name>JOIN_RIGHT</name> <operator>&amp;&amp;</operator> <name>jointype</name> <operator>!=</operator> <name>JOIN_FULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * If either of the joining relations is marked as unsafe to pushdown, the
	 * join can not be pushed down.
	 */</comment>
	<expr_stmt><expr><name>fpinfo</name> <operator>=</operator> <operator>(</operator><name>PgFdwRelationInfo</name> <operator>*</operator><operator>)</operator> <name><name>joinrel</name><operator>-&gt;</operator><name>fdw_private</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>fpinfo_o</name> <operator>=</operator> <operator>(</operator><name>PgFdwRelationInfo</name> <operator>*</operator><operator>)</operator> <name><name>outerrel</name><operator>-&gt;</operator><name>fdw_private</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>fpinfo_i</name> <operator>=</operator> <operator>(</operator><name>PgFdwRelationInfo</name> <operator>*</operator><operator>)</operator> <name><name>innerrel</name><operator>-&gt;</operator><name>fdw_private</name></name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>fpinfo_o</name> <operator>||</operator> <operator>!</operator><name><name>fpinfo_o</name><operator>-&gt;</operator><name>pushdown_safe</name></name> <operator>||</operator>
		<operator>!</operator><name>fpinfo_i</name> <operator>||</operator> <operator>!</operator><name><name>fpinfo_i</name><operator>-&gt;</operator><name>pushdown_safe</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * If joining relations have local conditions, those conditions are
	 * required to be applied before joining the relations. Hence the join can
	 * not be pushed down.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>fpinfo_o</name><operator>-&gt;</operator><name>local_conds</name></name> <operator>||</operator> <name><name>fpinfo_i</name><operator>-&gt;</operator><name>local_conds</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Merge FDW options.  We might be tempted to do this after we have deemed
	 * the foreign join to be OK.  But we must do this beforehand so that we
	 * know which quals can be evaluated on the foreign server, which might
	 * depend on shippable_extensions.
	 */</comment>
	<expr_stmt><expr><name><name>fpinfo</name><operator>-&gt;</operator><name>server</name></name> <operator>=</operator> <name><name>fpinfo_o</name><operator>-&gt;</operator><name>server</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>merge_fdw_options</name><argument_list>(<argument><expr><name>fpinfo</name></expr></argument>, <argument><expr><name>fpinfo_o</name></expr></argument>, <argument><expr><name>fpinfo_i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Separate restrict list into join quals and pushed-down (other) quals.
	 *
	 * Join quals belonging to an outer join must all be shippable, else we
	 * cannot execute the join remotely.  Add such quals to 'joinclauses'.
	 *
	 * Add other quals to fpinfo-&gt;remote_conds if they are shippable, else to
	 * fpinfo-&gt;local_conds.  In an inner join it's okay to execute conditions
	 * either locally or remotely; the same is true for pushed-down conditions
	 * at an outer join.
	 *
	 * Note we might return failure after having already scribbled on
	 * fpinfo-&gt;remote_conds and fpinfo-&gt;local_conds.  That's okay because we
	 * won't consult those lists again if we deem the join unshippable.
	 */</comment>
	<expr_stmt><expr><name>joinclauses</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>extra-&gt;restrictlist</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>RestrictInfo</name> <modifier>*</modifier></type><name>rinfo</name> <init>= <expr><call><name>lfirst_node</name><argument_list>(<argument><expr><name>RestrictInfo</name></expr></argument>, <argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>is_remote_clause</name> <init>= <expr><call><name>is_foreign_expr</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>joinrel</name></expr></argument>,
													   <argument><expr><name><name>rinfo</name><operator>-&gt;</operator><name>clause</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>IS_OUTER_JOIN</name><argument_list>(<argument><expr><name>jointype</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
			<operator>!</operator><call><name>RINFO_IS_PUSHED_DOWN</name><argument_list>(<argument><expr><name>rinfo</name></expr></argument>, <argument><expr><name><name>joinrel</name><operator>-&gt;</operator><name>relids</name></name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>is_remote_clause</name></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
			<expr_stmt><expr><name>joinclauses</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>joinclauses</name></expr></argument>, <argument><expr><name>rinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>is_remote_clause</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>fpinfo</name><operator>-&gt;</operator><name>remote_conds</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>fpinfo</name><operator>-&gt;</operator><name>remote_conds</name></name></expr></argument>, <argument><expr><name>rinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>fpinfo</name><operator>-&gt;</operator><name>local_conds</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>fpinfo</name><operator>-&gt;</operator><name>local_conds</name></name></expr></argument>, <argument><expr><name>rinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block>

	<comment type="block">/*
	 * deparseExplicitTargetList() isn't smart enough to handle anything other
	 * than a Var.  In particular, if there's some PlaceHolderVar that would
	 * need to be evaluated within this join tree (because there's an upper
	 * reference to a quantity that may go to NULL as a result of an outer
	 * join), then we can't try to push the join down because we'll fail when
	 * we get to deparseExplicitTargetList().  However, a PlaceHolderVar that
	 * needs to be evaluated *at the top* of this join tree is OK, because we
	 * can do that locally after fetching the results from the remote side.
	 */</comment>
	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>root-&gt;placeholder_list</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>PlaceHolderInfo</name> <modifier>*</modifier></type><name>phinfo</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Relids</name></type>		<name>relids</name></decl>;</decl_stmt>

		<comment type="block">/* PlaceHolderInfo refers to parent relids, not child relids. */</comment>
		<expr_stmt><expr><name>relids</name> <operator>=</operator> <ternary><condition><expr><call><name>IS_OTHER_REL</name><argument_list>(<argument><expr><name>joinrel</name></expr></argument>)</argument_list></call></expr> ?</condition><then>
			<expr><name><name>joinrel</name><operator>-&gt;</operator><name>top_parent_relids</name></name></expr> </then><else>: <expr><name><name>joinrel</name><operator>-&gt;</operator><name>relids</name></name></expr></else></ternary></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>bms_is_subset</name><argument_list>(<argument><expr><name><name>phinfo</name><operator>-&gt;</operator><name>ph_eval_at</name></name></expr></argument>, <argument><expr><name>relids</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
			<call><name>bms_nonempty_difference</name><argument_list>(<argument><expr><name>relids</name></expr></argument>, <argument><expr><name><name>phinfo</name><operator>-&gt;</operator><name>ph_eval_at</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block>

	<comment type="block">/* Save the join clauses, for later use. */</comment>
	<expr_stmt><expr><name><name>fpinfo</name><operator>-&gt;</operator><name>joinclauses</name></name> <operator>=</operator> <name>joinclauses</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>fpinfo</name><operator>-&gt;</operator><name>outerrel</name></name> <operator>=</operator> <name>outerrel</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fpinfo</name><operator>-&gt;</operator><name>innerrel</name></name> <operator>=</operator> <name>innerrel</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fpinfo</name><operator>-&gt;</operator><name>jointype</name></name> <operator>=</operator> <name>jointype</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * By default, both the input relations are not required to be deparsed as
	 * subqueries, but there might be some relations covered by the input
	 * relations that are required to be deparsed as subqueries, so save the
	 * relids of those relations for later use by the deparser.
	 */</comment>
	<expr_stmt><expr><name><name>fpinfo</name><operator>-&gt;</operator><name>make_outerrel_subquery</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fpinfo</name><operator>-&gt;</operator><name>make_innerrel_subquery</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>bms_is_subset</name><argument_list>(<argument><expr><name><name>fpinfo_o</name><operator>-&gt;</operator><name>lower_subquery_rels</name></name></expr></argument>, <argument><expr><name><name>outerrel</name><operator>-&gt;</operator><name>relids</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>bms_is_subset</name><argument_list>(<argument><expr><name><name>fpinfo_i</name><operator>-&gt;</operator><name>lower_subquery_rels</name></name></expr></argument>, <argument><expr><name><name>innerrel</name><operator>-&gt;</operator><name>relids</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fpinfo</name><operator>-&gt;</operator><name>lower_subquery_rels</name></name> <operator>=</operator> <call><name>bms_union</name><argument_list>(<argument><expr><name><name>fpinfo_o</name><operator>-&gt;</operator><name>lower_subquery_rels</name></name></expr></argument>,
											<argument><expr><name><name>fpinfo_i</name><operator>-&gt;</operator><name>lower_subquery_rels</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Pull the other remote conditions from the joining relations into join
	 * clauses or other remote clauses (remote_conds) of this relation
	 * wherever possible. This avoids building subqueries at every join step.
	 *
	 * For an inner join, clauses from both the relations are added to the
	 * other remote clauses. For LEFT and RIGHT OUTER join, the clauses from
	 * the outer side are added to remote_conds since those can be evaluated
	 * after the join is evaluated. The clauses from inner side are added to
	 * the joinclauses, since they need to be evaluated while constructing the
	 * join.
	 *
	 * For a FULL OUTER JOIN, the other clauses from either relation can not
	 * be added to the joinclauses or remote_conds, since each relation acts
	 * as an outer relation for the other.
	 *
	 * The joining sides can not have local conditions, thus no need to test
	 * shippability of the clauses being pulled up.
	 */</comment>
	<switch>switch <condition>(<expr><name>jointype</name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>JOIN_INNER</name></expr>:</case>
			<expr_stmt><expr><name><name>fpinfo</name><operator>-&gt;</operator><name>remote_conds</name></name> <operator>=</operator> <call><name>list_concat</name><argument_list>(<argument><expr><name><name>fpinfo</name><operator>-&gt;</operator><name>remote_conds</name></name></expr></argument>,
											   <argument><expr><call><name>list_copy</name><argument_list>(<argument><expr><name><name>fpinfo_i</name><operator>-&gt;</operator><name>remote_conds</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>fpinfo</name><operator>-&gt;</operator><name>remote_conds</name></name> <operator>=</operator> <call><name>list_concat</name><argument_list>(<argument><expr><name><name>fpinfo</name><operator>-&gt;</operator><name>remote_conds</name></name></expr></argument>,
											   <argument><expr><call><name>list_copy</name><argument_list>(<argument><expr><name><name>fpinfo_o</name><operator>-&gt;</operator><name>remote_conds</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>JOIN_LEFT</name></expr>:</case>
			<expr_stmt><expr><name><name>fpinfo</name><operator>-&gt;</operator><name>joinclauses</name></name> <operator>=</operator> <call><name>list_concat</name><argument_list>(<argument><expr><name><name>fpinfo</name><operator>-&gt;</operator><name>joinclauses</name></name></expr></argument>,
											  <argument><expr><call><name>list_copy</name><argument_list>(<argument><expr><name><name>fpinfo_i</name><operator>-&gt;</operator><name>remote_conds</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>fpinfo</name><operator>-&gt;</operator><name>remote_conds</name></name> <operator>=</operator> <call><name>list_concat</name><argument_list>(<argument><expr><name><name>fpinfo</name><operator>-&gt;</operator><name>remote_conds</name></name></expr></argument>,
											   <argument><expr><call><name>list_copy</name><argument_list>(<argument><expr><name><name>fpinfo_o</name><operator>-&gt;</operator><name>remote_conds</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>JOIN_RIGHT</name></expr>:</case>
			<expr_stmt><expr><name><name>fpinfo</name><operator>-&gt;</operator><name>joinclauses</name></name> <operator>=</operator> <call><name>list_concat</name><argument_list>(<argument><expr><name><name>fpinfo</name><operator>-&gt;</operator><name>joinclauses</name></name></expr></argument>,
											  <argument><expr><call><name>list_copy</name><argument_list>(<argument><expr><name><name>fpinfo_o</name><operator>-&gt;</operator><name>remote_conds</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>fpinfo</name><operator>-&gt;</operator><name>remote_conds</name></name> <operator>=</operator> <call><name>list_concat</name><argument_list>(<argument><expr><name><name>fpinfo</name><operator>-&gt;</operator><name>remote_conds</name></name></expr></argument>,
											   <argument><expr><call><name>list_copy</name><argument_list>(<argument><expr><name><name>fpinfo_i</name><operator>-&gt;</operator><name>remote_conds</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>JOIN_FULL</name></expr>:</case>

			<comment type="block">/*
			 * In this case, if any of the input relations has conditions, we
			 * need to deparse that relation as a subquery so that the
			 * conditions can be evaluated before the join.  Remember it in
			 * the fpinfo of this relation so that the deparser can take
			 * appropriate action.  Also, save the relids of base relations
			 * covered by that relation for later use by the deparser.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>fpinfo_o</name><operator>-&gt;</operator><name>remote_conds</name></name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name><name>fpinfo</name><operator>-&gt;</operator><name>make_outerrel_subquery</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>fpinfo</name><operator>-&gt;</operator><name>lower_subquery_rels</name></name> <operator>=</operator>
					<call><name>bms_add_members</name><argument_list>(<argument><expr><name><name>fpinfo</name><operator>-&gt;</operator><name>lower_subquery_rels</name></name></expr></argument>,
									<argument><expr><name><name>outerrel</name><operator>-&gt;</operator><name>relids</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>fpinfo_i</name><operator>-&gt;</operator><name>remote_conds</name></name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name><name>fpinfo</name><operator>-&gt;</operator><name>make_innerrel_subquery</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>fpinfo</name><operator>-&gt;</operator><name>lower_subquery_rels</name></name> <operator>=</operator>
					<call><name>bms_add_members</name><argument_list>(<argument><expr><name><name>fpinfo</name><operator>-&gt;</operator><name>lower_subquery_rels</name></name></expr></argument>,
									<argument><expr><name><name>innerrel</name><operator>-&gt;</operator><name>relids</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			<break>break;</break>

		<default>default:</default>
			<comment type="block">/* Should not happen, we have just checked this above */</comment>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unsupported join type %d"</literal></expr></argument>, <argument><expr><name>jointype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></switch>

	<comment type="block">/*
	 * For an inner join, all restrictions can be treated alike. Treating the
	 * pushed down conditions as join conditions allows a top level full outer
	 * join to be deparsed without requiring subqueries.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>jointype</name> <operator>==</operator> <name>JOIN_INNER</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name><name>fpinfo</name><operator>-&gt;</operator><name>joinclauses</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>fpinfo</name><operator>-&gt;</operator><name>joinclauses</name></name> <operator>=</operator> <name><name>fpinfo</name><operator>-&gt;</operator><name>remote_conds</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>fpinfo</name><operator>-&gt;</operator><name>remote_conds</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Mark that this join can be pushed down safely */</comment>
	<expr_stmt><expr><name><name>fpinfo</name><operator>-&gt;</operator><name>pushdown_safe</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

	<comment type="block">/* Get user mapping */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>fpinfo</name><operator>-&gt;</operator><name>use_remote_estimate</name></name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>fpinfo_o</name><operator>-&gt;</operator><name>use_remote_estimate</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>fpinfo</name><operator>-&gt;</operator><name>user</name></name> <operator>=</operator> <name><name>fpinfo_o</name><operator>-&gt;</operator><name>user</name></name></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>fpinfo</name><operator>-&gt;</operator><name>user</name></name> <operator>=</operator> <name><name>fpinfo_i</name><operator>-&gt;</operator><name>user</name></name></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>fpinfo</name><operator>-&gt;</operator><name>user</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/*
	 * Set cached relation costs to some negative value, so that we can detect
	 * when they are set to some sensible costs, during one (usually the
	 * first) of the calls to estimate_path_cost_size().
	 */</comment>
	<expr_stmt><expr><name><name>fpinfo</name><operator>-&gt;</operator><name>rel_startup_cost</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fpinfo</name><operator>-&gt;</operator><name>rel_total_cost</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>

	<comment type="block">/*
	 * Set the string describing this join relation to be used in EXPLAIN
	 * output of corresponding ForeignScan.
	 */</comment>
	<expr_stmt><expr><name><name>fpinfo</name><operator>-&gt;</operator><name>relation_name</name></name> <operator>=</operator> <call><name>makeStringInfo</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name><name>fpinfo</name><operator>-&gt;</operator><name>relation_name</name></name></expr></argument>, <argument><expr><literal type="string">"(%s) %s JOIN (%s)"</literal></expr></argument>,
					 <argument><expr><name><name>fpinfo_o</name><operator>-&gt;</operator><name>relation_name</name><operator>-&gt;</operator><name>data</name></name></expr></argument>,
					 <argument><expr><call><name>get_jointype_name</name><argument_list>(<argument><expr><name><name>fpinfo</name><operator>-&gt;</operator><name>jointype</name></name></expr></argument>)</argument_list></call></expr></argument>,
					 <argument><expr><name><name>fpinfo_i</name><operator>-&gt;</operator><name>relation_name</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Set the relation index.  This is defined as the position of this
	 * joinrel in the join_rel_list list plus the length of the rtable list.
	 * Note that since this joinrel is at the end of the join_rel_list list
	 * when we are called, we can get the position by list_length.
	 */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>fpinfo</name><operator>-&gt;</operator><name>relation_index</name></name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>	<comment type="block">/* shouldn't be set yet */</comment>
	<expr_stmt><expr><name><name>fpinfo</name><operator>-&gt;</operator><name>relation_index</name></name> <operator>=</operator>
		<call><name>list_length</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>parse</name><operator>-&gt;</operator><name>rtable</name></name></expr></argument>)</argument_list></call> <operator>+</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>join_rel_list</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>add_paths_with_pathkeys_for_rel</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>rel</name></decl></parameter>,
								<parameter><decl><type><name>Path</name> <modifier>*</modifier></type><name>epq_path</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>useful_pathkeys_list</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt> <comment type="block">/* List of all pathkeys */</comment>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>useful_pathkeys_list</name> <operator>=</operator> <call><name>get_useful_pathkeys_for_relation</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Create one path for each set of pathkeys we found above. */</comment>
	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>useful_pathkeys_list</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>double</name></type>		<name>rows</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>width</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Cost</name></type>		<name>startup_cost</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Cost</name></type>		<name>total_cost</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>useful_pathkeys</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Path</name>	   <modifier>*</modifier></type><name>sorted_epq_path</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>estimate_path_cost_size</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><name>NIL</name></expr></argument>, <argument><expr><name>useful_pathkeys</name></expr></argument>,
								<argument><expr><operator>&amp;</operator><name>rows</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>width</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>startup_cost</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>total_cost</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * The EPQ path must be at least as well sorted as the path itself, in
		 * case it gets used as input to a mergejoin.
		 */</comment>
		<expr_stmt><expr><name>sorted_epq_path</name> <operator>=</operator> <name>epq_path</name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>sorted_epq_path</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator>
			<operator>!</operator><call><name>pathkeys_contained_in</name><argument_list>(<argument><expr><name>useful_pathkeys</name></expr></argument>,
								   <argument><expr><name><name>sorted_epq_path</name><operator>-&gt;</operator><name>pathkeys</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>sorted_epq_path</name> <operator>=</operator> <operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator>
				<call><name>create_sort_path</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
								 <argument><expr><name>rel</name></expr></argument>,
								 <argument><expr><name>sorted_epq_path</name></expr></argument>,
								 <argument><expr><name>useful_pathkeys</name></expr></argument>,
								 <argument><expr><operator>-</operator><literal type="number">1.0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>add_path</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator>
				 <call><name>create_foreignscan_path</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>,
										 <argument><expr><name>NULL</name></expr></argument>,
										 <argument><expr><name>rows</name></expr></argument>,
										 <argument><expr><name>startup_cost</name></expr></argument>,
										 <argument><expr><name>total_cost</name></expr></argument>,
										 <argument><expr><name>useful_pathkeys</name></expr></argument>,
										 <argument><expr><name><name>rel</name><operator>-&gt;</operator><name>lateral_relids</name></name></expr></argument>,
										 <argument><expr><name>sorted_epq_path</name></expr></argument>,
										 <argument><expr><name>NIL</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
</block_content>}</block></function>

<comment type="block">/*
 * Parse options from foreign server and apply them to fpinfo.
 *
 * New options might also require tweaking merge_fdw_options().
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>apply_server_options</name><parameter_list>(<parameter><decl><type><name>PgFdwRelationInfo</name> <modifier>*</modifier></type><name>fpinfo</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>fpinfo-&gt;server-&gt;options</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>DefElem</name>    <modifier>*</modifier></type><name>def</name> <init>= <expr><operator>(</operator><name>DefElem</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>def</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>, <argument><expr><literal type="string">"use_remote_estimate"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>fpinfo</name><operator>-&gt;</operator><name>use_remote_estimate</name></name> <operator>=</operator> <call><name>defGetBoolean</name><argument_list>(<argument><expr><name>def</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>def</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>, <argument><expr><literal type="string">"fdw_startup_cost"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>fpinfo</name><operator>-&gt;</operator><name>fdw_startup_cost</name></name> <operator>=</operator> <call><name>strtod</name><argument_list>(<argument><expr><call><name>defGetString</name><argument_list>(<argument><expr><name>def</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>def</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>, <argument><expr><literal type="string">"fdw_tuple_cost"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>fpinfo</name><operator>-&gt;</operator><name>fdw_tuple_cost</name></name> <operator>=</operator> <call><name>strtod</name><argument_list>(<argument><expr><call><name>defGetString</name><argument_list>(<argument><expr><name>def</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>def</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>, <argument><expr><literal type="string">"extensions"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>fpinfo</name><operator>-&gt;</operator><name>shippable_extensions</name></name> <operator>=</operator>
				<call><name>ExtractExtensionList</name><argument_list>(<argument><expr><call><name>defGetString</name><argument_list>(<argument><expr><name>def</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>def</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>, <argument><expr><literal type="string">"fetch_size"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>fpinfo</name><operator>-&gt;</operator><name>fetch_size</name></name> <operator>=</operator> <call><name>strtol</name><argument_list>(<argument><expr><call><name>defGetString</name><argument_list>(<argument><expr><name>def</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">10</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block>
</block_content>}</block></function>

<comment type="block">/*
 * Parse options from foreign table and apply them to fpinfo.
 *
 * New options might also require tweaking merge_fdw_options().
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>apply_table_options</name><parameter_list>(<parameter><decl><type><name>PgFdwRelationInfo</name> <modifier>*</modifier></type><name>fpinfo</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>fpinfo-&gt;table-&gt;options</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>DefElem</name>    <modifier>*</modifier></type><name>def</name> <init>= <expr><operator>(</operator><name>DefElem</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>def</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>, <argument><expr><literal type="string">"use_remote_estimate"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>fpinfo</name><operator>-&gt;</operator><name>use_remote_estimate</name></name> <operator>=</operator> <call><name>defGetBoolean</name><argument_list>(<argument><expr><name>def</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>def</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>, <argument><expr><literal type="string">"fetch_size"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>fpinfo</name><operator>-&gt;</operator><name>fetch_size</name></name> <operator>=</operator> <call><name>strtol</name><argument_list>(<argument><expr><call><name>defGetString</name><argument_list>(<argument><expr><name>def</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">10</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block>
</block_content>}</block></function>

<comment type="block">/*
 * Merge FDW options from input relations into a new set of options for a join
 * or an upper rel.
 *
 * For a join relation, FDW-specific information about the inner and outer
 * relations is provided using fpinfo_i and fpinfo_o.  For an upper relation,
 * fpinfo_o provides the information for the input relation; fpinfo_i is
 * expected to NULL.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>merge_fdw_options</name><parameter_list>(<parameter><decl><type><name>PgFdwRelationInfo</name> <modifier>*</modifier></type><name>fpinfo</name></decl></parameter>,
				  <parameter><decl><type><specifier>const</specifier> <name>PgFdwRelationInfo</name> <modifier>*</modifier></type><name>fpinfo_o</name></decl></parameter>,
				  <parameter><decl><type><specifier>const</specifier> <name>PgFdwRelationInfo</name> <modifier>*</modifier></type><name>fpinfo_i</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* We must always have fpinfo_o. */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>fpinfo_o</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* fpinfo_i may be NULL, but if present the servers must both match. */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>fpinfo_i</name> <operator>||</operator>
		   <name><name>fpinfo_i</name><operator>-&gt;</operator><name>server</name><operator>-&gt;</operator><name>serverid</name></name> <operator>==</operator> <name><name>fpinfo_o</name><operator>-&gt;</operator><name>server</name><operator>-&gt;</operator><name>serverid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Copy the server specific FDW options.  (For a join, both relations come
	 * from the same server, so the server options should have the same value
	 * for both relations.)
	 */</comment>
	<expr_stmt><expr><name><name>fpinfo</name><operator>-&gt;</operator><name>fdw_startup_cost</name></name> <operator>=</operator> <name><name>fpinfo_o</name><operator>-&gt;</operator><name>fdw_startup_cost</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fpinfo</name><operator>-&gt;</operator><name>fdw_tuple_cost</name></name> <operator>=</operator> <name><name>fpinfo_o</name><operator>-&gt;</operator><name>fdw_tuple_cost</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fpinfo</name><operator>-&gt;</operator><name>shippable_extensions</name></name> <operator>=</operator> <name><name>fpinfo_o</name><operator>-&gt;</operator><name>shippable_extensions</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fpinfo</name><operator>-&gt;</operator><name>use_remote_estimate</name></name> <operator>=</operator> <name><name>fpinfo_o</name><operator>-&gt;</operator><name>use_remote_estimate</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fpinfo</name><operator>-&gt;</operator><name>fetch_size</name></name> <operator>=</operator> <name><name>fpinfo_o</name><operator>-&gt;</operator><name>fetch_size</name></name></expr>;</expr_stmt>

	<comment type="block">/* Merge the table level options from either side of the join. */</comment>
	<if_stmt><if>if <condition>(<expr><name>fpinfo_i</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * We'll prefer to use remote estimates for this join if any table
		 * from either side of the join is using remote estimates.  This is
		 * most likely going to be preferred since they're already willing to
		 * pay the price of a round trip to get the remote EXPLAIN.  In any
		 * case it's not entirely clear how we might otherwise handle this
		 * best.
		 */</comment>
		<expr_stmt><expr><name><name>fpinfo</name><operator>-&gt;</operator><name>use_remote_estimate</name></name> <operator>=</operator> <name><name>fpinfo_o</name><operator>-&gt;</operator><name>use_remote_estimate</name></name> <operator>||</operator>
			<name><name>fpinfo_i</name><operator>-&gt;</operator><name>use_remote_estimate</name></name></expr>;</expr_stmt>

		<comment type="block">/*
		 * Set fetch size to maximum of the joining sides, since we are
		 * expecting the rows returned by the join to be proportional to the
		 * relation sizes.
		 */</comment>
		<expr_stmt><expr><name><name>fpinfo</name><operator>-&gt;</operator><name>fetch_size</name></name> <operator>=</operator> <call><name>Max</name><argument_list>(<argument><expr><name><name>fpinfo_o</name><operator>-&gt;</operator><name>fetch_size</name></name></expr></argument>, <argument><expr><name><name>fpinfo_i</name><operator>-&gt;</operator><name>fetch_size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * postgresGetForeignJoinPaths
 *		Add possible ForeignPath to joinrel, if join is safe to push down.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>postgresGetForeignJoinPaths</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
							<parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>joinrel</name></decl></parameter>,
							<parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>outerrel</name></decl></parameter>,
							<parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>innerrel</name></decl></parameter>,
							<parameter><decl><type><name>JoinType</name></type> <name>jointype</name></decl></parameter>,
							<parameter><decl><type><name>JoinPathExtraData</name> <modifier>*</modifier></type><name>extra</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PgFdwRelationInfo</name> <modifier>*</modifier></type><name>fpinfo</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ForeignPath</name> <modifier>*</modifier></type><name>joinpath</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type>		<name>rows</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>width</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Cost</name></type>		<name>startup_cost</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Cost</name></type>		<name>total_cost</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Path</name>	   <modifier>*</modifier></type><name>epq_path</name></decl>;</decl_stmt>		<comment type="block">/* Path to create plan to be executed when
								 * EvalPlanQual gets triggered. */</comment>

	<comment type="block">/*
	 * Skip if this join combination has been considered already.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>joinrel</name><operator>-&gt;</operator><name>fdw_private</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * This code does not work for joins with lateral references, since those
	 * must have parameterized paths, which we don't generate yet.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>bms_is_empty</name><argument_list>(<argument><expr><name><name>joinrel</name><operator>-&gt;</operator><name>lateral_relids</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Create unfinished PgFdwRelationInfo entry which is used to indicate
	 * that the join relation is already considered, so that we won't waste
	 * time in judging safety of join pushdown and adding the same paths again
	 * if found safe. Once we know that this join can be pushed down, we fill
	 * the entry.
	 */</comment>
	<expr_stmt><expr><name>fpinfo</name> <operator>=</operator> <operator>(</operator><name>PgFdwRelationInfo</name> <operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>PgFdwRelationInfo</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fpinfo</name><operator>-&gt;</operator><name>pushdown_safe</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>joinrel</name><operator>-&gt;</operator><name>fdw_private</name></name> <operator>=</operator> <name>fpinfo</name></expr>;</expr_stmt>
	<comment type="block">/* attrs_used is only for base relations. */</comment>
	<expr_stmt><expr><name><name>fpinfo</name><operator>-&gt;</operator><name>attrs_used</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * If there is a possibility that EvalPlanQual will be executed, we need
	 * to be able to reconstruct the row using scans of the base relations.
	 * GetExistingLocalJoinPath will find a suitable path for this purpose in
	 * the path list of the joinrel, if one exists.  We must be careful to
	 * call it before adding any ForeignPath, since the ForeignPath might
	 * dominate the only suitable local path available.  We also do it before
	 * calling foreign_join_ok(), since that function updates fpinfo and marks
	 * it as pushable if the join is found to be pushable.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>root</name><operator>-&gt;</operator><name>parse</name><operator>-&gt;</operator><name>commandType</name></name> <operator>==</operator> <name>CMD_DELETE</name> <operator>||</operator>
		<name><name>root</name><operator>-&gt;</operator><name>parse</name><operator>-&gt;</operator><name>commandType</name></name> <operator>==</operator> <name>CMD_UPDATE</name> <operator>||</operator>
		<name><name>root</name><operator>-&gt;</operator><name>rowMarks</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>epq_path</name> <operator>=</operator> <call><name>GetExistingLocalJoinPath</name><argument_list>(<argument><expr><name>joinrel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>epq_path</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG3</name></expr></argument>, <argument><expr><literal type="string">"could not push down foreign join because a local path suitable for EPQ checks was not found"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>epq_path</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>foreign_join_ok</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>joinrel</name></expr></argument>, <argument><expr><name>jointype</name></expr></argument>, <argument><expr><name>outerrel</name></expr></argument>, <argument><expr><name>innerrel</name></expr></argument>, <argument><expr><name>extra</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Free path required for EPQ if we copied one; we don't need it now */</comment>
		<if_stmt><if>if <condition>(<expr><name>epq_path</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>epq_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Compute the selectivity and cost of the local_conds, so we don't have
	 * to do it over again for each path. The best we can do for these
	 * conditions is to estimate selectivity on the basis of local statistics.
	 * The local conditions are applied after the join has been computed on
	 * the remote side like quals in WHERE clause, so pass jointype as
	 * JOIN_INNER.
	 */</comment>
	<expr_stmt><expr><name><name>fpinfo</name><operator>-&gt;</operator><name>local_conds_sel</name></name> <operator>=</operator> <call><name>clauselist_selectivity</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
													 <argument><expr><name><name>fpinfo</name><operator>-&gt;</operator><name>local_conds</name></name></expr></argument>,
													 <argument><expr><literal type="number">0</literal></expr></argument>,
													 <argument><expr><name>JOIN_INNER</name></expr></argument>,
													 <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>cost_qual_eval</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>fpinfo</name><operator>-&gt;</operator><name>local_conds_cost</name></name></expr></argument>, <argument><expr><name><name>fpinfo</name><operator>-&gt;</operator><name>local_conds</name></name></expr></argument>, <argument><expr><name>root</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If we are going to estimate costs locally, estimate the join clause
	 * selectivity here while we have special join info.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>fpinfo</name><operator>-&gt;</operator><name>use_remote_estimate</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>fpinfo</name><operator>-&gt;</operator><name>joinclause_sel</name></name> <operator>=</operator> <call><name>clauselist_selectivity</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name><name>fpinfo</name><operator>-&gt;</operator><name>joinclauses</name></name></expr></argument>,
														<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>fpinfo</name><operator>-&gt;</operator><name>jointype</name></name></expr></argument>,
														<argument><expr><name><name>extra</name><operator>-&gt;</operator><name>sjinfo</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Estimate costs for bare join relation */</comment>
	<expr_stmt><expr><call><name>estimate_path_cost_size</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>joinrel</name></expr></argument>, <argument><expr><name>NIL</name></expr></argument>, <argument><expr><name>NIL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rows</name></expr></argument>,
							<argument><expr><operator>&amp;</operator><name>width</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>startup_cost</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>total_cost</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* Now update this information in the joinrel */</comment>
	<expr_stmt><expr><name><name>joinrel</name><operator>-&gt;</operator><name>rows</name></name> <operator>=</operator> <name>rows</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>joinrel</name><operator>-&gt;</operator><name>reltarget</name><operator>-&gt;</operator><name>width</name></name> <operator>=</operator> <name>width</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fpinfo</name><operator>-&gt;</operator><name>rows</name></name> <operator>=</operator> <name>rows</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fpinfo</name><operator>-&gt;</operator><name>width</name></name> <operator>=</operator> <name>width</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fpinfo</name><operator>-&gt;</operator><name>startup_cost</name></name> <operator>=</operator> <name>startup_cost</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fpinfo</name><operator>-&gt;</operator><name>total_cost</name></name> <operator>=</operator> <name>total_cost</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Create a new join path and add it to the joinrel which represents a
	 * join between foreign tables.
	 */</comment>
	<expr_stmt><expr><name>joinpath</name> <operator>=</operator> <call><name>create_foreignscan_path</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
									   <argument><expr><name>joinrel</name></expr></argument>,
									   <argument><expr><name>NULL</name></expr></argument>,	<comment type="block">/* default pathtarget */</comment>
									   <argument><expr><name>rows</name></expr></argument>,
									   <argument><expr><name>startup_cost</name></expr></argument>,
									   <argument><expr><name>total_cost</name></expr></argument>,
									   <argument><expr><name>NIL</name></expr></argument>, <comment type="block">/* no pathkeys */</comment>
									   <argument><expr><name><name>joinrel</name><operator>-&gt;</operator><name>lateral_relids</name></name></expr></argument>,
									   <argument><expr><name>epq_path</name></expr></argument>,
									   <argument><expr><name>NIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>	<comment type="block">/* no fdw_private */</comment>

	<comment type="block">/* Add generated path into joinrel by add_path(). */</comment>
	<expr_stmt><expr><call><name>add_path</name><argument_list>(<argument><expr><name>joinrel</name></expr></argument>, <argument><expr><operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator> <name>joinpath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Consider pathkeys for the join relation */</comment>
	<expr_stmt><expr><call><name>add_paths_with_pathkeys_for_rel</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>joinrel</name></expr></argument>, <argument><expr><name>epq_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* XXX Consider parameterized paths for the join relation */</comment>
</block_content>}</block></function>

<comment type="block">/*
 * Assess whether the aggregation, grouping and having operations can be pushed
 * down to the foreign server.  As a side effect, save information we obtain in
 * this function to PgFdwRelationInfo of the input relation.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>foreign_grouping_ok</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>grouped_rel</name></decl></parameter>,
					<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>havingQual</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Query</name>	   <modifier>*</modifier></type><name>query</name> <init>= <expr><name><name>root</name><operator>-&gt;</operator><name>parse</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PgFdwRelationInfo</name> <modifier>*</modifier></type><name>fpinfo</name> <init>= <expr><operator>(</operator><name>PgFdwRelationInfo</name> <operator>*</operator><operator>)</operator> <name><name>grouped_rel</name><operator>-&gt;</operator><name>fdw_private</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PathTarget</name> <modifier>*</modifier></type><name>grouping_target</name> <init>= <expr><name><name>grouped_rel</name><operator>-&gt;</operator><name>reltarget</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PgFdwRelationInfo</name> <modifier>*</modifier></type><name>ofpinfo</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>tlist</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* We currently don't support pushing Grouping Sets. */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>query</name><operator>-&gt;</operator><name>groupingSets</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* Get the fpinfo of the underlying scan relation. */</comment>
	<expr_stmt><expr><name>ofpinfo</name> <operator>=</operator> <operator>(</operator><name>PgFdwRelationInfo</name> <operator>*</operator><operator>)</operator> <name><name>fpinfo</name><operator>-&gt;</operator><name>outerrel</name><operator>-&gt;</operator><name>fdw_private</name></name></expr>;</expr_stmt>

	<comment type="block">/*
	 * If underlying scan relation has any local conditions, those conditions
	 * are required to be applied before performing aggregation.  Hence the
	 * aggregate cannot be pushed down.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>ofpinfo</name><operator>-&gt;</operator><name>local_conds</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Examine grouping expressions, as well as other expressions we'd need to
	 * compute, and check whether they are safe to push down to the foreign
	 * server.  All GROUP BY expressions will be part of the grouping target
	 * and thus there is no need to search for them separately.  Add grouping
	 * expressions into target list which will be passed to foreign server.
	 *
	 * A tricky fine point is that we must not put any expression into the
	 * target list that is just a foreign param (that is, something that
	 * deparse.c would conclude has to be sent to the foreign server).  If we
	 * do, the expression will also appear in the fdw_exprs list of the plan
	 * node, and setrefs.c will get confused and decide that the fdw_exprs
	 * entry is actually a reference to the fdw_scan_tlist entry, resulting in
	 * a broken plan.  Somewhat oddly, it's OK if the expression contains such
	 * a node, as long as it's not at top level; then no match is possible.
	 */</comment>
	<expr_stmt><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>grouping_target-&gt;exprs</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Expr</name>	   <modifier>*</modifier></type><name>expr</name> <init>= <expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Index</name></type>		<name>sgref</name> <init>= <expr><call><name>get_pathtarget_sortgroupref</name><argument_list>(<argument><expr><name>grouping_target</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>

		<comment type="block">/* Check whether this expression is part of GROUP BY clause */</comment>
		<if_stmt><if>if <condition>(<expr><name>sgref</name> <operator>&amp;&amp;</operator> <call><name>get_sortgroupref_clause_noerr</name><argument_list>(<argument><expr><name>sgref</name></expr></argument>, <argument><expr><name><name>query</name><operator>-&gt;</operator><name>groupClause</name></name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>tle</name></decl>;</decl_stmt>

			<comment type="block">/*
			 * If any GROUP BY expression is not shippable, then we cannot
			 * push down aggregation to the foreign server.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>is_foreign_expr</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>grouped_rel</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

			<comment type="block">/*
			 * If it would be a foreign param, we can't put it into the tlist,
			 * so we have to fail.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>is_foreign_param</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>grouped_rel</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

			<comment type="block">/*
			 * Pushable, so add to tlist.  We need to create a TLE for this
			 * expression and apply the sortgroupref to it.  We cannot use
			 * add_to_flat_tlist() here because that avoids making duplicate
			 * entries in the tlist.  If there are duplicate entries with
			 * distinct sortgrouprefs, we have to duplicate that situation in
			 * the output tlist.
			 */</comment>
			<expr_stmt><expr><name>tle</name> <operator>=</operator> <call><name>makeTargetEntry</name><argument_list>(<argument><expr><name>expr</name></expr></argument>, <argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name>tlist</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>tle</name><operator>-&gt;</operator><name>ressortgroupref</name></name> <operator>=</operator> <name>sgref</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>tlist</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>tlist</name></expr></argument>, <argument><expr><name>tle</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/*
			 * Non-grouping expression we need to compute.  Can we ship it
			 * as-is to the foreign server?
			 */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>is_foreign_expr</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>grouped_rel</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
				<operator>!</operator><call><name>is_foreign_param</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>grouped_rel</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* Yes, so add to tlist as-is; OK to suppress duplicates */</comment>
				<expr_stmt><expr><name>tlist</name> <operator>=</operator> <call><name>add_to_flat_tlist</name><argument_list>(<argument><expr><name>tlist</name></expr></argument>, <argument><expr><call><name>list_make1</name><argument_list>(<argument><expr><name>expr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<comment type="block">/* Not pushable as a whole; extract its Vars and aggregates */</comment>
				<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>aggvars</name></decl>;</decl_stmt>

				<expr_stmt><expr><name>aggvars</name> <operator>=</operator> <call><name>pull_var_clause</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>expr</name></expr></argument>,
										  <argument><expr><name>PVC_INCLUDE_AGGREGATES</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/*
				 * If any aggregate expression is not shippable, then we
				 * cannot push down aggregation to the foreign server.  (We
				 * don't have to check is_foreign_param, since that certainly
				 * won't return true for any such expression.)
				 */</comment>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>is_foreign_expr</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>grouped_rel</name></expr></argument>, <argument><expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>aggvars</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

				<comment type="block">/*
				 * Add aggregates, if any, into the targetlist.  Plain Vars
				 * outside an aggregate can be ignored, because they should be
				 * either same as some GROUP BY column or part of some GROUP
				 * BY expression.  In either case, they are already part of
				 * the targetlist and thus no need to add them again.  In fact
				 * including plain Vars in the tlist when they do not match a
				 * GROUP BY column would cause the foreign server to complain
				 * that the shipped query is invalid.
				 */</comment>
				<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>aggvars</argument>)</argument_list></macro>
				<block>{<block_content>
					<decl_stmt><decl><type><name>Expr</name>	   <modifier>*</modifier></type><name>expr</name> <init>= <expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

					<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>expr</name></expr></argument>, <argument><expr><name>Aggref</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><name>tlist</name> <operator>=</operator> <call><name>add_to_flat_tlist</name><argument_list>(<argument><expr><name>tlist</name></expr></argument>, <argument><expr><call><name>list_make1</name><argument_list>(<argument><expr><name>expr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				</block_content>}</block>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block></else></if_stmt>

		<expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block>

	<comment type="block">/*
	 * Classify the pushable and non-pushable HAVING clauses and save them in
	 * remote_conds and local_conds of the grouped rel's fpinfo.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>havingQual</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

		<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>(List *) havingQual</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Expr</name>	   <modifier>*</modifier></type><name>expr</name> <init>= <expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>RestrictInfo</name> <modifier>*</modifier></type><name>rinfo</name></decl>;</decl_stmt>

			<comment type="block">/*
			 * Currently, the core code doesn't wrap havingQuals in
			 * RestrictInfos, so we must make our own.
			 */</comment>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name>expr</name></expr></argument>, <argument><expr><name>RestrictInfo</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>rinfo</name> <operator>=</operator> <call><name>make_restrictinfo</name><argument_list>(<argument><expr><name>expr</name></expr></argument>,
									  <argument><expr><name>true</name></expr></argument>,
									  <argument><expr><name>false</name></expr></argument>,
									  <argument><expr><name>false</name></expr></argument>,
									  <argument><expr><name><name>root</name><operator>-&gt;</operator><name>qual_security_level</name></name></expr></argument>,
									  <argument><expr><name><name>grouped_rel</name><operator>-&gt;</operator><name>relids</name></name></expr></argument>,
									  <argument><expr><name>NULL</name></expr></argument>,
									  <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><call><name>is_foreign_expr</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>grouped_rel</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>fpinfo</name><operator>-&gt;</operator><name>remote_conds</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>fpinfo</name><operator>-&gt;</operator><name>remote_conds</name></name></expr></argument>, <argument><expr><name>rinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>fpinfo</name><operator>-&gt;</operator><name>local_conds</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>fpinfo</name><operator>-&gt;</operator><name>local_conds</name></name></expr></argument>, <argument><expr><name>rinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
		</block_content>}</block>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * If there are any local conditions, pull Vars and aggregates from it and
	 * check whether they are safe to pushdown or not.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>fpinfo</name><operator>-&gt;</operator><name>local_conds</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>aggvars</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

		<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>fpinfo-&gt;local_conds</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>RestrictInfo</name> <modifier>*</modifier></type><name>rinfo</name> <init>= <expr><call><name>lfirst_node</name><argument_list>(<argument><expr><name>RestrictInfo</name></expr></argument>, <argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><name>aggvars</name> <operator>=</operator> <call><name>list_concat</name><argument_list>(<argument><expr><name>aggvars</name></expr></argument>,
								  <argument><expr><call><name>pull_var_clause</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>rinfo</name><operator>-&gt;</operator><name>clause</name></name></expr></argument>,
												  <argument><expr><name>PVC_INCLUDE_AGGREGATES</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>

		<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>aggvars</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Expr</name>	   <modifier>*</modifier></type><name>expr</name> <init>= <expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<comment type="block">/*
			 * If aggregates within local conditions are not safe to push
			 * down, then we cannot push down the query.  Vars are already
			 * part of GROUP BY clause which are checked above, so no need to
			 * access them again here.  Again, we need not check
			 * is_foreign_param for a foreign aggregate.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>expr</name></expr></argument>, <argument><expr><name>Aggref</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>is_foreign_expr</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>grouped_rel</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

				<expr_stmt><expr><name>tlist</name> <operator>=</operator> <call><name>add_to_flat_tlist</name><argument_list>(<argument><expr><name>tlist</name></expr></argument>, <argument><expr><call><name>list_make1</name><argument_list>(<argument><expr><name>expr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Store generated targetlist */</comment>
	<expr_stmt><expr><name><name>fpinfo</name><operator>-&gt;</operator><name>grouped_tlist</name></name> <operator>=</operator> <name>tlist</name></expr>;</expr_stmt>

	<comment type="block">/* Safe to pushdown */</comment>
	<expr_stmt><expr><name><name>fpinfo</name><operator>-&gt;</operator><name>pushdown_safe</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Set cached relation costs to some negative value, so that we can detect
	 * when they are set to some sensible costs, during one (usually the
	 * first) of the calls to estimate_path_cost_size().
	 */</comment>
	<expr_stmt><expr><name><name>fpinfo</name><operator>-&gt;</operator><name>rel_startup_cost</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fpinfo</name><operator>-&gt;</operator><name>rel_total_cost</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>

	<comment type="block">/*
	 * Set the string describing this grouped relation to be used in EXPLAIN
	 * output of corresponding ForeignScan.
	 */</comment>
	<expr_stmt><expr><name><name>fpinfo</name><operator>-&gt;</operator><name>relation_name</name></name> <operator>=</operator> <call><name>makeStringInfo</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name><name>fpinfo</name><operator>-&gt;</operator><name>relation_name</name></name></expr></argument>, <argument><expr><literal type="string">"Aggregate on (%s)"</literal></expr></argument>,
					 <argument><expr><name><name>ofpinfo</name><operator>-&gt;</operator><name>relation_name</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * postgresGetForeignUpperPaths
 *		Add paths for post-join operations like aggregation, grouping etc. if
 *		corresponding operations are safe to push down.
 *
 * Right now, we only support aggregate, grouping and having clause pushdown.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>postgresGetForeignUpperPaths</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>UpperRelationKind</name></type> <name>stage</name></decl></parameter>,
							 <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>input_rel</name></decl></parameter>, <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>output_rel</name></decl></parameter>,
							 <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>extra</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PgFdwRelationInfo</name> <modifier>*</modifier></type><name>fpinfo</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * If input rel is not safe to pushdown, then simply return as we cannot
	 * perform any post-join operations on the foreign server.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>input_rel</name><operator>-&gt;</operator><name>fdw_private</name></name> <operator>||</operator>
		<operator>!</operator><operator>(</operator><operator>(</operator><name>PgFdwRelationInfo</name> <operator>*</operator><operator>)</operator> <name><name>input_rel</name><operator>-&gt;</operator><name>fdw_private</name></name><operator>)</operator><operator>-&gt;</operator><name>pushdown_safe</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/* Ignore stages we don't support; and skip any duplicate calls. */</comment>
	<if_stmt><if>if <condition>(<expr><name>stage</name> <operator>!=</operator> <name>UPPERREL_GROUP_AGG</name> <operator>||</operator> <name><name>output_rel</name><operator>-&gt;</operator><name>fdw_private</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>fpinfo</name> <operator>=</operator> <operator>(</operator><name>PgFdwRelationInfo</name> <operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>PgFdwRelationInfo</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fpinfo</name><operator>-&gt;</operator><name>pushdown_safe</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>output_rel</name><operator>-&gt;</operator><name>fdw_private</name></name> <operator>=</operator> <name>fpinfo</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>add_foreign_grouping_paths</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>input_rel</name></expr></argument>, <argument><expr><name>output_rel</name></expr></argument>,
							   <argument><expr><operator>(</operator><name>GroupPathExtraData</name> <operator>*</operator><operator>)</operator> <name>extra</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * add_foreign_grouping_paths
 *		Add foreign path for grouping and/or aggregation.
 *
 * Given input_rel represents the underlying scan.  The paths are added to the
 * given grouped_rel.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>add_foreign_grouping_paths</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>input_rel</name></decl></parameter>,
						   <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>grouped_rel</name></decl></parameter>,
						   <parameter><decl><type><name>GroupPathExtraData</name> <modifier>*</modifier></type><name>extra</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Query</name>	   <modifier>*</modifier></type><name>parse</name> <init>= <expr><name><name>root</name><operator>-&gt;</operator><name>parse</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PgFdwRelationInfo</name> <modifier>*</modifier></type><name>ifpinfo</name> <init>= <expr><name><name>input_rel</name><operator>-&gt;</operator><name>fdw_private</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PgFdwRelationInfo</name> <modifier>*</modifier></type><name>fpinfo</name> <init>= <expr><name><name>grouped_rel</name><operator>-&gt;</operator><name>fdw_private</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ForeignPath</name> <modifier>*</modifier></type><name>grouppath</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type>		<name>rows</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>width</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Cost</name></type>		<name>startup_cost</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Cost</name></type>		<name>total_cost</name></decl>;</decl_stmt>

	<comment type="block">/* Nothing to be done, if there is no grouping or aggregation required. */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>parse</name><operator>-&gt;</operator><name>groupClause</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>parse</name><operator>-&gt;</operator><name>groupingSets</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>parse</name><operator>-&gt;</operator><name>hasAggs</name></name> <operator>&amp;&amp;</operator>
		<operator>!</operator><name><name>root</name><operator>-&gt;</operator><name>hasHavingQual</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>extra</name><operator>-&gt;</operator><name>patype</name></name> <operator>==</operator> <name>PARTITIONWISE_AGGREGATE_NONE</name> <operator>||</operator>
		   <name><name>extra</name><operator>-&gt;</operator><name>patype</name></name> <operator>==</operator> <name>PARTITIONWISE_AGGREGATE_FULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* save the input_rel as outerrel in fpinfo */</comment>
	<expr_stmt><expr><name><name>fpinfo</name><operator>-&gt;</operator><name>outerrel</name></name> <operator>=</operator> <name>input_rel</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Copy foreign table, foreign server, user mapping, FDW options etc.
	 * details from the input relation's fpinfo.
	 */</comment>
	<expr_stmt><expr><name><name>fpinfo</name><operator>-&gt;</operator><name>table</name></name> <operator>=</operator> <name><name>ifpinfo</name><operator>-&gt;</operator><name>table</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fpinfo</name><operator>-&gt;</operator><name>server</name></name> <operator>=</operator> <name><name>ifpinfo</name><operator>-&gt;</operator><name>server</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fpinfo</name><operator>-&gt;</operator><name>user</name></name> <operator>=</operator> <name><name>ifpinfo</name><operator>-&gt;</operator><name>user</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>merge_fdw_options</name><argument_list>(<argument><expr><name>fpinfo</name></expr></argument>, <argument><expr><name>ifpinfo</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Assess if it is safe to push down aggregation and grouping.
	 *
	 * Use HAVING qual from extra. In case of child partition, it will have
	 * translated Vars.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>foreign_grouping_ok</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>grouped_rel</name></expr></argument>, <argument><expr><name><name>extra</name><operator>-&gt;</operator><name>havingQual</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/* Estimate the cost of push down */</comment>
	<expr_stmt><expr><call><name>estimate_path_cost_size</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>grouped_rel</name></expr></argument>, <argument><expr><name>NIL</name></expr></argument>, <argument><expr><name>NIL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rows</name></expr></argument>,
							<argument><expr><operator>&amp;</operator><name>width</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>startup_cost</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>total_cost</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Now update this information in the fpinfo */</comment>
	<expr_stmt><expr><name><name>fpinfo</name><operator>-&gt;</operator><name>rows</name></name> <operator>=</operator> <name>rows</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fpinfo</name><operator>-&gt;</operator><name>width</name></name> <operator>=</operator> <name>width</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fpinfo</name><operator>-&gt;</operator><name>startup_cost</name></name> <operator>=</operator> <name>startup_cost</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fpinfo</name><operator>-&gt;</operator><name>total_cost</name></name> <operator>=</operator> <name>total_cost</name></expr>;</expr_stmt>

	<comment type="block">/* Create and add foreign path to the grouping relation. */</comment>
	<expr_stmt><expr><name>grouppath</name> <operator>=</operator> <call><name>create_foreignscan_path</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
										<argument><expr><name>grouped_rel</name></expr></argument>,
										<argument><expr><name><name>grouped_rel</name><operator>-&gt;</operator><name>reltarget</name></name></expr></argument>,
										<argument><expr><name>rows</name></expr></argument>,
										<argument><expr><name>startup_cost</name></expr></argument>,
										<argument><expr><name>total_cost</name></expr></argument>,
										<argument><expr><name>NIL</name></expr></argument>,	<comment type="block">/* no pathkeys */</comment>
										<argument><expr><name><name>grouped_rel</name><operator>-&gt;</operator><name>lateral_relids</name></name></expr></argument>,
										<argument><expr><name>NULL</name></expr></argument>,
										<argument><expr><name>NIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>	<comment type="block">/* no fdw_private */</comment>

	<comment type="block">/* Add generated path into grouped_rel by add_path(). */</comment>
	<expr_stmt><expr><call><name>add_path</name><argument_list>(<argument><expr><name>grouped_rel</name></expr></argument>, <argument><expr><operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator> <name>grouppath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Create a tuple from the specified row of the PGresult.
 *
 * rel is the local representation of the foreign table, attinmeta is
 * conversion data for the rel's tupdesc, and retrieved_attrs is an
 * integer list of the table column numbers present in the PGresult.
 * temp_context is a working context that can be reset after each tuple.
 */</comment>
<function><type><specifier>static</specifier> <name>HeapTuple</name></type>
<name>make_tuple_from_result_row</name><parameter_list>(<parameter><decl><type><name>PGresult</name> <modifier>*</modifier></type><name>res</name></decl></parameter>,
						   <parameter><decl><type><name>int</name></type> <name>row</name></decl></parameter>,
						   <parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>,
						   <parameter><decl><type><name>AttInMetadata</name> <modifier>*</modifier></type><name>attinmeta</name></decl></parameter>,
						   <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>retrieved_attrs</name></decl></parameter>,
						   <parameter><decl><type><name>ForeignScanState</name> <modifier>*</modifier></type><name>fsstate</name></decl></parameter>,
						   <parameter><decl><type><name>MemoryContext</name></type> <name>temp_context</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleDesc</name></type>	<name>tupdesc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name>	   <modifier>*</modifier></type><name>values</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name>	   <modifier>*</modifier></type><name>nulls</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ItemPointer</name></type> <name>ctid</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>oid</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ConversionLocation</name></type> <name>errpos</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ErrorContextCallback</name></type> <name>errcallback</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcontext</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>j</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>row</name> <operator>&lt;</operator> <call><name>PQntuples</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Do the following work in a temp context that we reset after each tuple.
	 * This cleans up not only the data we have direct access to, but any
	 * cruft the I/O functions might leak.
	 */</comment>
	<expr_stmt><expr><name>oldcontext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>temp_context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>rel</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>tupdesc</name> <operator>=</operator> <call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>fsstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>tupdesc</name> <operator>=</operator> <name><name>fsstate</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ss_ScanTupleSlot</name><operator>-&gt;</operator><name>tts_tupleDescriptor</name></name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><name>values</name> <operator>=</operator> <operator>(</operator><name>Datum</name> <operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><name><name>tupdesc</name><operator>-&gt;</operator><name>natts</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Datum</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>nulls</name> <operator>=</operator> <operator>(</operator><name>bool</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name><name>tupdesc</name><operator>-&gt;</operator><name>natts</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* Initialize to nulls for any columns not present in result */</comment>
	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>nulls</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name><name>tupdesc</name><operator>-&gt;</operator><name>natts</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Set up and install callback to report where conversion error occurs.
	 */</comment>
	<expr_stmt><expr><name><name>errpos</name><operator>.</operator><name>rel</name></name> <operator>=</operator> <name>rel</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>errpos</name><operator>.</operator><name>cur_attno</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>errpos</name><operator>.</operator><name>fsstate</name></name> <operator>=</operator> <name>fsstate</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>errcallback</name><operator>.</operator><name>callback</name></name> <operator>=</operator> <name>conversion_error_callback</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>errcallback</name><operator>.</operator><name>arg</name></name> <operator>=</operator> <operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>errpos</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>errcallback</name><operator>.</operator><name>previous</name></name> <operator>=</operator> <name>error_context_stack</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>error_context_stack</name> <operator>=</operator> <operator>&amp;</operator><name>errcallback</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * i indexes columns in the relation, j indexes columns in the PGresult.
	 */</comment>
	<expr_stmt><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>retrieved_attrs</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>i</name> <init>= <expr><call><name>lfirst_int</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>valstr</name></decl>;</decl_stmt>

		<comment type="block">/* fetch next column's textual value */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>PQgetisnull</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>row</name></expr></argument>, <argument><expr><name>j</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>valstr</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>valstr</name> <operator>=</operator> <call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>row</name></expr></argument>, <argument><expr><name>j</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<comment type="block">/*
		 * convert value to internal representation
		 *
		 * Note: we ignore system columns other than ctid and oid in result
		 */</comment>
		<expr_stmt><expr><name><name>errpos</name><operator>.</operator><name>cur_attno</name></name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>i</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* ordinary column */</comment>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>i</name> <operator>&lt;=</operator> <name><name>tupdesc</name><operator>-&gt;</operator><name>natts</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>nulls</name><index>[<expr><name>i</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>valstr</name> <operator>==</operator> <name>NULL</name><operator>)</operator></expr>;</expr_stmt>
			<comment type="block">/* Apply the input function even to nulls, to support domains */</comment>
			<expr_stmt><expr><name><name>values</name><index>[<expr><name>i</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>InputFunctionCall</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>attinmeta</name><operator>-&gt;</operator><name>attinfuncs</name><index>[<expr><name>i</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>,
											  <argument><expr><name>valstr</name></expr></argument>,
											  <argument><expr><name><name>attinmeta</name><operator>-&gt;</operator><name>attioparams</name><index>[<expr><name>i</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>,
											  <argument><expr><name><name>attinmeta</name><operator>-&gt;</operator><name>atttypmods</name><index>[<expr><name>i</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name>i</name> <operator>==</operator> <name>SelfItemPointerAttributeNumber</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* ctid */</comment>
			<if_stmt><if>if <condition>(<expr><name>valstr</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>Datum</name></type>		<name>datum</name></decl>;</decl_stmt>

				<expr_stmt><expr><name>datum</name> <operator>=</operator> <call><name>DirectFunctionCall1</name><argument_list>(<argument><expr><name>tidin</name></expr></argument>, <argument><expr><call><name>CStringGetDatum</name><argument_list>(<argument><expr><name>valstr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>ctid</name> <operator>=</operator> <operator>(</operator><name>ItemPointer</name><operator>)</operator> <call><name>DatumGetPointer</name><argument_list>(<argument><expr><name>datum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name>i</name> <operator>==</operator> <name>ObjectIdAttributeNumber</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* oid */</comment>
			<if_stmt><if>if <condition>(<expr><name>valstr</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>Datum</name></type>		<name>datum</name></decl>;</decl_stmt>

				<expr_stmt><expr><name>datum</name> <operator>=</operator> <call><name>DirectFunctionCall1</name><argument_list>(<argument><expr><name>oidin</name></expr></argument>, <argument><expr><call><name>CStringGetDatum</name><argument_list>(<argument><expr><name>valstr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>oid</name> <operator>=</operator> <call><name>DatumGetObjectId</name><argument_list>(<argument><expr><name>datum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><name><name>errpos</name><operator>.</operator><name>cur_attno</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

		<expr_stmt><expr><name>j</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block>

	<comment type="block">/* Uninstall error context callback. */</comment>
	<expr_stmt><expr><name>error_context_stack</name> <operator>=</operator> <name><name>errcallback</name><operator>.</operator><name>previous</name></name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Check we got the expected number of columns.  Note: j == 0 and
	 * PQnfields == 1 is expected, since deparse emits a NULL if no columns.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>j</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>j</name> <operator>!=</operator> <call><name>PQnfields</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"remote query result does not match the foreign table"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Build the result tuple in caller's memory context.
	 */</comment>
	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>heap_form_tuple</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><name>values</name></expr></argument>, <argument><expr><name>nulls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If we have a CTID to return, install it in both t_self and t_ctid.
	 * t_self is the normal place, but if the tuple is converted to a
	 * composite Datum, t_self will be lost; setting t_ctid allows CTID to be
	 * preserved during EvalPlanQual re-evaluations (see ROW_MARK_COPY code).
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>ctid</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>tuple</name><operator>-&gt;</operator><name>t_self</name></name> <operator>=</operator> <name><name>tuple</name><operator>-&gt;</operator><name>t_data</name><operator>-&gt;</operator><name>t_ctid</name></name> <operator>=</operator> <operator>*</operator><name>ctid</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Stomp on the xmin, xmax, and cmin fields from the tuple created by
	 * heap_form_tuple.  heap_form_tuple actually creates the tuple with
	 * DatumTupleFields, not HeapTupleFields, but the executor expects
	 * HeapTupleFields and will happily extract system columns on that
	 * assumption.  If we don't do this then, for example, the tuple length
	 * ends up in the xmin field, which isn't what we want.
	 */</comment>
	<expr_stmt><expr><call><name>HeapTupleHeaderSetXmax</name><argument_list>(<argument><expr><name><name>tuple</name><operator>-&gt;</operator><name>t_data</name></name></expr></argument>, <argument><expr><name>InvalidTransactionId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>HeapTupleHeaderSetXmin</name><argument_list>(<argument><expr><name><name>tuple</name><operator>-&gt;</operator><name>t_data</name></name></expr></argument>, <argument><expr><name>InvalidTransactionId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>HeapTupleHeaderSetCmin</name><argument_list>(<argument><expr><name><name>tuple</name><operator>-&gt;</operator><name>t_data</name></name></expr></argument>, <argument><expr><name>InvalidTransactionId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If we have an OID to return, install it.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>oid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>HeapTupleSetOid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>, <argument><expr><name>oid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Clean up */</comment>
	<expr_stmt><expr><call><name>MemoryContextReset</name><argument_list>(<argument><expr><name>temp_context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>tuple</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Callback function which is called when error occurs during column value
 * conversion.  Print names of column and relation.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>conversion_error_callback</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>attname</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>relname</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>is_wholerow</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ConversionLocation</name> <modifier>*</modifier></type><name>errpos</name> <init>= <expr><operator>(</operator><name>ConversionLocation</name> <operator>*</operator><operator>)</operator> <name>arg</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>errpos</name><operator>-&gt;</operator><name>rel</name></name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* error occurred in a scan against a foreign table */</comment>
		<decl_stmt><decl><type><name>TupleDesc</name></type>	<name>tupdesc</name> <init>= <expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name><name>errpos</name><operator>-&gt;</operator><name>rel</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>attr</name> <init>= <expr><call><name>TupleDescAttr</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><name><name>errpos</name><operator>-&gt;</operator><name>cur_attno</name></name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>errpos</name><operator>-&gt;</operator><name>cur_attno</name></name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>errpos</name><operator>-&gt;</operator><name>cur_attno</name></name> <operator>&lt;=</operator> <name><name>tupdesc</name><operator>-&gt;</operator><name>natts</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>attname</name> <operator>=</operator> <call><name>NameStr</name><argument_list>(<argument><expr><name><name>attr</name><operator>-&gt;</operator><name>attname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><name><name>errpos</name><operator>-&gt;</operator><name>cur_attno</name></name> <operator>==</operator> <name>SelfItemPointerAttributeNumber</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>attname</name> <operator>=</operator> <literal type="string">"ctid"</literal></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><name><name>errpos</name><operator>-&gt;</operator><name>cur_attno</name></name> <operator>==</operator> <name>ObjectIdAttributeNumber</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>attname</name> <operator>=</operator> <literal type="string">"oid"</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>relname</name> <operator>=</operator> <call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name><name>errpos</name><operator>-&gt;</operator><name>rel</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* error occurred in a scan against a foreign join */</comment>
		<decl_stmt><decl><type><name>ForeignScanState</name> <modifier>*</modifier></type><name>fsstate</name> <init>= <expr><name><name>errpos</name><operator>-&gt;</operator><name>fsstate</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ForeignScan</name> <modifier>*</modifier></type><name>fsplan</name> <init>= <expr><call><name>castNode</name><argument_list>(<argument><expr><name>ForeignScan</name></expr></argument>, <argument><expr><name><name>fsstate</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ps</name><operator>.</operator><name>plan</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>EState</name>	   <modifier>*</modifier></type><name>estate</name> <init>= <expr><name><name>fsstate</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ps</name><operator>.</operator><name>state</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>tle</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>tle</name> <operator>=</operator> <call><name>list_nth_node</name><argument_list>(<argument><expr><name>TargetEntry</name></expr></argument>, <argument><expr><name><name>fsplan</name><operator>-&gt;</operator><name>fdw_scan_tlist</name></name></expr></argument>,
							<argument><expr><name><name>errpos</name><operator>-&gt;</operator><name>cur_attno</name></name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Target list can have Vars and expressions.  For Vars, we can get
		 * its relation, however for expressions we can't.  Thus for
		 * expressions, just show generic context message.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name><name>tle</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>, <argument><expr><name>Var</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Var</name>		   <modifier>*</modifier></type><name>var</name> <init>= <expr><operator>(</operator><name>Var</name> <operator>*</operator><operator>)</operator> <name><name>tle</name><operator>-&gt;</operator><name>expr</name></name></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><name>rte</name> <operator>=</operator> <call><name>rt_fetch</name><argument_list>(<argument><expr><name><name>var</name><operator>-&gt;</operator><name>varno</name></name></expr></argument>, <argument><expr><name><name>estate</name><operator>-&gt;</operator><name>es_range_table</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>var</name><operator>-&gt;</operator><name>varattno</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>is_wholerow</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name>attname</name> <operator>=</operator> <call><name>get_attname</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>, <argument><expr><name><name>var</name><operator>-&gt;</operator><name>varattno</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

			<expr_stmt><expr><name>relname</name> <operator>=</operator> <call><name>get_rel_name</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>errcontext</name><argument_list>(<argument><expr><literal type="string">"processing expression at position %d in select list"</literal></expr></argument>,
					   <argument><expr><name><name>errpos</name><operator>-&gt;</operator><name>cur_attno</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>relname</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>is_wholerow</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>errcontext</name><argument_list>(<argument><expr><literal type="string">"whole-row reference to foreign table \"%s\""</literal></expr></argument>, <argument><expr><name>relname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><name>attname</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>errcontext</name><argument_list>(<argument><expr><literal type="string">"column \"%s\" of foreign table \"%s\""</literal></expr></argument>, <argument><expr><name>attname</name></expr></argument>, <argument><expr><name>relname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Find an equivalence class member expression, all of whose Vars, come from
 * the indicated relation.
 */</comment>
<function><type><name>Expr</name> <modifier>*</modifier></type>
<name>find_em_expr_for_rel</name><parameter_list>(<parameter><decl><type><name>EquivalenceClass</name> <modifier>*</modifier></type><name>ec</name></decl></parameter>, <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>rel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc_em</name></decl>;</decl_stmt>

	<macro><name>foreach</name><argument_list>(<argument>lc_em</argument>, <argument>ec-&gt;ec_members</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>EquivalenceMember</name> <modifier>*</modifier></type><name>em</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc_em</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>bms_is_subset</name><argument_list>(<argument><expr><name><name>em</name><operator>-&gt;</operator><name>em_relids</name></name></expr></argument>, <argument><expr><name><name>rel</name><operator>-&gt;</operator><name>relids</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
			<operator>!</operator><call><name>bms_is_empty</name><argument_list>(<argument><expr><name><name>em</name><operator>-&gt;</operator><name>em_relids</name></name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * If there is more than one equivalence member whose Vars are
			 * taken entirely from this relation, we'll be content to choose
			 * any one of those.
			 */</comment>
			<return>return <expr><name><name>em</name><operator>-&gt;</operator><name>em_expr</name></name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>

	<comment type="block">/* We didn't find any suitable equivalence class expression */</comment>
	<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>
</unit>
