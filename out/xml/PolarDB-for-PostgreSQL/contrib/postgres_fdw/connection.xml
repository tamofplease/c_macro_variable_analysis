<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/PolarDB-for-PostgreSQL/contrib/postgres_fdw/connection.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * connection.c
 *		  Connection management functions for postgres_fdw
 *
 * Portions Copyright (c) 2012-2018, PostgreSQL Global Development Group
 *
 * IDENTIFICATION
 *		  contrib/postgres_fdw/connection.c
 *
 *-------------------------------------------------------------------------
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres_fdw.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/htup_details.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_user_mapping.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/xact.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"mb/pg_wchar.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pgstat.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/latch.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/hsearch.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/inval.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/memutils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/syscache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/guc.h"</cpp:file></cpp:include>


<comment type="block">/*
 * Connection cache hash table entry
 *
 * The lookup key in this hash table is the user mapping OID. We use just one
 * connection per user mapping ID, which ensures that all the scans use the
 * same snapshot during a query.  Using the user mapping OID rather than
 * the foreign server OID + user OID avoids creating multiple connections when
 * the public user mapping applies to all user OIDs.
 *
 * The "conn" pointer can be NULL if we don't currently have a live connection.
 * When we do have a connection, xact_depth tracks the current depth of
 * transactions and subtransactions open on the remote side.  We need to issue
 * commands at the same nesting depth on the remote as we're executing at
 * ourselves, so that rolling back a subtransaction will kill the right
 * queries and not the wrong ones.
 */</comment>
<typedef>typedef <type><name>Oid</name></type> <name>ConnCacheKey</name>;</typedef>

<typedef>typedef <type><struct>struct <name>ConnCacheEntry</name>
<block>{
	<decl_stmt><decl><type><name>ConnCacheKey</name></type> <name>key</name></decl>;</decl_stmt>			<comment type="block">/* hash key (must be first) */</comment>
	<decl_stmt><decl><type><name>PGconn</name>	   <modifier>*</modifier></type><name>conn</name></decl>;</decl_stmt>			<comment type="block">/* connection to foreign server, or NULL */</comment>
	<comment type="block">/* Remaining fields are invalid when conn is NULL: */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>xact_depth</name></decl>;</decl_stmt>		<comment type="block">/* 0 = no xact open, 1 = main xact open, 2 =
								 * one level of subxact open, etc */</comment>
	<decl_stmt><decl><type><name>bool</name></type>		<name>have_prep_stmt</name></decl>;</decl_stmt> <comment type="block">/* have we prepared any stmts in this xact? */</comment>
	<decl_stmt><decl><type><name>bool</name></type>		<name>have_error</name></decl>;</decl_stmt>		<comment type="block">/* have any subxacts aborted in this xact? */</comment>
	<decl_stmt><decl><type><name>bool</name></type>		<name>changing_xact_state</name></decl>;</decl_stmt>	<comment type="block">/* xact state change in process */</comment>
	<decl_stmt><decl><type><name>bool</name></type>		<name>invalidated</name></decl>;</decl_stmt>	<comment type="block">/* true if reconnect is pending */</comment>
	<decl_stmt><decl><type><name>uint32</name></type>		<name>server_hashvalue</name></decl>;</decl_stmt>	<comment type="block">/* hash value of foreign server OID */</comment>
	<decl_stmt><decl><type><name>uint32</name></type>		<name>mapping_hashvalue</name></decl>;</decl_stmt>	<comment type="block">/* hash value of user mapping OID */</comment>
}</block></struct></type> <name>ConnCacheEntry</name>;</typedef>

<comment type="block">/*
 * Connection cache (initialized on first use)
 */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>HTAB</name> <modifier>*</modifier></type><name>ConnectionHash</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<comment type="block">/* for assigning cursor numbers and prepared statement numbers */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>unsigned</name> <name>int</name></type> <name>cursor_number</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>unsigned</name> <name>int</name></type> <name>prep_stmt_number</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<comment type="block">/* tracks whether any work is needed in callback functions */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type> <name>xact_got_connection</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

<comment type="block">/* prototypes of private functions */</comment>
<function_decl><type><specifier>static</specifier> <name>PGconn</name> <modifier>*</modifier></type><name>connect_pg_server</name><parameter_list>(<parameter><decl><type><name>ForeignServer</name> <modifier>*</modifier></type><name>server</name></decl></parameter>, <parameter><decl><type><name>UserMapping</name> <modifier>*</modifier></type><name>user</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>disconnect_pg_server</name><parameter_list>(<parameter><decl><type><name>ConnCacheEntry</name> <modifier>*</modifier></type><name>entry</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>check_conn_params</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>keywords</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>values</name></decl></parameter>, <parameter><decl><type><name>UserMapping</name> <modifier>*</modifier></type><name>user</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>configure_remote_session</name><parameter_list>(<parameter><decl><type><name>PGconn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>do_sql_command</name><parameter_list>(<parameter><decl><type><name>PGconn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>sql</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>begin_remote_xact</name><parameter_list>(<parameter><decl><type><name>ConnCacheEntry</name> <modifier>*</modifier></type><name>entry</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>pgfdw_xact_callback</name><parameter_list>(<parameter><decl><type><name>XactEvent</name></type> <name>event</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>pgfdw_subxact_callback</name><parameter_list>(<parameter><decl><type><name>SubXactEvent</name></type> <name>event</name></decl></parameter>,
					   <parameter><decl><type><name>SubTransactionId</name></type> <name>mySubid</name></decl></parameter>,
					   <parameter><decl><type><name>SubTransactionId</name></type> <name>parentSubid</name></decl></parameter>,
					   <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>pgfdw_inval_callback</name><parameter_list>(<parameter><decl><type><name>Datum</name></type> <name>arg</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>cacheid</name></decl></parameter>, <parameter><decl><type><name>uint32</name></type> <name>hashvalue</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>pgfdw_reject_incomplete_xact_state_change</name><parameter_list>(<parameter><decl><type><name>ConnCacheEntry</name> <modifier>*</modifier></type><name>entry</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>pgfdw_cancel_query</name><parameter_list>(<parameter><decl><type><name>PGconn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>pgfdw_exec_cleanup_query</name><parameter_list>(<parameter><decl><type><name>PGconn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>query</name></decl></parameter>,
						 <parameter><decl><type><name>bool</name></type> <name>ignore_errors</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>pgfdw_get_cleanup_result</name><parameter_list>(<parameter><decl><type><name>PGconn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>, <parameter><decl><type><name>TimestampTz</name></type> <name>endtime</name></decl></parameter>,
						 <parameter><decl><type><name>PGresult</name> <modifier>*</modifier><modifier>*</modifier></type><name>result</name></decl></parameter>)</parameter_list>;</function_decl>
<comment type="block">/* POLAR */</comment>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>polar_conn_opt_parse</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>keyword</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>value</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>freeptr</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type>		<name>_PG_init</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>

<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type> <name>polar_auto_port_mapping</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type> <name>polar_connection_check</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>extern</specifier> <name>PGDLLIMPORT</name> <name>int</name></type>	<name>PostPortNumber</name></decl>;</decl_stmt>
<comment type="block">/* POLAR end */</comment>

<comment type="block">/*
 * declare guc paramters
 */</comment>
<function><type><name>void</name></type>
<name>_PG_init</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>DefineCustomBoolVariable</name><argument_list>(<argument><expr><literal type="string">"postgres_fdw.polar_auto_port_mapping"</literal></expr></argument>,
							 <argument><expr><literal type="string">"auto mapping port to local instance."</literal></expr></argument>,
							 <argument><expr><name>NULL</name></expr></argument>,
							 <argument><expr><operator>&amp;</operator><name>polar_auto_port_mapping</name></expr></argument>,
							 <argument><expr><name>false</name></expr></argument>,
							 <argument><expr><name>PGC_SUSET</name></expr></argument>,
							 <argument><expr><literal type="number">0</literal></expr></argument>,
							 <argument><expr><name>NULL</name></expr></argument>,
							 <argument><expr><name>NULL</name></expr></argument>,
							 <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>DefineCustomBoolVariable</name><argument_list>(<argument><expr><literal type="string">"postgres_fdw.polar_connection_check"</literal></expr></argument>,
							 <argument><expr><literal type="string">"rds connection check"</literal></expr></argument>,
							 <argument><expr><name>NULL</name></expr></argument>,
							 <argument><expr><operator>&amp;</operator><name>polar_connection_check</name></expr></argument>,
							 <argument><expr><name>false</name></expr></argument>,
							 <argument><expr><name>PGC_SUSET</name></expr></argument>,
							 <argument><expr><literal type="number">0</literal></expr></argument>,
							 <argument><expr><name>NULL</name></expr></argument>,
							 <argument><expr><name>NULL</name></expr></argument>,
							 <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Get a PGconn which can be used to execute queries on the remote PostgreSQL
 * server with the user's authorization.  A new connection is established
 * if we don't already have a suitable one, and a transaction is opened at
 * the right subtransaction nesting depth if we didn't do that already.
 *
 * will_prep_stmt must be true if caller intends to create any prepared
 * statements.  Since those don't go away automatically at transaction end
 * (not even on error), we need this flag to cue manual cleanup.
 */</comment>
<function><type><name>PGconn</name> <modifier>*</modifier></type>
<name>GetConnection</name><parameter_list>(<parameter><decl><type><name>UserMapping</name> <modifier>*</modifier></type><name>user</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>will_prep_stmt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type>		<name>found</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ConnCacheEntry</name> <modifier>*</modifier></type><name>entry</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ConnCacheKey</name></type> <name>key</name></decl>;</decl_stmt>

	<comment type="block">/* First time through, initialize connection cache hashtable */</comment>
	<if_stmt><if>if <condition>(<expr><name>ConnectionHash</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>HASHCTL</name></type>		<name>ctl</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ctl</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ctl</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>ctl</name><operator>.</operator><name>keysize</name></name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ConnCacheKey</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>ctl</name><operator>.</operator><name>entrysize</name></name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ConnCacheEntry</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
		<comment type="block">/* allocate ConnectionHash in the cache context */</comment>
		<expr_stmt><expr><name><name>ctl</name><operator>.</operator><name>hcxt</name></name> <operator>=</operator> <name>CacheMemoryContext</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>ConnectionHash</name> <operator>=</operator> <call><name>hash_create</name><argument_list>(<argument><expr><literal type="string">"postgres_fdw connections"</literal></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>,
									 <argument><expr><operator>&amp;</operator><name>ctl</name></expr></argument>,
									 <argument><expr><name>HASH_ELEM</name> <operator>|</operator> <name>HASH_BLOBS</name> <operator>|</operator> <name>HASH_CONTEXT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Register some callback functions that manage connection cleanup.
		 * This should be done just once in each backend.
		 */</comment>
		<expr_stmt><expr><call><name>RegisterXactCallback</name><argument_list>(<argument><expr><name>pgfdw_xact_callback</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>RegisterSubXactCallback</name><argument_list>(<argument><expr><name>pgfdw_subxact_callback</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>CacheRegisterSyscacheCallback</name><argument_list>(<argument><expr><name>FOREIGNSERVEROID</name></expr></argument>,
									  <argument><expr><name>pgfdw_inval_callback</name></expr></argument>, <argument><expr><operator>(</operator><name>Datum</name><operator>)</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>CacheRegisterSyscacheCallback</name><argument_list>(<argument><expr><name>USERMAPPINGOID</name></expr></argument>,
									  <argument><expr><name>pgfdw_inval_callback</name></expr></argument>, <argument><expr><operator>(</operator><name>Datum</name><operator>)</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Set flag that we did GetConnection during the current transaction */</comment>
	<expr_stmt><expr><name>xact_got_connection</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

	<comment type="block">/* Create hash key for the entry.  Assume no pad bytes in key struct */</comment>
	<expr_stmt><expr><name>key</name> <operator>=</operator> <name><name>user</name><operator>-&gt;</operator><name>umid</name></name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Find or create cached entry for requested connection.
	 */</comment>
	<expr_stmt><expr><name>entry</name> <operator>=</operator> <call><name>hash_search</name><argument_list>(<argument><expr><name>ConnectionHash</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>key</name></expr></argument>, <argument><expr><name>HASH_ENTER</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>found</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * We need only clear "conn" here; remaining fields will be filled
		 * later when "conn" is set.
		 */</comment>
		<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>conn</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Reject further use of connections which failed abort cleanup. */</comment>
	<expr_stmt><expr><call><name>pgfdw_reject_incomplete_xact_state_change</name><argument_list>(<argument><expr><name>entry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If the connection needs to be remade due to invalidation, disconnect as
	 * soon as we're out of all transactions.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>entry</name><operator>-&gt;</operator><name>conn</name></name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name><name>entry</name><operator>-&gt;</operator><name>invalidated</name></name> <operator>&amp;&amp;</operator> <name><name>entry</name><operator>-&gt;</operator><name>xact_depth</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG3</name></expr></argument>, <argument><expr><literal type="string">"closing connection %p for option changes to take effect"</literal></expr></argument>,
			 <argument><expr><name><name>entry</name><operator>-&gt;</operator><name>conn</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>disconnect_pg_server</name><argument_list>(<argument><expr><name>entry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * We don't check the health of cached connection here, because it would
	 * require some overhead.  Broken connection will be detected when the
	 * connection is actually used.
	 */</comment>

	<comment type="block">/*
	 * If cache entry doesn't have a connection, we have to establish a new
	 * connection.  (If connect_pg_server throws an error, the cache entry
	 * will remain in a valid empty state, ie conn == NULL.)
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>entry</name><operator>-&gt;</operator><name>conn</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ForeignServer</name> <modifier>*</modifier></type><name>server</name> <init>= <expr><call><name>GetForeignServer</name><argument_list>(<argument><expr><name><name>user</name><operator>-&gt;</operator><name>serverid</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/* Reset all transient state fields, to be sure all are clean */</comment>
		<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>xact_depth</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>have_prep_stmt</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>have_error</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>changing_xact_state</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>invalidated</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>server_hashvalue</name></name> <operator>=</operator>
			<call><name>GetSysCacheHashValue1</name><argument_list>(<argument><expr><name>FOREIGNSERVEROID</name></expr></argument>,
								  <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name><name>server</name><operator>-&gt;</operator><name>serverid</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>mapping_hashvalue</name></name> <operator>=</operator>
			<call><name>GetSysCacheHashValue1</name><argument_list>(<argument><expr><name>USERMAPPINGOID</name></expr></argument>,
								  <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name><name>user</name><operator>-&gt;</operator><name>umid</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Now try to make the connection */</comment>
		<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>conn</name></name> <operator>=</operator> <call><name>connect_pg_server</name><argument_list>(<argument><expr><name>server</name></expr></argument>, <argument><expr><name>user</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG3</name></expr></argument>, <argument><expr><literal type="string">"new postgres_fdw connection %p for server \"%s\" (user mapping oid %u, userid %u)"</literal></expr></argument>,
			 <argument><expr><name><name>entry</name><operator>-&gt;</operator><name>conn</name></name></expr></argument>, <argument><expr><name><name>server</name><operator>-&gt;</operator><name>servername</name></name></expr></argument>, <argument><expr><name><name>user</name><operator>-&gt;</operator><name>umid</name></name></expr></argument>, <argument><expr><name><name>user</name><operator>-&gt;</operator><name>userid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Start a new transaction or subtransaction if needed.
	 */</comment>
	<expr_stmt><expr><call><name>begin_remote_xact</name><argument_list>(<argument><expr><name>entry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Remember if caller will prepare statements */</comment>
	<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>have_prep_stmt</name></name> <operator>|=</operator> <name>will_prep_stmt</name></expr>;</expr_stmt>

	<return>return <expr><name><name>entry</name><operator>-&gt;</operator><name>conn</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Connect to remote server using specified server and user mapping properties.
 */</comment>
<function><type><specifier>static</specifier> <name>PGconn</name> <modifier>*</modifier></type>
<name>connect_pg_server</name><parameter_list>(<parameter><decl><type><name>ForeignServer</name> <modifier>*</modifier></type><name>server</name></decl></parameter>, <parameter><decl><type><name>UserMapping</name> <modifier>*</modifier></type><name>user</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PGconn</name>	   <modifier>*</modifier><specifier>volatile</specifier></type> <name>conn</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	<modifier>*</modifier></type><name>freeptr</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * Use PG_TRY block to ensure closing connection on error.
	 */</comment>
	<expr_stmt><expr><call><name>PG_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<block>{<block_content>
		<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>keywords</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>values</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>n</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * Construct connection params from generic options of ForeignServer
		 * and UserMapping.  (Some of them might not be libpq options, in
		 * which case we'll just waste a few array slots.)  Add 3 extra slots
		 * for fallback_application_name, client_encoding, end marker.
		 */</comment>
		<expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>server</name><operator>-&gt;</operator><name>options</name></name></expr></argument>)</argument_list></call> <operator>+</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>user</name><operator>-&gt;</operator><name>options</name></name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">5</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name>keywords</name> <operator>=</operator> <operator>(</operator><specifier>const</specifier> <name>char</name> <operator>*</operator><operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>n</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>char</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>values</name> <operator>=</operator> <operator>(</operator><specifier>const</specifier> <name>char</name> <operator>*</operator><operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>n</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>char</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>n</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name>n</name> <operator>+=</operator> <call><name>ExtractConnectionOptions</name><argument_list>(<argument><expr><name><name>server</name><operator>-&gt;</operator><name>options</name></name></expr></argument>,
									  <argument><expr><name>keywords</name> <operator>+</operator> <name>n</name></expr></argument>, <argument><expr><name>values</name> <operator>+</operator> <name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>n</name> <operator>+=</operator> <call><name>ExtractConnectionOptions</name><argument_list>(<argument><expr><name><name>user</name><operator>-&gt;</operator><name>options</name></name></expr></argument>,
									  <argument><expr><name>keywords</name> <operator>+</operator> <name>n</name></expr></argument>, <argument><expr><name>values</name> <operator>+</operator> <name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Use "postgres_fdw" as fallback_application_name. */</comment>
		<expr_stmt><expr><name><name>keywords</name><index>[<expr><name>n</name></expr>]</index></name> <operator>=</operator> <literal type="string">"fallback_application_name"</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>values</name><index>[<expr><name>n</name></expr>]</index></name> <operator>=</operator> <literal type="string">"postgres_fdw"</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name>n</name><operator>++</operator></expr>;</expr_stmt>

		<comment type="block">/* Set client_encoding so that libpq can convert encoding properly. */</comment>
		<expr_stmt><expr><name><name>keywords</name><index>[<expr><name>n</name></expr>]</index></name> <operator>=</operator> <literal type="string">"client_encoding"</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>values</name><index>[<expr><name>n</name></expr>]</index></name> <operator>=</operator> <call><name>GetDatabaseEncodingName</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>n</name><operator>++</operator></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>keywords</name><index>[<expr><name>n</name></expr>]</index></name> <operator>=</operator> <name><name>values</name><index>[<expr><name>n</name></expr>]</index></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>polar_conn_opt_parse</name><argument_list>(<argument><expr><name>keywords</name></expr></argument>, <argument><expr><name>values</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>freeptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* verify connection parameters and make connection */</comment>
		<expr_stmt><expr><call><name>check_conn_params</name><argument_list>(<argument><expr><name>keywords</name></expr></argument>, <argument><expr><name>values</name></expr></argument>, <argument><expr><name>user</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>conn</name> <operator>=</operator> <call><name>PQconnectdbParams</name><argument_list>(<argument><expr><name>keywords</name></expr></argument>, <argument><expr><name>values</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>conn</name> <operator>||</operator> <call><name>PQstatus</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>CONNECTION_OK</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SQLCLIENT_UNABLE_TO_ESTABLISH_SQLCONNECTION</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not connect to server \"%s\""</literal></expr></argument>,
							<argument><expr><name><name>server</name><operator>-&gt;</operator><name>servername</name></name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errdetail_internal</name><argument_list>(<argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><call><name>pchomp</name><argument_list>(<argument><expr><call><name>PQerrorMessage</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * Check that non-superuser has used password to establish connection;
		 * otherwise, he's piggybacking on the postgres server's user
		 * identity. See also dblink_security_check() in contrib/dblink.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>superuser_arg</name><argument_list>(<argument><expr><name><name>user</name><operator>-&gt;</operator><name>userid</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>PQconnectionUsedPassword</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_S_R_E_PROHIBITED_SQL_STATEMENT_ATTEMPTED</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"password is required"</literal></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Non-superuser cannot connect if the server does not request a password."</literal></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Target server's authentication method must be changed."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/* Prepare new session for use */</comment>
		<expr_stmt><expr><call><name>configure_remote_session</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>freeptr</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>freeptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>keywords</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>values</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
	<expr_stmt><expr><call><name>PG_CATCH</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<block>{<block_content>
		<comment type="block">/* Release PGconn data structure if we managed to create one */</comment>
		<if_stmt><if>if <condition>(<expr><name>conn</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>PQfinish</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>PG_RE_THROW</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
	<expr_stmt><expr><call><name>PG_END_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>conn</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Disconnect any open connection for a connection cache entry.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>disconnect_pg_server</name><parameter_list>(<parameter><decl><type><name>ConnCacheEntry</name> <modifier>*</modifier></type><name>entry</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name><name>entry</name><operator>-&gt;</operator><name>conn</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>PQfinish</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>conn</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>conn</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * For non-superusers, insist that the connstr specify a password.  This
 * prevents a password from being picked up from .pgpass, a service file,
 * the environment, etc.  We don't want the postgres user's passwords
 * to be accessible to non-superusers.  (See also dblink_connstr_check in
 * contrib/dblink.)
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>check_conn_params</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>keywords</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>values</name></decl></parameter>, <parameter><decl><type><name>UserMapping</name> <modifier>*</modifier></type><name>user</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<comment type="block">/* no check required if superuser */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>superuser_arg</name><argument_list>(<argument><expr><name><name>user</name><operator>-&gt;</operator><name>userid</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/* ok if params contain a non-empty password */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name><name>keywords</name><index>[<expr><name>i</name></expr>]</index></name> <operator>!=</operator> <name>NULL</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>keywords</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"password"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>values</name><index>[<expr><name>i</name></expr>]</index><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'\0'</literal></expr>)</condition><block type="pseudo"><block_content>
			<return>return;</return></block_content></block></if></if_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
			<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_S_R_E_PROHIBITED_SQL_STATEMENT_ATTEMPTED</name></expr></argument>)</argument_list></call><operator>,</operator>
			 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"password is required"</literal></expr></argument>)</argument_list></call><operator>,</operator>
			 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Non-superusers must provide a password in the user mapping."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Issue SET commands to make sure remote session is configured properly.
 *
 * We do this just once at connection, assuming nothing will change the
 * values later.  Since we'll never send volatile function calls to the
 * remote, there shouldn't be any way to break this assumption from our end.
 * It's possible to think of ways to break it at the remote end, eg making
 * a foreign table point to a view that includes a set_config call ---
 * but once you admit the possibility of a malicious view definition,
 * there are any number of ways to break things.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>configure_remote_session</name><parameter_list>(<parameter><decl><type><name>PGconn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>remoteversion</name> <init>= <expr><call><name>PQserverVersion</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/* Force the search path to contain only pg_catalog (see deparse.c) */</comment>
	<expr_stmt><expr><call><name>do_sql_command</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><literal type="string">"SET search_path = pg_catalog"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Set remote timezone; this is basically just cosmetic, since all
	 * transmitted and returned timestamptzs should specify a zone explicitly
	 * anyway.  However it makes the regression test outputs more predictable.
	 *
	 * We don't risk setting remote zone equal to ours, since the remote
	 * server might use a different timezone database.  Instead, use UTC
	 * (quoted, because very old servers are picky about case).
	 */</comment>
	<expr_stmt><expr><call><name>do_sql_command</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><literal type="string">"SET timezone = 'UTC'"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Set values needed to ensure unambiguous data output from remote.  (This
	 * logic should match what pg_dump does.  See also set_transmission_modes
	 * in postgres_fdw.c.)
	 */</comment>
	<expr_stmt><expr><call><name>do_sql_command</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><literal type="string">"SET datestyle = ISO"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>remoteversion</name> <operator>&gt;=</operator> <literal type="number">80400</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>do_sql_command</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><literal type="string">"SET intervalstyle = postgres"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>remoteversion</name> <operator>&gt;=</operator> <literal type="number">90000</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>do_sql_command</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><literal type="string">"SET extra_float_digits = 3"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>do_sql_command</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><literal type="string">"SET extra_float_digits = 2"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Convenience subroutine to issue a non-data-returning SQL command to remote
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>do_sql_command</name><parameter_list>(<parameter><decl><type><name>PGconn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>sql</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>PQsendQuery</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>sql</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>pgfdw_report_error</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>conn</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>sql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>pgfdw_get_result</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>sql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>PQresultStatus</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>PGRES_COMMAND_OK</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>pgfdw_report_error</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><name>res</name></expr></argument>, <argument><expr><name>conn</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>sql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Start remote transaction or subtransaction, if needed.
 *
 * Note that we always use at least REPEATABLE READ in the remote session.
 * This is so that, if a query initiates multiple scans of the same or
 * different foreign tables, we will get snapshot-consistent results from
 * those scans.  A disadvantage is that we can't provide sane emulation of
 * READ COMMITTED behavior --- it would be nice if we had some other way to
 * control which remote queries share a snapshot.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>begin_remote_xact</name><parameter_list>(<parameter><decl><type><name>ConnCacheEntry</name> <modifier>*</modifier></type><name>entry</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>curlevel</name> <init>= <expr><call><name>GetCurrentTransactionNestLevel</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/* Start main transaction if we haven't yet */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>entry</name><operator>-&gt;</operator><name>xact_depth</name></name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>sql</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG3</name></expr></argument>, <argument><expr><literal type="string">"starting remote transaction on connection %p"</literal></expr></argument>,
			 <argument><expr><name><name>entry</name><operator>-&gt;</operator><name>conn</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>IsolationIsSerializable</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>sql</name> <operator>=</operator> <literal type="string">"START TRANSACTION ISOLATION LEVEL SERIALIZABLE"</literal></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>sql</name> <operator>=</operator> <literal type="string">"START TRANSACTION ISOLATION LEVEL REPEATABLE READ"</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>
		<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>changing_xact_state</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>do_sql_command</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>conn</name></name></expr></argument>, <argument><expr><name>sql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>xact_depth</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>changing_xact_state</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * If we're in a subtransaction, stack up savepoints to match our level.
	 * This ensures we can rollback just the desired effects when a
	 * subtransaction aborts.
	 */</comment>
	<while>while <condition>(<expr><name><name>entry</name><operator>-&gt;</operator><name>xact_depth</name></name> <operator>&lt;</operator> <name>curlevel</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name></type>		<name><name>sql</name><index>[<expr><literal type="number">64</literal></expr>]</index></name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>sql</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>sql</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"SAVEPOINT s%d"</literal></expr></argument>, <argument><expr><name><name>entry</name><operator>-&gt;</operator><name>xact_depth</name></name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>changing_xact_state</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>do_sql_command</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>conn</name></name></expr></argument>, <argument><expr><name>sql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>xact_depth</name></name><operator>++</operator></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>changing_xact_state</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	</block_content>}</block></while>
</block_content>}</block></function>

<comment type="block">/*
 * Release connection reference count created by calling GetConnection.
 */</comment>
<function><type><name>void</name></type>
<name>ReleaseConnection</name><parameter_list>(<parameter><decl><type><name>PGconn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * Currently, we don't actually track connection references because all
	 * cleanup is managed on a transaction or subtransaction basis instead. So
	 * there's nothing to do here.
	 */</comment>
</block_content>}</block></function>

<comment type="block">/*
 * Assign a "unique" number for a cursor.
 *
 * These really only need to be unique per connection within a transaction.
 * For the moment we ignore the per-connection point and assign them across
 * all connections in the transaction, but we ask for the connection to be
 * supplied in case we want to refine that.
 *
 * Note that even if wraparound happens in a very long transaction, actual
 * collisions are highly improbable; just be sure to use %u not %d to print.
 */</comment>
<function><type><name>unsigned</name> <name>int</name></type>
<name>GetCursorNumber</name><parameter_list>(<parameter><decl><type><name>PGconn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><operator>++</operator><name>cursor_number</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Assign a "unique" number for a prepared statement.
 *
 * This works much like GetCursorNumber, except that we never reset the counter
 * within a session.  That's because we can't be 100% sure we've gotten rid
 * of all prepared statements on all connections, and it's not really worth
 * increasing the risk of prepared-statement name collisions by resetting.
 */</comment>
<function><type><name>unsigned</name> <name>int</name></type>
<name>GetPrepStmtNumber</name><parameter_list>(<parameter><decl><type><name>PGconn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><operator>++</operator><name>prep_stmt_number</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Submit a query and wait for the result.
 *
 * This function is interruptible by signals.
 *
 * Caller is responsible for the error handling on the result.
 */</comment>
<function><type><name>PGresult</name> <modifier>*</modifier></type>
<name>pgfdw_exec_query</name><parameter_list>(<parameter><decl><type><name>PGconn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>query</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * Submit a query.  Since we don't use non-blocking mode, this also can
	 * block.  But its risk is relatively small, so we ignore that for now.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>PQsendQuery</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>pgfdw_report_error</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>conn</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Wait for the result. */</comment>
	<return>return <expr><call><name>pgfdw_get_result</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Wait for the result from a prior asynchronous execution function call.
 *
 * This function offers quick responsiveness by checking for any interruptions.
 *
 * This function emulates PQexec()'s behavior of returning the last result
 * when there are many.
 *
 * Caller is responsible for the error handling on the result.
 */</comment>
<function><type><name>PGresult</name> <modifier>*</modifier></type>
<name>pgfdw_get_result</name><parameter_list>(<parameter><decl><type><name>PGconn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>query</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier><specifier>volatile</specifier></type> <name>last_res</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* In what follows, do not leak any PGresults on an error. */</comment>
	<expr_stmt><expr><call><name>PG_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<block>{<block_content>
		<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>

			<while>while <condition>(<expr><call><name>PQisBusy</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>int</name></type>			<name>wc</name></decl>;</decl_stmt>

				<comment type="block">/* Sleep until there's something to do */</comment>
				<expr_stmt><expr><name>wc</name> <operator>=</operator> <call><name>WaitLatchOrSocket</name><argument_list>(<argument><expr><name>MyLatch</name></expr></argument>,
									   <argument><expr><name>WL_LATCH_SET</name> <operator>|</operator> <name>WL_SOCKET_READABLE</name></expr></argument>,
									   <argument><expr><call><name>PQsocket</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr></argument>,
									   <argument><expr><operator>-</operator><literal type="number">1L</literal></expr></argument>, <argument><expr><name>PG_WAIT_EXTENSION</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>ResetLatch</name><argument_list>(<argument><expr><name>MyLatch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><call><name>CHECK_FOR_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/* Data available in socket? */</comment>
				<if_stmt><if>if <condition>(<expr><name>wc</name> <operator>&amp;</operator> <name>WL_SOCKET_READABLE</name></expr>)</condition>
				<block>{<block_content>
					<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>PQconsumeInput</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>pgfdw_report_error</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>conn</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></while>

			<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>PQgetResult</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>res</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
				<break>break;</break></block_content></block></if></if_stmt>			<comment type="block">/* query is complete */</comment>

			<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>last_res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>last_res</name> <operator>=</operator> <name>res</name></expr>;</expr_stmt>
		</block_content>}</block></for>
	</block_content>}</block>
	<expr_stmt><expr><call><name>PG_CATCH</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<block>{<block_content>
		<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>last_res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>PG_RE_THROW</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
	<expr_stmt><expr><call><name>PG_END_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>last_res</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Report an error we got from the remote server.
 *
 * elevel: error level to use (typically ERROR, but might be less)
 * res: PGresult containing the error
 * conn: connection we did the query on
 * clear: if true, PQclear the result (otherwise caller will handle it)
 * sql: NULL, or text of remote command we tried to execute
 *
 * Note: callers that choose not to throw ERROR for a remote error are
 * responsible for making sure that the associated ConnCacheEntry gets
 * marked with have_error = true.
 */</comment>
<function><type><name>void</name></type>
<name>pgfdw_report_error</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>elevel</name></decl></parameter>, <parameter><decl><type><name>PGresult</name> <modifier>*</modifier></type><name>res</name></decl></parameter>, <parameter><decl><type><name>PGconn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>,
				   <parameter><decl><type><name>bool</name></type> <name>clear</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>sql</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* If requested, PGresult must be released before leaving this function. */</comment>
	<expr_stmt><expr><call><name>PG_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>diag_sqlstate</name> <init>= <expr><call><name>PQresultErrorField</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>PG_DIAG_SQLSTATE</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>message_primary</name> <init>= <expr><call><name>PQresultErrorField</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>PG_DIAG_MESSAGE_PRIMARY</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>message_detail</name> <init>= <expr><call><name>PQresultErrorField</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>PG_DIAG_MESSAGE_DETAIL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>message_hint</name> <init>= <expr><call><name>PQresultErrorField</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>PG_DIAG_MESSAGE_HINT</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>message_context</name> <init>= <expr><call><name>PQresultErrorField</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>PG_DIAG_CONTEXT</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>sqlstate</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>diag_sqlstate</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>sqlstate</name> <operator>=</operator> <call><name>MAKE_SQLSTATE</name><argument_list>(<argument><expr><name><name>diag_sqlstate</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,
									 <argument><expr><name><name>diag_sqlstate</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>,
									 <argument><expr><name><name>diag_sqlstate</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>,
									 <argument><expr><name><name>diag_sqlstate</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></expr></argument>,
									 <argument><expr><name><name>diag_sqlstate</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>sqlstate</name> <operator>=</operator> <name>ERRCODE_CONNECTION_FAILURE</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<comment type="block">/*
		 * If we don't get a message from the PGresult, try the PGconn.  This
		 * is needed because for connection-level failures, PQexec may just
		 * return NULL, not a PGresult at all.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>message_primary</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>message_primary</name> <operator>=</operator> <call><name>pchomp</name><argument_list>(<argument><expr><call><name>PQerrorMessage</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>elevel</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>sqlstate</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <ternary><condition><expr><name>message_primary</name></expr> ?</condition><then> <expr><call><name>errmsg_internal</name><argument_list>(<argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name>message_primary</name></expr></argument>)</argument_list></call></expr> </then><else>:
				 <expr><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not obtain message string for remote error"</literal></expr></argument>)</argument_list></call></expr></else></ternary><operator>,</operator>
				 <ternary><condition><expr><name>message_detail</name></expr> ?</condition><then> <expr><call><name>errdetail_internal</name><argument_list>(<argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name>message_detail</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>,</operator>
				 <ternary><condition><expr><name>message_hint</name></expr> ?</condition><then> <expr><call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name>message_hint</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>,</operator>
				 <ternary><condition><expr><name>message_context</name></expr> ?</condition><then> <expr><call><name>errcontext</name><argument_list>(<argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name>message_context</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>,</operator>
				 <ternary><condition><expr><name>sql</name></expr> ?</condition><then> <expr><call><name>errcontext</name><argument_list>(<argument><expr><literal type="string">"remote SQL command: %s"</literal></expr></argument>, <argument><expr><name>sql</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
	<expr_stmt><expr><call><name>PG_CATCH</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>clear</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>PG_RE_THROW</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
	<expr_stmt><expr><call><name>PG_END_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>clear</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * pgfdw_xact_callback --- cleanup at main-transaction end.
 *
 * This runs just late enough that it must not enter user-defined code
 * locally.  (Entering such code on the remote side is fine.  Its remote
 * COMMIT TRANSACTION may run deferred triggers.)
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>pgfdw_xact_callback</name><parameter_list>(<parameter><decl><type><name>XactEvent</name></type> <name>event</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HASH_SEQ_STATUS</name></type> <name>scan</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ConnCacheEntry</name> <modifier>*</modifier></type><name>entry</name></decl>;</decl_stmt>

	<comment type="block">/* Quick exit if no connections were touched in this transaction. */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>xact_got_connection</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Scan all connection cache entries to find open remote transactions, and
	 * close them.
	 */</comment>
	<expr_stmt><expr><call><name>hash_seq_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>scan</name></expr></argument>, <argument><expr><name>ConnectionHash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<while>while <condition>(<expr><operator>(</operator><name>entry</name> <operator>=</operator> <operator>(</operator><name>ConnCacheEntry</name> <operator>*</operator><operator>)</operator> <call><name>hash_seq_search</name><argument_list>(<argument><expr><operator>&amp;</operator><name>scan</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>

		<comment type="block">/* Ignore cache entry if no open connection right now */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>entry</name><operator>-&gt;</operator><name>conn</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<comment type="block">/* If it has an open remote transaction, try to close it */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>entry</name><operator>-&gt;</operator><name>xact_depth</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>bool</name></type>		<name>abort_cleanup_failure</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG3</name></expr></argument>, <argument><expr><literal type="string">"closing remote transaction on connection %p"</literal></expr></argument>,
				 <argument><expr><name><name>entry</name><operator>-&gt;</operator><name>conn</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<switch>switch <condition>(<expr><name>event</name></expr>)</condition>
			<block>{<block_content>
				<case>case <expr><name>XACT_EVENT_PARALLEL_PRE_COMMIT</name></expr>:</case>
				<case>case <expr><name>XACT_EVENT_PRE_COMMIT</name></expr>:</case>

					<comment type="block">/*
					 * If abort cleanup previously failed for this connection,
					 * we can't issue any more commands against it.
					 */</comment>
					<expr_stmt><expr><call><name>pgfdw_reject_incomplete_xact_state_change</name><argument_list>(<argument><expr><name>entry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<comment type="block">/* Commit all remote transactions during pre-commit */</comment>
					<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>changing_xact_state</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>do_sql_command</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>conn</name></name></expr></argument>, <argument><expr><literal type="string">"COMMIT TRANSACTION"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>changing_xact_state</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

					<comment type="block">/*
					 * If there were any errors in subtransactions, and we
					 * made prepared statements, do a DEALLOCATE ALL to make
					 * sure we get rid of all prepared statements. This is
					 * annoying and not terribly bulletproof, but it's
					 * probably not worth trying harder.
					 *
					 * DEALLOCATE ALL only exists in 8.3 and later, so this
					 * constrains how old a server postgres_fdw can
					 * communicate with.  We intentionally ignore errors in
					 * the DEALLOCATE, so that we can hobble along to some
					 * extent with older servers (leaking prepared statements
					 * as we go; but we don't really support update operations
					 * pre-8.3 anyway).
					 */</comment>
					<if_stmt><if>if <condition>(<expr><name><name>entry</name><operator>-&gt;</operator><name>have_prep_stmt</name></name> <operator>&amp;&amp;</operator> <name><name>entry</name><operator>-&gt;</operator><name>have_error</name></name></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>PQexec</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>conn</name></name></expr></argument>, <argument><expr><literal type="string">"DEALLOCATE ALL"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block></if></if_stmt>
					<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>have_prep_stmt</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>have_error</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
					<break>break;</break>
				<case>case <expr><name>XACT_EVENT_PRE_PREPARE</name></expr>:</case>

					<comment type="block">/*
					 * We disallow any remote transactions, since it's not
					 * very reasonable to hold them open until the prepared
					 * transaction is committed.  For the moment, throw error
					 * unconditionally; later we might allow read-only cases.
					 * Note that the error will cause us to come right back
					 * here with event == XACT_EVENT_ABORT, so we'll clean up
					 * the connection state at that point.
					 */</comment>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot PREPARE a transaction that has operated on postgres_fdw foreign tables"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<break>break;</break>
				<case>case <expr><name>XACT_EVENT_PARALLEL_COMMIT</name></expr>:</case>
				<case>case <expr><name>XACT_EVENT_COMMIT</name></expr>:</case>
				<case>case <expr><name>XACT_EVENT_PREPARE</name></expr>:</case>
					<comment type="block">/* Pre-commit should have closed the open transaction */</comment>
					<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"missed cleaning up connection during pre-commit"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<break>break;</break>
				<case>case <expr><name>XACT_EVENT_PARALLEL_ABORT</name></expr>:</case>
				<case>case <expr><name>XACT_EVENT_ABORT</name></expr>:</case>

					<comment type="block">/*
					 * Don't try to clean up the connection if we're already
					 * in error recursion trouble.
					 */</comment>
					<if_stmt><if>if <condition>(<expr><call><name>in_error_recursion_trouble</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>changing_xact_state</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

					<comment type="block">/*
					 * If connection is already unsalvageable, don't touch it
					 * further.
					 */</comment>
					<if_stmt><if>if <condition>(<expr><name><name>entry</name><operator>-&gt;</operator><name>changing_xact_state</name></name></expr>)</condition><block type="pseudo"><block_content>
						<break>break;</break></block_content></block></if></if_stmt>

					<comment type="block">/*
					 * Mark this connection as in the process of changing
					 * transaction state.
					 */</comment>
					<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>changing_xact_state</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

					<comment type="block">/* Assume we might have lost track of prepared statements */</comment>
					<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>have_error</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

					<comment type="block">/*
					 * If a command has been submitted to the remote server by
					 * using an asynchronous execution function, the command
					 * might not have yet completed.  Check to see if a
					 * command is still being processed by the remote server,
					 * and if so, request cancellation of the command.
					 */</comment>
					<if_stmt><if>if <condition>(<expr><call><name>PQtransactionStatus</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>conn</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <name>PQTRANS_ACTIVE</name> <operator>&amp;&amp;</operator>
						<operator>!</operator><call><name>pgfdw_cancel_query</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>conn</name></name></expr></argument>)</argument_list></call></expr>)</condition>
					<block>{<block_content>
						<comment type="block">/* Unable to cancel running query. */</comment>
						<expr_stmt><expr><name>abort_cleanup_failure</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
					</block_content>}</block></if>
					<if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>pgfdw_exec_cleanup_query</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>conn</name></name></expr></argument>,
													   <argument><expr><literal type="string">"ABORT TRANSACTION"</literal></expr></argument>,
													   <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>)</condition>
					<block>{<block_content>
						<comment type="block">/* Unable to abort remote transaction. */</comment>
						<expr_stmt><expr><name>abort_cleanup_failure</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
					</block_content>}</block></if>
					<if type="elseif">else if <condition>(<expr><name><name>entry</name><operator>-&gt;</operator><name>have_prep_stmt</name></name> <operator>&amp;&amp;</operator> <name><name>entry</name><operator>-&gt;</operator><name>have_error</name></name> <operator>&amp;&amp;</operator>
							 <operator>!</operator><call><name>pgfdw_exec_cleanup_query</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>conn</name></name></expr></argument>,
													   <argument><expr><literal type="string">"DEALLOCATE ALL"</literal></expr></argument>,
													   <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>)</condition>
					<block>{<block_content>
						<comment type="block">/* Trouble clearing prepared statements. */</comment>
						<expr_stmt><expr><name>abort_cleanup_failure</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
					</block_content>}</block></if>
					<else>else
					<block>{<block_content>
						<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>have_prep_stmt</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
						<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>have_error</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
					</block_content>}</block></else></if_stmt>

					<comment type="block">/* Disarm changing_xact_state if it all worked. */</comment>
					<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>changing_xact_state</name></name> <operator>=</operator> <name>abort_cleanup_failure</name></expr>;</expr_stmt>
					<break>break;</break>
			</block_content>}</block></switch>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* Reset state to show we're out of a transaction */</comment>
		<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>xact_depth</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

		<comment type="block">/*
		 * If the connection isn't in a good idle state, discard it to
		 * recover. Next GetConnection will open a new connection.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>PQstatus</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>conn</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>CONNECTION_OK</name> <operator>||</operator>
			<call><name>PQtransactionStatus</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>conn</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>PQTRANS_IDLE</name> <operator>||</operator>
			<name><name>entry</name><operator>-&gt;</operator><name>changing_xact_state</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG3</name></expr></argument>, <argument><expr><literal type="string">"discarding connection %p"</literal></expr></argument>, <argument><expr><name><name>entry</name><operator>-&gt;</operator><name>conn</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>disconnect_pg_server</name><argument_list>(<argument><expr><name>entry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></while>

	<comment type="block">/*
	 * Regardless of the event type, we can now mark ourselves as out of the
	 * transaction.  (Note: if we are here during PRE_COMMIT or PRE_PREPARE,
	 * this saves a useless scan of the hashtable during COMMIT or PREPARE.)
	 */</comment>
	<expr_stmt><expr><name>xact_got_connection</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<comment type="block">/* Also reset cursor numbering for next transaction */</comment>
	<expr_stmt><expr><name>cursor_number</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * pgfdw_subxact_callback --- cleanup at subtransaction end.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>pgfdw_subxact_callback</name><parameter_list>(<parameter><decl><type><name>SubXactEvent</name></type> <name>event</name></decl></parameter>, <parameter><decl><type><name>SubTransactionId</name></type> <name>mySubid</name></decl></parameter>,
					   <parameter><decl><type><name>SubTransactionId</name></type> <name>parentSubid</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HASH_SEQ_STATUS</name></type> <name>scan</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ConnCacheEntry</name> <modifier>*</modifier></type><name>entry</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>curlevel</name></decl>;</decl_stmt>

	<comment type="block">/* Nothing to do at subxact start, nor after commit. */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>event</name> <operator>==</operator> <name>SUBXACT_EVENT_PRE_COMMIT_SUB</name> <operator>||</operator>
		  <name>event</name> <operator>==</operator> <name>SUBXACT_EVENT_ABORT_SUB</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/* Quick exit if no connections were touched in this transaction. */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>xact_got_connection</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Scan all connection cache entries to find open remote subtransactions
	 * of the current level, and close them.
	 */</comment>
	<expr_stmt><expr><name>curlevel</name> <operator>=</operator> <call><name>GetCurrentTransactionNestLevel</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>hash_seq_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>scan</name></expr></argument>, <argument><expr><name>ConnectionHash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<while>while <condition>(<expr><operator>(</operator><name>entry</name> <operator>=</operator> <operator>(</operator><name>ConnCacheEntry</name> <operator>*</operator><operator>)</operator> <call><name>hash_seq_search</name><argument_list>(<argument><expr><operator>&amp;</operator><name>scan</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name></type>		<name><name>sql</name><index>[<expr><literal type="number">100</literal></expr>]</index></name></decl>;</decl_stmt>

		<comment type="block">/*
		 * We only care about connections with open remote subtransactions of
		 * the current level.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>entry</name><operator>-&gt;</operator><name>conn</name></name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name><name>entry</name><operator>-&gt;</operator><name>xact_depth</name></name> <operator>&lt;</operator> <name>curlevel</name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>entry</name><operator>-&gt;</operator><name>xact_depth</name></name> <operator>&gt;</operator> <name>curlevel</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"missed cleaning up remote subtransaction at level %d"</literal></expr></argument>,
				 <argument><expr><name><name>entry</name><operator>-&gt;</operator><name>xact_depth</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>event</name> <operator>==</operator> <name>SUBXACT_EVENT_PRE_COMMIT_SUB</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * If abort cleanup previously failed for this connection, we
			 * can't issue any more commands against it.
			 */</comment>
			<expr_stmt><expr><call><name>pgfdw_reject_incomplete_xact_state_change</name><argument_list>(<argument><expr><name>entry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* Commit all remote subtransactions during pre-commit */</comment>
			<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>sql</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>sql</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"RELEASE SAVEPOINT s%d"</literal></expr></argument>, <argument><expr><name>curlevel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>changing_xact_state</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>do_sql_command</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>conn</name></name></expr></argument>, <argument><expr><name>sql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>changing_xact_state</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><call><name>in_error_recursion_trouble</name><argument_list>()</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * Don't try to clean up the connection if we're already in error
			 * recursion trouble.
			 */</comment>
			<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>changing_xact_state</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><operator>!</operator><name><name>entry</name><operator>-&gt;</operator><name>changing_xact_state</name></name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>bool</name></type>		<name>abort_cleanup_failure</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

			<comment type="block">/* Remember that abort cleanup is in progress. */</comment>
			<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>changing_xact_state</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

			<comment type="block">/* Assume we might have lost track of prepared statements */</comment>
			<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>have_error</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

			<comment type="block">/*
			 * If a command has been submitted to the remote server by using
			 * an asynchronous execution function, the command might not have
			 * yet completed.  Check to see if a command is still being
			 * processed by the remote server, and if so, request cancellation
			 * of the command.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>PQtransactionStatus</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>conn</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <name>PQTRANS_ACTIVE</name> <operator>&amp;&amp;</operator>
				<operator>!</operator><call><name>pgfdw_cancel_query</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>conn</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>abort_cleanup_failure</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if>
			<else>else
			<block>{<block_content>
				<comment type="block">/* Rollback all remote subtransactions during abort */</comment>
				<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>sql</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>sql</name></expr></argument>)</argument_list></sizeof></expr></argument>,
						 <argument><expr><literal type="string">"ROLLBACK TO SAVEPOINT s%d; RELEASE SAVEPOINT s%d"</literal></expr></argument>,
						 <argument><expr><name>curlevel</name></expr></argument>, <argument><expr><name>curlevel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>pgfdw_exec_cleanup_query</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>conn</name></name></expr></argument>, <argument><expr><name>sql</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>abort_cleanup_failure</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block></else></if_stmt>

			<comment type="block">/* Disarm changing_xact_state if it all worked. */</comment>
			<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>changing_xact_state</name></name> <operator>=</operator> <name>abort_cleanup_failure</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* OK, we're outta that level of subtransaction */</comment>
		<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>xact_depth</name></name><operator>--</operator></expr>;</expr_stmt>
	</block_content>}</block></while>
</block_content>}</block></function>

<comment type="block">/*
 * Connection invalidation callback function
 *
 * After a change to a pg_foreign_server or pg_user_mapping catalog entry,
 * mark connections depending on that entry as needing to be remade.
 * We can't immediately destroy them, since they might be in the midst of
 * a transaction, but we'll remake them at the next opportunity.
 *
 * Although most cache invalidation callbacks blow away all the related stuff
 * regardless of the given hashvalue, connections are expensive enough that
 * it's worth trying to avoid that.
 *
 * NB: We could avoid unnecessary disconnection more strictly by examining
 * individual option values, but it seems too much effort for the gain.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>pgfdw_inval_callback</name><parameter_list>(<parameter><decl><type><name>Datum</name></type> <name>arg</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>cacheid</name></decl></parameter>, <parameter><decl><type><name>uint32</name></type> <name>hashvalue</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HASH_SEQ_STATUS</name></type> <name>scan</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ConnCacheEntry</name> <modifier>*</modifier></type><name>entry</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>cacheid</name> <operator>==</operator> <name>FOREIGNSERVEROID</name> <operator>||</operator> <name>cacheid</name> <operator>==</operator> <name>USERMAPPINGOID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* ConnectionHash must exist already, if we're registered */</comment>
	<expr_stmt><expr><call><name>hash_seq_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>scan</name></expr></argument>, <argument><expr><name>ConnectionHash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<while>while <condition>(<expr><operator>(</operator><name>entry</name> <operator>=</operator> <operator>(</operator><name>ConnCacheEntry</name> <operator>*</operator><operator>)</operator> <call><name>hash_seq_search</name><argument_list>(<argument><expr><operator>&amp;</operator><name>scan</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Ignore invalid entries */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>entry</name><operator>-&gt;</operator><name>conn</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<comment type="block">/* hashvalue == 0 means a cache reset, must clear all state */</comment>
		<if_stmt><if>if <condition>(<expr><name>hashvalue</name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
			<operator>(</operator><name>cacheid</name> <operator>==</operator> <name>FOREIGNSERVEROID</name> <operator>&amp;&amp;</operator>
			 <name><name>entry</name><operator>-&gt;</operator><name>server_hashvalue</name></name> <operator>==</operator> <name>hashvalue</name><operator>)</operator> <operator>||</operator>
			<operator>(</operator><name>cacheid</name> <operator>==</operator> <name>USERMAPPINGOID</name> <operator>&amp;&amp;</operator>
			 <name><name>entry</name><operator>-&gt;</operator><name>mapping_hashvalue</name></name> <operator>==</operator> <name>hashvalue</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>invalidated</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></while>
</block_content>}</block></function>

<comment type="block">/*
 * Raise an error if the given connection cache entry is marked as being
 * in the middle of an xact state change.  This should be called at which no
 * such change is expected to be in progress; if one is found to be in
 * progress, it means that we aborted in the middle of a previous state change
 * and now don't know what the remote transaction state actually is.
 * Such connections can't safely be further used.  Re-establishing the
 * connection would change the snapshot and roll back any writes already
 * performed, so that's not an option, either. Thus, we must abort.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>pgfdw_reject_incomplete_xact_state_change</name><parameter_list>(<parameter><decl><type><name>ConnCacheEntry</name> <modifier>*</modifier></type><name>entry</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tup</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Form_pg_user_mapping</name></type> <name>umform</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ForeignServer</name> <modifier>*</modifier></type><name>server</name></decl>;</decl_stmt>

	<comment type="block">/* nothing to do for inactive entries and entries of sane state */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>entry</name><operator>-&gt;</operator><name>conn</name></name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <operator>!</operator><name><name>entry</name><operator>-&gt;</operator><name>changing_xact_state</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/* make sure this entry is inactive */</comment>
	<expr_stmt><expr><call><name>disconnect_pg_server</name><argument_list>(<argument><expr><name>entry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* find server name to be shown in the message below */</comment>
	<expr_stmt><expr><name>tup</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>USERMAPPINGOID</name></expr></argument>,
						  <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>key</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tup</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for user mapping %u"</literal></expr></argument>, <argument><expr><name><name>entry</name><operator>-&gt;</operator><name>key</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>umform</name> <operator>=</operator> <operator>(</operator><name>Form_pg_user_mapping</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>server</name> <operator>=</operator> <call><name>GetForeignServer</name><argument_list>(<argument><expr><name><name>umform</name><operator>-&gt;</operator><name>umserver</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
			<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_CONNECTION_EXCEPTION</name></expr></argument>)</argument_list></call><operator>,</operator>
			 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"connection to server \"%s\" was lost"</literal></expr></argument>,
					<argument><expr><name><name>server</name><operator>-&gt;</operator><name>servername</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Cancel the currently-in-progress query (whose query text we do not have)
 * and ignore the result.  Returns true if we successfully cancel the query
 * and discard any pending result, and false if not.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>pgfdw_cancel_query</name><parameter_list>(<parameter><decl><type><name>PGconn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PGcancel</name>   <modifier>*</modifier></type><name>cancel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>errbuf</name><index>[<expr><literal type="number">256</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier></type><name>result</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TimestampTz</name></type> <name>endtime</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * If it takes too long to cancel the query and discard the result, assume
	 * the connection is dead.
	 */</comment>
	<expr_stmt><expr><name>endtime</name> <operator>=</operator> <call><name>TimestampTzPlusMilliseconds</name><argument_list>(<argument><expr><call><name>GetCurrentTimestamp</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><literal type="number">30000</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Issue cancel request.  Unfortunately, there's no good way to limit the
	 * amount of time that we might block inside PQgetCancel().
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>cancel</name> <operator>=</operator> <call><name>PQgetCancel</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>PQcancel</name><argument_list>(<argument><expr><name>cancel</name></expr></argument>, <argument><expr><name>errbuf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>errbuf</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_CONNECTION_FAILURE</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not send cancel request: %s"</literal></expr></argument>,
							<argument><expr><name>errbuf</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>PQfreeCancel</name><argument_list>(<argument><expr><name>cancel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>false</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><call><name>PQfreeCancel</name><argument_list>(<argument><expr><name>cancel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Get and discard the result of the query. */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>pgfdw_get_cleanup_result</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>endtime</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>result</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
	<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Submit a query during (sub)abort cleanup and wait up to 30 seconds for the
 * result.  If the query is executed without error, the return value is true.
 * If the query is executed successfully but returns an error, the return
 * value is true if and only if ignore_errors is set.  If the query can't be
 * sent or times out, the return value is false.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>pgfdw_exec_cleanup_query</name><parameter_list>(<parameter><decl><type><name>PGconn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>query</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>ignore_errors</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier></type><name>result</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TimestampTz</name></type> <name>endtime</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * If it takes too long to execute a cleanup query, assume the connection
	 * is dead.  It's fairly likely that this is why we aborted in the first
	 * place (e.g. statement timeout, user cancel), so the timeout shouldn't
	 * be too long.
	 */</comment>
	<expr_stmt><expr><name>endtime</name> <operator>=</operator> <call><name>TimestampTzPlusMilliseconds</name><argument_list>(<argument><expr><call><name>GetCurrentTimestamp</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><literal type="number">30000</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Submit a query.  Since we don't use non-blocking mode, this also can
	 * block.  But its risk is relatively small, so we ignore that for now.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>PQsendQuery</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>pgfdw_report_error</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>conn</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Get the result of the query. */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>pgfdw_get_cleanup_result</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>endtime</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>result</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* Issue a warning if not successful. */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>PQresultStatus</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>PGRES_COMMAND_OK</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>pgfdw_report_error</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>, <argument><expr><name>result</name></expr></argument>, <argument><expr><name>conn</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>ignore_errors</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Get, during abort cleanup, the result of a query that is in progress.  This
 * might be a query that is being interrupted by transaction abort, or it might
 * be a query that was initiated as part of transaction abort to get the remote
 * side back to the appropriate state.
 *
 * It's not a huge problem if we throw an ERROR here, but if we get into error
 * recursion trouble, we'll end up slamming the connection shut, which will
 * necessitate failing the entire toplevel transaction even if subtransactions
 * were used.  Try to use WARNING where we can.
 *
 * endtime is the time at which we should give up and assume the remote
 * side is dead.  Returns true if the timeout expired, otherwise false.
 * Sets *result except in case of a timeout.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>pgfdw_get_cleanup_result</name><parameter_list>(<parameter><decl><type><name>PGconn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>, <parameter><decl><type><name>TimestampTz</name></type> <name>endtime</name></decl></parameter>, <parameter><decl><type><name>PGresult</name> <modifier>*</modifier><modifier>*</modifier></type><name>result</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>volatile</specifier> <name>bool</name></type> <name>timed_out</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier><specifier>volatile</specifier></type> <name>last_res</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* In what follows, do not leak any PGresults on an error. */</comment>
	<expr_stmt><expr><call><name>PG_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<block>{<block_content>
		<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>

			<while>while <condition>(<expr><call><name>PQisBusy</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>int</name></type>			<name>wc</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>TimestampTz</name></type> <name>now</name> <init>= <expr><call><name>GetCurrentTimestamp</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>long</name></type>		<name>secs</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>int</name></type>			<name>microsecs</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>long</name></type>		<name>cur_timeout</name></decl>;</decl_stmt>

				<comment type="block">/* If timeout has expired, give up, else get sleep time. */</comment>
				<if_stmt><if>if <condition>(<expr><name>now</name> <operator>&gt;=</operator> <name>endtime</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name>timed_out</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
					<goto>goto <name>exit</name>;</goto>
				</block_content>}</block></if></if_stmt>
				<expr_stmt><expr><call><name>TimestampDifference</name><argument_list>(<argument><expr><name>now</name></expr></argument>, <argument><expr><name>endtime</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>secs</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>microsecs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/* To protect against clock skew, limit sleep to one minute. */</comment>
				<expr_stmt><expr><name>cur_timeout</name> <operator>=</operator> <call><name>Min</name><argument_list>(<argument><expr><literal type="number">60000</literal></expr></argument>, <argument><expr><name>secs</name> <operator>*</operator> <name>USECS_PER_SEC</name> <operator>+</operator> <name>microsecs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/* Sleep until there's something to do */</comment>
				<expr_stmt><expr><name>wc</name> <operator>=</operator> <call><name>WaitLatchOrSocket</name><argument_list>(<argument><expr><name>MyLatch</name></expr></argument>,
									   <argument><expr><name>WL_LATCH_SET</name> <operator>|</operator> <name>WL_SOCKET_READABLE</name> <operator>|</operator> <name>WL_TIMEOUT</name></expr></argument>,
									   <argument><expr><call><name>PQsocket</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr></argument>,
									   <argument><expr><name>cur_timeout</name></expr></argument>, <argument><expr><name>PG_WAIT_EXTENSION</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>ResetLatch</name><argument_list>(<argument><expr><name>MyLatch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><call><name>CHECK_FOR_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/* Data available in socket? */</comment>
				<if_stmt><if>if <condition>(<expr><name>wc</name> <operator>&amp;</operator> <name>WL_SOCKET_READABLE</name></expr>)</condition>
				<block>{<block_content>
					<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>PQconsumeInput</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>)</condition>
					<block>{<block_content>
						<comment type="block">/* connection trouble; treat the same as a timeout */</comment>
						<expr_stmt><expr><name>timed_out</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
						<goto>goto <name>exit</name>;</goto>
					</block_content>}</block></if></if_stmt>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></while>

			<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>PQgetResult</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>res</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
				<break>break;</break></block_content></block></if></if_stmt>			<comment type="block">/* query is complete */</comment>

			<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>last_res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>last_res</name> <operator>=</operator> <name>res</name></expr>;</expr_stmt>
		</block_content>}</block></for>
<label><name>exit</name>:</label>	<empty_stmt>;</empty_stmt>
	</block_content>}</block>
	<expr_stmt><expr><call><name>PG_CATCH</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<block>{<block_content>
		<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>last_res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>PG_RE_THROW</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
	<expr_stmt><expr><call><name>PG_END_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>timed_out</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>last_res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><operator>*</operator><name>result</name> <operator>=</operator> <name>last_res</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
	<return>return <expr><name>timed_out</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 *  POLAR: Forbidden to connect to other instances
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>polar_conn_opt_parse</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>keyword</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>value</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>freeptr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> 	<name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>	<name><name>tmp_port_str</name><index>[<expr><name>NI_MAXSERV</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> 	<name>has_port</name> <init>= <expr><name>false</name></expr></init></decl>, <decl><type ref="prev"/><name>has_host</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><operator>*</operator><name>freeptr</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name><name>keyword</name><index>[<expr><name>i</name></expr>]</index></name> <operator>!=</operator> <name>NULL</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>kw</name> <init>= <expr><name><name>keyword</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>val</name> <init>= <expr><name><name>value</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>val</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>pg_strcasecmp</name><argument_list>(<argument><expr><name>kw</name></expr></argument>, <argument><expr><literal type="string">"port"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>polar_connection_check</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"only connections to self instance are supported, please do not specify the port parameter"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<expr_stmt><expr><name>has_port</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><call><name>pg_strcasecmp</name><argument_list>(<argument><expr><name>kw</name></expr></argument>, <argument><expr><literal type="string">"host"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <call><name>pg_strcasecmp</name><argument_list>(<argument><expr><name>kw</name></expr></argument>, <argument><expr><literal type="string">"hostaddr"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>polar_connection_check</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"only connections to self instance are supported, please do not specify the host or hostaddr parameters"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			
			<expr_stmt><expr><name>has_host</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>

	<if_stmt><if>if <condition>(<expr><name>polar_auto_port_mapping</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>has_port</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>has_host</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>tmp_port_str</name></expr></argument>, <argument><expr><name>NI_MAXSERV</name></expr></argument>, <argument><expr><literal type="string">"%d"</literal></expr></argument>, <argument><expr><name>PostPortNumber</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>keyword</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <literal type="string">"port"</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>value</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <operator>*</operator><name>freeptr</name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><name>tmp_port_str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>keyword</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <literal type="string">"host"</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>value</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <literal type="string">"127.0.0.1"</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>keyword</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>value</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return;</return>
</block_content>}</block></function></unit>
