<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/PolarDB-for-PostgreSQL/external/polar_monitor_preload/polar_monitor_backend.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * polar_monitor_backend.c
 *    views of polardb monitor statistics by backend type.
 *
 * Copyright (c) 2021, Alibaba Group Holding Limited
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * IDENTIFICATION
 *    external/polar_monitor/polar_monitor_backend.c
 *-------------------------------------------------------------------------
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_type.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"funcapi.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"libpq/polar_network_stats.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"polar_monitor_backend.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"polar_procstat.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postmaster/bgworker.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/lwlock.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/backendid.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/ipc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/polar_lock_stats.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/polar_io_stat.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/sinvaladt.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"tcop/utility.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/builtins.h"</cpp:file></cpp:include>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BACKEND_TYPE_MAXLEN</name></cpp:macro>		<cpp:value>96</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BACKEND_MAX_NUMBER</name></cpp:macro>      <cpp:value>(1024)</cpp:value></cpp:define>

<typedef>typedef <type><enum>enum <name>STAT_COL_DEF</name>
<block>{
	<decl><name>COL_BACKEND_TYPE</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>,
	<decl><name>COL_CPU_USER</name></decl>,
	<decl><name>COL_CPU_SYS</name></decl>,
	<decl><name>COL_RSS</name></decl>,
	<decl><name>COL_SHARED_READ_PS</name></decl>,
	<decl><name>COL_SHARED_WRITE_PS</name></decl>,
	<decl><name>COL_SHARED_READ_THROUGHPUT</name></decl>,
	<decl><name>COL_SHARED_WRITE_THROUGHPUT</name></decl>,
	<decl><name>COL_SHARED_READ_LATENCY</name></decl>,
	<decl><name>COL_SHARED_WRITE_LATENCY</name></decl>,
	<decl><name>COL_LOCAL_READ_PS</name></decl>,
	<decl><name>COL_LOCAL_WRITE_PS</name></decl>,
	<decl><name>COL_LOCAL_READ_THROUGHPUT</name></decl>,
	<decl><name>COL_LOCAL_WRITE_THROUGHPUT</name></decl>,
	<decl><name>COL_LOCAL_READ_LATENCY</name></decl>,
	<decl><name>COL_LOCAL_WRITE_LATENCY</name></decl>,
	<decl><name>COL_SEND_COUNT</name></decl>,
	<decl><name>COL_SEND_BYTES</name></decl>,
	<decl><name>COL_RECV_COUNT</name></decl>,
	<decl><name>COL_RECV_BYTES</name></decl>,
	<decl><name>COL_POLAR_STAT_BACKEND</name></decl>
}</block></enum></type> <name>STAT_COL_DEF</name>;</typedef>


<typedef>typedef <type><struct>struct <name>polarBackendHashKey</name>
<block>{
    <decl_stmt><decl><type><name>char</name></type>  <name><name>backend_type</name><index>[<expr><name>BACKEND_TYPE_MAXLEN</name></expr>]</index></name></decl>;</decl_stmt>
}</block></struct></type><name>polarBackendHashKey</name>;</typedef>

<typedef>typedef <type><struct>struct <name>pgBackendCounters</name>
<block>{
	<decl_stmt><decl><type><name>char</name></type>  	<name><name>backend_type</name><index>[<expr><name>BACKEND_TYPE_MAXLEN</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int64</name></type>	<name>cpu_user</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int64</name></type>	<name>cpu_sys</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int64</name></type> 	<name>rss</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int64</name></type>	<name>shared_read_ps</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int64</name></type>	<name>shared_write_ps</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int64</name></type>	<name>shared_read_throughput</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int64</name></type>	<name>shared_write_throughput</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type>	<name>shared_read_latency</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type> 	<name>shared_write_latency</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int64</name></type>	<name>local_read_ps</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int64</name></type>	<name>local_write_ps</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int64</name></type>	<name>local_read_throughput</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int64</name></type>	<name>local_write_throughput</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type>	<name>local_read_latency</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type> 	<name>local_write_latency</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int64</name></type>	<name>send_count</name></decl>;</decl_stmt>	
	<decl_stmt><decl><type><name>int64</name></type>	<name>send_bytes</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int64</name></type>	<name>recv_count</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int64</name></type>	<name>recv_bytes</name></decl>;</decl_stmt>
}</block></struct></type> <name>pgBackendCounters</name>;</typedef>

<typedef>typedef <type><struct>struct <name>polarBackendEntry</name>
<block>{
	<decl_stmt><decl><type><name>polarBackendHashKey</name></type> <name>key</name></decl>;</decl_stmt>	<comment type="block">/* hash key of entry - MUST BE FIRST */</comment>
	<decl_stmt><decl><type><name>pgBackendCounters</name></type>	<name>counters</name></decl>;</decl_stmt>		<comment type="block">/* the statistics for this query */</comment>
	<decl_stmt><decl><type><name>Size</name></type>		<name>query_offset</name></decl>;</decl_stmt>	<comment type="block">/* query text offset in external file */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>query_len</name></decl>;</decl_stmt>		<comment type="block">/* # of valid bytes in query string, or -1 */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>encoding</name></decl>;</decl_stmt>		<comment type="block">/* query text encoding */</comment>
	<decl_stmt><decl><type><name>slock_t</name></type>		<name>mutex</name></decl>;</decl_stmt>			<comment type="block">/* protects the counters only */</comment>
}</block></struct></type> <name>polarBackendEntry</name>;</typedef>

<typedef>typedef <type><struct>struct
<block>{
	<decl_stmt><decl><type><name>LWLock</name>	   <modifier>*</modifier></type><name>lock</name></decl>;</decl_stmt>					<comment type="block">/* protects hashtable search/modification */</comment>
}</block></struct></type> <name>polarBacktypeSharedState</name>;</typedef>


<decl_stmt><decl><type><specifier>static</specifier> <name>polarBacktypeSharedState</name> <modifier>*</modifier></type><name>polar_monitor_backtype_share_state</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>HTAB</name> <modifier>*</modifier></type><name>polar_monitor_backend_hash</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type>	<name>polar_hash_entry_max</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>polar_monitor_backend_entry_store</name><parameter_list>(<parameter><decl><type><name>HTAB</name> <modifier>*</modifier></type><name>tmp_backend_htab</name></decl></parameter>, <parameter><decl><type><name>pgBackendCounters</name></type> <name>counters</name></decl></parameter>, <parameter><decl><type><name>LWLock</name> <modifier>*</modifier></type><name>lock</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>polar_backend_collect_stat</name><parameter_list>(<parameter><decl><type><name>pgBackendCounters</name> <modifier>*</modifier></type><name>counters</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>backendid</name></decl></parameter>)</parameter_list>;</function_decl>
<comment type="block">/*
 * POLAR: return the cpu stat info ever backend
 */</comment>
<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>polar_stat_backend</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><name>Datum</name></type>
<name>polar_stat_backend</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ReturnSetInfo</name>	<modifier>*</modifier></type><name>rsinfo</name> <init>= <expr><operator>(</operator><name>ReturnSetInfo</name> <operator>*</operator><operator>)</operator> <name><name>fcinfo</name><operator>-&gt;</operator><name>resultinfo</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type>	<name>per_query_ctx</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type>	<name>oldcontext</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleDesc</name></type>		<name>tupdesc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Tuplestorestate</name>	<modifier>*</modifier></type><name>tupstore</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HASH_SEQ_STATUS</name></type> <name>hash_seq</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>polarBackendEntry</name>		<modifier>*</modifier></type><name>entry</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>num_backends</name> <init>= <expr><call><name>pgstat_fetch_stat_numbackends</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>	<name>curr_backend</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HTAB</name>	   <modifier>*</modifier></type><name>tmp_backend_htab</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HASHCTL</name></type>		<name>tmp_backend_hash_ctl</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HASH_SEQ_STATUS</name></type> <name>tmp_hash_seq</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>polar_monitor_backend_hash</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"polar monitor must be loaded via shared_preload_libraries"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<comment type="block">/* check to see if caller supports us returning a tuplestore */</comment>
	<if_stmt><if>if <condition>(<expr><name>rsinfo</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name>rsinfo</name></expr></argument>, <argument><expr><name>ReturnSetInfo</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"set-valued function called in context that cannot accept a set"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name><name>rsinfo</name><operator>-&gt;</operator><name>allowedModes</name></name> <operator>&amp;</operator> <name>SFRM_Materialize</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"materialize mode required, but it is not "</literal> \
							<literal type="string">"allowed in this context"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Switch into long-lived context to construct returned data structures */</comment>
	<expr_stmt><expr><name>per_query_ctx</name> <operator>=</operator> <name><name>rsinfo</name><operator>-&gt;</operator><name>econtext</name><operator>-&gt;</operator><name>ecxt_per_query_memory</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>oldcontext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>per_query_ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Build a tuple descriptor for our result type */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>get_call_result_type</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tupdesc</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>TYPEFUNC_COMPOSITE</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"return type must be a row type"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>tupstore</name> <operator>=</operator> <call><name>tuplestore_begin_heap</name><argument_list>(<argument><expr><name>true</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>work_mem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rsinfo</name><operator>-&gt;</operator><name>returnMode</name></name> <operator>=</operator> <name>SFRM_Materialize</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rsinfo</name><operator>-&gt;</operator><name>setResult</name></name> <operator>=</operator> <name>tupstore</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rsinfo</name><operator>-&gt;</operator><name>setDesc</name></name> <operator>=</operator> <name>tupdesc</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tmp_backend_hash_ctl</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>tmp_backend_hash_ctl</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>tmp_backend_hash_ctl</name><operator>.</operator><name>keysize</name></name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>polarBackendHashKey</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>tmp_backend_hash_ctl</name><operator>.</operator><name>entrysize</name></name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>polarBackendEntry</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
	<expr_stmt><expr><name>tmp_backend_htab</name> <operator>=</operator> <call><name>hash_create</name><argument_list>(<argument><expr><literal type="string">"Temporary table of all backend info"</literal></expr></argument>,
					   <argument><expr><name>BACKEND_MAX_NUMBER</name></expr></argument>,
					   <argument><expr><operator>&amp;</operator><name>tmp_backend_hash_ctl</name></expr></argument>,
					   <argument><expr><name>HASH_ELEM</name> <operator>|</operator> <name>HASH_BLOBS</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* check create hash table */</comment>
	<if_stmt><if>if<condition>(<expr><operator>!</operator><name>tmp_backend_htab</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"create hash table fail "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt><empty_stmt>;</empty_stmt>

	<comment type="block">/* copy the history backend statistics info the temp hash table */</comment>
	<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name><name>polar_monitor_backtype_share_state</name><operator>-&gt;</operator><name>lock</name></name></expr></argument>, <argument><expr><name>LW_SHARED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>hash_seq_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>hash_seq</name></expr></argument>, <argument><expr><name>polar_monitor_backend_hash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<while>while <condition>(<expr><operator>(</operator><name>entry</name> <operator>=</operator> <call><name>hash_seq_search</name><argument_list>(<argument><expr><operator>&amp;</operator><name>hash_seq</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>pgBackendCounters</name></type>	<name>tmp</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><specifier>volatile</specifier> <name>polarBackendEntry</name> <modifier>*</modifier></type><name>e</name> <init>= <expr><operator>(</operator><specifier>volatile</specifier> <name>polarBackendEntry</name> <operator>*</operator><operator>)</operator> <name>entry</name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tmp</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>SpinLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>e</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>tmp</name> <operator>=</operator> <name><name>e</name><operator>-&gt;</operator><name>counters</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>SpinLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>e</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		
		<expr_stmt><expr><call><name>polar_monitor_backend_entry_store</name><argument_list>(<argument><expr><name>tmp_backend_htab</name></expr></argument>, <argument><expr><name>tmp</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	
	</block_content>}</block></while>
	<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name><name>polar_monitor_backtype_share_state</name><operator>-&gt;</operator><name>lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* add active backend statistics to the temp hash table*/</comment>
	<for>for <control>(<init><expr><name>curr_backend</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>curr_backend</name> <operator>&lt;=</operator> <name>num_backends</name></expr>;</condition> <incr><expr><name>curr_backend</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>pgBackendCounters</name></type>	<name>counters</name></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>counters</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>counters</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* collect backend statistics */</comment>
		<if_stmt><if>if <condition>(<expr><literal type="number">0</literal> <operator>!=</operator> <call><name>polar_backend_collect_stat</name><argument_list>(<argument><expr><operator>&amp;</operator><name>counters</name></expr></argument>, <argument><expr><name>curr_backend</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>
		
		<expr_stmt><expr><call><name>polar_monitor_backend_entry_store</name><argument_list>(<argument><expr><name>tmp_backend_htab</name></expr></argument>, <argument><expr><name>counters</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>
	
	<comment type="block">/* get all the backend statistics by search the temp hash table */</comment>
	<expr_stmt><expr><call><name>hash_seq_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tmp_hash_seq</name></expr></argument>, <argument><expr><name>tmp_backend_htab</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<while>while <condition>(<expr><operator>(</operator><name>entry</name> <operator>=</operator> <call><name>hash_seq_search</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tmp_hash_seq</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Datum</name></type>			<name><name>values</name><index>[<expr><name>COL_POLAR_STAT_BACKEND</name></expr>]</index></name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>			<name><name>nulls</name><index>[<expr><name>COL_POLAR_STAT_BACKEND</name></expr>]</index></name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>pgBackendCounters</name></type>	<name>tmp</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><specifier>volatile</specifier> <name>polarBackendEntry</name> <modifier>*</modifier></type><name>e</name> <init>= <expr><operator>(</operator><specifier>volatile</specifier> <name>polarBackendEntry</name> <operator>*</operator><operator>)</operator> <name>entry</name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>values</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>values</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>nulls</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>nulls</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>tmp</name> <operator>=</operator> <name><name>e</name><operator>-&gt;</operator><name>counters</name></name></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>values</name><index>[<expr><name>COL_BACKEND_TYPE</name></expr>]</index></name> <operator>=</operator> <call><name>CStringGetTextDatum</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>key</name><operator>.</operator><name>backend_type</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>values</name><index>[<expr><name>COL_CPU_USER</name></expr>]</index></name> <operator>=</operator> <call><name>Int64GetDatumFast</name><argument_list>(<argument><expr><name><name>tmp</name><operator>.</operator><name>cpu_user</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>values</name><index>[<expr><name>COL_CPU_SYS</name></expr>]</index></name> <operator>=</operator> <call><name>Int64GetDatumFast</name><argument_list>(<argument><expr><name><name>tmp</name><operator>.</operator><name>cpu_sys</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>values</name><index>[<expr><name>COL_RSS</name></expr>]</index></name> <operator>=</operator> <call><name>Int64GetDatumFast</name><argument_list>(<argument><expr><name><name>tmp</name><operator>.</operator><name>rss</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>values</name><index>[<expr><name>COL_SHARED_READ_PS</name></expr>]</index></name> <operator>=</operator> <call><name>Int64GetDatumFast</name><argument_list>(<argument><expr><name><name>tmp</name><operator>.</operator><name>shared_read_ps</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>values</name><index>[<expr><name>COL_SHARED_WRITE_PS</name></expr>]</index></name> <operator>=</operator> <call><name>Int64GetDatumFast</name><argument_list>(<argument><expr><name><name>tmp</name><operator>.</operator><name>shared_write_ps</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>values</name><index>[<expr><name>COL_SHARED_READ_THROUGHPUT</name></expr>]</index></name> <operator>=</operator> <call><name>Int64GetDatumFast</name><argument_list>(<argument><expr><name><name>tmp</name><operator>.</operator><name>shared_read_throughput</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>values</name><index>[<expr><name>COL_SHARED_WRITE_THROUGHPUT</name></expr>]</index></name> <operator>=</operator> <call><name>Int64GetDatumFast</name><argument_list>(<argument><expr><name><name>tmp</name><operator>.</operator><name>shared_write_throughput</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>values</name><index>[<expr><name>COL_SHARED_READ_LATENCY</name></expr>]</index></name> <operator>=</operator> <call><name>Float8GetDatumFast</name><argument_list>(<argument><expr><name><name>tmp</name><operator>.</operator><name>shared_read_latency</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>values</name><index>[<expr><name>COL_SHARED_WRITE_LATENCY</name></expr>]</index></name> <operator>=</operator> <call><name>Float8GetDatumFast</name><argument_list>(<argument><expr><name><name>tmp</name><operator>.</operator><name>shared_write_latency</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>values</name><index>[<expr><name>COL_LOCAL_READ_PS</name></expr>]</index></name> <operator>=</operator> <call><name>Int64GetDatumFast</name><argument_list>(<argument><expr><name><name>tmp</name><operator>.</operator><name>local_read_ps</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>values</name><index>[<expr><name>COL_LOCAL_WRITE_PS</name></expr>]</index></name> <operator>=</operator> <call><name>Int64GetDatumFast</name><argument_list>(<argument><expr><name><name>tmp</name><operator>.</operator><name>local_write_ps</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>values</name><index>[<expr><name>COL_LOCAL_READ_THROUGHPUT</name></expr>]</index></name> <operator>=</operator> <call><name>Int64GetDatumFast</name><argument_list>(<argument><expr><name><name>tmp</name><operator>.</operator><name>local_read_throughput</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>values</name><index>[<expr><name>COL_LOCAL_WRITE_THROUGHPUT</name></expr>]</index></name> <operator>=</operator> <call><name>Int64GetDatumFast</name><argument_list>(<argument><expr><name><name>tmp</name><operator>.</operator><name>local_write_throughput</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>values</name><index>[<expr><name>COL_LOCAL_READ_LATENCY</name></expr>]</index></name> <operator>=</operator> <call><name>Float8GetDatumFast</name><argument_list>(<argument><expr><name><name>tmp</name><operator>.</operator><name>local_read_latency</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>values</name><index>[<expr><name>COL_LOCAL_WRITE_LATENCY</name></expr>]</index></name> <operator>=</operator> <call><name>Float8GetDatumFast</name><argument_list>(<argument><expr><name><name>tmp</name><operator>.</operator><name>local_write_latency</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>values</name><index>[<expr><name>COL_SEND_COUNT</name></expr>]</index></name> <operator>=</operator> <call><name>Int64GetDatumFast</name><argument_list>(<argument><expr><name><name>tmp</name><operator>.</operator><name>send_count</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>values</name><index>[<expr><name>COL_SEND_BYTES</name></expr>]</index></name> <operator>=</operator> <call><name>Int64GetDatumFast</name><argument_list>(<argument><expr><name><name>tmp</name><operator>.</operator><name>send_bytes</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>values</name><index>[<expr><name>COL_RECV_COUNT</name></expr>]</index></name> <operator>=</operator> <call><name>Int64GetDatumFast</name><argument_list>(<argument><expr><name><name>tmp</name><operator>.</operator><name>recv_count</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>values</name><index>[<expr><name>COL_RECV_BYTES</name></expr>]</index></name> <operator>=</operator> <call><name>Int64GetDatumFast</name><argument_list>(<argument><expr><name><name>tmp</name><operator>.</operator><name>recv_bytes</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>tuplestore_putvalues</name><argument_list>(<argument><expr><name>tupstore</name></expr></argument>, <argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><name>values</name></expr></argument>, <argument><expr><name>nulls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></while>

	<comment type="block">/* clean up and return the tuplestore */</comment>
	<expr_stmt><expr><call><name>tuplestore_donestoring</name><argument_list>(<argument><expr><name>tupstore</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>hash_destroy</name><argument_list>(<argument><expr><name>tmp_backend_htab</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>tmp_backend_htab</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<return>return <expr><operator>(</operator><name>Datum</name><operator>)</operator> <literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Allocate a new hashtable entry.
 * caller must hold an exclusive lock on pgss-&gt;lock
 */</comment>
<function><type><specifier>static</specifier> <name>polarBackendEntry</name> <modifier>*</modifier></type><name>polar_monitor_entry_alloc</name><parameter_list>(<parameter><decl><type><name>HTAB</name> <modifier>*</modifier></type><name>tmp_backend_htab</name></decl></parameter>, <parameter><decl><type><name>polarBackendHashKey</name> <modifier>*</modifier></type><name>key</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>polarBackendEntry</name>  	<modifier>*</modifier></type><name>entry</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>				<name>found</name></decl>;</decl_stmt>

	<comment type="block">/* Find or create an entry with desired hash code */</comment>
	<expr_stmt><expr><name>entry</name> <operator>=</operator> <operator>(</operator><name>polarBackendEntry</name> <operator>*</operator><operator>)</operator> <call><name>hash_search</name><argument_list>(<argument><expr><name>tmp_backend_htab</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name>HASH_ENTER</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>found</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* New entry, initialize it */</comment>

		<comment type="block">/* reset the statistics */</comment>
		<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>entry</name><operator>-&gt;</operator><name>counters</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>pgBackendCounters</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* re-initialize the mutex each time ... we assume no one using it */</comment>
		<expr_stmt><expr><call><name>SpinLockInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>entry</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>entry</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>polar_monitor_backend_entry_store</name><parameter_list>(<parameter><decl><type><name>HTAB</name> <modifier>*</modifier></type><name>tmp_backend_htab</name></decl></parameter>, <parameter><decl><type><name>pgBackendCounters</name></type> <name>counters</name></decl></parameter>, <parameter><decl><type><name>LWLock</name> <modifier>*</modifier></type><name>lock</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>volatile</specifier> <name>polarBackendEntry</name> <modifier>*</modifier></type><name>e</name></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>polarBackendHashKey</name></type> <name>key</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>polarBackendEntry</name>  <modifier>*</modifier></type><name>entry</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name><name>key</name><operator>.</operator><name>backend_type</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>key</name><operator>.</operator><name>backend_type</name></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Safety check... */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>tmp_backend_htab</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/* Set up key for hashtable search */</comment>
	<expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name><name>key</name><operator>.</operator><name>backend_type</name></name></expr></argument>, <argument><expr><name><name>counters</name><operator>.</operator><name>backend_type</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Lookup the hash table entry with shared lock. */</comment>
	<if_stmt><if>if <condition>(<expr><name>lock</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>lock</name></expr></argument>, <argument><expr><name>LW_SHARED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	
	<expr_stmt><expr><name>entry</name> <operator>=</operator> <operator>(</operator><name>polarBackendEntry</name> <operator>*</operator><operator>)</operator> <call><name>hash_search</name><argument_list>(<argument><expr><name>tmp_backend_htab</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>key</name></expr></argument>, <argument><expr><name>HASH_FIND</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Create new entry, if not present */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>entry</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Need exclusive lock to make a new hashtable entry - promote */</comment>
		<if_stmt><if>if <condition>(<expr><name>lock</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>lock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>lock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* OK to create a new hashtable entry */</comment>
		<expr_stmt><expr><name>entry</name> <operator>=</operator> <call><name>polar_monitor_entry_alloc</name><argument_list>(<argument><expr><name>tmp_backend_htab</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Grab the spinlock while updating the counters (see comment about
	 * locking rules at the head of the file)
	 */</comment>
	<expr_stmt><expr><name>e</name> <operator>=</operator> <operator>(</operator><specifier>volatile</specifier> <name>polarBackendEntry</name> <operator>*</operator><operator>)</operator> <name>entry</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>SpinLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>e</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name><name>e</name><operator>-&gt;</operator><name>counters</name><operator>.</operator><name>backend_type</name></name></expr></argument>, <argument><expr><name><name>counters</name><operator>.</operator><name>backend_type</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>counters</name><operator>.</operator><name>cpu_user</name></name> <operator>+=</operator> <name><name>counters</name><operator>.</operator><name>cpu_user</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>counters</name><operator>.</operator><name>cpu_sys</name></name> <operator>+=</operator> <name><name>counters</name><operator>.</operator><name>cpu_sys</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>counters</name><operator>.</operator><name>rss</name></name> <operator>+=</operator> <name><name>counters</name><operator>.</operator><name>rss</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>counters</name><operator>.</operator><name>shared_read_ps</name></name> <operator>+=</operator> <name><name>counters</name><operator>.</operator><name>shared_read_ps</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>counters</name><operator>.</operator><name>shared_write_ps</name></name> <operator>+=</operator> <name><name>counters</name><operator>.</operator><name>shared_write_ps</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>counters</name><operator>.</operator><name>shared_read_throughput</name></name> <operator>+=</operator> <name><name>counters</name><operator>.</operator><name>shared_read_throughput</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>counters</name><operator>.</operator><name>shared_write_throughput</name></name> <operator>+=</operator> <name><name>counters</name><operator>.</operator><name>shared_write_throughput</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>counters</name><operator>.</operator><name>shared_read_latency</name></name> <operator>+=</operator> <name><name>counters</name><operator>.</operator><name>shared_read_latency</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>counters</name><operator>.</operator><name>shared_write_latency</name></name> <operator>+=</operator> <name><name>counters</name><operator>.</operator><name>shared_write_latency</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>counters</name><operator>.</operator><name>local_read_ps</name></name> <operator>+=</operator> <name><name>counters</name><operator>.</operator><name>local_read_ps</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>counters</name><operator>.</operator><name>local_write_ps</name></name> <operator>+=</operator> <name><name>counters</name><operator>.</operator><name>local_write_ps</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>counters</name><operator>.</operator><name>local_read_throughput</name></name> <operator>+=</operator> <name><name>counters</name><operator>.</operator><name>local_read_throughput</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>counters</name><operator>.</operator><name>local_write_throughput</name></name> <operator>+=</operator> <name><name>counters</name><operator>.</operator><name>local_write_throughput</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>counters</name><operator>.</operator><name>local_read_latency</name></name> <operator>+=</operator> <name><name>counters</name><operator>.</operator><name>local_read_latency</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>counters</name><operator>.</operator><name>local_write_latency</name></name> <operator>+=</operator> <name><name>counters</name><operator>.</operator><name>local_write_latency</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>counters</name><operator>.</operator><name>send_count</name></name> <operator>+=</operator> <name><name>counters</name><operator>.</operator><name>send_count</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>counters</name><operator>.</operator><name>send_bytes</name></name> <operator>+=</operator> <name><name>counters</name><operator>.</operator><name>send_bytes</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>counters</name><operator>.</operator><name>recv_count</name></name> <operator>+=</operator> <name><name>counters</name><operator>.</operator><name>recv_count</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>counters</name><operator>.</operator><name>recv_bytes</name></name> <operator>+=</operator> <name><name>counters</name><operator>.</operator><name>recv_bytes</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>SpinLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>e</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>lock</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>lock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

</block_content>}</block></function>

<comment type="block">/*
 * collect the statistics of backends.
 *
 * We need to check the result, when call this funcition.
 * The value of result, -1 means fail, 0 means succeed.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>polar_backend_collect_stat</name><parameter_list>(<parameter><decl><type><name>pgBackendCounters</name> <modifier>*</modifier></type><name>counters</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>backendid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	
	<decl_stmt><decl><type><name>LocalPgBackendStatus</name> <modifier>*</modifier></type><name>local_beentry</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PgBackendStatus</name> <modifier>*</modifier></type><name>beentry</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>polar_proc_stat</name></type> <name>procstat</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>polar_net_stat</name> 	<modifier>*</modifier></type><name>net_procstat</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>  			<name>index</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>backend_type</name></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>uint64</name></type> 			<name>shared_read_ps</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint64</name></type> 			<name>shared_write_ps</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint64</name></type>			<name>shared_read_throughput</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint64</name></type>			<name>shared_write_throughput</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>instr_time</name></type>		<name>shared_read_latency</name></decl> ;</decl_stmt>
	<decl_stmt><decl><type><name>instr_time</name></type>		<name>shared_write_latency</name></decl> ;</decl_stmt>
	<decl_stmt><decl><type><name>uint64</name></type> 			<name>local_read_ps</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint64</name></type> 			<name>local_write_ps</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint64</name></type>			<name>local_read_throughput</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint64</name></type>			<name>local_write_throughput</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>instr_time</name></type>		<name>local_read_latency</name></decl> ;</decl_stmt>
	<decl_stmt><decl><type><name>instr_time</name></type>		<name>local_write_latency</name></decl> ;</decl_stmt>

	<expr_stmt><expr><call><name>INSTR_TIME_SET_ZERO</name><argument_list>(<argument><expr><name>shared_read_latency</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>INSTR_TIME_SET_ZERO</name><argument_list>(<argument><expr><name>shared_write_latency</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>INSTR_TIME_SET_ZERO</name><argument_list>(<argument><expr><name>local_read_latency</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>INSTR_TIME_SET_ZERO</name><argument_list>(<argument><expr><name>local_write_latency</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>procstat</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>procstat</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Get the next one in the list */</comment>
	<expr_stmt><expr><name>local_beentry</name> <operator>=</operator> <call><name>pgstat_fetch_stat_local_beentry</name><argument_list>(<argument><expr><name>backendid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>local_beentry</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Ignore if local_beentry type is empty */</comment>
		<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>beentry</name> <operator>=</operator> <operator>&amp;</operator><name><name>local_beentry</name><operator>-&gt;</operator><name>backendStatus</name></name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>beentry</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Ignore if beentry type is empty */</comment>
		<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Add backend type */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>beentry</name><operator>-&gt;</operator><name>st_backendType</name></name> <operator>==</operator> <name>B_BG_WORKER</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>backend_type</name> <operator>=</operator> <call><name>GetBackgroundWorkerTypeByPid</name><argument_list>(<argument><expr><name><name>beentry</name><operator>-&gt;</operator><name>st_procpid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name>backend_type</name> <operator>=</operator> <call><name>pgstat_get_backend_desc</name><argument_list>(<argument><expr><name><name>beentry</name><operator>-&gt;</operator><name>st_backendType</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>backend_type</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Ignore if backend type is empty*/</comment>
		<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name><name>counters</name><operator>-&gt;</operator><name>backend_type</name></name></expr></argument>, <argument><expr><name>backend_type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if<condition>(<expr><operator>!</operator><call><name>polar_get_proc_stat</name><argument_list>(<argument><expr><name><name>beentry</name><operator>-&gt;</operator><name>st_procpid</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>procstat</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>counters</name><operator>-&gt;</operator><name>cpu_user</name></name> <operator>=</operator> <name><name>procstat</name><operator>.</operator><name>utime</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>counters</name><operator>-&gt;</operator><name>cpu_sys</name></name> <operator>=</operator> <name><name>procstat</name><operator>.</operator><name>stime</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>counters</name><operator>-&gt;</operator><name>rss</name></name> <operator>=</operator> <name><name>procstat</name><operator>.</operator><name>rss</name></name> <operator>-</operator> <name><name>procstat</name><operator>.</operator><name>share</name></name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Each process accumulates its file type by file location */</comment>
	<if_stmt><if>if <condition>(<expr><name>PolarIOStatArray</name></expr>)</condition>
	<block>{<block_content>
		<for>for <control>(<init><expr><name>index</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>index</name> <operator>&lt;</operator> <name>POLARIO_TYPE_SIZE</name></expr>;</condition> <incr><expr><name>index</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<expr_stmt><expr><name>local_read_ps</name> <operator>+=</operator> <name><name>PolarIOStatArray</name><index>[<expr><name>backendid</name></expr>]</index></name><operator>.</operator><name><name>polar_proc_io_stat_dist</name><index>[<expr><name>index</name></expr>]</index><index>[<expr><name>POLARIO_LOCAL</name></expr>]</index></name><operator>.</operator><name>io_number_read</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>local_write_ps</name> <operator>+=</operator> <name><name>PolarIOStatArray</name><index>[<expr><name>backendid</name></expr>]</index></name><operator>.</operator><name><name>polar_proc_io_stat_dist</name><index>[<expr><name>index</name></expr>]</index><index>[<expr><name>POLARIO_LOCAL</name></expr>]</index></name><operator>.</operator><name>io_number_write</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>local_read_throughput</name> <operator>+=</operator> <name><name>PolarIOStatArray</name><index>[<expr><name>backendid</name></expr>]</index></name><operator>.</operator><name><name>polar_proc_io_stat_dist</name><index>[<expr><name>index</name></expr>]</index><index>[<expr><name>POLARIO_LOCAL</name></expr>]</index></name><operator>.</operator><name>io_throughtput_read</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>local_write_throughput</name> <operator>+=</operator> <name><name>PolarIOStatArray</name><index>[<expr><name>backendid</name></expr>]</index></name><operator>.</operator><name><name>polar_proc_io_stat_dist</name><index>[<expr><name>index</name></expr>]</index><index>[<expr><name>POLARIO_LOCAL</name></expr>]</index></name><operator>.</operator><name>io_throughtput_write</name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>INSTR_TIME_ADD</name><argument_list>(<argument><expr><name>local_read_latency</name></expr></argument>, <argument><expr><name><name>PolarIOStatArray</name><index>[<expr><name>backendid</name></expr>]</index></name><operator>.</operator><name><name>polar_proc_io_stat_dist</name><index>[<expr><name>index</name></expr>]</index><index>[<expr><name>POLARIO_LOCAL</name></expr>]</index></name><operator>.</operator><name>io_latency_read</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>INSTR_TIME_ADD</name><argument_list>(<argument><expr><name>local_write_latency</name></expr></argument>, <argument><expr><name><name>PolarIOStatArray</name><index>[<expr><name>backendid</name></expr>]</index></name><operator>.</operator><name><name>polar_proc_io_stat_dist</name><index>[<expr><name>index</name></expr>]</index><index>[<expr><name>POLARIO_LOCAL</name></expr>]</index></name><operator>.</operator><name>io_latency_write</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name>shared_read_ps</name> <operator>+=</operator> <name><name>PolarIOStatArray</name><index>[<expr><name>backendid</name></expr>]</index></name><operator>.</operator><name><name>polar_proc_io_stat_dist</name><index>[<expr><name>index</name></expr>]</index><index>[<expr><name>POLARIO_SHARED</name></expr>]</index></name><operator>.</operator><name>io_number_read</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>shared_write_ps</name> <operator>+=</operator> <name><name>PolarIOStatArray</name><index>[<expr><name>backendid</name></expr>]</index></name><operator>.</operator><name><name>polar_proc_io_stat_dist</name><index>[<expr><name>index</name></expr>]</index><index>[<expr><name>POLARIO_SHARED</name></expr>]</index></name><operator>.</operator><name>io_number_write</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>shared_read_throughput</name> <operator>+=</operator> <name><name>PolarIOStatArray</name><index>[<expr><name>backendid</name></expr>]</index></name><operator>.</operator><name><name>polar_proc_io_stat_dist</name><index>[<expr><name>index</name></expr>]</index><index>[<expr><name>POLARIO_SHARED</name></expr>]</index></name><operator>.</operator><name>io_throughtput_read</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>shared_write_throughput</name> <operator>+=</operator> <name><name>PolarIOStatArray</name><index>[<expr><name>backendid</name></expr>]</index></name><operator>.</operator><name><name>polar_proc_io_stat_dist</name><index>[<expr><name>index</name></expr>]</index><index>[<expr><name>POLARIO_SHARED</name></expr>]</index></name><operator>.</operator><name>io_throughtput_write</name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>INSTR_TIME_ADD</name><argument_list>(<argument><expr><name>shared_read_latency</name></expr></argument>, <argument><expr><name><name>PolarIOStatArray</name><index>[<expr><name>backendid</name></expr>]</index></name><operator>.</operator><name><name>polar_proc_io_stat_dist</name><index>[<expr><name>index</name></expr>]</index><index>[<expr><name>POLARIO_SHARED</name></expr>]</index></name><operator>.</operator><name>io_latency_read</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>INSTR_TIME_ADD</name><argument_list>(<argument><expr><name>shared_write_latency</name></expr></argument>, <argument><expr><name><name>PolarIOStatArray</name><index>[<expr><name>backendid</name></expr>]</index></name><operator>.</operator><name><name>polar_proc_io_stat_dist</name><index>[<expr><name>index</name></expr>]</index><index>[<expr><name>POLARIO_SHARED</name></expr>]</index></name><operator>.</operator><name>io_latency_write</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></for>

		<comment type="block">/* pfs iops */</comment>
		<expr_stmt><expr><name><name>counters</name><operator>-&gt;</operator><name>shared_read_ps</name></name> <operator>=</operator> <name>shared_read_ps</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>counters</name><operator>-&gt;</operator><name>shared_write_ps</name></name> <operator>=</operator> <name>shared_write_ps</name></expr>;</expr_stmt>

		<comment type="block">/* pfs io throughput */</comment>
		<expr_stmt><expr><name><name>counters</name><operator>-&gt;</operator><name>shared_read_throughput</name></name> <operator>=</operator> <name>shared_read_throughput</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>counters</name><operator>-&gt;</operator><name>shared_write_throughput</name></name> <operator>=</operator> <name>shared_write_throughput</name></expr>;</expr_stmt>

		<comment type="block">/* pfs io latency */</comment>
		<expr_stmt><expr><name><name>counters</name><operator>-&gt;</operator><name>shared_read_latency</name></name> <operator>=</operator> <call><name>INSTR_TIME_GET_MILLISEC</name><argument_list>(<argument><expr><name>shared_read_latency</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>counters</name><operator>-&gt;</operator><name>shared_write_latency</name></name> <operator>=</operator> <call><name>INSTR_TIME_GET_MILLISEC</name><argument_list>(<argument><expr><name>shared_write_latency</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* local iops */</comment>
		<expr_stmt><expr><name><name>counters</name><operator>-&gt;</operator><name>local_read_ps</name></name> <operator>=</operator> <name>local_read_ps</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>counters</name><operator>-&gt;</operator><name>local_write_ps</name></name> <operator>=</operator> <name>local_write_ps</name></expr>;</expr_stmt>

		<comment type="block">/* local io throughput */</comment>
		<expr_stmt><expr><name><name>counters</name><operator>-&gt;</operator><name>local_read_throughput</name></name> <operator>=</operator> <name>local_read_throughput</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>counters</name><operator>-&gt;</operator><name>local_write_throughput</name></name> <operator>=</operator> <name>local_write_throughput</name></expr>;</expr_stmt>

		<comment type="block">/* local io latency */</comment>
		<expr_stmt><expr><name><name>counters</name><operator>-&gt;</operator><name>local_read_latency</name></name> <operator>=</operator> <call><name>INSTR_TIME_GET_MILLISEC</name><argument_list>(<argument><expr><name>local_read_latency</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>counters</name><operator>-&gt;</operator><name>local_write_latency</name></name> <operator>=</operator> <call><name>INSTR_TIME_GET_MILLISEC</name><argument_list>(<argument><expr><name>local_write_latency</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>


	<expr_stmt><expr><name>net_procstat</name> <operator>=</operator> <operator>&amp;</operator><name><name>polar_network_stat_array</name><index>[<expr><name>backendid</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>counters</name><operator>-&gt;</operator><name>send_count</name></name> <operator>=</operator> <call><name>Int64GetDatumFast</name><argument_list>(<argument><expr><name><name>net_procstat</name><operator>-&gt;</operator><name>opstat</name><index>[<expr><name>POLAR_NETWORK_SEND_STAT</name></expr>]</index></name><operator>.</operator><name>count</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>counters</name><operator>-&gt;</operator><name>send_bytes</name></name> <operator>=</operator> <call><name>Int64GetDatumFast</name><argument_list>(<argument><expr><name><name>net_procstat</name><operator>-&gt;</operator><name>opstat</name><index>[<expr><name>POLAR_NETWORK_SEND_STAT</name></expr>]</index></name><operator>.</operator><name>bytes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>counters</name><operator>-&gt;</operator><name>recv_count</name></name> <operator>=</operator> <call><name>Int64GetDatumFast</name><argument_list>(<argument><expr><name><name>net_procstat</name><operator>-&gt;</operator><name>opstat</name><index>[<expr><name>POLAR_NETWORK_RECV_STAT</name></expr>]</index></name><operator>.</operator><name>count</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>counters</name><operator>-&gt;</operator><name>recv_bytes</name></name> <operator>=</operator> <call><name>Int64GetDatumFast</name><argument_list>(<argument><expr><name><name>net_procstat</name><operator>-&gt;</operator><name>opstat</name><index>[<expr><name>POLAR_NETWORK_RECV_STAT</name></expr>]</index></name><operator>.</operator><name>bytes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type> 
<name>polar_backend_stat_shmem_shutdown</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>code</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>polar_net_stat</name> 	<modifier>*</modifier></type><name>net_procstat</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>pgBackendCounters</name></type>	<name>counters</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>counters</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>counters</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><literal type="number">0</literal> <operator>!=</operator> <call><name>polar_backend_collect_stat</name><argument_list>(<argument><expr><operator>&amp;</operator><name>counters</name></expr></argument>, <argument><expr><name>MyBackendId</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>
	
	<comment type="block">/* process exit, need to memset the network stat */</comment>
	<expr_stmt><expr><name>net_procstat</name> <operator>=</operator> <operator>&amp;</operator><name><name>polar_network_stat_array</name><index>[<expr><name>MyBackendId</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>net_procstat</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>polar_net_stat</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>polar_monitor_backend_entry_store</name><argument_list>(<argument><expr><name>polar_monitor_backend_hash</name></expr></argument>, <argument><expr><name>counters</name></expr></argument>, <argument><expr><name><name>polar_monitor_backtype_share_state</name><operator>-&gt;</operator><name>lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><name>Size</name></type> <name>backend_stat_memsize</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Size</name></type>	<name>size</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>polar_hash_entry_max</name> <operator>!=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>size</name> <operator>=</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>polarBacktypeSharedState</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>size</name> <operator>=</operator> <call><name>add_size</name><argument_list>(<argument><expr><name>size</name></expr></argument>, <argument><expr><call><name>hash_estimate_size</name><argument_list>(<argument><expr><name>polar_hash_entry_max</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>polarBackendEntry</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>size</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>polar_backend_stat_shmem_startup</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HASHCTL</name></type>		<name>info</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> 		<name>found</name></decl>;</decl_stmt>
	
	<comment type="block">/* Create or attach to the shared memory state */</comment>
	<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>AddinShmemInitLock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* global access lock */</comment>
	<expr_stmt><expr><name>polar_monitor_backtype_share_state</name> <operator>=</operator> <call><name>ShmemInitStruct</name><argument_list>(<argument><expr><literal type="string">"polar_monitor"</literal></expr></argument>,
					<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>polarBacktypeSharedState</name></expr></argument>)</argument_list></sizeof></expr></argument>,
					<argument><expr><operator>&amp;</operator><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>found</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* First time through ... */</comment>
		<expr_stmt><expr><name><name>polar_monitor_backtype_share_state</name><operator>-&gt;</operator><name>lock</name></name> <operator>=</operator> <operator>&amp;</operator><operator>(</operator><call><name>GetNamedLWLockTranche</name><argument_list>(<argument><expr><literal type="string">"polar_stat_backend"</literal></expr></argument>)</argument_list></call><operator>)</operator><operator>-&gt;</operator><name>lock</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>info</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>info</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>info</name><operator>.</operator><name>keysize</name></name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>polarBackendHashKey</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>info</name><operator>.</operator><name>entrysize</name></name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>polarBackendEntry</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>

	<comment type="block">/* allocate stats shared memory hash */</comment>
	<expr_stmt><expr><name>polar_monitor_backend_hash</name> <operator>=</operator> <call><name>ShmemInitHash</name><argument_list>(<argument><expr><literal type="string">"polar_monitor cpu hash"</literal></expr></argument>,
							  <argument><expr><name>polar_hash_entry_max</name></expr></argument>, <argument><expr><name>polar_hash_entry_max</name></expr></argument>,
							  <argument><expr><operator>&amp;</operator><name>info</name></expr></argument>,
							  <argument><expr><name>HASH_ELEM</name> <operator>|</operator> <name>HASH_BLOBS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>AddinShmemInitLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return;</return>

</block_content>}</block></function>
</unit>
