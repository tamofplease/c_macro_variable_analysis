<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/PolarDB-for-PostgreSQL/external/polar_stat_sql/polar_stat_sql.c"><comment type="block">/*-------------------------------------------------------------------------
 * polar_stat_sql.c
 *    There are two parts: one is the collection of information about the kernel,
 *    and the other is the statistics about the execution plan nodes.
 *
 * Copyright (c) 2021, Alibaba Group Holding Limited
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * IDENTIFICATION
 *    external/polar_stat_sql/polar_stat_sql.c
 *-------------------------------------------------------------------------
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;unistd.h&gt;</cpp:file></cpp:include>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_SYS_RESOURCE_H</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/time.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/resource.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>HAVE_GETRUSAGE</name></cpp:ifndef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"rusagestub.h"</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/hash.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/parallel.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_type.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/executor.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/hashjoin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/instrument.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"funcapi.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/analyze.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pgstat.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postmaster/autovacuum.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/fd.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/ipc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/polar_lock_stats.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/polar_io_stat.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/spin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"tcop/utility.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/builtins.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/guc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/polar_sql_time_stat.h"</cpp:file></cpp:include>

<comment type="block">/* POLAR */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/polar_sql_time_stat.h"</cpp:file></cpp:include>

<expr_stmt><expr><name>PG_MODULE_MAGIC</name></expr>;</expr_stmt>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PGSS_DUMP_FILE</name></cpp:macro>		<cpp:value>"pg_stat/polar_stat_sql.stat"</cpp:value></cpp:define>

<typedef>typedef <type><name>uint64</name></type> <name>pgss_queryid</name>;</typedef>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>USAGE_INCREASE</name></cpp:macro>			<cpp:value>(1.0)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>USAGE_DECREASE_FACTOR</name></cpp:macro>	<cpp:value>(0.99)</cpp:value></cpp:define>	<comment type="block">/* decreased every pgss_entry_dealloc */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>USAGE_DEALLOC_PERCENT</name></cpp:macro>	<cpp:value>5</cpp:value></cpp:define>		<comment type="block">/* free this % of entries at once */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>USAGE_INIT</name></cpp:macro>				<cpp:value>(1.0)</cpp:value></cpp:define>	<comment type="block">/* including initial planning */</comment>

<comment type="block">/* 
 * ru_inblock block size is 512 bytes with Linux
 * see http://lkml.indiana.edu/hypermail/linux/kernel/0703.2/0937.html
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RUSAGE_BLOCK_SIZE</name></cpp:macro>	<cpp:value>512</cpp:value></cpp:define>			<comment type="block">/* Size of a block for getrusage() */</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TIMEVAL_DIFF</name><parameter_list>(<parameter><type><name>start</name></type></parameter>, <parameter><type><name>end</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(((double) end.tv_sec + (double) end.tv_usec / 1000000.0) \
	- ((double) start.tv_sec + (double) start.tv_usec / 1000000.0))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TIMESPEC_DIFF_IN_MS</name><parameter_list>(<parameter><type><name>t2</name></type></parameter>, <parameter><type><name>t1</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((t2 - t1)/1000.0)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LOCK_WAIT_TIMING</name><parameter_list>(<parameter><type><name>tag</name></type></parameter>)</parameter_list></cpp:macro> \
	 <cpp:value>TIMESPEC_DIFF_IN_MS(polar_lock_stat_local_summary[tag].wait_time,  \
						queryDesc-&gt;polar_sql_info-&gt;lock_stats_table_start[tag].wait_time);</cpp:value></cpp:define>
						
<comment type="block">/*
 * Extension version number, for supporting older extension versions' objects
 */</comment>
<typedef>typedef <type><enum>enum <name>pgssVersion</name>
<block>{
	<decl><name>PGSS_V1_0</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>,
	<decl><name>PGSS_V1_1</name></decl>,
}</block></enum></type> <name>pgssVersion</name>;</typedef>

<typedef>typedef <type><enum>enum <name>POLAR_SS_COL_DEF</name> <block>{
	<decl><name>COL_QUERY_ID</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>,
   	<decl><name>COL_USER_ID</name></decl>,
   	<decl><name>COL_DB_ID</name></decl>,
   	<decl><name>COL_READS</name></decl>,
   	<decl><name>COL_WRITES</name></decl>,
   	<decl><name>COL_USER_TIME</name></decl>,
   	<decl><name>COL_SYSTEM_TIME</name></decl>,
   	<decl><name>COL_MINFLTS</name></decl>,
   	<decl><name>COL_MAJFLTS</name></decl>,
   	<decl><name>COL_NSWAPS</name></decl>,
   	<decl><name>COL_MSGSNDS</name></decl>,
	<decl><name>COL_MSGRCVS</name></decl>,
	<decl><name>COL_NSIGNALS</name></decl>,
	<decl><name>COL_NVCSWS</name></decl>,
	<decl><name>COL_NIVCSWS</name></decl>,
	<decl><name>COL_SCAN_ROWS</name></decl>,
	<decl><name>COL_SCAN_TIME</name></decl>,
	<decl><name>COL_SCAN_COUNT</name></decl>,
	<decl><name>COL_JOIN_ROWS</name></decl>,
	<decl><name>COL_JOIN_TIME</name></decl>,
	<decl><name>COL_JOIN_COUNT</name></decl>,
	<decl><name>COL_SORT_ROWS</name></decl>,
	<decl><name>COL_SORT_TIME</name></decl>,
	<decl><name>COL_SORT_COUNT</name></decl>,
	<decl><name>COL_GROUP_ROWS</name></decl>,
	<decl><name>COL_GROUP_TIME</name></decl>,
	<decl><name>COl_GROUP_COUNT</name></decl>,
	<decl><name>COL_HASH_ROWS</name></decl>,
	<decl><name>COL_HASH_MEMORY</name></decl>,
	<decl><name>COL_HASH_COUNT</name></decl>,
	<decl><name>COL_PARSE_TIME</name></decl>,
	<decl><name>COL_ANALYZE_TIME</name></decl>,
	<decl><name>COL_REWRITE_TIME</name></decl>,
	<decl><name>COL_PLAN_TIME</name></decl>,
	<decl><name>COL_EXECUTE_TIME</name></decl>,
	<decl><name>COL_LWLOCK_WAIT</name></decl>,
	<decl><name>COL_REL_LOCK_WAIT</name></decl>,
	<decl><name>COL_XACT_LOCK_WAIT</name></decl>,
	<decl><name>COL_PAGE_LOCK_WAIT</name></decl>,
	<decl><name>COL_TUPLE_LOCK_WAIT</name></decl>,
	<decl><name>COL_SHARED_READ_PS</name></decl>,
	<decl><name>COL_SHARED_WRITE_PS</name></decl>,
	<decl><name>COL_SHARED_READ_THROUGHPUT</name></decl>,
	<decl><name>COL_SHARED_WRITE_THROUGHPUT</name></decl>,
	<decl><name>COL_SHARED_READ_LATENCY</name></decl>,
	<decl><name>COL_SHARED_WRITE_LATENCY</name></decl>,
	<decl><name>COL_IO_OPEN_NUM</name></decl>,
	<decl><name>COL_IO_SEEK_COUNT</name></decl>,
	<decl><name>COL_IO_OPEN_TIME</name></decl>,
	<decl><name>COL_IO_SEEK_TIME</name></decl>,
   	<decl><name>COL_POLAR_STAT_SQL_MAX</name></decl>
}</block></enum></type> <name>POLAR_SS_COL_DEF</name>;</typedef>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>uint32</name></type> <name>PGSS_FILE_HEADER</name> <init>= <expr><literal type="number">0x0d756e10</literal></expr></init></decl>;</decl_stmt>

<comment type="block">/*
 * Current getrusage counters.
 *
 * For platform without getrusage support, we rely on postgres implementation
 * defined in rusagestub.h, which only supports user and system time.
 *
 * Note that the following counters are not maintained on GNU/Linux:
 *   - ru_nswap
 *   - ru_msgsnd
 *   - ru_msgrcv
 *   - ru_nsignals
*/</comment>
<typedef>typedef <type><struct>struct <name>pgssCounters</name>
<block>{
	<decl_stmt><decl><type><name>double</name></type>			<name>usage</name></decl>;</decl_stmt>		<comment type="block">/* usage factor */</comment>
	<decl_stmt><decl><type><name>float8</name></type>			<name>utime</name></decl>;</decl_stmt>		<comment type="block">/* CPU user time */</comment>
	<decl_stmt><decl><type><name>float8</name></type>			<name>stime</name></decl>;</decl_stmt>		<comment type="block">/* CPU system time */</comment>
	<decl_stmt><decl><type><name>int64</name></type>			<name>minflts</name></decl>;</decl_stmt>	<comment type="block">/* page reclaims (soft page faults) */</comment>
	<decl_stmt><decl><type><name>int64</name></type>			<name>majflts</name></decl>;</decl_stmt>	<comment type="block">/* page faults (hard page faults) */</comment>
	<decl_stmt><decl><type><name>int64</name></type>			<name>nswaps</name></decl>;</decl_stmt>		<comment type="block">/* page faults (hard page faults) */</comment>
	<decl_stmt><decl><type><name>int64</name></type>			<name>reads</name></decl>;</decl_stmt>		<comment type="block">/* Physical block reads */</comment>
	<decl_stmt><decl><type><name>int64</name></type>			<name>writes</name></decl>;</decl_stmt>		<comment type="block">/* Physical block writes */</comment>
	<decl_stmt><decl><type><name>int64</name></type>			<name>msgsnds</name></decl>;</decl_stmt>	<comment type="block">/* IPC messages sent */</comment>
	<decl_stmt><decl><type><name>int64</name></type>			<name>msgrcvs</name></decl>;</decl_stmt>	<comment type="block">/* IPC messages received */</comment>
	<decl_stmt><decl><type><name>int64</name></type>			<name>nsignals</name></decl>;</decl_stmt>	<comment type="block">/* signals received */</comment>
	<decl_stmt><decl><type><name>int64</name></type>			<name>nvcsws</name></decl>;</decl_stmt>		<comment type="block">/* voluntary context witches */</comment>
	<decl_stmt><decl><type><name>int64</name></type>			<name>nivcsws</name></decl>;</decl_stmt>	<comment type="block">/* unvoluntary context witches */</comment>

	<decl_stmt><decl><type><name>double</name></type>		    <name>scan_rows</name></decl>;</decl_stmt>			<comment type="block">/* scan rows */</comment>
	<decl_stmt><decl><type><name>double</name></type>		    <name>scan_time</name></decl>;</decl_stmt>			<comment type="block">/* scan time */</comment>
	<decl_stmt><decl><type><name>int64</name></type>		    <name>scan_count</name></decl>;</decl_stmt>			<comment type="block">/* scan count */</comment>
	<decl_stmt><decl><type><name>double</name></type>		    <name>join_rows</name></decl>;</decl_stmt>		    <comment type="block">/* join rows */</comment>
	<decl_stmt><decl><type><name>double</name></type>		    <name>join_time</name></decl>;</decl_stmt>		    <comment type="block">/* join time */</comment>
	<decl_stmt><decl><type><name>int64</name></type>		    <name>join_count</name></decl>;</decl_stmt>   	    <comment type="block">/* join count */</comment>
	<decl_stmt><decl><type><name>double</name></type>		    <name>sort_rows</name></decl>;</decl_stmt>			<comment type="block">/* sort rows */</comment>
	<decl_stmt><decl><type><name>double</name></type>		    <name>sort_time</name></decl>;</decl_stmt>			<comment type="block">/* sort time */</comment>
	<decl_stmt><decl><type><name>int64</name></type>		    <name>sort_count</name></decl>;</decl_stmt>   	    <comment type="block">/* sort count */</comment>
	<decl_stmt><decl><type><name>double</name></type>		    <name>group_rows</name></decl>;</decl_stmt>			<comment type="block">/* group rows */</comment>
	<decl_stmt><decl><type><name>double</name></type>		    <name>group_time</name></decl>;</decl_stmt>			<comment type="block">/* group time */</comment>
	<decl_stmt><decl><type><name>int64</name></type>		    <name>group_count</name></decl>;</decl_stmt>   	    <comment type="block">/* group count */</comment>
	<decl_stmt><decl><type><name>double</name></type>		    <name>hash_rows</name></decl>;</decl_stmt>			<comment type="block">/* hash rows */</comment>
	<decl_stmt><decl><type><name>int64</name></type>		    <name>hash_memory</name></decl>;</decl_stmt>		<comment type="block">/* hash memory, unit kB */</comment>
	<decl_stmt><decl><type><name>int64</name></type>		    <name>hash_count</name></decl>;</decl_stmt>   	    <comment type="block">/* hash count */</comment>
	<decl_stmt><decl><type><name>double</name></type>		    <name>parse_time</name></decl>;</decl_stmt>			<comment type="block">/* total time for sql parse */</comment>
	<decl_stmt><decl><type><name>double</name></type>		    <name>analyze_time</name></decl>;</decl_stmt>		<comment type="block">/* total time for sql analyze */</comment>
	<decl_stmt><decl><type><name>double</name></type>		    <name>rewrite_time</name></decl>;</decl_stmt>		<comment type="block">/* total time for sql analyze */</comment>
	<decl_stmt><decl><type><name>double</name></type>		    <name>plan_time</name></decl>;</decl_stmt>			<comment type="block">/* total time for sql plan  */</comment>
	<decl_stmt><decl><type><name>double</name></type>		    <name>execute_time</name></decl>;</decl_stmt>		<comment type="block">/* total time for sql execute */</comment>
	<decl_stmt><decl><type><name>double</name></type>		    <name>lwlock_wait</name></decl>;</decl_stmt>		<comment type="block">/* lwlock wait time */</comment>
	<decl_stmt><decl><type><name>double</name></type>		    <name>rel_lock_wait</name></decl>;</decl_stmt>		<comment type="block">/* rel lock wait time */</comment>
	<decl_stmt><decl><type><name>double</name></type>		    <name>xact_lock_wait</name></decl>;</decl_stmt>		<comment type="block">/* xact lock wait time */</comment>
	<decl_stmt><decl><type><name>double</name></type>		    <name>page_lock_wait</name></decl>;</decl_stmt>		<comment type="block">/* page lock wait time */</comment>
	<decl_stmt><decl><type><name>double</name></type>		    <name>tuple_lock_wait</name></decl>;</decl_stmt>	<comment type="block">/* tuple lock wait time */</comment>
	<decl_stmt><decl><type><name>int64</name></type>	<name>shared_read_ps</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int64</name></type>	<name>shared_write_ps</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int64</name></type>	<name>shared_read_throughput</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int64</name></type>	<name>shared_write_throughput</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type>	<name>shared_read_latency</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type> 	<name>shared_write_latency</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int64</name></type>	<name>io_open_num</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int64</name></type>	<name>io_seek_count</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type>	<name>io_open_time</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type>	<name>io_seek_time</name></decl>;</decl_stmt>
}</block></struct></type> <name>pgssCounters</name>;</typedef>

<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type>	<name>pgss_max</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>	<comment type="block">/* max #queries to store. pg_stat_statements.max is used */</comment>

<comment type="block">/*
 * Hashtable key that defines the identity of a hashtable entry.  We use the
 * same hash as pg_stat_statements
 */</comment>
<typedef>typedef <type><struct>struct <name>pgssHashKey</name>
<block>{
	<decl_stmt><decl><type><name>Oid</name></type>			<name>userid</name></decl>;</decl_stmt>			<comment type="block">/* user OID */</comment>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>dbid</name></decl>;</decl_stmt>			<comment type="block">/* database OID */</comment>
	<decl_stmt><decl><type><name>pgss_queryid</name></type>		<name>queryid</name></decl>;</decl_stmt>		<comment type="block">/* query identifier */</comment>
}</block></struct></type> <name>pgssHashKey</name>;</typedef>

<comment type="block">/*
 * Statistics per database
 */</comment>
<typedef>typedef <type><struct>struct <name>pgssEntry</name>
<block>{
	<decl_stmt><decl><type><name>pgssHashKey</name></type>		<name>key</name></decl>;</decl_stmt>		<comment type="block">/* hash key of entry - MUST BE FIRST */</comment>
	<decl_stmt><decl><type><name>pgssCounters</name></type>	<name>counters</name></decl>;</decl_stmt>	<comment type="block">/* statistics for this query */</comment>
	<decl_stmt><decl><type><name>slock_t</name></type>			<name>mutex</name></decl>;</decl_stmt>		<comment type="block">/* protects the counters only */</comment>
}</block></struct></type> <name>pgssEntry</name>;</typedef>

<comment type="block">/*
 * Global shared state
 */</comment>
<typedef>typedef <type><struct>struct <name>pgssSharedState</name>
<block>{
	<decl_stmt><decl><type><name>LWLock</name>	   <modifier>*</modifier></type><name>lock</name></decl>;</decl_stmt>					<comment type="block">/* protects hashtable search/modification */</comment>
}</block></struct></type> <name>pgssSharedState</name>;</typedef>

<comment type="block">/*
 * struct about plan info 
*/</comment>
<typedef>typedef <type><struct>struct <name>pgssPlanInfo</name>
<block>{
	<decl_stmt><decl><type><name>double</name></type>		<name>scan_rows</name></decl>;</decl_stmt>			<comment type="block">/* scan rows */</comment>
	<decl_stmt><decl><type><name>double</name></type>		<name>scan_time</name></decl>;</decl_stmt>			<comment type="block">/* scan time */</comment>
	<decl_stmt><decl><type><name>int64</name></type>		<name>scan_count</name></decl>;</decl_stmt>			<comment type="block">/* scan count */</comment>
	<decl_stmt><decl><type><name>double</name></type>		<name>join_rows</name></decl>;</decl_stmt>			<comment type="block">/* join rows */</comment>
	<decl_stmt><decl><type><name>double</name></type>		<name>join_time</name></decl>;</decl_stmt>			<comment type="block">/* join time */</comment>
	<decl_stmt><decl><type><name>int64</name></type>		<name>join_count</name></decl>;</decl_stmt>   		<comment type="block">/* join count */</comment>
	<decl_stmt><decl><type><name>double</name></type>		<name>sort_rows</name></decl>;</decl_stmt>			<comment type="block">/* sort rows */</comment>
	<decl_stmt><decl><type><name>double</name></type>		<name>sort_time</name></decl>;</decl_stmt>			<comment type="block">/* sort time */</comment>
	<decl_stmt><decl><type><name>int64</name></type>		<name>sort_count</name></decl>;</decl_stmt>   	    <comment type="block">/* sort count */</comment>
	<decl_stmt><decl><type><name>double</name></type>		<name>group_rows</name></decl>;</decl_stmt>			<comment type="block">/* group rows */</comment>
	<decl_stmt><decl><type><name>double</name></type>		<name>group_time</name></decl>;</decl_stmt>			<comment type="block">/* group time */</comment>
	<decl_stmt><decl><type><name>int64</name></type>		<name>group_count</name></decl>;</decl_stmt>   	    <comment type="block">/* group count */</comment>
	<decl_stmt><decl><type><name>double</name></type>		<name>hash_rows</name></decl>;</decl_stmt>			<comment type="block">/* hash rows */</comment>
	<decl_stmt><decl><type><name>int64</name></type>		<name>hash_memory</name></decl>;</decl_stmt>		<comment type="block">/* hash memory, unit kB */</comment>
	<decl_stmt><decl><type><name>int64</name></type>		<name>hash_count</name></decl>;</decl_stmt>   	    <comment type="block">/* hash count */</comment>
}</block></struct></type><name>pgssPlanInfo</name>;</typedef>

<comment type="block">/* QPS */</comment>
<typedef>typedef <type><struct>struct <name>QueryTypeStat</name>
<block>{
	<decl_stmt><decl><type><name>LWLock</name>	   <modifier>*</modifier></type><name>lock</name></decl>;</decl_stmt>
	<comment type="block">/* DQL */</comment>
	<decl_stmt><decl><type><name>pg_atomic_uint64</name></type> <name>select_count</name></decl>;</decl_stmt>
	<comment type="block">/* DML */</comment>
	<decl_stmt><decl><type><name>pg_atomic_uint64</name></type> <name>update_count</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>pg_atomic_uint64</name></type> <name>insert_count</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>pg_atomic_uint64</name></type> <name>delete_count</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>pg_atomic_uint64</name></type> <name>explain_count</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>pg_atomic_uint64</name></type> <name>lock_count</name></decl>;</decl_stmt>
	<comment type="block">/* DDL */</comment>
	<decl_stmt><decl><type><name>pg_atomic_uint64</name></type> <name>create_count</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>pg_atomic_uint64</name></type> <name>drop_count</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>pg_atomic_uint64</name></type> <name>rename_count</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>pg_atomic_uint64</name></type> <name>truncate_count</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>pg_atomic_uint64</name></type> <name>comment_count</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>pg_atomic_uint64</name></type> <name>alter_count</name></decl>;</decl_stmt>
	<comment type="block">/* DCL */</comment>
	<decl_stmt><decl><type><name>pg_atomic_uint64</name></type> <name>grant_count</name></decl>;</decl_stmt>
}</block></struct></type> <name>QueryTypeStat</name>;</typedef>

<decl_stmt><decl><type><specifier>static</specifier> <name>QueryTypeStat</name><modifier>*</modifier></type> <name>query_type_stat</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>add_various_tuple</name><parameter_list>(<parameter><decl><type><name>Tuplestorestate</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>TupleDesc</name></type> <name>tdesc</name></decl></parameter>, <parameter><decl><type><name>char</name><modifier>*</modifier></type> <name>sqltype</name></decl></parameter>, <parameter><decl><type><name>char</name><modifier>*</modifier></type> <name>cmdtype</name></decl></parameter>,
					 <parameter><decl><type><specifier>const</specifier> <name>int</name></type> <name>arraylen</name></decl></parameter>, <parameter><decl><type><name>int64</name></type> <name>count</name></decl></parameter>, <parameter><decl><type><name>Datum</name> <modifier>*</modifier></type><name>values</name></decl></parameter>, 
					 <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>nulls</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>array_size</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>record_query_type</name><parameter_list>(<parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>query</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>pgsk_post_parse_analyze</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>query</name></decl></parameter>)</parameter_list>;</function_decl>
<comment type="block">/* QPS end */</comment>

<comment type="block">/* saved hook address in case of unload */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>shmem_startup_hook_type</name></type> <name>prev_shmem_startup_hook</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>ExecutorStart_hook_type</name></type> <name>prev_ExecutorStart</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>ExecutorRun_hook_type</name></type> <name>prev_ExecutorRun</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>ExecutorFinish_hook_type</name></type> <name>prev_ExecutorFinish</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>ExecutorEnd_hook_type</name></type> <name>prev_ExecutorEnd</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>post_parse_analyze_hook_type</name></type> <name>prev_post_parse_analyze_hook</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>ProcessUtility_hook_type</name></type> <name>prev_ProcessUtility</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<comment type="block">/* Links to shared memory state */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>pgssSharedState</name> <modifier>*</modifier></type><name>pgss</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>HTAB</name> <modifier>*</modifier></type><name>polar_stat_sql_hash</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<comment type="block">/*--- Functions --- */</comment>

<function_decl><type><name>void</name></type>	<name>_PG_init</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type>	<name>_PG_fini</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>extern</specifier> <name>PGDLLEXPORT</name> <name>Datum</name></type>	<name>polar_stat_sql_reset</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>extern</specifier> <name>PGDLLEXPORT</name> <name>Datum</name></type>	<name>polar_stat_sql</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>extern</specifier> <name>PGDLLEXPORT</name> <name>Datum</name></type>	<name>polar_stat_sql_1_0</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>extern</specifier> <name>PGDLLEXPORT</name> <name>Datum</name></type>	<name>polar_stat_sql_1_1</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>;</function_decl>

<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>polar_stat_sql_reset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>polar_stat_sql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>polar_stat_sql_1_0</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>polar_stat_sql_1_1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>polar_stat_sql_internal</name><parameter_list>(<parameter><decl><type><name>FunctionCallInfo</name></type> <name>fcinfo</name></decl></parameter>, <parameter><decl><type><name>pgssVersion</name></type>
		<name>api_version</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>pgss_setmax</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Size</name></type> <name>pgss_memsize</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>polar_stat_shmem_startup</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>pgss_shmem_shutdown</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>code</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>arg</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>polar_stat_ExecutorStart</name><parameter_list>(<parameter><decl><type><name>QueryDesc</name> <modifier>*</modifier></type><name>queryDesc</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>eflags</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>polar_stat_ExecutorEnd</name><parameter_list>(<parameter><decl><type><name>QueryDesc</name> <modifier>*</modifier></type><name>queryDesc</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>polar_stat_ExecutorRun</name><parameter_list>(<parameter><decl><type><name>QueryDesc</name> <modifier>*</modifier></type><name>queryDesc</name></decl></parameter>, <parameter><decl><type><name>ScanDirection</name></type> <name>direction</name></decl></parameter>, <parameter><decl><type><name>uint64</name></type> <name>count</name></decl></parameter>,
				 <parameter><decl><type><name>bool</name></type> <name>execute_once</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type>
<name>polar_stat_ExecutorFinish</name><parameter_list>(<parameter><decl><type><name>QueryDesc</name> <modifier>*</modifier></type><name>queryDesc</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type>
<name>polar_stat_ProcessUtility</name><parameter_list>(<parameter><decl><type><name>PlannedStmt</name> <modifier>*</modifier></type><name>pstmt</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>queryString</name></decl></parameter>,
					<parameter><decl><type><name>ProcessUtilityContext</name></type> <name>context</name></decl></parameter>,
					<parameter><decl><type><name>ParamListInfo</name></type> <name>params</name></decl></parameter>, <parameter><decl><type><name>QueryEnvironment</name> <modifier>*</modifier></type><name>queryEnv</name></decl></parameter>,
					<parameter><decl><type><name>DestReceiver</name> <modifier>*</modifier></type><name>dest</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>completionTag</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>pgssEntry</name> <modifier>*</modifier></type><name>pgss_entry_alloc</name><parameter_list>(<parameter><decl><type><name>pgssHashKey</name> <modifier>*</modifier></type><name>key</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>pgss_entry_dealloc</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>pgss_entry_reset</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>pgss_entry_store</name><parameter_list>(<parameter><decl><type><name>pgss_queryid</name></type> <name>queryId</name></decl></parameter>, <parameter><decl><type><name>pgssCounters</name></type> <name>counters</name></decl></parameter>, <parameter><decl><type><name>pgssPlanInfo</name> <modifier>*</modifier></type><name>plan_info</name></decl></parameter>, <parameter><decl><type><name>PolarCollectIoStat</name> <modifier>*</modifier></type><name>io_stat_info</name></decl></parameter>, <parameter><decl><type><name>QueryDesc</name> <modifier>*</modifier></type><name>queryDesc</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>uint32</name></type> <name>polar_stat_sql_hash_fn</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>key</name></decl></parameter>, <parameter><decl><type><name>Size</name></type> <name>keysize</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type>	<name>pgss_match_fn</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>key1</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>key2</name></decl></parameter>, <parameter><decl><type><name>Size</name></type> <name>keysize</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>pgss_stat_plan_node</name><parameter_list>(<parameter><decl><type><name>PlanState</name> <modifier>*</modifier></type><name>planstate</name></decl></parameter>, <parameter><decl><type><name>pgssPlanInfo</name> <modifier>*</modifier></type><name>planInfo</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>pgss_stat_subplan_node</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>plans</name></decl></parameter>, <parameter><decl><type><name>pgssPlanInfo</name>  <modifier>*</modifier></type><name>planInfo</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>pgss_assign_linux_hz_check_hook</name><parameter_list>(<parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>newval</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier><modifier>*</modifier></type><name>extra</name></decl></parameter>, <parameter><decl><type><name>GucSource</name></type> <name>source</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>Size</name></type> <name>pgss_queryids_array_size</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>

<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type>	<name>pgss_linux_hz</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type> <name>polar_ss_enable_stat</name></decl>;</decl_stmt>      	<comment type="block">/* whether to enable the extension */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type> <name>polar_ss_getuage</name></decl>;</decl_stmt>      		<comment type="block">/* whether to enable getuage */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type> <name>polar_ss_gather_plan_info</name></decl>;</decl_stmt> 	<comment type="block">/* whether to gather plan node information */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type> <name>polar_ss_plan_need_time</name></decl>;</decl_stmt>		<comment type="block">/* whether to gather plan node information need time*/</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type> <name>polar_ss_save</name></decl>;</decl_stmt>				<comment type="block">/* whether to save stats across shutdown */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type> <name>polar_pgsk_qps_monitor</name></decl>;</decl_stmt>		<comment type="block">/* whether to monitor qps */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>double</name></type> <name>polar_ss_sample_rate</name></decl>;</decl_stmt>   	<comment type="block">/* sample rate of sql */</comment>

<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type> <name>is_sql_sampled</name></decl>;</decl_stmt>      			<comment type="block">/* sql level sampled */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type> <name>is_stat_enable</name></decl>;</decl_stmt>      			<comment type="block">/* stat enable switch */</comment>

<comment type="block">/* Current nesting depth of ExecutorRun+ProcessUtility calls */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type>	<name>nested_level</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<function><type><name>void</name></type>
<name>_PG_init</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>process_shared_preload_libraries_in_progress</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"This module can only be loaded via shared_preload_libraries"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>DefineCustomIntVariable</name><argument_list>(<argument><expr><literal type="string">"polar_stat_sql.linux_hz"</literal></expr></argument>,
				<argument><expr><literal type="string">"Inform polar_stat_sql of the linux CONFIG_HZ config option"</literal></expr></argument>,
				<argument><expr><literal type="string">"This is used by polar_stat_sql to compensate for sampling errors "</literal>
				<literal type="string">"in getrusage due to the kernel adhering to its ticks. The default value, -1, "</literal>
				<literal type="string">"tries to guess it at startup. "</literal></expr></argument>,
							<argument><expr><operator>&amp;</operator><name>pgss_linux_hz</name></expr></argument>,
							<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>,
							<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>,
							<argument><expr><name>INT_MAX</name></expr></argument>,
							<argument><expr><name>PGC_USERSET</name></expr></argument>,
							<argument><expr><literal type="number">0</literal></expr></argument>,
							<argument><expr><name>pgss_assign_linux_hz_check_hook</name></expr></argument>,
							<argument><expr><name>NULL</name></expr></argument>,
							<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


	<comment type="block">/*
	 * POLAR: whether to enable the extension
	 */</comment>
	<expr_stmt><expr><call><name>DefineCustomBoolVariable</name><argument_list>(<argument><expr><literal type="string">"polar_stat_sql.enable_stat"</literal></expr></argument>,
							 <argument><expr><literal type="string">"Whether to enable the extension"</literal></expr></argument>,
							 <argument><expr><name>NULL</name></expr></argument>,
							 <argument><expr><operator>&amp;</operator><name>polar_ss_enable_stat</name></expr></argument>,
							 <argument><expr><name>false</name></expr></argument>,
							 <argument><expr><name>PGC_SUSET</name></expr></argument>,
							 <argument><expr><literal type="number">0</literal></expr></argument>,
							 <argument><expr><name>NULL</name></expr></argument>,
							 <argument><expr><name>NULL</name></expr></argument>,
							 <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>DefineCustomRealVariable</name><argument_list>(<argument><expr><literal type="string">"polar_stat_sql.sample_rate"</literal></expr></argument>,
							 <argument><expr><literal type="string">"Sampling rate. 1 means every query, 0.2 means 1 in five queries"</literal></expr></argument>,
							 <argument><expr><name>NULL</name></expr></argument>,
							 <argument><expr><operator>&amp;</operator><name>polar_ss_sample_rate</name></expr></argument>,
							 <argument><expr><literal type="number">0.5</literal></expr></argument>,
							 <argument><expr><literal type="number">0.0</literal></expr></argument>,
							 <argument><expr><literal type="number">1.0</literal></expr></argument>,
							 <argument><expr><name>PGC_USERSET</name></expr></argument>,
							 <argument><expr><literal type="number">0</literal></expr></argument>,
							 <argument><expr><name>NULL</name></expr></argument>,
							 <argument><expr><name>NULL</name></expr></argument>,
							 <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * POLAR: whether to enable getrusage
	 */</comment>
	<expr_stmt><expr><call><name>DefineCustomBoolVariable</name><argument_list>(<argument><expr><literal type="string">"polar_stat_sql.enable_getrusage"</literal></expr></argument>,
							 <argument><expr><literal type="string">"Whether to enable getuage"</literal></expr></argument>,
							 <argument><expr><name>NULL</name></expr></argument>,
							 <argument><expr><operator>&amp;</operator><name>polar_ss_getuage</name></expr></argument>,
							 <argument><expr><name>false</name></expr></argument>,
							 <argument><expr><name>PGC_SUSET</name></expr></argument>,
							 <argument><expr><literal type="number">0</literal></expr></argument>,
							 <argument><expr><name>NULL</name></expr></argument>,
							 <argument><expr><name>NULL</name></expr></argument>,
							 <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * POLAR: whether to gather plan nodes info switch
	 */</comment>
	<expr_stmt><expr><call><name>DefineCustomBoolVariable</name><argument_list>(<argument><expr><literal type="string">"polar_stat_sql.enable_gather_plan_info"</literal></expr></argument>,
							 <argument><expr><literal type="string">"Whether to gather plan nodes info"</literal></expr></argument>,
							 <argument><expr><name>NULL</name></expr></argument>,
							 <argument><expr><operator>&amp;</operator><name>polar_ss_gather_plan_info</name></expr></argument>,
							 <argument><expr><name>false</name></expr></argument>,
							 <argument><expr><name>PGC_SUSET</name></expr></argument>,
							 <argument><expr><literal type="number">0</literal></expr></argument>,
							 <argument><expr><name>NULL</name></expr></argument>,
							 <argument><expr><name>NULL</name></expr></argument>,
							 <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/*
	 * POLAR: whether to gather plan nodes need time
	 */</comment>
	<expr_stmt><expr><call><name>DefineCustomBoolVariable</name><argument_list>(<argument><expr><literal type="string">"polar_stat_sql.enable_plan_need_time"</literal></expr></argument>,
							 <argument><expr><literal type="string">"Whether to gather plan nodes need time information"</literal></expr></argument>,
							 <argument><expr><name>NULL</name></expr></argument>,
							 <argument><expr><operator>&amp;</operator><name>polar_ss_plan_need_time</name></expr></argument>,
							 <argument><expr><name>false</name></expr></argument>,
							 <argument><expr><name>PGC_SUSET</name></expr></argument>,
							 <argument><expr><literal type="number">0</literal></expr></argument>,
							 <argument><expr><name>NULL</name></expr></argument>,
							 <argument><expr><name>NULL</name></expr></argument>,
							 <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * POLAR: Set the default value to be 'false' here.
	 */</comment>
	<expr_stmt><expr><call><name>DefineCustomBoolVariable</name><argument_list>(<argument><expr><literal type="string">"polar_stat_sql.save"</literal></expr></argument>,
							 <argument><expr><literal type="string">"Save polar statistics for across server shutdowns."</literal></expr></argument>,
							 <argument><expr><name>NULL</name></expr></argument>,
							 <argument><expr><operator>&amp;</operator><name>polar_ss_save</name></expr></argument>,
							 <argument><expr><name>false</name></expr></argument>,
							 <argument><expr><name>PGC_SIGHUP</name></expr></argument>,
							 <argument><expr><literal type="number">0</literal></expr></argument>,
							 <argument><expr><name>NULL</name></expr></argument>,
							 <argument><expr><name>NULL</name></expr></argument>,
							 <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * POLAR: Set the default value to be 'false' here, 
	 */</comment>
	<expr_stmt><expr><call><name>DefineCustomBoolVariable</name><argument_list>(<argument><expr><literal type="string">"polar_stat_sql.enable_qps_monitor"</literal></expr></argument>,
							 <argument><expr><literal type="string">"Selects whether to monitor qps "</literal></expr></argument>,
							 <argument><expr><name>NULL</name></expr></argument>,
							 <argument><expr><operator>&amp;</operator><name>polar_pgsk_qps_monitor</name></expr></argument>,
							 <argument><expr><name>false</name></expr></argument>,
							 <argument><expr><name>PGC_SUSET</name></expr></argument>,
							 <argument><expr><literal type="number">0</literal></expr></argument>,
							 <argument><expr><name>NULL</name></expr></argument>,
							 <argument><expr><name>NULL</name></expr></argument>,
							 <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>EmitWarningsOnPlaceholders</name><argument_list>(<argument><expr><literal type="string">"polar_stat_sql"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* set pgss_max if needed */</comment>
	<expr_stmt><expr><call><name>pgss_setmax</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>RequestAddinShmemSpace</name><argument_list>(<argument><expr><call><name>pgss_memsize</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>RequestNamedLWLockTranche</name><argument_list>(<argument><expr><literal type="string">"polar_stat_sql"</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Install hook */</comment>
	<expr_stmt><expr><name>prev_shmem_startup_hook</name> <operator>=</operator> <name>shmem_startup_hook</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>shmem_startup_hook</name> <operator>=</operator> <name>polar_stat_shmem_startup</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>prev_post_parse_analyze_hook</name> <operator>=</operator> <name>post_parse_analyze_hook</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>post_parse_analyze_hook</name> <operator>=</operator> <name>pgsk_post_parse_analyze</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>prev_ExecutorStart</name> <operator>=</operator> <name>ExecutorStart_hook</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>ExecutorStart_hook</name> <operator>=</operator> <name>polar_stat_ExecutorStart</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>prev_ExecutorRun</name> <operator>=</operator> <name>ExecutorRun_hook</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>ExecutorRun_hook</name> <operator>=</operator> <name>polar_stat_ExecutorRun</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>prev_ExecutorFinish</name> <operator>=</operator> <name>ExecutorFinish_hook</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>ExecutorFinish_hook</name> <operator>=</operator> <name>polar_stat_ExecutorFinish</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>prev_ExecutorEnd</name> <operator>=</operator> <name>ExecutorEnd_hook</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>ExecutorEnd_hook</name> <operator>=</operator> <name>polar_stat_ExecutorEnd</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>prev_ProcessUtility</name> <operator>=</operator> <name>ProcessUtility_hook</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>ProcessUtility_hook</name> <operator>=</operator> <name>polar_stat_ProcessUtility</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>_PG_fini</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* uninstall hook */</comment>
	<expr_stmt><expr><name>ExecutorStart_hook</name> <operator>=</operator> <name>prev_ExecutorStart</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>ExecutorRun_hook</name> <operator>=</operator> <name>prev_ExecutorRun</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>ExecutorFinish_hook</name> <operator>=</operator> <name>prev_ExecutorFinish</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>ExecutorEnd_hook</name> <operator>=</operator> <name>prev_ExecutorEnd</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>shmem_startup_hook</name> <operator>=</operator> <name>prev_shmem_startup_hook</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>post_parse_analyze_hook</name> <operator>=</operator> <name>prev_post_parse_analyze_hook</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>ProcessUtility_hook</name> <operator>=</operator> <name>prev_ProcessUtility</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>pgss_assign_linux_hz_check_hook</name><parameter_list>(<parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>newval</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier><modifier>*</modifier></type><name>extra</name></decl></parameter>, <parameter><decl><type><name>GucSource</name></type> <name>source</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>val</name> <init>= <expr><operator>*</operator><name>newval</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>rusage</name></name></type> <name>myrusage</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>timeval</name></name></type> <name>previous_value</name></decl>;</decl_stmt>

	<comment type="block">/* In that case we try to guess it */</comment>
	<if_stmt><if>if <condition>(<expr><name>val</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"Auto detecting polar_stat_sql.linux_hz parameter..."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>getrusage</name><argument_list>(<argument><expr><name>RUSAGE_SELF</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>myrusage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>previous_value</name> <operator>=</operator> <name><name>myrusage</name><operator>.</operator><name>ru_utime</name></name></expr>;</expr_stmt>
		<while>while <condition>(<expr><name><name>myrusage</name><operator>.</operator><name>ru_utime</name><operator>.</operator><name>tv_usec</name></name> <operator>==</operator> <name><name>previous_value</name><operator>.</operator><name>tv_usec</name></name> <operator>&amp;&amp;</operator>
			   <name><name>myrusage</name><operator>.</operator><name>ru_utime</name><operator>.</operator><name>tv_sec</name></name> <operator>==</operator> <name><name>previous_value</name><operator>.</operator><name>tv_sec</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>getrusage</name><argument_list>(<argument><expr><name>RUSAGE_SELF</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>myrusage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></while>
		<expr_stmt><expr><operator>*</operator><name>newval</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator> <operator>(</operator><literal type="number">1</literal> <operator>/</operator> <operator>(</operator><operator>(</operator><name><name>myrusage</name><operator>.</operator><name>ru_utime</name><operator>.</operator><name>tv_sec</name></name> <operator>-</operator> <name><name>previous_value</name><operator>.</operator><name>tv_sec</name></name><operator>)</operator> <operator>+</operator>
		   <operator>(</operator><name><name>myrusage</name><operator>.</operator><name>ru_utime</name><operator>.</operator><name>tv_usec</name></name> <operator>-</operator> <name><name>previous_value</name><operator>.</operator><name>tv_usec</name></name><operator>)</operator> <operator>/</operator> <literal type="number">1000000.</literal><operator>)</operator><operator>)</operator></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"polar_stat_sql.linux_hz is set to %d"</literal></expr></argument>, <argument><expr><operator>*</operator><name>newval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>polar_stat_shmem_startup</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type>		<name>found</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HASHCTL</name></type>		<name>info</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>FILE</name>		<modifier>*</modifier></type><name>file</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32</name></type>		<name>header</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name></type>		<name>num</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>pgssEntry</name>	<modifier>*</modifier></type><name>buffer</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>prev_shmem_startup_hook</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>prev_shmem_startup_hook</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* reset in case this is a restart within the postmaster */</comment>
	<expr_stmt><expr><name>pgss</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>query_type_stat</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<comment type="block">/* Create or attach to the shared memory state */</comment>
	<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>AddinShmemInitLock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>query_type_stat</name> <operator>=</operator> <call><name>ShmemInitStruct</name><argument_list>(<argument><expr><literal type="string">"query_type_stat"</literal></expr></argument>,
						   <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>QueryTypeStat</name></expr></argument>)</argument_list></sizeof></expr></argument>,
						   <argument><expr><operator>&amp;</operator><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* global access lock */</comment>
	<expr_stmt><expr><name>pgss</name> <operator>=</operator> <call><name>ShmemInitStruct</name><argument_list>(<argument><expr><literal type="string">"polar_stat_sql"</literal></expr></argument>,
					<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>pgssSharedState</name></expr></argument>)</argument_list></sizeof></expr></argument>,
					<argument><expr><operator>&amp;</operator><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>found</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* First time through ... */</comment>
		<decl_stmt><decl><type><name>LWLockPadded</name> <modifier>*</modifier></type><name>locks</name> <init>= <expr><call><name>GetNamedLWLockTranche</name><argument_list>(<argument><expr><literal type="string">"polar_stat_sql"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name><name>pgss</name><operator>-&gt;</operator><name>lock</name></name> <operator>=</operator> <operator>&amp;</operator><operator>(</operator><name><name>locks</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>)</operator><operator>.</operator><name>lock</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* set pgss_max if needed */</comment>
	<expr_stmt><expr><call><name>pgss_setmax</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>info</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>info</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>info</name><operator>.</operator><name>keysize</name></name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>pgssHashKey</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>info</name><operator>.</operator><name>entrysize</name></name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>pgssEntry</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>info</name><operator>.</operator><name>hash</name></name> <operator>=</operator> <name>polar_stat_sql_hash_fn</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>info</name><operator>.</operator><name>match</name></name> <operator>=</operator> <name>pgss_match_fn</name></expr>;</expr_stmt>

	<comment type="block">/* allocate stats shared memory hash */</comment>
	<expr_stmt><expr><name>polar_stat_sql_hash</name> <operator>=</operator> <call><name>ShmemInitHash</name><argument_list>(<argument><expr><literal type="string">"polar_stat_sql hash"</literal></expr></argument>,
							  <argument><expr><name>pgss_max</name></expr></argument>, <argument><expr><name>pgss_max</name></expr></argument>,
							  <argument><expr><operator>&amp;</operator><name>info</name></expr></argument>,
							  <argument><expr><name>HASH_ELEM</name> <operator>|</operator> <name>HASH_FUNCTION</name> <operator>|</operator> <name>HASH_COMPARE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>AddinShmemInitLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>IsUnderPostmaster</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>on_shmem_exit</name><argument_list>(<argument><expr><name>pgss_shmem_shutdown</name></expr></argument>, <argument><expr><operator>(</operator><name>Datum</name><operator>)</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Done if some other process already completed our initialization.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>found</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * If we were told not to load old statistics, we're done.  (Note we do
	 * not try to unlink any old dump file in this case.  This seems a bit
	 * questionable but it's the historical behavior.)
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>polar_ss_save</name></expr>)</condition>
	<block>{<block_content>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Load stat file, don't care about locking */</comment>
	<expr_stmt><expr><name>file</name> <operator>=</operator> <call><name>AllocateFile</name><argument_list>(<argument><expr><name>PGSS_DUMP_FILE</name></expr></argument>, <argument><expr><name>PG_BINARY_R</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>file</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>errno</name> <operator>==</operator> <name>ENOENT</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return;</return></block_content></block></if></if_stmt>			<comment type="block">/* ignore not-found error */</comment>
		<goto>goto <name>error</name>;</goto>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* check if header is valid */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>fread</name><argument_list>(<argument><expr><operator>&amp;</operator><name>header</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>uint32</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>file</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">1</literal> <operator>||</operator>
		<name>header</name> <operator>!=</operator> <name>PGSS_FILE_HEADER</name></expr>)</condition><block type="pseudo"><block_content>
		<goto>goto <name>error</name>;</goto></block_content></block></if></if_stmt>

	<comment type="block">/* get number of entries */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>fread</name><argument_list>(<argument><expr><operator>&amp;</operator><name>num</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>int32</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>file</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
		<goto>goto <name>error</name>;</goto></block_content></block></if></if_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>num</name></expr> ;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>pgssEntry</name></type>	<name>temp</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>pgssEntry</name>  <modifier>*</modifier></type><name>entry</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>fread</name><argument_list>(<argument><expr><operator>&amp;</operator><name>temp</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>pgssEntry</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>file</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
			<goto>goto <name>error</name>;</goto></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>entry</name> <operator>=</operator> <call><name>pgss_entry_alloc</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>temp</name><operator>.</operator><name>key</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* copy in the actual stats */</comment>
		<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>counters</name></name> <operator>=</operator> <name><name>temp</name><operator>.</operator><name>counters</name></name></expr>;</expr_stmt>
		<comment type="block">/* don't initialize spinlock, already done */</comment>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>FreeFile</name><argument_list>(<argument><expr><name>file</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Remove the file so it's not included in backups/replication slaves,
	 * etc. A new file will be written on next shutdown.
	 */</comment>
	<expr_stmt><expr><call><name>unlink</name><argument_list>(<argument><expr><name>PGSS_DUMP_FILE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return;</return>

<label><name>error</name>:</label>
	<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
			<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
			 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not read polar_stat_sql file \"%s\": %m"</literal></expr></argument>,
					<argument><expr><name>PGSS_DUMP_FILE</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>buffer</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>file</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>FreeFile</name><argument_list>(<argument><expr><name>file</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<comment type="block">/* delete bogus file, don't care of errors in this case */</comment>
	<expr_stmt><expr><call><name>unlink</name><argument_list>(<argument><expr><name>PGSS_DUMP_FILE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * shmem_shutdown hook: dump statistics into file.
 *
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>pgss_shmem_shutdown</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>code</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>FILE</name>	<modifier>*</modifier></type><name>file</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HASH_SEQ_STATUS</name></type> <name>hash_seq</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name></type>	<name>num_entries</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>pgssEntry</name>	<modifier>*</modifier></type><name>entry</name></decl>;</decl_stmt>

	<comment type="block">/* Don't try to dump during a crash. */</comment>
	<if_stmt><if>if <condition>(<expr><name>code</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>pgss</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>


	<comment type="block">/* Don't dump if told not to. */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>polar_ss_save</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>file</name> <operator>=</operator> <call><name>AllocateFile</name><argument_list>(<argument><expr><name>PGSS_DUMP_FILE</name> <literal type="string">".tmp"</literal></expr></argument>, <argument><expr><name>PG_BINARY_W</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>file</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<goto>goto <name>error</name>;</goto></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>fwrite</name><argument_list>(<argument><expr><operator>&amp;</operator><name>PGSS_FILE_HEADER</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>uint32</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>file</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
		<goto>goto <name>error</name>;</goto></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>num_entries</name> <operator>=</operator> <call><name>hash_get_num_entries</name><argument_list>(<argument><expr><name>polar_stat_sql_hash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>fwrite</name><argument_list>(<argument><expr><operator>&amp;</operator><name>num_entries</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>int32</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>file</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
		<goto>goto <name>error</name>;</goto></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>hash_seq_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>hash_seq</name></expr></argument>, <argument><expr><name>polar_stat_sql_hash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<while>while <condition>(<expr><operator>(</operator><name>entry</name> <operator>=</operator> <call><name>hash_seq_search</name><argument_list>(<argument><expr><operator>&amp;</operator><name>hash_seq</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>fwrite</name><argument_list>(<argument><expr><name>entry</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>pgssEntry</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>file</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* note: we assume hash_seq_term won't change errno */</comment>
			<expr_stmt><expr><call><name>hash_seq_term</name><argument_list>(<argument><expr><operator>&amp;</operator><name>hash_seq</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<goto>goto <name>error</name>;</goto>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></while>

	<if_stmt><if>if <condition>(<expr><call><name>FreeFile</name><argument_list>(<argument><expr><name>file</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>file</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<goto>goto <name>error</name>;</goto>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Rename file inplace
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>rename</name><argument_list>(<argument><expr><name>PGSS_DUMP_FILE</name> <literal type="string">".tmp"</literal></expr></argument>, <argument><expr><name>PGSS_DUMP_FILE</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not rename polar_stat_sql file \"%s\": %m"</literal></expr></argument>,
						<argument><expr><name>PGSS_DUMP_FILE</name> <literal type="string">".tmp"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return;</return>

<label><name>error</name>:</label>
	<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
			<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
			 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not read polar_stat_sql file \"%s\": %m"</literal></expr></argument>,
					<argument><expr><name>PGSS_DUMP_FILE</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>file</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>FreeFile</name><argument_list>(<argument><expr><name>file</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><call><name>unlink</name><argument_list>(<argument><expr><name>PGSS_DUMP_FILE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Retrieve pg_stat_statement.max GUC value and store it into pgss_max, since
 * we want to store the same number of entries as pg_stat_statements. Don't do
 * anything if pgss_max is already set.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>pgss_setmax</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>pgss_max_str</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name> <init>= <expr><literal type="string">"pg_stat_statements.max"</literal></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>pgss_max</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>pgss_max_str</name> <operator>=</operator> <call><name>GetConfigOption</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Retrieving pg_stat_statements.max can fail if pgss is loaded after pgss
	 * in shared_preload_libraries.  Hint user in case this happens.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>pgss_max_str</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_OBJECT</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"unrecognized configuration parameter \"%s\""</literal></expr></argument>,
						<argument><expr><name>name</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"make sure pg_stat_statements is loaded,\n"</literal>
					 <literal type="string">"and make sure polar_stat_sql is present after pg_stat_statements"</literal>
					 <literal type="string">" in the shared_preload_libraries setting"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>pgss_max</name> <operator>=</operator> <call><name>atoi</name><argument_list>(<argument><expr><name>pgss_max_str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>Size</name></type> <name>pgss_memsize</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Size</name></type>	<name>size</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>pgss_max</name> <operator>!=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>size</name> <operator>=</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>pgssSharedState</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>size</name> <operator>=</operator> <call><name>add_size</name><argument_list>(<argument><expr><name>size</name></expr></argument>, <argument><expr><call><name>hash_estimate_size</name><argument_list>(<argument><expr><name>pgss_max</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>pgssEntry</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>size</name> <operator>=</operator> <call><name>add_size</name><argument_list>(<argument><expr><name>size</name></expr></argument>, <argument><expr><call><name>MAXALIGN</name><argument_list>(<argument><expr><call><name>pgss_queryids_array_size</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>size</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>Size</name></type>
<name>pgss_queryids_array_size</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * queryid isn't pushed to parallel workers.  We store them in shared mem
	 * for each query, identified by their BackendId.  If need room for all
	 * possible backends, plus autovacuum launcher and workers, plus bg workers
	 * and an extra one since BackendId numerotation starts at 1.
	 */</comment>
	<return>return <expr><operator>(</operator><sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <operator>(</operator><name>MaxConnections</name> <operator>+</operator> <name>autovacuum_max_workers</name> <operator>+</operator> <literal type="number">1</literal>
							<operator>+</operator> <name>max_worker_processes</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * support functions
 */</comment>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>pgss_entry_store</name><parameter_list>(<parameter><decl><type><name>pgss_queryid</name></type> <name>queryId</name></decl></parameter>, <parameter><decl><type><name>pgssCounters</name></type> <name>counters</name></decl></parameter>, <parameter><decl><type><name>pgssPlanInfo</name> <modifier>*</modifier></type><name>plan_info</name></decl></parameter>, 
	<parameter><decl><type><name>PolarCollectIoStat</name> <modifier>*</modifier></type><name>io_stat_info</name></decl></parameter>, <parameter><decl><type><name>QueryDesc</name> <modifier>*</modifier></type><name>queryDesc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>volatile</specifier> <name>pgssEntry</name> <modifier>*</modifier></type><name>e</name></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>pgssHashKey</name></type> <name>key</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>pgssEntry</name>  <modifier>*</modifier></type><name>entry</name></decl>;</decl_stmt>

	<comment type="block">/* Safety check... */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>pgss</name> <operator>||</operator> <operator>!</operator><name>polar_stat_sql_hash</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/* Set up key for hashtable search */</comment>
	<expr_stmt><expr><name><name>key</name><operator>.</operator><name>userid</name></name> <operator>=</operator> <call><name>GetUserId</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>key</name><operator>.</operator><name>dbid</name></name> <operator>=</operator> <name>MyDatabaseId</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>key</name><operator>.</operator><name>queryid</name></name> <operator>=</operator> <name>queryId</name></expr>;</expr_stmt>

	<comment type="block">/* Lookup the hash table entry with shared lock. */</comment>
	<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name><name>pgss</name><operator>-&gt;</operator><name>lock</name></name></expr></argument>, <argument><expr><name>LW_SHARED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>entry</name> <operator>=</operator> <operator>(</operator><name>pgssEntry</name> <operator>*</operator><operator>)</operator> <call><name>hash_search</name><argument_list>(<argument><expr><name>polar_stat_sql_hash</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>key</name></expr></argument>, <argument><expr><name>HASH_FIND</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Create new entry, if not present */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>entry</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Need exclusive lock to make a new hashtable entry - promote */</comment>
		<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name><name>pgss</name><operator>-&gt;</operator><name>lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name><name>pgss</name><operator>-&gt;</operator><name>lock</name></name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* OK to create a new hashtable entry */</comment>
		<expr_stmt><expr><name>entry</name> <operator>=</operator> <call><name>pgss_entry_alloc</name><argument_list>(<argument><expr><operator>&amp;</operator><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Grab the spinlock while updating the counters (see comment about
	 * locking rules at the head of the file)
	 */</comment>
	<expr_stmt><expr><name>e</name> <operator>=</operator> <operator>(</operator><specifier>volatile</specifier> <name>pgssEntry</name> <operator>*</operator><operator>)</operator> <name>entry</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>SpinLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>e</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>counters</name><operator>.</operator><name>usage</name></name> <operator>+=</operator> <name>USAGE_INCREASE</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>counters</name><operator>.</operator><name>utime</name></name> <operator>+=</operator> <name><name>counters</name><operator>.</operator><name>utime</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>counters</name><operator>.</operator><name>stime</name></name> <operator>+=</operator> <name><name>counters</name><operator>.</operator><name>stime</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>counters</name><operator>.</operator><name>minflts</name></name> <operator>+=</operator> <name><name>counters</name><operator>.</operator><name>minflts</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>counters</name><operator>.</operator><name>majflts</name></name> <operator>+=</operator> <name><name>counters</name><operator>.</operator><name>majflts</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>counters</name><operator>.</operator><name>nswaps</name></name> <operator>+=</operator> <name><name>counters</name><operator>.</operator><name>nswaps</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>counters</name><operator>.</operator><name>reads</name></name> <operator>+=</operator> <name><name>counters</name><operator>.</operator><name>reads</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>counters</name><operator>.</operator><name>writes</name></name> <operator>+=</operator> <name><name>counters</name><operator>.</operator><name>writes</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>counters</name><operator>.</operator><name>msgsnds</name></name> <operator>+=</operator> <name><name>counters</name><operator>.</operator><name>msgsnds</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>counters</name><operator>.</operator><name>msgrcvs</name></name> <operator>+=</operator> <name><name>counters</name><operator>.</operator><name>msgrcvs</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>counters</name><operator>.</operator><name>nsignals</name></name> <operator>+=</operator> <name><name>counters</name><operator>.</operator><name>nsignals</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>counters</name><operator>.</operator><name>nvcsws</name></name> <operator>+=</operator> <name><name>counters</name><operator>.</operator><name>nvcsws</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>counters</name><operator>.</operator><name>nivcsws</name></name> <operator>+=</operator> <name><name>counters</name><operator>.</operator><name>nivcsws</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>counters</name><operator>.</operator><name>scan_rows</name></name> <operator>+=</operator> <name><name>plan_info</name><operator>-&gt;</operator><name>scan_rows</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>counters</name><operator>.</operator><name>scan_time</name></name> <operator>+=</operator> <name><name>plan_info</name><operator>-&gt;</operator><name>scan_time</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>counters</name><operator>.</operator><name>scan_count</name></name> <operator>+=</operator> <name><name>plan_info</name><operator>-&gt;</operator><name>scan_count</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>counters</name><operator>.</operator><name>join_rows</name></name> <operator>+=</operator> <name><name>plan_info</name><operator>-&gt;</operator><name>join_rows</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>counters</name><operator>.</operator><name>join_time</name></name> <operator>+=</operator> <name><name>plan_info</name><operator>-&gt;</operator><name>join_time</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>counters</name><operator>.</operator><name>join_count</name></name> <operator>+=</operator> <name><name>plan_info</name><operator>-&gt;</operator><name>join_count</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>counters</name><operator>.</operator><name>sort_rows</name></name> <operator>+=</operator> <name><name>plan_info</name><operator>-&gt;</operator><name>sort_rows</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>counters</name><operator>.</operator><name>sort_time</name></name> <operator>+=</operator> <name><name>plan_info</name><operator>-&gt;</operator><name>sort_time</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>counters</name><operator>.</operator><name>sort_count</name></name> <operator>+=</operator> <name><name>plan_info</name><operator>-&gt;</operator><name>sort_count</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>counters</name><operator>.</operator><name>group_rows</name></name> <operator>+=</operator> <name><name>plan_info</name><operator>-&gt;</operator><name>group_rows</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>counters</name><operator>.</operator><name>group_time</name></name> <operator>+=</operator> <name><name>plan_info</name><operator>-&gt;</operator><name>group_time</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>counters</name><operator>.</operator><name>group_count</name></name> <operator>+=</operator> <name><name>plan_info</name><operator>-&gt;</operator><name>group_count</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>counters</name><operator>.</operator><name>hash_rows</name></name> <operator>+=</operator> <name><name>plan_info</name><operator>-&gt;</operator><name>hash_rows</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>counters</name><operator>.</operator><name>hash_memory</name></name> <operator>+=</operator> <name><name>plan_info</name><operator>-&gt;</operator><name>hash_memory</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>counters</name><operator>.</operator><name>hash_count</name></name> <operator>+=</operator> <name><name>plan_info</name><operator>-&gt;</operator><name>hash_count</name></name></expr>;</expr_stmt>
	
	<comment type="block">/* sql stat time */</comment>
	<if_stmt><if>if <condition>(<expr><name>polar_enable_track_sql_time_stat</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>counters</name><operator>.</operator><name>execute_time</name></name> <operator>+=</operator> <name><name>polar_sql_time_stat_local_summary</name><operator>.</operator><name>execute_time</name></name> <operator>/</operator> <literal type="number">1000.0</literal></expr>;</expr_stmt>
		<comment type="block">/*
		 * Only the top sql need to record the parse/analyze/rewrite/plan time.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>nested_level</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>counters</name><operator>.</operator><name>parse_time</name></name> <operator>+=</operator> <name><name>polar_sql_time_stat_local_summary</name><operator>.</operator><name>parse_time</name></name> <operator>/</operator> <literal type="number">1000.0</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>counters</name><operator>.</operator><name>analyze_time</name></name> <operator>+=</operator> <name><name>polar_sql_time_stat_local_summary</name><operator>.</operator><name>analyze_time</name></name> <operator>/</operator> <literal type="number">1000.0</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>counters</name><operator>.</operator><name>rewrite_time</name></name> <operator>+=</operator> <name><name>polar_sql_time_stat_local_summary</name><operator>.</operator><name>rewrite_time</name></name> <operator>/</operator> <literal type="number">1000.0</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>counters</name><operator>.</operator><name>plan_time</name></name> <operator>+=</operator> <name><name>polar_sql_time_stat_local_summary</name><operator>.</operator><name>plan_time</name></name> <operator>/</operator> <literal type="number">1000.0</literal></expr>;</expr_stmt>
			<comment type="block">/*
			* When all the sql execute finish, need to init the global record.
			*/</comment>
			<expr_stmt><expr><call><name>polar_init_sql_time_local_stats</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt> 
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* lwlock timing */</comment>
	<expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>counters</name><operator>.</operator><name>lwlock_wait</name></name> <operator>+=</operator> <call><name>TIMESPEC_DIFF_IN_MS</name><argument_list>(
											<argument><expr><name><name>polar_lwlock_stat_local_summary</name><operator>.</operator><name>wait_time</name></name></expr></argument>, 
											<argument><expr><name><name>queryDesc</name><operator>-&gt;</operator><name>polar_sql_info</name><operator>-&gt;</operator><name>lwlock_stat_start</name><operator>.</operator><name>wait_time</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* lock timing */</comment>
	<expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>counters</name><operator>.</operator><name>rel_lock_wait</name></name> <operator>+=</operator> <call><name>LOCK_WAIT_TIMING</name><argument_list>(<argument><expr><name>LOCKTAG_RELATION</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>counters</name><operator>.</operator><name>rel_lock_wait</name></name> <operator>+=</operator> <call><name>LOCK_WAIT_TIMING</name><argument_list>(<argument><expr><name>LOCKTAG_RELATION_EXTEND</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>counters</name><operator>.</operator><name>xact_lock_wait</name></name> <operator>+=</operator> <call><name>LOCK_WAIT_TIMING</name><argument_list>(<argument><expr><name>LOCKTAG_TRANSACTION</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>counters</name><operator>.</operator><name>xact_lock_wait</name></name> <operator>+=</operator> <call><name>LOCK_WAIT_TIMING</name><argument_list>(<argument><expr><name>LOCKTAG_VIRTUALTRANSACTION</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>counters</name><operator>.</operator><name>xact_lock_wait</name></name> <operator>+=</operator> <call><name>LOCK_WAIT_TIMING</name><argument_list>(<argument><expr><name>LOCKTAG_SPECULATIVE_TOKEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>counters</name><operator>.</operator><name>page_lock_wait</name></name> <operator>+=</operator> <call><name>LOCK_WAIT_TIMING</name><argument_list>(<argument><expr><name>LOCKTAG_PAGE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>counters</name><operator>.</operator><name>tuple_lock_wait</name></name> <operator>+=</operator> <call><name>LOCK_WAIT_TIMING</name><argument_list>(<argument><expr><name>LOCKTAG_TUPLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	
	<expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>counters</name><operator>.</operator><name>shared_read_ps</name></name> <operator>+=</operator> <name><name>io_stat_info</name><operator>-&gt;</operator><name>shared_read_ps</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>counters</name><operator>.</operator><name>shared_write_ps</name></name> <operator>+=</operator> <name><name>io_stat_info</name><operator>-&gt;</operator><name>shared_write_ps</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>counters</name><operator>.</operator><name>shared_read_throughput</name></name> <operator>+=</operator> <name><name>io_stat_info</name><operator>-&gt;</operator><name>shared_read_throughput</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>counters</name><operator>.</operator><name>shared_write_throughput</name></name> <operator>+=</operator> <name><name>io_stat_info</name><operator>-&gt;</operator><name>shared_write_throughput</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>counters</name><operator>.</operator><name>shared_read_latency</name></name> <operator>+=</operator> <name><name>io_stat_info</name><operator>-&gt;</operator><name>shared_read_latency</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>counters</name><operator>.</operator><name>shared_write_latency</name></name> <operator>+=</operator> <name><name>io_stat_info</name><operator>-&gt;</operator><name>shared_write_latency</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>counters</name><operator>.</operator><name>io_open_num</name></name> <operator>+=</operator> <name><name>io_stat_info</name><operator>-&gt;</operator><name>io_open_num</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>counters</name><operator>.</operator><name>io_seek_count</name></name> <operator>+=</operator> <name><name>io_stat_info</name><operator>-&gt;</operator><name>io_seek_count</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>counters</name><operator>.</operator><name>io_open_time</name></name> <operator>+=</operator> <name><name>io_stat_info</name><operator>-&gt;</operator><name>io_open_time</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>counters</name><operator>.</operator><name>io_seek_time</name></name> <operator>+=</operator> <name><name>io_stat_info</name><operator>-&gt;</operator><name>io_seek_time</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>SpinLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>e</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name><name>pgss</name><operator>-&gt;</operator><name>lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Allocate a new hashtable entry.
 * caller must hold an exclusive lock on pgss-&gt;lock
 */</comment>
<function><type><specifier>static</specifier> <name>pgssEntry</name> <modifier>*</modifier></type><name>pgss_entry_alloc</name><parameter_list>(<parameter><decl><type><name>pgssHashKey</name> <modifier>*</modifier></type><name>key</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>pgssEntry</name>  <modifier>*</modifier></type><name>entry</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>found</name></decl>;</decl_stmt>

	<comment type="block">/* Make space if needed */</comment>
	<while>while <condition>(<expr><call><name>hash_get_num_entries</name><argument_list>(<argument><expr><name>polar_stat_sql_hash</name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <name>pgss_max</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>pgss_entry_dealloc</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></while>

	<comment type="block">/* Find or create an entry with desired hash code */</comment>
	<expr_stmt><expr><name>entry</name> <operator>=</operator> <operator>(</operator><name>pgssEntry</name> <operator>*</operator><operator>)</operator> <call><name>hash_search</name><argument_list>(<argument><expr><name>polar_stat_sql_hash</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name>HASH_ENTER</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>found</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* New entry, initialize it */</comment>

		<comment type="block">/* reset the statistics */</comment>
		<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>entry</name><operator>-&gt;</operator><name>counters</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>pgssCounters</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* set the appropriate initial usage count */</comment>
		<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>counters</name><operator>.</operator><name>usage</name></name> <operator>=</operator> <name>USAGE_INIT</name></expr>;</expr_stmt>
		<comment type="block">/* re-initialize the mutex each time ... we assume no one using it */</comment>
		<expr_stmt><expr><call><name>SpinLockInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>entry</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>entry</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * qsort comparator for sorting into increasing usage order
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>entry_cmp</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>lhs</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>rhs</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>double</name></type>		<name>l_usage</name> <init>= <expr><operator>(</operator><operator>*</operator><operator>(</operator><name>pgssEntry</name> <operator>*</operator><specifier>const</specifier> <operator>*</operator><operator>)</operator> <name>lhs</name><operator>)</operator><operator>-&gt;</operator><name><name>counters</name><operator>.</operator><name>usage</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type>		<name>r_usage</name> <init>= <expr><operator>(</operator><operator>*</operator><operator>(</operator><name>pgssEntry</name> <operator>*</operator><specifier>const</specifier> <operator>*</operator><operator>)</operator> <name>rhs</name><operator>)</operator><operator>-&gt;</operator><name><name>counters</name><operator>.</operator><name>usage</name></name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>l_usage</name> <operator>&lt;</operator> <name>r_usage</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><name>l_usage</name> <operator>&gt;</operator> <name>r_usage</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><operator>+</operator><literal type="number">1</literal></expr>;</return></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Deallocate least used entries.
 * Caller must hold an exclusive lock on pgss-&gt;lock.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>pgss_entry_dealloc</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HASH_SEQ_STATUS</name></type> <name>hash_seq</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>pgssEntry</name> <modifier>*</modifier><modifier>*</modifier></type><name>entries</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>pgssEntry</name>  <modifier>*</modifier></type><name>entry</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>nvictims</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Sort entries by usage and deallocate USAGE_DEALLOC_PERCENT of them.
	 * While we're scanning the table, apply the decay factor to the usage
	 * values.
	 */</comment>
	<expr_stmt><expr><name>entries</name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><call><name>hash_get_num_entries</name><argument_list>(<argument><expr><name>polar_stat_sql_hash</name></expr></argument>)</argument_list></call> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>pgssEntry</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>hash_seq_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>hash_seq</name></expr></argument>, <argument><expr><name>polar_stat_sql_hash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<while>while <condition>(<expr><operator>(</operator><name>entry</name> <operator>=</operator> <call><name>hash_seq_search</name><argument_list>(<argument><expr><operator>&amp;</operator><name>hash_seq</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>entries</name><index>[<expr><name>i</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>entry</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>counters</name><operator>.</operator><name>usage</name></name> <operator>*=</operator> <name>USAGE_DECREASE_FACTOR</name></expr>;</expr_stmt>
	</block_content>}</block></while>

	<expr_stmt><expr><call><name>qsort</name><argument_list>(<argument><expr><name>entries</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>pgssEntry</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>entry_cmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>nvictims</name> <operator>=</operator> <call><name>Max</name><argument_list>(<argument><expr><literal type="number">10</literal></expr></argument>, <argument><expr><name>i</name> <operator>*</operator> <name>USAGE_DEALLOC_PERCENT</name> <operator>/</operator> <literal type="number">100</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>nvictims</name> <operator>=</operator> <call><name>Min</name><argument_list>(<argument><expr><name>nvictims</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nvictims</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><call><name>hash_search</name><argument_list>(<argument><expr><name>polar_stat_sql_hash</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>entries</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>key</name></expr></argument>, <argument><expr><name>HASH_REMOVE</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>entries</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>pgss_entry_reset</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HASH_SEQ_STATUS</name></type> <name>hash_seq</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>pgssEntry</name>  <modifier>*</modifier></type><name>entry</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name><name>pgss</name><operator>-&gt;</operator><name>lock</name></name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>hash_seq_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>hash_seq</name></expr></argument>, <argument><expr><name>polar_stat_sql_hash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<while>while <condition>(<expr><operator>(</operator><name>entry</name> <operator>=</operator> <call><name>hash_seq_search</name><argument_list>(<argument><expr><operator>&amp;</operator><name>hash_seq</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>hash_search</name><argument_list>(<argument><expr><name>polar_stat_sql_hash</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>entry</name><operator>-&gt;</operator><name>key</name></name></expr></argument>, <argument><expr><name>HASH_REMOVE</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></while>

	<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name><name>pgss</name><operator>-&gt;</operator><name>lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Hooks
 */</comment>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>polar_stat_ExecutorStart</name> <parameter_list>(<parameter><decl><type><name>QueryDesc</name> <modifier>*</modifier></type><name>queryDesc</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>eflags</name></decl></parameter>)</parameter_list>
<block>{<block_content>

	<expr_stmt><expr><name>is_sql_sampled</name> <operator>=</operator> <operator>(</operator><call><name>random</name><argument_list>()</argument_list></call> <operator>&lt;=</operator> <operator>(</operator><name>MAX_RANDOM_VALUE</name> <operator>*</operator> <name>polar_ss_sample_rate</name><operator>)</operator><operator>)</operator></expr>;</expr_stmt>
	<expr_stmt><expr><name>is_stat_enable</name> <operator>=</operator> <name>polar_ss_enable_stat</name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>is_stat_enable</name> <operator>&amp;&amp;</operator> <name><name>queryDesc</name><operator>-&gt;</operator><name>polar_sql_info</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition> 
	<block>{<block_content>
		<expr_stmt><expr><name><name>queryDesc</name><operator>-&gt;</operator><name>polar_sql_info</name></name> <operator>=</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>PolarStatSqlCollector</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>is_stat_enable</name> <operator>&amp;&amp;</operator> <name>is_sql_sampled</name></expr>)</condition> <block>{<block_content>
 
		<comment type="block">/* capture kernel usage stats in rusage_start */</comment>
		<if_stmt><if>if <condition>(<expr><name>polar_ss_getuage</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>getrusage</name><argument_list>(<argument><expr><name>RUSAGE_SELF</name></expr></argument>, <argument><expr><operator>&amp;</operator><operator>(</operator><name><name>queryDesc</name><operator>-&gt;</operator><name>polar_sql_info</name><operator>-&gt;</operator><name>rusage_start</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	

		<if_stmt><if>if <condition>(<expr><name>polar_enable_track_sql_time_stat</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>INSTR_TIME_SET_CURRENT</name><argument_list>(<argument><expr><name><name>queryDesc</name><operator>-&gt;</operator><name>polar_sql_info</name><operator>-&gt;</operator><name>polar_execute_start</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			
		</block_content>}</block></if></if_stmt>
		
		<comment type="block">/*
		* Enable per-node instrumentation if plan execute info is required.
		* We need set the instrument_options before the function standard_ExecutorStart
		*/</comment>
		<if_stmt><if>if <condition>(<expr><name><name>queryDesc</name><operator>-&gt;</operator><name>plannedstmt</name><operator>-&gt;</operator><name>queryId</name></name> <operator>!=</operator> <call><name>UINT64CONST</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call> 
			<operator>&amp;&amp;</operator> <name>polar_ss_gather_plan_info</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>queryDesc</name><operator>-&gt;</operator><name>instrument_options</name></name> <operator>|=</operator> <name>INSTRUMENT_POLAR_PLAN</name></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>polar_ss_plan_need_time</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>queryDesc</name><operator>-&gt;</operator><name>instrument_options</name></name> <operator>|=</operator> <name>INSTRUMENT_TIMER</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
				
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name><name>queryDesc</name><operator>-&gt;</operator><name>polar_sql_info</name><operator>-&gt;</operator><name>lwlock_stat_start</name></name> <operator>=</operator> <name>polar_lwlock_stat_local_summary</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>queryDesc</name><operator>-&gt;</operator><name>polar_sql_info</name><operator>-&gt;</operator><name>lock_stats_table_start</name></name></expr></argument>, <argument><expr><name>polar_lock_stat_local_summary</name></expr></argument>,
				<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>queryDesc</name><operator>-&gt;</operator><name>polar_sql_info</name><operator>-&gt;</operator><name>lock_stats_table_start</name></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>polar_collect_io_stat</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>queryDesc</name><operator>-&gt;</operator><name>polar_sql_info</name><operator>-&gt;</operator><name>start_io_stat</name></name></expr></argument>, <argument><expr><name>MyBackendId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* give control back to PostgreSQL */</comment>
	<if_stmt><if>if <condition>(<expr><name>prev_ExecutorStart</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>prev_ExecutorStart</name><argument_list>(<argument><expr><name>queryDesc</name></expr></argument>, <argument><expr><name>eflags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>standard_ExecutorStart</name><argument_list>(<argument><expr><name>queryDesc</name></expr></argument>, <argument><expr><name>eflags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * ExecutorRun hook: all we need do is track nesting depth
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>polar_stat_ExecutorRun</name><parameter_list>(<parameter><decl><type><name>QueryDesc</name> <modifier>*</modifier></type><name>queryDesc</name></decl></parameter>, <parameter><decl><type><name>ScanDirection</name></type> <name>direction</name></decl></parameter>, <parameter><decl><type><name>uint64</name></type> <name>count</name></decl></parameter>,
				 <parameter><decl><type><name>bool</name></type> <name>execute_once</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><name>nested_level</name><operator>++</operator></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PG_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>prev_ExecutorRun</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>prev_ExecutorRun</name><argument_list>(<argument><expr><name>queryDesc</name></expr></argument>, <argument><expr><name>direction</name></expr></argument>, <argument><expr><name>count</name></expr></argument>, <argument><expr><name>execute_once</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>standard_ExecutorRun</name><argument_list>(<argument><expr><name>queryDesc</name></expr></argument>, <argument><expr><name>direction</name></expr></argument>, <argument><expr><name>count</name></expr></argument>, <argument><expr><name>execute_once</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
		<expr_stmt><expr><name>nested_level</name><operator>--</operator></expr>;</expr_stmt>
	</block_content>}</block>
	<expr_stmt><expr><call><name>PG_CATCH</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<block>{<block_content>
		<expr_stmt><expr><name>nested_level</name><operator>--</operator></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>PG_RE_THROW</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
	<expr_stmt><expr><call><name>PG_END_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * ExecutorFinish hook: all we need do is track nesting depth
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>polar_stat_ExecutorFinish</name><parameter_list>(<parameter><decl><type><name>QueryDesc</name> <modifier>*</modifier></type><name>queryDesc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><name>nested_level</name><operator>++</operator></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PG_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>prev_ExecutorFinish</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>prev_ExecutorFinish</name><argument_list>(<argument><expr><name>queryDesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>standard_ExecutorFinish</name><argument_list>(<argument><expr><name>queryDesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
		<expr_stmt><expr><name>nested_level</name><operator>--</operator></expr>;</expr_stmt>
	</block_content>}</block>
	<expr_stmt><expr><call><name>PG_CATCH</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<block>{<block_content>
		<expr_stmt><expr><name>nested_level</name><operator>--</operator></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>PG_RE_THROW</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
	<expr_stmt><expr><call><name>PG_END_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * ProcessUtility hook
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>polar_stat_ProcessUtility</name><parameter_list>(<parameter><decl><type><name>PlannedStmt</name> <modifier>*</modifier></type><name>pstmt</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>queryString</name></decl></parameter>,
					<parameter><decl><type><name>ProcessUtilityContext</name></type> <name>context</name></decl></parameter>,
					<parameter><decl><type><name>ParamListInfo</name></type> <name>params</name></decl></parameter>, <parameter><decl><type><name>QueryEnvironment</name> <modifier>*</modifier></type><name>queryEnv</name></decl></parameter>,
					<parameter><decl><type><name>DestReceiver</name> <modifier>*</modifier></type><name>dest</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>completionTag</name></decl></parameter>)</parameter_list>
<block>{<block_content>
		<expr_stmt><expr><name>nested_level</name><operator>++</operator></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>PG_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>prev_ProcessUtility</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>prev_ProcessUtility</name><argument_list>(<argument><expr><name>pstmt</name></expr></argument>, <argument><expr><name>queryString</name></expr></argument>,
									<argument><expr><name>context</name></expr></argument>, <argument><expr><name>params</name></expr></argument>, <argument><expr><name>queryEnv</name></expr></argument>,
									<argument><expr><name>dest</name></expr></argument>, <argument><expr><name>completionTag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>standard_ProcessUtility</name><argument_list>(<argument><expr><name>pstmt</name></expr></argument>, <argument><expr><name>queryString</name></expr></argument>,
										<argument><expr><name>context</name></expr></argument>, <argument><expr><name>params</name></expr></argument>, <argument><expr><name>queryEnv</name></expr></argument>,
										<argument><expr><name>dest</name></expr></argument>, <argument><expr><name>completionTag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
			<expr_stmt><expr><name>nested_level</name><operator>--</operator></expr>;</expr_stmt>
		</block_content>}</block>
		<expr_stmt><expr><call><name>PG_CATCH</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<block>{<block_content>
			<expr_stmt><expr><name>nested_level</name><operator>--</operator></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>PG_RE_THROW</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>
		<expr_stmt><expr><call><name>PG_END_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>polar_stat_ExecutorEnd</name> <parameter_list>(<parameter><decl><type><name>QueryDesc</name> <modifier>*</modifier></type><name>queryDesc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>pgss_queryid</name></type> <name>queryId</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>rusage</name></name></type> <name>rusage_start</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>rusage</name></name></type> <name>rusage_end</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>pgssCounters</name></type> <name>counters</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>pgssPlanInfo</name></type> <name>planInfo</name> <init>= <expr><block>{<expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PolarCollectIoStat</name></type> <name>start_io_stat</name> <init>= <expr><block>{<expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PolarCollectIoStat</name></type> <name>end_io_stat</name> <init>= <expr><block>{<expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PolarCollectIoStat</name></type> <name>interval_io_stat</name> <init>= <expr><block>{<expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt>
	

	<if_stmt><if>if <condition>(<expr><name>is_stat_enable</name> <operator>&amp;&amp;</operator> <name>is_sql_sampled</name></expr>)</condition> <block>{<block_content>
		
		<comment type="block">/* capture kernel usage stats in rusage_end */</comment>
		<if_stmt><if>if <condition>(<expr><name>polar_ss_getuage</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>getrusage</name><argument_list>(<argument><expr><name>RUSAGE_SELF</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rusage_end</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>polar_enable_track_sql_time_stat</name> 
			<operator>&amp;&amp;</operator> <operator>!</operator> <operator>(</operator><call><name>INSTR_TIME_IS_ZERO</name><argument_list>(<argument><expr><name><name>queryDesc</name><operator>-&gt;</operator><name>polar_sql_info</name><operator>-&gt;</operator><name>polar_execute_start</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>instr_time</name></type> <name>end</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>uint64</name></type> <name>diff</name></decl>;</decl_stmt>
			<expr_stmt><expr><call><name>INSTR_TIME_SET_CURRENT</name><argument_list>(<argument><expr><name>end</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>diff</name> <operator>=</operator> <call><name>INSTR_TIME_GET_MICROSEC</name><argument_list>(<argument><expr><name>end</name></expr></argument>)</argument_list></call> <operator>-</operator> <call><name>INSTR_TIME_GET_MICROSEC</name><argument_list>(<argument><expr><name><name>queryDesc</name><operator>-&gt;</operator><name>polar_sql_info</name><operator>-&gt;</operator><name>polar_execute_start</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>polar_sql_time_stat_local_summary</name><operator>.</operator><name>execute_time</name></name> <operator>=</operator> <name>diff</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* gather plan nodes information */</comment>
		<if_stmt><if>if <condition>(<expr><name>polar_ss_gather_plan_info</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>pgss_stat_plan_node</name><argument_list>(<argument><expr><name><name>queryDesc</name><operator>-&gt;</operator><name>planstate</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>planInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>queryId</name> <operator>=</operator> <name><name>queryDesc</name><operator>-&gt;</operator><name>plannedstmt</name><operator>-&gt;</operator><name>queryId</name></name></expr>;</expr_stmt>

		<expr_stmt><expr><name>rusage_start</name> <operator>=</operator> <name><name>queryDesc</name><operator>-&gt;</operator><name>polar_sql_info</name><operator>-&gt;</operator><name>rusage_start</name></name></expr>;</expr_stmt>
		<comment type="block">/* Compute CPU time delta */</comment>
		<expr_stmt><expr><name><name>counters</name><operator>.</operator><name>utime</name></name> <operator>=</operator> <literal type="number">1000.0</literal> <operator>*</operator> <call><name>TIMEVAL_DIFF</name><argument_list>(<argument><expr><name><name>rusage_start</name><operator>.</operator><name>ru_utime</name></name></expr></argument>, <argument><expr><name><name>rusage_end</name><operator>.</operator><name>ru_utime</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>counters</name><operator>.</operator><name>stime</name></name> <operator>=</operator> <literal type="number">1000.0</literal> <operator>*</operator> <call><name>TIMEVAL_DIFF</name><argument_list>(<argument><expr><name><name>rusage_start</name><operator>.</operator><name>ru_stime</name></name></expr></argument>, <argument><expr><name><name>rusage_end</name><operator>.</operator><name>ru_stime</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>queryDesc</name><operator>-&gt;</operator><name>totaltime</name></name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Make sure stats accumulation is done */</comment>
			<expr_stmt><expr><call><name>InstrEndLoop</name><argument_list>(<argument><expr><name><name>queryDesc</name><operator>-&gt;</operator><name>totaltime</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			* We only consider values greater than 3 * linux tick, otherwise the
			* bias is too big
			*/</comment>
			<if_stmt><if>if <condition>(<expr><name><name>queryDesc</name><operator>-&gt;</operator><name>totaltime</name><operator>-&gt;</operator><name>total</name></name> <operator>&lt;</operator> <operator>(</operator><literal type="number">3.</literal> <operator>/</operator> <name>pgss_linux_hz</name><operator>)</operator></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name><name>counters</name><operator>.</operator><name>stime</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>counters</name><operator>.</operator><name>utime</name></name> <operator>=</operator> <literal type="number">1000.0</literal> <operator>*</operator> <name><name>queryDesc</name><operator>-&gt;</operator><name>totaltime</name><operator>-&gt;</operator><name>total</name></name></expr>;</expr_stmt> 
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* Compute the rest of the counters */</comment>
		<expr_stmt><expr><name><name>counters</name><operator>.</operator><name>minflts</name></name> <operator>=</operator> <name><name>rusage_end</name><operator>.</operator><name>ru_minflt</name></name> <operator>-</operator> <name><name>rusage_start</name><operator>.</operator><name>ru_minflt</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>counters</name><operator>.</operator><name>majflts</name></name> <operator>=</operator> <name><name>rusage_end</name><operator>.</operator><name>ru_majflt</name></name> <operator>-</operator> <name><name>rusage_start</name><operator>.</operator><name>ru_majflt</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>counters</name><operator>.</operator><name>nswaps</name></name> <operator>=</operator> <name><name>rusage_end</name><operator>.</operator><name>ru_nswap</name></name> <operator>-</operator> <name><name>rusage_start</name><operator>.</operator><name>ru_nswap</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>counters</name><operator>.</operator><name>reads</name></name> <operator>=</operator> <name><name>rusage_end</name><operator>.</operator><name>ru_inblock</name></name> <operator>-</operator> <name><name>rusage_start</name><operator>.</operator><name>ru_inblock</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>counters</name><operator>.</operator><name>writes</name></name> <operator>=</operator> <name><name>rusage_end</name><operator>.</operator><name>ru_oublock</name></name> <operator>-</operator> <name><name>rusage_start</name><operator>.</operator><name>ru_oublock</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>counters</name><operator>.</operator><name>msgsnds</name></name> <operator>=</operator> <name><name>rusage_end</name><operator>.</operator><name>ru_msgsnd</name></name> <operator>-</operator> <name><name>rusage_start</name><operator>.</operator><name>ru_msgsnd</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>counters</name><operator>.</operator><name>msgrcvs</name></name> <operator>=</operator> <name><name>rusage_end</name><operator>.</operator><name>ru_msgrcv</name></name> <operator>-</operator> <name><name>rusage_start</name><operator>.</operator><name>ru_msgrcv</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>counters</name><operator>.</operator><name>nsignals</name></name> <operator>=</operator> <name><name>rusage_end</name><operator>.</operator><name>ru_nsignals</name></name> <operator>-</operator> <name><name>rusage_start</name><operator>.</operator><name>ru_nsignals</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>counters</name><operator>.</operator><name>nvcsws</name></name> <operator>=</operator> <name><name>rusage_end</name><operator>.</operator><name>ru_nvcsw</name></name> <operator>-</operator> <name><name>rusage_start</name><operator>.</operator><name>ru_nvcsw</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>counters</name><operator>.</operator><name>nivcsws</name></name> <operator>=</operator> <name><name>rusage_end</name><operator>.</operator><name>ru_nivcsw</name></name> <operator>-</operator> <name><name>rusage_start</name><operator>.</operator><name>ru_nivcsw</name></name></expr>;</expr_stmt>

		

		<comment type="block">/* If disable getuage, memset the counters */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>polar_ss_getuage</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>counters</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>counters</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>polar_collect_io_stat</name><argument_list>(<argument><expr><operator>&amp;</operator><name>end_io_stat</name></expr></argument>, <argument><expr><name>MyBackendId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>start_io_stat</name> <operator>=</operator> <name><name>queryDesc</name><operator>-&gt;</operator><name>polar_sql_info</name><operator>-&gt;</operator><name>start_io_stat</name></name></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>interval_io_stat</name><operator>.</operator><name>shared_read_ps</name></name> <operator>=</operator> <name><name>end_io_stat</name><operator>.</operator><name>shared_read_ps</name></name> <operator>-</operator> <name><name>start_io_stat</name><operator>.</operator><name>shared_read_ps</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>interval_io_stat</name><operator>.</operator><name>shared_write_ps</name></name> <operator>=</operator> <name><name>end_io_stat</name><operator>.</operator><name>shared_write_ps</name></name> <operator>-</operator> <name><name>start_io_stat</name><operator>.</operator><name>shared_write_ps</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>interval_io_stat</name><operator>.</operator><name>shared_read_throughput</name></name> <operator>=</operator> <name><name>end_io_stat</name><operator>.</operator><name>shared_read_throughput</name></name> <operator>-</operator> <name><name>start_io_stat</name><operator>.</operator><name>shared_read_throughput</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>interval_io_stat</name><operator>.</operator><name>shared_write_throughput</name></name> <operator>=</operator> <name><name>end_io_stat</name><operator>.</operator><name>shared_write_throughput</name></name> <operator>-</operator> <name><name>start_io_stat</name><operator>.</operator><name>shared_write_throughput</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>interval_io_stat</name><operator>.</operator><name>shared_read_latency</name></name> <operator>=</operator> <name><name>end_io_stat</name><operator>.</operator><name>shared_read_latency</name></name> <operator>-</operator> <name><name>start_io_stat</name><operator>.</operator><name>shared_read_latency</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>interval_io_stat</name><operator>.</operator><name>shared_write_latency</name></name> <operator>=</operator> <name><name>end_io_stat</name><operator>.</operator><name>shared_write_latency</name></name> <operator>-</operator> <name><name>start_io_stat</name><operator>.</operator><name>shared_write_latency</name></name></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>interval_io_stat</name><operator>.</operator><name>io_open_num</name></name> <operator>=</operator> <name><name>end_io_stat</name><operator>.</operator><name>io_open_num</name></name> <operator>-</operator> <name><name>start_io_stat</name><operator>.</operator><name>io_open_num</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>interval_io_stat</name><operator>.</operator><name>io_seek_count</name></name> <operator>=</operator> <name><name>end_io_stat</name><operator>.</operator><name>io_seek_count</name></name> <operator>-</operator> <name><name>start_io_stat</name><operator>.</operator><name>io_seek_count</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>interval_io_stat</name><operator>.</operator><name>io_open_time</name></name> <operator>=</operator> <name><name>end_io_stat</name><operator>.</operator><name>io_open_time</name></name> <operator>-</operator> <name><name>start_io_stat</name><operator>.</operator><name>io_open_time</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>interval_io_stat</name><operator>.</operator><name>io_seek_time</name></name> <operator>=</operator> <name><name>end_io_stat</name><operator>.</operator><name>io_seek_time</name></name> <operator>-</operator> <name><name>start_io_stat</name><operator>.</operator><name>io_seek_time</name></name></expr>;</expr_stmt>

		<comment type="block">/* store current number of block reads and writes */</comment>
		<expr_stmt><expr><call><name>pgss_entry_store</name><argument_list>(<argument><expr><name>queryId</name></expr></argument>, <argument><expr><name>counters</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>planInfo</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>interval_io_stat</name></expr></argument>, <argument><expr><name>queryDesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>queryDesc</name><operator>-&gt;</operator><name>polar_sql_info</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>queryDesc</name><operator>-&gt;</operator><name>polar_sql_info</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* give control back to PostgreSQL */</comment>
	<if_stmt><if>if <condition>(<expr><name>prev_ExecutorEnd</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>prev_ExecutorEnd</name><argument_list>(<argument><expr><name>queryDesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>standard_ExecutorEnd</name><argument_list>(<argument><expr><name>queryDesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

</block_content>}</block></function>

<comment type="block">/*
 * get hash nodes memory information.
 */</comment>
<function><type><specifier>static</specifier> <name>int64</name></type>
<name>get_hash_memory_info</name><parameter_list>(<parameter><decl><type><name>PlanState</name>  <modifier>*</modifier></type><name>planstate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HashState</name> <modifier>*</modifier></type><name>hashstate</name> <init>= <expr><operator>(</operator><name>HashState</name> <operator>*</operator><operator>)</operator><name>planstate</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int64</name></type> <name>spacePeakKb</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HashInstrumentation</name></type> <name>hinstrument</name> <init>= <expr><block>{<expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt>
	<comment type="block">/*
	 * In a parallel query, the leader process may or may not have run the
	 * hash join, and even if it did it may not have built a hash table due to
	 * timing (if it started late it might have seen no tuples in the outer
	 * relation and skipped building the hash table).  Therefore we have to be
	 * prepared to get instrumentation data from all participants.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>hashstate</name><operator>-&gt;</operator><name>hashtable</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>hinstrument</name><operator>.</operator><name>nbatch</name></name> <operator>=</operator> <name><name>hashstate</name><operator>-&gt;</operator><name>hashtable</name><operator>-&gt;</operator><name>nbatch</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>hinstrument</name><operator>.</operator><name>space_peak</name></name> <operator>=</operator> <name><name>hashstate</name><operator>-&gt;</operator><name>hashtable</name><operator>-&gt;</operator><name>spacePeak</name></name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/*
	 * Merge results from workers.  In the parallel-oblivious case, the
	 * results from all participants should be identical, except where
	 * participants didn't run the join at all so have no data.  In the
	 * parallel-aware case, we need to consider all the results.  Each worker
	 * may have seen a different subset of batches and we want to find the
	 * highest memory usage for any one batch across all batches.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>hashstate</name><operator>-&gt;</operator><name>shared_info</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>SharedHashInfo</name> <modifier>*</modifier></type><name>shared_info</name> <init>= <expr><name><name>hashstate</name><operator>-&gt;</operator><name>shared_info</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>shared_info</name><operator>-&gt;</operator><name>num_workers</name></name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>HashInstrumentation</name> <modifier>*</modifier></type><name>worker_hi</name> <init>= <expr><operator>&amp;</operator><name><name>shared_info</name><operator>-&gt;</operator><name>hinstrument</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>worker_hi</name></expr>)</condition>
			<block>{<block_content>
				<continue>continue;</continue>
			</block_content>}</block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>worker_hi</name><operator>-&gt;</operator><name>nbatch</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/*
				 * Normally every participant should agree on the number of
				 * batches too, but it's possible for a backend that started
				 * late and missed the whole join not to have the final nbatch
				 * number.  So we'll take the largest number.
				 */</comment>
				<expr_stmt><expr><name><name>hinstrument</name><operator>.</operator><name>nbatch</name></name> <operator>=</operator> <call><name>Max</name><argument_list>(<argument><expr><name><name>hinstrument</name><operator>.</operator><name>nbatch</name></name></expr></argument>, <argument><expr><name><name>worker_hi</name><operator>-&gt;</operator><name>nbatch</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<comment type="block">/*
				 * In a parallel-aware hash join, for now we report the
				 * maximum peak memory reported by any worker.
				 */</comment>
				<expr_stmt><expr><name><name>hinstrument</name><operator>.</operator><name>space_peak</name></name> <operator>=</operator>
					<call><name>Max</name><argument_list>(<argument><expr><name><name>hinstrument</name><operator>.</operator><name>space_peak</name></name></expr></argument>, <argument><expr><name><name>worker_hi</name><operator>-&gt;</operator><name>space_peak</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></for>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>hinstrument</name><operator>.</operator><name>nbatch</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>spacePeakKb</name> <operator>=</operator> <operator>(</operator><name><name>hinstrument</name><operator>.</operator><name>space_peak</name></name> <operator>+</operator> <literal type="number">1023</literal><operator>)</operator> <operator>/</operator> <literal type="number">1024</literal></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><name>spacePeakKb</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Statistical execution plan node information
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>pgss_stat_plan_node</name><parameter_list>(<parameter><decl><type><name>PlanState</name>  <modifier>*</modifier></type><name>planstate</name></decl></parameter>, <parameter><decl><type><name>pgssPlanInfo</name>  <modifier>*</modifier></type><name>planInfo</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Plan</name> <modifier>*</modifier></type><name>plan</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * if planstate or instrument is null, we should return.  
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>planstate</name> <operator>||</operator> <operator>!</operator><name><name>planstate</name><operator>-&gt;</operator><name>instrument</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>plan</name> <operator>=</operator> <name><name>planstate</name><operator>-&gt;</operator><name>plan</name></name></expr>;</expr_stmt>
	<comment type="block">/*
	* Make sure stats accumulation is done.  
	*/</comment>
	<expr_stmt><expr><call><name>InstrEndLoop</name><argument_list>(<argument><expr><name><name>planstate</name><operator>-&gt;</operator><name>instrument</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/*
	* In version 1.9, we only gather information about scan, join, sort agg/group_by hash nodes 
	*/</comment>
	<switch>switch <condition>(<expr><call><name>nodeTag</name><argument_list>(<argument><expr><name>plan</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>T_Scan</name></expr>:</case>
		<case>case <expr><name>T_SeqScan</name></expr>:</case>
		<case>case <expr><name>T_SampleScan</name></expr>:</case>
		<case>case <expr><name>T_IndexScan</name></expr>:</case>
		<case>case <expr><name>T_IndexOnlyScan</name></expr>:</case>
		<case>case <expr><name>T_BitmapIndexScan</name></expr>:</case>
		<case>case <expr><name>T_BitmapHeapScan</name></expr>:</case>
		<case>case <expr><name>T_TidScan</name></expr>:</case>
		<case>case <expr><name>T_SubqueryScan</name></expr>:</case>
		<case>case <expr><name>T_FunctionScan</name></expr>:</case>
		<case>case <expr><name>T_ValuesScan</name></expr>:</case>
		<case>case <expr><name>T_TableFuncScan</name></expr>:</case>
		<case>case <expr><name>T_CteScan</name></expr>:</case>
		<case>case <expr><name>T_NamedTuplestoreScan</name></expr>:</case>
		<case>case <expr><name>T_WorkTableScan</name></expr>:</case>
		<case>case <expr><name>T_ForeignScan</name></expr>:</case>
		<case>case <expr><name>T_CustomScan</name></expr>:</case>
			<expr_stmt><expr><name><name>planInfo</name><operator>-&gt;</operator><name>scan_rows</name></name> <operator>+=</operator> <name><name>planstate</name><operator>-&gt;</operator><name>instrument</name><operator>-&gt;</operator><name>ntuples</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>planInfo</name><operator>-&gt;</operator><name>scan_time</name></name> <operator>+=</operator> <literal type="number">1000.0</literal>
				<operator>*</operator> <name><name>planstate</name><operator>-&gt;</operator><name>instrument</name><operator>-&gt;</operator><name>total</name></name></expr>;</expr_stmt>   <comment type="block">/* Total scan_time (in milliseconds) */</comment>
			<expr_stmt><expr><name><name>planInfo</name><operator>-&gt;</operator><name>scan_count</name></name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_NestLoop</name></expr>:</case>
		<case>case <expr><name>T_MergeJoin</name></expr>:</case>
		<case>case <expr><name>T_HashJoin</name></expr>:</case> <expr_stmt><expr><name><name>planInfo</name><operator>-&gt;</operator><name>join_rows</name></name> <operator>+=</operator> <name><name>planstate</name><operator>-&gt;</operator><name>instrument</name><operator>-&gt;</operator><name>ntuples</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>planInfo</name><operator>-&gt;</operator><name>join_time</name></name> <operator>+=</operator> <literal type="number">1000.0</literal>
				<operator>*</operator> <name><name>planstate</name><operator>-&gt;</operator><name>instrument</name><operator>-&gt;</operator><name>total</name></name></expr>;</expr_stmt>   <comment type="block">/* Total join_time (in milliseconds) */</comment>
			<expr_stmt><expr><name><name>planInfo</name><operator>-&gt;</operator><name>join_count</name></name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_Sort</name></expr>:</case> <expr_stmt><expr><name><name>planInfo</name><operator>-&gt;</operator><name>sort_rows</name></name> <operator>+=</operator> <name><name>planstate</name><operator>-&gt;</operator><name>instrument</name><operator>-&gt;</operator><name>ntuples</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>planInfo</name><operator>-&gt;</operator><name>sort_time</name></name> <operator>+=</operator> <literal type="number">1000.0</literal>
				<operator>*</operator> <name><name>planstate</name><operator>-&gt;</operator><name>instrument</name><operator>-&gt;</operator><name>total</name></name></expr>;</expr_stmt>   <comment type="block">/* Total sort_time (in milliseconds) */</comment>
			<expr_stmt><expr><name><name>planInfo</name><operator>-&gt;</operator><name>sort_count</name></name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_Group</name></expr>:</case>
		<case>case <expr><name>T_Agg</name></expr>:</case> <expr_stmt><expr><name><name>planInfo</name><operator>-&gt;</operator><name>group_rows</name></name> <operator>+=</operator> <name><name>planstate</name><operator>-&gt;</operator><name>instrument</name><operator>-&gt;</operator><name>ntuples</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>planInfo</name><operator>-&gt;</operator><name>group_time</name></name> <operator>+=</operator> <literal type="number">1000.0</literal>
				<operator>*</operator> <name><name>planstate</name><operator>-&gt;</operator><name>instrument</name><operator>-&gt;</operator><name>total</name></name></expr>;</expr_stmt>   <comment type="block">/* Total total time (in milliseconds) */</comment>
			<expr_stmt><expr><name><name>planInfo</name><operator>-&gt;</operator><name>group_count</name></name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_Hash</name></expr>:</case> <expr_stmt><expr><name><name>planInfo</name><operator>-&gt;</operator><name>hash_rows</name></name> <operator>+=</operator> <name><name>planstate</name><operator>-&gt;</operator><name>instrument</name><operator>-&gt;</operator><name>ntuples</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>planInfo</name><operator>-&gt;</operator><name>hash_memory</name></name> <operator>+=</operator> <call><name>get_hash_memory_info</name><argument_list>(<argument><expr><name>planstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>   <comment type="block">/* KB */</comment>
			<expr_stmt><expr><name><name>planInfo</name><operator>-&gt;</operator><name>hash_count</name></name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
			<break>break;</break>
		<default>default:</default> <break>break;</break>
	</block_content>}</block></switch>

	<comment type="block">/* initPlan-s */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>planstate</name><operator>-&gt;</operator><name>initPlan</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>pgss_stat_subplan_node</name><argument_list>(<argument><expr><name><name>planstate</name><operator>-&gt;</operator><name>initPlan</name></name></expr></argument>, <argument><expr><name>planInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* lefttree */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>outerPlanState</name><argument_list>(<argument><expr><name>planstate</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>pgss_stat_plan_node</name><argument_list>(<argument><expr><call><name>outerPlanState</name><argument_list>(<argument><expr><name>planstate</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>planInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<comment type="block">/* righttree */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>innerPlanState</name><argument_list>(<argument><expr><name>planstate</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>pgss_stat_plan_node</name><argument_list>(<argument><expr><call><name>innerPlanState</name><argument_list>(<argument><expr><name>planstate</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>planInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<comment type="block">/* subPlan-s */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>planstate</name><operator>-&gt;</operator><name>subPlan</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>pgss_stat_subplan_node</name><argument_list>(<argument><expr><name><name>planstate</name><operator>-&gt;</operator><name>subPlan</name></name></expr></argument>, <argument><expr><name>planInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Statistical execution sub plan node information
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>pgss_stat_subplan_node</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>plans</name></decl></parameter>, <parameter><decl><type><name>pgssPlanInfo</name>  <modifier>*</modifier></type><name>planInfo</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lst</name></decl>;</decl_stmt>
	
	<macro><name>foreach</name><argument_list>(<argument>lst</argument>, <argument>plans</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>SubPlanState</name> <modifier>*</modifier></type><name>sps</name> <init>= <expr><operator>(</operator><name>SubPlanState</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lst</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>pgss_stat_plan_node</name><argument_list>(<argument><expr><name><name>sps</name><operator>-&gt;</operator><name>planstate</name></name></expr></argument>, <argument><expr><name>planInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
</block_content>}</block></function>

<comment type="block">/*
 * Calculate hash value for a key
 */</comment>
<function><type><specifier>static</specifier> <name>uint32</name></type>
<name>polar_stat_sql_hash_fn</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>key</name></decl></parameter>, <parameter><decl><type><name>Size</name></type> <name>keysize</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>pgssHashKey</name> <modifier>*</modifier></type><name>k</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>pgssHashKey</name> <operator>*</operator><operator>)</operator> <name>key</name></expr></init></decl>;</decl_stmt>

	<return>return <expr><call><name>hash_uint32</name><argument_list>(<argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <name><name>k</name><operator>-&gt;</operator><name>userid</name></name></expr></argument>)</argument_list></call> <operator>^</operator>
		<call><name>hash_uint32</name><argument_list>(<argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <name><name>k</name><operator>-&gt;</operator><name>dbid</name></name></expr></argument>)</argument_list></call> <operator>^</operator>
		<call><name>hash_uint32</name><argument_list>(<argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <name><name>k</name><operator>-&gt;</operator><name>queryid</name></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Compare two keys - zero means match
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>pgss_match_fn</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>key1</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>key2</name></decl></parameter>, <parameter><decl><type><name>Size</name></type> <name>keysize</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>pgssHashKey</name> <modifier>*</modifier></type><name>k1</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>pgssHashKey</name> <operator>*</operator><operator>)</operator> <name>key1</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>pgssHashKey</name> <modifier>*</modifier></type><name>k2</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>pgssHashKey</name> <operator>*</operator><operator>)</operator> <name>key2</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>k1</name><operator>-&gt;</operator><name>userid</name></name> <operator>==</operator> <name><name>k2</name><operator>-&gt;</operator><name>userid</name></name> <operator>&amp;&amp;</operator>
		<name><name>k1</name><operator>-&gt;</operator><name>dbid</name></name> <operator>==</operator> <name><name>k2</name><operator>-&gt;</operator><name>dbid</name></name> <operator>&amp;&amp;</operator>
		<name><name>k1</name><operator>-&gt;</operator><name>queryid</name></name> <operator>==</operator> <name><name>k2</name><operator>-&gt;</operator><name>queryid</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Reset statistics.
 */</comment>
<function><type><name>PGDLLEXPORT</name> <name>Datum</name></type>
<name>polar_stat_sql_reset</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>pgss</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"polar_stat_sql must be loaded via shared_preload_libraries"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>pgss_entry_reset</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PG_RETURN_VOID</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>PGDLLEXPORT</name> <name>Datum</name></type>
<name>polar_stat_sql</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>polar_stat_sql_internal</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><name>PGSS_V1_0</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><operator>(</operator><name>Datum</name><operator>)</operator> <literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><name>PGDLLEXPORT</name> <name>Datum</name></type>
<name>polar_stat_sql_1_0</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>polar_stat_sql_internal</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><name>PGSS_V1_0</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><operator>(</operator><name>Datum</name><operator>)</operator> <literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><name>PGDLLEXPORT</name> <name>Datum</name></type>
<name>polar_stat_sql_1_1</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>polar_stat_sql_internal</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><name>PGSS_V1_1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><operator>(</operator><name>Datum</name><operator>)</operator> <literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>polar_stat_sql_internal</name><parameter_list>(<parameter><decl><type><name>FunctionCallInfo</name></type> <name>fcinfo</name></decl></parameter>, <parameter><decl><type><name>pgssVersion</name></type> <name>api_version</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ReturnSetInfo</name>	<modifier>*</modifier></type><name>rsinfo</name> <init>= <expr><operator>(</operator><name>ReturnSetInfo</name> <operator>*</operator><operator>)</operator> <name><name>fcinfo</name><operator>-&gt;</operator><name>resultinfo</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type>	<name>per_query_ctx</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type>	<name>oldcontext</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleDesc</name></type>		<name>tupdesc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Tuplestorestate</name>	<modifier>*</modifier></type><name>tupstore</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HASH_SEQ_STATUS</name></type> <name>hash_seq</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>pgssEntry</name>		<modifier>*</modifier></type><name>entry</name></decl>;</decl_stmt>


	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>pgss</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"polar_stat_sql must be loaded via shared_preload_libraries"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<comment type="block">/* check to see if caller supports us returning a tuplestore */</comment>
	<if_stmt><if>if <condition>(<expr><name>rsinfo</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name>rsinfo</name></expr></argument>, <argument><expr><name>ReturnSetInfo</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"set-valued function called in context that cannot accept a set"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name><name>rsinfo</name><operator>-&gt;</operator><name>allowedModes</name></name> <operator>&amp;</operator> <name>SFRM_Materialize</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"materialize mode required, but it is not "</literal> \
							<literal type="string">"allowed in this context"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Switch into long-lived context to construct returned data structures */</comment>
	<expr_stmt><expr><name>per_query_ctx</name> <operator>=</operator> <name><name>rsinfo</name><operator>-&gt;</operator><name>econtext</name><operator>-&gt;</operator><name>ecxt_per_query_memory</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>oldcontext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>per_query_ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Build a tuple descriptor for our result type */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>get_call_result_type</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tupdesc</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>TYPEFUNC_COMPOSITE</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"return type must be a row type"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>tupstore</name> <operator>=</operator> <call><name>tuplestore_begin_heap</name><argument_list>(<argument><expr><name>true</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>work_mem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rsinfo</name><operator>-&gt;</operator><name>returnMode</name></name> <operator>=</operator> <name>SFRM_Materialize</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rsinfo</name><operator>-&gt;</operator><name>setResult</name></name> <operator>=</operator> <name>tupstore</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rsinfo</name><operator>-&gt;</operator><name>setDesc</name></name> <operator>=</operator> <name>tupdesc</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name><name>pgss</name><operator>-&gt;</operator><name>lock</name></name></expr></argument>, <argument><expr><name>LW_SHARED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>hash_seq_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>hash_seq</name></expr></argument>, <argument><expr><name>polar_stat_sql_hash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<while>while <condition>(<expr><operator>(</operator><name>entry</name> <operator>=</operator> <call><name>hash_seq_search</name><argument_list>(<argument><expr><operator>&amp;</operator><name>hash_seq</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Datum</name></type>			<name><name>values</name><index>[<expr><name>COL_POLAR_STAT_SQL_MAX</name></expr>]</index></name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>			<name><name>nulls</name><index>[<expr><name>COL_POLAR_STAT_SQL_MAX</name></expr>]</index></name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>pgssCounters</name></type>	<name>tmp</name></decl>;</decl_stmt>

		<decl_stmt><decl><type><name>int64</name></type>			<name>reads</name></decl>, <decl><type ref="prev"/><name>writes</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>values</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>values</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>nulls</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>nulls</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* copy counters to a local variable to keep locking time short */</comment>
		<block>{<block_content>
			<decl_stmt><decl><type><specifier>volatile</specifier> <name>pgssEntry</name> <modifier>*</modifier></type><name>e</name> <init>= <expr><operator>(</operator><specifier>volatile</specifier> <name>pgssEntry</name> <operator>*</operator><operator>)</operator> <name>entry</name></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>SpinLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>e</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>tmp</name> <operator>=</operator> <name><name>e</name><operator>-&gt;</operator><name>counters</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>SpinLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>e</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>

		<expr_stmt><expr><name><name>values</name><index>[<expr><name>COL_QUERY_ID</name></expr>]</index></name> <operator>=</operator> <call><name>Int64GetDatum</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>key</name><operator>.</operator><name>queryid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>values</name><index>[<expr><name>COL_USER_ID</name></expr>]</index></name> <operator>=</operator> <call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>key</name><operator>.</operator><name>userid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>values</name><index>[<expr><name>COL_DB_ID</name></expr>]</index></name> <operator>=</operator> <call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>key</name><operator>.</operator><name>dbid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>reads</name> <operator>=</operator> <name><name>tmp</name><operator>.</operator><name>reads</name></name> <operator>*</operator> <name>RUSAGE_BLOCK_SIZE</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>writes</name> <operator>=</operator> <name><name>tmp</name><operator>.</operator><name>writes</name></name> <operator>*</operator> <name>RUSAGE_BLOCK_SIZE</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>values</name><index>[<expr><name>COL_READS</name></expr>]</index></name> <operator>=</operator> <call><name>Int64GetDatumFast</name><argument_list>(<argument><expr><name>reads</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>values</name><index>[<expr><name>COL_WRITES</name></expr>]</index></name> <operator>=</operator> <call><name>Int64GetDatumFast</name><argument_list>(<argument><expr><name>writes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>values</name><index>[<expr><name>COL_USER_TIME</name></expr>]</index></name> <operator>=</operator> <call><name>Float8GetDatumFast</name><argument_list>(<argument><expr><name><name>tmp</name><operator>.</operator><name>utime</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>values</name><index>[<expr><name>COL_SYSTEM_TIME</name></expr>]</index></name> <operator>=</operator> <call><name>Float8GetDatumFast</name><argument_list>(<argument><expr><name><name>tmp</name><operator>.</operator><name>stime</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>values</name><index>[<expr><name>COL_MINFLTS</name></expr>]</index></name> <operator>=</operator> <call><name>Int64GetDatumFast</name><argument_list>(<argument><expr><name><name>tmp</name><operator>.</operator><name>minflts</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>values</name><index>[<expr><name>COL_MAJFLTS</name></expr>]</index></name> <operator>=</operator> <call><name>Int64GetDatumFast</name><argument_list>(<argument><expr><name><name>tmp</name><operator>.</operator><name>majflts</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>values</name><index>[<expr><name>COL_NSWAPS</name></expr>]</index></name> <operator>=</operator> <call><name>Int64GetDatumFast</name><argument_list>(<argument><expr><name><name>tmp</name><operator>.</operator><name>nswaps</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>values</name><index>[<expr><name>COL_MSGSNDS</name></expr>]</index></name> <operator>=</operator> <call><name>Int64GetDatumFast</name><argument_list>(<argument><expr><name><name>tmp</name><operator>.</operator><name>msgsnds</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>values</name><index>[<expr><name>COL_MSGRCVS</name></expr>]</index></name> <operator>=</operator> <call><name>Int64GetDatumFast</name><argument_list>(<argument><expr><name><name>tmp</name><operator>.</operator><name>msgrcvs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>values</name><index>[<expr><name>COL_NSIGNALS</name></expr>]</index></name> <operator>=</operator> <call><name>Int64GetDatumFast</name><argument_list>(<argument><expr><name><name>tmp</name><operator>.</operator><name>nsignals</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>values</name><index>[<expr><name>COL_NVCSWS</name></expr>]</index></name> <operator>=</operator> <call><name>Int64GetDatumFast</name><argument_list>(<argument><expr><name><name>tmp</name><operator>.</operator><name>nvcsws</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>values</name><index>[<expr><name>COL_NIVCSWS</name></expr>]</index></name> <operator>=</operator> <call><name>Int64GetDatumFast</name><argument_list>(<argument><expr><name><name>tmp</name><operator>.</operator><name>nivcsws</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		
		<expr_stmt><expr><name><name>values</name><index>[<expr><name>COL_SCAN_ROWS</name></expr>]</index></name> <operator>=</operator> <call><name>Float8GetDatumFast</name><argument_list>(<argument><expr><name><name>tmp</name><operator>.</operator><name>scan_rows</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>values</name><index>[<expr><name>COL_SCAN_TIME</name></expr>]</index></name> <operator>=</operator> <call><name>Float8GetDatumFast</name><argument_list>(<argument><expr><name><name>tmp</name><operator>.</operator><name>scan_time</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>values</name><index>[<expr><name>COL_SCAN_COUNT</name></expr>]</index></name> <operator>=</operator> <call><name>Int64GetDatumFast</name><argument_list>(<argument><expr><name><name>tmp</name><operator>.</operator><name>scan_count</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>values</name><index>[<expr><name>COL_JOIN_ROWS</name></expr>]</index></name> <operator>=</operator> <call><name>Float8GetDatumFast</name><argument_list>(<argument><expr><name><name>tmp</name><operator>.</operator><name>join_rows</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>values</name><index>[<expr><name>COL_JOIN_TIME</name></expr>]</index></name> <operator>=</operator> <call><name>Float8GetDatumFast</name><argument_list>(<argument><expr><name><name>tmp</name><operator>.</operator><name>join_time</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>values</name><index>[<expr><name>COL_JOIN_COUNT</name></expr>]</index></name> <operator>=</operator> <call><name>Int64GetDatumFast</name><argument_list>(<argument><expr><name><name>tmp</name><operator>.</operator><name>join_count</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>values</name><index>[<expr><name>COL_SORT_ROWS</name></expr>]</index></name> <operator>=</operator> <call><name>Float8GetDatumFast</name><argument_list>(<argument><expr><name><name>tmp</name><operator>.</operator><name>sort_rows</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>values</name><index>[<expr><name>COL_SORT_TIME</name></expr>]</index></name> <operator>=</operator> <call><name>Float8GetDatumFast</name><argument_list>(<argument><expr><name><name>tmp</name><operator>.</operator><name>sort_time</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>values</name><index>[<expr><name>COL_SORT_COUNT</name></expr>]</index></name> <operator>=</operator> <call><name>Int64GetDatumFast</name><argument_list>(<argument><expr><name><name>tmp</name><operator>.</operator><name>sort_count</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>values</name><index>[<expr><name>COL_GROUP_ROWS</name></expr>]</index></name> <operator>=</operator> <call><name>Float8GetDatumFast</name><argument_list>(<argument><expr><name><name>tmp</name><operator>.</operator><name>group_rows</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>values</name><index>[<expr><name>COL_GROUP_TIME</name></expr>]</index></name> <operator>=</operator> <call><name>Float8GetDatumFast</name><argument_list>(<argument><expr><name><name>tmp</name><operator>.</operator><name>group_time</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>values</name><index>[<expr><name>COl_GROUP_COUNT</name></expr>]</index></name> <operator>=</operator> <call><name>Int64GetDatumFast</name><argument_list>(<argument><expr><name><name>tmp</name><operator>.</operator><name>group_count</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>values</name><index>[<expr><name>COL_HASH_ROWS</name></expr>]</index></name> <operator>=</operator> <call><name>Float8GetDatumFast</name><argument_list>(<argument><expr><name><name>tmp</name><operator>.</operator><name>hash_rows</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>values</name><index>[<expr><name>COL_HASH_MEMORY</name></expr>]</index></name> <operator>=</operator> <call><name>Int64GetDatumFast</name><argument_list>(<argument><expr><name><name>tmp</name><operator>.</operator><name>hash_memory</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>values</name><index>[<expr><name>COL_HASH_COUNT</name></expr>]</index></name> <operator>=</operator> <call><name>Int64GetDatumFast</name><argument_list>(<argument><expr><name><name>tmp</name><operator>.</operator><name>hash_count</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>api_version</name> <operator>&gt;=</operator> <name>PGSS_V1_1</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>values</name><index>[<expr><name>COL_PARSE_TIME</name></expr>]</index></name> <operator>=</operator> <call><name>Float8GetDatumFast</name><argument_list>(<argument><expr><name><name>tmp</name><operator>.</operator><name>parse_time</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>values</name><index>[<expr><name>COL_ANALYZE_TIME</name></expr>]</index></name> <operator>=</operator> <call><name>Float8GetDatumFast</name><argument_list>(<argument><expr><name><name>tmp</name><operator>.</operator><name>analyze_time</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>values</name><index>[<expr><name>COL_REWRITE_TIME</name></expr>]</index></name> <operator>=</operator> <call><name>Float8GetDatumFast</name><argument_list>(<argument><expr><name><name>tmp</name><operator>.</operator><name>rewrite_time</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>values</name><index>[<expr><name>COL_PLAN_TIME</name></expr>]</index></name> <operator>=</operator> <call><name>Float8GetDatumFast</name><argument_list>(<argument><expr><name><name>tmp</name><operator>.</operator><name>plan_time</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>values</name><index>[<expr><name>COL_EXECUTE_TIME</name></expr>]</index></name> <operator>=</operator> <call><name>Float8GetDatumFast</name><argument_list>(<argument><expr><name><name>tmp</name><operator>.</operator><name>execute_time</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name><name>values</name><index>[<expr><name>COL_LWLOCK_WAIT</name></expr>]</index></name> <operator>=</operator> <call><name>Float8GetDatumFast</name><argument_list>(<argument><expr><name><name>tmp</name><operator>.</operator><name>lwlock_wait</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>values</name><index>[<expr><name>COL_REL_LOCK_WAIT</name></expr>]</index></name> <operator>=</operator> <call><name>Float8GetDatumFast</name><argument_list>(<argument><expr><name><name>tmp</name><operator>.</operator><name>rel_lock_wait</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>values</name><index>[<expr><name>COL_XACT_LOCK_WAIT</name></expr>]</index></name> <operator>=</operator> <call><name>Float8GetDatumFast</name><argument_list>(<argument><expr><name><name>tmp</name><operator>.</operator><name>xact_lock_wait</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>values</name><index>[<expr><name>COL_PAGE_LOCK_WAIT</name></expr>]</index></name> <operator>=</operator> <call><name>Float8GetDatumFast</name><argument_list>(<argument><expr><name><name>tmp</name><operator>.</operator><name>page_lock_wait</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>values</name><index>[<expr><name>COL_TUPLE_LOCK_WAIT</name></expr>]</index></name> <operator>=</operator> <call><name>Float8GetDatumFast</name><argument_list>(<argument><expr><name><name>tmp</name><operator>.</operator><name>tuple_lock_wait</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name><name>values</name><index>[<expr><name>COL_SHARED_READ_PS</name></expr>]</index></name> <operator>=</operator> <call><name>Int64GetDatumFast</name><argument_list>(<argument><expr><name><name>tmp</name><operator>.</operator><name>shared_read_ps</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>values</name><index>[<expr><name>COL_SHARED_WRITE_PS</name></expr>]</index></name> <operator>=</operator> <call><name>Int64GetDatumFast</name><argument_list>(<argument><expr><name><name>tmp</name><operator>.</operator><name>shared_write_ps</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>values</name><index>[<expr><name>COL_SHARED_READ_THROUGHPUT</name></expr>]</index></name> <operator>=</operator> <call><name>Int64GetDatumFast</name><argument_list>(<argument><expr><name><name>tmp</name><operator>.</operator><name>shared_read_throughput</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>values</name><index>[<expr><name>COL_SHARED_WRITE_THROUGHPUT</name></expr>]</index></name> <operator>=</operator> <call><name>Int64GetDatumFast</name><argument_list>(<argument><expr><name><name>tmp</name><operator>.</operator><name>shared_write_throughput</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>values</name><index>[<expr><name>COL_SHARED_READ_LATENCY</name></expr>]</index></name> <operator>=</operator> <call><name>Float8GetDatumFast</name><argument_list>(<argument><expr><name><name>tmp</name><operator>.</operator><name>shared_read_latency</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>values</name><index>[<expr><name>COL_SHARED_WRITE_LATENCY</name></expr>]</index></name> <operator>=</operator> <call><name>Float8GetDatumFast</name><argument_list>(<argument><expr><name><name>tmp</name><operator>.</operator><name>shared_write_latency</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>values</name><index>[<expr><name>COL_IO_OPEN_NUM</name></expr>]</index></name> <operator>=</operator> <call><name>Int64GetDatumFast</name><argument_list>(<argument><expr><name><name>tmp</name><operator>.</operator><name>io_open_num</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>values</name><index>[<expr><name>COL_IO_SEEK_COUNT</name></expr>]</index></name> <operator>=</operator> <call><name>Int64GetDatumFast</name><argument_list>(<argument><expr><name><name>tmp</name><operator>.</operator><name>io_seek_count</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>values</name><index>[<expr><name>COL_IO_OPEN_TIME</name></expr>]</index></name> <operator>=</operator> <call><name>Float8GetDatumFast</name><argument_list>(<argument><expr><name><name>tmp</name><operator>.</operator><name>io_open_time</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>values</name><index>[<expr><name>COL_IO_SEEK_TIME</name></expr>]</index></name> <operator>=</operator> <call><name>Float8GetDatumFast</name><argument_list>(<argument><expr><name><name>tmp</name><operator>.</operator><name>io_seek_time</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>tuplestore_putvalues</name><argument_list>(<argument><expr><name>tupstore</name></expr></argument>, <argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><name>values</name></expr></argument>, <argument><expr><name>nulls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></while>

	<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name><name>pgss</name><operator>-&gt;</operator><name>lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* clean up and return the tuplestore */</comment>
	<expr_stmt><expr><call><name>tuplestore_donestoring</name><argument_list>(<argument><expr><name>tupstore</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>pgsk_post_parse_analyze</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>query</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>prev_post_parse_analyze_hook</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>prev_post_parse_analyze_hook</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Record call times of each query type
	 */</comment>
	<expr_stmt><expr><call><name>record_query_type</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Add various query type to tuple.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>add_various_tuple</name><parameter_list>(<parameter><decl><type><name>Tuplestorestate</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>TupleDesc</name></type> <name>tdesc</name></decl></parameter>, <parameter><decl><type><name>char</name><modifier>*</modifier></type> <name>sqltype</name></decl></parameter>, <parameter><decl><type><name>char</name><modifier>*</modifier></type> <name>cmdtype</name></decl></parameter>,
					 <parameter><decl><type><specifier>const</specifier> <name>int</name></type> <name>arraylen</name></decl></parameter>, <parameter><decl><type><name>int64</name></type> <name>count</name></decl></parameter>, <parameter><decl><type><name>Datum</name> <modifier>*</modifier></type><name>values</name></decl></parameter>, 
					 <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>nulls</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>array_size</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>col</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><name>values</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Datum</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>array_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><name>nulls</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>array_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>values</name><index>[<expr><name>col</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <call><name>CStringGetTextDatum</name><argument_list>(<argument><expr><name>sqltype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>values</name><index>[<expr><name>col</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <call><name>CStringGetTextDatum</name><argument_list>(<argument><expr><name>cmdtype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>values</name><index>[<expr><name>col</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <call><name>Int64GetDatumFast</name><argument_list>(<argument><expr><name>count</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>col</name> <operator>&lt;=</operator> <name>arraylen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>tuplestore_putvalues</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>tdesc</name></expr></argument>, <argument><expr><name>values</name></expr></argument>, <argument><expr><name>nulls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Record call times of each query type
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>record_query_type</name><parameter_list>(<parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>query</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if<condition>(<expr><name>polar_pgsk_qps_monitor</name></expr>)</condition>
	<block>{<block_content>
		<switch>switch<condition>(<expr><name><name>query</name><operator>-&gt;</operator><name>commandType</name></name></expr>)</condition><block>{<block_content>
			<case>case <expr><name>CMD_SELECT</name></expr>:</case>
				<expr_stmt><expr><call><name>pg_atomic_add_fetch_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>query_type_stat</name><operator>-&gt;</operator><name>select_count</name></name><operator>)</operator></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>CMD_UPDATE</name></expr>:</case>
				<expr_stmt><expr><call><name>pg_atomic_add_fetch_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>query_type_stat</name><operator>-&gt;</operator><name>update_count</name></name><operator>)</operator></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>CMD_INSERT</name></expr>:</case>
				<expr_stmt><expr><call><name>pg_atomic_add_fetch_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>query_type_stat</name><operator>-&gt;</operator><name>insert_count</name></name><operator>)</operator></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>CMD_DELETE</name></expr>:</case>
				<expr_stmt><expr><call><name>pg_atomic_add_fetch_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>query_type_stat</name><operator>-&gt;</operator><name>delete_count</name></name><operator>)</operator></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>CMD_UTILITY</name></expr>:</case>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>query</name><operator>-&gt;</operator><name>utilityStmt</name></name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<switch>switch <condition>(<expr><name><name>query</name><operator>-&gt;</operator><name>utilityStmt</name><operator>-&gt;</operator><name>type</name></name></expr>)</condition>
				<block>{<block_content>
					<case>case <expr><name>T_ExplainStmt</name></expr>:</case>
						<expr_stmt><expr><call><name>pg_atomic_add_fetch_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>query_type_stat</name><operator>-&gt;</operator><name>explain_count</name></name><operator>)</operator></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<break>break;</break>
					<case>case <expr><name>T_CreateStmt</name></expr>:</case>
						<expr_stmt><expr><call><name>pg_atomic_add_fetch_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>query_type_stat</name><operator>-&gt;</operator><name>create_count</name></name><operator>)</operator></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<break>break;</break>
					<case>case <expr><name>T_DropStmt</name></expr>:</case>
						<expr_stmt><expr><call><name>pg_atomic_add_fetch_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>query_type_stat</name><operator>-&gt;</operator><name>drop_count</name></name><operator>)</operator></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<break>break;</break>
					<case>case <expr><name>T_RenameStmt</name></expr>:</case>
						<expr_stmt><expr><call><name>pg_atomic_add_fetch_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>query_type_stat</name><operator>-&gt;</operator><name>rename_count</name></name><operator>)</operator></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<break>break;</break>
					<case>case <expr><name>T_TruncateStmt</name></expr>:</case>
						<expr_stmt><expr><call><name>pg_atomic_add_fetch_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>query_type_stat</name><operator>-&gt;</operator><name>truncate_count</name></name><operator>)</operator></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<break>break;</break>
					<case>case <expr><name>T_CommentStmt</name></expr>:</case>
						<expr_stmt><expr><call><name>pg_atomic_add_fetch_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>query_type_stat</name><operator>-&gt;</operator><name>comment_count</name></name><operator>)</operator></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<break>break;</break>
					<case>case <expr><name>T_GrantStmt</name></expr>:</case>
						<expr_stmt><expr><call><name>pg_atomic_add_fetch_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>query_type_stat</name><operator>-&gt;</operator><name>grant_count</name></name><operator>)</operator></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<break>break;</break>
					<case>case <expr><name>T_LockStmt</name></expr>:</case>
						<expr_stmt><expr><call><name>pg_atomic_add_fetch_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>query_type_stat</name><operator>-&gt;</operator><name>lock_count</name></name><operator>)</operator></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<break>break;</break>
					<case>case <expr><name>T_AlterTableStmt</name></expr>:</case>
					<case>case <expr><name>T_AlterTableCmd</name></expr>:</case>
					<case>case <expr><name>T_AlterDomainStmt</name></expr>:</case>
					<case>case <expr><name>T_AlterDefaultPrivilegesStmt</name></expr>:</case>
					<case>case <expr><name>T_AlterFunctionStmt</name></expr>:</case>
					<case>case <expr><name>T_AlterSeqStmt</name></expr>:</case>
					<case>case <expr><name>T_AlterRoleStmt</name></expr>:</case>
					<case>case <expr><name>T_AlterDatabaseStmt</name></expr>:</case>
					<case>case <expr><name>T_AlterDatabaseSetStmt</name></expr>:</case>
					<case>case <expr><name>T_AlterRoleSetStmt</name></expr>:</case>
					<case>case <expr><name>T_AlterOpFamilyStmt</name></expr>:</case>
					<case>case <expr><name>T_AlterObjectDependsStmt</name></expr>:</case>
					<case>case <expr><name>T_AlterObjectSchemaStmt</name></expr>:</case>
					<case>case <expr><name>T_AlterOwnerStmt</name></expr>:</case>
					<case>case <expr><name>T_AlterOperatorStmt</name></expr>:</case>
					<case>case <expr><name>T_AlterEnumStmt</name></expr>:</case>
					<case>case <expr><name>T_AlterTSDictionaryStmt</name></expr>:</case>
					<case>case <expr><name>T_AlterTSConfigurationStmt</name></expr>:</case>
					<case>case <expr><name>T_AlterFdwStmt</name></expr>:</case>
					<case>case <expr><name>T_AlterForeignServerStmt</name></expr>:</case>
					<case>case <expr><name>T_AlterUserMappingStmt</name></expr>:</case>
					<case>case <expr><name>T_AlterTableSpaceOptionsStmt</name></expr>:</case>
					<case>case <expr><name>T_AlterTableMoveAllStmt</name></expr>:</case>
					<case>case <expr><name>T_AlterExtensionStmt</name></expr>:</case>
					<case>case <expr><name>T_AlterExtensionContentsStmt</name></expr>:</case>
					<case>case <expr><name>T_AlterEventTrigStmt</name></expr>:</case>
					<case>case <expr><name>T_AlterSystemStmt</name></expr>:</case>
					<case>case <expr><name>T_AlterPolicyStmt</name></expr>:</case>
					<case>case <expr><name>T_AlterPublicationStmt</name></expr>:</case>
					<case>case <expr><name>T_AlterSubscriptionStmt</name></expr>:</case>
					<case>case <expr><name>T_AlterCollationStmt</name></expr>:</case>
						<expr_stmt><expr><call><name>pg_atomic_add_fetch_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>query_type_stat</name><operator>-&gt;</operator><name>alter_count</name></name><operator>)</operator></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<break>break;</break>
					<default>default:</default>
						<break>break;</break>
				</block_content>}</block></switch>
				<break>break;</break>
			<default>default:</default>
				<break>break;</break>
		</block_content>}</block></switch>	
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>polar_stat_query_count</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><name>Datum</name></type>
<name>polar_stat_query_count</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>POLAR_QUERYTYPE_STAT_COLS</name> <init>= <expr><literal type="number">3</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>  			<name>index</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ReturnSetInfo</name> <modifier>*</modifier></type><name>rsinfo</name> <init>= <expr><operator>(</operator><name>ReturnSetInfo</name> <operator>*</operator><operator>)</operator> <name><name>fcinfo</name><operator>-&gt;</operator><name>resultinfo</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleDesc</name></type>	<name>tupdesc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Tuplestorestate</name> <modifier>*</modifier></type><name>tupstore</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>per_query_ctx</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcontext</name></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>Datum</name></type>		<name><name>values</name><index>[<expr><name>POLAR_QUERYTYPE_STAT_COLS</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name><name>nulls</name><index>[<expr><name>POLAR_QUERYTYPE_STAT_COLS</name></expr>]</index></name></decl>;</decl_stmt>

	<comment type="block">/* check to see if caller supports us returning a tuplestore */</comment>
	<if_stmt><if>if <condition>(<expr><name>rsinfo</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name>rsinfo</name></expr></argument>, <argument><expr><name>ReturnSetInfo</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"set-valued function called in context that cannot accept a set"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name><name>rsinfo</name><operator>-&gt;</operator><name>allowedModes</name></name> <operator>&amp;</operator> <name>SFRM_Materialize</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"materialize mode required, but it is not "</literal> \
						<literal type="string">"allowed in this context"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>tupdesc</name> <operator>=</operator> <call><name>CreateTemplateTupleDesc</name><argument_list>(<argument><expr><name>POLAR_QUERYTYPE_STAT_COLS</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>TupleDescInitEntry</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><operator>(</operator><name>AttrNumber</name><operator>)</operator> <name>index</name><operator>++</operator></expr></argument>, <argument><expr><literal type="string">"sql_type"</literal></expr></argument>,
						<argument><expr><name>TEXTOID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>TupleDescInitEntry</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><operator>(</operator><name>AttrNumber</name><operator>)</operator> <name>index</name><operator>++</operator></expr></argument>, <argument><expr><literal type="string">"cmp_type"</literal></expr></argument>,
						<argument><expr><name>TEXTOID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>					
	<expr_stmt><expr><call><name>TupleDescInitEntry</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><operator>(</operator><name>AttrNumber</name><operator>)</operator> <name>index</name><operator>++</operator></expr></argument>, <argument><expr><literal type="string">"count"</literal></expr></argument>,
						<argument><expr><name>INT8OID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>index</name> <operator>-</operator> <literal type="number">1</literal> <operator>&lt;=</operator> <name>POLAR_QUERYTYPE_STAT_COLS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>per_query_ctx</name> <operator>=</operator> <name><name>rsinfo</name><operator>-&gt;</operator><name>econtext</name><operator>-&gt;</operator><name>ecxt_per_query_memory</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>oldcontext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>per_query_ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>tupstore</name> <operator>=</operator> <call><name>tuplestore_begin_heap</name><argument_list>(<argument><expr><name>true</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>work_mem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rsinfo</name><operator>-&gt;</operator><name>returnMode</name></name> <operator>=</operator> <name>SFRM_Materialize</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rsinfo</name><operator>-&gt;</operator><name>setResult</name></name> <operator>=</operator> <name>tupstore</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rsinfo</name><operator>-&gt;</operator><name>setDesc</name></name> <operator>=</operator> <name>tupdesc</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* DQL */</comment>
	<expr_stmt><expr><call><name>add_various_tuple</name><argument_list>(<argument><expr><name>tupstore</name></expr></argument>, <argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><literal type="string">"DQL"</literal></expr></argument>, <argument><expr><literal type="string">"SELECT"</literal></expr></argument>, <argument><expr><name>POLAR_QUERYTYPE_STAT_COLS</name></expr></argument>,
					 <argument><expr><call><name>pg_atomic_read_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>query_type_stat</name><operator>-&gt;</operator><name>select_count</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr></argument>, 
					 <argument><expr><name>values</name></expr></argument>, <argument><expr><name>nulls</name></expr></argument>, <argument><expr><name>POLAR_QUERYTYPE_STAT_COLS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* DML */</comment>
	<expr_stmt><expr><call><name>add_various_tuple</name><argument_list>(<argument><expr><name>tupstore</name></expr></argument>, <argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><literal type="string">"DML"</literal></expr></argument>, <argument><expr><literal type="string">"INSERT"</literal></expr></argument>, <argument><expr><name>POLAR_QUERYTYPE_STAT_COLS</name></expr></argument>,
					 <argument><expr><call><name>pg_atomic_read_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>query_type_stat</name><operator>-&gt;</operator><name>insert_count</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr></argument>, 
					 <argument><expr><name>values</name></expr></argument>, <argument><expr><name>nulls</name></expr></argument>, <argument><expr><name>POLAR_QUERYTYPE_STAT_COLS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>add_various_tuple</name><argument_list>(<argument><expr><name>tupstore</name></expr></argument>, <argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><literal type="string">"DML"</literal></expr></argument>, <argument><expr><literal type="string">"UPDATE"</literal></expr></argument>, <argument><expr><name>POLAR_QUERYTYPE_STAT_COLS</name></expr></argument>,
					 <argument><expr><call><name>pg_atomic_read_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>query_type_stat</name><operator>-&gt;</operator><name>update_count</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr></argument>, 
					 <argument><expr><name>values</name></expr></argument>, <argument><expr><name>nulls</name></expr></argument>, <argument><expr><name>POLAR_QUERYTYPE_STAT_COLS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>add_various_tuple</name><argument_list>(<argument><expr><name>tupstore</name></expr></argument>, <argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><literal type="string">"DML"</literal></expr></argument>, <argument><expr><literal type="string">"DELETE"</literal></expr></argument>, <argument><expr><name>POLAR_QUERYTYPE_STAT_COLS</name></expr></argument>,
					 <argument><expr><call><name>pg_atomic_read_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>query_type_stat</name><operator>-&gt;</operator><name>delete_count</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr></argument>, 
					 <argument><expr><name>values</name></expr></argument>, <argument><expr><name>nulls</name></expr></argument>, <argument><expr><name>POLAR_QUERYTYPE_STAT_COLS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>add_various_tuple</name><argument_list>(<argument><expr><name>tupstore</name></expr></argument>, <argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><literal type="string">"DML"</literal></expr></argument>, <argument><expr><literal type="string">"EXPLAIN"</literal></expr></argument>, <argument><expr><name>POLAR_QUERYTYPE_STAT_COLS</name></expr></argument>,
					 <argument><expr><call><name>pg_atomic_read_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>query_type_stat</name><operator>-&gt;</operator><name>explain_count</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr></argument>, 
					 <argument><expr><name>values</name></expr></argument>, <argument><expr><name>nulls</name></expr></argument>, <argument><expr><name>POLAR_QUERYTYPE_STAT_COLS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>add_various_tuple</name><argument_list>(<argument><expr><name>tupstore</name></expr></argument>, <argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><literal type="string">"DML"</literal></expr></argument>, <argument><expr><literal type="string">"LOCKTABLE"</literal></expr></argument>, <argument><expr><name>POLAR_QUERYTYPE_STAT_COLS</name></expr></argument>,
					 <argument><expr><call><name>pg_atomic_read_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>query_type_stat</name><operator>-&gt;</operator><name>lock_count</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr></argument>, 
					 <argument><expr><name>values</name></expr></argument>, <argument><expr><name>nulls</name></expr></argument>, <argument><expr><name>POLAR_QUERYTYPE_STAT_COLS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* DDL */</comment>
	<expr_stmt><expr><call><name>add_various_tuple</name><argument_list>(<argument><expr><name>tupstore</name></expr></argument>, <argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><literal type="string">"DDL"</literal></expr></argument>, <argument><expr><literal type="string">"CREATE"</literal></expr></argument>, <argument><expr><name>POLAR_QUERYTYPE_STAT_COLS</name></expr></argument>,
					 <argument><expr><call><name>pg_atomic_read_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>query_type_stat</name><operator>-&gt;</operator><name>create_count</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr></argument>, 
					 <argument><expr><name>values</name></expr></argument>, <argument><expr><name>nulls</name></expr></argument>, <argument><expr><name>POLAR_QUERYTYPE_STAT_COLS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>add_various_tuple</name><argument_list>(<argument><expr><name>tupstore</name></expr></argument>, <argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><literal type="string">"DDL"</literal></expr></argument>, <argument><expr><literal type="string">"DROP"</literal></expr></argument>, <argument><expr><name>POLAR_QUERYTYPE_STAT_COLS</name></expr></argument>,
					 <argument><expr><call><name>pg_atomic_read_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>query_type_stat</name><operator>-&gt;</operator><name>drop_count</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr></argument>, 
					 <argument><expr><name>values</name></expr></argument>, <argument><expr><name>nulls</name></expr></argument>, <argument><expr><name>POLAR_QUERYTYPE_STAT_COLS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>add_various_tuple</name><argument_list>(<argument><expr><name>tupstore</name></expr></argument>, <argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><literal type="string">"DDL"</literal></expr></argument>, <argument><expr><literal type="string">"RENAME"</literal></expr></argument>, <argument><expr><name>POLAR_QUERYTYPE_STAT_COLS</name></expr></argument>,
					 <argument><expr><call><name>pg_atomic_read_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>query_type_stat</name><operator>-&gt;</operator><name>rename_count</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr></argument>, 
					 <argument><expr><name>values</name></expr></argument>, <argument><expr><name>nulls</name></expr></argument>, <argument><expr><name>POLAR_QUERYTYPE_STAT_COLS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>add_various_tuple</name><argument_list>(<argument><expr><name>tupstore</name></expr></argument>, <argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><literal type="string">"DDL"</literal></expr></argument>, <argument><expr><literal type="string">"TRUNCATE"</literal></expr></argument>, <argument><expr><name>POLAR_QUERYTYPE_STAT_COLS</name></expr></argument>,
					 <argument><expr><call><name>pg_atomic_read_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>query_type_stat</name><operator>-&gt;</operator><name>truncate_count</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr></argument>, 
					 <argument><expr><name>values</name></expr></argument>, <argument><expr><name>nulls</name></expr></argument>, <argument><expr><name>POLAR_QUERYTYPE_STAT_COLS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>add_various_tuple</name><argument_list>(<argument><expr><name>tupstore</name></expr></argument>, <argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><literal type="string">"DDL"</literal></expr></argument>, <argument><expr><literal type="string">"COMMENT"</literal></expr></argument>, <argument><expr><name>POLAR_QUERYTYPE_STAT_COLS</name></expr></argument>,
					 <argument><expr><call><name>pg_atomic_read_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>query_type_stat</name><operator>-&gt;</operator><name>comment_count</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr></argument>, 
					 <argument><expr><name>values</name></expr></argument>, <argument><expr><name>nulls</name></expr></argument>, <argument><expr><name>POLAR_QUERYTYPE_STAT_COLS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>add_various_tuple</name><argument_list>(<argument><expr><name>tupstore</name></expr></argument>, <argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><literal type="string">"DDL"</literal></expr></argument>, <argument><expr><literal type="string">"ALTER"</literal></expr></argument>, <argument><expr><name>POLAR_QUERYTYPE_STAT_COLS</name></expr></argument>,
					 <argument><expr><call><name>pg_atomic_read_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>query_type_stat</name><operator>-&gt;</operator><name>alter_count</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr></argument>, 
					 <argument><expr><name>values</name></expr></argument>, <argument><expr><name>nulls</name></expr></argument>, <argument><expr><name>POLAR_QUERYTYPE_STAT_COLS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* DCL */</comment>
	<expr_stmt><expr><call><name>add_various_tuple</name><argument_list>(<argument><expr><name>tupstore</name></expr></argument>, <argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><literal type="string">"DCL"</literal></expr></argument>, <argument><expr><literal type="string">"GRANT"</literal></expr></argument>, <argument><expr><name>POLAR_QUERYTYPE_STAT_COLS</name></expr></argument>,
					 <argument><expr><call><name>pg_atomic_read_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>query_type_stat</name><operator>-&gt;</operator><name>grant_count</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr></argument>, 
					 <argument><expr><name>values</name></expr></argument>, <argument><expr><name>nulls</name></expr></argument>, <argument><expr><name>POLAR_QUERYTYPE_STAT_COLS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* clean up and return the tuplestore */</comment>
	<expr_stmt><expr><call><name>tuplestore_donestoring</name><argument_list>(<argument><expr><name>tupstore</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	
	<return>return <expr><operator>(</operator><name>Datum</name><operator>)</operator> <literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>
</unit>
