<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/PolarDB-for-PostgreSQL/src/test/modules/test_px/test_px.c"><cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;pg_config.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;time.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;unistd.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/types.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/wait.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"common/relpath.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/execnodes.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/plannodes.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/bufmgr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/elog.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"px/px_mutate.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"px/px_plan.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"px/px_hash.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"px/px_snapshot.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"px/px_gang.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/px_walkers.h"</cpp:file></cpp:include>

<expr_stmt><expr><name>PG_MODULE_MAGIC</name></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>FAULT_INJECTOR</name></cpp:ifdef>
<typedef>typedef <type><struct>struct
<block>{
	<decl_stmt><decl><type><name>plan_tree_base_prefix</name></type> <name>base</name></decl>;</decl_stmt> <comment type="block">/* Required prefix for
								 * plan_tree_walker/mutator */</comment>
	<decl_stmt><decl><type><name>EState</name>	   <modifier>*</modifier></type><name>estate</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>single_row_insert</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>cursorPositions</name></decl>;</decl_stmt>
}</block></struct></type> <name>pre_dispatch_function_evaluation_context</name>;</typedef>

<typedef>typedef <type><enum>enum
<block>{
	<decl><name>PQTRANS_IDLE</name></decl>,				<comment type="block">/* connection idle */</comment>
	<decl><name>PQTRANS_ACTIVE</name></decl>,				<comment type="block">/* command in progress */</comment>
	<decl><name>PQTRANS_INTRANS</name></decl>,			<comment type="block">/* idle, within transaction block */</comment>
	<decl><name>PQTRANS_INERROR</name></decl>,			<comment type="block">/* idle, within failed transaction */</comment>
	<decl><name>PQTRANS_UNKNOWN</name></decl>				<comment type="block">/* cannot determine status */</comment>
}</block></enum></type> <name>PGTransactionStatusType</name>;</typedef>

<function_decl><type><specifier>extern</specifier> <name>Node</name><modifier>*</modifier></type> (<modifier>*</modifier><name>test_pre_dispatch_function_evaluation_mutator</name>)<parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>,
										 <parameter><decl><type><name>pre_dispatch_function_evaluation_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>extern</specifier> <specifier>const</specifier> <name>char</name><modifier>*</modifier></type> (<modifier>*</modifier><name>test_trans_status_to_string</name>)<parameter_list>(<parameter><decl><type><name>PGTransactionStatusType</name></type> <name>status</name></decl></parameter>)</parameter_list>;</function_decl>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>test_lock_rows</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>new_node</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>LockRows</name> <modifier>*</modifier></type><name>lockrows</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>LockRows</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>pre_dispatch_function_evaluation_context</name></type> <name>pcontext</name></decl>;</decl_stmt>
	<expr_stmt><expr><name>new_node</name> <operator>=</operator> <call><name>plan_tree_mutator</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name><operator>*</operator><operator>)</operator><name>lockrows</name></expr></argument>,
									<argument><expr><operator>(</operator><operator>*</operator><name>test_pre_dispatch_function_evaluation_mutator</name><operator>)</operator></expr></argument>,
									<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>pcontext</name></expr></argument>,
									<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>new_node</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>test_repeat</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>new_node</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Repeat</name> <modifier>*</modifier></type><name>repeat</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>Repeat</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>pre_dispatch_function_evaluation_context</name></type> <name>pcontext</name></decl>;</decl_stmt>
	<expr_stmt><expr><name>new_node</name> <operator>=</operator> <call><name>plan_tree_mutator</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name><operator>*</operator><operator>)</operator><name>repeat</name></expr></argument>,
								<argument><expr><operator>(</operator><operator>*</operator><name>test_pre_dispatch_function_evaluation_mutator</name><operator>)</operator></expr></argument>,
								<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>pcontext</name></expr></argument>,
								<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>new_node</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>test_append</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>new_node</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Append</name> <modifier>*</modifier></type><name>append</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>Append</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>pre_dispatch_function_evaluation_context</name></type> <name>pcontext</name></decl>;</decl_stmt>
	<expr_stmt><expr><name>new_node</name> <operator>=</operator> <call><name>plan_tree_mutator</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name><operator>*</operator><operator>)</operator><name>append</name></expr></argument>,
								<argument><expr><operator>(</operator><operator>*</operator><name>test_pre_dispatch_function_evaluation_mutator</name><operator>)</operator></expr></argument>,
								<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>pcontext</name></expr></argument>,
								<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>new_node</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>test_mergeappend</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>new_node</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MergeAppend</name> <modifier>*</modifier></type><name>merge</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>MergeAppend</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>pre_dispatch_function_evaluation_context</name></type> <name>pcontext</name></decl>;</decl_stmt>
	<expr_stmt><expr><name>new_node</name> <operator>=</operator> <call><name>plan_tree_mutator</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name><operator>*</operator><operator>)</operator><name>merge</name></expr></argument>,
								<argument><expr><operator>(</operator><operator>*</operator><name>test_pre_dispatch_function_evaluation_mutator</name><operator>)</operator></expr></argument>,
								<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>pcontext</name></expr></argument>,
								<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>new_node</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>test_recursiveunion</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>new_node</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RecursiveUnion</name> <modifier>*</modifier></type><name>ru</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>RecursiveUnion</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>pre_dispatch_function_evaluation_context</name></type> <name>pcontext</name></decl>;</decl_stmt>
	<expr_stmt><expr><name>new_node</name> <operator>=</operator> <call><name>plan_tree_mutator</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name><operator>*</operator><operator>)</operator><name>ru</name></expr></argument>,
								<argument><expr><operator>(</operator><operator>*</operator><name>test_pre_dispatch_function_evaluation_mutator</name><operator>)</operator></expr></argument>,
								<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>pcontext</name></expr></argument>,
								<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>new_node</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>test_sequnce</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>new_node</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Sequence</name> <modifier>*</modifier></type><name>sequence</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>Sequence</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>pre_dispatch_function_evaluation_context</name></type> <name>pcontext</name></decl>;</decl_stmt>
	<expr_stmt><expr><name>new_node</name> <operator>=</operator> <call><name>plan_tree_mutator</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name><operator>*</operator><operator>)</operator><name>sequence</name></expr></argument>,
								<argument><expr><operator>(</operator><operator>*</operator><name>test_pre_dispatch_function_evaluation_mutator</name><operator>)</operator></expr></argument>,
								<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>pcontext</name></expr></argument>,
								<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>new_node</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>test_bitmapand</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>new_node</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BitmapAnd</name> <modifier>*</modifier></type><name>old</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>BitmapAnd</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>pre_dispatch_function_evaluation_context</name></type> <name>pcontext</name></decl>;</decl_stmt>
	<expr_stmt><expr><name>new_node</name> <operator>=</operator> <call><name>plan_tree_mutator</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name><operator>*</operator><operator>)</operator><name>old</name></expr></argument>,
								<argument><expr><operator>(</operator><operator>*</operator><name>test_pre_dispatch_function_evaluation_mutator</name><operator>)</operator></expr></argument>,
								<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>pcontext</name></expr></argument>,
								<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>new_node</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>test_bitmapor</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>new_node</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BitmapOr</name> <modifier>*</modifier></type><name>old</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>BitmapOr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>pre_dispatch_function_evaluation_context</name></type> <name>pcontext</name></decl>;</decl_stmt>
	<expr_stmt><expr><name>new_node</name> <operator>=</operator> <call><name>plan_tree_mutator</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name><operator>*</operator><operator>)</operator><name>old</name></expr></argument>,
								<argument><expr><operator>(</operator><operator>*</operator><name>test_pre_dispatch_function_evaluation_mutator</name><operator>)</operator></expr></argument>,
								<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>pcontext</name></expr></argument>,
								<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>new_node</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>test_scan</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>new_node</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Scan</name> <modifier>*</modifier></type><name>scan</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>Scan</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>pre_dispatch_function_evaluation_context</name></type> <name>pcontext</name></decl>;</decl_stmt>
	<comment type="block">/*
	 * We need the try-catch because plan_tree_mutator with T_Scan will
	 * repport an error. We don't want this test case stop.
	 */</comment>
	<expr_stmt><expr><call><name>PG_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<block>{<block_content>
		<expr_stmt><expr><name>new_node</name> <operator>=</operator> <call><name>plan_tree_mutator</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name><operator>*</operator><operator>)</operator><name>scan</name></expr></argument>,
									<argument><expr><operator>(</operator><operator>*</operator><name>test_pre_dispatch_function_evaluation_mutator</name><operator>)</operator></expr></argument>,
									<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>pcontext</name></expr></argument>,
									<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
	<expr_stmt><expr><call><name>PG_CATCH</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<block>{<block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>, <argument><expr><literal type="string">"Inject error test_scan"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
	<expr_stmt><expr><call><name>PG_END_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>new_node</name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>test_samplescan</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>new_node</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SampleScan</name> <modifier>*</modifier></type><name>samplescan</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>SampleScan</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>pre_dispatch_function_evaluation_context</name></type> <name>pcontext</name></decl>;</decl_stmt>
	<expr_stmt><expr><name>new_node</name> <operator>=</operator> <call><name>plan_tree_mutator</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name><operator>*</operator><operator>)</operator><name>samplescan</name></expr></argument>,
								<argument><expr><operator>(</operator><operator>*</operator><name>test_pre_dispatch_function_evaluation_mutator</name><operator>)</operator></expr></argument>,
								<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>pcontext</name></expr></argument>,
								<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>new_node</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>test_customscan</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>new_node</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CustomScan</name> <modifier>*</modifier></type><name>cscan</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>CustomScan</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>pre_dispatch_function_evaluation_context</name></type> <name>pcontext</name></decl>;</decl_stmt>
	<expr_stmt><expr><name>new_node</name> <operator>=</operator> <call><name>plan_tree_mutator</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name><operator>*</operator><operator>)</operator><name>cscan</name></expr></argument>,
								<argument><expr><operator>(</operator><operator>*</operator><name>test_pre_dispatch_function_evaluation_mutator</name><operator>)</operator></expr></argument>,
								<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>pcontext</name></expr></argument>,
								<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>new_node</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>test_indexonlyscan</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>new_node</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>IndexOnlyScan</name> <modifier>*</modifier></type><name>idxonlyscan</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>IndexOnlyScan</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>pre_dispatch_function_evaluation_context</name></type> <name>pcontext</name></decl>;</decl_stmt>
	<expr_stmt><expr><name>new_node</name> <operator>=</operator> <call><name>plan_tree_mutator</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name><operator>*</operator><operator>)</operator><name>idxonlyscan</name></expr></argument>,
								<argument><expr><operator>(</operator><operator>*</operator><name>test_pre_dispatch_function_evaluation_mutator</name><operator>)</operator></expr></argument>,
								<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>pcontext</name></expr></argument>,
								<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>new_node</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>test_bitmapindexscan</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>new_node</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BitmapIndexScan</name> <modifier>*</modifier></type><name>idxscan</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>BitmapIndexScan</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>pre_dispatch_function_evaluation_context</name></type> <name>pcontext</name></decl>;</decl_stmt>
	<expr_stmt><expr><name>new_node</name> <operator>=</operator> <call><name>plan_tree_mutator</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name><operator>*</operator><operator>)</operator><name>idxscan</name></expr></argument>,
								<argument><expr><operator>(</operator><operator>*</operator><name>test_pre_dispatch_function_evaluation_mutator</name><operator>)</operator></expr></argument>,
								<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>pcontext</name></expr></argument>,
								<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>new_node</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>test_bitmapheapscan</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>new_node</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BitmapHeapScan</name> <modifier>*</modifier></type><name>bmheapscan</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>BitmapHeapScan</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>pre_dispatch_function_evaluation_context</name></type> <name>pcontext</name></decl>;</decl_stmt>
	<expr_stmt><expr><name>new_node</name> <operator>=</operator> <call><name>plan_tree_mutator</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name><operator>*</operator><operator>)</operator><name>bmheapscan</name></expr></argument>,
								<argument><expr><operator>(</operator><operator>*</operator><name>test_pre_dispatch_function_evaluation_mutator</name><operator>)</operator></expr></argument>,
								<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>pcontext</name></expr></argument>,
								<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>new_node</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>test_tidscan</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>new_node</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TidScan</name> <modifier>*</modifier></type><name>tidscan</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>TidScan</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>pre_dispatch_function_evaluation_context</name></type> <name>pcontext</name></decl>;</decl_stmt>
	<expr_stmt><expr><name>new_node</name> <operator>=</operator> <call><name>plan_tree_mutator</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name><operator>*</operator><operator>)</operator><name>tidscan</name></expr></argument>,
								<argument><expr><operator>(</operator><operator>*</operator><name>test_pre_dispatch_function_evaluation_mutator</name><operator>)</operator></expr></argument>,
								<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>pcontext</name></expr></argument>,
								<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>new_node</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>test_subqueryscan</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>new_node</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SubqueryScan</name> <modifier>*</modifier></type><name>sqscan</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>SubqueryScan</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>pre_dispatch_function_evaluation_context</name></type> <name>pcontext</name></decl>;</decl_stmt>
	<expr_stmt><expr><name>new_node</name> <operator>=</operator> <call><name>plan_tree_mutator</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name><operator>*</operator><operator>)</operator><name>sqscan</name></expr></argument>,
								<argument><expr><operator>(</operator><operator>*</operator><name>test_pre_dispatch_function_evaluation_mutator</name><operator>)</operator></expr></argument>,
								<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>pcontext</name></expr></argument>,
								<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>new_node</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>test_valuesscan</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>new_node</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ValuesScan</name> <modifier>*</modifier></type><name>scan</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>ValuesScan</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>pre_dispatch_function_evaluation_context</name></type> <name>pcontext</name></decl>;</decl_stmt>
	<expr_stmt><expr><name>new_node</name> <operator>=</operator> <call><name>plan_tree_mutator</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name><operator>*</operator><operator>)</operator><name>scan</name></expr></argument>,
								<argument><expr><operator>(</operator><operator>*</operator><name>test_pre_dispatch_function_evaluation_mutator</name><operator>)</operator></expr></argument>,
								<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>pcontext</name></expr></argument>,
								<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>new_node</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>test_worktablescan</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>new_node</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>WorkTableScan</name> <modifier>*</modifier></type><name>wts</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>WorkTableScan</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>pre_dispatch_function_evaluation_context</name></type> <name>pcontext</name></decl>;</decl_stmt>
	<expr_stmt><expr><name>new_node</name> <operator>=</operator> <call><name>plan_tree_mutator</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name><operator>*</operator><operator>)</operator><name>wts</name></expr></argument>,
								<argument><expr><operator>(</operator><operator>*</operator><name>test_pre_dispatch_function_evaluation_mutator</name><operator>)</operator></expr></argument>,
								<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>pcontext</name></expr></argument>,
								<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>new_node</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>test_join</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>new_node</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Join</name> <modifier>*</modifier></type><name>join</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>Join</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>pre_dispatch_function_evaluation_context</name></type> <name>pcontext</name></decl>;</decl_stmt>
	<comment type="block">/*
	 * We need the try-catch because plan_tree_mutator with T_Join will
	 * repport an error. We don't want this test case stop.
	 */</comment>
	<expr_stmt><expr><call><name>PG_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<block>{<block_content>
		<expr_stmt><expr><name>new_node</name> <operator>=</operator> <call><name>plan_tree_mutator</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name><operator>*</operator><operator>)</operator><name>join</name></expr></argument>,
									<argument><expr><operator>(</operator><operator>*</operator><name>test_pre_dispatch_function_evaluation_mutator</name><operator>)</operator></expr></argument>,
									<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>pcontext</name></expr></argument>,
									<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
	<expr_stmt><expr><call><name>PG_CATCH</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<block>{<block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>, <argument><expr><literal type="string">"Inject error test_join"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
	<expr_stmt><expr><call><name>PG_END_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>new_node</name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>test_tablefuncscan</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>new_node</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TableFuncScan</name> <modifier>*</modifier></type><name>tabfunc</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>TableFuncScan</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>pre_dispatch_function_evaluation_context</name></type> <name>pcontext</name></decl>;</decl_stmt>
	<expr_stmt><expr><name>new_node</name> <operator>=</operator> <call><name>plan_tree_mutator</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name><operator>*</operator><operator>)</operator><name>tabfunc</name></expr></argument>,
								<argument><expr><operator>(</operator><operator>*</operator><name>test_pre_dispatch_function_evaluation_mutator</name><operator>)</operator></expr></argument>,
								<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>pcontext</name></expr></argument>,
								<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>new_node</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>test_unique</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>new_node</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Unique</name> <modifier>*</modifier></type><name>uniq</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>Unique</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>pre_dispatch_function_evaluation_context</name></type> <name>pcontext</name></decl>;</decl_stmt>
	<expr_stmt><expr><name>new_node</name> <operator>=</operator> <call><name>plan_tree_mutator</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name><operator>*</operator><operator>)</operator><name>uniq</name></expr></argument>,
								<argument><expr><operator>(</operator><operator>*</operator><name>test_pre_dispatch_function_evaluation_mutator</name><operator>)</operator></expr></argument>,
								<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>pcontext</name></expr></argument>,
								<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>new_node</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>test_gather</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>new_node</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Gather</name> <modifier>*</modifier></type><name>gather</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>Gather</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>pre_dispatch_function_evaluation_context</name></type> <name>pcontext</name></decl>;</decl_stmt>
	<expr_stmt><expr><name>new_node</name> <operator>=</operator> <call><name>plan_tree_mutator</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name><operator>*</operator><operator>)</operator><name>gather</name></expr></argument>,
								<argument><expr><operator>(</operator><operator>*</operator><name>test_pre_dispatch_function_evaluation_mutator</name><operator>)</operator></expr></argument>,
								<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>pcontext</name></expr></argument>,
								<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>new_node</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>test_setop</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>new_node</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SetOp</name> <modifier>*</modifier></type><name>setop</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>SetOp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>pre_dispatch_function_evaluation_context</name></type> <name>pcontext</name></decl>;</decl_stmt>
	<expr_stmt><expr><name>new_node</name> <operator>=</operator> <call><name>plan_tree_mutator</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name><operator>*</operator><operator>)</operator><name>setop</name></expr></argument>,
								<argument><expr><operator>(</operator><operator>*</operator><name>test_pre_dispatch_function_evaluation_mutator</name><operator>)</operator></expr></argument>,
								<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>pcontext</name></expr></argument>,
								<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>new_node</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>test_flow</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>new_node</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Flow</name> <modifier>*</modifier></type><name>flow</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>Flow</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>pre_dispatch_function_evaluation_context</name></type> <name>pcontext</name></decl>;</decl_stmt>
	<expr_stmt><expr><name>new_node</name> <operator>=</operator> <call><name>plan_tree_mutator</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name><operator>*</operator><operator>)</operator><name>flow</name></expr></argument>,
								<argument><expr><operator>(</operator><operator>*</operator><name>test_pre_dispatch_function_evaluation_mutator</name><operator>)</operator></expr></argument>,
								<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>pcontext</name></expr></argument>,
								<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>new_node</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>test_query</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>new_node</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Query</name> <modifier>*</modifier></type><name>query</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>Query</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>pre_dispatch_function_evaluation_context</name></type> <name>pcontext</name></decl>;</decl_stmt>
	<expr_stmt><expr><name>new_node</name> <operator>=</operator> <call><name>plan_tree_mutator</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name><operator>*</operator><operator>)</operator><name>query</name></expr></argument>,
								<argument><expr><operator>(</operator><operator>*</operator><name>test_pre_dispatch_function_evaluation_mutator</name><operator>)</operator></expr></argument>,
								<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>pcontext</name></expr></argument>,
								<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>new_node</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>test_subplan</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>new_node</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SubPlan</name> <modifier>*</modifier></type><name>subplan</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>SubPlan</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>pre_dispatch_function_evaluation_context</name> <modifier>*</modifier></type><name>pcontext</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name>new_node</name> <operator>=</operator> <call><name>plan_tree_mutator</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name><operator>*</operator><operator>)</operator><name>subplan</name></expr></argument>,
								<argument><expr><operator>(</operator><operator>*</operator><name>test_pre_dispatch_function_evaluation_mutator</name><operator>)</operator></expr></argument>,
								<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>pcontext</name></expr></argument>,
								<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>new_node</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>test_rangetblentry</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>new_node</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>RangeTblEntry</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>pre_dispatch_function_evaluation_context</name></type> <name>pcontext</name></decl>;</decl_stmt>
	<expr_stmt><expr><name><name>rte</name><operator>-&gt;</operator><name>ctename</name></name> <operator>=</operator> <operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><call><name>calloc</name><argument_list>(<argument><expr><literal type="number">10</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>char</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>ctename</name></name></expr></argument>, <argument><expr><literal type="string">"test"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rte</name><operator>-&gt;</operator><name>ctelevelsup</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rte</name><operator>-&gt;</operator><name>self_reference</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<comment type="block">/*RTE_SUBQUERY*/</comment>
	<expr_stmt><expr><name><name>rte</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>=</operator> <name>RTE_SUBQUERY</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>new_node</name> <operator>=</operator> <call><name>plan_tree_mutator</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name><operator>*</operator><operator>)</operator><name>rte</name></expr></argument>,
								<argument><expr><operator>(</operator><operator>*</operator><name>test_pre_dispatch_function_evaluation_mutator</name><operator>)</operator></expr></argument>,
								<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>pcontext</name></expr></argument>,
								<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>new_node</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>new_node</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<comment type="block">/*RTE_CTE*/</comment>
	<expr_stmt><expr><name><name>rte</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>=</operator> <name>RTE_CTE</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>new_node</name> <operator>=</operator> <call><name>plan_tree_mutator</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name><operator>*</operator><operator>)</operator><name>rte</name></expr></argument>,
								<argument><expr><operator>(</operator><operator>*</operator><name>test_pre_dispatch_function_evaluation_mutator</name><operator>)</operator></expr></argument>,
								<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>pcontext</name></expr></argument>,
								<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>new_node</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>new_node</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<comment type="block">/*RTE_JOIN*/</comment>
	<expr_stmt><expr><name><name>rte</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>=</operator> <name>RTE_JOIN</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>new_node</name> <operator>=</operator> <call><name>plan_tree_mutator</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name><operator>*</operator><operator>)</operator><name>rte</name></expr></argument>,
								<argument><expr><operator>(</operator><operator>*</operator><name>test_pre_dispatch_function_evaluation_mutator</name><operator>)</operator></expr></argument>,
								<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>pcontext</name></expr></argument>,
								<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>new_node</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>new_node</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<comment type="block">/*RTE_FUNCTION*/</comment>
	<expr_stmt><expr><name><name>rte</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>=</operator> <name>RTE_FUNCTION</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>new_node</name> <operator>=</operator> <call><name>plan_tree_mutator</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name><operator>*</operator><operator>)</operator><name>rte</name></expr></argument>,
								<argument><expr><operator>(</operator><operator>*</operator><name>test_pre_dispatch_function_evaluation_mutator</name><operator>)</operator></expr></argument>,
								<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>pcontext</name></expr></argument>,
								<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>new_node</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>new_node</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<comment type="block">/*RTE_TABLEFUNCTION*/</comment>
	<expr_stmt><expr><name><name>rte</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>=</operator> <name>RTE_TABLEFUNCTION</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>new_node</name> <operator>=</operator> <call><name>plan_tree_mutator</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name><operator>*</operator><operator>)</operator><name>rte</name></expr></argument>,
								<argument><expr><operator>(</operator><operator>*</operator><name>test_pre_dispatch_function_evaluation_mutator</name><operator>)</operator></expr></argument>,
								<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>pcontext</name></expr></argument>,
								<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>new_node</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>new_node</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<comment type="block">/*RTE_VALUES*/</comment>
	<expr_stmt><expr><name><name>rte</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>=</operator> <name>RTE_VALUES</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>new_node</name> <operator>=</operator> <call><name>plan_tree_mutator</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name><operator>*</operator><operator>)</operator><name>rte</name></expr></argument>,
								<argument><expr><operator>(</operator><operator>*</operator><name>test_pre_dispatch_function_evaluation_mutator</name><operator>)</operator></expr></argument>,
								<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>pcontext</name></expr></argument>,
								<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>new_node</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>ctename</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>test_rangetblfunction</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>new_node</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RangeTblFunction</name> <modifier>*</modifier></type><name>rtfunc</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>RangeTblFunction</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>pre_dispatch_function_evaluation_context</name></type> <name>pcontext</name></decl>;</decl_stmt>
	<expr_stmt><expr><name>new_node</name> <operator>=</operator> <call><name>plan_tree_mutator</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name><operator>*</operator><operator>)</operator><name>rtfunc</name></expr></argument>,
								<argument><expr><operator>(</operator><operator>*</operator><name>test_pre_dispatch_function_evaluation_mutator</name><operator>)</operator></expr></argument>,
								<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>pcontext</name></expr></argument>,
								<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>new_node</name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>test_foreignscan</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>new_node</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ForeignScan</name> <modifier>*</modifier></type><name>fdwscan</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>ForeignScan</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>pre_dispatch_function_evaluation_context</name></type> <name>pcontext</name></decl>;</decl_stmt>
	<expr_stmt><expr><name>new_node</name> <operator>=</operator> <call><name>plan_tree_mutator</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name><operator>*</operator><operator>)</operator><name>fdwscan</name></expr></argument>,
								<argument><expr><operator>(</operator><operator>*</operator><name>test_pre_dispatch_function_evaluation_mutator</name><operator>)</operator></expr></argument>,
								<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>pcontext</name></expr></argument>,
								<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>new_node</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* coverage for px_plan.c */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>test_plan_tree_mutator</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>test_lock_rows</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>test_repeat</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>test_append</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>test_mergeappend</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>test_recursiveunion</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>test_sequnce</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>test_bitmapand</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>test_bitmapor</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>test_scan</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>test_samplescan</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>test_customscan</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>test_indexonlyscan</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>test_bitmapindexscan</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>test_bitmapheapscan</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>test_tidscan</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>test_subqueryscan</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>test_valuesscan</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>test_worktablescan</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>test_join</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>test_tablefuncscan</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>test_unique</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>test_gather</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>test_setop</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>test_flow</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>test_query</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>test_subplan</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>test_rangetblentry</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>test_rangetblfunction</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>test_foreignscan</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* coverage for px_cat.c */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>test_px_policy</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PxPolicy</name> <modifier>*</modifier></type><name>policy</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name>policy</name> <operator>=</operator> <call><name>makePxPolicy</name><argument_list>(<argument><expr><name>POLICYTYPE_PARTITIONED</name></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>policy</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>test_px_hash_init</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PxHash</name> <modifier>*</modifier></type><name>h</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name>h</name> <operator>=</operator> <operator>(</operator><name>PxHash</name> <operator>*</operator><operator>)</operator><call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>PxHash</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>h</name><operator>-&gt;</operator><name>is_legacy_hash</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pxhashinit</name><argument_list>(<argument><expr><name>h</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>h</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>test_px_hash_reduce</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PxHash</name> <modifier>*</modifier></type><name>h</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>result</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name>h</name> <operator>=</operator> <operator>(</operator><name>PxHash</name> <operator>*</operator><operator>)</operator><call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>PxHash</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* case REDUCE_BITMASK */</comment>
	<expr_stmt><expr><name><name>h</name><operator>-&gt;</operator><name>reducealg</name></name> <operator>=</operator> <name>REDUCE_BITMASK</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>h</name><operator>-&gt;</operator><name>hash</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>h</name><operator>-&gt;</operator><name>numsegs</name></name> <operator>=</operator> <literal type="number">3</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>h</name><operator>-&gt;</operator><name>natts</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>pxhashreduce</name><argument_list>(<argument><expr><name>h</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>, <argument><expr><literal type="string">"pxhashreduce result %d"</literal></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* case REDUCE_LAZYMOD */</comment>
	<expr_stmt><expr><name><name>h</name><operator>-&gt;</operator><name>reducealg</name></name> <operator>=</operator> <name>REDUCE_LAZYMOD</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>h</name><operator>-&gt;</operator><name>hash</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>h</name><operator>-&gt;</operator><name>numsegs</name></name> <operator>=</operator> <literal type="number">3</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>h</name><operator>-&gt;</operator><name>natts</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>pxhashreduce</name><argument_list>(<argument><expr><name>h</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>, <argument><expr><literal type="string">"pxhashreduce result %d"</literal></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>h</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* coverage for px_hash.c */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>test_px_hash</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>test_px_hash_init</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>test_px_hash_reduce</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>void</name></type>
<name>test_contains_outer_params</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>new_node</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Param</name> <modifier>*</modifier></type><name>param</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PlannerParamItem</name> <modifier>*</modifier></type><name>param_item</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>result</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* test 1 */</comment>
	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>contains_outer_params</name><argument_list>(<argument><expr><name>new_node</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>result</name> <operator>==</operator> <name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* test 2 */</comment>
	<expr_stmt><expr><name>param</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>Param</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>param</name><operator>-&gt;</operator><name>paramid</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>param</name><operator>-&gt;</operator><name>paramkind</name></name> <operator>=</operator> <name>PARAM_EXEC</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>param_item</name> <operator>=</operator> <operator>(</operator><name>PlannerParamItem</name> <operator>*</operator><operator>)</operator><call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>PlannerParamItem</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>param_item</name><operator>-&gt;</operator><name>paramId</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

	<expr_stmt><expr><name>root</name> <operator>=</operator> <operator>(</operator><name>PlannerInfo</name> <operator>*</operator><operator>)</operator><call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>PlannerInfo</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>parent_root</name></name> <operator>=</operator> <operator>(</operator><name>PlannerInfo</name> <operator>*</operator><operator>)</operator><call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>PlannerInfo</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>parent_root</name><operator>-&gt;</operator><name>plan_params</name></name> <operator>=</operator> <operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator><call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>List</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>parent_root</name><operator>-&gt;</operator><name>plan_params</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name>T_List</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>parent_root</name><operator>-&gt;</operator><name>plan_params</name><operator>-&gt;</operator><name>length</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>parent_root</name><operator>-&gt;</operator><name>plan_params</name><operator>-&gt;</operator><name>head</name></name> <operator>=</operator> <operator>(</operator><name>ListCell</name> <operator>*</operator><operator>)</operator><call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ListCell</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>parent_root</name><operator>-&gt;</operator><name>plan_params</name><operator>-&gt;</operator><name>head</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>ptr_value</name></name> <operator>=</operator> <operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name>param_item</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>parent_root</name><operator>-&gt;</operator><name>plan_params</name><operator>-&gt;</operator><name>tail</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>contains_outer_params</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator><name>param</name></expr></argument>, <argument><expr><name>root</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>param</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>param_item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>parent_root</name><operator>-&gt;</operator><name>plan_params</name><operator>-&gt;</operator><name>head</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>parent_root</name><operator>-&gt;</operator><name>plan_params</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>parent_root</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>root</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* test 3 */</comment>
	<expr_stmt><expr><name>param</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>Param</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>param</name><operator>-&gt;</operator><name>paramkind</name></name> <operator>=</operator> <name>PARAM_EXEC</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>root</name> <operator>=</operator> <operator>(</operator><name>PlannerInfo</name> <operator>*</operator><operator>)</operator><call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>PlannerInfo</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>parent_root</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>contains_outer_params</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator><name>param</name></expr></argument>, <argument><expr><name>root</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>param</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>root</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* coverage for px_mutate.c */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>test_px_mutate</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>test_contains_outer_params</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>test_gang_type</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>ret</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>gangTypeToString</name><argument_list>(<argument><expr><name>GANGTYPE_PRIMARY_WRITER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>ret</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>gangTypeToString</name><argument_list>(<argument><expr><name>GANGTYPE_PRIMARY_READER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>ret</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>gangTypeToString</name><argument_list>(<argument><expr><name>GANGTYPE_SINGLETON_READER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>ret</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>gangTypeToString</name><argument_list>(<argument><expr><name>GANGTYPE_ENTRYDB_READER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>ret</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>gangTypeToString</name><argument_list>(<argument><expr><name>GANGTYPE_UNALLOCATED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>ret</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* coverage for px_gang.c */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>test_px_gang</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>test_gang_type</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/* coverage for px_conn.c */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>test_trans_stats</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>ret</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>ret</name> <operator>=</operator> <call>(<modifier>*</modifier><name>test_trans_status_to_string</name>)<argument_list>(<argument><expr><name>PQTRANS_IDLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>ret</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>ret</name> <operator>=</operator> <call>(<modifier>*</modifier><name>test_trans_status_to_string</name>)<argument_list>(<argument><expr><name>PQTRANS_ACTIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>ret</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>ret</name> <operator>=</operator> <call>(<modifier>*</modifier><name>test_trans_status_to_string</name>)<argument_list>(<argument><expr><name>PQTRANS_INTRANS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>ret</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>ret</name> <operator>=</operator> <call>(<modifier>*</modifier><name>test_trans_status_to_string</name>)<argument_list>(<argument><expr><name>PQTRANS_INERROR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>ret</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>ret</name> <operator>=</operator> <call>(<modifier>*</modifier><name>test_trans_status_to_string</name>)<argument_list>(<argument><expr><name>PQTRANS_UNKNOWN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>ret</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>test_px</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<comment type="block">/*
 * SQL-callable entry point to perform all tests.
 *
 * If a 1% false positive threshold is not met, emits WARNINGs.
 *
 * See README for details of arguments.
 */</comment>
<function><type><name>Datum</name></type>
<name>test_px</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>polar_enable_shared_storage_mode</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PG_RETURN_VOID</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>, <argument><expr><literal type="string">"test_plan_tree_mutator start"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>test_plan_tree_mutator</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>, <argument><expr><literal type="string">"test_px_policy"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>test_px_policy</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>, <argument><expr><literal type="string">"test_px_hash"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>test_px_hash</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>, <argument><expr><literal type="string">"test_px_mutate"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>test_px_mutate</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>, <argument><expr><literal type="string">"test_px_gang"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>test_px_gang</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>, <argument><expr><literal type="string">"test_trans_stats"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>test_trans_stats</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_VOID</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>test_px</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><name>Datum</name></type>
<name>test_px</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>PG_RETURN_VOID</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* FAULT_INJECTOR */</comment>
</unit>
