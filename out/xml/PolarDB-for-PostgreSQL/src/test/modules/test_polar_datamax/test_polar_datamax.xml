<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/PolarDB-for-PostgreSQL/src/test/modules/test_polar_datamax/test_polar_datamax.c">
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/timeline.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/xlog.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/xlog_internal.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"common/fe_memutils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pgstat.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"polar_datamax/polar_datamax.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"port.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postmaster/startup.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"replication/walreceiver.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"replication/slot.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/fd.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/polar_fd.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/guc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/ps_status.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/palloc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;unistd.h&gt;</cpp:file></cpp:include>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>POLAR_DATA_DIR</name></cpp:macro> <cpp:value>(POLAR_FILE_IN_SHARED_STORAGE() ? polar_datadir : DataDir)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RECOVERY_COMMAND_FILE</name></cpp:macro>   <cpp:value>"recovery.conf"</cpp:value></cpp:define>

<expr_stmt><expr><name>PG_MODULE_MAGIC</name></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>test_polar_datamax_shmem_size</name><parameter_list>()</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><name>polar_local_node_type</name> <operator>=</operator> <name>POLAR_STANDALONE_DATAMAX</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>polar_datamax_shmem_size</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>polar_local_node_type</name> <operator>=</operator> <name>POLAR_MASTER</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>polar_datamax_shmem_size</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* this test needs to be called before others to init polar_datamax_ctl */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>test_polar_datamax_shmem_init</name><parameter_list>()</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>polar_set_node_type</name><argument_list>(<argument><expr><name>POLAR_MASTER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>polar_datamax_shmem_init</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>polar_datamax_ctl</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>polar_set_node_type</name><argument_list>(<argument><expr><name>POLAR_STANDALONE_DATAMAX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>IsUnderPostmaster</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>IsUnderPostmaster</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>polar_datamax_shmem_init</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>polar_datamax_ctl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>IsUnderPostmaster</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>IsUnderPostmaster</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>polar_datamax_shmem_init</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>polar_set_node_type</name><argument_list>(<argument><expr><name>POLAR_MASTER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>IsUnderPostmaster</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>test_polar_datamax_read_recovery_conf</name><parameter_list>()</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name></type>    <name><name>path</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>FILE</name>   <modifier>*</modifier></type><name>out_file</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>     <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>   <modifier>*</modifier></type><name>pg_data</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>   <modifier>*</modifier></type><name>pgdata_get_env</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name><name>contents</name><index>[]</index></name> <init>=
	<expr><block>{
		<expr><literal type="string">"primary_conninfo = 'host=localhost port=8432 user=postgres dbname=postgres application_name=datamax1'\n"</literal></expr>,
		<expr><literal type="string">"polar_datamax_mode = standalone\n"</literal></expr>,
		<expr><literal type="string">"primary_slot_name = 'datamax1'\n"</literal></expr>
	}</block></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>   <modifier>*</modifier></type><name>primary_conninfo</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>   <modifier>*</modifier></type><name>primary_slot_name</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* create recovery.conf */</comment>
	<expr_stmt><expr><name>pgdata_get_env</name> <operator>=</operator> <call><name>getenv</name><argument_list>(<argument><expr><literal type="string">"PGDATA"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>pgdata_get_env</name> <operator>&amp;&amp;</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>pgdata_get_env</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>pg_data</name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><name>pgdata_get_env</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>MAXPGPATH</name></expr></argument>, <argument><expr><literal type="string">"%s/%s"</literal></expr></argument>, <argument><expr><name>pg_data</name></expr></argument>, <argument><expr><name>RECOVERY_COMMAND_FILE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>out_file</name> <operator>=</operator> <call><name>fopen</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><literal type="string">"w"</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"could not open file \"%s\""</literal></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <call><name>lengthof</name><argument_list>(<argument><expr><name>contents</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>fputs</name><argument_list>(<argument><expr><name><name>contents</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>out_file</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"could not write file content :%s"</literal></expr></argument>, <argument><expr><name><name>contents</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></for>

	<if_stmt><if>if <condition>(<expr><call><name>fclose</name><argument_list>(<argument><expr><name>out_file</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"could not close file \"%s\""</literal></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* test polar_datamax_read_recovery_conf() */</comment>
	<expr_stmt><expr><call><name>polar_set_node_type</name><argument_list>(<argument><expr><name>POLAR_STANDALONE_DATAMAX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>IsUnderPostmaster</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>polar_datamax_read_recovery_conf</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>primary_conninfo</name> <operator>=</operator> <call><name>polar_datamax_get_primary_info</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>primary_slot_name</name> <operator>=</operator> <call><name>polar_datamax_get_primary_slot_name</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>primary_conninfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>strcmp</name><argument_list>(<argument><expr><name>primary_conninfo</name></expr></argument>, <argument><expr><literal type="string">"host=localhost port=8432 user=postgres dbname=postgres application_name=datamax1"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>primary_slot_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>strcmp</name><argument_list>(<argument><expr><name>primary_slot_name</name></expr></argument>, <argument><expr><literal type="string">"datamax1"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>polar_datamax_mode_requested</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* detele recovery.conf created */</comment>
	<expr_stmt><expr><call><name>durable_unlink</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>LOG</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>polar_set_node_type</name><argument_list>(<argument><expr><name>POLAR_MASTER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>test_polar_datamax_load_write_meta</name><parameter_list>()</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name></type> <name><name>meta_path</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TimeLineID</name></type> <name>tli</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>XLogRecPtr</name></type> <name>lsn</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>polar_enable_shared_storage_mode</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>polar_local_node_type</name> <operator>=</operator> <name>POLAR_STANDALONE_DATAMAX</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>polar_datamax_validate_dir</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* init in memory */</comment>
	<expr_stmt><expr><call><name>polar_datamax_init_meta</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>polar_datamax_ctl</name><operator>-&gt;</operator><name>meta</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* create meta */</comment>
	<expr_stmt><expr><call><name>polar_datamax_write_meta</name><argument_list>(<argument><expr><name>polar_datamax_ctl</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>meta_path</name></expr></argument>, <argument><expr><name>MAXPGPATH</name></expr></argument>, <argument><expr><literal type="string">"%s/%s/%s"</literal></expr></argument>, <argument><expr><name>POLAR_DATA_DIR</name></expr></argument>, <argument><expr><name>POLAR_DATAMAX_DIR</name></expr></argument>, <argument><expr><name>POLAR_DATAMAX_META_FILE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>PathNameOpenFile</name><argument_list>(<argument><expr><name>meta_path</name></expr></argument>, <argument><expr><name>O_RDONLY</name> <operator>|</operator> <name>PG_BINARY</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* update meta and write */</comment>
	<expr_stmt><expr><call><name>polar_datamax_update_min_received_info</name><argument_list>(<argument><expr><name>polar_datamax_ctl</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>polar_datamax_write_meta</name><argument_list>(<argument><expr><name>polar_datamax_ctl</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* load and verify */</comment>
	<expr_stmt><expr><call><name>polar_datamax_update_min_received_info</name><argument_list>(<argument><expr><name>polar_datamax_ctl</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>polar_datamax_load_meta</name><argument_list>(<argument><expr><name>polar_datamax_ctl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>polar_datamax_ctl</name><operator>-&gt;</operator><name>meta_lock</name></name></expr></argument>, <argument><expr><name>LW_SHARED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>tli</name> <operator>=</operator> <name><name>polar_datamax_ctl</name><operator>-&gt;</operator><name>meta</name><operator>.</operator><name>min_timeline_id</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>lsn</name> <operator>=</operator> <name><name>polar_datamax_ctl</name><operator>-&gt;</operator><name>meta</name><operator>.</operator><name>min_received_lsn</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>polar_datamax_ctl</name><operator>-&gt;</operator><name>meta_lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>tli</name> <operator>==</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>lsn</name> <operator>==</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* delete meta file created */</comment>
	<expr_stmt><expr><call><name>durable_unlink</name><argument_list>(<argument><expr><name>meta_path</name></expr></argument>, <argument><expr><name>LOG</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>polar_local_node_type</name> <operator>=</operator> <name>POLAR_MASTER</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>test_polar_datamax_is_initial</name><parameter_list>()</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>polar_set_node_type</name><argument_list>(<argument><expr><name>POLAR_STANDALONE_DATAMAX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* case #1 */</comment>
	<expr_stmt><expr><call><name>polar_datamax_init_meta</name><argument_list>(<argument><expr><name>POLAR_DATAMAX_META</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>polar_datamax_is_initial</name><argument_list>(<argument><expr><name>polar_datamax_ctl</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* case #2 */</comment>
	<expr_stmt><expr><call><name>polar_datamax_update_received_info</name><argument_list>(<argument><expr><name>polar_datamax_ctl</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>InvalidXLogRecPtr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>polar_datamax_is_initial</name><argument_list>(<argument><expr><name>polar_datamax_ctl</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* case #3 */</comment>
	<expr_stmt><expr><call><name>polar_datamax_update_received_info</name><argument_list>(<argument><expr><name>polar_datamax_ctl</name></expr></argument>, <argument><expr><name>POLAR_INVALID_TIMELINE_ID</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>polar_datamax_is_initial</name><argument_list>(<argument><expr><name>polar_datamax_ctl</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* case #4 */</comment>
	<expr_stmt><expr><call><name>polar_datamax_update_received_info</name><argument_list>(<argument><expr><name>polar_datamax_ctl</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>polar_datamax_is_initial</name><argument_list>(<argument><expr><name>polar_datamax_ctl</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* case #5 */</comment>
	<expr_stmt><expr><call><name>polar_set_node_type</name><argument_list>(<argument><expr><name>POLAR_MASTER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>polar_datamax_is_initial</name><argument_list>(<argument><expr><name>polar_datamax_ctl</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>test_polar_datamax_init_meta</name><parameter_list>()</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>pg_crc32c</name></type> <name>crc</name></decl>;</decl_stmt>

	<comment type="block">/* case #1 */</comment>
	<expr_stmt><expr><call><name>polar_datamax_init_meta</name><argument_list>(<argument><expr><name>POLAR_DATAMAX_META</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>POLAR_DATAMAX_META</name><operator>-&gt;</operator><name>magic</name></name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>POLAR_DATAMAX_META</name><operator>-&gt;</operator><name>version</name></name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* case #2 */</comment>
	<expr_stmt><expr><call><name>polar_datamax_init_meta</name><argument_list>(<argument><expr><name>POLAR_DATAMAX_META</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>POLAR_DATAMAX_META</name><operator>-&gt;</operator><name>magic</name></name> <operator>==</operator> <name>POLAR_DATAMAX_MAGIC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>POLAR_DATAMAX_META</name><operator>-&gt;</operator><name>version</name></name> <operator>==</operator> <name>POLAR_DATAMAX_VERSION</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>POLAR_DATAMAX_META</name><operator>-&gt;</operator><name>min_timeline_id</name></name> <operator>==</operator> <name>POLAR_INVALID_TIMELINE_ID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>POLAR_DATAMAX_META</name><operator>-&gt;</operator><name>min_received_lsn</name></name> <operator>==</operator> <name>InvalidXLogRecPtr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>POLAR_DATAMAX_META</name><operator>-&gt;</operator><name>last_timeline_id</name></name> <operator>==</operator> <name>POLAR_INVALID_TIMELINE_ID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>POLAR_DATAMAX_META</name><operator>-&gt;</operator><name>last_received_lsn</name></name> <operator>==</operator> <name>InvalidXLogRecPtr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>crc</name> <operator>=</operator> <name><name>POLAR_DATAMAX_META</name><operator>-&gt;</operator><name>crc</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>POLAR_DATAMAX_META</name><operator>-&gt;</operator><name>crc</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>POLAR_DATAMAX_META</name><operator>-&gt;</operator><name>crc</name></name> <operator>=</operator> <call><name>polar_datamax_calc_meta_crc</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator><name>POLAR_DATAMAX_META</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>polar_datamax_meta_data_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>POLAR_DATAMAX_META</name><operator>-&gt;</operator><name>crc</name></name> <operator>==</operator> <name>crc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>test_polar_datamax_update_received_info</name><parameter_list>()</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TimeLineID</name></type> <name>tli</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>XLogRecPtr</name></type> <name>lsn</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>polar_datamax_update_received_info</name><argument_list>(<argument><expr><name>polar_datamax_ctl</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* test polar_datamax_get_last_received_info */</comment>
	<expr_stmt><expr><call><name>polar_datamax_get_last_received_info</name><argument_list>(<argument><expr><name>polar_datamax_ctl</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tli</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>lsn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>tli</name> <operator>==</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>lsn</name> <operator>==</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* test polar_datamax_get_last_received_lsn */</comment>
	<expr_stmt><expr><call><name>polar_datamax_update_received_info</name><argument_list>(<argument><expr><name>polar_datamax_ctl</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>lsn</name> <operator>=</operator> <call><name>polar_datamax_get_last_received_lsn</name><argument_list>(<argument><expr><name>polar_datamax_ctl</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tli</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>tli</name> <operator>==</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>lsn</name> <operator>==</operator> <literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>test_polar_datamax_update_min_received_info</name><parameter_list>()</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TimeLineID</name></type> <name>tli</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>XLogRecPtr</name></type> <name>lsn</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>polar_datamax_update_min_received_info</name><argument_list>(<argument><expr><name>polar_datamax_ctl</name></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>polar_datamax_ctl</name><operator>-&gt;</operator><name>meta_lock</name></name></expr></argument>, <argument><expr><name>LW_SHARED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>tli</name> <operator>=</operator> <name><name>polar_datamax_ctl</name><operator>-&gt;</operator><name>meta</name><operator>.</operator><name>min_timeline_id</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>lsn</name> <operator>=</operator> <name><name>polar_datamax_ctl</name><operator>-&gt;</operator><name>meta</name><operator>.</operator><name>min_received_lsn</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>polar_datamax_ctl</name><operator>-&gt;</operator><name>meta_lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>tli</name> <operator>==</operator> <literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>lsn</name> <operator>==</operator> <literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>test_polar_datamax_handle_timeline_switch</name><parameter_list>()</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name></type>    <name><name>path_history</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>    <name><name>meta_path</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>FILE</name>   <modifier>*</modifier></type><name>out_file</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>   <modifier>*</modifier></type><name>content</name> <init>= <expr><literal type="string">"1   0/A000078  no recovery target specified\n"</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TimeLineID</name></type> <name>next_tli</name> <init>= <expr><literal type="number">2</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>XLogRecPtr</name></type> <name>cur_lsn</name> <init>= <expr><operator>(</operator><name>XLogRecPtr</name><operator>)</operator><literal type="number">0xA000020</literal></expr></init></decl>;</decl_stmt>

	<comment type="block">/* case #1, no timeline switch */</comment>
	<expr_stmt><expr><call><name>polar_set_node_type</name><argument_list>(<argument><expr><name>POLAR_STANDALONE_DATAMAX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>polar_local_node_type</name> <operator>=</operator> <name>POLAR_STANDALONE_DATAMAX</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>polar_datamax_update_received_info</name><argument_list>(<argument><expr><name>polar_datamax_ctl</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>cur_lsn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>polar_datamax_handle_timeline_switch</name><argument_list>(<argument><expr><name>polar_datamax_ctl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>polar_is_datamax_mode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* create 2.history file, polar_is_datamax_mode = true */</comment>
	<expr_stmt><expr><call><name>polar_datamax_validate_dir</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>TLHistoryFilePath</name><argument_list>(<argument><expr><name>path_history</name></expr></argument>, <argument><expr><name>next_tli</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>out_file</name> <operator>=</operator> <call><name>fopen</name><argument_list>(<argument><expr><name>path_history</name></expr></argument>, <argument><expr><literal type="string">"w"</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"could not open file \"%s\""</literal></expr></argument>, <argument><expr><name>path_history</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>fputs</name><argument_list>(<argument><expr><name>content</name></expr></argument>, <argument><expr><name>out_file</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"could not write file content :%s"</literal></expr></argument>, <argument><expr><name>content</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>fclose</name><argument_list>(<argument><expr><name>out_file</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"could not close file \"%s\""</literal></expr></argument>, <argument><expr><name>path_history</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* create meta file */</comment>
	<expr_stmt><expr><call><name>polar_datamax_init_meta</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>polar_datamax_ctl</name><operator>-&gt;</operator><name>meta</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>polar_datamax_write_meta</name><argument_list>(<argument><expr><name>polar_datamax_ctl</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* case #2, timeline switch */</comment>
	<expr_stmt><expr><name>cur_lsn</name> <operator>=</operator> <operator>(</operator><name>XLogRecPtr</name><operator>)</operator><literal type="number">0xB000020</literal></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>polar_datamax_update_received_info</name><argument_list>(<argument><expr><name>polar_datamax_ctl</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>cur_lsn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>polar_datamax_handle_timeline_switch</name><argument_list>(<argument><expr><name>polar_datamax_ctl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>next_tli</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>polar_datamax_get_last_received_info</name><argument_list>(<argument><expr><name>polar_datamax_ctl</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>next_tli</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>cur_lsn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>next_tli</name> <operator>==</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* delete meta file */</comment>
	<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>meta_path</name></expr></argument>, <argument><expr><name>MAXPGPATH</name></expr></argument>, <argument><expr><literal type="string">"%s/%s/%s"</literal></expr></argument>, <argument><expr><name>POLAR_DATA_DIR</name></expr></argument>, <argument><expr><name>POLAR_DATAMAX_DIR</name></expr></argument>, <argument><expr><name>POLAR_DATAMAX_META_FILE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>durable_unlink</name><argument_list>(<argument><expr><name>meta_path</name></expr></argument>, <argument><expr><name>LOG</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* delete history file */</comment>
	<expr_stmt><expr><call><name>durable_unlink</name><argument_list>(<argument><expr><name>path_history</name></expr></argument>, <argument><expr><name>LOG</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>polar_set_node_type</name><argument_list>(<argument><expr><name>POLAR_MASTER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>polar_local_node_type</name> <operator>=</operator> <name>POLAR_MASTER</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>test_polar_datamax_validate_dir</name><parameter_list>()</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name><name>dirs</name><index>[]</index></name> <init>=
	<expr><block>{
		<expr><name>POLAR_DATAMAX_DIR</name></expr>,
		<expr><name>POLAR_DATAMAX_WAL_DIR</name></expr>,
		<expr><name>POLAR_DATAMAX_WAL_DIR</name> <literal type="string">"/archive_status"</literal></expr>
	}</block></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>    <name><name>path</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>     <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>polar_local_node_type</name> <operator>=</operator> <name>POLAR_STANDALONE_DATAMAX</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>polar_datamax_validate_dir</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <call><name>lengthof</name><argument_list>(<argument><expr><name>dirs</name></expr></argument>)</argument_list></call> <operator>-</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><name>i</name><operator>--</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name><name>struct</name> <name>stat</name></name></type> <name>stat_buf</name></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><operator>(</operator><name>path</name><operator>)</operator></expr></argument>, <argument><expr><name>MAXPGPATH</name></expr></argument>, <argument><expr><literal type="string">"%s/%s"</literal></expr></argument>, <argument><expr><name>polar_datadir</name></expr></argument>, <argument><expr><name><name>dirs</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* check and detele dir */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>polar_stat</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>stat_buf</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <call><name>S_ISDIR</name><argument_list>(<argument><expr><name><name>stat_buf</name><operator>.</operator><name>st_mode</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>polar_rmdir</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"could not delete directory \"%s\""</literal></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></for>
	<expr_stmt><expr><name>polar_local_node_type</name> <operator>=</operator> <name>POLAR_MASTER</name></expr>;</expr_stmt>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>void</name></type>
<name>test_create_wal_or_ready_file</name><parameter_list>(<parameter><decl><type><name>XLogSegNo</name></type> <name>_log_seg_no</name></decl></parameter>, <parameter><decl><type><name>TimeLineID</name></type> <name>tli</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>wal_file_num</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>wal_file</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>  <name>count</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type> <name><name>path</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type> <name><name>xlogfile</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>  <name>fd</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>polar_local_node_type</name> <operator>=</operator> <name>POLAR_STANDALONE_DATAMAX</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>polar_datamax_validate_dir</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<while>while <condition>(<expr><name>count</name> <operator>&lt;</operator> <name>wal_file_num</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>count</name><operator>++</operator></expr>;</expr_stmt>
		<expr_stmt><expr><name>polar_is_datamax_mode</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>wal_file</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>XLogFilePath</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>tli</name></expr></argument>, <argument><expr><name>_log_seg_no</name></expr></argument>, <argument><expr><name>wal_segment_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<comment type="block">/* create xlog.ready file */</comment>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><call><name>XLogFileName</name><argument_list>(<argument><expr><name>xlogfile</name></expr></argument>, <argument><expr><name>tli</name></expr></argument>, <argument><expr><name>_log_seg_no</name></expr></argument>, <argument><expr><name>wal_segment_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>polar_datamax_status_file_path</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>xlogfile</name></expr></argument>, <argument><expr><literal type="string">".ready"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<if_stmt><if>if <condition>(<expr><operator>(</operator><name>fd</name> <operator>=</operator> <call><name>PathNameOpenFile</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>O_RDONLY</name> <operator>|</operator> <name>PG_BINARY</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"try to create file \"%s\""</literal></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>fd</name> <operator>=</operator> <call><name>PathNameOpenFile</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>O_RDWR</name> <operator>|</operator> <name>O_CREAT</name> <operator>|</operator> <name>PG_BINARY</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name>fd</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"could not create file \"%s\""</literal></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><name>_log_seg_no</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block></while>
	<expr_stmt><expr><name>polar_local_node_type</name> <operator>=</operator> <name>POLAR_MASTER</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>test_delete_wal_file</name><parameter_list>(<parameter><decl><type><name>XLogSegNo</name></type> <name>_log_seg_no</name></decl></parameter>, <parameter><decl><type><name>TimeLineID</name></type> <name>tli</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>wal_file_num</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>count</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>        <name><name>seg_name</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name></decl>;</decl_stmt>

	<while>while <condition>(<expr><name>count</name> <operator>&lt;</operator> <name>wal_file_num</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>count</name><operator>++</operator></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>XLogFileName</name><argument_list>(<argument><expr><name>seg_name</name></expr></argument>, <argument><expr><name>tli</name></expr></argument>, <argument><expr><name>_log_seg_no</name></expr></argument>, <argument><expr><name>wal_segment_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>polar_datamax_remove_wal_file</name><argument_list>(<argument><expr><name>seg_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>_log_seg_no</name> <operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block></while>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>test_polar_datamax_remove_old_wal</name><parameter_list>()</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TimeLineID</name></type> <name>tli</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>XLogRecPtr</name></type> <name>lsn</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>XLogSegNo</name></type>  <name>seg</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>XLogRecPtr</name></type> <name>reserved_lsn</name> <init>= <expr><name>InvalidXLogRecPtr</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>wal_file_num</name> <init>= <expr><literal type="number">5</literal></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>polar_datamax_update_min_received_info</name><argument_list>(<argument><expr><name>polar_datamax_ctl</name></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* case 1, not datamax mode */</comment>
	<expr_stmt><expr><call><name>polar_set_node_type</name><argument_list>(<argument><expr><name>POLAR_MASTER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>polar_datamax_remove_old_wal</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>polar_datamax_ctl</name><operator>-&gt;</operator><name>meta_lock</name></name></expr></argument>, <argument><expr><name>LW_SHARED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>tli</name> <operator>=</operator> <name><name>polar_datamax_ctl</name><operator>-&gt;</operator><name>meta</name><operator>.</operator><name>min_timeline_id</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>lsn</name> <operator>=</operator> <name><name>polar_datamax_ctl</name><operator>-&gt;</operator><name>meta</name><operator>.</operator><name>min_received_lsn</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>polar_datamax_ctl</name><operator>-&gt;</operator><name>meta_lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>tli</name> <operator>==</operator> <literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>lsn</name> <operator>==</operator> <literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* case 2, invalid reserved_lsn */</comment>
	<expr_stmt><expr><call><name>polar_set_node_type</name><argument_list>(<argument><expr><name>POLAR_STANDALONE_DATAMAX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>polar_datamax_remove_old_wal</name><argument_list>(<argument><expr><name>InvalidXLogRecPtr</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>polar_datamax_ctl</name><operator>-&gt;</operator><name>meta_lock</name></name></expr></argument>, <argument><expr><name>LW_SHARED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>tli</name> <operator>=</operator> <name><name>polar_datamax_ctl</name><operator>-&gt;</operator><name>meta</name><operator>.</operator><name>min_timeline_id</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>lsn</name> <operator>=</operator> <name><name>polar_datamax_ctl</name><operator>-&gt;</operator><name>meta</name><operator>.</operator><name>min_received_lsn</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>polar_datamax_ctl</name><operator>-&gt;</operator><name>meta_lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>tli</name> <operator>==</operator> <literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>lsn</name> <operator>==</operator> <literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* case 3 force delete old wal */</comment>
	<expr_stmt><expr><name>tli</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>test_create_wal_or_ready_file</name><argument_list>(<argument><expr><name>seg</name></expr></argument>, <argument><expr><name>tli</name></expr></argument>, <argument><expr><name>wal_file_num</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>seg</name> <operator>=</operator> <literal type="number">3</literal></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>XLogSegNoOffsetToRecPtr</name><argument_list>(<argument><expr><name>seg</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>wal_segment_size</name></expr></argument>, <argument><expr><name>reserved_lsn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>polar_datamax_remove_old_wal</name><argument_list>(<argument><expr><name>reserved_lsn</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>polar_datamax_ctl</name><operator>-&gt;</operator><name>meta_lock</name></name></expr></argument>, <argument><expr><name>LW_SHARED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>lsn</name> <operator>=</operator> <name><name>polar_datamax_ctl</name><operator>-&gt;</operator><name>meta</name><operator>.</operator><name>min_received_lsn</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>polar_datamax_ctl</name><operator>-&gt;</operator><name>meta_lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>lsn</name> <operator>&lt;=</operator> <name>reserved_lsn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>test_delete_wal_file</name><argument_list>(<argument><expr><name>seg</name></expr></argument>, <argument><expr><name>tli</name></expr></argument>, <argument><expr><name>wal_file_num</name> <operator>-</operator> <name>seg</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>polar_set_node_type</name><argument_list>(<argument><expr><name>POLAR_MASTER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>test_polar_datamax_reset_clean_task</name><parameter_list>()</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>polar_datamax_clean_task_t</name></type> <name>task</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>polar_datamax_reset_clean_task</name><argument_list>(<argument><expr><name>polar_datamax_ctl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>task</name><operator>.</operator><name>reserved_lsn</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>task</name><operator>.</operator><name>force</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>SpinLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>polar_datamax_ctl</name><operator>-&gt;</operator><name>lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>task</name> <operator>=</operator> <name><name>polar_datamax_ctl</name><operator>-&gt;</operator><name>clean_task</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SpinLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>polar_datamax_ctl</name><operator>-&gt;</operator><name>lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>task</name><operator>.</operator><name>reserved_lsn</name></name> <operator>==</operator> <name>InvalidXLogRecPtr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>task</name><operator>.</operator><name>force</name></name> <operator>==</operator> <name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>test_polar_datamax_set_clean_task</name><parameter_list>()</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>polar_datamax_clean_task_t</name></type> <name>task</name></decl>;</decl_stmt>
	<expr_stmt><expr><name><name>task</name><operator>.</operator><name>reserved_lsn</name></name> <operator>=</operator> <name>InvalidXLogRecPtr</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>task</name><operator>.</operator><name>force</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>polar_datamax_reset_clean_task</name><argument_list>(<argument><expr><name>polar_datamax_ctl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>polar_datamax_set_clean_task</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>SpinLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>polar_datamax_ctl</name><operator>-&gt;</operator><name>lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>task</name> <operator>=</operator> <name><name>polar_datamax_ctl</name><operator>-&gt;</operator><name>clean_task</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SpinLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>polar_datamax_ctl</name><operator>-&gt;</operator><name>lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>task</name><operator>.</operator><name>reserved_lsn</name></name> <operator>==</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>task</name><operator>.</operator><name>force</name></name> <operator>==</operator> <name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>polar_datamax_set_clean_task</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>polar_datamax_reset_clean_task</name><argument_list>(<argument><expr><name>polar_datamax_ctl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>test_polar_datamax_handle_clean_task</name><parameter_list>()</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>XLogSegNo</name></type>  <name>seg</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TimeLineID</name></type> <name>tli</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>wal_file_num</name> <init>= <expr><literal type="number">3</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>XLogRecPtr</name></type> <name>reserved_lsn</name> <init>= <expr><name>InvalidXLogRecPtr</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>polar_datamax_clean_task_t</name></type> <name>task</name> <init>= <expr><block>{<expr><literal type="number">1</literal></expr>, <expr><name>true</name></expr>}</block></expr></init></decl>;</decl_stmt>

	<comment type="block">/* reset task */</comment>
	<expr_stmt><expr><name>seg</name> <operator>=</operator> <literal type="number">3</literal></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>test_create_wal_or_ready_file</name><argument_list>(<argument><expr><name>seg</name></expr></argument>, <argument><expr><name>tli</name></expr></argument>, <argument><expr><name>wal_file_num</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>polar_datamax_reset_clean_task</name><argument_list>(<argument><expr><name>polar_datamax_ctl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>XLogSegNoOffsetToRecPtr</name><argument_list>(<argument><expr><name>seg</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>wal_segment_size</name></expr></argument>, <argument><expr><name>reserved_lsn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* set and handle task */</comment>
	<expr_stmt><expr><call><name>polar_datamax_set_clean_task</name><argument_list>(<argument><expr><name>reserved_lsn</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>polar_datamax_handle_clean_task</name><argument_list>(<argument><expr><name>polar_datamax_ctl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* after handle, judge if reset */</comment>
	<expr_stmt><expr><call><name>SpinLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>polar_datamax_ctl</name><operator>-&gt;</operator><name>lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>task</name> <operator>=</operator> <name><name>polar_datamax_ctl</name><operator>-&gt;</operator><name>clean_task</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SpinLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>polar_datamax_ctl</name><operator>-&gt;</operator><name>lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>task</name><operator>.</operator><name>reserved_lsn</name></name> <operator>==</operator> <name>InvalidXLogRecPtr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>task</name><operator>.</operator><name>force</name></name> <operator>==</operator> <name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* delete wal file created */</comment>
	<expr_stmt><expr><call><name>test_delete_wal_file</name><argument_list>(<argument><expr><name>seg</name></expr></argument>, <argument><expr><name>tli</name></expr></argument>, <argument><expr><name>wal_file_num</name> <operator>-</operator> <name>seg</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>test_polar_datamax_replication_start_lsn</name><parameter_list>()</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ReplicationSlot</name> <modifier>*</modifier></type><name>slot</name> <init>= <expr><call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ReplicationSlot</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>XLogRecPtr</name></type> <name>lsn</name> <init>= <expr><name>InvalidXLogRecPtr</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>XLogRecPtr</name></type> <name>rel_lsn</name> <init>= <expr><name>InvalidXLogRecPtr</name></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>XLogSegNoOffsetToRecPtr</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">5</literal></expr></argument>, <argument><expr><name>wal_segment_size</name></expr></argument>, <argument><expr><name>lsn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>XLogSegNoOffsetToRecPtr</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>wal_segment_size</name></expr></argument>, <argument><expr><name>rel_lsn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>slot</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>SpinLockInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>slot</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>SpinLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>slot</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>slot</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>restart_lsn</name></name> <operator>=</operator> <name>lsn</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>SpinLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>slot</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>polar_datamax_replication_start_lsn</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>rel_lsn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>test_polar_datamax_archive_and_remove_archivedone</name><parameter_list>()</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>XLogSegNo</name></type>  <name>seg</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>XLogSegNo</name></type>  <name>tmp_seg</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TimeLineID</name></type> <name>tli</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>wal_file_num</name> <init>= <expr><literal type="number">5</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>XLogRecPtr</name></type>  <name>reserved_lsn</name> <init>= <expr><name>InvalidXLogRecPtr</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type> <name><name>path</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>stat</name></name></type> <name>stat_mode</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>polar_set_node_type</name><argument_list>(<argument><expr><name>POLAR_STANDALONE_DATAMAX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>wal_level</name> <operator>=</operator> <name>WAL_LEVEL_REPLICA</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>XLogArchiveMode</name> <operator>=</operator> <name>ARCHIVE_MODE_ALWAYS</name></expr>;</expr_stmt>

	<comment type="block">/* test polar_datamax_archive() */</comment>
	<comment type="block">/* first test archive, don't enter loop */</comment>
	<expr_stmt><expr><call><name>polar_datamax_archive</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>polar_datamax_archive_timeout</name> <operator>=</operator> <literal type="number">1000</literal></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>sleep</name><argument_list>(<argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* second, actual achive */</comment>
	<expr_stmt><expr><call><name>test_create_wal_or_ready_file</name><argument_list>(<argument><expr><name>seg</name></expr></argument>, <argument><expr><name>tli</name></expr></argument>, <argument><expr><name>wal_file_num</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>test_create_wal_or_ready_file</name><argument_list>(<argument><expr><name>seg</name></expr></argument>, <argument><expr><name>tli</name></expr></argument>, <argument><expr><name>wal_file_num</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>polar_datamax_archive</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* test end */</comment>

	<comment type="block">/* test polar_datamax_remove_archivedone_wal() */</comment>
	<comment type="block">/* first remove archivedone wal, don't do actual work */</comment>
	<expr_stmt><expr><call><name>polar_datamax_remove_archivedone_wal</name><argument_list>(<argument><expr><name>polar_datamax_ctl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* second, with wal_keep_segments = wal_file_num */</comment>
	<expr_stmt><expr><name>seg</name> <operator>=</operator> <name>wal_file_num</name></expr>;</expr_stmt>
	<comment type="block">/* update last_remove_segno of upstream */</comment>
	<expr_stmt><expr><call><name>polar_datamax_update_upstream_last_removed_segno</name><argument_list>(<argument><expr><name>polar_datamax_ctl</name></expr></argument>, <argument><expr><name>seg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>XLogSegNoOffsetToRecPtr</name><argument_list>(<argument><expr><name>seg</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>wal_segment_size</name></expr></argument>, <argument><expr><name>reserved_lsn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>polar_datamax_update_received_info</name><argument_list>(<argument><expr><name>polar_datamax_ctl</name></expr></argument>, <argument><expr><name>tli</name></expr></argument>, <argument><expr><name>reserved_lsn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>wal_keep_segments</name> <operator>=</operator> <name>wal_file_num</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>polar_datamax_remove_archivedone_wal_timeout</name> <operator>=</operator> <literal type="number">1000</literal></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>sleep</name><argument_list>(<argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>polar_datamax_remove_archivedone_wal</name><argument_list>(<argument><expr><name>polar_datamax_ctl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>wal_file_num</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><call><name>XLogFilePath</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>tli</name></expr></argument>, <argument><expr><name>tmp_seg</name></expr></argument>, <argument><expr><name>wal_segment_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>polar_stat</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>stat_mode</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<comment type="block">/* third, with wal_keep_segments = 0 */</comment>
	<expr_stmt><expr><name>wal_keep_segments</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>polar_datamax_remove_archivedone_wal_timeout</name> <operator>=</operator> <literal type="number">1000</literal></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>sleep</name><argument_list>(<argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>polar_datamax_remove_archivedone_wal</name><argument_list>(<argument><expr><name>polar_datamax_ctl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>wal_file_num</name> <operator>-</operator> <literal type="number">1</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><call><name>XLogFilePath</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>tli</name></expr></argument>, <argument><expr><name>tmp_seg</name></expr></argument>, <argument><expr><name>wal_segment_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>polar_stat</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>stat_mode</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>
	<comment type="block">/* test end */</comment>

	<comment type="block">/* delete wal file created */</comment>
	<expr_stmt><expr><call><name>test_delete_wal_file</name><argument_list>(<argument><expr><name>seg</name></expr></argument>, <argument><expr><name>tli</name></expr></argument>, <argument><expr><name>wal_file_num</name> <operator>-</operator> <name>seg</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>polar_set_node_type</name><argument_list>(<argument><expr><name>POLAR_MASTER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>test_polar_datamax_save_replication_slots</name><parameter_list>()</parameter_list>
<block>{<block_content>
	<comment type="block">/* no datamax mode */</comment>
	<expr_stmt><expr><call><name>polar_set_node_type</name><argument_list>(<argument><expr><name>POLAR_MASTER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>polar_datamax_save_replication_slots</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* datamax mode, no actual save */</comment>
	<expr_stmt><expr><call><name>polar_set_node_type</name><argument_list>(<argument><expr><name>POLAR_STANDALONE_DATAMAX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>polar_datamax_save_replication_slots</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* datamax mode, do actual save */</comment>
	<expr_stmt><expr><name>polar_datamax_save_replication_slots_timeout</name> <operator>=</operator> <literal type="number">1000</literal></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>sleep</name><argument_list>(<argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>polar_datamax_save_replication_slots</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>polar_set_node_type</name><argument_list>(<argument><expr><name>POLAR_MASTER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>test_polar_datamax_prealloc_wal_file</name><parameter_list>()</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>XLogSegNo</name></type>  <name>seg</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TimeLineID</name></type> <name>tli</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>wal_file_num</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>XLogRecPtr</name></type>  <name>reserved_lsn</name> <init>= <expr><name>InvalidXLogRecPtr</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type> <name><name>path</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>stat</name></name></type> <name>stat_mode</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>WalRcvData</name> <modifier>*</modifier></type><name>walrcv</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>WalRcvState</name></type> <name>state</name></decl>;</decl_stmt>

	<comment type="block">/* no datamax mode */</comment>
	<expr_stmt><expr><call><name>polar_set_node_type</name><argument_list>(<argument><expr><name>POLAR_MASTER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>polar_datamax_prealloc_wal_file</name><argument_list>(<argument><expr><name>polar_datamax_ctl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* datamax mode, no wal streaming */</comment>
	<expr_stmt><expr><call><name>polar_set_node_type</name><argument_list>(<argument><expr><name>POLAR_STANDALONE_DATAMAX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>walrcv</name> <operator>=</operator> <name>WalRcv</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>state</name> <operator>=</operator> <name>WALRCV_STOPPING</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SpinLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>walrcv</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>walrcv</name><operator>-&gt;</operator><name>walRcvState</name></name> <operator>=</operator> <name>state</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SpinLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>walrcv</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>polar_datamax_prealloc_wal_file</name><argument_list>(<argument><expr><name>polar_datamax_ctl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* datamax mode, wal streaming */</comment>
	<expr_stmt><expr><name>state</name> <operator>=</operator> <name>WALRCV_STREAMING</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SpinLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>walrcv</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>walrcv</name><operator>-&gt;</operator><name>walRcvState</name></name> <operator>=</operator> <name>state</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SpinLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>walrcv</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>test_create_wal_or_ready_file</name><argument_list>(<argument><expr><name>seg</name></expr></argument>, <argument><expr><name>tli</name></expr></argument>, <argument><expr><name>wal_file_num</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>XLogSegNoOffsetToRecPtr</name><argument_list>(<argument><expr><name>seg</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>wal_segment_size</name></expr></argument>, <argument><expr><name>reserved_lsn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>polar_datamax_update_received_info</name><argument_list>(<argument><expr><name>polar_datamax_ctl</name></expr></argument>, <argument><expr><name>tli</name></expr></argument>, <argument><expr><name>reserved_lsn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>polar_datamax_prealloc_walfile_timeout</name> <operator>=</operator> <literal type="number">1000</literal></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>sleep</name><argument_list>(<argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>polar_is_datamax_mode</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>polar_datamax_prealloc_wal_file</name><argument_list>(<argument><expr><name>polar_datamax_ctl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr> ;</init> <condition><expr><name>i</name> <operator>&lt;=</operator> <name>polar_datamax_prealloc_walfile_num</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><call><name>XLogFilePath</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>tli</name></expr></argument>, <argument><expr><name>seg</name> <operator>+</operator> <name>i</name></expr></argument>, <argument><expr><name>wal_segment_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>polar_stat</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>stat_mode</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<comment type="block">/* wal file have been preallocated before */</comment>
	<expr_stmt><expr><call><name>sleep</name><argument_list>(<argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>polar_datamax_prealloc_wal_file</name><argument_list>(<argument><expr><name>polar_datamax_ctl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>test_delete_wal_file</name><argument_list>(<argument><expr><name>seg</name></expr></argument>, <argument><expr><name>tli</name></expr></argument>, <argument><expr><name>wal_file_num</name> <operator>+</operator> <name>polar_datamax_prealloc_walfile_num</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>polar_set_node_type</name><argument_list>(<argument><expr><name>POLAR_MASTER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>test_polar_datamax_create_walfile</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>modify_wal</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>long</name></type> <name>modify_start</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TEST_WAL_SIZE</name></cpp:macro> <cpp:value>16*1024*1024</cpp:value></cpp:define>	
	<decl_stmt><decl><type><name>char</name></type> <name><name>path</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type> <name><name>readpath</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name> <init>= <expr><literal type="string">"/home/postgres/polardb_pg/src/test/modules/test_polar_datamax/000000010000000000000001"</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>fd</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>FILE</name> <modifier>*</modifier></type><name>readfile</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>nbytes</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>buffer</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>start</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>XLogSegNo</name></type> <name>segno</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TimeLineID</name></type> <name>tli</name></decl>;</decl_stmt>

	<comment type="block">/* create wal file 000000010000000000000001 in polar_datamax/pg_wal dir */</comment>
	<expr_stmt><expr><name>segno</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>tli</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>test_create_wal_or_ready_file</name><argument_list>(<argument><expr><name>segno</name></expr></argument>, <argument><expr><name>tli</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	
	<comment type="block">/* file allocate */</comment>
	<expr_stmt><expr><call><name>XLogFilePath</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>tli</name></expr></argument>, <argument><expr><name>segno</name></expr></argument>, <argument><expr><name>wal_segment_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>fd</name> <operator>=</operator> <call><name>PathNameOpenFile</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>O_RDWR</name> <operator>|</operator> <name>PG_BINARY</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"could not open file \"%s\""</literal></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>	
	<if_stmt><if>if <condition>(<expr><call><name>polar_fallocate</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>wal_segment_size</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"polar_fallocate file \"%s\" failed"</literal></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>	

	<comment type="block">/* read from test walfile */</comment>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>readfile</name> <operator>=</operator> <call><name>fopen</name><argument_list>(<argument><expr><name>readpath</name></expr></argument>, <argument><expr><literal type="string">"rb"</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"could not open file 000000010000000000000001 for read "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>rewind</name><argument_list>(<argument><expr><name>readfile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>buffer</name> <operator>=</operator> <operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><call><name>malloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>char</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>TEST_WAL_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>buffer</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"allocate memory for buffer error"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return;</return>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>fread</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>TEST_WAL_SIZE</name></expr></argument>, <argument><expr><name>readfile</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>TEST_WAL_SIZE</name></expr>)</condition>
    <block>{<block_content>
       <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"read file 000000010000000000000001 failed"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	   <return>return;</return>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>fclose</name><argument_list>(<argument><expr><name>readfile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* modify the last byte to make xlog checksum error */</comment>
	<if_stmt><if>if <condition>(<expr><name>modify_wal</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>buffer</name> <operator>+</operator> <name>modify_start</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TEST_WAL_SIZE</name> <operator>-</operator> <name>modify_start</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* copy 16M from test walfile to polar_datamax/pg_wal/walfile, and fill 0 for remain space */</comment>
	<for>for <control>(<init><expr><name>nbytes</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>nbytes</name> <operator>&lt;</operator> <name>wal_segment_size</name></expr>;</condition> <incr><expr><name>nbytes</name> <operator>+=</operator> <name>XLOG_BLCKSZ</name></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><name>errno</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>nbytes</name> <operator>&lt;</operator> <name>TEST_WAL_SIZE</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>start</name> <operator>=</operator> <name>buffer</name> <operator>+</operator> <name>nbytes</name></expr>;</expr_stmt></block_content></block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>char</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>TEST_WAL_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>start</name> <operator>=</operator> <name>buffer</name></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
		<if_stmt><if>if <condition>(<expr><operator>(</operator><name>int</name><operator>)</operator> <call><name>polar_write</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name>start</name></expr></argument>, <argument><expr><name>XLOG_BLCKSZ</name></expr></argument>)</argument_list></call> <operator>!=</operator> <operator>(</operator><name>int</name><operator>)</operator> <name>XLOG_BLCKSZ</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>int</name></type> <name>save_errno</name> <init>= <expr><name>errno</name></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><call><name>polar_unlink</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>polar_close</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* if write didn't set errno, assume problem is no disk space */</comment>
			<expr_stmt><expr><name>errno</name> <operator>=</operator> <ternary><condition><expr><name>save_errno</name></expr> ?</condition><then> <expr><name>save_errno</name></expr> </then><else>: <expr><name>ENOSPC</name></expr></else></ternary></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
						<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not write to file \"%s\": %m"</literal></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>
	<if_stmt><if>if <condition>(<expr><call><name>polar_fsync</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type> 		<name>save_errno</name> <init>= <expr><name>errno</name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>polar_close</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>errno</name> <operator>=</operator> <name>save_errno</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
					<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not fsync file \"%s\": %m"</literal></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>	
	<if_stmt><if>if <condition>(<expr><call><name>polar_close</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not close file \"%s\": %m"</literal></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>test_polar_datamax_parse_xlog</name><parameter_list>()</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TimeLineID</name></type> <name>tli</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>XLogRecPtr</name></type>  <name>received_lsn</name> <init>= <expr><name>InvalidXLogRecPtr</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>XLogRecPtr</name></type>  <name>valid_lsn</name> <init>= <expr><name>InvalidXLogRecPtr</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>XLogRecPtr</name></type>  <name>last_valid_lsn</name> <init>= <expr><name>InvalidXLogRecPtr</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>modify_start</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<comment type="block">/* case 1 received_lsn and valid_lsn are both invalid */</comment>
	<expr_stmt><expr><name>polar_enable_shared_storage_mode</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>polar_local_node_type</name> <operator>=</operator> <name>POLAR_STANDALONE_DATAMAX</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>polar_datamax_validate_dir</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>polar_datamax_init_meta</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>polar_datamax_ctl</name><operator>-&gt;</operator><name>meta</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>polar_datamax_parse_xlog</name><argument_list>(<argument><expr><name>polar_datamax_ctl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* case 2 xlog is correct, parse xlog */</comment>
	<expr_stmt><expr><name>tli</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>received_lsn</name> <operator>=</operator> <literal type="number">0x40FFF1F0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>valid_lsn</name> <operator>=</operator> <literal type="number">0x40000098</literal></expr>;</expr_stmt>	
	<expr_stmt><expr><call><name>polar_datamax_update_received_info</name><argument_list>(<argument><expr><name>polar_datamax_ctl</name></expr></argument>, <argument><expr><name>tli</name></expr></argument>, <argument><expr><name>received_lsn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>polar_datamax_update_last_valid_received_lsn</name><argument_list>(<argument><expr><name>polar_datamax_ctl</name></expr></argument>, <argument><expr><name>valid_lsn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>test_polar_datamax_create_walfile</name><argument_list>(<argument><expr><name>false</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>polar_datamax_parse_xlog</name><argument_list>(<argument><expr><name>polar_datamax_ctl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* valid_lsn will be updated after parsing xlog */</comment>
	<expr_stmt><expr><name>valid_lsn</name> <operator>=</operator> <call><name>polar_datamax_get_last_valid_received_lsn</name><argument_list>(<argument><expr><name>polar_datamax_ctl</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tli</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>received_lsn</name> <operator>==</operator> <name>valid_lsn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* case 3 modify xlog */</comment>
	<expr_stmt><expr><name>received_lsn</name> <operator>=</operator> <literal type="number">0x40FFF1F0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>valid_lsn</name> <operator>=</operator> <literal type="number">0x40000098</literal></expr>;</expr_stmt>	
	<expr_stmt><expr><name>last_valid_lsn</name> <operator>=</operator> <literal type="number">0x40FFD878</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>modify_start</name> <operator>=</operator> <literal type="number">16767096</literal></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>polar_datamax_init_meta</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>polar_datamax_ctl</name><operator>-&gt;</operator><name>meta</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>polar_datamax_update_received_info</name><argument_list>(<argument><expr><name>polar_datamax_ctl</name></expr></argument>, <argument><expr><name>tli</name></expr></argument>, <argument><expr><name>received_lsn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>polar_datamax_update_last_valid_received_lsn</name><argument_list>(<argument><expr><name>polar_datamax_ctl</name></expr></argument>, <argument><expr><name>valid_lsn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>test_polar_datamax_create_walfile</name><argument_list>(<argument><expr><name>true</name></expr></argument>, <argument><expr><name>modify_start</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>polar_datamax_parse_xlog</name><argument_list>(<argument><expr><name>polar_datamax_ctl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* valid_lsn will be updated after parsing xlog */</comment>
	<expr_stmt><expr><name>valid_lsn</name> <operator>=</operator> <call><name>polar_datamax_get_last_valid_received_lsn</name><argument_list>(<argument><expr><name>polar_datamax_ctl</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>valid_lsn</name> <operator>==</operator> <name>last_valid_lsn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>polar_local_node_type</name> <operator>=</operator> <name>POLAR_MASTER</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>test_polar_datamax_valid_lsn_list_operation</name><parameter_list>()</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>XLogRecPtr</name></type>  <name>valid_lsn</name> <init>= <expr><name>InvalidXLogRecPtr</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>polar_datamax_valid_lsn_list</name>	<modifier>*</modifier></type><name>polar_datamax_received_valid_lsn_list</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* case 1 init valid lsn list */</comment>
	<expr_stmt><expr><name>polar_datamax_received_valid_lsn_list</name> <operator>=</operator> <call><name>polar_datamax_create_valid_lsn_list</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* case 2 insert new valid lsn */</comment>
	<expr_stmt><expr><call><name>polar_datamax_insert_last_valid_lsn</name><argument_list>(<argument><expr><name>polar_datamax_received_valid_lsn_list</name></expr></argument>, <argument><expr><operator>(</operator><name>uint64</name><operator>)</operator><operator>(</operator><literal type="number">2</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* insert duplicate value */</comment>
	<expr_stmt><expr><call><name>polar_datamax_insert_last_valid_lsn</name><argument_list>(<argument><expr><name>polar_datamax_received_valid_lsn_list</name></expr></argument>, <argument><expr><operator>(</operator><name>uint64</name><operator>)</operator><operator>(</operator><literal type="number">2</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>polar_datamax_insert_last_valid_lsn</name><argument_list>(<argument><expr><name>polar_datamax_received_valid_lsn_list</name></expr></argument>, <argument><expr><operator>(</operator><name>uint64</name><operator>)</operator><operator>(</operator><literal type="number">4</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>polar_datamax_insert_last_valid_lsn</name><argument_list>(<argument><expr><name>polar_datamax_received_valid_lsn_list</name></expr></argument>, <argument><expr><operator>(</operator><name>uint64</name><operator>)</operator><operator>(</operator><literal type="number">6</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>polar_datamax_received_valid_lsn_list</name><operator>-&gt;</operator><name>list_length</name></name> <operator>==</operator> <literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* insert when reach max value */</comment>
	<expr_stmt><expr><name><name>polar_datamax_received_valid_lsn_list</name><operator>-&gt;</operator><name>list_length</name></name> <operator>=</operator> <literal type="number">200</literal></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>polar_datamax_insert_last_valid_lsn</name><argument_list>(<argument><expr><name>polar_datamax_received_valid_lsn_list</name></expr></argument>, <argument><expr><operator>(</operator><name>uint64</name><operator>)</operator><operator>(</operator><literal type="number">8</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>polar_datamax_received_valid_lsn_list</name><operator>-&gt;</operator><name>list_length</name></name> <operator>==</operator> <literal type="number">200</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* case 3 update meta.valid_lsn */</comment>
	<expr_stmt><expr><name>polar_enable_shared_storage_mode</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>polar_local_node_type</name> <operator>=</operator> <name>POLAR_STANDALONE_DATAMAX</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>polar_datamax_validate_dir</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>polar_datamax_init_meta</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>polar_datamax_ctl</name><operator>-&gt;</operator><name>meta</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* update when list length is 0 */</comment>
	<expr_stmt><expr><name><name>polar_datamax_received_valid_lsn_list</name><operator>-&gt;</operator><name>list_length</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>polar_datamax_update_cur_valid_lsn</name><argument_list>(<argument><expr><name>polar_datamax_received_valid_lsn_list</name></expr></argument>, <argument><expr><operator>(</operator><name>uint64</name><operator>)</operator><operator>(</operator><literal type="number">1</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>valid_lsn</name> <operator>=</operator> <call><name>polar_datamax_get_last_valid_received_lsn</name><argument_list>(<argument><expr><name>polar_datamax_ctl</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>valid_lsn</name> <operator>==</operator> <name>InvalidXLogRecPtr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* update when flush_lsn &lt; smaller lsn */</comment>
	<expr_stmt><expr><name><name>polar_datamax_received_valid_lsn_list</name><operator>-&gt;</operator><name>list_length</name></name> <operator>=</operator> <literal type="number">3</literal></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>polar_datamax_update_cur_valid_lsn</name><argument_list>(<argument><expr><name>polar_datamax_received_valid_lsn_list</name></expr></argument>, <argument><expr><operator>(</operator><name>uint64</name><operator>)</operator><operator>(</operator><literal type="number">1</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>polar_datamax_received_valid_lsn_list</name><operator>-&gt;</operator><name>list_length</name></name> <operator>==</operator> <literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>valid_lsn</name> <operator>=</operator> <call><name>polar_datamax_get_last_valid_received_lsn</name><argument_list>(<argument><expr><name>polar_datamax_ctl</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>valid_lsn</name> <operator>==</operator> <name>InvalidXLogRecPtr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* update valid lsn */</comment>
	<expr_stmt><expr><call><name>polar_datamax_update_cur_valid_lsn</name><argument_list>(<argument><expr><name>polar_datamax_received_valid_lsn_list</name></expr></argument>, <argument><expr><operator>(</operator><name>uint64</name><operator>)</operator><operator>(</operator><literal type="number">5</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>polar_datamax_received_valid_lsn_list</name><operator>-&gt;</operator><name>list_length</name></name> <operator>==</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>valid_lsn</name> <operator>=</operator> <call><name>polar_datamax_get_last_valid_received_lsn</name><argument_list>(<argument><expr><name>polar_datamax_ctl</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>valid_lsn</name> <operator>==</operator> <literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* free memory of valid_lsn_list */</comment>
	<expr_stmt><expr><call><name>polar_datamax_free_valid_lsn_list</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>polar_datamax_received_valid_lsn_list</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>polar_local_node_type</name> <operator>=</operator> <name>POLAR_MASTER</name></expr>;</expr_stmt>

</block_content>}</block></function>


<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>test_polar_datamax</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<comment type="block">/*
 * SQL-callable entry point to perform all tests.
 */</comment>
<function><type><name>Datum</name></type>
<name>test_polar_datamax</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>polar_enable_shared_storage_mode</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PG_RETURN_VOID</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"start of test case."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>test_polar_datamax_shmem_size</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>test_polar_datamax_shmem_init</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>test_polar_datamax_validate_dir</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>test_polar_datamax_read_recovery_conf</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>test_polar_datamax_is_initial</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>test_polar_datamax_init_meta</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>test_polar_datamax_load_write_meta</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>test_polar_datamax_update_received_info</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>test_polar_datamax_update_min_received_info</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>test_polar_datamax_handle_timeline_switch</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>test_polar_datamax_remove_old_wal</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>test_polar_datamax_reset_clean_task</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>test_polar_datamax_set_clean_task</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>test_polar_datamax_handle_clean_task</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>test_polar_datamax_replication_start_lsn</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>test_polar_datamax_archive_and_remove_archivedone</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>test_polar_datamax_save_replication_slots</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>test_polar_datamax_prealloc_wal_file</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>test_polar_datamax_parse_xlog</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>test_polar_datamax_valid_lsn_list_operation</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* detele datamax dirs created for test */</comment>
	<expr_stmt><expr><call><name>test_polar_datamax_validate_dir</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_VOID</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

</unit>
