<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/PolarDB-for-PostgreSQL/src/test/modules/test_flashback_log/test_flashback_log.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * test_flashback_log.c
 *
 *
 * Copyright (c) 2020-2120, Alibaba-inc PolarDB Group
 *
 * IDENTIFICATION
 *	  src/test/modules/test_flashback_log/test_flashback_log.c
 *
 *-------------------------------------------------------------------------
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/heapam.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/polar_logindex_redo.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/polar_ringbuf.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/xlog.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/xlog_internal.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_class.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_tablespace_d.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_type_d.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_extension_d.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_cast_d.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_aggregate_d.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_database_d.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_am_d.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"polar_flashback/polar_flashback_log.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"polar_flashback/polar_flashback_log_decoder.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"polar_flashback/polar_flashback_log_file.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"polar_flashback/polar_flashback_log_index.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"polar_flashback/polar_flashback_log_index_queue.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"polar_flashback/polar_flashback_log_insert.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"polar_flashback/polar_flashback_log_internal.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"polar_flashback/polar_flashback_log_list.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"polar_flashback/polar_flashback_log_mem.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"polar_flashback/polar_flashback_log_reader.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"polar_flashback/polar_flashback_log_record.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"polar_flashback/polar_flashback_log_repair_page.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"polar_flashback/polar_flashback_log_worker.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"polar_flashback/polar_flashback_point.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postmaster/bgworker.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/bufmgr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/bufpage.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/buf_internals.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/checksum.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/ipc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/pg_shmem.h"</cpp:file></cpp:include>

<expr_stmt><expr><name>PG_MODULE_MAGIC</name></expr>;</expr_stmt>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TEST_FLOG_NAME</name></cpp:macro> <cpp:value>"testflog"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TEST_FLOG_INSERT_LOCKS</name></cpp:macro> <cpp:value>2</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TEST_FLOG_BUFS</name></cpp:macro> <cpp:value>10</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TEST_FLOG_INDEX_MEM_SIZE</name></cpp:macro> <cpp:value>3</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TEST_FLOG_INDEX_BLOOM_BLKS</name></cpp:macro> <cpp:value>8</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TEST_FLOG_QUEUE_BUFS</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>QUEUE_PKT_SIZE</name></cpp:macro> <cpp:value>FLOG_INDEX_QUEUE_PKT_SIZE(FLOG_INDEX_QUEUE_DATA_SIZE)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FLOG_REC_EMPTY_PAGE_SIZE</name></cpp:macro> <cpp:value>(FLOG_REC_HEADER_SIZE + FL_ORIGIN_PAGE_REC_INFO_SIZE)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TEST_FLOG_PREALLOC_FILE_NUM</name></cpp:macro> <cpp:value>2</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TEST_BUF_LIST_NUM</name></cpp:macro> <cpp:value>6</cpp:value></cpp:define>

<comment type="block">/* Saved hook values in case of unload */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>shmem_startup_hook_type</name></type> <name>prev_shmem_startup_hook</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>insert_empty_page_rec_num</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>Oid</name></type> <name><name>test_relnodes</name><index>[<expr><name>TEST_BUF_LIST_NUM</name></expr>]</index></name> <init>=
<expr><block>{
	<expr><name>TypeRelationId</name></expr>,
	<expr><name>TableSpaceRelationId</name></expr>,
	<expr><name>CastRelationId</name></expr>,
	<expr><name>AggregateRelationId</name></expr>,
	<expr><name>DatabaseRelationId</name></expr>,
	<expr><name>AccessMethodRelationId</name></expr>
}</block></expr></init></decl>;</decl_stmt>

<comment type="block">/* Test buffer list, the buffer id from 0 */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name><name>test_bufs</name><index>[<expr><name>TEST_BUF_LIST_NUM</name></expr>]</index></name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>flog_ctl_t</name></type> <name>test_instance</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>flog_buf_ctl_t</name></type> <name>buf_ctl_test</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>flog_list_ctl_t</name></type> <name>flog_list_test</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>flog_index_queue_ctl_t</name></type> <name>flog_index_queue_test</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>logindex_snapshot_t</name></type> <name>flog_index_test</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<comment type="block">/*---- Function declarations ----*/</comment>
<function_decl><type><name>void</name></type>		<name>_PG_init</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type>		<name>_PG_fini</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>check_dir_validate</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>path</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name><name>struct</name> <name>stat</name></name></type> <name>st</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>(</operator><call><name>polar_stat</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>st</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal><operator>)</operator> <operator>&amp;&amp;</operator> <call><name>S_ISDIR</name><argument_list>(<argument><expr><name><name>st</name><operator>.</operator><name>st_mode</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>polar_flog_rec_ptr</name></type>
<name>flog_valid_ptr_from_end</name><parameter_list>(<parameter><decl><type><name>polar_flog_rec_ptr</name></type> <name>ptr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>ptr</name> <operator>%</operator> <name>POLAR_FLOG_SEG_SIZE</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>ptr</name> <operator>+</operator> <name>FLOG_LONG_PHD_SIZE</name></expr>;</return></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><name>ptr</name> <operator>%</operator> <name>POLAR_FLOG_BLCKSZ</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>ptr</name> <operator>+</operator> <name>FLOG_SHORT_PHD_SIZE</name></expr>;</return></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<return>return <expr><name>ptr</name></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>init_flog_buf_ctl_data</name><parameter_list>(<parameter><decl><type><name>flog_ctl_file_data_t</name> <modifier>*</modifier></type><name>ctl_file_data</name></decl></parameter>,
		<parameter><decl><type><name>uint64</name></type> <name>max_seg_no</name></decl></parameter>, <parameter><decl><type><name>polar_flog_rec_ptr</name></type> <name>flog_end_ptr</name></decl></parameter>,
		<parameter><decl><type><name>polar_flog_rec_ptr</name></type> <name>flog_end_ptr_prev</name></decl></parameter>,
		<parameter><decl><type><name>polar_flog_rec_ptr</name></type> <name>flog_start_ptr</name></decl></parameter>,
		<parameter><decl><type><name>fbpoint_wal_info_data_t</name></type> <name>wal_info</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>is_shutdown</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>ctl_file_data</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>flog_ctl_file_data_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ctl_file_data</name><operator>-&gt;</operator><name>max_seg_no</name></name> <operator>=</operator> <name>max_seg_no</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ctl_file_data</name><operator>-&gt;</operator><name>fbpoint_info</name><operator>.</operator><name>flog_end_ptr</name></name> <operator>=</operator> <name>flog_end_ptr</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ctl_file_data</name><operator>-&gt;</operator><name>fbpoint_info</name><operator>.</operator><name>flog_end_ptr_prev</name></name> <operator>=</operator> <name>flog_end_ptr_prev</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ctl_file_data</name><operator>-&gt;</operator><name>fbpoint_info</name><operator>.</operator><name>flog_start_ptr</name></name> <operator>=</operator> <name>flog_start_ptr</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ctl_file_data</name><operator>-&gt;</operator><name>version_no</name></name> <operator>=</operator> <name>FLOG_CTL_FILE_VERSION</name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>is_shutdown</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>ctl_file_data</name><operator>-&gt;</operator><name>version_no</name></name> <operator>|=</operator> <name>FLOG_SHUTDOWNED</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name><name>ctl_file_data</name><operator>-&gt;</operator><name>fbpoint_info</name><operator>.</operator><name>wal_info</name></name> <operator>=</operator> <name>wal_info</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>polar_flog_rec_ptr</name></type>
<name>compute_empty_page_next_ptr</name><parameter_list>(<parameter><decl><type><name>polar_flog_rec_ptr</name></type> <name>start_ptr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>uint64</name></type> <name>len</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint64</name></type> <name>free_space_blk</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint64</name></type> <name>free_space_seg</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>len</name> <operator>=</operator> <name>FLOG_REC_EMPTY_PAGE_SIZE</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>start_ptr</name> <operator>=</operator> <call><name>flog_valid_ptr_from_end</name><argument_list>(<argument><expr><name>start_ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>free_space_blk</name> <operator>=</operator> <name>POLAR_FLOG_BLCKSZ</name> <operator>-</operator> <operator>(</operator><name>start_ptr</name> <operator>%</operator> <name>POLAR_FLOG_BLCKSZ</name><operator>)</operator></expr>;</expr_stmt>
	<expr_stmt><expr><name>free_space_seg</name> <operator>=</operator> <name>POLAR_FLOG_SEG_SIZE</name> <operator>-</operator> <operator>(</operator><name>start_ptr</name> <operator>%</operator> <name>POLAR_FLOG_SEG_SIZE</name><operator>)</operator></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>free_space_blk</name> <operator>&gt;=</operator> <name>len</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><call><name>MAXALIGN64</name><argument_list>(<argument><expr><name>start_ptr</name> <operator>+</operator> <name>len</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><name>free_space_seg</name> <operator>&lt;</operator> <name>len</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><call><name>MAXALIGN64</name><argument_list>(<argument><expr><name>start_ptr</name> <operator>+</operator> <name>FLOG_LONG_PHD_SIZE</name> <operator>+</operator> <name>len</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<return>return <expr><call><name>MAXALIGN64</name><argument_list>(<argument><expr><name>start_ptr</name> <operator>+</operator> <name>FLOG_SHORT_PHD_SIZE</name> <operator>+</operator> <name>len</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>polar_flog_rec_ptr</name></type>
<name>compute_empty_page_start_ptr</name><parameter_list>(<parameter><decl><type><name>polar_flog_rec_ptr</name></type> <name>end_ptr</name></decl></parameter>, <parameter><decl><type><name>Size</name></type> <name>size</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>polar_flog_rec_ptr</name></type> <name>start_ptr</name> <init>= <expr><name>POLAR_INVALID_FLOG_REC_PTR</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>polar_flog_rec_ptr</name></type> <name>pos</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>pos</name> <operator>=</operator> <call><name>polar_flog_ptr2pos</name><argument_list>(<argument><expr><name>end_ptr</name></expr></argument>)</argument_list></call> <operator>-</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><name>FLOG_REC_EMPTY_PAGE_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>start_ptr</name> <operator>=</operator> <call><name>polar_flog_pos2ptr</name><argument_list>(<argument><expr><name>pos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>start_ptr</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>check_flog_list_init</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>flog_list_test</name><operator>-&gt;</operator><name>head</name></name> <operator>==</operator> <name>NOT_IN_FLOG_LIST</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>flog_list_test</name><operator>-&gt;</operator><name>tail</name></name> <operator>==</operator> <name>NOT_IN_FLOG_LIST</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>pg_atomic_read_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>flog_list_test</name><operator>-&gt;</operator><name>insert_total_num</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>pg_atomic_read_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>flog_list_test</name><operator>-&gt;</operator><name>remove_total_num</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>flog_list_test</name><operator>-&gt;</operator><name>bg_remove_num</name></name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>NBuffers</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>flog_list_slot</name></type> <name>slot</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>slot</name> <operator>=</operator> <name><name>flog_list_test</name><operator>-&gt;</operator><name>flashback_list</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>slot</name><operator>.</operator><name>flashback_ptr</name></name> <operator>==</operator> <name>POLAR_INVALID_FLOG_REC_PTR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>slot</name><operator>.</operator><name>info</name></name> <operator>==</operator> <name>FLOG_LIST_SLOT_EMPTY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>slot</name><operator>.</operator><name>prev_buf</name></name> <operator>==</operator> <name>NOT_IN_FLOG_LIST</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>slot</name><operator>.</operator><name>next_buf</name></name> <operator>==</operator> <name>NOT_IN_FLOG_LIST</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>slot</name><operator>.</operator><name>redo_lsn</name></name> <operator>==</operator> <name>InvalidXLogRecPtr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>check_flog_buf_init</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>insert_locks_num</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>log_buffers</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name></type> <name><name>buf</name><index>[<expr><name>POLAR_FLOG_BLCKSZ</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>POLAR_FLOG_BLCKSZ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>pg_atomic_read_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>buf_ctl_test</name><operator>-&gt;</operator><name>write_total_num</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>pg_atomic_read_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>buf_ctl_test</name><operator>-&gt;</operator><name>segs_added_total_num</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>buf_ctl_test</name><operator>-&gt;</operator><name>cache_blck</name></name> <operator>==</operator> <name>log_buffers</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>buf_ctl_test</name><operator>-&gt;</operator><name>write_result</name></name> <operator>==</operator> <name>POLAR_INVALID_FLOG_REC_PTR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>buf_ctl_test</name><operator>-&gt;</operator><name>write_request</name></name> <operator>==</operator> <name>POLAR_INVALID_FLOG_REC_PTR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>buf_ctl_test</name><operator>-&gt;</operator><name>max_seg_no</name></name> <operator>==</operator> <name>POLAR_INVALID_FLOG_SEGNO</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>strncmp</name><argument_list>(<argument><expr><name><name>buf_ctl_test</name><operator>-&gt;</operator><name>dir</name></name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>FL_INS_MAX_NAME_LEN</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>buf_ctl_test</name><operator>-&gt;</operator><name>insert</name><operator>.</operator><name>insert_locks_num</name></name> <operator>==</operator> <name>insert_locks_num</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>buf_ctl_test</name><operator>-&gt;</operator><name>buf_state</name></name> <operator>==</operator> <name>FLOG_BUF_INIT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>log_buffers</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>polar_flog_rec_ptr</name></type> <name>ptr</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>ptr</name> <operator>=</operator> <name><name>buf_ctl_test</name><operator>-&gt;</operator><name>blocks</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>ptr</name> <operator>==</operator> <name>POLAR_INVALID_FLOG_REC_PTR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>memcmp</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><operator>&amp;</operator><operator>(</operator><name><name>buf_ctl_test</name><operator>-&gt;</operator><name>pages</name><index>[<expr><name>i</name> <operator>*</operator> <name>POLAR_FLOG_BLCKSZ</name></expr>]</index></name><operator>)</operator></expr></argument>, <argument><expr><name>POLAR_FLOG_BLCKSZ</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>insert_locks_num</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>flog_insert_lock_padded</name> <modifier>*</modifier></type><name>lock</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>lock</name> <operator>=</operator> <name><name>buf_ctl_test</name><operator>-&gt;</operator><name>insert</name><operator>.</operator><name>insert_locks</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>lock</name><operator>-&gt;</operator><name>l</name><operator>.</operator><name>inserting_at</name></name> <operator>==</operator> <name>POLAR_INVALID_FLOG_REC_PTR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>polar_log_flog_buf_state</name><argument_list>(<argument><expr><name><name>buf_ctl_test</name><operator>-&gt;</operator><name>buf_state</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>check_flog_queue_init</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>queue_buffers_MB</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>polar_ringbuf_t</name></type> <name>queue</name> <init>= <expr><name><name>flog_index_queue_test</name><operator>-&gt;</operator><name>queue</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Size</name></type> <name>queue_size</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint8</name> <modifier>*</modifier></type><name>data_expected</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint64</name></type> <name>free_up_times</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint64</name></type> <name>read_from_file_rec_nums</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint64</name></type> <name>read_from_queue_rec_nums</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>flog_index_queue_stat</name> <modifier>*</modifier></type><name>queue_stat</name> <init>= <expr><name><name>flog_index_queue_test</name><operator>-&gt;</operator><name>queue_stat</name></name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>queue_size</name> <operator>=</operator> <name>queue_buffers_MB</name> <operator>*</operator> <literal type="number">1024L</literal> <operator>*</operator> <literal type="number">1024L</literal></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pg_atomic_init_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>queue</name><operator>-&gt;</operator><name>pread</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pg_atomic_init_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>queue</name><operator>-&gt;</operator><name>pwrite</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>data_expected</name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>queue_size</name> <operator>-</operator> <call><name>offsetof</name><argument_list>(<argument><expr><name>polar_ringbuf_data_t</name></expr></argument>, <argument><expr><name>data</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>POLAR_RINGBUF_MAX_SLOT</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>polar_ringbuf_slot_t</name></type> <name>slot_expected</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>slot_expected</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>polar_ringbuf_slot_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>memcmp</name><argument_list>(<argument><expr><operator>&amp;</operator><name>slot_expected</name></expr></argument>, <argument><expr><operator>&amp;</operator><operator>(</operator><name><name>queue</name><operator>-&gt;</operator><name>slot</name><index>[<expr><name>i</name></expr>]</index></name><operator>)</operator></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>polar_ringbuf_slot_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>queue</name><operator>-&gt;</operator><name>size</name></name> <operator>==</operator> <name>queue_size</name> <operator>-</operator> <call><name>offsetof</name><argument_list>(<argument><expr><name>polar_ringbuf_data_t</name></expr></argument>, <argument><expr><name>data</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>queue</name><operator>-&gt;</operator><name>occupied</name></name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>data_expected</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>queue_size</name> <operator>-</operator> <call><name>offsetof</name><argument_list>(<argument><expr><name>polar_ringbuf_data_t</name></expr></argument>, <argument><expr><name>data</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>memcmp</name><argument_list>(<argument><expr><name>data_expected</name></expr></argument>, <argument><expr><name><name>queue</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name><name>queue</name><operator>-&gt;</operator><name>size</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>polar_get_flog_index_queue_stat</name><argument_list>(<argument><expr><name>queue_stat</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>free_up_times</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>read_from_file_rec_nums</name></expr></argument>,
			<argument><expr><operator>&amp;</operator><name>read_from_queue_rec_nums</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>free_up_times</name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>read_from_file_rec_nums</name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>read_from_queue_rec_nums</name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>check_flog_index_init</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>flog_index_mem_size</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name></type> <name><name>flog_index_name</name><index>[<expr><name>FL_OBJ_MAX_NAME_LEN</name></expr>]</index></name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>flog_index_name</name></expr></argument>, <argument><expr><name>FL_OBJ_MAX_NAME_LEN</name></expr></argument>, <argument><expr><literal type="string">"%s%s"</literal></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>FL_LOGINDEX_SUFFIX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>flog_index_test</name><operator>-&gt;</operator><name>mem_tbl_size</name></name> <operator>==</operator> <call><name>polar_logindex_convert_mem_tbl_size</name><argument_list>(<argument><expr><name>flog_index_mem_size</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>pg_atomic_read_u32</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>flog_index_test</name><operator>-&gt;</operator><name>state</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>flog_index_test</name><operator>-&gt;</operator><name>max_allocated_seg_no</name></name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>flog_index_test</name><operator>-&gt;</operator><name>table_flushable</name></name> <operator>==</operator> <name>polar_flog_index_table_flushable</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>flog_index_test</name><operator>-&gt;</operator><name>dir</name></name></expr></argument>, <argument><expr><name>flog_index_name</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>flog_index_test</name><operator>-&gt;</operator><name>segment_cache</name></name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>check_flog_history_file</name><parameter_list>(<parameter><decl><type><name>polar_flog_rec_ptr</name></type> <name>switch_ptr</name></decl></parameter>, <parameter><decl><type><name>polar_flog_rec_ptr</name></type> <name>next_ptr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>cell</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>switch_ptrs</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>result</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>switch_ptrs</name> <operator>=</operator> <call><name>polar_read_flog_history_file</name><argument_list>(<argument><expr><name><name>buf_ctl_test</name><operator>-&gt;</operator><name>dir</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<macro><name>foreach</name><argument_list>(<argument>cell</argument>, <argument>switch_ptrs</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>flog_history_entry</name> <modifier>*</modifier></type><name>tle</name> <init>= <expr><operator>(</operator><name>flog_history_entry</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>cell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>switch_ptr</name> <operator>==</operator> <name><name>tle</name><operator>-&gt;</operator><name>switch_ptr</name></name> <operator>&amp;&amp;</operator>
				<name>next_ptr</name> <operator>==</operator> <name><name>tle</name><operator>-&gt;</operator><name>next_ptr</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block>
	<expr_stmt><expr><call><name>list_free_deep</name><argument_list>(<argument><expr><name>switch_ptrs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Check for flashback log record into buffer */</comment>
<function><type><specifier>static</specifier> <name>polar_flog_rec_ptr</name></type>
<name>test_flog_insert_to_buffer</name><parameter_list>(<parameter><decl><type><name>BufferTag</name></type> <name>test_tag</name></decl></parameter>, <parameter><decl><type><name>Page</name></type> <name>page</name></decl></parameter>, <parameter><decl><type><name>XLogRecPtr</name></type> <name>redo_lsn</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>polar_insert_buf_flog_rec</name><argument_list>(<argument><expr><name>buf_ctl_test</name></expr></argument>, <argument><expr><name>flog_index_queue_test</name></expr></argument>,
			<argument><expr><operator>&amp;</operator><name>test_tag</name></expr></argument>, <argument><expr><name>redo_lsn</name></expr></argument>, <argument><expr><call><name>polar_get_curr_fbpoint_lsn</name><argument_list>(<argument><expr><name>buf_ctl_test</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>page</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>check_flog_index_queue</name><parameter_list>(<parameter><decl><type><name>polar_flog_rec_ptr</name></type> <name>ptr</name></decl></parameter>, <parameter><decl><type><name>BufferTag</name></type> <name>tag_expected</name></decl></parameter>,
					   <parameter><decl><type><name>uint32</name></type> <name>log_len_expected</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>static</specifier> <name>polar_ringbuf_ref_t</name></type> <name>ref</name> <init>= <expr><block>{ <expr><operator>.</operator><name>slot</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>}</block></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BufferTag</name></type> <name>tag</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32</name></type> <name>log_len</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>polar_flog_rec_ptr</name></type> <name>max_ptr_in_disk</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>ref</name><operator>.</operator><name>slot</name></name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>polar_ringbuf_new_ref</name><argument_list>(<argument><expr><name><name>flog_index_queue_test</name><operator>-&gt;</operator><name>queue</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ref</name></expr></argument>, <argument><expr><literal type="string">"test_queue"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>max_ptr_in_disk</name> <operator>=</operator> <call><name>polar_get_flog_write_result</name><argument_list>(<argument><expr><name>buf_ctl_test</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* The flashback log may be not in the disk */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>polar_get_next_flog_ptr</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>log_len_expected</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <name>max_ptr_in_disk</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>uint32</name></type> <name>data_len</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>flog_index_queue_lsn_info</name></type> <name>lsn_info</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ssize_t</name></type> <name>offset</name> <init>= <expr><name>FLOG_INDEX_QUEUE_HEAD_SIZE</name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>lsn_info</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>flog_index_queue_lsn_info</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>polar_flog_index_queue_ref_pop</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ref</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>lsn_info</name></expr></argument>, <argument><expr><name>max_ptr_in_disk</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>data_len</name> <operator>=</operator> <name>FLOG_INDEX_QUEUE_DATA_SIZE</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>POLAR_COPY_QUEUE_CONTENT</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ref</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>, <argument><expr><operator>&amp;</operator><operator>(</operator><name><name>lsn_info</name><operator>.</operator><name>tag</name></name><operator>)</operator></expr></argument>, <argument><expr><name>data_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>polar_ringbuf_update_ref</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ref</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>tag</name> <operator>=</operator> <name><name>lsn_info</name><operator>.</operator><name>tag</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>log_len</name> <operator>=</operator> <name><name>lsn_info</name><operator>.</operator><name>log_len</name></name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>polar_flog_read_info_from_queue</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ref</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tag</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>log_len</name></expr></argument>, <argument><expr><name>max_ptr_in_disk</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>BUFFERTAGS_EQUAL</name><argument_list>(<argument><expr><name>tag_expected</name></expr></argument>, <argument><expr><name>tag</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>log_len</name> <operator>==</operator> <name>log_len_expected</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>check_flog_control_file</name><parameter_list>(<parameter><decl><type><name>polar_flog_rec_ptr</name></type> <name>start_ptr</name></decl></parameter>, <parameter><decl><type><name>polar_flog_rec_ptr</name></type> <name>end_ptr</name></decl></parameter>,
						<parameter><decl><type><name>polar_flog_rec_ptr</name></type> <name>end_ptr_prev</name></decl></parameter>, <parameter><decl><type><name>uint64</name></type> <name>max_seg_no</name></decl></parameter>,
						<parameter><decl><type><name>fbpoint_wal_info_data_t</name></type> <name>wal_info</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>is_shutdown</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>flog_ctl_file_data_t</name></type> <name>ctl_file_data</name></decl>;</decl_stmt>

	<comment type="block">/* Read the flashback log control file */</comment>
	<expr_stmt><expr><call><name>polar_read_flog_ctl_file</name><argument_list>(<argument><expr><name>buf_ctl_test</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ctl_file_data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>(</operator><name><name>ctl_file_data</name><operator>.</operator><name>version_no</name></name> <operator>&amp;</operator> <name>FLOG_CTL_VERSION_MASK</name><operator>)</operator> <operator>==</operator> <name>FLOG_CTL_FILE_VERSION</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>is_shutdown</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>ctl_file_data</name><operator>.</operator><name>version_no</name></name> <operator>&amp;</operator> <name>FLOG_SHUTDOWNED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>ctl_file_data</name><operator>.</operator><name>fbpoint_info</name><operator>.</operator><name>flog_end_ptr</name></name> <operator>==</operator> <name>end_ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>ctl_file_data</name><operator>.</operator><name>fbpoint_info</name><operator>.</operator><name>flog_end_ptr_prev</name></name> <operator>==</operator> <name>end_ptr_prev</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>ctl_file_data</name><operator>.</operator><name>fbpoint_info</name><operator>.</operator><name>flog_start_ptr</name></name> <operator>==</operator> <name>start_ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>ctl_file_data</name><operator>.</operator><name>max_seg_no</name></name> <operator>==</operator> <name>max_seg_no</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>ctl_file_data</name><operator>.</operator><name>fbpoint_info</name><operator>.</operator><name>wal_info</name><operator>.</operator><name>prior_fbpoint_lsn</name></name> <operator>==</operator>
			<name><name>wal_info</name><operator>.</operator><name>prior_fbpoint_lsn</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>ctl_file_data</name><operator>.</operator><name>fbpoint_info</name><operator>.</operator><name>wal_info</name><operator>.</operator><name>fbpoint_lsn</name></name> <operator>==</operator>
			<name><name>wal_info</name><operator>.</operator><name>fbpoint_lsn</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>ctl_file_data</name><operator>.</operator><name>fbpoint_info</name><operator>.</operator><name>wal_info</name><operator>.</operator><name>fbpoint_time</name></name> <operator>==</operator>
			<name><name>wal_info</name><operator>.</operator><name>fbpoint_time</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Test the flog insert to buffer.
 */</comment>
<function><type><specifier>static</specifier> <name>polar_flog_rec_ptr</name></type>
<name>test_flog_insert_buffer</name><parameter_list>(<parameter><decl><type><name>polar_flog_rec_ptr</name></type> <name>start_ptr</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>test_buf_full</name></decl></parameter>,
						<parameter><decl><type><name>bool</name></type> <name>check_queue</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>empty_page_num</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>polar_flog_rec_ptr</name></type> <name>end_ptr</name> <init>= <expr><name>POLAR_INVALID_FLOG_REC_PTR</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>empty_page_num</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>BufferTag</name></type> <name>test_tag</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>PGAlignedBlock</name></type> <name>page</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>XLogRecPtr</name></type> <name>redo_lsn</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>polar_flog_rec_ptr</name></type> <name>end_ptr_expected</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>PageInit</name><argument_list>(<argument><expr><operator>(</operator><name>Page</name><operator>)</operator><name><name>page</name><operator>.</operator><name>data</name></name></expr></argument>, <argument><expr><name>BLCKSZ</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>CLEAR_BUFFERTAG</name><argument_list>(<argument><expr><name>test_tag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>test_tag</name><operator>.</operator><name>rnode</name><operator>.</operator><name>dbNode</name></name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>test_tag</name><operator>.</operator><name>rnode</name><operator>.</operator><name>relNode</name></name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>test_tag</name><operator>.</operator><name>rnode</name><operator>.</operator><name>spcNode</name></name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>test_tag</name><operator>.</operator><name>forkNum</name></name> <operator>=</operator> <name>MAIN_FORKNUM</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>test_tag</name><operator>.</operator><name>blockNum</name></name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>redo_lsn</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>

		<expr_stmt><expr><name>end_ptr</name> <operator>=</operator> <call><name>test_flog_insert_to_buffer</name><argument_list>(<argument><expr><name>test_tag</name></expr></argument>, <argument><expr><operator>(</operator><name>Page</name><operator>)</operator><name><name>page</name><operator>.</operator><name>data</name></name></expr></argument>, <argument><expr><name>redo_lsn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>end_ptr_expected</name> <operator>=</operator> <call><name>compute_empty_page_next_ptr</name><argument_list>(<argument><expr><name>start_ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>end_ptr</name> <operator>==</operator> <name>end_ptr_expected</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Check the buffer is full */</comment>
		<if_stmt><if>if <condition>(<expr><name>test_buf_full</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>(</operator><name><name>buf_ctl_test</name><operator>-&gt;</operator><name>write_result</name></name> <operator>==</operator> <name>POLAR_FLOG_BLCKSZ</name><operator>)</operator> <operator>||</operator>
				   <operator>(</operator><name><name>buf_ctl_test</name><operator>-&gt;</operator><name>write_result</name></name> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>end_ptr</name> <operator>&gt;</operator> <name>POLAR_FLOG_BLCKSZ</name> <operator>*</operator> <name>TEST_FLOG_BUFS</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>test_buf_full</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>buf_ctl_test</name><operator>-&gt;</operator><name>write_result</name></name> <operator>==</operator> <name>POLAR_FLOG_BLCKSZ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* The queue is full, the buffer will advict */</comment>
		<if_stmt><if>if <condition>(<expr><name>QUEUE_PKT_SIZE</name> <operator>*</operator> <operator>(</operator><name>i</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>&gt;</operator> <name><name>flog_index_queue_test</name><operator>-&gt;</operator><name>queue</name><operator>-&gt;</operator><name>size</name></name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>check_queue</name></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>uint64</name></type> <name>free_up_times</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>uint64</name></type> <name>read_from_file_rec_nums</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>uint64</name></type> <name>read_from_queue_rec_nums</name></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>polar_get_flog_index_queue_stat</name><argument_list>(<argument><expr><name><name>flog_index_queue_test</name><operator>-&gt;</operator><name>queue_stat</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>free_up_times</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>read_from_file_rec_nums</name></expr></argument>,
												<argument><expr><operator>&amp;</operator><name>read_from_queue_rec_nums</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>free_up_times</name> <operator>==</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>read_from_file_rec_nums</name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>read_from_queue_rec_nums</name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<expr_stmt><expr><name>insert_empty_page_rec_num</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>check_queue</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>check_flog_index_queue</name><argument_list>(<argument><expr><call><name>VALID_FLOG_PTR</name><argument_list>(<argument><expr><name>start_ptr</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>test_tag</name></expr></argument>,
								   <argument><expr><name>FLOG_REC_EMPTY_PAGE_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>start_ptr</name> <operator>=</operator> <call><name>polar_get_next_flog_ptr</name><argument_list>(<argument><expr><name>start_ptr</name></expr></argument>,
											<argument><expr><name>FLOG_REC_EMPTY_PAGE_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>
	<return>return <expr><name>end_ptr</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>check_flog_dir_validate</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name></type> <name><name>name</name><index>[<expr><name>FL_INS_MAX_NAME_LEN</name></expr>]</index></name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>is_rm</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name></type> <name><name>flog_path</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type> <name><name>flog_index_path</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type> <name><name>logindex_name</name><index>[<expr><literal type="number">2</literal> <operator>*</operator> <name>FL_INS_MAX_NAME_LEN</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>is_valid</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>logindex_name</name></expr></argument>, <argument><expr><literal type="number">2</literal> <operator>*</operator> <name>FL_INS_MAX_NAME_LEN</name></expr></argument>, <argument><expr><literal type="string">"%s%s"</literal></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><literal type="string">"_index"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>polar_make_file_path_level2</name><argument_list>(<argument><expr><name>flog_path</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>is_valid</name> <operator>=</operator> <call><name>check_dir_validate</name><argument_list>(<argument><expr><name>flog_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>is_rm</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>is_valid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>is_valid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	<expr_stmt><expr><call><name>polar_make_file_path_level2</name><argument_list>(<argument><expr><name>flog_index_path</name></expr></argument>, <argument><expr><name>logindex_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>is_rm</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>check_dir_validate</name><argument_list>(<argument><expr><name>flog_index_path</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>check_dir_validate</name><argument_list>(<argument><expr><name>flog_index_path</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>check_flog_truncate</name><parameter_list>(<parameter><decl><type><name>polar_flog_rec_ptr</name></type> <name>ptr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>DIR</name>		   <modifier>*</modifier></type><name>xldir</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>dirent</name></name> <modifier>*</modifier></type><name>xlde</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>lastoff</name><index>[<expr><name>FLOG_MAX_FNAME_LEN</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>polar_path</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint64</name></type>      <name>seg_no</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>polar_make_file_path_level2</name><argument_list>(<argument><expr><name>polar_path</name></expr></argument>, <argument><expr><call><name>polar_get_flog_dir</name><argument_list>(<argument><expr><name>buf_ctl_test</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>seg_no</name> <operator>=</operator> <call><name>flog_ptr_to_seg</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>POLAR_FLOG_SEG_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>seg_no</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>seg_no</name><operator>--</operator></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>get_flog_fname</name><argument_list>(<argument><expr><name>lastoff</name></expr></argument>, <argument><expr><name>seg_no</name></expr></argument>, <argument><expr><name>POLAR_FLOG_SEG_SIZE</name></expr></argument>, <argument><expr><name>FLOG_DEFAULT_TIMELINE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>xldir</name> <operator>=</operator> <call><name>polar_allocate_dir</name><argument_list>(<argument><expr><name>polar_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<while>while <condition>(<expr><operator>(</operator><name>xlde</name> <operator>=</operator> <call><name>ReadDir</name><argument_list>(<argument><expr><name>xldir</name></expr></argument>, <argument><expr><name>polar_path</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Ignore files that are not flashback log segments */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>is_flashback_log_file</name><argument_list>(<argument><expr><name><name>xlde</name><operator>-&gt;</operator><name>d_name</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>xlde</name><operator>-&gt;</operator><name>d_name</name></name></expr></argument>, <argument><expr><name>lastoff</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></while>
	<expr_stmt><expr><call><name>FreeDir</name><argument_list>(<argument><expr><name>xldir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>check_flog_prealloc_files</name><parameter_list>(<parameter><decl><type><name>uint64</name></type> <name>seg_no</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>DIR</name>		   <modifier>*</modifier></type><name>xldir</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>dirent</name></name> <modifier>*</modifier></type><name>xlde</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>lastoff</name><index>[<expr><name>FLOG_MAX_FNAME_LEN</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>polar_path</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>polar_make_file_path_level2</name><argument_list>(<argument><expr><name>polar_path</name></expr></argument>, <argument><expr><call><name>polar_get_flog_dir</name><argument_list>(<argument><expr><name>buf_ctl_test</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>get_flog_fname</name><argument_list>(<argument><expr><name>lastoff</name></expr></argument>, <argument><expr><name>seg_no</name></expr></argument>, <argument><expr><name>POLAR_FLOG_SEG_SIZE</name></expr></argument>, <argument><expr><name>FLOG_DEFAULT_TIMELINE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>xldir</name> <operator>=</operator> <call><name>polar_allocate_dir</name><argument_list>(<argument><expr><name>polar_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<while>while <condition>(<expr><operator>(</operator><name>xlde</name> <operator>=</operator> <call><name>ReadDir</name><argument_list>(<argument><expr><name>xldir</name></expr></argument>, <argument><expr><name>polar_path</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Ignore files that are not flashback log segments */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>is_flashback_log_file</name><argument_list>(<argument><expr><name><name>xlde</name><operator>-&gt;</operator><name>d_name</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>xlde</name><operator>-&gt;</operator><name>d_name</name></name></expr></argument>, <argument><expr><name>lastoff</name></expr></argument>)</argument_list></call> <operator>&lt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></while>
	<expr_stmt><expr><call><name>FreeDir</name><argument_list>(<argument><expr><name>xldir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>flog_wal_info_equal</name><parameter_list>(<parameter><decl><type><name>fbpoint_wal_info_data_t</name></type> <name>info1</name></decl></parameter>, <parameter><decl><type><name>fbpoint_wal_info_data_t</name></type> <name>info2</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><name><name>info1</name><operator>.</operator><name>prior_fbpoint_lsn</name></name> <operator>==</operator> <name><name>info2</name><operator>.</operator><name>prior_fbpoint_lsn</name></name> <operator>&amp;&amp;</operator>
			<name><name>info1</name><operator>.</operator><name>fbpoint_lsn</name></name> <operator>==</operator> <name><name>info2</name><operator>.</operator><name>fbpoint_lsn</name></name> <operator>&amp;&amp;</operator>
			<name><name>info1</name><operator>.</operator><name>fbpoint_time</name></name> <operator>==</operator> <name><name>info2</name><operator>.</operator><name>fbpoint_time</name></name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>fbpoint_info_equal</name><parameter_list>(<parameter><decl><type><name>fbpoint_info_data_t</name></type> <name>info1</name></decl></parameter>, <parameter><decl><type><name>fbpoint_info_data_t</name></type> <name>info2</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>info1</name><operator>.</operator><name>flog_end_ptr</name></name> <operator>==</operator> <name><name>info2</name><operator>.</operator><name>flog_end_ptr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>info1</name><operator>.</operator><name>flog_end_ptr_prev</name></name> <operator>==</operator> <name><name>info2</name><operator>.</operator><name>flog_end_ptr_prev</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>info1</name><operator>.</operator><name>flog_start_ptr</name></name> <operator>==</operator> <name><name>info2</name><operator>.</operator><name>flog_start_ptr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>flog_wal_info_equal</name><argument_list>(<argument><expr><name><name>info1</name><operator>.</operator><name>wal_info</name></name></expr></argument>, <argument><expr><name><name>info2</name><operator>.</operator><name>wal_info</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>Size</name></type>
<name>get_test_shmem_size</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>polar_flog_shmem_size_internal</name><argument_list>(<argument><expr><name>TEST_FLOG_INSERT_LOCKS</name></expr></argument>, <argument><expr><name>TEST_FLOG_BUFS</name></expr></argument>,
										  <argument><expr><name>TEST_FLOG_INDEX_MEM_SIZE</name></expr></argument>, <argument><expr><name>TEST_FLOG_INDEX_BLOOM_BLKS</name></expr></argument>, <argument><expr><name>TEST_FLOG_QUEUE_BUFS</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>logindex_snapshot_t</name></type>
<name>init_flog_index</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>logindex_mem_size</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>logindex_bloom_blocks</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LOGINDEX_SNAPSHOT_SUFFIX</name></cpp:macro> <cpp:value>"_snapshot"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LOGINDEX_LOCK_SUFFIX</name></cpp:macro> <cpp:value>"_lock"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LOGINDEX_BLOOM_SUFFIX</name></cpp:macro> <cpp:value>"_bloom"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>POLAR_SLRU_HASH_NAME</name></cpp:macro> <cpp:value>" slru hash index"</cpp:value></cpp:define>

	<decl_stmt><decl><type><name>char</name></type>	<name><name>logindex_name</name><index>[<expr><name>POLAR_MAX_SHMEM_NAME</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>	<name><name>logindex_snapshot_name</name><index>[<expr><name>POLAR_MAX_SHMEM_NAME</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>	<name><name>logindex_lock_name</name><index>[<expr><name>POLAR_MAX_SHMEM_NAME</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>	<name><name>logindex_bloom_name</name><index>[<expr><name>POLAR_MAX_SHMEM_NAME</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>	<name><name>slru_hash_name</name><index>[<expr><name>POLAR_MAX_SHMEM_NAME</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>logindex_snapshot_t</name></type> <name>logindex_snapshot</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HTAB</name><modifier>*</modifier></type> <name>shem_index</name> <init>= <expr><call><name>polar_get_shmem_index</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>logindex_name</name></expr></argument>, <argument><expr><name>POLAR_MAX_SHMEM_NAME</name></expr></argument>, <argument><expr><literal type="string">"%s%s"</literal></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>FL_LOGINDEX_SUFFIX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>logindex_snapshot_name</name></expr></argument>, <argument><expr><name>POLAR_MAX_SHMEM_NAME</name></expr></argument>, <argument><expr><literal type="string">"%s%s"</literal></expr></argument>, <argument><expr><name>logindex_name</name></expr></argument>,
			<argument><expr><name>LOGINDEX_SNAPSHOT_SUFFIX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>logindex_lock_name</name></expr></argument>, <argument><expr><name>POLAR_MAX_SHMEM_NAME</name></expr></argument>, <argument><expr><literal type="string">"%s%s"</literal></expr></argument>, <argument><expr><name>logindex_name</name></expr></argument>,
			<argument><expr><name>LOGINDEX_LOCK_SUFFIX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>logindex_bloom_name</name></expr></argument>, <argument><expr><name>POLAR_MAX_SHMEM_NAME</name></expr></argument>, <argument><expr><literal type="string">" %s%s"</literal></expr></argument>, <argument><expr><name>logindex_name</name></expr></argument>,
			<argument><expr><name>LOGINDEX_BLOOM_SUFFIX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>slru_hash_name</name></expr></argument>, <argument><expr><name>POLAR_MAX_SHMEM_NAME</name></expr></argument>, <argument><expr><literal type="string">"%s%s"</literal></expr></argument>, <argument><expr><name>logindex_bloom_name</name></expr></argument>, <argument><expr><name>POLAR_SLRU_HASH_NAME</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>ShmemIndexLock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>hash_search</name><argument_list>(<argument><expr><name>shem_index</name></expr></argument>, <argument><expr><name>logindex_snapshot_name</name></expr></argument>, <argument><expr><name>HASH_REMOVE</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>hash_search</name><argument_list>(<argument><expr><name>shem_index</name></expr></argument>, <argument><expr><name>logindex_lock_name</name></expr></argument>, <argument><expr><name>HASH_REMOVE</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>hash_search</name><argument_list>(<argument><expr><name>shem_index</name></expr></argument>, <argument><expr><name>logindex_bloom_name</name></expr></argument>, <argument><expr><name>HASH_REMOVE</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>hash_search</name><argument_list>(<argument><expr><name>shem_index</name></expr></argument>, <argument><expr><name>slru_hash_name</name></expr></argument>, <argument><expr><name>HASH_REMOVE</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>ShmemIndexLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>IsUnderPostmaster</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>logindex_snapshot</name> <operator>=</operator>
			<call><name>polar_flog_index_shmem_init</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>logindex_mem_size</name></expr></argument>, <argument><expr><name>logindex_bloom_blocks</name></expr></argument>, <argument><expr><name>buf_ctl_test</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>IsUnderPostmaster</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

	<return>return <expr><name>logindex_snapshot</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>check_add_origin_page</name><parameter_list>(<parameter><decl><type><name>BufferDesc</name> <modifier>*</modifier></type><name>buf_hdr</name></decl></parameter>, <parameter><decl><type><name>int8</name></type> <name>buf_index</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><call><name>get_origin_buf_bit</name><argument_list>(<argument><expr><name>flog_list_test</name></expr></argument>, <argument><expr><name>buf_index</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>&amp;</operator> <literal type="number">1</literal><operator>)</operator> <operator>==</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>BUFFERTAGS_EQUAL</name><argument_list>(<argument><expr><name><name>flog_list_test</name><operator>-&gt;</operator><name>buf_tag</name><index>[<expr><name>buf_index</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>buf_hdr</name><operator>-&gt;</operator><name>tag</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>memcmp</name><argument_list>(<argument><expr><name><name>flog_list_test</name><operator>-&gt;</operator><name>origin_buf</name></name> <operator>+</operator> <name>buf_index</name> <operator>*</operator> <name>BLCKSZ</name></expr></argument>,
			<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>BufHdrGetBlock</name><argument_list>(<argument><expr><name>buf_hdr</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>BLCKSZ</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>flog_list_test</name><operator>-&gt;</operator><name>flashback_list</name><index>[<expr><name><name>buf_hdr</name><operator>-&gt;</operator><name>buf_id</name></name></expr>]</index></name><operator>.</operator><name>origin_buf_index</name> <operator>==</operator> <name>buf_index</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>check_clean_origin_page</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>buf_id</name></decl></parameter>, <parameter><decl><type><name>int8</name></type> <name>buf_index</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name></type> <name><name>origin_buf_clean</name><index>[<expr><name>BLCKSZ</name></expr>]</index></name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><name>origin_buf_clean</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>BLCKSZ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><call><name>get_origin_buf_bit</name><argument_list>(<argument><expr><name>flog_list_test</name></expr></argument>, <argument><expr><name>buf_index</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>&amp;</operator> <literal type="number">1</literal><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>memcmp</name><argument_list>(<argument><expr><name><name>flog_list_test</name><operator>-&gt;</operator><name>origin_buf</name></name> <operator>+</operator> <name>buf_index</name> <operator>*</operator> <name>BLCKSZ</name></expr></argument>, <argument><expr><name>origin_buf_clean</name></expr></argument>, <argument><expr><name>BLCKSZ</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>flog_list_test</name><operator>-&gt;</operator><name>flashback_list</name><index>[<expr><name>buf_id</name></expr>]</index></name><operator>.</operator><name>origin_buf_index</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>check_origin_buf_is_empty</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>j</name></decl>;</decl_stmt>

	<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>POLAR_ORIGIN_PAGE_BUF_ARRAY_NUM</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>pg_atomic_read_u32</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>flog_list_test</name><operator>-&gt;</operator><name>origin_buf_bitmap</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>check_origin_buf_is_full</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>j</name></decl>;</decl_stmt>

	<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>POLAR_ORIGIN_PAGE_BUF_ARRAY_NUM</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>pg_atomic_read_u32</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>flog_list_test</name><operator>-&gt;</operator><name>origin_buf_bitmap</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0xFFFFFFFF</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int8</name></type>
<name>get_expected_origin_buf_index</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>i</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>array_id</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int8</name></type> <name>buf_index</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>array_id</name> <operator>=</operator> <name><name>MyProc</name><operator>-&gt;</operator><name>pgprocno</name></name> <operator>%</operator> <name>POLAR_ORIGIN_PAGE_BUF_ARRAY_NUM</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>array_id</name> <operator>=</operator> <operator>(</operator><name>array_id</name> <operator>+</operator> <name>i</name> <operator>/</operator> <name>POLAR_ORIGIN_PAGE_BUF_NUM_PER_ARRAY</name><operator>)</operator> <operator>%</operator> <name>POLAR_ORIGIN_PAGE_BUF_ARRAY_NUM</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>buf_index</name> <operator>=</operator> <operator>(</operator><name>int8</name><operator>)</operator> <operator>(</operator><name>array_id</name> <operator>*</operator> <name>POLAR_ORIGIN_PAGE_BUF_NUM_PER_ARRAY</name> <operator>+</operator>
			<name>i</name> <operator>%</operator> <name>POLAR_ORIGIN_PAGE_BUF_NUM_PER_ARRAY</name><operator>)</operator></expr>;</expr_stmt>

	<return>return <expr><name>buf_index</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int8</name></type>
<name>test_add_origin_page</name><parameter_list>(<parameter><decl><type><name>BufferDesc</name> <modifier>*</modifier></type><name>buf_hdr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int8</name></type> <name>buf_index</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>buf_index</name> <operator>=</operator> <call><name>polar_add_origin_buf</name><argument_list>(<argument><expr><name>flog_list_test</name></expr></argument>, <argument><expr><name>buf_hdr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>check_add_origin_page</name><argument_list>(<argument><expr><name>buf_hdr</name></expr></argument>, <argument><expr><name>buf_index</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>buf_index</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>test_clean_origin_page</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>buf_id</name></decl></parameter>, <parameter><decl><type><name>int8</name></type> <name>buf_index</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>polar_clean_origin_buf_bit</name><argument_list>(<argument><expr><name>flog_list_test</name></expr></argument>, <argument><expr><name>buf_id</name></expr></argument>, <argument><expr><name>buf_index</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>check_clean_origin_page</name><argument_list>(<argument><expr><name>buf_id</name></expr></argument>, <argument><expr><name>buf_index</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>test_flog_shmem_startup</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>prev_shmem_startup_hook</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>prev_shmem_startup_hook</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Create or attach to the shared memory state, including hash table
	 */</comment>
	<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>AddinShmemInitLock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>polar_flog_shmem_init_internal</name><argument_list>(<argument><expr><name>TEST_FLOG_NAME</name></expr></argument>, <argument><expr><name>TEST_FLOG_INSERT_LOCKS</name></expr></argument>, <argument><expr><name>TEST_FLOG_BUFS</name></expr></argument>,
								   <argument><expr><name>TEST_FLOG_INDEX_MEM_SIZE</name></expr></argument>, <argument><expr><name>TEST_FLOG_INDEX_BLOOM_BLKS</name></expr></argument>, <argument><expr><name>TEST_FLOG_QUEUE_BUFS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>AddinShmemInitLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>test_flog_write</name><parameter_list>(<parameter><decl><type><name>polar_flog_rec_ptr</name></type> <name>ptr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>ptr</name> <operator>&gt;</operator> <name>POLAR_FLOG_BLCKSZ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>buf_ctl_test</name><operator>-&gt;</operator><name>write_result</name></name> <operator>&lt;</operator> <name>ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>polar_flog_flush</name><argument_list>(<argument><expr><name>buf_ctl_test</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>buf_ctl_test</name><operator>-&gt;</operator><name>write_result</name></name> <operator>==</operator> <name>ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>test_flog_read</name><parameter_list>(<parameter><decl><type><name>polar_flog_rec_ptr</name></type> <name>start_ptr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>flog_reader_state</name> <modifier>*</modifier></type><name>state</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>flog_record</name> <modifier>*</modifier></type><name>record</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>errormsg</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>state</name> <operator>=</operator> <call><name>polar_flog_reader_allocate</name><argument_list>(<argument><expr><name>POLAR_FLOG_SEG_SIZE</name></expr></argument>,
			<argument><expr><operator>&amp;</operator><name>polar_flog_page_read</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>buf_ctl_test</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>fl_origin_page_rec_data</name> <modifier>*</modifier></type><name>rec_data</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>BufferTag</name></type> <name>tag</name></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>tag</name><operator>.</operator><name>rnode</name><operator>.</operator><name>dbNode</name></name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>tag</name><operator>.</operator><name>rnode</name><operator>.</operator><name>relNode</name></name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>tag</name><operator>.</operator><name>rnode</name><operator>.</operator><name>spcNode</name></name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>tag</name><operator>.</operator><name>forkNum</name></name> <operator>=</operator> <name>MAIN_FORKNUM</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>tag</name><operator>.</operator><name>blockNum</name></name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>

		<comment type="block">/* try to read the next record */</comment>
		<expr_stmt><expr><name>record</name> <operator>=</operator> <call><name>polar_read_flog_record</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>start_ptr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>errormsg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>record</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>rec_data</name> <operator>=</operator> <call><name>FL_GET_ORIGIN_PAGE_REC_DATA</name><argument_list>(<argument><expr><name>record</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>rec_data</name><operator>-&gt;</operator><name>redo_lsn</name></name> <operator>==</operator> <name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>BUFFERTAGS_EQUAL</name><argument_list>(<argument><expr><name><name>rec_data</name><operator>-&gt;</operator><name>tag</name></name></expr></argument>, <argument><expr><name>tag</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* after reading the first record, continue at next one */</comment>
		<expr_stmt><expr><name>start_ptr</name> <operator>=</operator> <name>POLAR_INVALID_FLOG_REC_PTR</name></expr>;</expr_stmt>
	</block_content>}</block></for>
	<expr_stmt><expr><call><name>polar_flog_reader_free</name><argument_list>(<argument><expr><name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>test_flog_index_write</name><parameter_list>(<parameter><decl><type><name>polar_flog_rec_ptr</name></type> <name>ptr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>polar_flog_rec_ptr</name></type> <name>start_ptr</name></decl>;</decl_stmt>

	<comment type="block">/* Get the start ptr of the ptr */</comment>
	<expr_stmt><expr><name>start_ptr</name> <operator>=</operator> <call><name>compute_empty_page_start_ptr</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>FLOG_REC_EMPTY_PAGE_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>polar_flog_index_insert</name><argument_list>(<argument><expr><name>flog_index_test</name></expr></argument>, <argument><expr><name>flog_index_queue_test</name></expr></argument>, <argument><expr><name>buf_ctl_test</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>ANY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>polar_get_flog_index_max_ptr</name><argument_list>(<argument><expr><name>flog_index_test</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>start_ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>polar_logindex_flush_table</name><argument_list>(<argument><expr><name>flog_index_test</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>polar_get_flog_index_meta_max_ptr</name><argument_list>(<argument><expr><name>flog_index_test</name></expr></argument>)</argument_list></call> <operator>&lt;=</operator> <name>start_ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>test_flog_index_search</name><parameter_list>(<parameter><decl><type><name>polar_flog_rec_ptr</name></type> <name>start_ptr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PGAlignedBlock</name></type> <name>page_empty</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>polar_flog_rec_ptr</name></type> <name>end_ptr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>PageInit</name><argument_list>(<argument><expr><operator>(</operator><name>Page</name><operator>)</operator><name><name>page_empty</name><operator>.</operator><name>data</name></name></expr></argument>, <argument><expr><name>BLCKSZ</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>end_ptr</name> <operator>=</operator> <call><name>polar_get_flog_write_result</name><argument_list>(<argument><expr><name>buf_ctl_test</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>insert_empty_page_rec_num</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>BufferTag</name></type> <name>test_tag</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>PGAlignedBlock</name></type> <name>page</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>XLogRecPtr</name></type> <name>redo_lsn</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>PageInit</name><argument_list>(<argument><expr><operator>(</operator><name>Page</name><operator>)</operator><name><name>page</name><operator>.</operator><name>data</name></name></expr></argument>, <argument><expr><name>BLCKSZ</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>CLEAR_BUFFERTAG</name><argument_list>(<argument><expr><name>test_tag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>test_tag</name><operator>.</operator><name>rnode</name><operator>.</operator><name>dbNode</name></name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>test_tag</name><operator>.</operator><name>rnode</name><operator>.</operator><name>relNode</name></name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>test_tag</name><operator>.</operator><name>rnode</name><operator>.</operator><name>spcNode</name></name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>test_tag</name><operator>.</operator><name>forkNum</name></name> <operator>=</operator> <name>MAIN_FORKNUM</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>test_tag</name><operator>.</operator><name>blockNum</name></name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>polar_get_origin_page</name><argument_list>(<argument><expr><name>test_instance</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>test_tag</name></expr></argument>, <argument><expr><operator>(</operator><name>Page</name><operator>)</operator> <name><name>page</name><operator>.</operator><name>data</name></name></expr></argument>, <argument><expr><name>start_ptr</name></expr></argument>, <argument><expr><name>end_ptr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>redo_lsn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>redo_lsn</name> <operator>==</operator> <name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>memcmp</name><argument_list>(<argument><expr><name><name>page_empty</name><operator>.</operator><name>data</name></name></expr></argument>, <argument><expr><name><name>page</name><operator>.</operator><name>data</name></name></expr></argument>, <argument><expr><name>BLCKSZ</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>test_flog_init</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>first_init</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>first_init</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Share memory init first, just update the static in the backend */</comment>
		<expr_stmt><expr><name>test_instance</name> <operator>=</operator> <call><name>polar_flog_shmem_init_internal</name><argument_list>(<argument><expr><name>TEST_FLOG_NAME</name></expr></argument>, <argument><expr><name>TEST_FLOG_INSERT_LOCKS</name></expr></argument>, <argument><expr><name>TEST_FLOG_BUFS</name></expr></argument>,
								   <argument><expr><name>TEST_FLOG_INDEX_MEM_SIZE</name></expr></argument>, <argument><expr><name>TEST_FLOG_INDEX_BLOOM_BLKS</name></expr></argument>, <argument><expr><name>TEST_FLOG_QUEUE_BUFS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>polar_flog_ctl_init_data</name><argument_list>(<argument><expr><name>test_instance</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>polar_flog_buf_init_data</name><argument_list>(<argument><expr><name>buf_ctl_test</name></expr></argument>, <argument><expr><name>TEST_FLOG_NAME</name></expr></argument>, <argument><expr><name>TEST_FLOG_INSERT_LOCKS</name></expr></argument>, <argument><expr><name>TEST_FLOG_BUFS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>test_instance</name><operator>-&gt;</operator><name>buf_ctl</name></name> <operator>=</operator> <name>buf_ctl_test</name></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>polar_flog_list_init_data</name><argument_list>(<argument><expr><name>flog_list_test</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>test_instance</name><operator>-&gt;</operator><name>list_ctl</name></name> <operator>=</operator> <name>flog_list_test</name></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>polar_flog_index_queue_init_data</name><argument_list>(<argument><expr><name>flog_index_queue_test</name></expr></argument>, <argument><expr><name>TEST_FLOG_NAME</name></expr></argument>, <argument><expr><name>TEST_FLOG_QUEUE_BUFS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>test_instance</name><operator>-&gt;</operator><name>queue_ctl</name></name> <operator>=</operator> <name>flog_index_queue_test</name></expr>;</expr_stmt>

		<expr_stmt><expr><name>flog_index_test</name> <operator>=</operator> <call><name>init_flog_index</name><argument_list>(<argument><expr><name>TEST_FLOG_NAME</name></expr></argument>, <argument><expr><name>TEST_FLOG_INDEX_MEM_SIZE</name></expr></argument>, <argument><expr><name>TEST_FLOG_INDEX_BLOOM_BLKS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>test_instance</name><operator>-&gt;</operator><name>logindex_snapshot</name></name> <operator>=</operator> <name>flog_index_test</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/* Check flashback instance */</comment>
	<expr_stmt><expr><name>flog_instance</name> <operator>=</operator> <name>test_instance</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>test_instance</name><operator>-&gt;</operator><name>buf_ctl</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>test_instance</name><operator>-&gt;</operator><name>list_ctl</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>test_instance</name><operator>-&gt;</operator><name>logindex_snapshot</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>test_instance</name><operator>-&gt;</operator><name>queue_ctl</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>test_instance</name><operator>-&gt;</operator><name>state</name></name> <operator>==</operator> <name>FLOG_INIT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Check flashback log control */</comment>
	<expr_stmt><expr><name>buf_ctl_test</name> <operator>=</operator> <name><name>test_instance</name><operator>-&gt;</operator><name>buf_ctl</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>check_flog_buf_init</name><argument_list>(<argument><expr><name>TEST_FLOG_NAME</name></expr></argument>, <argument><expr><name>TEST_FLOG_INSERT_LOCKS</name></expr></argument>, <argument><expr><name>TEST_FLOG_BUFS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Check flashback log list */</comment>
	<expr_stmt><expr><name>flog_list_test</name> <operator>=</operator> <name><name>test_instance</name><operator>-&gt;</operator><name>list_ctl</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>check_flog_list_init</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Check flashback log queue */</comment>
	<expr_stmt><expr><name>flog_index_queue_test</name> <operator>=</operator> <name><name>test_instance</name><operator>-&gt;</operator><name>queue_ctl</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>check_flog_queue_init</name><argument_list>(<argument><expr><name>TEST_FLOG_QUEUE_BUFS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Check flashback logindex */</comment>
	<expr_stmt><expr><name>flog_index_test</name> <operator>=</operator> <name><name>test_instance</name><operator>-&gt;</operator><name>logindex_snapshot</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>check_flog_index_init</name><argument_list>(<argument><expr><name>TEST_FLOG_NAME</name></expr></argument>, <argument><expr><name>TEST_FLOG_INDEX_MEM_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>test_flog_startup</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>is_crash</name></decl></parameter>, <parameter><decl><type><name>flog_ctl_file_data_t</name></type> <name>ctl_file_data</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>log_index_meta_t</name></type> <name>logindex_meta</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CheckPoint</name></type> <name>checkpoint</name></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>checkpoint</name><operator>.</operator><name>redo</name></name> <operator>=</operator> <call><name>GetRedoRecPtr</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>checkpoint</name><operator>.</operator><name>time</name></name> <operator>=</operator> <operator>(</operator><name>pg_time_t</name><operator>)</operator> <call><name>time</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* first init will set the expected flashback point info in here */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>ctl_file_data</name><operator>.</operator><name>fbpoint_info</name><operator>.</operator><name>wal_info</name><operator>.</operator><name>fbpoint_lsn</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>ctl_file_data</name><operator>.</operator><name>fbpoint_info</name><operator>.</operator><name>wal_info</name><operator>.</operator><name>prior_fbpoint_lsn</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>ctl_file_data</name><operator>.</operator><name>fbpoint_info</name><operator>.</operator><name>wal_info</name><operator>.</operator><name>fbpoint_lsn</name></name> <operator>=</operator> <name><name>checkpoint</name><operator>.</operator><name>redo</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>ctl_file_data</name><operator>.</operator><name>fbpoint_info</name><operator>.</operator><name>wal_info</name><operator>.</operator><name>fbpoint_time</name></name> <operator>=</operator> <name><name>checkpoint</name><operator>.</operator><name>time</name></name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>is_crash</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>ctl_file_data</name><operator>.</operator><name>fbpoint_info</name><operator>.</operator><name>flog_end_ptr</name></name> <operator>=</operator> <operator>(</operator><name><name>ctl_file_data</name><operator>.</operator><name>max_seg_no</name></name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>*</operator> <name>POLAR_FLOG_SEG_SIZE</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>ctl_file_data</name><operator>.</operator><name>fbpoint_info</name><operator>.</operator><name>flog_end_ptr_prev</name></name> <operator>=</operator> <name>POLAR_INVALID_FLOG_REC_PTR</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>polar_startup_flog</name><argument_list>(<argument><expr><operator>&amp;</operator><name>checkpoint</name></expr></argument>, <argument><expr><name>test_instance</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>buf_ctl_test</name><operator>-&gt;</operator><name>buf_state</name></name> <operator>==</operator> <name>FLOG_BUF_READY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>test_instance</name><operator>-&gt;</operator><name>state</name></name> <operator>==</operator> <name>FLOG_STARTUP</name> <operator>||</operator> <name><name>test_instance</name><operator>-&gt;</operator><name>state</name></name> <operator>==</operator> <name>FLOG_READY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>ctl_file_data</name><operator>.</operator><name>version_no</name></name> <operator>&amp;</operator> <name>FLOG_SHUTDOWNED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>polar_startup_flog</name><argument_list>(<argument><expr><operator>&amp;</operator><name>checkpoint</name></expr></argument>, <argument><expr><name>test_instance</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>buf_ctl_test</name><operator>-&gt;</operator><name>buf_state</name></name> <operator>==</operator> <name>FLOG_BUF_READY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>test_instance</name><operator>-&gt;</operator><name>state</name></name> <operator>==</operator> <name>FLOG_STARTUP</name> <operator>||</operator> <name><name>test_instance</name><operator>-&gt;</operator><name>state</name></name> <operator>==</operator> <name>FLOG_READY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
	<expr_stmt><expr><call><name>check_flog_dir_validate</name><argument_list>(<argument><expr><name>TEST_FLOG_NAME</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* Check the flashback log checkpoint info */</comment>
	<expr_stmt><expr><call><name>fbpoint_info_equal</name><argument_list>(<argument><expr><name><name>buf_ctl_test</name><operator>-&gt;</operator><name>fbpoint_info</name></name></expr></argument>, <argument><expr><name><name>ctl_file_data</name><operator>.</operator><name>fbpoint_info</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* Check the flashback point wal lsn */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>flog_wal_info_equal</name><argument_list>(<argument><expr><name><name>buf_ctl_test</name><operator>-&gt;</operator><name>wal_info</name></name></expr></argument>,
			<argument><expr><name><name>ctl_file_data</name><operator>.</operator><name>fbpoint_info</name><operator>.</operator><name>wal_info</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* Check the flashback log max seg no */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>buf_ctl_test</name><operator>-&gt;</operator><name>max_seg_no</name></name> <operator>==</operator> <name><name>ctl_file_data</name><operator>.</operator><name>max_seg_no</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* Check the flashback log index */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>polar_logindex_check_state</name><argument_list>(<argument><expr><name>flog_index_test</name></expr></argument>, <argument><expr><name>POLAR_LOGINDEX_STATE_INITIALIZED</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>log_index_get_meta</name><argument_list>(<argument><expr><name>flog_index_test</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>logindex_meta</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>test_flog_recover</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* Refresh the flashback log insert function */</comment>
	<expr_stmt><expr><call><name>polar_flog_index_insert</name><argument_list>(<argument><expr><name>flog_index_test</name></expr></argument>, <argument><expr><name>flog_index_queue_test</name></expr></argument>,
			<argument><expr><name>buf_ctl_test</name></expr></argument>, <argument><expr><name>POLAR_INVALID_FLOG_REC_PTR</name></expr></argument>, <argument><expr><name>NONE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>polar_recover_flog</name><argument_list>(<argument><expr><name>test_instance</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>buf_ctl_test</name><operator>-&gt;</operator><name>buf_state</name></name> <operator>==</operator> <name>FLOG_BUF_READY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>test_instance</name><operator>-&gt;</operator><name>state</name></name> <operator>==</operator> <name>FLOG_READY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>check_flog_list_insert</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>buf_id</name></decl></parameter>, <parameter><decl><type><name>XLogRecPtr</name></type> <name>fbpoint_lsn</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>XLogRecPtr</name></type> <name>redo_lsn</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BufferDesc</name> <modifier>*</modifier></type><name>buf_hdr</name> <init>= <expr><call><name>GetBufferDescriptor</name><argument_list>(<argument><expr><name>buf_id</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>redo_lsn</name> <operator>=</operator> <call><name>polar_get_prior_fbpoint_lsn</name><argument_list>(<argument><expr><name>buf_ctl_test</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>flog_list_test</name><operator>-&gt;</operator><name>flashback_list</name><index>[<expr><name>buf_id</name></expr>]</index></name><operator>.</operator><name>flashback_ptr</name> <operator>==</operator> <name>POLAR_INVALID_FLOG_REC_PTR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>flog_list_test</name><operator>-&gt;</operator><name>flashback_list</name><index>[<expr><name>buf_id</name></expr>]</index></name><operator>.</operator><name>redo_lsn</name> <operator>==</operator> <name>redo_lsn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>flog_list_test</name><operator>-&gt;</operator><name>flashback_list</name><index>[<expr><name>buf_id</name></expr>]</index></name><operator>.</operator><name>fbpoint_lsn</name> <operator>==</operator> <name>fbpoint_lsn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>flog_list_test</name><operator>-&gt;</operator><name>flashback_list</name><index>[<expr><name>buf_id</name></expr>]</index></name><operator>.</operator><name>info</name> <operator>&amp;</operator> <name>FLOG_LIST_SLOT_READY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>polar_check_buf_flog_state</name><argument_list>(<argument><expr><name>buf_hdr</name></expr></argument>, <argument><expr><name>POLAR_BUF_IN_FLOG_LIST</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>check_flog_list_clean</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>buf_id</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>is_flog_flushed</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>check_buf_redo_state</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>BufferDesc</name> <modifier>*</modifier></type><name>buf_hdr</name> <init>= <expr><call><name>GetBufferDescriptor</name><argument_list>(<argument><expr><name>buf_id</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>is_flog_flushed</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>flog_list_test</name><operator>-&gt;</operator><name>flashback_list</name><index>[<expr><name>buf_id</name></expr>]</index></name><operator>.</operator><name>flashback_ptr</name> <operator>==</operator> <name>POLAR_INVALID_FLOG_REC_PTR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>flog_list_test</name><operator>-&gt;</operator><name>flashback_list</name><index>[<expr><name>buf_id</name></expr>]</index></name><operator>.</operator><name>flashback_ptr</name> <operator>!=</operator> <name>POLAR_INVALID_FLOG_REC_PTR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>flog_list_test</name><operator>-&gt;</operator><name>flashback_list</name><index>[<expr><name>buf_id</name></expr>]</index></name><operator>.</operator><name>redo_lsn</name> <operator>==</operator> <name>InvalidXLogRecPtr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>flog_list_test</name><operator>-&gt;</operator><name>flashback_list</name><index>[<expr><name>buf_id</name></expr>]</index></name><operator>.</operator><name>info</name> <operator>==</operator> <name>FLOG_LIST_SLOT_EMPTY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>flog_list_test</name><operator>-&gt;</operator><name>flashback_list</name><index>[<expr><name>buf_id</name></expr>]</index></name><operator>.</operator><name>prev_buf</name> <operator>==</operator> <name>NOT_IN_FLOG_LIST</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>flog_list_test</name><operator>-&gt;</operator><name>flashback_list</name><index>[<expr><name>buf_id</name></expr>]</index></name><operator>.</operator><name>next_buf</name> <operator>==</operator> <name>NOT_IN_FLOG_LIST</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>flog_list_test</name><operator>-&gt;</operator><name>flashback_list</name><index>[<expr><name>buf_id</name></expr>]</index></name><operator>.</operator><name>origin_buf_index</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>flog_list_test</name><operator>-&gt;</operator><name>head</name></name> <operator>!=</operator> <name>buf_id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>check_buf_redo_state</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>polar_check_buf_flog_state</name><argument_list>(<argument><expr><name>buf_hdr</name></expr></argument>, <argument><expr><name>POLAR_BUF_IN_FLOG_LIST</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>test_flog_insert_list</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>has_origin_buffer</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>head</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>tail</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>XLogRecPtr</name></type> <name>fbpoint_lsn</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>fbpoint_lsn</name> <operator>=</operator> <call><name>polar_get_curr_fbpoint_lsn</name><argument_list>(<argument><expr><name>buf_ctl_test</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>polar_get_local_fbpoint_lsn</name><argument_list>(<argument><expr><name>buf_ctl_test</name></expr></argument>, <argument><expr><name>InvalidXLogRecPtr</name></expr></argument>, <argument><expr><name>fbpoint_lsn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>TEST_BUF_LIST_NUM</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Relation</name></type> <name>rel</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Buffer</name></type>   <name>buf</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>BufferDesc</name> <modifier>*</modifier></type><name>buf_hdr</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type> <name>buf_id</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int8</name></type> <name>origin_buf_index</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>


		<expr_stmt><expr><name>rel</name> <operator>=</operator> <call><name>try_relation_open</name><argument_list>(<argument><expr><name><name>test_relnodes</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>buf</name> <operator>=</operator> <call><name>ReadBuffer</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>buf</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>buf</name> <operator>&lt;=</operator> <name>NBuffers</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>buf_id</name> <operator>=</operator> <name>buf</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name>buf_hdr</name> <operator>=</operator> <call><name>GetBufferDescriptor</name><argument_list>(<argument><expr><name>buf_id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>test_bufs</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>buf_id</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>BUFFER_LOCK_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Add test for origin buffer */</comment>
		<if_stmt><if>if <condition>(<expr><name>has_origin_buffer</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>TEST_BUF_LIST_NUM</name> <operator>&lt;=</operator> <name>POLAR_ORIGIN_PAGE_BUF_NUM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>origin_buf_index</name> <operator>=</operator> <call><name>test_add_origin_page</name><argument_list>(<argument><expr><name>buf_hdr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>origin_buf_index</name> <operator>==</operator> <call><name>get_expected_origin_buf_index</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>polar_push_buf_to_flog_list</name><argument_list>(<argument><expr><name>flog_list_test</name></expr></argument>, <argument><expr><name>buf_ctl_test</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>check_flog_list_insert</name><argument_list>(<argument><expr><name>buf_id</name></expr></argument>, <argument><expr><name>fbpoint_lsn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>i</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>flog_list_test</name><operator>-&gt;</operator><name>head</name></name> <operator>==</operator> <name>buf_id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>flog_list_test</name><operator>-&gt;</operator><name>tail</name></name> <operator>==</operator> <name>buf_id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<decl_stmt><decl><type><name>int</name></type>   <name>prev_buf_id</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>prev_buf_id</name> <operator>=</operator> <name><name>test_bufs</name><index>[<expr><name>i</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>flog_list_test</name><operator>-&gt;</operator><name>flashback_list</name><index>[<expr><name>prev_buf_id</name></expr>]</index></name><operator>.</operator><name>next_buf</name> <operator>==</operator> <name>buf_id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>flog_list_test</name><operator>-&gt;</operator><name>flashback_list</name><index>[<expr><name>buf_id</name></expr>]</index></name><operator>.</operator><name>prev_buf</name> <operator>==</operator> <name>prev_buf_id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>flog_list_test</name><operator>-&gt;</operator><name>flashback_list</name><index>[<expr><name>buf_id</name></expr>]</index></name><operator>.</operator><name>next_buf</name> <operator>==</operator> <name>NOT_IN_FLOG_LIST</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>polar_flog_get_async_list_info</name><argument_list>(<argument><expr><name>flog_list_test</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>head</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tail</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>head</name> <operator>==</operator> <name><name>test_bufs</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>tail</name> <operator>==</operator> <name><name>test_bufs</name><index>[<expr><name>TEST_BUF_LIST_NUM</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Half to insert flog record by background */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>TEST_BUF_LIST_NUM</name> <operator>/</operator> <literal type="number">2</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>   <name>buf_id</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>buf_id</name> <operator>=</operator> <name><name>test_bufs</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>flog_list_test</name><operator>-&gt;</operator><name>flashback_list</name><index>[<expr><name>buf_id</name></expr>]</index></name><operator>.</operator><name>prev_buf</name> <operator>==</operator> <name>NOT_IN_FLOG_LIST</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>polar_insert_flog_rec_from_list_bg</name><argument_list>(<argument><expr><name>flog_list_test</name></expr></argument>, <argument><expr><name>buf_ctl_test</name></expr></argument>, <argument><expr><name>flog_index_queue_test</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>has_origin_buffer</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>check_clean_origin_page</name><argument_list>(<argument><expr><name>buf_id</name></expr></argument>, <argument><expr><call><name>get_expected_origin_buf_index</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>polar_flog_get_async_list_info</name><argument_list>(<argument><expr><name>flog_list_test</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>head</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tail</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>head</name> <operator>!=</operator> <name>NOT_IN_FLOG_LIST</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>head</name> <operator>==</operator> <name><name>test_bufs</name><index>[<expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>tail</name> <operator>==</operator> <name><name>test_bufs</name><index>[<expr><name>TEST_BUF_LIST_NUM</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>tail</name> <operator>==</operator> <name>NOT_IN_FLOG_LIST</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<expr_stmt><expr><call><name>check_flog_list_clean</name><argument_list>(<argument><expr><name>buf_id</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>test_buf_flog_rec_sync</name><parameter_list>(<parameter><decl><type><name>Buffer</name></type> <name><name>bufs</name><index>[<expr><name>TEST_BUF_LIST_NUM</name></expr>]</index></name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>has_origin_buffer</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>TEST_BUF_LIST_NUM</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type> <name>buf</name> <init>= <expr><name><name>bufs</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>polar_flog_rec_ptr</name></type> <name>ptr</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>polar_flog_rec_ptr</name></type> <name>write_result</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>BufferDesc</name> <modifier>*</modifier></type><name>buf_hdr</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type> <name>is_invaild_buffer</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>is_invaild_buffer</name> <operator>=</operator> <operator>(</operator><name>i</name><operator>&amp;</operator><literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>
		<expr_stmt><expr><name>buf_hdr</name> <operator>=</operator> <call><name>GetBufferDescriptor</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>ptr</name> <operator>=</operator> <name><name>flog_list_test</name><operator>-&gt;</operator><name>flashback_list</name><index>[<expr><name>buf</name></expr>]</index></name><operator>.</operator><name>flashback_ptr</name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>i</name> <operator>&lt;</operator> <name>TEST_BUF_LIST_NUM</name> <operator>/</operator> <literal type="number">2</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>ptr</name> <operator>!=</operator> <name>POLAR_INVALID_FLOG_REC_PTR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>ptr</name> <operator>==</operator> <name>POLAR_INVALID_FLOG_REC_PTR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<expr_stmt><expr><name>write_result</name> <operator>=</operator> <name><name>buf_ctl_test</name><operator>-&gt;</operator><name>write_result</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>polar_flush_buf_flog_rec</name><argument_list>(<argument><expr><name>buf_hdr</name></expr></argument>, <argument><expr><name>test_instance</name></expr></argument>, <argument><expr><name>is_invaild_buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>is_invaild_buffer</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>buf_ctl_test</name><operator>-&gt;</operator><name>write_result</name></name> <operator>&gt;</operator> <name>write_result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>buf_ctl_test</name><operator>-&gt;</operator><name>write_result</name></name> <operator>==</operator> <name>write_result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<expr_stmt><expr><call><name>check_flog_list_clean</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>has_origin_buffer</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>check_clean_origin_page</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><call><name>get_expected_origin_buf_index</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>

	<comment type="block">/* The origin buffer is empty */</comment>
	<if_stmt><if>if <condition>(<expr><name>has_origin_buffer</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>check_origin_buf_is_empty</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>BufferDesc</name> <modifier>*</modifier></type>
<name>test_lock_buffer_in_bp</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>buf_id</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>BufferDesc</name> <modifier>*</modifier></type><name>buf_hdr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>locked</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>buf_hdr</name> <operator>=</operator> <call><name>GetBufferDescriptor</name><argument_list>(<argument><expr><name>buf_id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>locked</name> <operator>=</operator> <call><name>LWLockConditionalAcquire</name><argument_list>(<argument><expr><call><name>BufferDescriptorGetContentLock</name><argument_list>(<argument><expr><name>buf_hdr</name></expr></argument>)</argument_list></call></expr></argument>,
								   <argument><expr><name>LW_SHARED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>locked</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
	<return>return <expr><name>buf_hdr</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>BufferDesc</name> <modifier>*</modifier></type>
<name>test_add_origin_buf_from_bp</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>buf_id</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>locked</name></decl></parameter>, <parameter><decl><type><name>int8</name> <modifier>*</modifier></type><name>buf_index</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>BufferDesc</name> <modifier>*</modifier></type><name>buf_hdr</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>buf_hdr</name> <operator>=</operator> <call><name>test_lock_buffer_in_bp</name><argument_list>(<argument><expr><name>buf_id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>buf_hdr</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><operator>*</operator><name>locked</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><operator>*</operator><name>locked</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<expr_stmt><expr><operator>*</operator><name>buf_index</name> <operator>=</operator> <call><name>polar_add_origin_buf</name><argument_list>(<argument><expr><name>flog_list_test</name></expr></argument>, <argument><expr><name>buf_hdr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>buf_hdr</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>test_origin_buf_full</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>buf_num</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>j</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name><name>buf_id</name><index>[<expr><name>buf_num</name></expr>]</index></name></decl>;</decl_stmt>

	<comment type="block">/* Test the origin buffer full */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>buf_num</name> <operator>&amp;&amp;</operator> <name>i</name> <operator>&lt;</operator> <name>NBuffers</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>BufferDesc</name> <modifier>*</modifier></type><name>buf_hdr</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type> <name>locked</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int8</name></type> <name>buf_index</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int8</name></type> <name>buf_index_expected</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>buf_hdr</name> <operator>=</operator> <call><name>test_add_origin_buf_from_bp</name><argument_list>(<argument><expr><name>i</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>locked</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>buf_index</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>locked</name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>buf_index_expected</name> <operator>=</operator> <call><name>get_expected_origin_buf_index</name><argument_list>(<argument><expr><name>j</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>buf_index</name> <operator>==</operator> <name>buf_index_expected</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>check_add_origin_page</name><argument_list>(<argument><expr><name>buf_hdr</name></expr></argument>, <argument><expr><name>buf_index</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><call><name>BufferDescriptorGetContentLock</name><argument_list>(<argument><expr><name>buf_hdr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>buf_id</name><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>j</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>check_origin_buf_is_full</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name>i</name> <operator>+</operator> <literal type="number">1</literal></expr><operator>,</operator> <expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <literal type="number">5</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>BufferDesc</name> <modifier>*</modifier></type><name>buf_hdr</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type> <name>locked</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int8</name></type> <name>buf_index</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>buf_hdr</name> <operator>=</operator> <call><name>test_add_origin_buf_from_bp</name><argument_list>(<argument><expr><name>i</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>locked</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>buf_index</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>locked</name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><call><name>BufferDescriptorGetContentLock</name><argument_list>(<argument><expr><name>buf_hdr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>buf_index</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>j</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block></for>

	<comment type="block">/* Clean all the origin buffer to avoid to influence others */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>buf_num</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><call><name>test_clean_origin_page</name><argument_list>(<argument><expr><name><name>buf_id</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><call><name>get_expected_origin_buf_index</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>check_origin_buf_is_empty</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>test_flog_repair_buffer</name><parameter_list>(<parameter><decl><type><name>Buffer</name></type> <name><name>bufs</name><index>[<expr><name>TEST_BUF_LIST_NUM</name></expr>]</index></name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Buffer</name></type> <name>buf0</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BufferDesc</name> <modifier>*</modifier></type><name>buf_hdr0</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>XLogRecPtr</name></type> <name>fbpoint_lsn</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>XLogRecPtr</name></type> <name>end_lsn</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>buf0</name> <operator>=</operator> <name><name>bufs</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>buf_hdr0</name> <operator>=</operator> <call><name>GetBufferDescriptor</name><argument_list>(<argument><expr><name>buf0</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Test apply first fpi */</comment>
	<expr_stmt><expr><name>fbpoint_lsn</name> <operator>=</operator> <call><name>polar_get_curr_fbpoint_lsn</name><argument_list>(<argument><expr><name>buf_ctl_test</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>end_lsn</name> <operator>=</operator> <name>fbpoint_lsn</name> <operator>+</operator> <literal type="number">2</literal></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>polar_logindex_find_first_fpi</name><argument_list>(<argument><expr><name>polar_logindex_redo_instance</name></expr></argument>,
			<argument><expr><name>fbpoint_lsn</name></expr></argument>, <argument><expr><name>end_lsn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>buf_hdr0</name><operator>-&gt;</operator><name>tag</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>buf0</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Test polar_can_flog_repair */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>polar_can_flog_repair</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>buf_hdr0</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>polar_can_flog_repair</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>buf_hdr0</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>polar_can_flog_repair</name><argument_list>(<argument><expr><name>test_instance</name></expr></argument>, <argument><expr><name>buf_hdr0</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>polar_can_flog_repair</name><argument_list>(<argument><expr><name>test_instance</name></expr></argument>, <argument><expr><name>buf_hdr0</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>TEST_BUF_LIST_NUM</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type> <name>buf_id</name> <init>= <expr><name><name>bufs</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>BufferDesc</name> <modifier>*</modifier></type><name>buf_hdr</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>PGAlignedBlock</name></type> <name>page</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>uint32</name></type>		<name>buf_state</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>is_invaild_buffer</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>is_invaild_buffer</name> <operator>=</operator> <operator>(</operator><name>i</name><operator>&amp;</operator><literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>is_invaild_buffer</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>buf_hdr</name> <operator>=</operator> <call><name>GetBufferDescriptor</name><argument_list>(<argument><expr><name>buf_id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>page</name><operator>.</operator><name>data</name></name></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>BufHdrGetBlock</name><argument_list>(<argument><expr><name>buf_hdr</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>BLCKSZ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* Set the buffer invalid first to test */</comment>
			<expr_stmt><expr><name>buf_state</name> <operator>=</operator> <call><name>LockBufHdr</name><argument_list>(<argument><expr><name>buf_hdr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>buf_state</name> <operator>&amp;=</operator> <operator>~</operator><name>BM_VALID</name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>UnlockBufHdr</name><argument_list>(<argument><expr><name>buf_hdr</name></expr></argument>, <argument><expr><name>buf_state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* Break the buffer */</comment>
			<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>BufHdrGetBlock</name><argument_list>(<argument><expr><name>buf_hdr</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>BLCKSZ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>polar_repair_partial_write</name><argument_list>(<argument><expr><name>test_instance</name></expr></argument>, <argument><expr><name>buf_hdr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>polar_check_buf_flog_state</name><argument_list>(<argument><expr><name>buf_hdr</name></expr></argument>, <argument><expr><name>POLAR_BUF_FLOG_DISABLE</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>memcmp</name><argument_list>(<argument><expr><name><name>page</name><operator>.</operator><name>data</name></name></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>BufHdrGetBlock</name><argument_list>(<argument><expr><name>buf_hdr</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>BLCKSZ</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* Set the buffer valid again */</comment>
			<expr_stmt><expr><name>buf_state</name> <operator>=</operator> <call><name>LockBufHdr</name><argument_list>(<argument><expr><name>buf_hdr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>buf_state</name> <operator>|=</operator> <name>BM_VALID</name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>UnlockBufHdr</name><argument_list>(<argument><expr><name>buf_hdr</name></expr></argument>, <argument><expr><name>buf_state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><name>buf_id</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>BUFFER_LOCK_UNLOCK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>test_flog_checkpoint</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>is_shutdown</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>polar_flog_rec_ptr</name></type> <name>ckp_start</name> <init>= <expr><name>POLAR_INVALID_FLOG_REC_PTR</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>polar_flog_rec_ptr</name></type> <name>ckp_end</name> <init>= <expr><name>POLAR_INVALID_FLOG_REC_PTR</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>polar_flog_rec_ptr</name></type> <name>ckp_end_prev</name> <init>= <expr><name>POLAR_INVALID_FLOG_REC_PTR</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>XLogRecPtr</name></type> <name>lsn</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>XLogRecPtr</name></type> <name>lsn_prior</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint64</name></type> <name>max_seg_no</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>pg_time_t</name></type> <name>ckp_time</name> <init>= <expr><operator>(</operator><name>pg_time_t</name><operator>)</operator> <call><name>time</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>flags</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>is_shutdown</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>flags</name> <operator>=</operator> <name>CHECKPOINT_IS_SHUTDOWN</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>lsn</name> <operator>=</operator> <call><name>polar_get_faked_latest_lsn</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>polar_is_flashback_point</name><argument_list>(<argument><expr><name>test_instance</name></expr></argument>, <argument><expr><name>lsn</name></expr></argument>, <argument><expr><name>InvalidXLogRecPtr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>flags</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>lsn</name> <operator>=</operator> <name>lsn</name> <operator>+</operator> <name>wal_segment_size</name> <operator>*</operator> <operator>(</operator><name>polar_flashback_point_segments</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>polar_is_flashback_point</name><argument_list>(<argument><expr><name>test_instance</name></expr></argument>, <argument><expr><name>lsn</name></expr></argument>, <argument><expr><name>InvalidXLogRecPtr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>flags</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>lsn_prior</name> <operator>=</operator> <name><name>buf_ctl_test</name><operator>-&gt;</operator><name>wal_info</name><operator>.</operator><name>fbpoint_lsn</name></name></expr>;</expr_stmt>

	<comment type="block">/* If lsn is equal to prior lsn, add lsn */</comment>
	<if_stmt><if>if <condition>(<expr><name>lsn</name> <operator>==</operator> <name>lsn_prior</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>lsn</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>ckp_start</name> <operator>=</operator> <call><name>polar_get_flog_write_result</name><argument_list>(<argument><expr><name>buf_ctl_test</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>polar_set_fbpoint_wal_info</name><argument_list>(<argument><expr><name>buf_ctl_test</name></expr></argument>, <argument><expr><name>lsn</name></expr></argument>, <argument><expr><name>ckp_time</name></expr></argument>, <argument><expr><name>InvalidXLogRecPtr</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>polar_flog_do_fbpoint</name><argument_list>(<argument><expr><name>test_instance</name></expr></argument>, <argument><expr><name>ckp_start</name></expr></argument>, <argument><expr><name>is_shutdown</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>is_shutdown</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>polar_log_flog_buf_state</name><argument_list>(<argument><expr><name><name>buf_ctl_test</name><operator>-&gt;</operator><name>buf_state</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>buf_ctl_test</name><operator>-&gt;</operator><name>buf_state</name></name> <operator>==</operator> <name>FLOG_BUF_SHUTDOWNED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>buf_ctl_test</name><operator>-&gt;</operator><name>fbpoint_info</name><operator>.</operator><name>flog_start_ptr</name></name> <operator>==</operator> <name>ckp_start</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>is_shutdown</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>ckp_end</name> <operator>=</operator>
			<call><name>polar_get_curr_flog_ptr</name><argument_list>(<argument><expr><name>buf_ctl_test</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ckp_end_prev</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>ckp_end</name> <operator>=</operator> <call><name>polar_get_flog_write_result</name><argument_list>(<argument><expr><name>buf_ctl_test</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>buf_ctl_test</name><operator>-&gt;</operator><name>wal_info</name><operator>.</operator><name>prior_fbpoint_lsn</name></name> <operator>==</operator> <name>lsn_prior</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>buf_ctl_test</name><operator>-&gt;</operator><name>wal_info</name><operator>.</operator><name>fbpoint_lsn</name></name> <operator>==</operator> <name>lsn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>buf_ctl_test</name><operator>-&gt;</operator><name>wal_info</name><operator>.</operator><name>fbpoint_time</name></name> <operator>==</operator> <name>ckp_time</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>buf_ctl_test</name><operator>-&gt;</operator><name>fbpoint_info</name><operator>.</operator><name>wal_info</name><operator>.</operator><name>prior_fbpoint_lsn</name></name> <operator>==</operator> <name>lsn_prior</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>buf_ctl_test</name><operator>-&gt;</operator><name>fbpoint_info</name><operator>.</operator><name>wal_info</name><operator>.</operator><name>fbpoint_lsn</name></name> <operator>==</operator> <name>lsn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>buf_ctl_test</name><operator>-&gt;</operator><name>fbpoint_info</name><operator>.</operator><name>wal_info</name><operator>.</operator><name>fbpoint_time</name></name> <operator>==</operator> <name>ckp_time</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>max_seg_no</name> <operator>=</operator> <name><name>buf_ctl_test</name><operator>-&gt;</operator><name>max_seg_no</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>check_flog_control_file</name><argument_list>(<argument><expr><name>ckp_start</name></expr></argument>, <argument><expr><name>ckp_end</name></expr></argument>, <argument><expr><name>ckp_end_prev</name></expr></argument>, <argument><expr><name>max_seg_no</name></expr></argument>,
			<argument><expr><name><name>buf_ctl_test</name><operator>-&gt;</operator><name>wal_info</name></name></expr></argument>, <argument><expr><name>is_shutdown</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>buf_ctl_test</name><operator>-&gt;</operator><name>keep_wal_lsn</name></name> <operator>==</operator> <name>lsn_prior</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>check_flog_truncate</name><argument_list>(<argument><expr><call><name>Min</name><argument_list>(<argument><expr><name>ckp_start</name></expr></argument>, <argument><expr><call><name>polar_get_flog_index_meta_max_ptr</name><argument_list>(<argument><expr><name>flog_index_test</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>test_flog_crash_recovery</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>uint64</name></type> <name>max_seg_no</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>polar_flog_rec_ptr</name></type> <name>ptr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>polar_flog_rec_ptr</name></type> <name>pos</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>polar_flog_rec_ptr</name></type> <name>ckp_start</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>polar_flog_rec_ptr</name></type> <name>ckp_end</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>polar_flog_rec_ptr</name></type> <name>ckp_end_prev</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>polar_flog_rec_ptr</name></type> <name>ptr_expected</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>polar_flog_rec_ptr</name></type> <name>max_in_index</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>flog_ctl_file_data_t</name></type> <name>ctl_file_data</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>fbpoint_wal_info_data_t</name></type>  <name>wal_info</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>max_seg_no</name> <operator>=</operator> <name><name>buf_ctl_test</name><operator>-&gt;</operator><name>max_seg_no</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>max_seg_no</name> <operator>!=</operator> <name>POLAR_INVALID_FLOG_SEGNO</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>ckp_start</name> <operator>=</operator> <name><name>buf_ctl_test</name><operator>-&gt;</operator><name>fbpoint_info</name><operator>.</operator><name>flog_start_ptr</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>ckp_end</name> <operator>=</operator> <name><name>buf_ctl_test</name><operator>-&gt;</operator><name>fbpoint_info</name><operator>.</operator><name>flog_end_ptr</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>ckp_end_prev</name> <operator>=</operator> <name><name>buf_ctl_test</name><operator>-&gt;</operator><name>fbpoint_info</name><operator>.</operator><name>flog_end_ptr_prev</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>wal_info</name> <operator>=</operator> <name><name>buf_ctl_test</name><operator>-&gt;</operator><name>fbpoint_info</name><operator>.</operator><name>wal_info</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>max_in_index</name> <operator>=</operator> <call><name>polar_get_flog_index_max_ptr</name><argument_list>(<argument><expr><name>flog_index_test</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>polar_flog_flush</name><argument_list>(<argument><expr><name>buf_ctl_test</name></expr></argument>, <argument><expr><call><name>polar_get_curr_flog_ptr</name><argument_list>(<argument><expr><name>buf_ctl_test</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ptr_expected</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>max_in_index</name> <operator>&lt;</operator> <name>ptr_expected</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>init_flog_buf_ctl_data</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ctl_file_data</name></expr></argument>, <argument><expr><name>max_seg_no</name></expr></argument>, <argument><expr><name>ckp_end</name></expr></argument>, <argument><expr><name>ckp_end_prev</name></expr></argument>, <argument><expr><name>ckp_start</name></expr></argument>, <argument><expr><name>wal_info</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Reset the flashback thing and recover */</comment>
	<expr_stmt><expr><call><name>test_flog_init</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>test_flog_startup</name><argument_list>(<argument><expr><name>true</name></expr></argument>, <argument><expr><name>ctl_file_data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>test_flog_recover</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>ptr</name> <operator>=</operator> <operator>(</operator><name>max_seg_no</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>*</operator> <name>POLAR_FLOG_SEG_SIZE</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>pos</name> <operator>=</operator> <call><name>polar_flog_ptr2pos</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>buf_ctl_test</name><operator>-&gt;</operator><name>write_result</name></name> <operator>==</operator> <name>ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>buf_ctl_test</name><operator>-&gt;</operator><name>max_seg_no</name></name> <operator>==</operator> <name>max_seg_no</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>buf_ctl_test</name><operator>-&gt;</operator><name>initalized_upto</name></name> <operator>==</operator> <name>ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>buf_ctl_test</name><operator>-&gt;</operator><name>write_request</name></name> <operator>==</operator> <name>ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>buf_ctl_test</name><operator>-&gt;</operator><name>insert</name><operator>.</operator><name>curr_pos</name></name> <operator>==</operator> <name>pos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>buf_ctl_test</name><operator>-&gt;</operator><name>insert</name><operator>.</operator><name>prev_pos</name></name> <operator>==</operator> <name>POLAR_INVALID_FLOG_REC_PTR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>polar_get_flog_index_max_ptr</name><argument_list>(<argument><expr><name>flog_index_test</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>ptr_expected</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>check_flog_control_file</name><argument_list>(<argument><expr><name>ckp_start</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>POLAR_INVALID_FLOG_REC_PTR</name></expr></argument>, <argument><expr><name>max_seg_no</name></expr></argument>, <argument><expr><name>wal_info</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>check_flog_history_file</name><argument_list>(<argument><expr><name>ckp_end</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>test_flog_shutdown_recovery</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>uint64</name></type> <name>max_seg_no</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>fbpoint_info_data_t</name></type> <name>info_expected</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>polar_flog_rec_ptr</name></type> <name>write_result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>polar_flog_rec_ptr</name></type> <name>write_request</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>polar_flog_rec_ptr</name></type> <name>ckp_end_ptr_prev</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>polar_flog_rec_ptr</name></type> <name>pos</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>polar_flog_rec_ptr</name></type> <name>prev_pos</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>polar_flog_rec_ptr</name></type> <name>end_ptr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>polar_flog_rec_ptr</name></type> <name>upto</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>flog_ctl_file_data_t</name></type> <name>ctl_file_data</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>write_result</name> <operator>=</operator> <name><name>buf_ctl_test</name><operator>-&gt;</operator><name>write_result</name></name></expr>;</expr_stmt>

	<comment type="block">/* Insert the flashback log and write */</comment>
	<expr_stmt><expr><name>end_ptr</name> <operator>=</operator> <call><name>test_flog_insert_buffer</name><argument_list>(<argument><expr><name>write_result</name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
									  <argument><expr><name>false</name></expr></argument>, <argument><expr><operator>(</operator><name>TEST_FLOG_BUFS</name> <operator>*</operator> <name>POLAR_FLOG_BLCKSZ</name><operator>)</operator> <operator>/</operator> <name>FLOG_REC_EMPTY_PAGE_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>test_flog_write</name><argument_list>(<argument><expr><name>end_ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>write_result</name> <operator>=</operator> <name><name>buf_ctl_test</name><operator>-&gt;</operator><name>write_result</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>write_request</name> <operator>=</operator> <name><name>buf_ctl_test</name><operator>-&gt;</operator><name>write_request</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>polar_get_flog_index_max_ptr</name><argument_list>(<argument><expr><name>flog_index_test</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <name>write_result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Test the flashback log checkpoint (shutdown) */</comment>
	<expr_stmt><expr><call><name>test_flog_checkpoint</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>info_expected</name> <operator>=</operator> <name><name>buf_ctl_test</name><operator>-&gt;</operator><name>fbpoint_info</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>max_seg_no</name> <operator>=</operator> <name><name>buf_ctl_test</name><operator>-&gt;</operator><name>max_seg_no</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>pos</name> <operator>=</operator> <call><name>polar_flog_ptr2pos</name><argument_list>(<argument><expr><name>write_result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>ckp_end_ptr_prev</name> <operator>=</operator> <name><name>info_expected</name><operator>.</operator><name>flog_end_ptr_prev</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>prev_pos</name> <operator>=</operator> <call><name>polar_flog_ptr2pos</name><argument_list>(<argument><expr><name>ckp_end_ptr_prev</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>upto</name> <operator>=</operator> <call><name>polar_get_flog_buf_initalized_upto</name><argument_list>(<argument><expr><name>buf_ctl_test</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>info_expected</name><operator>.</operator><name>flog_end_ptr</name></name> <operator>==</operator> <name>end_ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>init_flog_buf_ctl_data</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ctl_file_data</name></expr></argument>, <argument><expr><name>max_seg_no</name></expr></argument>, <argument><expr><name><name>info_expected</name><operator>.</operator><name>flog_end_ptr</name></name></expr></argument>,
			<argument><expr><name>ckp_end_ptr_prev</name></expr></argument>, <argument><expr><name><name>info_expected</name><operator>.</operator><name>flog_start_ptr</name></name></expr></argument>, <argument><expr><name><name>info_expected</name><operator>.</operator><name>wal_info</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Reset the flashback thing and recover */</comment>
	<expr_stmt><expr><call><name>test_flog_init</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>test_flog_startup</name><argument_list>(<argument><expr><name>false</name></expr></argument>, <argument><expr><name>ctl_file_data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>test_flog_recover</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>buf_ctl_test</name><operator>-&gt;</operator><name>write_result</name></name> <operator>==</operator> <name>write_result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>buf_ctl_test</name><operator>-&gt;</operator><name>write_request</name></name> <operator>==</operator> <name>write_request</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>buf_ctl_test</name><operator>-&gt;</operator><name>max_seg_no</name></name> <operator>==</operator> <name>max_seg_no</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>buf_ctl_test</name><operator>-&gt;</operator><name>initalized_upto</name></name> <operator>==</operator> <name>upto</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>buf_ctl_test</name><operator>-&gt;</operator><name>insert</name><operator>.</operator><name>curr_pos</name></name> <operator>==</operator> <name>pos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>buf_ctl_test</name><operator>-&gt;</operator><name>insert</name><operator>.</operator><name>prev_pos</name></name> <operator>==</operator> <name>prev_pos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>fbpoint_info_equal</name><argument_list>(<argument><expr><name>info_expected</name></expr></argument>, <argument><expr><name><name>buf_ctl_test</name><operator>-&gt;</operator><name>fbpoint_info</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>polar_get_flog_index_max_ptr</name><argument_list>(<argument><expr><name>flog_index_test</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>ckp_end_ptr_prev</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>check_flog_control_file</name><argument_list>(<argument><expr><name><name>info_expected</name><operator>.</operator><name>flog_start_ptr</name></name></expr></argument>, <argument><expr><name><name>info_expected</name><operator>.</operator><name>flog_end_ptr</name></name></expr></argument>,
							<argument><expr><name><name>info_expected</name><operator>.</operator><name>flog_end_ptr_prev</name></name></expr></argument>, <argument><expr><name>max_seg_no</name></expr></argument>,
							<argument><expr><name><name>info_expected</name><operator>.</operator><name>wal_info</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Test the flashback log background worker functions.
 * Now is:
 * polar_flog_flush_bg
 * polar_insert_flog_index_bg
 * polar_flog_index_background_flush
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>test_flog_bg_worker_functions</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>polar_flog_rec_ptr</name></type> <name>start_ptr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>polar_flog_rec_ptr</name></type> <name>end_ptr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>polar_flog_rec_ptr</name></type> <name>write_result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>polar_flog_rec_ptr</name></type> <name>write_result_expected</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>polar_flog_rec_ptr</name></type> <name>max_ptr_in_index_mem</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>polar_flog_rec_ptr</name></type> <name>max_ptr_in_index_meta</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint64</name></type> <name>write_total_num</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint64</name></type> <name>bg_write_num</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint64</name></type> <name>segs_added_total_num</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>start_ptr</name> <operator>=</operator> <name><name>buf_ctl_test</name><operator>-&gt;</operator><name>write_result</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>end_ptr</name> <operator>=</operator> <call><name>test_flog_insert_buffer</name><argument_list>(<argument><expr><name>start_ptr</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
									  <argument><expr><operator>(</operator><name>TEST_FLOG_BUFS</name> <operator>*</operator> <name>POLAR_FLOG_BLCKSZ</name><operator>)</operator> <operator>/</operator> <name>FLOG_REC_EMPTY_PAGE_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>write_result</name> <operator>=</operator> <name><name>buf_ctl_test</name><operator>-&gt;</operator><name>write_result</name></name></expr>;</expr_stmt>

	<comment type="block">/* Just write one block */</comment>
	<expr_stmt><expr><name>write_result_expected</name> <operator>=</operator> <operator>(</operator><name>write_result</name> <operator>+</operator> <name>POLAR_FLOG_BLCKSZ</name><operator>)</operator> <operator>-</operator>
							<operator>(</operator><operator>(</operator><name>write_result</name> <operator>+</operator> <name>POLAR_FLOG_BLCKSZ</name><operator>)</operator> <operator>%</operator> <name>POLAR_FLOG_BLCKSZ</name><operator>)</operator></expr>;</expr_stmt>
	<expr_stmt><expr><name>polar_flashback_log_flush_max_size</name> <operator>=</operator> <name>POLAR_FLOG_BLCKSZ</name> <operator>/</operator> <literal type="number">1024</literal></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>polar_flog_flush_bg</name><argument_list>(<argument><expr><name>buf_ctl_test</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>polar_get_flog_write_stat</name><argument_list>(<argument><expr><name>buf_ctl_test</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>write_total_num</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>bg_write_num</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>segs_added_total_num</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>bg_write_num</name> <operator>==</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>write_total_num</name> <operator>&gt;</operator> <name>bg_write_num</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>buf_ctl_test</name><operator>-&gt;</operator><name>write_result</name></name> <operator>&gt;</operator> <name>write_result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>write_result</name> <operator>=</operator> <name><name>buf_ctl_test</name><operator>-&gt;</operator><name>write_result</name></name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>end_ptr</name> <operator>%</operator> <name>POLAR_FLOG_SEG_SIZE</name> <operator>+</operator> <name>POLAR_FLOG_BLCKSZ</name> <operator>&lt;</operator> <name>POLAR_FLOG_SEG_SIZE</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>write_result</name> <operator>==</operator> <name>write_result_expected</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>max_ptr_in_index_mem</name> <operator>=</operator> <call><name>polar_get_flog_index_max_ptr</name><argument_list>(<argument><expr><name>flog_index_test</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>max_ptr_in_index_meta</name> <operator>=</operator> <call><name>polar_get_flog_index_meta_max_ptr</name><argument_list>(<argument><expr><name>flog_index_test</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>polar_flog_index_insert</name><argument_list>(<argument><expr><name>flog_index_test</name></expr></argument>, <argument><expr><name>flog_index_queue_test</name></expr></argument>, <argument><expr><name>buf_ctl_test</name></expr></argument>, <argument><expr><name>write_result</name></expr></argument>, <argument><expr><name>ANY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>polar_flog_index_insert</name><argument_list>(<argument><expr><name>flog_index_test</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>buf_ctl_test</name></expr></argument>, <argument><expr><name>write_result</name></expr></argument>, <argument><expr><name>ANY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>polar_get_flog_index_max_ptr</name><argument_list>(<argument><expr><name>flog_index_test</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <name>write_result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>polar_get_flog_index_max_ptr</name><argument_list>(<argument><expr><name>flog_index_test</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <name>max_ptr_in_index_mem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>polar_logindex_flush_table</name><argument_list>(<argument><expr><name>flog_index_test</name></expr></argument>, <argument><expr><name>write_result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>polar_get_flog_index_meta_max_ptr</name><argument_list>(<argument><expr><name>flog_index_test</name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <name>max_ptr_in_index_meta</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>polar_get_flog_index_meta_max_ptr</name><argument_list>(<argument><expr><name>flog_index_test</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <name>write_result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>test_flog_prealloc_files</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>num</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>uint64</name></type> <name>max_segno</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>max_segno</name> <operator>=</operator> <name><name>buf_ctl_test</name><operator>-&gt;</operator><name>max_seg_no</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>polar_prealloc_flog_files</name><argument_list>(<argument><expr><name>buf_ctl_test</name></expr></argument>, <argument><expr><name>num</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>check_flog_prealloc_files</name><argument_list>(<argument><expr><name>max_segno</name> <operator>+</operator> <name>num</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>test_insert_flog_from_bp</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>test_bp_buf_nums</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>is_recovery</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>j</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name><name>bufs</name><index>[<expr><name>test_bp_buf_nums</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>XLogRecPtr</name></type> <name>fbpoint_lsn</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>polar_logindex_redo_ctl_data_t</name></type> <name>redo_ins</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>fbpoint_lsn</name> <operator>=</operator> <call><name>polar_get_curr_fbpoint_lsn</name><argument_list>(<argument><expr><name>buf_ctl_test</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>polar_get_local_fbpoint_lsn</name><argument_list>(<argument><expr><name>buf_ctl_test</name></expr></argument>, <argument><expr><name>InvalidXLogRecPtr</name></expr></argument>, <argument><expr><name>fbpoint_lsn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Set parallel replaying, but it may be not standby. Sorry for that */</comment>
	<expr_stmt><expr><call><name>pg_atomic_write_u32</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>redo_ins</name><operator>.</operator><name>bg_redo_state</name></name><operator>)</operator></expr></argument>, <argument><expr><name>POLAR_BG_PARALLEL_REPLAYING</name></expr></argument>)</argument_list></call></expr>;</expr_stmt><empty_stmt>;</empty_stmt>

	<comment type="block">/* Test the origin buffer full */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>NBuffers</name> <operator>&amp;&amp;</operator> <name>j</name> <operator>&lt;</operator> <name>test_bp_buf_nums</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>BufferDesc</name> <modifier>*</modifier></type><name>buf_hdr</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>XLogRecPtr</name></type> <name>replay_lsn</name> <init>= <expr><name>InvalidXLogRecPtr</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type> <name>run_extra_case</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type> <name>inserted</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type> <name>check_buf_redo_state</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>buf_hdr</name> <operator>=</operator> <call><name>test_lock_buffer_in_bp</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>buf_hdr</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>run_extra_case</name> <operator>=</operator> <operator>(</operator><name>j</name><operator>&amp;</operator><literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>is_recovery</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>run_extra_case</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>replay_lsn</name> <operator>=</operator> <call><name>polar_get_curr_fbpoint_lsn</name><argument_list>(<argument><expr><name>buf_ctl_test</name></expr></argument>)</argument_list></call> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>set_buf_flog_state</name><argument_list>(<argument><expr><name>buf_hdr</name></expr></argument>, <argument><expr><name>POLAR_BUF_FLOG_DISABLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>inserted</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name>replay_lsn</name> <operator>=</operator> <call><name>polar_get_curr_fbpoint_lsn</name><argument_list>(<argument><expr><name>buf_ctl_test</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>polar_check_buf_flog_state</name><argument_list>(<argument><expr><name>buf_hdr</name></expr></argument>, <argument><expr><name>POLAR_BUF_IN_FLOG_LIST</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>check_buf_redo_state</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>inserted</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>is_recovery</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><call><name>polar_is_buf_flog_enabled</name><argument_list>(<argument><expr><name>test_instance</name></expr></argument>, <argument><expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
					<call><name>polar_is_flog_needed</name><argument_list>(<argument><expr><name>test_instance</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>redo_ins</name></expr></argument>, <argument><expr><name><name>buf_hdr</name><operator>-&gt;</operator><name>tag</name><operator>.</operator><name>forkNum</name></name></expr></argument>,
							<argument><expr><call><name>BufHdrGetBlock</name><argument_list>(<argument><expr><name>buf_hdr</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>pg_atomic_read_u32</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>buf_hdr</name><operator>-&gt;</operator><name>state</name></name></expr></argument>)</argument_list></call> <operator>&amp;</operator> <name>BM_PERMANENT</name></expr></argument>,
							<argument><expr><name>InvalidXLogRecPtr</name></expr></argument>, <argument><expr><name>replay_lsn</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>polar_flog_insert</name><argument_list>(<argument><expr><name>test_instance</name></expr></argument>, <argument><expr><name><name>buf_hdr</name><operator>-&gt;</operator><name>buf_id</name></name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>is_recovery</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name>inserted</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><call><name>polar_is_flog_needed</name><argument_list>(<argument><expr><name>test_instance</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>redo_ins</name></expr></argument>, <argument><expr><name><name>buf_hdr</name><operator>-&gt;</operator><name>tag</name><operator>.</operator><name>forkNum</name></name></expr></argument>,
				<argument><expr><call><name>BufHdrGetBlock</name><argument_list>(<argument><expr><name>buf_hdr</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>pg_atomic_read_u32</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>buf_hdr</name><operator>-&gt;</operator><name>state</name></name></expr></argument>)</argument_list></call> <operator>&amp;</operator> <name>BM_PERMANENT</name></expr></argument>,
				<argument><expr><name>InvalidXLogRecPtr</name></expr></argument>, <argument><expr><name>InvalidXLogRecPtr</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>polar_flog_insert</name><argument_list>(<argument><expr><name>test_instance</name></expr></argument>, <argument><expr><name><name>buf_hdr</name><operator>-&gt;</operator><name>buf_id</name></name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>is_recovery</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><call><name>polar_flog_insert</name><argument_list>(<argument><expr><name>test_instance</name></expr></argument>, <argument><expr><name><name>buf_hdr</name><operator>-&gt;</operator><name>buf_id</name></name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>is_recovery</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>inserted</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>check_flog_list_insert</name><argument_list>(<argument><expr><name>i</name></expr></argument>, <argument><expr><name>fbpoint_lsn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>bufs</name><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>j</name><operator>++</operator></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><call><name>check_flog_list_clean</name><argument_list>(<argument><expr><name>i</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>check_buf_redo_state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><call><name>BufferDescriptorGetContentLock</name><argument_list>(<argument><expr><name>buf_hdr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></for>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>j</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type> <name>buf_id</name> <init>= <expr><name><name>bufs</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>BufferDesc</name> <modifier>*</modifier></type><name>buf_hdr</name> <init>=  <expr><call><name>GetBufferDescriptor</name><argument_list>(<argument><expr><name>buf_id</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>polar_flush_buf_flog_rec</name><argument_list>(<argument><expr><name>buf_hdr</name></expr></argument>, <argument><expr><name>test_instance</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>check_flog_list_clean</name><argument_list>(<argument><expr><name><name>buf_hdr</name><operator>-&gt;</operator><name>buf_id</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><call><name>BufferDescriptorGetContentLock</name><argument_list>(<argument><expr><name>buf_hdr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>test_flashback_log_online_promote</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>polar_logindex_redo_ctl_data_t</name></type> <name>redo_instance</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>j</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>XLogRecPtr</name></type> <name>fbpoint_lsn_perior</name></decl>;</decl_stmt>

	<comment type="block">/* Recovery */</comment>
	<expr_stmt><expr><call><name>test_flog_crash_recovery</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* Mark a fake flashback point lsn */</comment>
	<expr_stmt><expr><name>fbpoint_lsn_perior</name> <operator>=</operator> <call><name>polar_get_curr_fbpoint_lsn</name><argument_list>(<argument><expr><name>buf_ctl_test</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Mark online promote */</comment>
	<expr_stmt><expr><call><name>pg_atomic_write_u32</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>redo_instance</name><operator>.</operator><name>bg_redo_state</name></name><operator>)</operator></expr></argument>, <argument><expr><name>POLAR_BG_ONLINE_PROMOTE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Test the origin buffer full */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>NBuffers</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>BufferDesc</name> <modifier>*</modifier></type><name>buf_hdr</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type> <name>inserted</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type> <name>check_buf_redo_state</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>buf_hdr</name> <operator>=</operator> <call><name>test_lock_buffer_in_bp</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>buf_hdr</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<comment type="block">/* Mark a fake local flashback point lsn */</comment>
		<expr_stmt><expr><call><name>polar_get_local_fbpoint_lsn</name><argument_list>(<argument><expr><name>buf_ctl_test</name></expr></argument>, <argument><expr><name>InvalidXLogRecPtr</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><operator>(</operator><name>j</name> <operator>&amp;</operator> <literal type="number">1</literal><operator>)</operator> <operator>||</operator>
				<call><name>polar_check_buf_flog_state</name><argument_list>(<argument><expr><name>buf_hdr</name></expr></argument>, <argument><expr><name>POLAR_BUF_FLOG_LOST_CHECKED</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>polar_set_buf_flog_lost_checked</name><argument_list>(<argument><expr><name>test_instance</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>redo_instance</name></expr></argument>, <argument><expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>inserted</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>polar_check_buf_flog_state</name><argument_list>(<argument><expr><name>buf_hdr</name></expr></argument>, <argument><expr><name>POLAR_BUF_IN_FLOG_LIST</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>inserted</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>check_buf_redo_state</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>polar_may_buf_lost_flog</name><argument_list>(<argument><expr><name>test_instance</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>redo_instance</name></expr></argument>, <argument><expr><name>buf_hdr</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>polar_flog_insert</name><argument_list>(<argument><expr><name>test_instance</name></expr></argument>, <argument><expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>inserted</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>inserted</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>check_flog_list_insert</name><argument_list>(<argument><expr><name>i</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>j</name><operator>++</operator></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>check_flog_list_clean</name><argument_list>(<argument><expr><name>i</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>check_buf_redo_state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><call><name>BufferDescriptorGetContentLock</name><argument_list>(<argument><expr><name>buf_hdr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<comment type="block">/* Recovery the flashback point */</comment>
	<expr_stmt><expr><name><name>buf_ctl_test</name><operator>-&gt;</operator><name>wal_info</name><operator>.</operator><name>fbpoint_lsn</name></name> <operator>=</operator> <name>fbpoint_lsn_perior</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>_PG_init</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>process_shared_preload_libraries_in_progress</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>RequestAddinShmemSpace</name><argument_list>(<argument><expr><call><name>get_test_shmem_size</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>prev_shmem_startup_hook</name> <operator>=</operator> <name>shmem_startup_hook</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>shmem_startup_hook</name> <operator>=</operator> <name>test_flog_shmem_startup</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>_PG_fini</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><name>shmem_startup_hook</name> <operator>=</operator> <name>prev_shmem_startup_hook</name></expr>;</expr_stmt>
</block_content>}</block></function>

<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>test_flashback_log</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<comment type="block">/*
 * SQL-callable entry point to perform all tests.
 */</comment>
<function><type><name>Datum</name></type>
<name>test_flashback_log</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>polar_flog_rec_ptr</name></type> <name>ptr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>flog_ctl_file_data_t</name></type> <name>ctl_file_data</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CheckPoint</name></type> <name>checkpoint</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>fbpoint_wal_info_data_t</name></type> <name>wal_info</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>polar_is_flog_enabled</name><argument_list>(<argument><expr><name>flog_instance</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PG_RETURN_VOID</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Test flashback log init */</comment>
	<expr_stmt><expr><call><name>test_flog_init</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Test the flashback log start up */</comment>
	<expr_stmt><expr><name><name>wal_info</name><operator>.</operator><name>fbpoint_lsn</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>init_flog_buf_ctl_data</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ctl_file_data</name></expr></argument>, <argument><expr><name>POLAR_INVALID_FLOG_SEGNO</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>wal_info</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>test_flog_startup</name><argument_list>(<argument><expr><name>false</name></expr></argument>, <argument><expr><name>ctl_file_data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Test the flashback log recover */</comment>
	<expr_stmt><expr><call><name>test_flog_recover</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Test the flashback log insert to buffer */</comment>
	<expr_stmt><expr><name>ptr</name> <operator>=</operator> <call><name>test_flog_insert_buffer</name><argument_list>(<argument><expr><name>POLAR_INVALID_FLOG_REC_PTR</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>INT_MAX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Test the flashback log write */</comment>
	<expr_stmt><expr><call><name>test_flog_write</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Test the flashback log read */</comment>
	<expr_stmt><expr><call><name>test_flog_read</name><argument_list>(<argument><expr><name>FLOG_LONG_PHD_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Test the flashback logindex write */</comment>
	<expr_stmt><expr><call><name>test_flog_index_write</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Test the flashback logindex search */</comment>
	<expr_stmt><expr><call><name>test_flog_index_search</name><argument_list>(<argument><expr><name>POLAR_INVALID_FLOG_REC_PTR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Test the flashback log checkpoint (normal) */</comment>
	<expr_stmt><expr><call><name>test_flog_checkpoint</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Test the flashback log insert to list with origin buffer */</comment>
	<expr_stmt><expr><call><name>test_flog_insert_list</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Test the buffer sync the flashback log record */</comment>
	<expr_stmt><expr><call><name>test_buf_flog_rec_sync</name><argument_list>(<argument><expr><name>test_bufs</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Test the origin buffer full */</comment>
	<expr_stmt><expr><call><name>test_origin_buf_full</name><argument_list>(<argument><expr><name>POLAR_ORIGIN_PAGE_BUF_NUM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Test flashback log crash recovery */</comment>
	<expr_stmt><expr><call><name>test_flog_crash_recovery</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Test flashback log repaire the buffer */</comment>
	<expr_stmt><expr><call><name>test_flog_repair_buffer</name><argument_list>(<argument><expr><name>test_bufs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Test insert to flashback log from buffer pool in recovery (a standby or crash recovery). */</comment>
	<expr_stmt><expr><call><name>test_insert_flog_from_bp</name><argument_list>(<argument><expr><literal type="number">100</literal></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Test insert to flashback log from buffer pool. */</comment>
	<expr_stmt><expr><call><name>test_insert_flog_from_bp</name><argument_list>(<argument><expr><literal type="number">100</literal></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Test flashback log shutdown recovery */</comment>
	<expr_stmt><expr><call><name>test_flog_shutdown_recovery</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Test flashback log background work function */</comment>
	<expr_stmt><expr><call><name>test_flog_bg_worker_functions</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Test flashback log prealloc files */</comment>
	<expr_stmt><expr><call><name>test_flog_prealloc_files</name><argument_list>(<argument><expr><name>TEST_FLOG_PREALLOC_FILE_NUM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Test flashback log online promote */</comment>
	<expr_stmt><expr><call><name>test_flashback_log_online_promote</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* test remove the flashback data */</comment>
	<expr_stmt><expr><name>polar_enable_flashback_log</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>checkpoint</name><operator>.</operator><name>redo</name></name> <operator>=</operator> <call><name>GetRedoRecPtr</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>checkpoint</name><operator>.</operator><name>time</name></name> <operator>=</operator> <operator>(</operator><name>pg_time_t</name><operator>)</operator> <call><name>time</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>polar_startup_flog</name><argument_list>(<argument><expr><operator>&amp;</operator><name>checkpoint</name></expr></argument>, <argument><expr><name>test_instance</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>check_flog_dir_validate</name><argument_list>(<argument><expr><name>TEST_FLOG_NAME</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_VOID</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
</unit>
