<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/PolarDB-for-PostgreSQL/src/bin/psql/startup.c"><comment type="block">/*
 * psql - the PostgreSQL interactive terminal
 *
 * Copyright (c) 2000-2018, PostgreSQL Global Development Group
 *
 * src/bin/psql/startup.c
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres_fe.h"</cpp:file></cpp:include>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>WIN32</name></cpp:ifndef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;unistd.h&gt;</cpp:file></cpp:include>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>							<comment type="block">/* WIN32 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;io.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;win32.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>							<comment type="block">/* WIN32 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"getopt_long.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"command.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"common.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"describe.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"help.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"input.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"mainloop.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"fe_utils/print.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"settings.h"</cpp:file></cpp:include>



<comment type="block">/*
 * Global psql options
 */</comment>
<decl_stmt><decl><type><name>PsqlSettings</name></type> <name>pset</name></decl>;</decl_stmt>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>WIN32</name></cpp:ifndef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SYSPSQLRC</name></cpp:macro>	<cpp:value>"psqlrc"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PSQLRC</name></cpp:macro>		<cpp:value>".psqlrc"</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SYSPSQLRC</name></cpp:macro>	<cpp:value>"psqlrc"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PSQLRC</name></cpp:macro>		<cpp:value>"psqlrc.conf"</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
 * Structures to pass information between the option parsing routine
 * and the main function
 */</comment>
<enum>enum <name>_actions</name>
<block>{
	<decl><name>ACT_SINGLE_QUERY</name></decl>,
	<decl><name>ACT_SINGLE_SLASH</name></decl>,
	<decl><name>ACT_FILE</name></decl>
}</block>;</enum>

<typedef>typedef <type><struct>struct <name>SimpleActionListCell</name>
<block>{
	<decl_stmt><decl><type><name><name>struct</name> <name>SimpleActionListCell</name></name> <modifier>*</modifier></type><name>next</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>enum</name> <name>_actions</name></name></type> <name>action</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>val</name></decl>;</decl_stmt>
}</block></struct></type> <name>SimpleActionListCell</name>;</typedef>

<typedef>typedef <type><struct>struct <name>SimpleActionList</name>
<block>{
	<decl_stmt><decl><type><name>SimpleActionListCell</name> <modifier>*</modifier></type><name>head</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SimpleActionListCell</name> <modifier>*</modifier></type><name>tail</name></decl>;</decl_stmt>
}</block></struct></type> <name>SimpleActionList</name>;</typedef>

<struct>struct <name>adhoc_opts</name>
<block>{
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>dbname</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>host</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>port</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>username</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>logfilename</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>no_readline</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>no_psqlrc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>single_txn</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>list_dbs</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SimpleActionList</name></type> <name>actions</name></decl>;</decl_stmt>
}</block>;</struct>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>parse_psql_options</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name><name>argv</name><index>[]</index></name></decl></parameter>,
				   <parameter><decl><type><name><name>struct</name> <name>adhoc_opts</name></name> <modifier>*</modifier></type><name>options</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>simple_action_list_append</name><parameter_list>(<parameter><decl><type><name>SimpleActionList</name> <modifier>*</modifier></type><name>list</name></decl></parameter>,
						  <parameter><decl><type><name><name>enum</name> <name>_actions</name></name></type> <name>action</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>val</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>process_psqlrc</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>argv0</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>process_psqlrc_file</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>filename</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>showVersion</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>EstablishVariableSpace</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NOPAGER</name></cpp:macro>		<cpp:value>0</cpp:value></cpp:define>

<comment type="block">/*
 *
 * main
 *
 */</comment>
<function><type><name>int</name></type>
<name>main</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name><name>argv</name><index>[]</index></name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name><name>struct</name> <name>adhoc_opts</name></name></type> <name>options</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>successResult</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>have_password</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>password</name><index>[<expr><literal type="number">100</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>new_pass</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>set_pglocale_pgservice</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><call><name>PG_TEXTDOMAIN</name><argument_list>(<argument><expr><literal type="string">"psql"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>argc</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>(</operator><call><name>strcmp</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"-?"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal><operator>)</operator> <operator>||</operator> <operator>(</operator><name>argc</name> <operator>==</operator> <literal type="number">2</literal> <operator>&amp;&amp;</operator> <operator>(</operator><call><name>strcmp</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"--help"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal><operator>)</operator><operator>)</operator></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>usage</name><argument_list>(<argument><expr><name>NOPAGER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><name>EXIT_SUCCESS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"--version"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <call><name>strcmp</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"-V"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>showVersion</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><name>EXIT_SUCCESS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WIN32</name></cpp:ifdef>
	<expr_stmt><expr><call><name>setvbuf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>_IONBF</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<expr_stmt><expr><name><name>pset</name><operator>.</operator><name>progname</name></name> <operator>=</operator> <call><name>get_progname</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>pset</name><operator>.</operator><name>db</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>setDecimalLocale</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pset</name><operator>.</operator><name>encoding</name></name> <operator>=</operator> <call><name>PQenv2encoding</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pset</name><operator>.</operator><name>queryFout</name></name> <operator>=</operator> <name>stdout</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pset</name><operator>.</operator><name>queryReplicaFout</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pset</name><operator>.</operator><name>queryFoutPipe</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<comment type="block">/* POLAR */</comment>
	<expr_stmt><expr><name><name>pset</name><operator>.</operator><name>queryReplicaFoutPipe</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pset</name><operator>.</operator><name>copyStream</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pset</name><operator>.</operator><name>last_error_result</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pset</name><operator>.</operator><name>cur_cmd_source</name></name> <operator>=</operator> <name>stdin</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pset</name><operator>.</operator><name>cur_cmd_interactive</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<comment type="block">/* We rely on unmentioned fields of pset.popt to start out 0/false/NULL */</comment>
	<expr_stmt><expr><name><name>pset</name><operator>.</operator><name>popt</name><operator>.</operator><name>topt</name><operator>.</operator><name>format</name></name> <operator>=</operator> <name>PRINT_ALIGNED</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pset</name><operator>.</operator><name>popt</name><operator>.</operator><name>topt</name><operator>.</operator><name>border</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pset</name><operator>.</operator><name>popt</name><operator>.</operator><name>topt</name><operator>.</operator><name>pager</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pset</name><operator>.</operator><name>popt</name><operator>.</operator><name>topt</name><operator>.</operator><name>pager_min_lines</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pset</name><operator>.</operator><name>popt</name><operator>.</operator><name>topt</name><operator>.</operator><name>start_table</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pset</name><operator>.</operator><name>popt</name><operator>.</operator><name>topt</name><operator>.</operator><name>stop_table</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pset</name><operator>.</operator><name>popt</name><operator>.</operator><name>topt</name><operator>.</operator><name>default_footer</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>pset</name><operator>.</operator><name>popt</name><operator>.</operator><name>topt</name><operator>.</operator><name>unicode_border_linestyle</name></name> <operator>=</operator> <name>UNICODE_LINESTYLE_SINGLE</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pset</name><operator>.</operator><name>popt</name><operator>.</operator><name>topt</name><operator>.</operator><name>unicode_column_linestyle</name></name> <operator>=</operator> <name>UNICODE_LINESTYLE_SINGLE</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pset</name><operator>.</operator><name>popt</name><operator>.</operator><name>topt</name><operator>.</operator><name>unicode_header_linestyle</name></name> <operator>=</operator> <name>UNICODE_LINESTYLE_SINGLE</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>refresh_utf8format</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>pset</name><operator>.</operator><name>popt</name><operator>.</operator><name>topt</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* We must get COLUMNS here before readline() sets it */</comment>
	<expr_stmt><expr><name><name>pset</name><operator>.</operator><name>popt</name><operator>.</operator><name>topt</name><operator>.</operator><name>env_columns</name></name> <operator>=</operator> <ternary><condition><expr><call><name>getenv</name><argument_list>(<argument><expr><literal type="string">"COLUMNS"</literal></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><call><name>atoi</name><argument_list>(<argument><expr><call><name>getenv</name><argument_list>(<argument><expr><literal type="string">"COLUMNS"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>pset</name><operator>.</operator><name>notty</name></name> <operator>=</operator> <operator>(</operator><operator>!</operator><call><name>isatty</name><argument_list>(<argument><expr><call><name>fileno</name><argument_list>(<argument><expr><name>stdin</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>||</operator> <operator>!</operator><call><name>isatty</name><argument_list>(<argument><expr><call><name>fileno</name><argument_list>(<argument><expr><name>stdout</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>pset</name><operator>.</operator><name>getPassword</name></name> <operator>=</operator> <name>TRI_DEFAULT</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>EstablishVariableSpace</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Create variables showing psql version number */</comment>
	<expr_stmt><expr><call><name>SetVariable</name><argument_list>(<argument><expr><name><name>pset</name><operator>.</operator><name>vars</name></name></expr></argument>, <argument><expr><literal type="string">"VERSION"</literal></expr></argument>, <argument><expr><name>PG_VERSION_STR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SetVariable</name><argument_list>(<argument><expr><name><name>pset</name><operator>.</operator><name>vars</name></name></expr></argument>, <argument><expr><literal type="string">"VERSION_NAME"</literal></expr></argument>, <argument><expr><name>PG_VERSION</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SetVariable</name><argument_list>(<argument><expr><name><name>pset</name><operator>.</operator><name>vars</name></name></expr></argument>, <argument><expr><literal type="string">"VERSION_NUM"</literal></expr></argument>, <argument><expr><call><name>CppAsString2</name><argument_list>(<argument><expr><name>PG_VERSION_NUM</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Initialize variables for last error */</comment>
	<expr_stmt><expr><call><name>SetVariable</name><argument_list>(<argument><expr><name><name>pset</name><operator>.</operator><name>vars</name></name></expr></argument>, <argument><expr><literal type="string">"LAST_ERROR_MESSAGE"</literal></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SetVariable</name><argument_list>(<argument><expr><name><name>pset</name><operator>.</operator><name>vars</name></name></expr></argument>, <argument><expr><literal type="string">"LAST_ERROR_SQLSTATE"</literal></expr></argument>, <argument><expr><literal type="string">"00000"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Default values for variables (that don't match the result of \unset) */</comment>
	<expr_stmt><expr><call><name>SetVariableBool</name><argument_list>(<argument><expr><name><name>pset</name><operator>.</operator><name>vars</name></name></expr></argument>, <argument><expr><literal type="string">"AUTOCOMMIT"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SetVariable</name><argument_list>(<argument><expr><name><name>pset</name><operator>.</operator><name>vars</name></name></expr></argument>, <argument><expr><literal type="string">"PROMPT1"</literal></expr></argument>, <argument><expr><name>DEFAULT_PROMPT1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SetVariable</name><argument_list>(<argument><expr><name><name>pset</name><operator>.</operator><name>vars</name></name></expr></argument>, <argument><expr><literal type="string">"PROMPT2"</literal></expr></argument>, <argument><expr><name>DEFAULT_PROMPT2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SetVariable</name><argument_list>(<argument><expr><name><name>pset</name><operator>.</operator><name>vars</name></name></expr></argument>, <argument><expr><literal type="string">"PROMPT3"</literal></expr></argument>, <argument><expr><name>DEFAULT_PROMPT3</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>parse_psql_options</name><argument_list>(<argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>options</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If no action was specified and we're in non-interactive mode, treat it
	 * as if the user had specified "-f -".  This lets single-transaction mode
	 * work in this case.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>options</name><operator>.</operator><name>actions</name><operator>.</operator><name>head</name></name> <operator>==</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name><name>pset</name><operator>.</operator><name>notty</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>simple_action_list_append</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>options</name><operator>.</operator><name>actions</name></name></expr></argument>, <argument><expr><name>ACT_FILE</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Bail out if -1 was specified but will be ignored. */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>options</name><operator>.</operator><name>single_txn</name></name> <operator>&amp;&amp;</operator> <name><name>options</name><operator>.</operator><name>actions</name><operator>.</operator><name>head</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: -1 can only be used in non-interactive mode\n"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>pset</name><operator>.</operator><name>progname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><name>EXIT_FAILURE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>pset</name><operator>.</operator><name>popt</name><operator>.</operator><name>topt</name><operator>.</operator><name>fieldSep</name><operator>.</operator><name>separator</name></name> <operator>&amp;&amp;</operator>
		<operator>!</operator><name><name>pset</name><operator>.</operator><name>popt</name><operator>.</operator><name>topt</name><operator>.</operator><name>fieldSep</name><operator>.</operator><name>separator_zero</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>pset</name><operator>.</operator><name>popt</name><operator>.</operator><name>topt</name><operator>.</operator><name>fieldSep</name><operator>.</operator><name>separator</name></name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><name>DEFAULT_FIELD_SEP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>pset</name><operator>.</operator><name>popt</name><operator>.</operator><name>topt</name><operator>.</operator><name>fieldSep</name><operator>.</operator><name>separator_zero</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>pset</name><operator>.</operator><name>popt</name><operator>.</operator><name>topt</name><operator>.</operator><name>recordSep</name><operator>.</operator><name>separator</name></name> <operator>&amp;&amp;</operator>
		<operator>!</operator><name><name>pset</name><operator>.</operator><name>popt</name><operator>.</operator><name>topt</name><operator>.</operator><name>recordSep</name><operator>.</operator><name>separator_zero</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>pset</name><operator>.</operator><name>popt</name><operator>.</operator><name>topt</name><operator>.</operator><name>recordSep</name><operator>.</operator><name>separator</name></name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><name>DEFAULT_RECORD_SEP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>pset</name><operator>.</operator><name>popt</name><operator>.</operator><name>topt</name><operator>.</operator><name>recordSep</name><operator>.</operator><name>separator_zero</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>pset</name><operator>.</operator><name>getPassword</name></name> <operator>==</operator> <name>TRI_YES</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * We can't be sure yet of the username that will be used, so don't
		 * offer a potentially wrong one.  Typical uses of this option are
		 * noninteractive anyway.
		 */</comment>
		<expr_stmt><expr><call><name>simple_prompt</name><argument_list>(<argument><expr><literal type="string">"Password: "</literal></expr></argument>, <argument><expr><name>password</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>password</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>have_password</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* loop until we have a password if requested by backend */</comment>
	<do>do
	<block>{<block_content>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PARAMS_ARRAY_SIZE</name></cpp:macro>	<cpp:value>8</cpp:value></cpp:define>
		<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>keywords</name> <init>= <expr><call><name>pg_malloc</name><argument_list>(<argument><expr><name>PARAMS_ARRAY_SIZE</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>keywords</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>values</name> <init>= <expr><call><name>pg_malloc</name><argument_list>(<argument><expr><name>PARAMS_ARRAY_SIZE</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>values</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>keywords</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="string">"host"</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name><name>options</name><operator>.</operator><name>host</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>keywords</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <literal type="string">"port"</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name><name>options</name><operator>.</operator><name>port</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>keywords</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <literal type="string">"user"</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <name><name>options</name><operator>.</operator><name>username</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>keywords</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>=</operator> <literal type="string">"password"</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>=</operator> <ternary><condition><expr><name>have_password</name></expr> ?</condition><then> <expr><name>password</name></expr> </then><else>: <expr><name>NULL</name></expr></else></ternary></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>keywords</name><index>[<expr><literal type="number">4</literal></expr>]</index></name> <operator>=</operator> <literal type="string">"dbname"</literal></expr>;</expr_stmt> <comment type="block">/* see do_connect() */</comment>
		<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">4</literal></expr>]</index></name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name><name>options</name><operator>.</operator><name>list_dbs</name></name> <operator>&amp;&amp;</operator> <name><name>options</name><operator>.</operator><name>dbname</name></name> <operator>==</operator> <name>NULL</name><operator>)</operator></expr> ?</condition><then>
			<expr><literal type="string">"postgres"</literal></expr> </then><else>: <expr><name><name>options</name><operator>.</operator><name>dbname</name></name></expr></else></ternary></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>keywords</name><index>[<expr><literal type="number">5</literal></expr>]</index></name> <operator>=</operator> <literal type="string">"fallback_application_name"</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">5</literal></expr>]</index></name> <operator>=</operator> <name><name>pset</name><operator>.</operator><name>progname</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>keywords</name><index>[<expr><literal type="number">6</literal></expr>]</index></name> <operator>=</operator> <literal type="string">"client_encoding"</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">6</literal></expr>]</index></name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name><name>pset</name><operator>.</operator><name>notty</name></name> <operator>||</operator> <call><name>getenv</name><argument_list>(<argument><expr><literal type="string">"PGCLIENTENCODING"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr> ?</condition><then> <expr><name>NULL</name></expr> </then><else>: <expr><literal type="string">"auto"</literal></expr></else></ternary></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>keywords</name><index>[<expr><literal type="number">7</literal></expr>]</index></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">7</literal></expr>]</index></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

		<expr_stmt><expr><name>new_pass</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>pset</name><operator>.</operator><name>db</name></name> <operator>=</operator> <call><name>PQconnectdbParams</name><argument_list>(<argument><expr><name>keywords</name></expr></argument>, <argument><expr><name>values</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* POLAR: connect to replica */</comment>
		<expr_stmt><expr><name><name>keywords</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="string">"host"</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <ternary><condition><expr><call><name>getenv</name><argument_list>(<argument><expr><literal type="string">"PGREPLICAHOST"</literal></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><call><name>strdup</name><argument_list>(<argument><expr><call><name>getenv</name><argument_list>(<argument><expr><literal type="string">"PGREPLICAHOST"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> </then><else>: <expr><name>NULL</name></expr></else></ternary></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>keywords</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <literal type="string">"port"</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <ternary><condition><expr><call><name>getenv</name><argument_list>(<argument><expr><literal type="string">"PGREPLICAPORT"</literal></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><call><name>strdup</name><argument_list>(<argument><expr><call><name>getenv</name><argument_list>(<argument><expr><literal type="string">"PGREPLICAPORT"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> </then><else>: <expr><name>NULL</name></expr></else></ternary></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>keywords</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <literal type="string">"user"</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <name><name>options</name><operator>.</operator><name>username</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>keywords</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>=</operator> <literal type="string">"password"</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>=</operator> <ternary><condition><expr><name>have_password</name></expr> ?</condition><then> <expr><name>password</name></expr> </then><else>: <expr><name>NULL</name></expr></else></ternary></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>keywords</name><index>[<expr><literal type="number">4</literal></expr>]</index></name> <operator>=</operator> <literal type="string">"dbname"</literal></expr>;</expr_stmt> <comment type="block">/* see do_connect() */</comment>
		<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">4</literal></expr>]</index></name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name><name>options</name><operator>.</operator><name>list_dbs</name></name> <operator>&amp;&amp;</operator> <name><name>options</name><operator>.</operator><name>dbname</name></name> <operator>==</operator> <name>NULL</name><operator>)</operator></expr> ?</condition><then>
			<expr><literal type="string">"postgres"</literal></expr> </then><else>: <expr><name><name>options</name><operator>.</operator><name>dbname</name></name></expr></else></ternary></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>keywords</name><index>[<expr><literal type="number">5</literal></expr>]</index></name> <operator>=</operator> <literal type="string">"fallback_application_name"</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">5</literal></expr>]</index></name> <operator>=</operator> <name><name>pset</name><operator>.</operator><name>progname</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>keywords</name><index>[<expr><literal type="number">6</literal></expr>]</index></name> <operator>=</operator> <literal type="string">"client_encoding"</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">6</literal></expr>]</index></name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name><name>pset</name><operator>.</operator><name>notty</name></name> <operator>||</operator> <call><name>getenv</name><argument_list>(<argument><expr><literal type="string">"PGCLIENTENCODING"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr> ?</condition><then> <expr><name>NULL</name></expr> </then><else>: <expr><literal type="string">"auto"</literal></expr></else></ternary></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>keywords</name><index>[<expr><literal type="number">7</literal></expr>]</index></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">7</literal></expr>]</index></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

		<expr_stmt><expr><name>new_pass</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>getenv</name><argument_list>(<argument><expr><literal type="string">"PGREPLICAHOST"</literal></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>getenv</name><argument_list>(<argument><expr><literal type="string">"PGREPLICAPORT"</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>pset</name><operator>.</operator><name>replicadb</name></name> <operator>=</operator> <call><name>PQconnectdbParams</name><argument_list>(<argument><expr><name>keywords</name></expr></argument>, <argument><expr><name>values</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>pset</name><operator>.</operator><name>replicadb</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
		<comment type="block">/* POLAR end */</comment>

		<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>keywords</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>values</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>PQstatus</name><argument_list>(<argument><expr><name><name>pset</name><operator>.</operator><name>db</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <name>CONNECTION_BAD</name> <operator>&amp;&amp;</operator>
			<call><name>PQconnectionNeedsPassword</name><argument_list>(<argument><expr><name><name>pset</name><operator>.</operator><name>db</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
			<operator>!</operator><name>have_password</name> <operator>&amp;&amp;</operator>
			<name><name>pset</name><operator>.</operator><name>getPassword</name></name> <operator>!=</operator> <name>TRI_NO</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * Before closing the old PGconn, extract the user name that was
			 * actually connected with --- it might've come out of a URI or
			 * connstring "database name" rather than options.username.
			 */</comment>
			<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>realusername</name> <init>= <expr><call><name>PQuser</name><argument_list>(<argument><expr><name><name>pset</name><operator>.</operator><name>db</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>password_prompt</name></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name>realusername</name> <operator>&amp;&amp;</operator> <name><name>realusername</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>password_prompt</name> <operator>=</operator> <call><name>psprintf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Password for user %s: "</literal></expr></argument>)</argument_list></call></expr></argument>,
										   <argument><expr><name>realusername</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name>password_prompt</name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Password: "</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
			<expr_stmt><expr><call><name>PQfinish</name><argument_list>(<argument><expr><name><name>pset</name><operator>.</operator><name>db</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>simple_prompt</name><argument_list>(<argument><expr><name>password_prompt</name></expr></argument>, <argument><expr><name>password</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>password</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>password_prompt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>have_password</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>new_pass</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block> while <condition>(<expr><name>new_pass</name></expr>)</condition>;</do>

	<if_stmt><if>if <condition>(<expr><call><name>PQstatus</name><argument_list>(<argument><expr><name><name>pset</name><operator>.</operator><name>db</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <name>CONNECTION_BAD</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"%s: %s"</literal></expr></argument>, <argument><expr><name><name>pset</name><operator>.</operator><name>progname</name></name></expr></argument>, <argument><expr><call><name>PQerrorMessage</name><argument_list>(<argument><expr><name><name>pset</name><operator>.</operator><name>db</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>PQfinish</name><argument_list>(<argument><expr><name><name>pset</name><operator>.</operator><name>db</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><name>EXIT_BADCONN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>setup_cancel_handler</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PQsetNoticeProcessor</name><argument_list>(<argument><expr><name><name>pset</name><operator>.</operator><name>db</name></name></expr></argument>, <argument><expr><name>NoticeProcessor</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* POLAR: as the above */</comment>
	<expr_stmt><expr><call><name>PQsetNoticeProcessor</name><argument_list>(<argument><expr><name><name>pset</name><operator>.</operator><name>replicadb</name></name></expr></argument>, <argument><expr><name>NoticeProcessor</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>SyncVariables</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>options</name><operator>.</operator><name>list_dbs</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>success</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>options</name><operator>.</operator><name>no_psqlrc</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>process_psqlrc</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>success</name> <operator>=</operator> <call><name>listAllDbs</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>PQfinish</name><argument_list>(<argument><expr><name><name>pset</name><operator>.</operator><name>db</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><ternary><condition><expr><name>success</name></expr> ?</condition><then> <expr><name>EXIT_SUCCESS</name></expr> </then><else>: <expr><name>EXIT_FAILURE</name></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>options</name><operator>.</operator><name>logfilename</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>pset</name><operator>.</operator><name>logfile</name></name> <operator>=</operator> <call><name>fopen</name><argument_list>(<argument><expr><name><name>options</name><operator>.</operator><name>logfilename</name></name></expr></argument>, <argument><expr><literal type="string">"a"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>pset</name><operator>.</operator><name>logfile</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: could not open log file \"%s\": %s\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
					<argument><expr><name><name>pset</name><operator>.</operator><name>progname</name></name></expr></argument>, <argument><expr><name><name>options</name><operator>.</operator><name>logfilename</name></name></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><name>EXIT_FAILURE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>options</name><operator>.</operator><name>no_psqlrc</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>process_psqlrc</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * If any actions were given by user, process them in the order in which
	 * they were specified.  Note single_txn is only effective in this mode.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>options</name><operator>.</operator><name>actions</name><operator>.</operator><name>head</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>SimpleActionListCell</name> <modifier>*</modifier></type><name>cell</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>successResult</name> <operator>=</operator> <name>EXIT_SUCCESS</name></expr>;</expr_stmt>	<comment type="block">/* silence compiler */</comment>

		<if_stmt><if>if <condition>(<expr><name><name>options</name><operator>.</operator><name>single_txn</name></name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><operator>(</operator><name>res</name> <operator>=</operator> <call><name>PSQLexec</name><argument_list>(<argument><expr><literal type="string">"BEGIN"</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name><name>pset</name><operator>.</operator><name>on_error_stop</name></name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name>successResult</name> <operator>=</operator> <name>EXIT_USER</name></expr>;</expr_stmt>
					<goto>goto <name>error</name>;</goto>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
		</block_content>}</block></if></if_stmt>

		<for>for <control>(<init><expr><name>cell</name> <operator>=</operator> <name><name>options</name><operator>.</operator><name>actions</name><operator>.</operator><name>head</name></name></expr>;</init> <condition><expr><name>cell</name></expr>;</condition> <incr><expr><name>cell</name> <operator>=</operator> <name><name>cell</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name><name>cell</name><operator>-&gt;</operator><name>action</name></name> <operator>==</operator> <name>ACT_SINGLE_QUERY</name></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name><name>pset</name><operator>.</operator><name>echo</name></name> <operator>==</operator> <name>PSQL_ECHO_ALL</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>puts</name><argument_list>(<argument><expr><name><name>cell</name><operator>-&gt;</operator><name>val</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

				<expr_stmt><expr><name>successResult</name> <operator>=</operator> <ternary><condition><expr><call><name>SendQuery</name><argument_list>(<argument><expr><name><name>cell</name><operator>-&gt;</operator><name>val</name></name></expr></argument>)</argument_list></call></expr>
					?</condition><then> <expr><name>EXIT_SUCCESS</name></expr> </then><else>: <expr><name>EXIT_FAILURE</name></expr></else></ternary></expr>;</expr_stmt>
			</block_content>}</block></if>
			<if type="elseif">else if <condition>(<expr><name><name>cell</name><operator>-&gt;</operator><name>action</name></name> <operator>==</operator> <name>ACT_SINGLE_SLASH</name></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>PsqlScanState</name></type> <name>scan_state</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>ConditionalStack</name></type> <name>cond_stack</name></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><name><name>pset</name><operator>.</operator><name>echo</name></name> <operator>==</operator> <name>PSQL_ECHO_ALL</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>puts</name><argument_list>(<argument><expr><name><name>cell</name><operator>-&gt;</operator><name>val</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

				<expr_stmt><expr><name>scan_state</name> <operator>=</operator> <call><name>psql_scan_create</name><argument_list>(<argument><expr><operator>&amp;</operator><name>psqlscan_callbacks</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>psql_scan_setup</name><argument_list>(<argument><expr><name>scan_state</name></expr></argument>,
								<argument><expr><name><name>cell</name><operator>-&gt;</operator><name>val</name></name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name><name>cell</name><operator>-&gt;</operator><name>val</name></name></expr></argument>)</argument_list></call></expr></argument>,
								<argument><expr><name><name>pset</name><operator>.</operator><name>encoding</name></name></expr></argument>, <argument><expr><call><name>standard_strings</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>cond_stack</name> <operator>=</operator> <call><name>conditional_stack_create</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>psql_scan_set_passthrough</name><argument_list>(<argument><expr><name>scan_state</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>cond_stack</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><name>successResult</name> <operator>=</operator> <ternary><condition><expr><call><name>HandleSlashCmds</name><argument_list>(<argument><expr><name>scan_state</name></expr></argument>,
												<argument><expr><name>cond_stack</name></expr></argument>,
												<argument><expr><name>NULL</name></expr></argument>,
												<argument><expr><name>NULL</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>PSQL_CMD_ERROR</name></expr>
					?</condition><then> <expr><name>EXIT_SUCCESS</name></expr> </then><else>: <expr><name>EXIT_FAILURE</name></expr></else></ternary></expr>;</expr_stmt>

				<expr_stmt><expr><call><name>psql_scan_destroy</name><argument_list>(<argument><expr><name>scan_state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>conditional_stack_destroy</name><argument_list>(<argument><expr><name>cond_stack</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if>
			<if type="elseif">else if <condition>(<expr><name><name>cell</name><operator>-&gt;</operator><name>action</name></name> <operator>==</operator> <name>ACT_FILE</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>successResult</name> <operator>=</operator> <call><name>process_file</name><argument_list>(<argument><expr><name><name>cell</name><operator>-&gt;</operator><name>val</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<comment type="block">/* should never come here */</comment>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>

			<if_stmt><if>if <condition>(<expr><name>successResult</name> <operator>!=</operator> <name>EXIT_SUCCESS</name> <operator>&amp;&amp;</operator> <name><name>pset</name><operator>.</operator><name>on_error_stop</name></name></expr>)</condition><block type="pseudo"><block_content>
				<break>break;</break></block_content></block></if></if_stmt>
		</block_content>}</block></for>

		<if_stmt><if>if <condition>(<expr><name><name>options</name><operator>.</operator><name>single_txn</name></name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><operator>(</operator><name>res</name> <operator>=</operator> <call><name>PSQLexec</name><argument_list>(<argument><expr><literal type="string">"COMMIT"</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name><name>pset</name><operator>.</operator><name>on_error_stop</name></name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name>successResult</name> <operator>=</operator> <name>EXIT_USER</name></expr>;</expr_stmt>
					<goto>goto <name>error</name>;</goto>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
		</block_content>}</block></if></if_stmt>

<label><name>error</name>:</label>
		<empty_stmt>;</empty_stmt>
	</block_content>}</block></if>

	<comment type="block">/*
	 * or otherwise enter interactive main loop
	 */</comment>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>connection_warnings</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>pset</name><operator>.</operator><name>quiet</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Type \"help\" for help.\n\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>initializeInput</name><argument_list>(<argument><expr><ternary><condition><expr><name><name>options</name><operator>.</operator><name>no_readline</name></name></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><literal type="number">1</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>successResult</name> <operator>=</operator> <call><name>MainLoop</name><argument_list>(<argument><expr><name>stdin</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/* clean up */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>pset</name><operator>.</operator><name>logfile</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>fclose</name><argument_list>(<argument><expr><name><name>pset</name><operator>.</operator><name>logfile</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><call><name>PQfinish</name><argument_list>(<argument><expr><name><name>pset</name><operator>.</operator><name>db</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>setQFout</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>successResult</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * Parse command line options
 */</comment>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>parse_psql_options</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name><name>argv</name><index>[]</index></name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>adhoc_opts</name></name> <modifier>*</modifier></type><name>options</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>static</specifier> <name><name>struct</name> <name>option</name></name></type> <name><name>long_options</name><index>[]</index></name> <init>=
	<expr><block>{
		<expr><block>{<expr><literal type="string">"echo-all"</literal></expr>, <expr><name>no_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="char">'a'</literal></expr>}</block></expr>,
		<expr><block>{<expr><literal type="string">"no-align"</literal></expr>, <expr><name>no_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="char">'A'</literal></expr>}</block></expr>,
		<expr><block>{<expr><literal type="string">"command"</literal></expr>, <expr><name>required_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="char">'c'</literal></expr>}</block></expr>,
		<expr><block>{<expr><literal type="string">"dbname"</literal></expr>, <expr><name>required_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="char">'d'</literal></expr>}</block></expr>,
		<expr><block>{<expr><literal type="string">"echo-queries"</literal></expr>, <expr><name>no_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="char">'e'</literal></expr>}</block></expr>,
		<expr><block>{<expr><literal type="string">"echo-errors"</literal></expr>, <expr><name>no_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="char">'b'</literal></expr>}</block></expr>,
		<expr><block>{<expr><literal type="string">"echo-hidden"</literal></expr>, <expr><name>no_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="char">'E'</literal></expr>}</block></expr>,
		<expr><block>{<expr><literal type="string">"file"</literal></expr>, <expr><name>required_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="char">'f'</literal></expr>}</block></expr>,
		<expr><block>{<expr><literal type="string">"field-separator"</literal></expr>, <expr><name>required_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="char">'F'</literal></expr>}</block></expr>,
		<expr><block>{<expr><literal type="string">"field-separator-zero"</literal></expr>, <expr><name>no_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="char">'z'</literal></expr>}</block></expr>,
		<expr><block>{<expr><literal type="string">"host"</literal></expr>, <expr><name>required_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="char">'h'</literal></expr>}</block></expr>,
		<expr><block>{<expr><literal type="string">"html"</literal></expr>, <expr><name>no_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="char">'H'</literal></expr>}</block></expr>,
		<expr><block>{<expr><literal type="string">"list"</literal></expr>, <expr><name>no_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="char">'l'</literal></expr>}</block></expr>,
		<expr><block>{<expr><literal type="string">"log-file"</literal></expr>, <expr><name>required_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="char">'L'</literal></expr>}</block></expr>,
		<expr><block>{<expr><literal type="string">"no-readline"</literal></expr>, <expr><name>no_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="char">'n'</literal></expr>}</block></expr>,
		<expr><block>{<expr><literal type="string">"single-transaction"</literal></expr>, <expr><name>no_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="char">'1'</literal></expr>}</block></expr>,
		<expr><block>{<expr><literal type="string">"output"</literal></expr>, <expr><name>required_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="char">'o'</literal></expr>}</block></expr>,
		<comment type="block">/* POLAR */</comment>
		<expr><block>{<expr><literal type="string">"replicaoutput"</literal></expr>, <expr><name>required_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="char">'O'</literal></expr>}</block></expr>,
		<expr><block>{<expr><literal type="string">"port"</literal></expr>, <expr><name>required_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="char">'p'</literal></expr>}</block></expr>,
		<expr><block>{<expr><literal type="string">"pset"</literal></expr>, <expr><name>required_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="char">'P'</literal></expr>}</block></expr>,
		<expr><block>{<expr><literal type="string">"quiet"</literal></expr>, <expr><name>no_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="char">'q'</literal></expr>}</block></expr>,
		<expr><block>{<expr><literal type="string">"record-separator"</literal></expr>, <expr><name>required_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="char">'R'</literal></expr>}</block></expr>,
		<expr><block>{<expr><literal type="string">"record-separator-zero"</literal></expr>, <expr><name>no_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="char">'0'</literal></expr>}</block></expr>,
		<expr><block>{<expr><literal type="string">"single-step"</literal></expr>, <expr><name>no_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="char">'s'</literal></expr>}</block></expr>,
		<expr><block>{<expr><literal type="string">"single-line"</literal></expr>, <expr><name>no_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="char">'S'</literal></expr>}</block></expr>,
		<expr><block>{<expr><literal type="string">"tuples-only"</literal></expr>, <expr><name>no_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="char">'t'</literal></expr>}</block></expr>,
		<expr><block>{<expr><literal type="string">"table-attr"</literal></expr>, <expr><name>required_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="char">'T'</literal></expr>}</block></expr>,
		<expr><block>{<expr><literal type="string">"username"</literal></expr>, <expr><name>required_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="char">'U'</literal></expr>}</block></expr>,
		<expr><block>{<expr><literal type="string">"set"</literal></expr>, <expr><name>required_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="char">'v'</literal></expr>}</block></expr>,
		<expr><block>{<expr><literal type="string">"variable"</literal></expr>, <expr><name>required_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="char">'v'</literal></expr>}</block></expr>,
		<expr><block>{<expr><literal type="string">"version"</literal></expr>, <expr><name>no_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="char">'V'</literal></expr>}</block></expr>,
		<expr><block>{<expr><literal type="string">"no-password"</literal></expr>, <expr><name>no_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="char">'w'</literal></expr>}</block></expr>,
		<expr><block>{<expr><literal type="string">"password"</literal></expr>, <expr><name>no_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="char">'W'</literal></expr>}</block></expr>,
		<expr><block>{<expr><literal type="string">"expanded"</literal></expr>, <expr><name>no_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="char">'x'</literal></expr>}</block></expr>,
		<expr><block>{<expr><literal type="string">"no-psqlrc"</literal></expr>, <expr><name>no_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="char">'X'</literal></expr>}</block></expr>,
		<expr><block>{<expr><literal type="string">"help"</literal></expr>, <expr><name>optional_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="number">1</literal></expr>}</block></expr>,
		<expr><block>{<expr><name>NULL</name></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>NULL</name></expr>, <expr><literal type="number">0</literal></expr>}</block></expr>
	}</block></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>int</name></type>			<name>optindex</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>c</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>options</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof <name/></sizeof>*<name>options</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<while>while <condition>(<expr><operator>(</operator><name>c</name> <operator>=</operator> <call><name>getopt_long</name><argument_list>(<argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>, <argument><expr><literal type="string">"aAbc:d:eEf:F:h:HlL:no:O:p:P:qR:sStT:U:v:VwWxXz?01"</literal></expr></argument>,
							<argument><expr><name>long_options</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>optindex</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<switch>switch <condition>(<expr><name>c</name></expr>)</condition>
		<block>{<block_content>
			<case>case <expr><literal type="char">'a'</literal></expr>:</case>
				<expr_stmt><expr><call><name>SetVariable</name><argument_list>(<argument><expr><name><name>pset</name><operator>.</operator><name>vars</name></name></expr></argument>, <argument><expr><literal type="string">"ECHO"</literal></expr></argument>, <argument><expr><literal type="string">"all"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><literal type="char">'A'</literal></expr>:</case>
				<expr_stmt><expr><name><name>pset</name><operator>.</operator><name>popt</name><operator>.</operator><name>topt</name><operator>.</operator><name>format</name></name> <operator>=</operator> <name>PRINT_UNALIGNED</name></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><literal type="char">'b'</literal></expr>:</case>
				<expr_stmt><expr><call><name>SetVariable</name><argument_list>(<argument><expr><name><name>pset</name><operator>.</operator><name>vars</name></name></expr></argument>, <argument><expr><literal type="string">"ECHO"</literal></expr></argument>, <argument><expr><literal type="string">"errors"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><literal type="char">'c'</literal></expr>:</case>
				<if_stmt><if>if <condition>(<expr><name><name>optarg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'\\'</literal></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>simple_action_list_append</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>options</name><operator>-&gt;</operator><name>actions</name></name></expr></argument>,
											  <argument><expr><name>ACT_SINGLE_SLASH</name></expr></argument>,
											  <argument><expr><name>optarg</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>simple_action_list_append</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>options</name><operator>-&gt;</operator><name>actions</name></name></expr></argument>,
											  <argument><expr><name>ACT_SINGLE_QUERY</name></expr></argument>,
											  <argument><expr><name>optarg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
				<break>break;</break>
			<case>case <expr><literal type="char">'d'</literal></expr>:</case>
				<expr_stmt><expr><name><name>options</name><operator>-&gt;</operator><name>dbname</name></name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><name>optarg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><literal type="char">'e'</literal></expr>:</case>
				<expr_stmt><expr><call><name>SetVariable</name><argument_list>(<argument><expr><name><name>pset</name><operator>.</operator><name>vars</name></name></expr></argument>, <argument><expr><literal type="string">"ECHO"</literal></expr></argument>, <argument><expr><literal type="string">"queries"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><literal type="char">'E'</literal></expr>:</case>
				<expr_stmt><expr><call><name>SetVariableBool</name><argument_list>(<argument><expr><name><name>pset</name><operator>.</operator><name>vars</name></name></expr></argument>, <argument><expr><literal type="string">"ECHO_HIDDEN"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><literal type="char">'f'</literal></expr>:</case>
				<expr_stmt><expr><call><name>simple_action_list_append</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>options</name><operator>-&gt;</operator><name>actions</name></name></expr></argument>,
										  <argument><expr><name>ACT_FILE</name></expr></argument>,
										  <argument><expr><name>optarg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><literal type="char">'F'</literal></expr>:</case>
				<expr_stmt><expr><name><name>pset</name><operator>.</operator><name>popt</name><operator>.</operator><name>topt</name><operator>.</operator><name>fieldSep</name><operator>.</operator><name>separator</name></name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><name>optarg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>pset</name><operator>.</operator><name>popt</name><operator>.</operator><name>topt</name><operator>.</operator><name>fieldSep</name><operator>.</operator><name>separator_zero</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><literal type="char">'h'</literal></expr>:</case>
				<expr_stmt><expr><name><name>options</name><operator>-&gt;</operator><name>host</name></name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><name>optarg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><literal type="char">'H'</literal></expr>:</case>
				<expr_stmt><expr><name><name>pset</name><operator>.</operator><name>popt</name><operator>.</operator><name>topt</name><operator>.</operator><name>format</name></name> <operator>=</operator> <name>PRINT_HTML</name></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><literal type="char">'l'</literal></expr>:</case>
				<expr_stmt><expr><name><name>options</name><operator>-&gt;</operator><name>list_dbs</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><literal type="char">'L'</literal></expr>:</case>
				<expr_stmt><expr><name><name>options</name><operator>-&gt;</operator><name>logfilename</name></name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><name>optarg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><literal type="char">'n'</literal></expr>:</case>
				<expr_stmt><expr><name><name>options</name><operator>-&gt;</operator><name>no_readline</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><literal type="char">'o'</literal></expr>:</case>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>setQFout</name><argument_list>(<argument><expr><name>optarg</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><name>EXIT_FAILURE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<break>break;</break>
			<comment type="block">/* POLAR: replica out file */</comment>
			<case>case <expr><literal type="char">'O'</literal></expr>:</case>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>polar_set_replica_fout</name><argument_list>(<argument><expr><name>optarg</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><name>EXIT_FAILURE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<break>break;</break>
			<comment type="block">/* POLAR end */</comment>
			<case>case <expr><literal type="char">'p'</literal></expr>:</case>
				<expr_stmt><expr><name><name>options</name><operator>-&gt;</operator><name>port</name></name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><name>optarg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><literal type="char">'P'</literal></expr>:</case>
				<block>{<block_content>
					<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>value</name></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>equal_loc</name></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>bool</name></type>		<name>result</name></decl>;</decl_stmt>

					<expr_stmt><expr><name>value</name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><name>optarg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>equal_loc</name> <operator>=</operator> <call><name>strchr</name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr><literal type="char">'='</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<if_stmt><if>if <condition>(<expr><operator>!</operator><name>equal_loc</name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>do_pset</name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pset</name><operator>.</operator><name>popt</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
					<else>else
					<block>{<block_content>
						<expr_stmt><expr><operator>*</operator><name>equal_loc</name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
						<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>do_pset</name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr><name>equal_loc</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pset</name><operator>.</operator><name>popt</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block></else></if_stmt>

					<if_stmt><if>if <condition>(<expr><operator>!</operator><name>result</name></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: could not set printing parameter \"%s\"\n"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>pset</name><operator>.</operator><name>progname</name></name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><name>EXIT_FAILURE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block></if></if_stmt>

					<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<break>break;</break>
				</block_content>}</block>
			<case>case <expr><literal type="char">'q'</literal></expr>:</case>
				<expr_stmt><expr><call><name>SetVariableBool</name><argument_list>(<argument><expr><name><name>pset</name><operator>.</operator><name>vars</name></name></expr></argument>, <argument><expr><literal type="string">"QUIET"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><literal type="char">'R'</literal></expr>:</case>
				<expr_stmt><expr><name><name>pset</name><operator>.</operator><name>popt</name><operator>.</operator><name>topt</name><operator>.</operator><name>recordSep</name><operator>.</operator><name>separator</name></name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><name>optarg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>pset</name><operator>.</operator><name>popt</name><operator>.</operator><name>topt</name><operator>.</operator><name>recordSep</name><operator>.</operator><name>separator_zero</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><literal type="char">'s'</literal></expr>:</case>
				<expr_stmt><expr><call><name>SetVariableBool</name><argument_list>(<argument><expr><name><name>pset</name><operator>.</operator><name>vars</name></name></expr></argument>, <argument><expr><literal type="string">"SINGLESTEP"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><literal type="char">'S'</literal></expr>:</case>
				<expr_stmt><expr><call><name>SetVariableBool</name><argument_list>(<argument><expr><name><name>pset</name><operator>.</operator><name>vars</name></name></expr></argument>, <argument><expr><literal type="string">"SINGLELINE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><literal type="char">'t'</literal></expr>:</case>
				<expr_stmt><expr><name><name>pset</name><operator>.</operator><name>popt</name><operator>.</operator><name>topt</name><operator>.</operator><name>tuples_only</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><literal type="char">'T'</literal></expr>:</case>
				<expr_stmt><expr><name><name>pset</name><operator>.</operator><name>popt</name><operator>.</operator><name>topt</name><operator>.</operator><name>tableAttr</name></name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><name>optarg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><literal type="char">'U'</literal></expr>:</case>
				<expr_stmt><expr><name><name>options</name><operator>-&gt;</operator><name>username</name></name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><name>optarg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><literal type="char">'v'</literal></expr>:</case>
				<block>{<block_content>
					<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>value</name></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>equal_loc</name></decl>;</decl_stmt>

					<expr_stmt><expr><name>value</name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><name>optarg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>equal_loc</name> <operator>=</operator> <call><name>strchr</name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr><literal type="char">'='</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<if_stmt><if>if <condition>(<expr><operator>!</operator><name>equal_loc</name></expr>)</condition>
					<block>{<block_content>
						<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>DeleteVariable</name><argument_list>(<argument><expr><name><name>pset</name><operator>.</operator><name>vars</name></name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
							<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><name>EXIT_FAILURE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt> <comment type="block">/* error already printed */</comment>
					</block_content>}</block></if>
					<else>else
					<block>{<block_content>
						<expr_stmt><expr><operator>*</operator><name>equal_loc</name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
						<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>SetVariable</name><argument_list>(<argument><expr><name><name>pset</name><operator>.</operator><name>vars</name></name></expr></argument>, <argument><expr><name>value</name></expr></argument>, <argument><expr><name>equal_loc</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
							<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><name>EXIT_FAILURE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt> <comment type="block">/* error already printed */</comment>
					</block_content>}</block></else></if_stmt>

					<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<break>break;</break>
				</block_content>}</block>
			<case>case <expr><literal type="char">'V'</literal></expr>:</case>
				<expr_stmt><expr><call><name>showVersion</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><name>EXIT_SUCCESS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<case>case <expr><literal type="char">'w'</literal></expr>:</case>
				<expr_stmt><expr><name><name>pset</name><operator>.</operator><name>getPassword</name></name> <operator>=</operator> <name>TRI_NO</name></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><literal type="char">'W'</literal></expr>:</case>
				<expr_stmt><expr><name><name>pset</name><operator>.</operator><name>getPassword</name></name> <operator>=</operator> <name>TRI_YES</name></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><literal type="char">'x'</literal></expr>:</case>
				<expr_stmt><expr><name><name>pset</name><operator>.</operator><name>popt</name><operator>.</operator><name>topt</name><operator>.</operator><name>expanded</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><literal type="char">'X'</literal></expr>:</case>
				<expr_stmt><expr><name><name>options</name><operator>-&gt;</operator><name>no_psqlrc</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><literal type="char">'z'</literal></expr>:</case>
				<expr_stmt><expr><name><name>pset</name><operator>.</operator><name>popt</name><operator>.</operator><name>topt</name><operator>.</operator><name>fieldSep</name><operator>.</operator><name>separator_zero</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><literal type="char">'0'</literal></expr>:</case>
				<expr_stmt><expr><name><name>pset</name><operator>.</operator><name>popt</name><operator>.</operator><name>topt</name><operator>.</operator><name>recordSep</name><operator>.</operator><name>separator_zero</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><literal type="char">'1'</literal></expr>:</case>
				<expr_stmt><expr><name><name>options</name><operator>-&gt;</operator><name>single_txn</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><literal type="char">'?'</literal></expr>:</case>
				<if_stmt><if>if <condition>(<expr><name>optind</name> <operator>&lt;=</operator> <name>argc</name> <operator>&amp;&amp;</operator>
					<call><name>strcmp</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><name>optind</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"-?"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/* actual help option given */</comment>
					<expr_stmt><expr><call><name>usage</name><argument_list>(<argument><expr><name>NOPAGER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><name>EXIT_SUCCESS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if>
				<else>else
				<block>{<block_content>
					<comment type="block">/* getopt error (unknown option or missing argument) */</comment>
					<goto>goto <name>unknown_option</name>;</goto>
				</block_content>}</block></else></if_stmt>
				<break>break;</break>
			<case>case <expr><literal type="number">1</literal></expr>:</case>
				<block>{<block_content>
					<if_stmt><if>if <condition>(<expr><operator>!</operator><name>optarg</name> <operator>||</operator> <call><name>strcmp</name><argument_list>(<argument><expr><name>optarg</name></expr></argument>, <argument><expr><literal type="string">"options"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>usage</name><argument_list>(<argument><expr><name>NOPAGER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
					<if type="elseif">else if <condition>(<expr><name>optarg</name> <operator>&amp;&amp;</operator> <call><name>strcmp</name><argument_list>(<argument><expr><name>optarg</name></expr></argument>, <argument><expr><literal type="string">"commands"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>slashUsage</name><argument_list>(<argument><expr><name>NOPAGER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
					<if type="elseif">else if <condition>(<expr><name>optarg</name> <operator>&amp;&amp;</operator> <call><name>strcmp</name><argument_list>(<argument><expr><name>optarg</name></expr></argument>, <argument><expr><literal type="string">"variables"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>helpVariables</name><argument_list>(<argument><expr><name>NOPAGER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
					<else>else<block type="pseudo"><block_content>
						<goto>goto <name>unknown_option</name>;</goto></block_content></block></else></if_stmt>

					<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><name>EXIT_SUCCESS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block>
				<break>break;</break>
			<default>default:</default>
		<label><name>unknown_option</name>:</label>
				<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Try \"%s --help\" for more information.\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
						<argument><expr><name><name>pset</name><operator>.</operator><name>progname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><name>EXIT_FAILURE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
		</block_content>}</block></switch>
	</block_content>}</block></while>

	<comment type="block">/*
	 * if we still have arguments, use it as the database name and username
	 */</comment>
	<while>while <condition>(<expr><name>argc</name> <operator>-</operator> <name>optind</name> <operator>&gt;=</operator> <literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>options</name><operator>-&gt;</operator><name>dbname</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>options</name><operator>-&gt;</operator><name>dbname</name></name> <operator>=</operator> <name><name>argv</name><index>[<expr><name>optind</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><operator>!</operator><name><name>options</name><operator>-&gt;</operator><name>username</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>options</name><operator>-&gt;</operator><name>username</name></name> <operator>=</operator> <name><name>argv</name><index>[<expr><name>optind</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><operator>!</operator><name><name>pset</name><operator>.</operator><name>quiet</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: warning: extra command-line argument \"%s\" ignored\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
					<argument><expr><name><name>pset</name><operator>.</operator><name>progname</name></name></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><name>optind</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>optind</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block></while>
</block_content>}</block></function>


<comment type="block">/*
 * Append a new item to the end of the SimpleActionList.
 * Note that "val" is copied if it's not NULL.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>simple_action_list_append</name><parameter_list>(<parameter><decl><type><name>SimpleActionList</name> <modifier>*</modifier></type><name>list</name></decl></parameter>,
						  <parameter><decl><type><name><name>enum</name> <name>_actions</name></name></type> <name>action</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>val</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>SimpleActionListCell</name> <modifier>*</modifier></type><name>cell</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>cell</name> <operator>=</operator> <operator>(</operator><name>SimpleActionListCell</name> <operator>*</operator><operator>)</operator> <call><name>pg_malloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>SimpleActionListCell</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>cell</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>cell</name><operator>-&gt;</operator><name>action</name></name> <operator>=</operator> <name>action</name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>val</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>cell</name><operator>-&gt;</operator><name>val</name></name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>cell</name><operator>-&gt;</operator><name>val</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>list</name><operator>-&gt;</operator><name>tail</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>list</name><operator>-&gt;</operator><name>tail</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name>cell</name></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>list</name><operator>-&gt;</operator><name>head</name></name> <operator>=</operator> <name>cell</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
	<expr_stmt><expr><name><name>list</name><operator>-&gt;</operator><name>tail</name></name> <operator>=</operator> <name>cell</name></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * Load .psqlrc file, if found.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>process_psqlrc</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>argv0</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>home</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>rc_file</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>my_exec_path</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>etc_path</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>envrc</name> <init>= <expr><call><name>getenv</name><argument_list>(<argument><expr><literal type="string">"PSQLRC"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>find_my_exec</name><argument_list>(<argument><expr><name>argv0</name></expr></argument>, <argument><expr><name>my_exec_path</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: could not find own program executable\n"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>argv0</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><name>EXIT_FAILURE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>get_etc_path</name><argument_list>(<argument><expr><name>my_exec_path</name></expr></argument>, <argument><expr><name>etc_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>rc_file</name></expr></argument>, <argument><expr><name>MAXPGPATH</name></expr></argument>, <argument><expr><literal type="string">"%s/%s"</literal></expr></argument>, <argument><expr><name>etc_path</name></expr></argument>, <argument><expr><name>SYSPSQLRC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>process_psqlrc_file</name><argument_list>(<argument><expr><name>rc_file</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>envrc</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>envrc</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* might need to free() this */</comment>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>envrc_alloc</name> <init>= <expr><call><name>pstrdup</name><argument_list>(<argument><expr><name>envrc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>expand_tilde</name><argument_list>(<argument><expr><operator>&amp;</operator><name>envrc_alloc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>process_psqlrc_file</name><argument_list>(<argument><expr><name>envrc_alloc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>get_home_path</name><argument_list>(<argument><expr><name>home</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>rc_file</name></expr></argument>, <argument><expr><name>MAXPGPATH</name></expr></argument>, <argument><expr><literal type="string">"%s/%s"</literal></expr></argument>, <argument><expr><name>home</name></expr></argument>, <argument><expr><name>PSQLRC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>process_psqlrc_file</name><argument_list>(<argument><expr><name>rc_file</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>



<function><type><specifier>static</specifier> <name>void</name></type>
<name>process_psqlrc_file</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>filename</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>psqlrc_minor</name></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name>psqlrc_major</name></decl>;</decl_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>WIN32</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>(</operator><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>__MINGW32__</name></expr></argument>)</argument_list></call><operator>)</operator></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>R_OK</name></cpp:macro> <cpp:value>4</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<expr_stmt><expr><name>psqlrc_minor</name> <operator>=</operator> <call><name>psprintf</name><argument_list>(<argument><expr><literal type="string">"%s-%s"</literal></expr></argument>, <argument><expr><name>filename</name></expr></argument>, <argument><expr><name>PG_VERSION</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>psqlrc_major</name> <operator>=</operator> <call><name>psprintf</name><argument_list>(<argument><expr><literal type="string">"%s-%s"</literal></expr></argument>, <argument><expr><name>filename</name></expr></argument>, <argument><expr><name>PG_MAJORVERSION</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* check for minor version first, then major, then no version */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>access</name><argument_list>(<argument><expr><name>psqlrc_minor</name></expr></argument>, <argument><expr><name>R_OK</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>process_file</name><argument_list>(<argument><expr><name>psqlrc_minor</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>access</name><argument_list>(<argument><expr><name>psqlrc_major</name></expr></argument>, <argument><expr><name>R_OK</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>process_file</name><argument_list>(<argument><expr><name>psqlrc_major</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>access</name><argument_list>(<argument><expr><name>filename</name></expr></argument>, <argument><expr><name>R_OK</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>process_file</name><argument_list>(<argument><expr><name>filename</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>psqlrc_minor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>psqlrc_major</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>



<comment type="block">/* showVersion
 *
 * This output format is intended to match GNU standards.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>showVersion</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>puts</name><argument_list>(<argument><expr><literal type="string">"psql (PostgreSQL) "</literal> <name>PG_VERSION</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>



<comment type="block">/*
 * Substitute hooks and assign hooks for psql variables.
 *
 * This isn't an amazingly good place for them, but neither is anywhere else.
 *
 * By policy, every special variable that controls any psql behavior should
 * have one or both hooks, even if they're just no-ops.  This ensures that
 * the variable will remain present in variables.c's list even when unset,
 * which ensures that it's known to tab completion.
 */</comment>

<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type>
<name>bool_substitute_hook</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>newval</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>newval</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* "\unset FOO" becomes "\set FOO off" */</comment>
		<expr_stmt><expr><name>newval</name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><literal type="string">"off"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name><name>newval</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'\0'</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* "\set FOO" becomes "\set FOO on" */</comment>
		<expr_stmt><expr><call><name>pg_free</name><argument_list>(<argument><expr><name>newval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>newval</name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><literal type="string">"on"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><name>newval</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>autocommit_hook</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>newval</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>ParseVariableBool</name><argument_list>(<argument><expr><name>newval</name></expr></argument>, <argument><expr><literal type="string">"AUTOCOMMIT"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pset</name><operator>.</operator><name>autocommit</name></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>on_error_stop_hook</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>newval</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>ParseVariableBool</name><argument_list>(<argument><expr><name>newval</name></expr></argument>, <argument><expr><literal type="string">"ON_ERROR_STOP"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pset</name><operator>.</operator><name>on_error_stop</name></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>quiet_hook</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>newval</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>ParseVariableBool</name><argument_list>(<argument><expr><name>newval</name></expr></argument>, <argument><expr><literal type="string">"QUIET"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pset</name><operator>.</operator><name>quiet</name></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>singleline_hook</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>newval</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>ParseVariableBool</name><argument_list>(<argument><expr><name>newval</name></expr></argument>, <argument><expr><literal type="string">"SINGLELINE"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pset</name><operator>.</operator><name>singleline</name></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>singlestep_hook</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>newval</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>ParseVariableBool</name><argument_list>(<argument><expr><name>newval</name></expr></argument>, <argument><expr><literal type="string">"SINGLESTEP"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pset</name><operator>.</operator><name>singlestep</name></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type>
<name>fetch_count_substitute_hook</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>newval</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>newval</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>newval</name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><literal type="string">"0"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<return>return <expr><name>newval</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>fetch_count_hook</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>newval</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>ParseVariableNum</name><argument_list>(<argument><expr><name>newval</name></expr></argument>, <argument><expr><literal type="string">"FETCH_COUNT"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pset</name><operator>.</operator><name>fetch_count</name></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>histfile_hook</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>newval</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * Someday we might try to validate the filename, but for now, this is
	 * just a placeholder to ensure HISTFILE is known to tab completion.
	 */</comment>
	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type>
<name>histsize_substitute_hook</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>newval</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>newval</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>newval</name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><literal type="string">"500"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<return>return <expr><name>newval</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>histsize_hook</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>newval</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>ParseVariableNum</name><argument_list>(<argument><expr><name>newval</name></expr></argument>, <argument><expr><literal type="string">"HISTSIZE"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pset</name><operator>.</operator><name>histsize</name></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type>
<name>ignoreeof_substitute_hook</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>newval</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>dummy</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * This tries to mimic the behavior of bash, to wit "If set, the value is
	 * the number of consecutive EOF characters which must be typed as the
	 * first characters on an input line before bash exits.  If the variable
	 * exists but does not have a numeric value, or has no value, the default
	 * value is 10.  If it does not exist, EOF signifies the end of input to
	 * the shell."  Unlike bash, however, we insist on the stored value
	 * actually being a valid integer.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>newval</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>newval</name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><literal type="string">"0"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>ParseVariableNum</name><argument_list>(<argument><expr><name>newval</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>dummy</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>newval</name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><literal type="string">"10"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<return>return <expr><name>newval</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>ignoreeof_hook</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>newval</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>ParseVariableNum</name><argument_list>(<argument><expr><name>newval</name></expr></argument>, <argument><expr><literal type="string">"IGNOREEOF"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pset</name><operator>.</operator><name>ignoreeof</name></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type>
<name>echo_substitute_hook</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>newval</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>newval</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>newval</name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><literal type="string">"none"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<return>return <expr><name>newval</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>echo_hook</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>newval</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>newval</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>		<comment type="block">/* else substitute hook messed up */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>pg_strcasecmp</name><argument_list>(<argument><expr><name>newval</name></expr></argument>, <argument><expr><literal type="string">"queries"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>pset</name><operator>.</operator><name>echo</name></name> <operator>=</operator> <name>PSQL_ECHO_QUERIES</name></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>pg_strcasecmp</name><argument_list>(<argument><expr><name>newval</name></expr></argument>, <argument><expr><literal type="string">"errors"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>pset</name><operator>.</operator><name>echo</name></name> <operator>=</operator> <name>PSQL_ECHO_ERRORS</name></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>pg_strcasecmp</name><argument_list>(<argument><expr><name>newval</name></expr></argument>, <argument><expr><literal type="string">"all"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>pset</name><operator>.</operator><name>echo</name></name> <operator>=</operator> <name>PSQL_ECHO_ALL</name></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>pg_strcasecmp</name><argument_list>(<argument><expr><name>newval</name></expr></argument>, <argument><expr><literal type="string">"none"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>pset</name><operator>.</operator><name>echo</name></name> <operator>=</operator> <name>PSQL_ECHO_NONE</name></expr>;</expr_stmt></block_content></block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>PsqlVarEnumError</name><argument_list>(<argument><expr><literal type="string">"ECHO"</literal></expr></argument>, <argument><expr><name>newval</name></expr></argument>, <argument><expr><literal type="string">"none, errors, queries, all"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></else></if_stmt>
	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>echo_hidden_hook</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>newval</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>newval</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>		<comment type="block">/* else substitute hook messed up */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>pg_strcasecmp</name><argument_list>(<argument><expr><name>newval</name></expr></argument>, <argument><expr><literal type="string">"noexec"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>pset</name><operator>.</operator><name>echo_hidden</name></name> <operator>=</operator> <name>PSQL_ECHO_HIDDEN_NOEXEC</name></expr>;</expr_stmt></block_content></block></if>
	<else>else
	<block>{<block_content>
		<decl_stmt><decl><type><name>bool</name></type>		<name>on_off</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>ParseVariableBool</name><argument_list>(<argument><expr><name>newval</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>on_off</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>pset</name><operator>.</operator><name>echo_hidden</name></name> <operator>=</operator> <ternary><condition><expr><name>on_off</name></expr> ?</condition><then> <expr><name>PSQL_ECHO_HIDDEN_ON</name></expr> </then><else>: <expr><name>PSQL_ECHO_HIDDEN_OFF</name></expr></else></ternary></expr>;</expr_stmt></block_content></block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><call><name>PsqlVarEnumError</name><argument_list>(<argument><expr><literal type="string">"ECHO_HIDDEN"</literal></expr></argument>, <argument><expr><name>newval</name></expr></argument>, <argument><expr><literal type="string">"on, off, noexec"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>false</name></expr>;</return>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></else></if_stmt>
	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>on_error_rollback_hook</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>newval</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>newval</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>		<comment type="block">/* else substitute hook messed up */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>pg_strcasecmp</name><argument_list>(<argument><expr><name>newval</name></expr></argument>, <argument><expr><literal type="string">"interactive"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>pset</name><operator>.</operator><name>on_error_rollback</name></name> <operator>=</operator> <name>PSQL_ERROR_ROLLBACK_INTERACTIVE</name></expr>;</expr_stmt></block_content></block></if>
	<else>else
	<block>{<block_content>
		<decl_stmt><decl><type><name>bool</name></type>		<name>on_off</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>ParseVariableBool</name><argument_list>(<argument><expr><name>newval</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>on_off</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>pset</name><operator>.</operator><name>on_error_rollback</name></name> <operator>=</operator> <ternary><condition><expr><name>on_off</name></expr> ?</condition><then> <expr><name>PSQL_ERROR_ROLLBACK_ON</name></expr> </then><else>: <expr><name>PSQL_ERROR_ROLLBACK_OFF</name></expr></else></ternary></expr>;</expr_stmt></block_content></block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><call><name>PsqlVarEnumError</name><argument_list>(<argument><expr><literal type="string">"ON_ERROR_ROLLBACK"</literal></expr></argument>, <argument><expr><name>newval</name></expr></argument>, <argument><expr><literal type="string">"on, off, interactive"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>false</name></expr>;</return>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></else></if_stmt>
	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type>
<name>comp_keyword_case_substitute_hook</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>newval</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>newval</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>newval</name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><literal type="string">"preserve-upper"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<return>return <expr><name>newval</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>comp_keyword_case_hook</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>newval</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>newval</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>		<comment type="block">/* else substitute hook messed up */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>pg_strcasecmp</name><argument_list>(<argument><expr><name>newval</name></expr></argument>, <argument><expr><literal type="string">"preserve-upper"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>pset</name><operator>.</operator><name>comp_case</name></name> <operator>=</operator> <name>PSQL_COMP_CASE_PRESERVE_UPPER</name></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>pg_strcasecmp</name><argument_list>(<argument><expr><name>newval</name></expr></argument>, <argument><expr><literal type="string">"preserve-lower"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>pset</name><operator>.</operator><name>comp_case</name></name> <operator>=</operator> <name>PSQL_COMP_CASE_PRESERVE_LOWER</name></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>pg_strcasecmp</name><argument_list>(<argument><expr><name>newval</name></expr></argument>, <argument><expr><literal type="string">"upper"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>pset</name><operator>.</operator><name>comp_case</name></name> <operator>=</operator> <name>PSQL_COMP_CASE_UPPER</name></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>pg_strcasecmp</name><argument_list>(<argument><expr><name>newval</name></expr></argument>, <argument><expr><literal type="string">"lower"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>pset</name><operator>.</operator><name>comp_case</name></name> <operator>=</operator> <name>PSQL_COMP_CASE_LOWER</name></expr>;</expr_stmt></block_content></block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>PsqlVarEnumError</name><argument_list>(<argument><expr><literal type="string">"COMP_KEYWORD_CASE"</literal></expr></argument>, <argument><expr><name>newval</name></expr></argument>,
						 <argument><expr><literal type="string">"lower, upper, preserve-lower, preserve-upper"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></else></if_stmt>
	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type>
<name>histcontrol_substitute_hook</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>newval</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>newval</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>newval</name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><literal type="string">"none"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<return>return <expr><name>newval</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>histcontrol_hook</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>newval</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>newval</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>		<comment type="block">/* else substitute hook messed up */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>pg_strcasecmp</name><argument_list>(<argument><expr><name>newval</name></expr></argument>, <argument><expr><literal type="string">"ignorespace"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>pset</name><operator>.</operator><name>histcontrol</name></name> <operator>=</operator> <name>hctl_ignorespace</name></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>pg_strcasecmp</name><argument_list>(<argument><expr><name>newval</name></expr></argument>, <argument><expr><literal type="string">"ignoredups"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>pset</name><operator>.</operator><name>histcontrol</name></name> <operator>=</operator> <name>hctl_ignoredups</name></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>pg_strcasecmp</name><argument_list>(<argument><expr><name>newval</name></expr></argument>, <argument><expr><literal type="string">"ignoreboth"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>pset</name><operator>.</operator><name>histcontrol</name></name> <operator>=</operator> <name>hctl_ignoreboth</name></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>pg_strcasecmp</name><argument_list>(<argument><expr><name>newval</name></expr></argument>, <argument><expr><literal type="string">"none"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>pset</name><operator>.</operator><name>histcontrol</name></name> <operator>=</operator> <name>hctl_none</name></expr>;</expr_stmt></block_content></block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>PsqlVarEnumError</name><argument_list>(<argument><expr><literal type="string">"HISTCONTROL"</literal></expr></argument>, <argument><expr><name>newval</name></expr></argument>,
						 <argument><expr><literal type="string">"none, ignorespace, ignoredups, ignoreboth"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></else></if_stmt>
	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>prompt1_hook</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>newval</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><name><name>pset</name><operator>.</operator><name>prompt1</name></name> <operator>=</operator> <ternary><condition><expr><name>newval</name></expr> ?</condition><then> <expr><name>newval</name></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr>;</expr_stmt>
	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>prompt2_hook</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>newval</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><name><name>pset</name><operator>.</operator><name>prompt2</name></name> <operator>=</operator> <ternary><condition><expr><name>newval</name></expr> ?</condition><then> <expr><name>newval</name></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr>;</expr_stmt>
	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>prompt3_hook</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>newval</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><name><name>pset</name><operator>.</operator><name>prompt3</name></name> <operator>=</operator> <ternary><condition><expr><name>newval</name></expr> ?</condition><then> <expr><name>newval</name></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr>;</expr_stmt>
	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type>
<name>verbosity_substitute_hook</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>newval</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>newval</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>newval</name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><literal type="string">"default"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<return>return <expr><name>newval</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>verbosity_hook</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>newval</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>newval</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>		<comment type="block">/* else substitute hook messed up */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>pg_strcasecmp</name><argument_list>(<argument><expr><name>newval</name></expr></argument>, <argument><expr><literal type="string">"default"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>pset</name><operator>.</operator><name>verbosity</name></name> <operator>=</operator> <name>PQERRORS_DEFAULT</name></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>pg_strcasecmp</name><argument_list>(<argument><expr><name>newval</name></expr></argument>, <argument><expr><literal type="string">"terse"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>pset</name><operator>.</operator><name>verbosity</name></name> <operator>=</operator> <name>PQERRORS_TERSE</name></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>pg_strcasecmp</name><argument_list>(<argument><expr><name>newval</name></expr></argument>, <argument><expr><literal type="string">"verbose"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>pset</name><operator>.</operator><name>verbosity</name></name> <operator>=</operator> <name>PQERRORS_VERBOSE</name></expr>;</expr_stmt></block_content></block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>PsqlVarEnumError</name><argument_list>(<argument><expr><literal type="string">"VERBOSITY"</literal></expr></argument>, <argument><expr><name>newval</name></expr></argument>, <argument><expr><literal type="string">"default, terse, verbose"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>pset</name><operator>.</operator><name>db</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PQsetErrorVerbosity</name><argument_list>(<argument><expr><name><name>pset</name><operator>.</operator><name>db</name></name></expr></argument>, <argument><expr><name><name>pset</name><operator>.</operator><name>verbosity</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type>
<name>show_context_substitute_hook</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>newval</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>newval</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>newval</name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><literal type="string">"errors"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<return>return <expr><name>newval</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>show_context_hook</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>newval</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>newval</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>		<comment type="block">/* else substitute hook messed up */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>pg_strcasecmp</name><argument_list>(<argument><expr><name>newval</name></expr></argument>, <argument><expr><literal type="string">"never"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>pset</name><operator>.</operator><name>show_context</name></name> <operator>=</operator> <name>PQSHOW_CONTEXT_NEVER</name></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>pg_strcasecmp</name><argument_list>(<argument><expr><name>newval</name></expr></argument>, <argument><expr><literal type="string">"errors"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>pset</name><operator>.</operator><name>show_context</name></name> <operator>=</operator> <name>PQSHOW_CONTEXT_ERRORS</name></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>pg_strcasecmp</name><argument_list>(<argument><expr><name>newval</name></expr></argument>, <argument><expr><literal type="string">"always"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>pset</name><operator>.</operator><name>show_context</name></name> <operator>=</operator> <name>PQSHOW_CONTEXT_ALWAYS</name></expr>;</expr_stmt></block_content></block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>PsqlVarEnumError</name><argument_list>(<argument><expr><literal type="string">"SHOW_CONTEXT"</literal></expr></argument>, <argument><expr><name>newval</name></expr></argument>, <argument><expr><literal type="string">"never, errors, always"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>pset</name><operator>.</operator><name>db</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PQsetErrorContextVisibility</name><argument_list>(<argument><expr><name><name>pset</name><operator>.</operator><name>db</name></name></expr></argument>, <argument><expr><name><name>pset</name><operator>.</operator><name>show_context</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* POLAR px */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>sort_result_hook</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>newval</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type>		<name>on_off</name></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>newval</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>		<comment type="block">/* else substitute hook messed up */</comment>

	<if_stmt><if>if <condition>(<expr><call><name>ParseVariableBool</name><argument_list>(<argument><expr><name>newval</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>on_off</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>pset</name><operator>.</operator><name>sort_result</name></name> <operator>=</operator> <name>on_off</name></expr>;</expr_stmt></block_content></block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>PsqlVarEnumError</name><argument_list>(<argument><expr><literal type="string">"SORT_RESULT"</literal></expr></argument>, <argument><expr><name>newval</name></expr></argument>, <argument><expr><literal type="string">"off, on"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></else></if_stmt>
	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* POLAR px */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>compare_result_px_hook</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>newval</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type>		<name>on_off</name></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>newval</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>		<comment type="block">/* else substitute hook messed up */</comment>

	<if_stmt><if>if <condition>(<expr><call><name>ParseVariableBool</name><argument_list>(<argument><expr><name>newval</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>on_off</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>pset</name><operator>.</operator><name>compare_px_result</name></name> <operator>=</operator> <name>on_off</name></expr>;</expr_stmt></block_content></block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>PsqlVarEnumError</name><argument_list>(<argument><expr><literal type="string">"COMPARE_PX_RESULT"</literal></expr></argument>, <argument><expr><name>newval</name></expr></argument>, <argument><expr><literal type="string">"off, on"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></else></if_stmt>
	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>EstablishVariableSpace</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><name><name>pset</name><operator>.</operator><name>vars</name></name> <operator>=</operator> <call><name>CreateVariableSpace</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>SetVariableHooks</name><argument_list>(<argument><expr><name><name>pset</name><operator>.</operator><name>vars</name></name></expr></argument>, <argument><expr><literal type="string">"AUTOCOMMIT"</literal></expr></argument>,
					 <argument><expr><name>bool_substitute_hook</name></expr></argument>,
					 <argument><expr><name>autocommit_hook</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SetVariableHooks</name><argument_list>(<argument><expr><name><name>pset</name><operator>.</operator><name>vars</name></name></expr></argument>, <argument><expr><literal type="string">"ON_ERROR_STOP"</literal></expr></argument>,
					 <argument><expr><name>bool_substitute_hook</name></expr></argument>,
					 <argument><expr><name>on_error_stop_hook</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SetVariableHooks</name><argument_list>(<argument><expr><name><name>pset</name><operator>.</operator><name>vars</name></name></expr></argument>, <argument><expr><literal type="string">"QUIET"</literal></expr></argument>,
					 <argument><expr><name>bool_substitute_hook</name></expr></argument>,
					 <argument><expr><name>quiet_hook</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SetVariableHooks</name><argument_list>(<argument><expr><name><name>pset</name><operator>.</operator><name>vars</name></name></expr></argument>, <argument><expr><literal type="string">"SINGLELINE"</literal></expr></argument>,
					 <argument><expr><name>bool_substitute_hook</name></expr></argument>,
					 <argument><expr><name>singleline_hook</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SetVariableHooks</name><argument_list>(<argument><expr><name><name>pset</name><operator>.</operator><name>vars</name></name></expr></argument>, <argument><expr><literal type="string">"SINGLESTEP"</literal></expr></argument>,
					 <argument><expr><name>bool_substitute_hook</name></expr></argument>,
					 <argument><expr><name>singlestep_hook</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SetVariableHooks</name><argument_list>(<argument><expr><name><name>pset</name><operator>.</operator><name>vars</name></name></expr></argument>, <argument><expr><literal type="string">"FETCH_COUNT"</literal></expr></argument>,
					 <argument><expr><name>fetch_count_substitute_hook</name></expr></argument>,
					 <argument><expr><name>fetch_count_hook</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SetVariableHooks</name><argument_list>(<argument><expr><name><name>pset</name><operator>.</operator><name>vars</name></name></expr></argument>, <argument><expr><literal type="string">"HISTFILE"</literal></expr></argument>,
					 <argument><expr><name>NULL</name></expr></argument>,
					 <argument><expr><name>histfile_hook</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SetVariableHooks</name><argument_list>(<argument><expr><name><name>pset</name><operator>.</operator><name>vars</name></name></expr></argument>, <argument><expr><literal type="string">"HISTSIZE"</literal></expr></argument>,
					 <argument><expr><name>histsize_substitute_hook</name></expr></argument>,
					 <argument><expr><name>histsize_hook</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SetVariableHooks</name><argument_list>(<argument><expr><name><name>pset</name><operator>.</operator><name>vars</name></name></expr></argument>, <argument><expr><literal type="string">"IGNOREEOF"</literal></expr></argument>,
					 <argument><expr><name>ignoreeof_substitute_hook</name></expr></argument>,
					 <argument><expr><name>ignoreeof_hook</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SetVariableHooks</name><argument_list>(<argument><expr><name><name>pset</name><operator>.</operator><name>vars</name></name></expr></argument>, <argument><expr><literal type="string">"ECHO"</literal></expr></argument>,
					 <argument><expr><name>echo_substitute_hook</name></expr></argument>,
					 <argument><expr><name>echo_hook</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SetVariableHooks</name><argument_list>(<argument><expr><name><name>pset</name><operator>.</operator><name>vars</name></name></expr></argument>, <argument><expr><literal type="string">"ECHO_HIDDEN"</literal></expr></argument>,
					 <argument><expr><name>bool_substitute_hook</name></expr></argument>,
					 <argument><expr><name>echo_hidden_hook</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SetVariableHooks</name><argument_list>(<argument><expr><name><name>pset</name><operator>.</operator><name>vars</name></name></expr></argument>, <argument><expr><literal type="string">"ON_ERROR_ROLLBACK"</literal></expr></argument>,
					 <argument><expr><name>bool_substitute_hook</name></expr></argument>,
					 <argument><expr><name>on_error_rollback_hook</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SetVariableHooks</name><argument_list>(<argument><expr><name><name>pset</name><operator>.</operator><name>vars</name></name></expr></argument>, <argument><expr><literal type="string">"COMP_KEYWORD_CASE"</literal></expr></argument>,
					 <argument><expr><name>comp_keyword_case_substitute_hook</name></expr></argument>,
					 <argument><expr><name>comp_keyword_case_hook</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SetVariableHooks</name><argument_list>(<argument><expr><name><name>pset</name><operator>.</operator><name>vars</name></name></expr></argument>, <argument><expr><literal type="string">"HISTCONTROL"</literal></expr></argument>,
					 <argument><expr><name>histcontrol_substitute_hook</name></expr></argument>,
					 <argument><expr><name>histcontrol_hook</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SetVariableHooks</name><argument_list>(<argument><expr><name><name>pset</name><operator>.</operator><name>vars</name></name></expr></argument>, <argument><expr><literal type="string">"PROMPT1"</literal></expr></argument>,
					 <argument><expr><name>NULL</name></expr></argument>,
					 <argument><expr><name>prompt1_hook</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SetVariableHooks</name><argument_list>(<argument><expr><name><name>pset</name><operator>.</operator><name>vars</name></name></expr></argument>, <argument><expr><literal type="string">"PROMPT2"</literal></expr></argument>,
					 <argument><expr><name>NULL</name></expr></argument>,
					 <argument><expr><name>prompt2_hook</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SetVariableHooks</name><argument_list>(<argument><expr><name><name>pset</name><operator>.</operator><name>vars</name></name></expr></argument>, <argument><expr><literal type="string">"PROMPT3"</literal></expr></argument>,
					 <argument><expr><name>NULL</name></expr></argument>,
					 <argument><expr><name>prompt3_hook</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SetVariableHooks</name><argument_list>(<argument><expr><name><name>pset</name><operator>.</operator><name>vars</name></name></expr></argument>, <argument><expr><literal type="string">"VERBOSITY"</literal></expr></argument>,
					 <argument><expr><name>verbosity_substitute_hook</name></expr></argument>,
					 <argument><expr><name>verbosity_hook</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SetVariableHooks</name><argument_list>(<argument><expr><name><name>pset</name><operator>.</operator><name>vars</name></name></expr></argument>, <argument><expr><literal type="string">"SHOW_CONTEXT"</literal></expr></argument>,
					 <argument><expr><name>show_context_substitute_hook</name></expr></argument>,
					 <argument><expr><name>show_context_hook</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SetVariableHooks</name><argument_list>(<argument><expr><name><name>pset</name><operator>.</operator><name>vars</name></name></expr></argument>, <argument><expr><literal type="string">"SORT_RESULT"</literal></expr></argument>,
					 <argument><expr><name>bool_substitute_hook</name></expr></argument>,
					 <argument><expr><name>sort_result_hook</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SetVariableHooks</name><argument_list>(<argument><expr><name><name>pset</name><operator>.</operator><name>vars</name></name></expr></argument>, <argument><expr><literal type="string">"COMPARE_PX_RESULT"</literal></expr></argument>,
					 <argument><expr><name>bool_substitute_hook</name></expr></argument>,
					 <argument><expr><name>compare_result_px_hook</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pset</name><operator>.</operator><name>explain_query</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pset</name><operator>.</operator><name>explain_analyze</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
</block_content>}</block></function>
</unit>
