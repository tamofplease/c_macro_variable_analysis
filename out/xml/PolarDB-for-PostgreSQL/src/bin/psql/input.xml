<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/PolarDB-for-PostgreSQL/src/bin/psql/input.c"><comment type="block">/*
 * psql - the PostgreSQL interactive terminal
 *
 * Copyright (c) 2000-2018, PostgreSQL Global Development Group
 *
 * src/bin/psql/input.c
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres_fe.h"</cpp:file></cpp:include>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>WIN32</name></cpp:ifndef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;unistd.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;fcntl.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;limits.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"input.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"settings.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"tab-complete.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"common.h"</cpp:file></cpp:include>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>WIN32</name></cpp:ifndef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PSQLHISTORY</name></cpp:macro> <cpp:value>".psql_history"</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PSQLHISTORY</name></cpp:macro> <cpp:value>"psql_history"</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* Runtime options for turning off readline and history */</comment>
<comment type="block">/* (of course there is no runtime command for doing that :) */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_READLINE</name></cpp:ifdef>
<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type> <name>useReadline</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type> <name>useHistory</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>psql_history</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type>	<name>history_lines_added</name></decl>;</decl_stmt>


<comment type="block">/*
 *	Preserve newlines in saved queries by mapping '\n' to NL_IN_HISTORY
 *
 *	It is assumed NL_IN_HISTORY will never be entered by the user
 *	nor appear inside a multi-byte string.  0x00 is not properly
 *	handled by the readline routines so it can not be used
 *	for this purpose.
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NL_IN_HISTORY</name></cpp:macro>	<cpp:value>0x01</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>finishInput</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>


<comment type="block">/*
 * gets_interactive()
 *
 * Gets a line of interactive input, using readline if desired.
 *
 * prompt: the prompt string to be used
 * query_buf: buffer containing lines already read in the current command
 * (query_buf is not modified here, but may be consulted for tab completion)
 *
 * The result is a malloc'd string.
 *
 * Caller *must* have set up sigint_interrupt_jmp before calling.
 */</comment>
<function><type><name>char</name> <modifier>*</modifier></type>
<name>gets_interactive</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>prompt</name></decl></parameter>, <parameter><decl><type><name>PQExpBuffer</name></type> <name>query_buf</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_READLINE</name></cpp:ifdef>
	<if_stmt><if>if <condition>(<expr><name>useReadline</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * Some versions of readline don't notice SIGWINCH signals that arrive
		 * when not actively reading input.  The simplest fix is to always
		 * re-read the terminal size.  This leaves a window for SIGWINCH to be
		 * missed between here and where readline() enables libreadline's
		 * signal handler, but that's probably short enough to be ignored.
		 */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_RL_RESET_SCREEN_SIZE</name></cpp:ifdef>
		<expr_stmt><expr><call><name>rl_reset_screen_size</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

		<comment type="block">/* Make current query_buf available to tab completion callback */</comment>
		<expr_stmt><expr><name>tab_completion_query_buf</name> <operator>=</operator> <name>query_buf</name></expr>;</expr_stmt>

		<comment type="block">/* Enable SIGINT to longjmp to sigint_interrupt_jmp */</comment>
		<expr_stmt><expr><name>sigint_interrupt_enabled</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

		<comment type="block">/* On some platforms, readline is declared as readline(char *) */</comment>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>readline</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>prompt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Disable SIGINT again */</comment>
		<expr_stmt><expr><name>sigint_interrupt_enabled</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

		<comment type="block">/* Pure neatnik-ism */</comment>
		<expr_stmt><expr><name>tab_completion_query_buf</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

		<return>return <expr><name>result</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<expr_stmt><expr><call><name>fputs</name><argument_list>(<argument><expr><name>prompt</name></expr></argument>, <argument><expr><name>stdout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>fflush</name><argument_list>(<argument><expr><name>stdout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><call><name>gets_fromFile</name><argument_list>(<argument><expr><name>stdin</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * Append the line to the history buffer, making sure there is a trailing '\n'
 */</comment>
<function><type><name>void</name></type>
<name>pg_append_history</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>s</name></decl></parameter>, <parameter><decl><type><name>PQExpBuffer</name></type> <name>history_buf</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_READLINE</name></cpp:ifdef>
	<if_stmt><if>if <condition>(<expr><name>useHistory</name> <operator>&amp;&amp;</operator> <name>s</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>history_buf</name></expr></argument>, <argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>s</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>||</operator> <name><name>s</name><index>[<expr><call><name>strlen</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'\n'</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendPQExpBufferChar</name><argument_list>(<argument><expr><name>history_buf</name></expr></argument>, <argument><expr><literal type="char">'\n'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>


<comment type="block">/*
 * Emit accumulated history entry to readline's history mechanism,
 * then reset the buffer to empty.
 *
 * Note: we write nothing if history_buf is empty, so extra calls to this
 * function don't hurt.  There must have been at least one line added by
 * pg_append_history before we'll do anything.
 */</comment>
<function><type><name>void</name></type>
<name>pg_send_history</name><parameter_list>(<parameter><decl><type><name>PQExpBuffer</name></type> <name>history_buf</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_READLINE</name></cpp:ifdef>
	<decl_stmt><decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>prev_hist</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>s</name> <init>= <expr><name><name>history_buf</name><operator>-&gt;</operator><name>data</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<comment type="block">/* Trim any trailing \n's (OK to scribble on history_buf) */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call> <operator>-</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>s</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <literal type="char">'\n'</literal></expr>;</condition> <incr><expr><name>i</name><operator>--</operator></expr></incr>)</control><block type="pseudo"><block_content>
		<empty_stmt>;</empty_stmt></block_content></block></for>
	<expr_stmt><expr><name><name>s</name><index>[<expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>useHistory</name> <operator>&amp;&amp;</operator> <name><name>s</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>(</operator><operator>(</operator><name><name>pset</name><operator>.</operator><name>histcontrol</name></name> <operator>&amp;</operator> <name>hctl_ignorespace</name><operator>)</operator> <operator>&amp;&amp;</operator>
			 <name><name>s</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">' '</literal><operator>)</operator> <operator>||</operator>
			<operator>(</operator><operator>(</operator><name><name>pset</name><operator>.</operator><name>histcontrol</name></name> <operator>&amp;</operator> <name>hctl_ignoredups</name><operator>)</operator> <operator>&amp;&amp;</operator>
			 <name>prev_hist</name> <operator>&amp;&amp;</operator> <call><name>strcmp</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>prev_hist</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Ignore this line as far as history is concerned */</comment>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/* Save each previous line for ignoredups processing */</comment>
			<if_stmt><if>if <condition>(<expr><name>prev_hist</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>prev_hist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><name>prev_hist</name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* And send it to readline */</comment>
			<expr_stmt><expr><call><name>add_history</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* Count lines added to history for use later */</comment>
			<expr_stmt><expr><name>history_lines_added</name><operator>++</operator></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>resetPQExpBuffer</name><argument_list>(<argument><expr><name>history_buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>


<comment type="block">/*
 * gets_fromFile
 *
 * Gets a line of noninteractive input from a file (which could be stdin).
 * The result is a malloc'd string, or NULL on EOF or input error.
 *
 * Caller *must* have set up sigint_interrupt_jmp before calling.
 *
 * Note: we re-use a static PQExpBuffer for each call.  This is to avoid
 * leaking memory if interrupted by SIGINT.
 */</comment>
<function><type><name>char</name> <modifier>*</modifier></type>
<name>gets_fromFile</name><parameter_list>(<parameter><decl><type><name>FILE</name> <modifier>*</modifier></type><name>source</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>static</specifier> <name>PQExpBuffer</name></type> <name>buffer</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>char</name></type>		<name><name>line</name><index>[<expr><literal type="number">1024</literal></expr>]</index></name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>buffer</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>			<comment type="block">/* first time through? */</comment>
		<expr_stmt><expr><name>buffer</name> <operator>=</operator> <call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>resetPQExpBuffer</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>

		<comment type="block">/* Enable SIGINT to longjmp to sigint_interrupt_jmp */</comment>
		<expr_stmt><expr><name>sigint_interrupt_enabled</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

		<comment type="block">/* Get some data */</comment>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>fgets</name><argument_list>(<argument><expr><name>line</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>line</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>source</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Disable SIGINT again */</comment>
		<expr_stmt><expr><name>sigint_interrupt_enabled</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

		<comment type="block">/* EOF or error? */</comment>
		<if_stmt><if>if <condition>(<expr><name>result</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><call><name>ferror</name><argument_list>(<argument><expr><name>source</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>psql_error</name><argument_list>(<argument><expr><literal type="string">"could not read from input file: %s\n"</literal></expr></argument>,
						   <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr><name>NULL</name></expr>;</return>
			</block_content>}</block></if></if_stmt>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>PQExpBufferBroken</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>psql_error</name><argument_list>(<argument><expr><literal type="string">"out of memory\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>NULL</name></expr>;</return>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* EOL? */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>buffer</name><operator>-&gt;</operator><name>len</name></name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>buffer</name><operator>-&gt;</operator><name>data</name><index>[<expr><name><name>buffer</name><operator>-&gt;</operator><name>len</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'\n'</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>buffer</name><operator>-&gt;</operator><name>data</name><index>[<expr><name><name>buffer</name><operator>-&gt;</operator><name>len</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
			<return>return <expr><call><name>pg_strdup</name><argument_list>(<argument><expr><name><name>buffer</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>

	<if_stmt><if>if <condition>(<expr><name><name>buffer</name><operator>-&gt;</operator><name>len</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>		<comment type="block">/* EOF after reading some bufferload(s) */</comment>
		<return>return <expr><call><name>pg_strdup</name><argument_list>(<argument><expr><name><name>buffer</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* EOF, so return null */</comment>
	<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>


<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_READLINE</name></cpp:ifdef>

<comment type="block">/*
 * Macros to iterate over each element of the history list in order
 *
 * You would think this would be simple enough, but in its inimitable fashion
 * libedit has managed to break it: in libreadline we must use next_history()
 * to go from oldest to newest, but in libedit we must use previous_history().
 * To detect what to do, we make a trial call of previous_history(): if it
 * fails, then either next_history() is what to use, or there's zero or one
 * history entry so that it doesn't matter which direction we go.
 *
 * In case that wasn't disgusting enough: the code below is not as obvious as
 * it might appear.  In some libedit releases history_set_pos(0) fails until
 * at least one add_history() call has been done.  This is not an issue for
 * printHistory() or encode_history(), which cannot be invoked before that has
 * happened.  In decode_history(), that's not so, and what actually happens is
 * that we are sitting on the newest entry to start with, previous_history()
 * fails, and we iterate over all the entries using next_history().  So the
 * decode_history() loop iterates over the entries in the wrong order when
 * using such a libedit release, and if there were another attempt to use
 * BEGIN_ITERATE_HISTORY() before some add_history() call had happened, it
 * wouldn't work.  Fortunately we don't care about either of those things.
 *
 * Usage pattern is:
 *
 *		BEGIN_ITERATE_HISTORY(varname);
 *		{
 *			loop body referencing varname-&gt;line;
 *		}
 *		END_ITERATE_HISTORY();
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BEGIN_ITERATE_HISTORY</name><parameter_list>(<parameter><type><name>VARNAME</name></type></parameter>)</parameter_list></cpp:macro> \
	<cpp:value>do { \
		HIST_ENTRY *VARNAME; \
		bool		use_prev_; \
		\
		history_set_pos(0); \
		use_prev_ = (previous_history() != NULL); \
		history_set_pos(0); \
		for (VARNAME = current_history(); VARNAME != NULL; \
			 VARNAME = use_prev_ ? previous_history() : next_history()) \
		{ \
			(void) 0</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>END_ITERATE_HISTORY</name><parameter_list>()</parameter_list></cpp:macro> \
		<cpp:value>} \
	} while(0)</cpp:value></cpp:define>


<comment type="block">/*
 * Convert newlines to NL_IN_HISTORY for safe saving in readline history file
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>encode_history</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>BEGIN_ITERATE_HISTORY</name><argument_list>(<argument><expr><name>cur_hist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>cur_ptr</name></decl>;</decl_stmt>

		<comment type="block">/* some platforms declare HIST_ENTRY.line as const char * */</comment>
		<for>for <control>(<init><expr><name>cur_ptr</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name><name>cur_hist</name><operator>-&gt;</operator><name>line</name></name></expr>;</init> <condition><expr><operator>*</operator><name>cur_ptr</name></expr>;</condition> <incr><expr><name>cur_ptr</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><operator>*</operator><name>cur_ptr</name> <operator>==</operator> <literal type="char">'\n'</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><operator>*</operator><name>cur_ptr</name> <operator>=</operator> <name>NL_IN_HISTORY</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></for>
	</block_content>}</block>
	<expr_stmt><expr><call><name>END_ITERATE_HISTORY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Reverse the above encoding
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>decode_history</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>BEGIN_ITERATE_HISTORY</name><argument_list>(<argument><expr><name>cur_hist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>cur_ptr</name></decl>;</decl_stmt>

		<comment type="block">/* some platforms declare HIST_ENTRY.line as const char * */</comment>
		<for>for <control>(<init><expr><name>cur_ptr</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name><name>cur_hist</name><operator>-&gt;</operator><name>line</name></name></expr>;</init> <condition><expr><operator>*</operator><name>cur_ptr</name></expr>;</condition> <incr><expr><name>cur_ptr</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><operator>*</operator><name>cur_ptr</name> <operator>==</operator> <name>NL_IN_HISTORY</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><operator>*</operator><name>cur_ptr</name> <operator>=</operator> <literal type="char">'\n'</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></for>
	</block_content>}</block>
	<expr_stmt><expr><call><name>END_ITERATE_HISTORY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>							<comment type="block">/* USE_READLINE */</comment>


<comment type="block">/*
 * Put any startup stuff related to input in here. It's good to maintain
 * abstraction this way.
 *
 * The only "flag" right now is 1 for use readline &amp; history.
 */</comment>
<function><type><name>void</name></type>
<name>initializeInput</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_READLINE</name></cpp:ifdef>
	<if_stmt><if>if <condition>(<expr><name>flags</name> <operator>&amp;</operator> <literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>histfile</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name></type>		<name><name>home</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name></decl>;</decl_stmt>

		<expr_stmt><expr><name>useReadline</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

		<comment type="block">/* these two things must be done in this order: */</comment>
		<expr_stmt><expr><call><name>initialize_readline</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>rl_initialize</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>useHistory</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>using_history</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>history_lines_added</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

		<expr_stmt><expr><name>histfile</name> <operator>=</operator> <call><name>GetVariable</name><argument_list>(<argument><expr><name><name>pset</name><operator>.</operator><name>vars</name></name></expr></argument>, <argument><expr><literal type="string">"HISTFILE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>histfile</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>envhist</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>envhist</name> <operator>=</operator> <call><name>getenv</name><argument_list>(<argument><expr><literal type="string">"PSQL_HISTORY"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>envhist</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>envhist</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>histfile</name> <operator>=</operator> <name>envhist</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>histfile</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><call><name>get_home_path</name><argument_list>(<argument><expr><name>home</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>psql_history</name> <operator>=</operator> <call><name>psprintf</name><argument_list>(<argument><expr><literal type="string">"%s/%s"</literal></expr></argument>, <argument><expr><name>home</name></expr></argument>, <argument><expr><name>PSQLHISTORY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><name>psql_history</name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><name>histfile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>expand_tilde</name><argument_list>(<argument><expr><operator>&amp;</operator><name>psql_history</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>psql_history</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>read_history</name><argument_list>(<argument><expr><name>psql_history</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>decode_history</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<expr_stmt><expr><call><name>atexit</name><argument_list>(<argument><expr><name>finishInput</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * This function saves the readline history when psql exits.
 *
 * fname: pathname of history file.  (Should really be "const char *",
 * but some ancient versions of readline omit the const-decoration.)
 *
 * max_lines: if &gt;= 0, limit history file to that many entries.
 */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_READLINE</name></cpp:ifdef>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>saveHistory</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>fname</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>max_lines</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>errnum</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Suppressing the write attempt when HISTFILE is set to /dev/null may
	 * look like a negligible optimization, but it's necessary on e.g. macOS,
	 * where write_history will fail because it tries to chmod the target
	 * file.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>fname</name></expr></argument>, <argument><expr><name>DEVNULL</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Encode \n, since otherwise readline will reload multiline history
		 * entries as separate lines.  (libedit doesn't really need this, but
		 * we do it anyway since it's too hard to tell which implementation we
		 * are using.)
		 */</comment>
		<expr_stmt><expr><call><name>encode_history</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * On newer versions of libreadline, truncate the history file as
		 * needed and then append what we've added.  This avoids overwriting
		 * history from other concurrent sessions (although there are still
		 * race conditions when two sessions exit at about the same time). If
		 * we don't have those functions, fall back to write_history().
		 */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_HISTORY_TRUNCATE_FILE</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>defined</name><argument_list>(<argument><expr><name>HAVE_APPEND_HISTORY</name></expr></argument>)</argument_list></call></expr></cpp:if>
		<block>{<block_content>
			<decl_stmt><decl><type><name>int</name></type>			<name>nlines</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int</name></type>			<name>fd</name></decl>;</decl_stmt>

			<comment type="block">/* truncate previous entries if needed */</comment>
			<if_stmt><if>if <condition>(<expr><name>max_lines</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>nlines</name> <operator>=</operator> <call><name>Max</name><argument_list>(<argument><expr><name>max_lines</name> <operator>-</operator> <name>history_lines_added</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>history_truncate_file</name><argument_list>(<argument><expr><name>fname</name></expr></argument>, <argument><expr><name>nlines</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			<comment type="block">/* append_history fails if file doesn't already exist :-( */</comment>
			<expr_stmt><expr><name>fd</name> <operator>=</operator> <call><name>open</name><argument_list>(<argument><expr><name>fname</name></expr></argument>, <argument><expr><name>O_CREAT</name> <operator>|</operator> <name>O_WRONLY</name> <operator>|</operator> <name>PG_BINARY</name></expr></argument>, <argument><expr><literal type="number">0600</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>fd</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<comment type="block">/* append the appropriate number of lines */</comment>
			<if_stmt><if>if <condition>(<expr><name>max_lines</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>nlines</name> <operator>=</operator> <call><name>Min</name><argument_list>(<argument><expr><name>max_lines</name></expr></argument>, <argument><expr><name>history_lines_added</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name>nlines</name> <operator>=</operator> <name>history_lines_added</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
			<expr_stmt><expr><name>errnum</name> <operator>=</operator> <call><name>append_history</name><argument_list>(<argument><expr><name>nlines</name></expr></argument>, <argument><expr><name>fname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>errnum</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
		</block_content>}</block>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>							<comment type="block">/* don't have append support */</comment>
		<block>{<block_content>
			<comment type="block">/* truncate what we have ... */</comment>
			<if_stmt><if>if <condition>(<expr><name>max_lines</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>stifle_history</name><argument_list>(<argument><expr><name>max_lines</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<comment type="block">/* ... and overwrite file.  Tough luck for concurrent sessions. */</comment>
			<expr_stmt><expr><name>errnum</name> <operator>=</operator> <call><name>write_history</name><argument_list>(<argument><expr><name>fname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>errnum</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
		</block_content>}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

		<expr_stmt><expr><call><name>psql_error</name><argument_list>(<argument><expr><literal type="string">"could not save history to file \"%s\": %s\n"</literal></expr></argument>,
				   <argument><expr><name>fname</name></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errnum</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>



<comment type="block">/*
 * Print history to the specified file, or to the console if fname is NULL
 * (psql \s command)
 *
 * We used to use saveHistory() for this purpose, but that doesn't permit
 * use of a pager; moreover libedit's implementation behaves incompatibly
 * (preferring to encode its output) and may fail outright when the target
 * file is specified as /dev/tty.
 */</comment>
<function><type><name>bool</name></type>
<name>printHistory</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>fname</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>short</name> <name>int</name></type> <name>pager</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_READLINE</name></cpp:ifdef>
	<decl_stmt><decl><type><name>FILE</name>	   <modifier>*</modifier></type><name>output</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>is_pager</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>useHistory</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>fname</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* use pager, if enabled, when printing to console */</comment>
		<expr_stmt><expr><name>output</name> <operator>=</operator> <call><name>PageOutput</name><argument_list>(<argument><expr><name>INT_MAX</name></expr></argument>, <argument><expr><ternary><condition><expr><name>pager</name></expr> ?</condition><then> <expr><operator>&amp;</operator><operator>(</operator><name><name>pset</name><operator>.</operator><name>popt</name><operator>.</operator><name>topt</name></name><operator>)</operator></expr> </then><else>: <expr><name>NULL</name></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>is_pager</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name>output</name> <operator>=</operator> <call><name>fopen</name><argument_list>(<argument><expr><name>fname</name></expr></argument>, <argument><expr><literal type="string">"w"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>output</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>psql_error</name><argument_list>(<argument><expr><literal type="string">"could not save history to file \"%s\": %s\n"</literal></expr></argument>,
					   <argument><expr><name>fname</name></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>false</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><name>is_pager</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><call><name>BEGIN_ITERATE_HISTORY</name><argument_list>(<argument><expr><name>cur_hist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<block>{<block_content>
		<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>output</name></expr></argument>, <argument><expr><literal type="string">"%s\n"</literal></expr></argument>, <argument><expr><name><name>cur_hist</name><operator>-&gt;</operator><name>line</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
	<expr_stmt><expr><call><name>END_ITERATE_HISTORY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>is_pager</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ClosePager</name><argument_list>(<argument><expr><name>output</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>fclose</name><argument_list>(<argument><expr><name>output</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<return>return <expr><name>true</name></expr>;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	<expr_stmt><expr><call><name>psql_error</name><argument_list>(<argument><expr><literal type="string">"history is not supported by this installation\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>false</name></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>void</name></type>
<name>finishInput</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_READLINE</name></cpp:ifdef>
	<if_stmt><if>if <condition>(<expr><name>useHistory</name> <operator>&amp;&amp;</operator> <name>psql_history</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>saveHistory</name><argument_list>(<argument><expr><name>psql_history</name></expr></argument>, <argument><expr><name><name>pset</name><operator>.</operator><name>histsize</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>psql_history</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>psql_history</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>
</unit>
