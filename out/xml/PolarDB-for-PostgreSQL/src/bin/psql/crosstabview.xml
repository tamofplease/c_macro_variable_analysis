<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/PolarDB-for-PostgreSQL/src/bin/psql/crosstabview.c"><comment type="block">/*
 * psql - the PostgreSQL interactive terminal
 *
 * Copyright (c) 2000-2018, PostgreSQL Global Development Group
 *
 * src/bin/psql/crosstabview.c
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres_fe.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"common.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"crosstabview.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pqexpbuffer.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"psqlscanslash.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"settings.h"</cpp:file></cpp:include>


<comment type="block">/*
 * Value/position from the resultset that goes into the horizontal or vertical
 * crosstabview header.
 */</comment>
<typedef>typedef <type><struct>struct <name>_pivot_field</name>
<block>{
	<comment type="block">/*
	 * Pointer obtained from PQgetvalue() for colV or colH. Each distinct
	 * value becomes an entry in the vertical header (colV), or horizontal
	 * header (colH). A Null value is represented by a NULL pointer.
	 */</comment>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>name</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * When a sort is requested on an alternative column, this holds
	 * PQgetvalue() for the sort column corresponding to &lt;name&gt;. If &lt;name&gt;
	 * appear multiple times, it's the first value in the order of the results
	 * that is kept. A Null value is represented by a NULL pointer.
	 */</comment>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>sort_value</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Rank of this value, starting at 0. Initially, it's the relative
	 * position of the first appearance of &lt;name&gt; in the resultset. For
	 * example, if successive rows contain B,A,C,A,D then it's B:0,A:1,C:2,D:3
	 * When a sort column is specified, ranks get updated in a final pass to
	 * reflect the desired order.
	 */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>rank</name></decl>;</decl_stmt>
}</block></struct></type> <name>pivot_field</name>;</typedef>

<comment type="block">/* Node in avl_tree */</comment>
<typedef>typedef <type><struct>struct <name>_avl_node</name>
<block>{
	<comment type="block">/* Node contents */</comment>
	<decl_stmt><decl><type><name>pivot_field</name></type> <name>field</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Height of this node in the tree (number of nodes on the longest path to
	 * a leaf).
	 */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>height</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Child nodes. [0] points to left subtree, [1] to right subtree. Never
	 * NULL, points to the empty node avl_tree.end when no left or right
	 * value.
	 */</comment>
	<decl_stmt><decl><type><name><name>struct</name> <name>_avl_node</name></name> <modifier>*</modifier></type><name><name>children</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>
}</block></struct></type> <name>avl_node</name>;</typedef>

<comment type="block">/*
 * Control structure for the AVL tree (binary search tree kept
 * balanced with the AVL algorithm)
 */</comment>
<typedef>typedef <type><struct>struct <name>_avl_tree</name>
<block>{
	<decl_stmt><decl><type><name>int</name></type>			<name>count</name></decl>;</decl_stmt>			<comment type="block">/* Total number of nodes */</comment>
	<decl_stmt><decl><type><name>avl_node</name>   <modifier>*</modifier></type><name>root</name></decl>;</decl_stmt>			<comment type="block">/* root of the tree */</comment>
	<decl_stmt><decl><type><name>avl_node</name>   <modifier>*</modifier></type><name>end</name></decl>;</decl_stmt>			<comment type="block">/* Immutable dereferenceable empty tree */</comment>
}</block></struct></type> <name>avl_tree</name>;</typedef>


<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>printCrosstab</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>PGresult</name> <modifier>*</modifier></type><name>results</name></decl></parameter>,
			  <parameter><decl><type><name>int</name></type> <name>num_columns</name></decl></parameter>, <parameter><decl><type><name>pivot_field</name> <modifier>*</modifier></type><name>piv_columns</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>field_for_columns</name></decl></parameter>,
			  <parameter><decl><type><name>int</name></type> <name>num_rows</name></decl></parameter>, <parameter><decl><type><name>pivot_field</name> <modifier>*</modifier></type><name>piv_rows</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>field_for_rows</name></decl></parameter>,
			  <parameter><decl><type><name>int</name></type> <name>field_for_data</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>avlInit</name><parameter_list>(<parameter><decl><type><name>avl_tree</name> <modifier>*</modifier></type><name>tree</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>avlMergeValue</name><parameter_list>(<parameter><decl><type><name>avl_tree</name> <modifier>*</modifier></type><name>tree</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>sort_value</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>avlCollectFields</name><parameter_list>(<parameter><decl><type><name>avl_tree</name> <modifier>*</modifier></type><name>tree</name></decl></parameter>, <parameter><decl><type><name>avl_node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>,
				 <parameter><decl><type><name>pivot_field</name> <modifier>*</modifier></type><name>fields</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>idx</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>avlFree</name><parameter_list>(<parameter><decl><type><name>avl_tree</name> <modifier>*</modifier></type><name>tree</name></decl></parameter>, <parameter><decl><type><name>avl_node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>rankSort</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>num_columns</name></decl></parameter>, <parameter><decl><type><name>pivot_field</name> <modifier>*</modifier></type><name>piv_columns</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type>	<name>indexOfColumn</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>PGresult</name> <modifier>*</modifier></type><name>res</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type>	<name>pivotFieldCompare</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type>	<name>rankCompare</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>;</function_decl>


<comment type="block">/*
 * Main entry point to this module.
 *
 * Process the data from *res according to the options in pset (global),
 * to generate the horizontal and vertical headers contents,
 * then call printCrosstab() for the actual output.
 */</comment>
<function><type><name>bool</name></type>
<name>PrintResultsInCrosstab</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>PGresult</name> <modifier>*</modifier></type><name>res</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type>		<name>retval</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>avl_tree</name></type>	<name>piv_columns</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>avl_tree</name></type>	<name>piv_rows</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>pivot_field</name> <modifier>*</modifier></type><name>array_columns</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>pivot_field</name> <modifier>*</modifier></type><name>array_rows</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>num_columns</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>num_rows</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>field_for_rows</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>field_for_columns</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>field_for_data</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>sort_field_for_columns</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>rn</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>avlInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name>piv_rows</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>avlInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name>piv_columns</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>PQresultStatus</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>PGRES_TUPLES_OK</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>psql_error</name><argument_list>(<argument><expr><literal type="string">"\\crosstabview: statement did not return a result set\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<goto>goto <name>error_return</name>;</goto>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>PQnfields</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">3</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>psql_error</name><argument_list>(<argument><expr><literal type="string">"\\crosstabview: query must return at least three columns\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<goto>goto <name>error_return</name>;</goto>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Process first optional arg (vertical header column) */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>pset</name><operator>.</operator><name>ctv_args</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>field_for_rows</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name>field_for_rows</name> <operator>=</operator> <call><name>indexOfColumn</name><argument_list>(<argument><expr><name><name>pset</name><operator>.</operator><name>ctv_args</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>field_for_rows</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<goto>goto <name>error_return</name>;</goto></block_content></block></if></if_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/* Process second optional arg (horizontal header column) */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>pset</name><operator>.</operator><name>ctv_args</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>field_for_columns</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name>field_for_columns</name> <operator>=</operator> <call><name>indexOfColumn</name><argument_list>(<argument><expr><name><name>pset</name><operator>.</operator><name>ctv_args</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>field_for_columns</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<goto>goto <name>error_return</name>;</goto></block_content></block></if></if_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/* Insist that header columns be distinct */</comment>
	<if_stmt><if>if <condition>(<expr><name>field_for_columns</name> <operator>==</operator> <name>field_for_rows</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>psql_error</name><argument_list>(<argument><expr><literal type="string">"\\crosstabview: vertical and horizontal headers must be different columns\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<goto>goto <name>error_return</name>;</goto>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Process third optional arg (data column) */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>pset</name><operator>.</operator><name>ctv_args</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * If the data column was not specified, we search for the one not
		 * used as either vertical or horizontal headers.  Must be exactly
		 * three columns, or this won't be unique.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>PQnfields</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">3</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>psql_error</name><argument_list>(<argument><expr><literal type="string">"\\crosstabview: data column must be specified when query returns more than three columns\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<goto>goto <name>error_return</name>;</goto>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name>field_for_data</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <call><name>PQnfields</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>i</name> <operator>!=</operator> <name>field_for_rows</name> <operator>&amp;&amp;</operator> <name>i</name> <operator>!=</operator> <name>field_for_columns</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>field_for_data</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></for>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>field_for_data</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name>field_for_data</name> <operator>=</operator> <call><name>indexOfColumn</name><argument_list>(<argument><expr><name><name>pset</name><operator>.</operator><name>ctv_args</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>, <argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>field_for_data</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<goto>goto <name>error_return</name>;</goto></block_content></block></if></if_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/* Process fourth optional arg (horizontal header sort column) */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>pset</name><operator>.</operator><name>ctv_args</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>sort_field_for_columns</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if>	<comment type="block">/* no sort column */</comment>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name>sort_field_for_columns</name> <operator>=</operator> <call><name>indexOfColumn</name><argument_list>(<argument><expr><name><name>pset</name><operator>.</operator><name>ctv_args</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></expr></argument>, <argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>sort_field_for_columns</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<goto>goto <name>error_return</name>;</goto></block_content></block></if></if_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/*
	 * First part: accumulate the names that go into the vertical and
	 * horizontal headers, each into an AVL binary tree to build the set of
	 * DISTINCT values.
	 */</comment>

	<for>for <control>(<init><expr><name>rn</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>rn</name> <operator>&lt;</operator> <call><name>PQntuples</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>rn</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>val</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>val1</name></decl>;</decl_stmt>

		<comment type="block">/* horizontal */</comment>
		<expr_stmt><expr><name>val</name> <operator>=</operator> <ternary><condition><expr><call><name>PQgetisnull</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>rn</name></expr></argument>, <argument><expr><name>field_for_columns</name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><name>NULL</name></expr> </then><else>:
			<expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>rn</name></expr></argument>, <argument><expr><name>field_for_columns</name></expr></argument>)</argument_list></call></expr></else></ternary></expr>;</expr_stmt>
		<expr_stmt><expr><name>val1</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>sort_field_for_columns</name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
			<operator>!</operator><call><name>PQgetisnull</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>rn</name></expr></argument>, <argument><expr><name>sort_field_for_columns</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>val1</name> <operator>=</operator> <call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>rn</name></expr></argument>, <argument><expr><name>sort_field_for_columns</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>avlMergeValue</name><argument_list>(<argument><expr><operator>&amp;</operator><name>piv_columns</name></expr></argument>, <argument><expr><name>val</name></expr></argument>, <argument><expr><name>val1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>piv_columns</name><operator>.</operator><name>count</name></name> <operator>&gt;</operator> <name>CROSSTABVIEW_MAX_COLUMNS</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>psql_error</name><argument_list>(<argument><expr><literal type="string">"\\crosstabview: maximum number of columns (%d) exceeded\n"</literal></expr></argument>,
					   <argument><expr><name>CROSSTABVIEW_MAX_COLUMNS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<goto>goto <name>error_return</name>;</goto>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* vertical */</comment>
		<expr_stmt><expr><name>val</name> <operator>=</operator> <ternary><condition><expr><call><name>PQgetisnull</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>rn</name></expr></argument>, <argument><expr><name>field_for_rows</name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><name>NULL</name></expr> </then><else>:
			<expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>rn</name></expr></argument>, <argument><expr><name>field_for_rows</name></expr></argument>)</argument_list></call></expr></else></ternary></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>avlMergeValue</name><argument_list>(<argument><expr><operator>&amp;</operator><name>piv_rows</name></expr></argument>, <argument><expr><name>val</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<comment type="block">/*
	 * Second part: Generate sorted arrays from the AVL trees.
	 */</comment>

	<expr_stmt><expr><name>num_columns</name> <operator>=</operator> <name><name>piv_columns</name><operator>.</operator><name>count</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>num_rows</name> <operator>=</operator> <name><name>piv_rows</name><operator>.</operator><name>count</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><name>array_columns</name> <operator>=</operator> <operator>(</operator><name>pivot_field</name> <operator>*</operator><operator>)</operator>
		<call><name>pg_malloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>pivot_field</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>num_columns</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>array_rows</name> <operator>=</operator> <operator>(</operator><name>pivot_field</name> <operator>*</operator><operator>)</operator>
		<call><name>pg_malloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>pivot_field</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>num_rows</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>avlCollectFields</name><argument_list>(<argument><expr><operator>&amp;</operator><name>piv_columns</name></expr></argument>, <argument><expr><name><name>piv_columns</name><operator>.</operator><name>root</name></name></expr></argument>, <argument><expr><name>array_columns</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>avlCollectFields</name><argument_list>(<argument><expr><operator>&amp;</operator><name>piv_rows</name></expr></argument>, <argument><expr><name><name>piv_rows</name><operator>.</operator><name>root</name></name></expr></argument>, <argument><expr><name>array_rows</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Third part: optionally, process the ranking data for the horizontal
	 * header
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>sort_field_for_columns</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>rankSort</name><argument_list>(<argument><expr><name>num_columns</name></expr></argument>, <argument><expr><name>array_columns</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Fourth part: print the crosstab'ed results.
	 */</comment>
	<expr_stmt><expr><name>retval</name> <operator>=</operator> <call><name>printCrosstab</name><argument_list>(<argument><expr><name>res</name></expr></argument>,
						   <argument><expr><name>num_columns</name></expr></argument>, <argument><expr><name>array_columns</name></expr></argument>, <argument><expr><name>field_for_columns</name></expr></argument>,
						   <argument><expr><name>num_rows</name></expr></argument>, <argument><expr><name>array_rows</name></expr></argument>, <argument><expr><name>field_for_rows</name></expr></argument>,
						   <argument><expr><name>field_for_data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<label><name>error_return</name>:</label>
	<expr_stmt><expr><call><name>avlFree</name><argument_list>(<argument><expr><operator>&amp;</operator><name>piv_columns</name></expr></argument>, <argument><expr><name><name>piv_columns</name><operator>.</operator><name>root</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>avlFree</name><argument_list>(<argument><expr><operator>&amp;</operator><name>piv_rows</name></expr></argument>, <argument><expr><name><name>piv_rows</name><operator>.</operator><name>root</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pg_free</name><argument_list>(<argument><expr><name>array_columns</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pg_free</name><argument_list>(<argument><expr><name>array_rows</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>retval</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Output the pivoted resultset with the printTable* functions.  Return true
 * if successful, false otherwise.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>printCrosstab</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>PGresult</name> <modifier>*</modifier></type><name>results</name></decl></parameter>,
			  <parameter><decl><type><name>int</name></type> <name>num_columns</name></decl></parameter>, <parameter><decl><type><name>pivot_field</name> <modifier>*</modifier></type><name>piv_columns</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>field_for_columns</name></decl></parameter>,
			  <parameter><decl><type><name>int</name></type> <name>num_rows</name></decl></parameter>, <parameter><decl><type><name>pivot_field</name> <modifier>*</modifier></type><name>piv_rows</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>field_for_rows</name></decl></parameter>,
			  <parameter><decl><type><name>int</name></type> <name>field_for_data</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>printQueryOpt</name></type> <name>popt</name> <init>= <expr><name><name>pset</name><operator>.</operator><name>popt</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>printTableContent</name></type> <name>cont</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>,
				<decl><type ref="prev"/><name>rn</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name>col_align</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name>		   <modifier>*</modifier></type><name>horiz_map</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>retval</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>printTableInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cont</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>popt</name><operator>.</operator><name>topt</name></name></expr></argument>, <argument><expr><name><name>popt</name><operator>.</operator><name>title</name></name></expr></argument>, <argument><expr><name>num_columns</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>num_rows</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Step 1: set target column names (horizontal header) */</comment>

	<comment type="block">/* The name of the first column is kept unchanged by the pivoting */</comment>
	<expr_stmt><expr><call><name>printTableAddHeader</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cont</name></expr></argument>,
						<argument><expr><call><name>PQfname</name><argument_list>(<argument><expr><name>results</name></expr></argument>, <argument><expr><name>field_for_rows</name></expr></argument>)</argument_list></call></expr></argument>,
						<argument><expr><name>false</name></expr></argument>,
						<argument><expr><call><name>column_type_alignment</name><argument_list>(<argument><expr><call><name>PQftype</name><argument_list>(<argument><expr><name>results</name></expr></argument>,
													  <argument><expr><name>field_for_rows</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * To iterate over piv_columns[] by piv_columns[].rank, create a reverse
	 * map associating each piv_columns[].rank to its index in piv_columns.
	 * This avoids an O(N^2) loop later.
	 */</comment>
	<expr_stmt><expr><name>horiz_map</name> <operator>=</operator> <operator>(</operator><name>int</name> <operator>*</operator><operator>)</operator> <call><name>pg_malloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>num_columns</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>num_columns</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>horiz_map</name><index>[<expr><name><name>piv_columns</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>rank</name></expr>]</index></name> <operator>=</operator> <name>i</name></expr>;</expr_stmt></block_content></block></for>

	<comment type="block">/*
	 * The display alignment depends on its PQftype().
	 */</comment>
	<expr_stmt><expr><name>col_align</name> <operator>=</operator> <call><name>column_type_alignment</name><argument_list>(<argument><expr><call><name>PQftype</name><argument_list>(<argument><expr><name>results</name></expr></argument>, <argument><expr><name>field_for_data</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>num_columns</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>colname</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>colname</name> <operator>=</operator> <ternary><condition><expr><name><name>piv_columns</name><index>[<expr><name><name>horiz_map</name><index>[<expr><name>i</name></expr>]</index></name></expr>]</index></name><operator>.</operator><name>name</name></expr> ?</condition><then>
			<expr><name><name>piv_columns</name><index>[<expr><name><name>horiz_map</name><index>[<expr><name>i</name></expr>]</index></name></expr>]</index></name><operator>.</operator><name>name</name></expr> </then><else>:
			<expr><operator>(</operator><ternary><condition><expr><name><name>popt</name><operator>.</operator><name>nullPrint</name></name></expr> ?</condition><then> <expr><name><name>popt</name><operator>.</operator><name>nullPrint</name></name></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary><operator>)</operator></expr></else></ternary></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>printTableAddHeader</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cont</name></expr></argument>, <argument><expr><name>colname</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>col_align</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>
	<expr_stmt><expr><call><name>pg_free</name><argument_list>(<argument><expr><name>horiz_map</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Step 2: set row names in the first output column (vertical header) */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>num_rows</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>k</name> <init>= <expr><name><name>piv_rows</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>rank</name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>cont</name><operator>.</operator><name>cells</name><index>[<expr><name>k</name> <operator>*</operator> <operator>(</operator><name>num_columns</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr>]</index></name> <operator>=</operator> <ternary><condition><expr><name><name>piv_rows</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>name</name></expr> ?</condition><then>
			<expr><name><name>piv_rows</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>name</name></expr> </then><else>:
			<expr><operator>(</operator><ternary><condition><expr><name><name>popt</name><operator>.</operator><name>nullPrint</name></name></expr> ?</condition><then> <expr><name><name>popt</name><operator>.</operator><name>nullPrint</name></name></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary><operator>)</operator></expr></else></ternary></expr>;</expr_stmt>
	</block_content>}</block></for>
	<expr_stmt><expr><name><name>cont</name><operator>.</operator><name>cellsadded</name></name> <operator>=</operator> <name>num_rows</name> <operator>*</operator> <operator>(</operator><name>num_columns</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>

	<comment type="block">/*
	 * Step 3: fill in the content cells.
	 */</comment>
	<for>for <control>(<init><expr><name>rn</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>rn</name> <operator>&lt;</operator> <call><name>PQntuples</name><argument_list>(<argument><expr><name>results</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>rn</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>row_number</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>col_number</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>pivot_field</name> <modifier>*</modifier></type><name>rp</name></decl>,
				   <decl><type ref="prev"><modifier>*</modifier></type><name>cp</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>pivot_field</name></type> <name>elt</name></decl>;</decl_stmt>

		<comment type="block">/* Find target row */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>PQgetisnull</name><argument_list>(<argument><expr><name>results</name></expr></argument>, <argument><expr><name>rn</name></expr></argument>, <argument><expr><name>field_for_rows</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>elt</name><operator>.</operator><name>name</name></name> <operator>=</operator> <call><name>PQgetvalue</name><argument_list>(<argument><expr><name>results</name></expr></argument>, <argument><expr><name>rn</name></expr></argument>, <argument><expr><name>field_for_rows</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>elt</name><operator>.</operator><name>name</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
		<expr_stmt><expr><name>rp</name> <operator>=</operator> <operator>(</operator><name>pivot_field</name> <operator>*</operator><operator>)</operator> <call><name>bsearch</name><argument_list>(<argument><expr><operator>&amp;</operator><name>elt</name></expr></argument>,
									 <argument><expr><name>piv_rows</name></expr></argument>,
									 <argument><expr><name>num_rows</name></expr></argument>,
									 <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>pivot_field</name></expr></argument>)</argument_list></sizeof></expr></argument>,
									 <argument><expr><name>pivotFieldCompare</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>rp</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>row_number</name> <operator>=</operator> <name><name>rp</name><operator>-&gt;</operator><name>rank</name></name></expr>;</expr_stmt>

		<comment type="block">/* Find target column */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>PQgetisnull</name><argument_list>(<argument><expr><name>results</name></expr></argument>, <argument><expr><name>rn</name></expr></argument>, <argument><expr><name>field_for_columns</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>elt</name><operator>.</operator><name>name</name></name> <operator>=</operator> <call><name>PQgetvalue</name><argument_list>(<argument><expr><name>results</name></expr></argument>, <argument><expr><name>rn</name></expr></argument>, <argument><expr><name>field_for_columns</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>elt</name><operator>.</operator><name>name</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<expr_stmt><expr><name>cp</name> <operator>=</operator> <operator>(</operator><name>pivot_field</name> <operator>*</operator><operator>)</operator> <call><name>bsearch</name><argument_list>(<argument><expr><operator>&amp;</operator><name>elt</name></expr></argument>,
									 <argument><expr><name>piv_columns</name></expr></argument>,
									 <argument><expr><name>num_columns</name></expr></argument>,
									 <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>pivot_field</name></expr></argument>)</argument_list></sizeof></expr></argument>,
									 <argument><expr><name>pivotFieldCompare</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>cp</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>col_number</name> <operator>=</operator> <name><name>cp</name><operator>-&gt;</operator><name>rank</name></name></expr>;</expr_stmt>

		<comment type="block">/* Place value into cell */</comment>
		<if_stmt><if>if <condition>(<expr><name>col_number</name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>row_number</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>int</name></type>			<name>idx</name></decl>;</decl_stmt>

			<comment type="block">/* index into the cont.cells array */</comment>
			<expr_stmt><expr><name>idx</name> <operator>=</operator> <literal type="number">1</literal> <operator>+</operator> <name>col_number</name> <operator>+</operator> <name>row_number</name> <operator>*</operator> <operator>(</operator><name>num_columns</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>

			<comment type="block">/*
			 * If the cell already contains a value, raise an error.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>cont</name><operator>.</operator><name>cells</name><index>[<expr><name>idx</name></expr>]</index></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>psql_error</name><argument_list>(<argument><expr><literal type="string">"\\crosstabview: query result contains multiple data values for row \"%s\", column \"%s\"\n"</literal></expr></argument>,
						   <argument><expr><ternary><condition><expr><name><name>rp</name><operator>-&gt;</operator><name>name</name></name></expr> ?</condition><then> <expr><name><name>rp</name><operator>-&gt;</operator><name>name</name></name></expr> </then><else>:
						   <expr><operator>(</operator><ternary><condition><expr><name><name>popt</name><operator>.</operator><name>nullPrint</name></name></expr> ?</condition><then> <expr><name><name>popt</name><operator>.</operator><name>nullPrint</name></name></expr> </then><else>: <expr><literal type="string">"(null)"</literal></expr></else></ternary><operator>)</operator></expr></else></ternary></expr></argument>,
						   <argument><expr><ternary><condition><expr><name><name>cp</name><operator>-&gt;</operator><name>name</name></name></expr> ?</condition><then> <expr><name><name>cp</name><operator>-&gt;</operator><name>name</name></name></expr> </then><else>:
						   <expr><operator>(</operator><ternary><condition><expr><name><name>popt</name><operator>.</operator><name>nullPrint</name></name></expr> ?</condition><then> <expr><name><name>popt</name><operator>.</operator><name>nullPrint</name></name></expr> </then><else>: <expr><literal type="string">"(null)"</literal></expr></else></ternary><operator>)</operator></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<goto>goto <name>error</name>;</goto>
			</block_content>}</block></if></if_stmt>

			<expr_stmt><expr><name><name>cont</name><operator>.</operator><name>cells</name><index>[<expr><name>idx</name></expr>]</index></name> <operator>=</operator> <ternary><condition><expr><operator>!</operator><call><name>PQgetisnull</name><argument_list>(<argument><expr><name>results</name></expr></argument>, <argument><expr><name>rn</name></expr></argument>, <argument><expr><name>field_for_data</name></expr></argument>)</argument_list></call></expr> ?</condition><then>
				<expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>results</name></expr></argument>, <argument><expr><name>rn</name></expr></argument>, <argument><expr><name>field_for_data</name></expr></argument>)</argument_list></call></expr> </then><else>:
				<expr><operator>(</operator><ternary><condition><expr><name><name>popt</name><operator>.</operator><name>nullPrint</name></name></expr> ?</condition><then> <expr><name><name>popt</name><operator>.</operator><name>nullPrint</name></name></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary><operator>)</operator></expr></else></ternary></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>

	<comment type="block">/*
	 * The non-initialized cells must be set to an empty string for the print
	 * functions
	 */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>cont</name><operator>.</operator><name>cellsadded</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>cont</name><operator>.</operator><name>cells</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>cont</name><operator>.</operator><name>cells</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <literal type="string">""</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>printTable</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cont</name></expr></argument>, <argument><expr><name><name>pset</name><operator>.</operator><name>queryFout</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name><name>pset</name><operator>.</operator><name>logfile</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>retval</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

<label><name>error</name>:</label>
	<expr_stmt><expr><call><name>printTableCleanup</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cont</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>retval</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * The avl* functions below provide a minimalistic implementation of AVL binary
 * trees, to efficiently collect the distinct values that will form the horizontal
 * and vertical headers. It only supports adding new values, no removal or even
 * search.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>avlInit</name><parameter_list>(<parameter><decl><type><name>avl_tree</name> <modifier>*</modifier></type><name>tree</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><name><name>tree</name><operator>-&gt;</operator><name>end</name></name> <operator>=</operator> <operator>(</operator><name>avl_node</name> <operator>*</operator><operator>)</operator> <call><name>pg_malloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>avl_node</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>tree</name><operator>-&gt;</operator><name>end</name><operator>-&gt;</operator><name>children</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name><name>tree</name><operator>-&gt;</operator><name>end</name><operator>-&gt;</operator><name>children</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name><name>tree</name><operator>-&gt;</operator><name>end</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>tree</name><operator>-&gt;</operator><name>count</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>tree</name><operator>-&gt;</operator><name>root</name></name> <operator>=</operator> <name><name>tree</name><operator>-&gt;</operator><name>end</name></name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Deallocate recursively an AVL tree, starting from node */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>avlFree</name><parameter_list>(<parameter><decl><type><name>avl_tree</name> <modifier>*</modifier></type><name>tree</name></decl></parameter>, <parameter><decl><type><name>avl_node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>children</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <name><name>tree</name><operator>-&gt;</operator><name>end</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>avlFree</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>children</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pg_free</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>children</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>children</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>!=</operator> <name><name>tree</name><operator>-&gt;</operator><name>end</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>avlFree</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>children</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pg_free</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>children</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>node</name> <operator>==</operator> <name><name>tree</name><operator>-&gt;</operator><name>root</name></name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* free the root separately as it's not child of anything */</comment>
		<if_stmt><if>if <condition>(<expr><name>node</name> <operator>!=</operator> <name><name>tree</name><operator>-&gt;</operator><name>end</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>pg_free</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<comment type="block">/* free the tree-&gt;end struct only once and when all else is freed */</comment>
		<expr_stmt><expr><call><name>pg_free</name><argument_list>(<argument><expr><name><name>tree</name><operator>-&gt;</operator><name>end</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/* Set the height to 1 plus the greatest of left and right heights */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>avlUpdateHeight</name><parameter_list>(<parameter><decl><type><name>avl_node</name> <modifier>*</modifier></type><name>n</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><name><name>n</name><operator>-&gt;</operator><name>height</name></name> <operator>=</operator> <literal type="number">1</literal> <operator>+</operator> <operator>(</operator><ternary><condition><expr><name><name>n</name><operator>-&gt;</operator><name>children</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>-&gt;</operator><name>height</name> <operator>&gt;</operator> <name><name>n</name><operator>-&gt;</operator><name>children</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>-&gt;</operator><name>height</name></expr> ?</condition><then>
					 <expr><name><name>n</name><operator>-&gt;</operator><name>children</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>-&gt;</operator><name>height</name></expr> </then><else>:
					 <expr><name><name>n</name><operator>-&gt;</operator><name>children</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>-&gt;</operator><name>height</name></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Rotate a subtree left (dir=0) or right (dir=1). Not recursive */</comment>
<function><type><specifier>static</specifier> <name>avl_node</name> <modifier>*</modifier></type>
<name>avlRotate</name><parameter_list>(<parameter><decl><type><name>avl_node</name> <modifier>*</modifier><modifier>*</modifier></type><name>current</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>dir</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>avl_node</name>   <modifier>*</modifier></type><name>before</name> <init>= <expr><operator>*</operator><name>current</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>avl_node</name>   <modifier>*</modifier></type><name>after</name> <init>= <expr><name><operator>(</operator><operator>*</operator><name>current</name><operator>)</operator><operator>-&gt;</operator><name>children</name></name><index>[<expr><name>dir</name></expr>]</index></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><operator>*</operator><name>current</name> <operator>=</operator> <name>after</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>before</name><operator>-&gt;</operator><name>children</name><index>[<expr><name>dir</name></expr>]</index></name> <operator>=</operator> <name><name>after</name><operator>-&gt;</operator><name>children</name><index>[<expr><operator>!</operator><name>dir</name></expr>]</index></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>avlUpdateHeight</name><argument_list>(<argument><expr><name>before</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>after</name><operator>-&gt;</operator><name>children</name><index>[<expr><operator>!</operator><name>dir</name></expr>]</index></name> <operator>=</operator> <name>before</name></expr>;</expr_stmt>

	<return>return <expr><name>after</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>avlBalance</name><parameter_list>(<parameter><decl><type><name>avl_node</name> <modifier>*</modifier></type><name>n</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><name><name>n</name><operator>-&gt;</operator><name>children</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>-&gt;</operator><name>height</name> <operator>-</operator> <name><name>n</name><operator>-&gt;</operator><name>children</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>-&gt;</operator><name>height</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * After an insertion, possibly rebalance the tree so that the left and right
 * node heights don't differ by more than 1.
 * May update *node.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>avlAdjustBalance</name><parameter_list>(<parameter><decl><type><name>avl_tree</name> <modifier>*</modifier></type><name>tree</name></decl></parameter>, <parameter><decl><type><name>avl_node</name> <modifier>*</modifier><modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>avl_node</name>   <modifier>*</modifier></type><name>current</name> <init>= <expr><operator>*</operator><name>node</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>b</name> <init>= <expr><call><name>avlBalance</name><argument_list>(<argument><expr><name>current</name></expr></argument>)</argument_list></call> <operator>/</operator> <literal type="number">2</literal></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>b</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>dir</name> <init>= <expr><operator>(</operator><literal type="number">1</literal> <operator>-</operator> <name>b</name><operator>)</operator> <operator>/</operator> <literal type="number">2</literal></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>avlBalance</name><argument_list>(<argument><expr><name><name>current</name><operator>-&gt;</operator><name>children</name><index>[<expr><name>dir</name></expr>]</index></name></expr></argument>)</argument_list></call> <operator>==</operator> <operator>-</operator><name>b</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>avlRotate</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>current</name><operator>-&gt;</operator><name>children</name><index>[<expr><name>dir</name></expr>]</index></name></expr></argument>, <argument><expr><operator>!</operator><name>dir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>current</name> <operator>=</operator> <call><name>avlRotate</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>dir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>current</name> <operator>!=</operator> <name><name>tree</name><operator>-&gt;</operator><name>end</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>avlUpdateHeight</name><argument_list>(<argument><expr><name>current</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Insert a new value/field, starting from *node, reaching the correct position
 * in the tree by recursion.  Possibly rebalance the tree and possibly update
 * *node.  Do nothing if the value is already present in the tree.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>avlInsertNode</name><parameter_list>(<parameter><decl><type><name>avl_tree</name> <modifier>*</modifier></type><name>tree</name></decl></parameter>, <parameter><decl><type><name>avl_node</name> <modifier>*</modifier><modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>pivot_field</name></type> <name>field</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>avl_node</name>   <modifier>*</modifier></type><name>current</name> <init>= <expr><operator>*</operator><name>node</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>current</name> <operator>==</operator> <name><name>tree</name><operator>-&gt;</operator><name>end</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>avl_node</name>   <modifier>*</modifier></type><name>new_node</name> <init>= <expr><operator>(</operator><name>avl_node</name> <operator>*</operator><operator>)</operator>
		<call><name>pg_malloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>avl_node</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>new_node</name><operator>-&gt;</operator><name>height</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>new_node</name><operator>-&gt;</operator><name>field</name></name> <operator>=</operator> <name>field</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>new_node</name><operator>-&gt;</operator><name>children</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name><name>new_node</name><operator>-&gt;</operator><name>children</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name><name>tree</name><operator>-&gt;</operator><name>end</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>tree</name><operator>-&gt;</operator><name>count</name></name><operator>++</operator></expr>;</expr_stmt>
		<expr_stmt><expr><operator>*</operator><name>node</name> <operator>=</operator> <name>new_node</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>cmp</name> <init>= <expr><call><name>pivotFieldCompare</name><argument_list>(<argument><expr><operator>&amp;</operator><name>field</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>current</name><operator>-&gt;</operator><name>field</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>cmp</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>avlInsertNode</name><argument_list>(<argument><expr><name>tree</name></expr></argument>,
						  <argument><expr><ternary><condition><expr><name>cmp</name> <operator>&gt;</operator> <literal type="number">0</literal></expr> ?</condition><then> <expr><operator>&amp;</operator><name><name>current</name><operator>-&gt;</operator><name>children</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr> </then><else>: <expr><operator>&amp;</operator><name><name>current</name><operator>-&gt;</operator><name>children</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></else></ternary></expr></argument>,
						  <argument><expr><name>field</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>avlAdjustBalance</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/* Insert the value into the AVL tree, if it does not preexist */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>avlMergeValue</name><parameter_list>(<parameter><decl><type><name>avl_tree</name> <modifier>*</modifier></type><name>tree</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>sort_value</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>pivot_field</name></type> <name>field</name></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>field</name><operator>.</operator><name>name</name></name> <operator>=</operator> <name>name</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>field</name><operator>.</operator><name>rank</name></name> <operator>=</operator> <name><name>tree</name><operator>-&gt;</operator><name>count</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>field</name><operator>.</operator><name>sort_value</name></name> <operator>=</operator> <name>sort_value</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>avlInsertNode</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>tree</name><operator>-&gt;</operator><name>root</name></name></expr></argument>, <argument><expr><name>field</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Recursively extract node values into the names array, in sorted order with a
 * left-to-right tree traversal.
 * Return the next candidate offset to write into the names array.
 * fields[] must be preallocated to hold tree-&gt;count entries
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>avlCollectFields</name><parameter_list>(<parameter><decl><type><name>avl_tree</name> <modifier>*</modifier></type><name>tree</name></decl></parameter>, <parameter><decl><type><name>avl_node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>pivot_field</name> <modifier>*</modifier></type><name>fields</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>idx</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>node</name> <operator>==</operator> <name><name>tree</name><operator>-&gt;</operator><name>end</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>idx</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>idx</name> <operator>=</operator> <call><name>avlCollectFields</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>children</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name>fields</name></expr></argument>, <argument><expr><name>idx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fields</name><index>[<expr><name>idx</name></expr>]</index></name> <operator>=</operator> <name><name>node</name><operator>-&gt;</operator><name>field</name></name></expr>;</expr_stmt>
	<return>return <expr><call><name>avlCollectFields</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>children</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name>fields</name></expr></argument>, <argument><expr><name>idx</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>rankSort</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>num_columns</name></decl></parameter>, <parameter><decl><type><name>pivot_field</name> <modifier>*</modifier></type><name>piv_columns</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name>		   <modifier>*</modifier></type><name>hmap</name></decl>;</decl_stmt>			<comment type="block">/* [[offset in piv_columns, rank], ...for
								 * every header entry] */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>hmap</name> <operator>=</operator> <operator>(</operator><name>int</name> <operator>*</operator><operator>)</operator> <call><name>pg_malloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>num_columns</name> <operator>*</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>num_columns</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>val</name> <init>= <expr><name><name>piv_columns</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>sort_value</name></expr></init></decl>;</decl_stmt>

		<comment type="block">/* ranking information is valid if non null and matches /^-?\d+$/ */</comment>
		<if_stmt><if>if <condition>(<expr><name>val</name> <operator>&amp;&amp;</operator>
			<operator>(</operator><operator>(</operator><operator>*</operator><name>val</name> <operator>==</operator> <literal type="char">'-'</literal> <operator>&amp;&amp;</operator>
			  <call><name>strspn</name><argument_list>(<argument><expr><name>val</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><literal type="string">"0123456789"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>val</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>||</operator>
			 <call><name>strspn</name><argument_list>(<argument><expr><name>val</name></expr></argument>, <argument><expr><literal type="string">"0123456789"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>hmap</name><index>[<expr><name>i</name> <operator>*</operator> <literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <call><name>atoi</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>hmap</name><index>[<expr><name>i</name> <operator>*</operator> <literal type="number">2</literal> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/* invalid rank information ignored (equivalent to rank 0) */</comment>
			<expr_stmt><expr><name><name>hmap</name><index>[<expr><name>i</name> <operator>*</operator> <literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>hmap</name><index>[<expr><name>i</name> <operator>*</operator> <literal type="number">2</literal> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>qsort</name><argument_list>(<argument><expr><name>hmap</name></expr></argument>, <argument><expr><name>num_columns</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <literal type="number">2</literal></expr></argument>, <argument><expr><name>rankCompare</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>num_columns</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><name><name>piv_columns</name><index>[<expr><name><name>hmap</name><index>[<expr><name>i</name> <operator>*</operator> <literal type="number">2</literal> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></expr>]</index></name><operator>.</operator><name>rank</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>pg_free</name><argument_list>(<argument><expr><name>hmap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Look up a column reference, which can be either:
 * - a number from 1 to PQnfields(res)
 * - a column name matching one of PQfname(res,...)
 *
 * Returns zero-based column number, or -1 if not found or ambiguous.
 *
 * Note: may modify contents of "arg" string.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>indexOfColumn</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>PGresult</name> <modifier>*</modifier></type><name>res</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>idx</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>arg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&amp;&amp;</operator> <call><name>strspn</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><literal type="string">"0123456789"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* if arg contains only digits, it's a column number */</comment>
		<expr_stmt><expr><name>idx</name> <operator>=</operator> <call><name>atoi</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>idx</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator> <name>idx</name> <operator>&gt;=</operator> <call><name>PQnfields</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>psql_error</name><argument_list>(<argument><expr><literal type="string">"\\crosstabview: column number %d is out of range 1..%d\n"</literal></expr></argument>,
					   <argument><expr><name>idx</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><call><name>PQnfields</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * Dequote and downcase the column name.  By checking for all-digits
		 * before doing this, we can ensure that a quoted name is treated as a
		 * name even if it's all digits.
		 */</comment>
		<expr_stmt><expr><call><name>dequote_downcase_identifier</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name><name>pset</name><operator>.</operator><name>encoding</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Now look for match(es) among res' column names */</comment>
		<expr_stmt><expr><name>idx</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <call><name>PQnfields</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><call><name>PQfname</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name>idx</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/* another idx was already found for the same name */</comment>
					<expr_stmt><expr><call><name>psql_error</name><argument_list>(<argument><expr><literal type="string">"\\crosstabview: ambiguous column name: \"%s\"\n"</literal></expr></argument>, <argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
				</block_content>}</block></if></if_stmt>
				<expr_stmt><expr><name>idx</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></for>
		<if_stmt><if>if <condition>(<expr><name>idx</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>psql_error</name><argument_list>(<argument><expr><literal type="string">"\\crosstabview: column name not found: \"%s\"\n"</literal></expr></argument>, <argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></else></if_stmt>

	<return>return <expr><name>idx</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Value comparator for vertical and horizontal headers
 * used for deduplication only.
 * - null values are considered equal
 * - non-null &lt; null
 * - non-null values are compared with strcmp()
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>pivotFieldCompare</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>pivot_field</name> <modifier>*</modifier></type><name>pa</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>pivot_field</name> <operator>*</operator><operator>)</operator> <name>a</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>pivot_field</name> <modifier>*</modifier></type><name>pb</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>pivot_field</name> <operator>*</operator><operator>)</operator> <name>b</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* test null values */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>pb</name><operator>-&gt;</operator><name>name</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><ternary><condition><expr><name><name>pa</name><operator>-&gt;</operator><name>name</name></name></expr> ?</condition><then> <expr><operator>-</operator><literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr>;</return></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><operator>!</operator><name><name>pa</name><operator>-&gt;</operator><name>name</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* non-null values */</comment>
	<return>return <expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>pa</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name><name>pb</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>rankCompare</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><operator>*</operator><operator>(</operator><operator>(</operator><specifier>const</specifier> <name>int</name> <operator>*</operator><operator>)</operator> <name>a</name><operator>)</operator> <operator>-</operator> <operator>*</operator><operator>(</operator><operator>(</operator><specifier>const</specifier> <name>int</name> <operator>*</operator><operator>)</operator> <name>b</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>
</unit>
