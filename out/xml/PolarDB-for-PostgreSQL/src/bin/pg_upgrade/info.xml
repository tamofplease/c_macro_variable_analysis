<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/PolarDB-for-PostgreSQL/src/bin/pg_upgrade/info.c"><comment type="block">/*
 *	info.c
 *
 *	information support functions
 *
 *	Copyright (c) 2010-2018, PostgreSQL Global Development Group
 *	src/bin/pg_upgrade/info.c
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres_fe.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pg_upgrade.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/transam.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_class_d.h"</cpp:file></cpp:include>


<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>create_rel_filename_map</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>old_data</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>new_data</name></decl></parameter>,
						<parameter><decl><type><specifier>const</specifier> <name>DbInfo</name> <modifier>*</modifier></type><name>old_db</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>DbInfo</name> <modifier>*</modifier></type><name>new_db</name></decl></parameter>,
						<parameter><decl><type><specifier>const</specifier> <name>RelInfo</name> <modifier>*</modifier></type><name>old_rel</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>RelInfo</name> <modifier>*</modifier></type><name>new_rel</name></decl></parameter>,
						<parameter><decl><type><name>FileNameMap</name> <modifier>*</modifier></type><name>map</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>report_unmatched_relation</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>RelInfo</name> <modifier>*</modifier></type><name>rel</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>DbInfo</name> <modifier>*</modifier></type><name>db</name></decl></parameter>,
						  <parameter><decl><type><name>bool</name></type> <name>is_new_db</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>free_db_and_rel_infos</name><parameter_list>(<parameter><decl><type><name>DbInfoArr</name> <modifier>*</modifier></type><name>db_arr</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>get_db_infos</name><parameter_list>(<parameter><decl><type><name>ClusterInfo</name> <modifier>*</modifier></type><name>cluster</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>get_rel_infos</name><parameter_list>(<parameter><decl><type><name>ClusterInfo</name> <modifier>*</modifier></type><name>cluster</name></decl></parameter>, <parameter><decl><type><name>DbInfo</name> <modifier>*</modifier></type><name>dbinfo</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>free_rel_infos</name><parameter_list>(<parameter><decl><type><name>RelInfoArr</name> <modifier>*</modifier></type><name>rel_arr</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>print_db_infos</name><parameter_list>(<parameter><decl><type><name>DbInfoArr</name> <modifier>*</modifier></type><name>dbinfo</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>print_rel_infos</name><parameter_list>(<parameter><decl><type><name>RelInfoArr</name> <modifier>*</modifier></type><name>rel_arr</name></decl></parameter>)</parameter_list>;</function_decl>


<comment type="block">/*
 * gen_db_file_maps()
 *
 * generates a database mapping from "old_db" to "new_db".
 *
 * Returns a malloc'ed array of mappings.  The length of the array
 * is returned into *nmaps.
 */</comment>
<function><type><name>FileNameMap</name> <modifier>*</modifier></type>
<name>gen_db_file_maps</name><parameter_list>(<parameter><decl><type><name>DbInfo</name> <modifier>*</modifier></type><name>old_db</name></decl></parameter>, <parameter><decl><type><name>DbInfo</name> <modifier>*</modifier></type><name>new_db</name></decl></parameter>,
				 <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>nmaps</name></decl></parameter>,
				 <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>old_pgdata</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>new_pgdata</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>FileNameMap</name> <modifier>*</modifier></type><name>maps</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>old_relnum</name></decl>,
				<decl><type ref="prev"/><name>new_relnum</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>num_maps</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>all_matched</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* There will certainly not be more mappings than there are old rels */</comment>
	<expr_stmt><expr><name>maps</name> <operator>=</operator> <operator>(</operator><name>FileNameMap</name> <operator>*</operator><operator>)</operator> <call><name>pg_malloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>FileNameMap</name></expr></argument>)</argument_list></sizeof> <operator>*</operator>
									 <name><name>old_db</name><operator>-&gt;</operator><name>rel_arr</name><operator>.</operator><name>nrels</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Each of the RelInfo arrays should be sorted by OID.  Scan through them
	 * and match them up.  If we fail to match everything, we'll abort, but
	 * first print as much info as we can about mismatches.
	 */</comment>
	<expr_stmt><expr><name>old_relnum</name> <operator>=</operator> <name>new_relnum</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<while>while <condition>(<expr><name>old_relnum</name> <operator>&lt;</operator> <name><name>old_db</name><operator>-&gt;</operator><name>rel_arr</name><operator>.</operator><name>nrels</name></name> <operator>||</operator>
		   <name>new_relnum</name> <operator>&lt;</operator> <name><name>new_db</name><operator>-&gt;</operator><name>rel_arr</name><operator>.</operator><name>nrels</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>RelInfo</name>    <modifier>*</modifier></type><name>old_rel</name> <init>= <expr><ternary><condition><expr><operator>(</operator><name>old_relnum</name> <operator>&lt;</operator> <name><name>old_db</name><operator>-&gt;</operator><name>rel_arr</name><operator>.</operator><name>nrels</name></name><operator>)</operator></expr> ?</condition><then>
		<expr><operator>&amp;</operator><name><name>old_db</name><operator>-&gt;</operator><name>rel_arr</name><operator>.</operator><name>rels</name><index>[<expr><name>old_relnum</name></expr>]</index></name></expr> </then><else>: <expr><name>NULL</name></expr></else></ternary></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>RelInfo</name>    <modifier>*</modifier></type><name>new_rel</name> <init>= <expr><ternary><condition><expr><operator>(</operator><name>new_relnum</name> <operator>&lt;</operator> <name><name>new_db</name><operator>-&gt;</operator><name>rel_arr</name><operator>.</operator><name>nrels</name></name><operator>)</operator></expr> ?</condition><then>
		<expr><operator>&amp;</operator><name><name>new_db</name><operator>-&gt;</operator><name>rel_arr</name><operator>.</operator><name>rels</name><index>[<expr><name>new_relnum</name></expr>]</index></name></expr> </then><else>: <expr><name>NULL</name></expr></else></ternary></expr></init></decl>;</decl_stmt>

		<comment type="block">/* handle running off one array before the other */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>new_rel</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * old_rel is unmatched.  This should never happen, because we
			 * force new rels to have TOAST tables if the old one did.
			 */</comment>
			<expr_stmt><expr><call><name>report_unmatched_relation</name><argument_list>(<argument><expr><name>old_rel</name></expr></argument>, <argument><expr><name>old_db</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>all_matched</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>old_relnum</name><operator>++</operator></expr>;</expr_stmt>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>old_rel</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * new_rel is unmatched.  This shouldn't really happen either, but
			 * if it's a TOAST table, we can ignore it and continue
			 * processing, assuming that the new server made a TOAST table
			 * that wasn't needed.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>new_rel</name><operator>-&gt;</operator><name>nspname</name></name></expr></argument>, <argument><expr><literal type="string">"pg_toast"</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>report_unmatched_relation</name><argument_list>(<argument><expr><name>new_rel</name></expr></argument>, <argument><expr><name>new_db</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>all_matched</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			<expr_stmt><expr><name>new_relnum</name><operator>++</operator></expr>;</expr_stmt>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* check for mismatched OID */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>old_rel</name><operator>-&gt;</operator><name>reloid</name></name> <operator>&lt;</operator> <name><name>new_rel</name><operator>-&gt;</operator><name>reloid</name></name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* old_rel is unmatched, see comment above */</comment>
			<expr_stmt><expr><call><name>report_unmatched_relation</name><argument_list>(<argument><expr><name>old_rel</name></expr></argument>, <argument><expr><name>old_db</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>all_matched</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>old_relnum</name><operator>++</operator></expr>;</expr_stmt>
			<continue>continue;</continue>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name><name>old_rel</name><operator>-&gt;</operator><name>reloid</name></name> <operator>&gt;</operator> <name><name>new_rel</name><operator>-&gt;</operator><name>reloid</name></name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* new_rel is unmatched, see comment above */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>new_rel</name><operator>-&gt;</operator><name>nspname</name></name></expr></argument>, <argument><expr><literal type="string">"pg_toast"</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>report_unmatched_relation</name><argument_list>(<argument><expr><name>new_rel</name></expr></argument>, <argument><expr><name>new_db</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>all_matched</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			<expr_stmt><expr><name>new_relnum</name><operator>++</operator></expr>;</expr_stmt>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * Verify that rels of same OID have same name.  The namespace name
		 * should always match, but the relname might not match for TOAST
		 * tables (and, therefore, their indexes).
		 *
		 * TOAST table names initially match the heap pg_class oid, but
		 * pre-9.0 they can change during certain commands such as CLUSTER, so
		 * don't insist on a match if old cluster is &lt; 9.0.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>old_rel</name><operator>-&gt;</operator><name>nspname</name></name></expr></argument>, <argument><expr><name><name>new_rel</name><operator>-&gt;</operator><name>nspname</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal> <operator>||</operator>
			<operator>(</operator><call><name>strcmp</name><argument_list>(<argument><expr><name><name>old_rel</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>, <argument><expr><name><name>new_rel</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
			 <operator>(</operator><call><name>GET_MAJOR_VERSION</name><argument_list>(<argument><expr><name><name>old_cluster</name><operator>.</operator><name>major_version</name></name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <literal type="number">900</literal> <operator>||</operator>
			  <call><name>strcmp</name><argument_list>(<argument><expr><name><name>old_rel</name><operator>-&gt;</operator><name>nspname</name></name></expr></argument>, <argument><expr><literal type="string">"pg_toast"</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal><operator>)</operator><operator>)</operator></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>pg_log</name><argument_list>(<argument><expr><name>PG_WARNING</name></expr></argument>, <argument><expr><literal type="string">"Relation names for OID %u in database \"%s\" do not match: "</literal>
				   <literal type="string">"old name \"%s.%s\", new name \"%s.%s\"\n"</literal></expr></argument>,
				   <argument><expr><name><name>old_rel</name><operator>-&gt;</operator><name>reloid</name></name></expr></argument>, <argument><expr><name><name>old_db</name><operator>-&gt;</operator><name>db_name</name></name></expr></argument>,
				   <argument><expr><name><name>old_rel</name><operator>-&gt;</operator><name>nspname</name></name></expr></argument>, <argument><expr><name><name>old_rel</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>,
				   <argument><expr><name><name>new_rel</name><operator>-&gt;</operator><name>nspname</name></name></expr></argument>, <argument><expr><name><name>new_rel</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>all_matched</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>old_relnum</name><operator>++</operator></expr>;</expr_stmt>
			<expr_stmt><expr><name>new_relnum</name><operator>++</operator></expr>;</expr_stmt>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* OK, create a mapping entry */</comment>
		<expr_stmt><expr><call><name>create_rel_filename_map</name><argument_list>(<argument><expr><name>old_pgdata</name></expr></argument>, <argument><expr><name>new_pgdata</name></expr></argument>, <argument><expr><name>old_db</name></expr></argument>, <argument><expr><name>new_db</name></expr></argument>,
								<argument><expr><name>old_rel</name></expr></argument>, <argument><expr><name>new_rel</name></expr></argument>, <argument><expr><name>maps</name> <operator>+</operator> <name>num_maps</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>num_maps</name><operator>++</operator></expr>;</expr_stmt>
		<expr_stmt><expr><name>old_relnum</name><operator>++</operator></expr>;</expr_stmt>
		<expr_stmt><expr><name>new_relnum</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block></while>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>all_matched</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>pg_fatal</name><argument_list>(<argument><expr><literal type="string">"Failed to match up old and new tables in database \"%s\"\n"</literal></expr></argument>,
				 <argument><expr><name><name>old_db</name><operator>-&gt;</operator><name>db_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><operator>*</operator><name>nmaps</name> <operator>=</operator> <name>num_maps</name></expr>;</expr_stmt>
	<return>return <expr><name>maps</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * create_rel_filename_map()
 *
 * fills a file node map structure and returns it in "map".
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>create_rel_filename_map</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>old_data</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>new_data</name></decl></parameter>,
						<parameter><decl><type><specifier>const</specifier> <name>DbInfo</name> <modifier>*</modifier></type><name>old_db</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>DbInfo</name> <modifier>*</modifier></type><name>new_db</name></decl></parameter>,
						<parameter><decl><type><specifier>const</specifier> <name>RelInfo</name> <modifier>*</modifier></type><name>old_rel</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>RelInfo</name> <modifier>*</modifier></type><name>new_rel</name></decl></parameter>,
						<parameter><decl><type><name>FileNameMap</name> <modifier>*</modifier></type><name>map</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* In case old/new tablespaces don't match, do them separately. */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>strlen</name><argument_list>(<argument><expr><name><name>old_rel</name><operator>-&gt;</operator><name>tablespace</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * relation belongs to the default tablespace, hence relfiles should
		 * exist in the data directories.
		 */</comment>
		<expr_stmt><expr><name><name>map</name><operator>-&gt;</operator><name>old_tablespace</name></name> <operator>=</operator> <name>old_data</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>map</name><operator>-&gt;</operator><name>old_tablespace_suffix</name></name> <operator>=</operator> <literal type="string">"/base"</literal></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* relation belongs to a tablespace, so use the tablespace location */</comment>
		<expr_stmt><expr><name><name>map</name><operator>-&gt;</operator><name>old_tablespace</name></name> <operator>=</operator> <name><name>old_rel</name><operator>-&gt;</operator><name>tablespace</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>map</name><operator>-&gt;</operator><name>old_tablespace_suffix</name></name> <operator>=</operator> <name><name>old_cluster</name><operator>.</operator><name>tablespace_suffix</name></name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/* Do the same for new tablespaces */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>strlen</name><argument_list>(<argument><expr><name><name>new_rel</name><operator>-&gt;</operator><name>tablespace</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>map</name><operator>-&gt;</operator><name>new_tablespace</name></name> <operator>=</operator> <name>new_data</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>map</name><operator>-&gt;</operator><name>new_tablespace_suffix</name></name> <operator>=</operator> <literal type="string">"/base"</literal></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name><name>map</name><operator>-&gt;</operator><name>new_tablespace</name></name> <operator>=</operator> <name><name>new_rel</name><operator>-&gt;</operator><name>tablespace</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>map</name><operator>-&gt;</operator><name>new_tablespace_suffix</name></name> <operator>=</operator> <name><name>new_cluster</name><operator>.</operator><name>tablespace_suffix</name></name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><name><name>map</name><operator>-&gt;</operator><name>old_db_oid</name></name> <operator>=</operator> <name><name>old_db</name><operator>-&gt;</operator><name>db_oid</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>map</name><operator>-&gt;</operator><name>new_db_oid</name></name> <operator>=</operator> <name><name>new_db</name><operator>-&gt;</operator><name>db_oid</name></name></expr>;</expr_stmt>

	<comment type="block">/*
	 * old_relfilenode might differ from pg_class.oid (and hence
	 * new_relfilenode) because of CLUSTER, REINDEX, or VACUUM FULL.
	 */</comment>
	<expr_stmt><expr><name><name>map</name><operator>-&gt;</operator><name>old_relfilenode</name></name> <operator>=</operator> <name><name>old_rel</name><operator>-&gt;</operator><name>relfilenode</name></name></expr>;</expr_stmt>

	<comment type="block">/* new_relfilenode will match old and new pg_class.oid */</comment>
	<expr_stmt><expr><name><name>map</name><operator>-&gt;</operator><name>new_relfilenode</name></name> <operator>=</operator> <name><name>new_rel</name><operator>-&gt;</operator><name>relfilenode</name></name></expr>;</expr_stmt>

	<comment type="block">/* used only for logging and error reporting, old/new are identical */</comment>
	<expr_stmt><expr><name><name>map</name><operator>-&gt;</operator><name>nspname</name></name> <operator>=</operator> <name><name>old_rel</name><operator>-&gt;</operator><name>nspname</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>map</name><operator>-&gt;</operator><name>relname</name></name> <operator>=</operator> <name><name>old_rel</name><operator>-&gt;</operator><name>relname</name></name></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * Complain about a relation we couldn't match to the other database,
 * identifying it as best we can.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>report_unmatched_relation</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>RelInfo</name> <modifier>*</modifier></type><name>rel</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>DbInfo</name> <modifier>*</modifier></type><name>db</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>is_new_db</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>reloid</name> <init>= <expr><name><name>rel</name><operator>-&gt;</operator><name>reloid</name></name></expr></init></decl>;</decl_stmt>	<comment type="block">/* we might change rel below */</comment>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>reldesc</name><index>[<expr><literal type="number">1000</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>reldesc</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>reldesc</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"\"%s.%s\""</literal></expr></argument>,
			 <argument><expr><name><name>rel</name><operator>-&gt;</operator><name>nspname</name></name></expr></argument>, <argument><expr><name><name>rel</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>rel</name><operator>-&gt;</operator><name>indtable</name></name></expr>)</condition>
	<block>{<block_content>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>db</name><operator>-&gt;</operator><name>rel_arr</name><operator>.</operator><name>nrels</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><specifier>const</specifier> <name>RelInfo</name> <modifier>*</modifier></type><name>hrel</name> <init>= <expr><operator>&amp;</operator><name><name>db</name><operator>-&gt;</operator><name>rel_arr</name><operator>.</operator><name>rels</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>hrel</name><operator>-&gt;</operator><name>reloid</name></name> <operator>==</operator> <name><name>rel</name><operator>-&gt;</operator><name>indtable</name></name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>reldesc</name> <operator>+</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>reldesc</name></expr></argument>)</argument_list></call></expr></argument>,
						 <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>reldesc</name></expr></argument>)</argument_list></sizeof> <operator>-</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>reldesc</name></expr></argument>)</argument_list></call></expr></argument>,
						 <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">" which is an index on \"%s.%s\""</literal></expr></argument>)</argument_list></call></expr></argument>,
						 <argument><expr><name><name>hrel</name><operator>-&gt;</operator><name>nspname</name></name></expr></argument>, <argument><expr><name><name>hrel</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<comment type="block">/* Shift attention to index's table for toast check */</comment>
				<expr_stmt><expr><name>rel</name> <operator>=</operator> <name>hrel</name></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></for>
		<if_stmt><if>if <condition>(<expr><name>i</name> <operator>&gt;=</operator> <name><name>db</name><operator>-&gt;</operator><name>rel_arr</name><operator>.</operator><name>nrels</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>reldesc</name> <operator>+</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>reldesc</name></expr></argument>)</argument_list></call></expr></argument>,
					 <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>reldesc</name></expr></argument>)</argument_list></sizeof> <operator>-</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>reldesc</name></expr></argument>)</argument_list></call></expr></argument>,
					 <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">" which is an index on OID %u"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>rel</name><operator>-&gt;</operator><name>indtable</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>rel</name><operator>-&gt;</operator><name>toastheap</name></name></expr>)</condition>
	<block>{<block_content>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>db</name><operator>-&gt;</operator><name>rel_arr</name><operator>.</operator><name>nrels</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><specifier>const</specifier> <name>RelInfo</name> <modifier>*</modifier></type><name>brel</name> <init>= <expr><operator>&amp;</operator><name><name>db</name><operator>-&gt;</operator><name>rel_arr</name><operator>.</operator><name>rels</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>brel</name><operator>-&gt;</operator><name>reloid</name></name> <operator>==</operator> <name><name>rel</name><operator>-&gt;</operator><name>toastheap</name></name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>reldesc</name> <operator>+</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>reldesc</name></expr></argument>)</argument_list></call></expr></argument>,
						 <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>reldesc</name></expr></argument>)</argument_list></sizeof> <operator>-</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>reldesc</name></expr></argument>)</argument_list></call></expr></argument>,
						 <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">" which is the TOAST table for \"%s.%s\""</literal></expr></argument>)</argument_list></call></expr></argument>,
						 <argument><expr><name><name>brel</name><operator>-&gt;</operator><name>nspname</name></name></expr></argument>, <argument><expr><name><name>brel</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></for>
		<if_stmt><if>if <condition>(<expr><name>i</name> <operator>&gt;=</operator> <name><name>db</name><operator>-&gt;</operator><name>rel_arr</name><operator>.</operator><name>nrels</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>reldesc</name> <operator>+</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>reldesc</name></expr></argument>)</argument_list></call></expr></argument>,
					 <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>reldesc</name></expr></argument>)</argument_list></sizeof> <operator>-</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>reldesc</name></expr></argument>)</argument_list></call></expr></argument>,
					 <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">" which is the TOAST table for OID %u"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>rel</name><operator>-&gt;</operator><name>toastheap</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>is_new_db</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>pg_log</name><argument_list>(<argument><expr><name>PG_WARNING</name></expr></argument>, <argument><expr><literal type="string">"No match found in old cluster for new relation with OID %u in database \"%s\": %s\n"</literal></expr></argument>,
			   <argument><expr><name>reloid</name></expr></argument>, <argument><expr><name><name>db</name><operator>-&gt;</operator><name>db_name</name></name></expr></argument>, <argument><expr><name>reldesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>pg_log</name><argument_list>(<argument><expr><name>PG_WARNING</name></expr></argument>, <argument><expr><literal type="string">"No match found in new cluster for old relation with OID %u in database \"%s\": %s\n"</literal></expr></argument>,
			   <argument><expr><name>reloid</name></expr></argument>, <argument><expr><name><name>db</name><operator>-&gt;</operator><name>db_name</name></name></expr></argument>, <argument><expr><name>reldesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></function>


<function><type><name>void</name></type>
<name>print_maps</name><parameter_list>(<parameter><decl><type><name>FileNameMap</name> <modifier>*</modifier></type><name>maps</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>n_maps</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>db_name</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name><name>log_opts</name><operator>.</operator><name>verbose</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>mapnum</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>pg_log</name><argument_list>(<argument><expr><name>PG_VERBOSE</name></expr></argument>, <argument><expr><literal type="string">"mappings for database \"%s\":\n"</literal></expr></argument>, <argument><expr><name>db_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<for>for <control>(<init><expr><name>mapnum</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>mapnum</name> <operator>&lt;</operator> <name>n_maps</name></expr>;</condition> <incr><expr><name>mapnum</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>pg_log</name><argument_list>(<argument><expr><name>PG_VERBOSE</name></expr></argument>, <argument><expr><literal type="string">"%s.%s: %u to %u\n"</literal></expr></argument>,
				   <argument><expr><name><name>maps</name><index>[<expr><name>mapnum</name></expr>]</index></name><operator>.</operator><name>nspname</name></expr></argument>, <argument><expr><name><name>maps</name><index>[<expr><name>mapnum</name></expr>]</index></name><operator>.</operator><name>relname</name></expr></argument>,
				   <argument><expr><name><name>maps</name><index>[<expr><name>mapnum</name></expr>]</index></name><operator>.</operator><name>old_relfilenode</name></expr></argument>,
				   <argument><expr><name><name>maps</name><index>[<expr><name>mapnum</name></expr>]</index></name><operator>.</operator><name>new_relfilenode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>

		<expr_stmt><expr><call><name>pg_log</name><argument_list>(<argument><expr><name>PG_VERBOSE</name></expr></argument>, <argument><expr><literal type="string">"\n\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * get_db_and_rel_infos()
 *
 * higher level routine to generate dbinfos for the database running
 * on the given "port". Assumes that server is already running.
 */</comment>
<function><type><name>void</name></type>
<name>get_db_and_rel_infos</name><parameter_list>(<parameter><decl><type><name>ClusterInfo</name> <modifier>*</modifier></type><name>cluster</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>dbnum</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>cluster</name><operator>-&gt;</operator><name>dbarr</name><operator>.</operator><name>dbs</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>free_db_and_rel_infos</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>cluster</name><operator>-&gt;</operator><name>dbarr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>get_db_infos</name><argument_list>(<argument><expr><name>cluster</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>dbnum</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>dbnum</name> <operator>&lt;</operator> <name><name>cluster</name><operator>-&gt;</operator><name>dbarr</name><operator>.</operator><name>ndbs</name></name></expr>;</condition> <incr><expr><name>dbnum</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>get_rel_infos</name><argument_list>(<argument><expr><name>cluster</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>cluster</name><operator>-&gt;</operator><name>dbarr</name><operator>.</operator><name>dbs</name><index>[<expr><name>dbnum</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>

	<if_stmt><if>if <condition>(<expr><name>cluster</name> <operator>==</operator> <operator>&amp;</operator><name>old_cluster</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>pg_log</name><argument_list>(<argument><expr><name>PG_VERBOSE</name></expr></argument>, <argument><expr><literal type="string">"\nsource databases:\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>pg_log</name><argument_list>(<argument><expr><name>PG_VERBOSE</name></expr></argument>, <argument><expr><literal type="string">"\ntarget databases:\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>log_opts</name><operator>.</operator><name>verbose</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>print_db_infos</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>cluster</name><operator>-&gt;</operator><name>dbarr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * get_db_infos()
 *
 * Scans pg_database system catalog and populates all user
 * databases.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>get_db_infos</name><parameter_list>(<parameter><decl><type><name>ClusterInfo</name> <modifier>*</modifier></type><name>cluster</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PGconn</name>	   <modifier>*</modifier></type><name>conn</name> <init>= <expr><call><name>connectToServer</name><argument_list>(<argument><expr><name>cluster</name></expr></argument>, <argument><expr><literal type="string">"template1"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>ntups</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>tupnum</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>DbInfo</name>	   <modifier>*</modifier></type><name>dbinfos</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_datname</name></decl>,
				<decl><type ref="prev"/><name>i_oid</name></decl>,
				<decl><type ref="prev"/><name>i_encoding</name></decl>,
				<decl><type ref="prev"/><name>i_datcollate</name></decl>,
				<decl><type ref="prev"/><name>i_datctype</name></decl>,
				<decl><type ref="prev"/><name>i_spclocation</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>query</name><index>[<expr><name>QUERY_ALLOC</name></expr>]</index></name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></sizeof></expr></argument>,
			 <argument><expr><literal type="string">"SELECT d.oid, d.datname, d.encoding, d.datcollate, d.datctype, "</literal>
			 <literal type="string">"%s AS spclocation "</literal>
			 <literal type="string">"FROM pg_catalog.pg_database d "</literal>
			 <literal type="string">" LEFT OUTER JOIN pg_catalog.pg_tablespace t "</literal>
			 <literal type="string">" ON d.dattablespace = t.oid "</literal>
			 <literal type="string">"WHERE d.datallowconn = true "</literal>
	<comment type="block">/* we don't preserve pg_database.oid so we sort by name */</comment>
			 <literal type="string">"ORDER BY 2"</literal></expr></argument>,
	<comment type="block">/* 9.2 removed the spclocation column */</comment>
			 <argument><expr><ternary><condition><expr><operator>(</operator><call><name>GET_MAJOR_VERSION</name><argument_list>(<argument><expr><name><name>cluster</name><operator>-&gt;</operator><name>major_version</name></name></expr></argument>)</argument_list></call> <operator>&lt;=</operator> <literal type="number">901</literal><operator>)</operator></expr> ?</condition><then>
			 <expr><literal type="string">"t.spclocation"</literal></expr> </then><else>: <expr><literal type="string">"pg_catalog.pg_tablespace_location(t.oid)"</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>executeQueryOrDie</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>i_oid</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"oid"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_datname</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"datname"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_encoding</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"encoding"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_datcollate</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"datcollate"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_datctype</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"datctype"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_spclocation</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"spclocation"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>ntups</name> <operator>=</operator> <call><name>PQntuples</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>dbinfos</name> <operator>=</operator> <operator>(</operator><name>DbInfo</name> <operator>*</operator><operator>)</operator> <call><name>pg_malloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>DbInfo</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>ntups</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>tupnum</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>tupnum</name> <operator>&lt;</operator> <name>ntups</name></expr>;</condition> <incr><expr><name>tupnum</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><name><name>dbinfos</name><index>[<expr><name>tupnum</name></expr>]</index></name><operator>.</operator><name>db_oid</name> <operator>=</operator> <call><name>atooid</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>tupnum</name></expr></argument>, <argument><expr><name>i_oid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>dbinfos</name><index>[<expr><name>tupnum</name></expr>]</index></name><operator>.</operator><name>db_name</name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>tupnum</name></expr></argument>, <argument><expr><name>i_datname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>dbinfos</name><index>[<expr><name>tupnum</name></expr>]</index></name><operator>.</operator><name>db_encoding</name> <operator>=</operator> <call><name>atoi</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>tupnum</name></expr></argument>, <argument><expr><name>i_encoding</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>dbinfos</name><index>[<expr><name>tupnum</name></expr>]</index></name><operator>.</operator><name>db_collate</name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>tupnum</name></expr></argument>, <argument><expr><name>i_datcollate</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>dbinfos</name><index>[<expr><name>tupnum</name></expr>]</index></name><operator>.</operator><name>db_ctype</name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>tupnum</name></expr></argument>, <argument><expr><name>i_datctype</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name><name>dbinfos</name><index>[<expr><name>tupnum</name></expr>]</index></name><operator>.</operator><name>db_tablespace</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>dbinfos</name><index>[<expr><name>tupnum</name></expr>]</index></name><operator>.</operator><name>db_tablespace</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>,
				 <argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>tupnum</name></expr></argument>, <argument><expr><name>i_spclocation</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>
	<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PQfinish</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>cluster</name><operator>-&gt;</operator><name>dbarr</name><operator>.</operator><name>dbs</name></name> <operator>=</operator> <name>dbinfos</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>cluster</name><operator>-&gt;</operator><name>dbarr</name><operator>.</operator><name>ndbs</name></name> <operator>=</operator> <name>ntups</name></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * get_rel_infos()
 *
 * gets the relinfos for all the user tables and indexes of the database
 * referred to by "dbinfo".
 *
 * Note: the resulting RelInfo array is assumed to be sorted by OID.
 * This allows later processing to match up old and new databases efficiently.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>get_rel_infos</name><parameter_list>(<parameter><decl><type><name>ClusterInfo</name> <modifier>*</modifier></type><name>cluster</name></decl></parameter>, <parameter><decl><type><name>DbInfo</name> <modifier>*</modifier></type><name>dbinfo</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PGconn</name>	   <modifier>*</modifier></type><name>conn</name> <init>= <expr><call><name>connectToServer</name><argument_list>(<argument><expr><name>cluster</name></expr></argument>,
									   <argument><expr><name><name>dbinfo</name><operator>-&gt;</operator><name>db_name</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RelInfo</name>    <modifier>*</modifier></type><name>relinfos</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>ntups</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>relnum</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>num_rels</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>nspname</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>relname</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>tablespace</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_spclocation</name></decl>,
				<decl><type ref="prev"/><name>i_nspname</name></decl>,
				<decl><type ref="prev"/><name>i_relname</name></decl>,
				<decl><type ref="prev"/><name>i_reloid</name></decl>,
				<decl><type ref="prev"/><name>i_indtable</name></decl>,
				<decl><type ref="prev"/><name>i_toastheap</name></decl>,
				<decl><type ref="prev"/><name>i_relfilenode</name></decl>,
				<decl><type ref="prev"/><name>i_reltablespace</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>query</name><index>[<expr><name>QUERY_ALLOC</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>last_namespace</name> <init>= <expr><name>NULL</name></expr></init></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name>last_tablespace</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>query</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>			<comment type="block">/* initialize query string to empty */</comment>

	<comment type="block">/*
	 * Create a CTE that collects OIDs of regular user tables, including
	 * matviews and sequences, but excluding toast tables and indexes.  We
	 * assume that relations with OIDs &gt;= FirstNormalObjectId belong to the
	 * user.  (That's probably redundant with the namespace-name exclusions,
	 * but let's be safe.)
	 *
	 * pg_largeobject contains user data that does not appear in pg_dump
	 * output, so we have to copy that system table.  It's easiest to do that
	 * by treating it as a user table.  Likewise for pg_largeobject_metadata,
	 * if it exists.
	 */</comment>
	<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>query</name> <operator>+</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></sizeof> <operator>-</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr></argument>,
			 <argument><expr><literal type="string">"WITH regular_heap (reloid, indtable, toastheap) AS ( "</literal>
			 <literal type="string">"  SELECT c.oid, 0::oid, 0::oid "</literal>
			 <literal type="string">"  FROM pg_catalog.pg_class c JOIN pg_catalog.pg_namespace n "</literal>
			 <literal type="string">"         ON c.relnamespace = n.oid "</literal>
			 <literal type="string">"  WHERE relkind IN ("</literal> <call><name>CppAsString2</name><argument_list>(<argument><expr><name>RELKIND_RELATION</name></expr></argument>)</argument_list></call> <literal type="string">", "</literal>
			 <call><name>CppAsString2</name><argument_list>(<argument><expr><name>RELKIND_MATVIEW</name></expr></argument>)</argument_list></call> <literal type="string">") AND "</literal>
	<comment type="block">/* exclude possible orphaned temp tables */</comment>
			 <literal type="string">"    ((n.nspname !~ '^pg_temp_' AND "</literal>
			 <literal type="string">"      n.nspname !~ '^pg_toast_temp_' AND "</literal>
			 <literal type="string">"      n.nspname NOT IN ('pg_catalog', 'information_schema', "</literal>
			 <literal type="string">"                        'binary_upgrade', 'pg_toast') AND "</literal>
			 <literal type="string">"      c.oid &gt;= %u::pg_catalog.oid) OR "</literal>
			 <literal type="string">"     (n.nspname = 'pg_catalog' AND "</literal>
			 <literal type="string">"      relname IN ('pg_largeobject'%s) ))), "</literal></expr></argument>,
			 <argument><expr><name>FirstNormalObjectId</name></expr></argument>,
			 <argument><expr><ternary><condition><expr><operator>(</operator><call><name>GET_MAJOR_VERSION</name><argument_list>(<argument><expr><name><name>old_cluster</name><operator>.</operator><name>major_version</name></name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <literal type="number">900</literal><operator>)</operator></expr> ?</condition><then>
			 <expr><literal type="string">", 'pg_largeobject_metadata'"</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Add a CTE that collects OIDs of toast tables belonging to the tables
	 * selected by the regular_heap CTE.  (We have to do this separately
	 * because the namespace-name rules above don't work for toast tables.)
	 */</comment>
	<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>query</name> <operator>+</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></sizeof> <operator>-</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr></argument>,
			 <argument><expr><literal type="string">"  toast_heap (reloid, indtable, toastheap) AS ( "</literal>
			 <literal type="string">"  SELECT c.reltoastrelid, 0::oid, c.oid "</literal>
			 <literal type="string">"  FROM regular_heap JOIN pg_catalog.pg_class c "</literal>
			 <literal type="string">"      ON regular_heap.reloid = c.oid "</literal>
			 <literal type="string">"  WHERE c.reltoastrelid != 0), "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Add a CTE that collects OIDs of all valid indexes on the previously
	 * selected tables.  We can ignore invalid indexes since pg_dump does.
	 * Testing indisready is necessary in 9.2, and harmless in earlier/later
	 * versions.
	 */</comment>
	<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>query</name> <operator>+</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></sizeof> <operator>-</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr></argument>,
			 <argument><expr><literal type="string">"  all_index (reloid, indtable, toastheap) AS ( "</literal>
			 <literal type="string">"  SELECT indexrelid, indrelid, 0::oid "</literal>
			 <literal type="string">"  FROM pg_catalog.pg_index "</literal>
			 <literal type="string">"  WHERE indisvalid AND indisready "</literal>
			 <literal type="string">"    AND indrelid IN "</literal>
			 <literal type="string">"        (SELECT reloid FROM regular_heap "</literal>
			 <literal type="string">"         UNION ALL "</literal>
			 <literal type="string">"         SELECT reloid FROM toast_heap)) "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * And now we can write the query that retrieves the data we want for each
	 * heap and index relation.  Make sure result is sorted by OID.
	 */</comment>
	<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>query</name> <operator>+</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></sizeof> <operator>-</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr></argument>,
			 <argument><expr><literal type="string">"SELECT all_rels.*, n.nspname, c.relname, "</literal>
			 <literal type="string">"  c.relfilenode, c.reltablespace, %s "</literal>
			 <literal type="string">"FROM (SELECT * FROM regular_heap "</literal>
			 <literal type="string">"      UNION ALL "</literal>
			 <literal type="string">"      SELECT * FROM toast_heap "</literal>
			 <literal type="string">"      UNION ALL "</literal>
			 <literal type="string">"      SELECT * FROM all_index) all_rels "</literal>
			 <literal type="string">"  JOIN pg_catalog.pg_class c "</literal>
			 <literal type="string">"      ON all_rels.reloid = c.oid "</literal>
			 <literal type="string">"  JOIN pg_catalog.pg_namespace n "</literal>
			 <literal type="string">"     ON c.relnamespace = n.oid "</literal>
			 <literal type="string">"  LEFT OUTER JOIN pg_catalog.pg_tablespace t "</literal>
			 <literal type="string">"     ON c.reltablespace = t.oid "</literal>
			 <literal type="string">"ORDER BY 1;"</literal></expr></argument>,
	<comment type="block">/* 9.2 removed the pg_tablespace.spclocation column */</comment>
			 <argument><expr><ternary><condition><expr><operator>(</operator><call><name>GET_MAJOR_VERSION</name><argument_list>(<argument><expr><name><name>cluster</name><operator>-&gt;</operator><name>major_version</name></name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <literal type="number">902</literal><operator>)</operator></expr> ?</condition><then>
			 <expr><literal type="string">"pg_catalog.pg_tablespace_location(t.oid) AS spclocation"</literal></expr> </then><else>:
			 <expr><literal type="string">"t.spclocation"</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>executeQueryOrDie</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>ntups</name> <operator>=</operator> <call><name>PQntuples</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>relinfos</name> <operator>=</operator> <operator>(</operator><name>RelInfo</name> <operator>*</operator><operator>)</operator> <call><name>pg_malloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>RelInfo</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>ntups</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>i_reloid</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"reloid"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_indtable</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"indtable"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_toastheap</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"toastheap"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_nspname</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"nspname"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_relname</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"relname"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_relfilenode</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"relfilenode"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_reltablespace</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"reltablespace"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_spclocation</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"spclocation"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>relnum</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>relnum</name> <operator>&lt;</operator> <name>ntups</name></expr>;</condition> <incr><expr><name>relnum</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>RelInfo</name>    <modifier>*</modifier></type><name>curr</name> <init>= <expr><operator>&amp;</operator><name><name>relinfos</name><index>[<expr><name>num_rels</name><operator>++</operator></expr>]</index></name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>curr</name><operator>-&gt;</operator><name>reloid</name></name> <operator>=</operator> <call><name>atooid</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>relnum</name></expr></argument>, <argument><expr><name>i_reloid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>curr</name><operator>-&gt;</operator><name>indtable</name></name> <operator>=</operator> <call><name>atooid</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>relnum</name></expr></argument>, <argument><expr><name>i_indtable</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>curr</name><operator>-&gt;</operator><name>toastheap</name></name> <operator>=</operator> <call><name>atooid</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>relnum</name></expr></argument>, <argument><expr><name>i_toastheap</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>nspname</name> <operator>=</operator> <call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>relnum</name></expr></argument>, <argument><expr><name>i_nspname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>curr</name><operator>-&gt;</operator><name>nsp_alloc</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

		<comment type="block">/*
		 * Many of the namespace and tablespace strings are identical, so we
		 * try to reuse the allocated string pointers where possible to reduce
		 * memory consumption.
		 */</comment>
		<comment type="block">/* Can we reuse the previous string allocation? */</comment>
		<if_stmt><if>if <condition>(<expr><name>last_namespace</name> <operator>&amp;&amp;</operator> <call><name>strcmp</name><argument_list>(<argument><expr><name>nspname</name></expr></argument>, <argument><expr><name>last_namespace</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>curr</name><operator>-&gt;</operator><name>nspname</name></name> <operator>=</operator> <name>last_namespace</name></expr>;</expr_stmt></block_content></block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><name>last_namespace</name> <operator>=</operator> <name><name>curr</name><operator>-&gt;</operator><name>nspname</name></name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><name>nspname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>curr</name><operator>-&gt;</operator><name>nsp_alloc</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<expr_stmt><expr><name>relname</name> <operator>=</operator> <call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>relnum</name></expr></argument>, <argument><expr><name>i_relname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>curr</name><operator>-&gt;</operator><name>relname</name></name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><name>relname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>curr</name><operator>-&gt;</operator><name>relfilenode</name></name> <operator>=</operator> <call><name>atooid</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>relnum</name></expr></argument>, <argument><expr><name>i_relfilenode</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>curr</name><operator>-&gt;</operator><name>tblsp_alloc</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

		<comment type="block">/* Is the tablespace oid non-default? */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>atooid</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>relnum</name></expr></argument>, <argument><expr><name>i_reltablespace</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * The tablespace location might be "", meaning the cluster
			 * default location, i.e. pg_default or pg_global.
			 */</comment>
			<expr_stmt><expr><name>tablespace</name> <operator>=</operator> <call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>relnum</name></expr></argument>, <argument><expr><name>i_spclocation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* Can we reuse the previous string allocation? */</comment>
			<if_stmt><if>if <condition>(<expr><name>last_tablespace</name> <operator>&amp;&amp;</operator> <call><name>strcmp</name><argument_list>(<argument><expr><name>tablespace</name></expr></argument>, <argument><expr><name>last_tablespace</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>curr</name><operator>-&gt;</operator><name>tablespace</name></name> <operator>=</operator> <name>last_tablespace</name></expr>;</expr_stmt></block_content></block></if>
			<else>else
			<block>{<block_content>
				<expr_stmt><expr><name>last_tablespace</name> <operator>=</operator> <name><name>curr</name><operator>-&gt;</operator><name>tablespace</name></name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><name>tablespace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>curr</name><operator>-&gt;</operator><name>tblsp_alloc</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block></if>
		<else>else<block type="pseudo"><block_content>
			<comment type="block">/* A zero reltablespace oid indicates the database tablespace. */</comment>
			<expr_stmt><expr><name><name>curr</name><operator>-&gt;</operator><name>tablespace</name></name> <operator>=</operator> <name><name>dbinfo</name><operator>-&gt;</operator><name>db_tablespace</name></name></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></for>
	<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PQfinish</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>dbinfo</name><operator>-&gt;</operator><name>rel_arr</name><operator>.</operator><name>rels</name></name> <operator>=</operator> <name>relinfos</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>dbinfo</name><operator>-&gt;</operator><name>rel_arr</name><operator>.</operator><name>nrels</name></name> <operator>=</operator> <name>num_rels</name></expr>;</expr_stmt>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>void</name></type>
<name>free_db_and_rel_infos</name><parameter_list>(<parameter><decl><type><name>DbInfoArr</name> <modifier>*</modifier></type><name>db_arr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>dbnum</name></decl>;</decl_stmt>

	<for>for <control>(<init><expr><name>dbnum</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>dbnum</name> <operator>&lt;</operator> <name><name>db_arr</name><operator>-&gt;</operator><name>ndbs</name></name></expr>;</condition> <incr><expr><name>dbnum</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><call><name>free_rel_infos</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>db_arr</name><operator>-&gt;</operator><name>dbs</name><index>[<expr><name>dbnum</name></expr>]</index></name><operator>.</operator><name>rel_arr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pg_free</name><argument_list>(<argument><expr><name><name>db_arr</name><operator>-&gt;</operator><name>dbs</name><index>[<expr><name>dbnum</name></expr>]</index></name><operator>.</operator><name>db_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>
	<expr_stmt><expr><call><name>pg_free</name><argument_list>(<argument><expr><name><name>db_arr</name><operator>-&gt;</operator><name>dbs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>db_arr</name><operator>-&gt;</operator><name>dbs</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>db_arr</name><operator>-&gt;</operator><name>ndbs</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>void</name></type>
<name>free_rel_infos</name><parameter_list>(<parameter><decl><type><name>RelInfoArr</name> <modifier>*</modifier></type><name>rel_arr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>relnum</name></decl>;</decl_stmt>

	<for>for <control>(<init><expr><name>relnum</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>relnum</name> <operator>&lt;</operator> <name><name>rel_arr</name><operator>-&gt;</operator><name>nrels</name></name></expr>;</condition> <incr><expr><name>relnum</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>rel_arr</name><operator>-&gt;</operator><name>rels</name><index>[<expr><name>relnum</name></expr>]</index></name><operator>.</operator><name>nsp_alloc</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>pg_free</name><argument_list>(<argument><expr><name><name>rel_arr</name><operator>-&gt;</operator><name>rels</name><index>[<expr><name>relnum</name></expr>]</index></name><operator>.</operator><name>nspname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>pg_free</name><argument_list>(<argument><expr><name><name>rel_arr</name><operator>-&gt;</operator><name>rels</name><index>[<expr><name>relnum</name></expr>]</index></name><operator>.</operator><name>relname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>rel_arr</name><operator>-&gt;</operator><name>rels</name><index>[<expr><name>relnum</name></expr>]</index></name><operator>.</operator><name>tblsp_alloc</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>pg_free</name><argument_list>(<argument><expr><name><name>rel_arr</name><operator>-&gt;</operator><name>rels</name><index>[<expr><name>relnum</name></expr>]</index></name><operator>.</operator><name>tablespace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></for>
	<expr_stmt><expr><call><name>pg_free</name><argument_list>(<argument><expr><name><name>rel_arr</name><operator>-&gt;</operator><name>rels</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rel_arr</name><operator>-&gt;</operator><name>nrels</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>void</name></type>
<name>print_db_infos</name><parameter_list>(<parameter><decl><type><name>DbInfoArr</name> <modifier>*</modifier></type><name>db_arr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>dbnum</name></decl>;</decl_stmt>

	<for>for <control>(<init><expr><name>dbnum</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>dbnum</name> <operator>&lt;</operator> <name><name>db_arr</name><operator>-&gt;</operator><name>ndbs</name></name></expr>;</condition> <incr><expr><name>dbnum</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><call><name>pg_log</name><argument_list>(<argument><expr><name>PG_VERBOSE</name></expr></argument>, <argument><expr><literal type="string">"Database: %s\n"</literal></expr></argument>, <argument><expr><name><name>db_arr</name><operator>-&gt;</operator><name>dbs</name><index>[<expr><name>dbnum</name></expr>]</index></name><operator>.</operator><name>db_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>print_rel_infos</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>db_arr</name><operator>-&gt;</operator><name>dbs</name><index>[<expr><name>dbnum</name></expr>]</index></name><operator>.</operator><name>rel_arr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pg_log</name><argument_list>(<argument><expr><name>PG_VERBOSE</name></expr></argument>, <argument><expr><literal type="string">"\n\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>void</name></type>
<name>print_rel_infos</name><parameter_list>(<parameter><decl><type><name>RelInfoArr</name> <modifier>*</modifier></type><name>rel_arr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>relnum</name></decl>;</decl_stmt>

	<for>for <control>(<init><expr><name>relnum</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>relnum</name> <operator>&lt;</operator> <name><name>rel_arr</name><operator>-&gt;</operator><name>nrels</name></name></expr>;</condition> <incr><expr><name>relnum</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>pg_log</name><argument_list>(<argument><expr><name>PG_VERBOSE</name></expr></argument>, <argument><expr><literal type="string">"relname: %s.%s: reloid: %u reltblspace: %s\n"</literal></expr></argument>,
			   <argument><expr><name><name>rel_arr</name><operator>-&gt;</operator><name>rels</name><index>[<expr><name>relnum</name></expr>]</index></name><operator>.</operator><name>nspname</name></expr></argument>,
			   <argument><expr><name><name>rel_arr</name><operator>-&gt;</operator><name>rels</name><index>[<expr><name>relnum</name></expr>]</index></name><operator>.</operator><name>relname</name></expr></argument>,
			   <argument><expr><name><name>rel_arr</name><operator>-&gt;</operator><name>rels</name><index>[<expr><name>relnum</name></expr>]</index></name><operator>.</operator><name>reloid</name></expr></argument>,
			   <argument><expr><name><name>rel_arr</name><operator>-&gt;</operator><name>rels</name><index>[<expr><name>relnum</name></expr>]</index></name><operator>.</operator><name>tablespace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
</block_content>}</block></function>
</unit>
