<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/PolarDB-for-PostgreSQL/src/bin/pg_dump/pg_backup_db.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * pg_backup_db.c
 *
 *	Implements the basic DB functions used by the archiver.
 *
 * IDENTIFICATION
 *	  src/bin/pg_dump/pg_backup_db.c
 *
 *-------------------------------------------------------------------------
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres_fe.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"dumputils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"fe_utils/connect.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"fe_utils/string_utils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parallel.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pg_backup_archiver.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pg_backup_db.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pg_backup_utils.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;unistd.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;ctype.h&gt;</cpp:file></cpp:include>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_TERMIOS_H</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;termios.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>


<comment type="block">/* translator: this is a module name */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>modulename</name> <init>= <expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"archiver (db)"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>_check_database_version</name><parameter_list>(<parameter><decl><type><name>ArchiveHandle</name> <modifier>*</modifier></type><name>AH</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>PGconn</name> <modifier>*</modifier></type><name>_connectDB</name><parameter_list>(<parameter><decl><type><name>ArchiveHandle</name> <modifier>*</modifier></type><name>AH</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>newdbname</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>newUser</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>notice_processor</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>message</name></decl></parameter>)</parameter_list>;</function_decl>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_check_database_version</name><parameter_list>(<parameter><decl><type><name>ArchiveHandle</name> <modifier>*</modifier></type><name>AH</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>remoteversion_str</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>remoteversion</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>remoteversion_str</name> <operator>=</operator> <call><name>PQparameterStatus</name><argument_list>(<argument><expr><name><name>AH</name><operator>-&gt;</operator><name>connection</name></name></expr></argument>, <argument><expr><literal type="string">"server_version"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>remoteversion</name> <operator>=</operator> <call><name>PQserverVersion</name><argument_list>(<argument><expr><name><name>AH</name><operator>-&gt;</operator><name>connection</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>remoteversion</name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <operator>!</operator><name>remoteversion_str</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>exit_horribly</name><argument_list>(<argument><expr><name>modulename</name></expr></argument>, <argument><expr><literal type="string">"could not get server_version from libpq\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name><name>AH</name><operator>-&gt;</operator><name>public</name><operator>.</operator><name>remoteVersionStr</name></name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><name>remoteversion_str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>AH</name><operator>-&gt;</operator><name>public</name><operator>.</operator><name>remoteVersion</name></name> <operator>=</operator> <name>remoteversion</name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>AH</name><operator>-&gt;</operator><name>archiveRemoteVersion</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>AH</name><operator>-&gt;</operator><name>archiveRemoteVersion</name></name> <operator>=</operator> <name><name>AH</name><operator>-&gt;</operator><name>public</name><operator>.</operator><name>remoteVersionStr</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>remoteversion</name> <operator>!=</operator> <name>PG_VERSION_NUM</name>
		<operator>&amp;&amp;</operator> <operator>(</operator><name><name>remoteversion</name> <argument_list type="generic">&lt; <argument><expr><name><name>AH</name><operator>-&gt;</operator><name>public</name><operator>.</operator><name>minRemoteVersion</name></name> <operator>||</operator>
			<name>remoteversion</name></expr></argument> &gt;</argument_list></name> <name><name>AH</name><operator>-&gt;</operator><name>public</name><operator>.</operator><name>maxRemoteVersion</name></name><operator>)</operator></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>write_msg</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="string">"server version: %s; %s version: %s\n"</literal></expr></argument>,
				  <argument><expr><name>remoteversion_str</name></expr></argument>, <argument><expr><name>progname</name></expr></argument>, <argument><expr><name>PG_VERSION</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>exit_horribly</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="string">"aborting because of server version mismatch\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * When running against 9.0 or later, check if we are in recovery mode,
	 * which means we are on a hot standby.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>remoteversion</name> <operator>&gt;=</operator> <literal type="number">90000</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>ExecuteSqlQueryForSingleRow</name><argument_list>(<argument><expr><operator>(</operator><name>Archive</name> <operator>*</operator><operator>)</operator> <name>AH</name></expr></argument>, <argument><expr><literal type="string">"SELECT pg_catalog.pg_is_in_recovery()"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>AH</name><operator>-&gt;</operator><name>public</name><operator>.</operator><name>isStandby</name></name> <operator>=</operator> <operator>(</operator><call><name>strcmp</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"t"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>AH</name><operator>-&gt;</operator><name>public</name><operator>.</operator><name>isStandby</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Reconnect to the server.  If dbname is not NULL, use that database,
 * else the one associated with the archive handle.  If username is
 * not NULL, use that user name, else the one from the handle.
 */</comment>
<function><type><name>void</name></type>
<name>ReconnectToServer</name><parameter_list>(<parameter><decl><type><name>ArchiveHandle</name> <modifier>*</modifier></type><name>AH</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>dbname</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>username</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PGconn</name>	   <modifier>*</modifier></type><name>newConn</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>newdbname</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>newusername</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>dbname</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>newdbname</name> <operator>=</operator> <call><name>PQdb</name><argument_list>(<argument><expr><name><name>AH</name><operator>-&gt;</operator><name>connection</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>newdbname</name> <operator>=</operator> <name>dbname</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>username</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>newusername</name> <operator>=</operator> <call><name>PQuser</name><argument_list>(<argument><expr><name><name>AH</name><operator>-&gt;</operator><name>connection</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>newusername</name> <operator>=</operator> <name>username</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<expr_stmt><expr><name>newConn</name> <operator>=</operator> <call><name>_connectDB</name><argument_list>(<argument><expr><name>AH</name></expr></argument>, <argument><expr><name>newdbname</name></expr></argument>, <argument><expr><name>newusername</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Update ArchiveHandle's connCancel before closing old connection */</comment>
	<expr_stmt><expr><call><name>set_archive_cancel_info</name><argument_list>(<argument><expr><name>AH</name></expr></argument>, <argument><expr><name>newConn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PQfinish</name><argument_list>(<argument><expr><name><name>AH</name><operator>-&gt;</operator><name>connection</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>AH</name><operator>-&gt;</operator><name>connection</name></name> <operator>=</operator> <name>newConn</name></expr>;</expr_stmt>

	<comment type="block">/* Start strict; later phases may override this. */</comment>
	<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><call><name>ExecuteSqlQueryForSingleRow</name><argument_list>(<argument><expr><operator>(</operator><name>Archive</name> <operator>*</operator><operator>)</operator> <name>AH</name></expr></argument>,
										<argument><expr><name>ALWAYS_SECURE_SEARCH_PATH_SQL</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Connect to the db again.
 *
 * Note: it's not really all that sensible to use a single-entry password
 * cache if the username keeps changing.  In current usage, however, the
 * username never does change, so one savedPassword is sufficient.  We do
 * update the cache on the off chance that the password has changed since the
 * start of the run.
 */</comment>
<function><type><specifier>static</specifier> <name>PGconn</name> <modifier>*</modifier></type>
<name>_connectDB</name><parameter_list>(<parameter><decl><type><name>ArchiveHandle</name> <modifier>*</modifier></type><name>AH</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>reqdb</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>requser</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PQExpBufferData</name></type> <name>connstr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PGconn</name>	   <modifier>*</modifier></type><name>newConn</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>newdb</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>newuser</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>password</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>passbuf</name><index>[<expr><literal type="number">100</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>new_pass</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>reqdb</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>newdb</name> <operator>=</operator> <call><name>PQdb</name><argument_list>(<argument><expr><name><name>AH</name><operator>-&gt;</operator><name>connection</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>newdb</name> <operator>=</operator> <name>reqdb</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>requser</name> <operator>||</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>requser</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>newuser</name> <operator>=</operator> <call><name>PQuser</name><argument_list>(<argument><expr><name><name>AH</name><operator>-&gt;</operator><name>connection</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>newuser</name> <operator>=</operator> <name>requser</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<expr_stmt><expr><call><name>ahlog</name><argument_list>(<argument><expr><name>AH</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="string">"connecting to database \"%s\" as user \"%s\"\n"</literal></expr></argument>,
		  <argument><expr><name>newdb</name></expr></argument>, <argument><expr><name>newuser</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>password</name> <operator>=</operator> <name><name>AH</name><operator>-&gt;</operator><name>savedPassword</name></name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>AH</name><operator>-&gt;</operator><name>promptPassword</name></name> <operator>==</operator> <name>TRI_YES</name> <operator>&amp;&amp;</operator> <name>password</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>simple_prompt</name><argument_list>(<argument><expr><literal type="string">"Password: "</literal></expr></argument>, <argument><expr><name>passbuf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>passbuf</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>password</name> <operator>=</operator> <name>passbuf</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>initPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>connstr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>connstr</name></expr></argument>, <argument><expr><literal type="string">"dbname="</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>appendConnStrVal</name><argument_list>(<argument><expr><operator>&amp;</operator><name>connstr</name></expr></argument>, <argument><expr><name>newdb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<do>do
	<block>{<block_content>
		<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name><name>keywords</name><index>[<expr><literal type="number">7</literal></expr>]</index></name></decl>;</decl_stmt>
		<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name><name>values</name><index>[<expr><literal type="number">7</literal></expr>]</index></name></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>keywords</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="string">"host"</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>PQhost</name><argument_list>(<argument><expr><name><name>AH</name><operator>-&gt;</operator><name>connection</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>keywords</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <literal type="string">"port"</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>PQport</name><argument_list>(<argument><expr><name><name>AH</name><operator>-&gt;</operator><name>connection</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>keywords</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <literal type="string">"user"</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <name>newuser</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>keywords</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>=</operator> <literal type="string">"password"</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>=</operator> <name>password</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>keywords</name><index>[<expr><literal type="number">4</literal></expr>]</index></name> <operator>=</operator> <literal type="string">"dbname"</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">4</literal></expr>]</index></name> <operator>=</operator> <name><name>connstr</name><operator>.</operator><name>data</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>keywords</name><index>[<expr><literal type="number">5</literal></expr>]</index></name> <operator>=</operator> <literal type="string">"fallback_application_name"</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">5</literal></expr>]</index></name> <operator>=</operator> <name>progname</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>keywords</name><index>[<expr><literal type="number">6</literal></expr>]</index></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">6</literal></expr>]</index></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

		<expr_stmt><expr><name>new_pass</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>newConn</name> <operator>=</operator> <call><name>PQconnectdbParams</name><argument_list>(<argument><expr><name>keywords</name></expr></argument>, <argument><expr><name>values</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>newConn</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>exit_horribly</name><argument_list>(<argument><expr><name>modulename</name></expr></argument>, <argument><expr><literal type="string">"failed to reconnect to database\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>PQstatus</name><argument_list>(<argument><expr><name>newConn</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>CONNECTION_BAD</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>PQconnectionNeedsPassword</name><argument_list>(<argument><expr><name>newConn</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>exit_horribly</name><argument_list>(<argument><expr><name>modulename</name></expr></argument>, <argument><expr><literal type="string">"could not reconnect to database: %s"</literal></expr></argument>,
							  <argument><expr><call><name>PQerrorMessage</name><argument_list>(<argument><expr><name>newConn</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><call><name>PQfinish</name><argument_list>(<argument><expr><name>newConn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name>password</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"Password incorrect\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"Connecting to %s as %s\n"</literal></expr></argument>,
					<argument><expr><name>newdb</name></expr></argument>, <argument><expr><name>newuser</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>AH</name><operator>-&gt;</operator><name>promptPassword</name></name> <operator>!=</operator> <name>TRI_NO</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>simple_prompt</name><argument_list>(<argument><expr><literal type="string">"Password: "</literal></expr></argument>, <argument><expr><name>passbuf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>passbuf</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>password</name> <operator>=</operator> <name>passbuf</name></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>exit_horribly</name><argument_list>(<argument><expr><name>modulename</name></expr></argument>, <argument><expr><literal type="string">"connection needs password\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

			<expr_stmt><expr><name>new_pass</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block> while <condition>(<expr><name>new_pass</name></expr>)</condition>;</do>

	<comment type="block">/*
	 * We want to remember connection's actual password, whether or not we got
	 * it by prompting.  So we don't just store the password variable.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>PQconnectionUsedPassword</name><argument_list>(<argument><expr><name>newConn</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>AH</name><operator>-&gt;</operator><name>savedPassword</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>AH</name><operator>-&gt;</operator><name>savedPassword</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name><name>AH</name><operator>-&gt;</operator><name>savedPassword</name></name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><call><name>PQpass</name><argument_list>(<argument><expr><name>newConn</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>termPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>connstr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* check for version mismatch */</comment>
	<expr_stmt><expr><call><name>_check_database_version</name><argument_list>(<argument><expr><name>AH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PQsetNoticeProcessor</name><argument_list>(<argument><expr><name>newConn</name></expr></argument>, <argument><expr><name>notice_processor</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>newConn</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * Make a database connection with the given parameters.  The
 * connection handle is returned, the parameters are stored in AHX.
 * An interactive password prompt is automatically issued if required.
 *
 * Note: it's not really all that sensible to use a single-entry password
 * cache if the username keeps changing.  In current usage, however, the
 * username never does change, so one savedPassword is sufficient.
 */</comment>
<function><type><name>void</name></type>
<name>ConnectDatabase</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>AHX</name></decl></parameter>,
				<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>dbname</name></decl></parameter>,
				<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>pghost</name></decl></parameter>,
				<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>pgport</name></decl></parameter>,
				<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>username</name></decl></parameter>,
				<parameter><decl><type><name>trivalue</name></type> <name>prompt_password</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ArchiveHandle</name> <modifier>*</modifier></type><name>AH</name> <init>= <expr><operator>(</operator><name>ArchiveHandle</name> <operator>*</operator><operator>)</operator> <name>AHX</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>password</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>passbuf</name><index>[<expr><literal type="number">100</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>new_pass</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>AH</name><operator>-&gt;</operator><name>connection</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>exit_horribly</name><argument_list>(<argument><expr><name>modulename</name></expr></argument>, <argument><expr><literal type="string">"already connected to a database\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>password</name> <operator>=</operator> <name><name>AH</name><operator>-&gt;</operator><name>savedPassword</name></name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>prompt_password</name> <operator>==</operator> <name>TRI_YES</name> <operator>&amp;&amp;</operator> <name>password</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>simple_prompt</name><argument_list>(<argument><expr><literal type="string">"Password: "</literal></expr></argument>, <argument><expr><name>passbuf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>passbuf</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>password</name> <operator>=</operator> <name>passbuf</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name><name>AH</name><operator>-&gt;</operator><name>promptPassword</name></name> <operator>=</operator> <name>prompt_password</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Start the connection.  Loop until we have a password if requested by
	 * backend.
	 */</comment>
	<do>do
	<block>{<block_content>
		<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name><name>keywords</name><index>[<expr><literal type="number">7</literal></expr>]</index></name></decl>;</decl_stmt>
		<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name><name>values</name><index>[<expr><literal type="number">7</literal></expr>]</index></name></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>keywords</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="string">"host"</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>pghost</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>keywords</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <literal type="string">"port"</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>pgport</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>keywords</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <literal type="string">"user"</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <name>username</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>keywords</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>=</operator> <literal type="string">"password"</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>=</operator> <name>password</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>keywords</name><index>[<expr><literal type="number">4</literal></expr>]</index></name> <operator>=</operator> <literal type="string">"dbname"</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">4</literal></expr>]</index></name> <operator>=</operator> <name>dbname</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>keywords</name><index>[<expr><literal type="number">5</literal></expr>]</index></name> <operator>=</operator> <literal type="string">"fallback_application_name"</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">5</literal></expr>]</index></name> <operator>=</operator> <name>progname</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>keywords</name><index>[<expr><literal type="number">6</literal></expr>]</index></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">6</literal></expr>]</index></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

		<expr_stmt><expr><name>new_pass</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>AH</name><operator>-&gt;</operator><name>connection</name></name> <operator>=</operator> <call><name>PQconnectdbParams</name><argument_list>(<argument><expr><name>keywords</name></expr></argument>, <argument><expr><name>values</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>AH</name><operator>-&gt;</operator><name>connection</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>exit_horribly</name><argument_list>(<argument><expr><name>modulename</name></expr></argument>, <argument><expr><literal type="string">"failed to connect to database\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>PQstatus</name><argument_list>(<argument><expr><name><name>AH</name><operator>-&gt;</operator><name>connection</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <name>CONNECTION_BAD</name> <operator>&amp;&amp;</operator>
			<call><name>PQconnectionNeedsPassword</name><argument_list>(<argument><expr><name><name>AH</name><operator>-&gt;</operator><name>connection</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
			<name>password</name> <operator>==</operator> <name>NULL</name> <operator>&amp;&amp;</operator>
			<name>prompt_password</name> <operator>!=</operator> <name>TRI_NO</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>PQfinish</name><argument_list>(<argument><expr><name><name>AH</name><operator>-&gt;</operator><name>connection</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>simple_prompt</name><argument_list>(<argument><expr><literal type="string">"Password: "</literal></expr></argument>, <argument><expr><name>passbuf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>passbuf</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>password</name> <operator>=</operator> <name>passbuf</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>new_pass</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block> while <condition>(<expr><name>new_pass</name></expr>)</condition>;</do>

	<comment type="block">/* check to see that the backend connection was successfully made */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>PQstatus</name><argument_list>(<argument><expr><name><name>AH</name><operator>-&gt;</operator><name>connection</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <name>CONNECTION_BAD</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>exit_horribly</name><argument_list>(<argument><expr><name>modulename</name></expr></argument>, <argument><expr><literal type="string">"connection to database \"%s\" failed: %s"</literal></expr></argument>,
					  <argument><expr><ternary><condition><expr><call><name>PQdb</name><argument_list>(<argument><expr><name><name>AH</name><operator>-&gt;</operator><name>connection</name></name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><call><name>PQdb</name><argument_list>(<argument><expr><name><name>AH</name><operator>-&gt;</operator><name>connection</name></name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>,
					  <argument><expr><call><name>PQerrorMessage</name><argument_list>(<argument><expr><name><name>AH</name><operator>-&gt;</operator><name>connection</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Start strict; later phases may override this. */</comment>
	<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><call><name>ExecuteSqlQueryForSingleRow</name><argument_list>(<argument><expr><operator>(</operator><name>Archive</name> <operator>*</operator><operator>)</operator> <name>AH</name></expr></argument>,
										<argument><expr><name>ALWAYS_SECURE_SEARCH_PATH_SQL</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * We want to remember connection's actual password, whether or not we got
	 * it by prompting.  So we don't just store the password variable.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>PQconnectionUsedPassword</name><argument_list>(<argument><expr><name><name>AH</name><operator>-&gt;</operator><name>connection</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>AH</name><operator>-&gt;</operator><name>savedPassword</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>AH</name><operator>-&gt;</operator><name>savedPassword</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name><name>AH</name><operator>-&gt;</operator><name>savedPassword</name></name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><call><name>PQpass</name><argument_list>(<argument><expr><name><name>AH</name><operator>-&gt;</operator><name>connection</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* check for version mismatch */</comment>
	<expr_stmt><expr><call><name>_check_database_version</name><argument_list>(<argument><expr><name>AH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PQsetNoticeProcessor</name><argument_list>(<argument><expr><name><name>AH</name><operator>-&gt;</operator><name>connection</name></name></expr></argument>, <argument><expr><name>notice_processor</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* arrange for SIGINT to issue a query cancel on this connection */</comment>
	<expr_stmt><expr><call><name>set_archive_cancel_info</name><argument_list>(<argument><expr><name>AH</name></expr></argument>, <argument><expr><name><name>AH</name><operator>-&gt;</operator><name>connection</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Close the connection to the database and also cancel off the query if we
 * have one running.
 */</comment>
<function><type><name>void</name></type>
<name>DisconnectDatabase</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>AHX</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ArchiveHandle</name> <modifier>*</modifier></type><name>AH</name> <init>= <expr><operator>(</operator><name>ArchiveHandle</name> <operator>*</operator><operator>)</operator> <name>AHX</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>errbuf</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>AH</name><operator>-&gt;</operator><name>connection</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>AH</name><operator>-&gt;</operator><name>connCancel</name></name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * If we have an active query, send a cancel before closing, ignoring
		 * any errors.  This is of no use for a normal exit, but might be
		 * helpful during exit_horribly().
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>PQtransactionStatus</name><argument_list>(<argument><expr><name><name>AH</name><operator>-&gt;</operator><name>connection</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <name>PQTRANS_ACTIVE</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>PQcancel</name><argument_list>(<argument><expr><name><name>AH</name><operator>-&gt;</operator><name>connCancel</name></name></expr></argument>, <argument><expr><name>errbuf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>errbuf</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * Prevent signal handler from sending a cancel after this.
		 */</comment>
		<expr_stmt><expr><call><name>set_archive_cancel_info</name><argument_list>(<argument><expr><name>AH</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>PQfinish</name><argument_list>(<argument><expr><name><name>AH</name><operator>-&gt;</operator><name>connection</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>AH</name><operator>-&gt;</operator><name>connection</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>PGconn</name> <modifier>*</modifier></type>
<name>GetConnection</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>AHX</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ArchiveHandle</name> <modifier>*</modifier></type><name>AH</name> <init>= <expr><operator>(</operator><name>ArchiveHandle</name> <operator>*</operator><operator>)</operator> <name>AHX</name></expr></init></decl>;</decl_stmt>

	<return>return <expr><name><name>AH</name><operator>-&gt;</operator><name>connection</name></name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>notice_processor</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>message</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>write_msg</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name>message</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Like exit_horribly(), but with a complaint about a particular query. */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>die_on_query_failure</name><parameter_list>(<parameter><decl><type><name>ArchiveHandle</name> <modifier>*</modifier></type><name>AH</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>modulename</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>query</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>write_msg</name><argument_list>(<argument><expr><name>modulename</name></expr></argument>, <argument><expr><literal type="string">"query failed: %s"</literal></expr></argument>,
			  <argument><expr><call><name>PQerrorMessage</name><argument_list>(<argument><expr><name><name>AH</name><operator>-&gt;</operator><name>connection</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>exit_horribly</name><argument_list>(<argument><expr><name>modulename</name></expr></argument>, <argument><expr><literal type="string">"query was: %s\n"</literal></expr></argument>, <argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>ExecuteSqlStatement</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>AHX</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>query</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ArchiveHandle</name> <modifier>*</modifier></type><name>AH</name> <init>= <expr><operator>(</operator><name>ArchiveHandle</name> <operator>*</operator><operator>)</operator> <name>AHX</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>PQexec</name><argument_list>(<argument><expr><name><name>AH</name><operator>-&gt;</operator><name>connection</name></name></expr></argument>, <argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>PQresultStatus</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>PGRES_COMMAND_OK</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>die_on_query_failure</name><argument_list>(<argument><expr><name>AH</name></expr></argument>, <argument><expr><name>modulename</name></expr></argument>, <argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>PGresult</name> <modifier>*</modifier></type>
<name>ExecuteSqlQuery</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>AHX</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>query</name></decl></parameter>, <parameter><decl><type><name>ExecStatusType</name></type> <name>status</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ArchiveHandle</name> <modifier>*</modifier></type><name>AH</name> <init>= <expr><operator>(</operator><name>ArchiveHandle</name> <operator>*</operator><operator>)</operator> <name>AHX</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>PQexec</name><argument_list>(<argument><expr><name><name>AH</name><operator>-&gt;</operator><name>connection</name></name></expr></argument>, <argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>PQresultStatus</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>status</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>die_on_query_failure</name><argument_list>(<argument><expr><name>AH</name></expr></argument>, <argument><expr><name>modulename</name></expr></argument>, <argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<return>return <expr><name>res</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Execute an SQL query and verify that we got exactly one row back.
 */</comment>
<function><type><name>PGresult</name> <modifier>*</modifier></type>
<name>ExecuteSqlQueryForSingleRow</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>query</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>ntups</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>ExecuteSqlQuery</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name>query</name></expr></argument>, <argument><expr><name>PGRES_TUPLES_OK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Expecting a single result only */</comment>
	<expr_stmt><expr><name>ntups</name> <operator>=</operator> <call><name>PQntuples</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>ntups</name> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>exit_horribly</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>,
					  <argument><expr><call><name>ngettext</name><argument_list>(<argument><expr><literal type="string">"query returned %d row instead of one: %s\n"</literal></expr></argument>,
							   <argument><expr><literal type="string">"query returned %d rows instead of one: %s\n"</literal></expr></argument>,
							   <argument><expr><name>ntups</name></expr></argument>)</argument_list></call></expr></argument>,
					  <argument><expr><name>ntups</name></expr></argument>, <argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>res</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Convenience function to send a query.
 * Monitors result to detect COPY statements
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ExecuteSqlCommand</name><parameter_list>(<parameter><decl><type><name>ArchiveHandle</name> <modifier>*</modifier></type><name>AH</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>qry</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>desc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PGconn</name>	   <modifier>*</modifier></type><name>conn</name> <init>= <expr><name><name>AH</name><operator>-&gt;</operator><name>connection</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>NOT_USED</name></cpp:ifdef>
	<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"Executing: '%s'\n\n"</literal></expr></argument>, <argument><expr><name>qry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>PQexec</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>qry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<switch>switch <condition>(<expr><call><name>PQresultStatus</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>PGRES_COMMAND_OK</name></expr>:</case>
		<case>case <expr><name>PGRES_TUPLES_OK</name></expr>:</case>
		<case>case <expr><name>PGRES_EMPTY_QUERY</name></expr>:</case>
			<comment type="block">/* A-OK */</comment>
			<break>break;</break>
		<case>case <expr><name>PGRES_COPY_IN</name></expr>:</case>
			<comment type="block">/* Assume this is an expected result */</comment>
			<expr_stmt><expr><name><name>AH</name><operator>-&gt;</operator><name>pgCopyIn</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<break>break;</break>
		<default>default:</default>
			<comment type="block">/* trouble */</comment>
			<expr_stmt><expr><call><name>warn_or_exit_horribly</name><argument_list>(<argument><expr><name>AH</name></expr></argument>, <argument><expr><name>modulename</name></expr></argument>, <argument><expr><literal type="string">"%s: %s    Command was: %s\n"</literal></expr></argument>,
								  <argument><expr><name>desc</name></expr></argument>, <argument><expr><call><name>PQerrorMessage</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>qry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
	</block_content>}</block></switch>

	<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * Process non-COPY table data (that is, INSERT commands).
 *
 * The commands have been run together as one long string for compressibility,
 * and we are receiving them in bufferloads with arbitrary boundaries, so we
 * have to locate command boundaries and save partial commands across calls.
 * All state must be kept in AH-&gt;sqlparse, not in local variables of this
 * routine.  We assume that AH-&gt;sqlparse was filled with zeroes when created.
 *
 * We have to lex the data to the extent of identifying literals and quoted
 * identifiers, so that we can recognize statement-terminating semicolons.
 * We assume that INSERT data will not contain SQL comments, E'' literals,
 * or dollar-quoted strings, so this is much simpler than a full SQL lexer.
 *
 * Note: when restoring from a pre-9.0 dump file, this code is also used to
 * process BLOB COMMENTS data, which has the same problem of containing
 * multiple SQL commands that might be split across bufferloads.  Fortunately,
 * that data won't contain anything complicated to lex either.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ExecuteSimpleCommands</name><parameter_list>(<parameter><decl><type><name>ArchiveHandle</name> <modifier>*</modifier></type><name>AH</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>bufLen</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>qry</name> <init>= <expr><name>buf</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>eos</name> <init>= <expr><name>buf</name> <operator>+</operator> <name>bufLen</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* initialize command buffer if first time through */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>AH</name><operator>-&gt;</operator><name>sqlparse</name><operator>.</operator><name>curCmd</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>AH</name><operator>-&gt;</operator><name>sqlparse</name><operator>.</operator><name>curCmd</name></name> <operator>=</operator> <call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<for>for <control>(<init>;</init> <condition><expr><name>qry</name> <operator>&lt;</operator> <name>eos</name></expr>;</condition> <incr><expr><name>qry</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name></type>		<name>ch</name> <init>= <expr><operator>*</operator><name>qry</name></expr></init></decl>;</decl_stmt>

		<comment type="block">/* For neatness, we skip any newlines between commands */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>ch</name> <operator>==</operator> <literal type="char">'\n'</literal> <operator>&amp;&amp;</operator> <name><name>AH</name><operator>-&gt;</operator><name>sqlparse</name><operator>.</operator><name>curCmd</name><operator>-&gt;</operator><name>len</name></name> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendPQExpBufferChar</name><argument_list>(<argument><expr><name><name>AH</name><operator>-&gt;</operator><name>sqlparse</name><operator>.</operator><name>curCmd</name></name></expr></argument>, <argument><expr><name>ch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<switch>switch <condition>(<expr><name><name>AH</name><operator>-&gt;</operator><name>sqlparse</name><operator>.</operator><name>state</name></name></expr>)</condition>
		<block>{<block_content>
			<case>case <expr><name>SQL_SCAN</name></expr>:</case>		<comment type="block">/* Default state == 0, set in _allocAH */</comment>
				<if_stmt><if>if <condition>(<expr><name>ch</name> <operator>==</operator> <literal type="char">';'</literal></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/*
					 * We've found the end of a statement. Send it and reset
					 * the buffer.
					 */</comment>
					<expr_stmt><expr><call><name>ExecuteSqlCommand</name><argument_list>(<argument><expr><name>AH</name></expr></argument>, <argument><expr><name><name>AH</name><operator>-&gt;</operator><name>sqlparse</name><operator>.</operator><name>curCmd</name><operator>-&gt;</operator><name>data</name></name></expr></argument>,
									  <argument><expr><literal type="string">"could not execute query"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>resetPQExpBuffer</name><argument_list>(<argument><expr><name><name>AH</name><operator>-&gt;</operator><name>sqlparse</name><operator>.</operator><name>curCmd</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if>
				<if type="elseif">else if <condition>(<expr><name>ch</name> <operator>==</operator> <literal type="char">'\''</literal></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name><name>AH</name><operator>-&gt;</operator><name>sqlparse</name><operator>.</operator><name>state</name></name> <operator>=</operator> <name>SQL_IN_SINGLE_QUOTE</name></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>AH</name><operator>-&gt;</operator><name>sqlparse</name><operator>.</operator><name>backSlash</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
				</block_content>}</block></if>
				<if type="elseif">else if <condition>(<expr><name>ch</name> <operator>==</operator> <literal type="char">'"'</literal></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name><name>AH</name><operator>-&gt;</operator><name>sqlparse</name><operator>.</operator><name>state</name></name> <operator>=</operator> <name>SQL_IN_DOUBLE_QUOTE</name></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
				<break>break;</break>

			<case>case <expr><name>SQL_IN_SINGLE_QUOTE</name></expr>:</case>
				<comment type="block">/* We needn't handle '' specially */</comment>
				<if_stmt><if>if <condition>(<expr><name>ch</name> <operator>==</operator> <literal type="char">'\''</literal> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>AH</name><operator>-&gt;</operator><name>sqlparse</name><operator>.</operator><name>backSlash</name></name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name><name>AH</name><operator>-&gt;</operator><name>sqlparse</name><operator>.</operator><name>state</name></name> <operator>=</operator> <name>SQL_SCAN</name></expr>;</expr_stmt></block_content></block></if>
				<if type="elseif">else if <condition>(<expr><name>ch</name> <operator>==</operator> <literal type="char">'\\'</literal> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>AH</name><operator>-&gt;</operator><name>public</name><operator>.</operator><name>std_strings</name></name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name><name>AH</name><operator>-&gt;</operator><name>sqlparse</name><operator>.</operator><name>backSlash</name></name> <operator>=</operator> <operator>!</operator><name><name>AH</name><operator>-&gt;</operator><name>sqlparse</name><operator>.</operator><name>backSlash</name></name></expr>;</expr_stmt></block_content></block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><name><name>AH</name><operator>-&gt;</operator><name>sqlparse</name><operator>.</operator><name>backSlash</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
				<break>break;</break>

			<case>case <expr><name>SQL_IN_DOUBLE_QUOTE</name></expr>:</case>
				<comment type="block">/* We needn't handle "" specially */</comment>
				<if_stmt><if>if <condition>(<expr><name>ch</name> <operator>==</operator> <literal type="char">'"'</literal></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name><name>AH</name><operator>-&gt;</operator><name>sqlparse</name><operator>.</operator><name>state</name></name> <operator>=</operator> <name>SQL_SCAN</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<break>break;</break>
		</block_content>}</block></switch>
	</block_content>}</block></for>
</block_content>}</block></function>


<comment type="block">/*
 * Implement ahwrite() for direct-to-DB restore
 */</comment>
<function><type><name>int</name></type>
<name>ExecuteSqlCommandBuf</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>AHX</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>bufLen</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ArchiveHandle</name> <modifier>*</modifier></type><name>AH</name> <init>= <expr><operator>(</operator><name>ArchiveHandle</name> <operator>*</operator><operator>)</operator> <name>AHX</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>AH</name><operator>-&gt;</operator><name>outputKind</name></name> <operator>==</operator> <name>OUTPUT_COPYDATA</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * COPY data.
		 *
		 * We drop the data on the floor if libpq has failed to enter COPY
		 * mode; this allows us to behave reasonably when trying to continue
		 * after an error in a COPY command.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>AH</name><operator>-&gt;</operator><name>pgCopyIn</name></name> <operator>&amp;&amp;</operator>
			<call><name>PQputCopyData</name><argument_list>(<argument><expr><name><name>AH</name><operator>-&gt;</operator><name>connection</name></name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>bufLen</name></expr></argument>)</argument_list></call> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>exit_horribly</name><argument_list>(<argument><expr><name>modulename</name></expr></argument>, <argument><expr><literal type="string">"error returned by PQputCopyData: %s"</literal></expr></argument>,
						  <argument><expr><call><name>PQerrorMessage</name><argument_list>(<argument><expr><name><name>AH</name><operator>-&gt;</operator><name>connection</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name><name>AH</name><operator>-&gt;</operator><name>outputKind</name></name> <operator>==</operator> <name>OUTPUT_OTHERDATA</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Table data expressed as INSERT commands; or, in old dump files,
		 * BLOB COMMENTS data (which is expressed as COMMENT ON commands).
		 */</comment>
		<expr_stmt><expr><call><name>ExecuteSimpleCommands</name><argument_list>(<argument><expr><name>AH</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>bufLen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/*
		 * General SQL commands; we assume that commands will not be split
		 * across calls.
		 *
		 * In most cases the data passed to us will be a null-terminated
		 * string, but if it's not, we have to add a trailing null.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>buf</name><index>[<expr><name>bufLen</name></expr>]</index></name> <operator>==</operator> <literal type="char">'\0'</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ExecuteSqlCommand</name><argument_list>(<argument><expr><name>AH</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"could not execute query"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else
		<block>{<block_content>
			<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>str</name> <init>= <expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>pg_malloc</name><argument_list>(<argument><expr><name>bufLen</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>bufLen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>str</name><index>[<expr><name>bufLen</name></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>ExecuteSqlCommand</name><argument_list>(<argument><expr><name>AH</name></expr></argument>, <argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">"could not execute query"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></else></if_stmt>

	<return>return <expr><name>bufLen</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Terminate a COPY operation during direct-to-DB restore
 */</comment>
<function><type><name>void</name></type>
<name>EndDBCopyMode</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>AHX</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>tocEntryTag</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ArchiveHandle</name> <modifier>*</modifier></type><name>AH</name> <init>= <expr><operator>(</operator><name>ArchiveHandle</name> <operator>*</operator><operator>)</operator> <name>AHX</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>AH</name><operator>-&gt;</operator><name>pgCopyIn</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>PQputCopyEnd</name><argument_list>(<argument><expr><name><name>AH</name><operator>-&gt;</operator><name>connection</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>exit_horribly</name><argument_list>(<argument><expr><name>modulename</name></expr></argument>, <argument><expr><literal type="string">"error returned by PQputCopyEnd: %s"</literal></expr></argument>,
						  <argument><expr><call><name>PQerrorMessage</name><argument_list>(<argument><expr><name><name>AH</name><operator>-&gt;</operator><name>connection</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/* Check command status and return to normal libpq state */</comment>
		<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>PQgetResult</name><argument_list>(<argument><expr><name><name>AH</name><operator>-&gt;</operator><name>connection</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>PQresultStatus</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>PGRES_COMMAND_OK</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>warn_or_exit_horribly</name><argument_list>(<argument><expr><name>AH</name></expr></argument>, <argument><expr><name>modulename</name></expr></argument>, <argument><expr><literal type="string">"COPY failed for table \"%s\": %s"</literal></expr></argument>,
								  <argument><expr><name>tocEntryTag</name></expr></argument>, <argument><expr><call><name>PQerrorMessage</name><argument_list>(<argument><expr><name><name>AH</name><operator>-&gt;</operator><name>connection</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Do this to ensure we've pumped libpq back to idle state */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>PQgetResult</name><argument_list>(<argument><expr><name><name>AH</name><operator>-&gt;</operator><name>connection</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>write_msg</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="string">"WARNING: unexpected extra results during COPY of table \"%s\"\n"</literal></expr></argument>,
					  <argument><expr><name>tocEntryTag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name><name>AH</name><operator>-&gt;</operator><name>pgCopyIn</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>StartTransaction</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>AHX</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ArchiveHandle</name> <modifier>*</modifier></type><name>AH</name> <init>= <expr><operator>(</operator><name>ArchiveHandle</name> <operator>*</operator><operator>)</operator> <name>AHX</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>ExecuteSqlCommand</name><argument_list>(<argument><expr><name>AH</name></expr></argument>, <argument><expr><literal type="string">"BEGIN"</literal></expr></argument>, <argument><expr><literal type="string">"could not start database transaction"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>CommitTransaction</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>AHX</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ArchiveHandle</name> <modifier>*</modifier></type><name>AH</name> <init>= <expr><operator>(</operator><name>ArchiveHandle</name> <operator>*</operator><operator>)</operator> <name>AHX</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>ExecuteSqlCommand</name><argument_list>(<argument><expr><name>AH</name></expr></argument>, <argument><expr><literal type="string">"COMMIT"</literal></expr></argument>, <argument><expr><literal type="string">"could not commit database transaction"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>DropBlobIfExists</name><parameter_list>(<parameter><decl><type><name>ArchiveHandle</name> <modifier>*</modifier></type><name>AH</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>oid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * If we are not restoring to a direct database connection, we have to
	 * guess about how to detect whether the blob exists.  Assume new-style.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>AH</name><operator>-&gt;</operator><name>connection</name></name> <operator>==</operator> <name>NULL</name> <operator>||</operator>
		<call><name>PQserverVersion</name><argument_list>(<argument><expr><name><name>AH</name><operator>-&gt;</operator><name>connection</name></name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <literal type="number">90000</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ahprintf</name><argument_list>(<argument><expr><name>AH</name></expr></argument>,
				 <argument><expr><literal type="string">"SELECT pg_catalog.lo_unlink(oid) "</literal>
				 <literal type="string">"FROM pg_catalog.pg_largeobject_metadata "</literal>
				 <literal type="string">"WHERE oid = '%u';\n"</literal></expr></argument>,
				 <argument><expr><name>oid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* Restoring to pre-9.0 server, so do it the old way */</comment>
		<expr_stmt><expr><call><name>ahprintf</name><argument_list>(<argument><expr><name>AH</name></expr></argument>,
				 <argument><expr><literal type="string">"SELECT CASE WHEN EXISTS("</literal>
				 <literal type="string">"SELECT 1 FROM pg_catalog.pg_largeobject WHERE loid = '%u'"</literal>
				 <literal type="string">") THEN pg_catalog.lo_unlink('%u') END;\n"</literal></expr></argument>,
				 <argument><expr><name>oid</name></expr></argument>, <argument><expr><name>oid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>
</unit>
