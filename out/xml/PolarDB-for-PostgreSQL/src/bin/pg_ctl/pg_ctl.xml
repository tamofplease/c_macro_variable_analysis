<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/PolarDB-for-PostgreSQL/src/bin/pg_ctl/pg_ctl.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * pg_ctl --- start/stops/restarts the PostgreSQL server
 *
 * Portions Copyright (c) 1996-2018, PostgreSQL Global Development Group
 *
 * src/bin/pg_ctl/pg_ctl.c
 *
 *-------------------------------------------------------------------------
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres_fe.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;fcntl.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;signal.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;time.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/stat.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/wait.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;unistd.h&gt;</cpp:file></cpp:include>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_SYS_RESOURCE_H</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/time.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/resource.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_control.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"common/controldata_utils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"common/file_perm.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"getopt_long.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/pidfile.h"</cpp:file></cpp:include>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WIN32</name></cpp:ifdef>					<comment type="block">/* on Unix, we don't need libpq */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pqexpbuffer.h"</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* PID can be negative for standalone backend */</comment>
<typedef>typedef <type><name>long</name></type> <name>pgpid_t</name>;</typedef>


<typedef>typedef <type><enum>enum
<block>{
	<decl><name>SMART_MODE</name></decl>,
	<decl><name>FAST_MODE</name></decl>,
	<decl><name>IMMEDIATE_MODE</name></decl>
}</block></enum></type> <name>ShutdownMode</name>;</typedef>

<typedef>typedef <type><enum>enum
<block>{
	<decl><name>POSTMASTER_READY</name></decl>,
	<decl><name>POSTMASTER_STILL_STARTING</name></decl>,
	<decl><name>POSTMASTER_FAILED</name></decl>
}</block></enum></type> <name>WaitPMResult</name>;</typedef>

<typedef>typedef <type><enum>enum
<block>{
	<decl><name>NO_COMMAND</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>,
	<decl><name>INIT_COMMAND</name></decl>,
	<decl><name>START_COMMAND</name></decl>,
	<decl><name>STOP_COMMAND</name></decl>,
	<decl><name>RESTART_COMMAND</name></decl>,
	<decl><name>RELOAD_COMMAND</name></decl>,
	<decl><name>STATUS_COMMAND</name></decl>,
	<decl><name>PROMOTE_COMMAND</name></decl>,
	<decl><name>KILL_COMMAND</name></decl>,
	<decl><name>REGISTER_COMMAND</name></decl>,
	<decl><name>UNREGISTER_COMMAND</name></decl>,
	<decl><name>RUN_AS_SERVICE_COMMAND</name></decl>
}</block></enum></type> <name>CtlCommand</name>;</typedef>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DEFAULT_WAIT</name></cpp:macro>	<cpp:value>60</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>USEC_PER_SEC</name></cpp:macro>	<cpp:value>1000000</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>WAITS_PER_SEC</name></cpp:macro>	<cpp:value>10</cpp:value></cpp:define>		<comment type="block">/* should divide USEC_PER_SEC evenly */</comment>

<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type> <name>do_wait</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type>	<name>wait_seconds</name> <init>= <expr><name>DEFAULT_WAIT</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type> <name>wait_seconds_arg</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type> <name>silent_mode</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>ShutdownMode</name></type> <name>shutdown_mode</name> <init>= <expr><name>FAST_MODE</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type>	<name>sig</name> <init>= <expr><name>SIGINT</name></expr></init></decl>;</decl_stmt>		<comment type="block">/* default */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>CtlCommand</name></type> <name>ctl_command</name> <init>= <expr><name>NO_COMMAND</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>pg_data</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>pg_config</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>pgdata_opt</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>post_opts</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>progname</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>log_file</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>exec_path</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>event_source</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>register_servicename</name> <init>= <expr><literal type="string">"PostgreSQL"</literal></expr></init></decl>;</decl_stmt>	<comment type="block">/* FIXME: + version ID? */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>register_username</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>register_password</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>argv0</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type> <name>allow_core_files</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>time_t</name></type> <name>start_time</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>char</name></type> <name><name>postopts_file</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name></type> <name><name>version_file</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name></type> <name><name>pid_file</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name></type> <name><name>backup_file</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name></type> <name><name>promote_file</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name></decl>;</decl_stmt>

<comment type="block">/* POLAR: add force promote */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type> <name>polar_force_promote</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name></type> <name><name>polar_force_promote_file</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name></type> <name><name>polar_promote_not_allowed</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name></decl>;</decl_stmt>
<comment type="block">/* POLAR end */</comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WIN32</name></cpp:ifdef>
<decl_stmt><decl><type><specifier>static</specifier> <name>DWORD</name></type> <name>pgctl_start_type</name> <init>= <expr><name>SERVICE_AUTO_START</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>SERVICE_STATUS</name></type> <name>status</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>SERVICE_STATUS_HANDLE</name></type> <name>hStatus</name> <init>= <expr><operator>(</operator><name>SERVICE_STATUS_HANDLE</name><operator>)</operator> <literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>HANDLE</name></type> <name><name>shutdownHandles</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>pid_t</name></type> <name>postmasterPID</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>shutdownEvent</name></cpp:macro>	  <cpp:value>shutdownHandles[0]</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>postmasterProcess</name></cpp:macro> <cpp:value>shutdownHandles[1]</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>


<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>write_stderr</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>fmt</name></decl></parameter>,<parameter><decl><type><modifier>...</modifier></type></decl></parameter>)</parameter_list> pg_attribute_printf<parameter_list>(</parameter_list>1<operator>,</operator> 2</function_decl>)<empty_stmt>;</empty_stmt>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>do_advice</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>do_help</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>set_mode</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>modeopt</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>set_sig</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>signame</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>do_init</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>do_start</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>do_stop</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>do_restart</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>do_reload</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>do_status</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>do_promote</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>do_kill</name><parameter_list>(<parameter><decl><type><name>pgpid_t</name></type> <name>pid</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>print_msg</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>msg</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>adjust_data_dir</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WIN32</name></cpp:ifdef>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>(</operator><name>_MSC_VER</name> <operator>&gt;=</operator> <literal type="number">1800</literal><operator>)</operator></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;versionhelpers.h&gt;</cpp:file></cpp:include>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>IsWindowsXPOrGreater</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>IsWindows7OrGreater</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>pgwin32_IsInstalled</name><parameter_list>(<parameter><decl><type><name>SC_HANDLE</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>pgwin32_CommandLine</name><parameter_list>(<parameter><decl><type><name>bool</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>pgwin32_doRegister</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>pgwin32_doUnregister</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>pgwin32_SetServiceStatus</name><parameter_list>(<parameter><decl><type><name>DWORD</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name> <name>WINAPI</name></type> <name>pgwin32_ServiceHandler</name><parameter_list>(<parameter><decl><type><name>DWORD</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name> <name>WINAPI</name></type> <name>pgwin32_ServiceMain</name><parameter_list>(<parameter><decl><type><name>DWORD</name></type></decl></parameter>, <parameter><decl><type><name>LPTSTR</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>pgwin32_doRunAsService</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type>	<name>CreateRestrictedProcess</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>cmd</name></decl></parameter>, <parameter><decl><type><name>PROCESS_INFORMATION</name> <modifier>*</modifier></type><name>processInfo</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>as_service</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>PTOKEN_PRIVILEGES</name></type> <name>GetPrivilegesToDelete</name><parameter_list>(<parameter><decl><type><name>HANDLE</name></type> <name>hToken</name></decl></parameter>)</parameter_list>;</function_decl>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function_decl><type><specifier>static</specifier> <name>pgpid_t</name></type> <name>get_pgpid</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>is_status_request</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>readfile</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>path</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>numlines</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>free_readfile</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>optlines</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>pgpid_t</name></type> <name>start_postmaster</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>read_post_opts</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>WaitPMResult</name></type> <name>wait_for_postmaster</name><parameter_list>(<parameter><decl><type><name>pgpid_t</name></type> <name>pm_pid</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>do_checkpoint</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>postmaster_is_alive</name><parameter_list>(<parameter><decl><type><name>pid_t</name></type> <name>pid</name></decl></parameter>)</parameter_list>;</function_decl>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_GETRLIMIT</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>defined</name><argument_list>(<argument><expr><name>RLIMIT_CORE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>unlimit_core_size</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function_decl><type><specifier>static</specifier> <name>DBState</name></type> <name>get_control_dbstate</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>


<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WIN32</name></cpp:ifdef>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>write_eventlog</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>level</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>line</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>static</specifier> <name>HANDLE</name></type> <name>evtHandle</name> <init>= <expr><name>INVALID_HANDLE_VALUE</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>silent_mode</name> <operator>&amp;&amp;</operator> <name>level</name> <operator>==</operator> <name>EVENTLOG_INFORMATION_TYPE</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>evtHandle</name> <operator>==</operator> <name>INVALID_HANDLE_VALUE</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>evtHandle</name> <operator>=</operator> <call><name>RegisterEventSource</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>,
										<argument><expr><ternary><condition><expr><name>event_source</name></expr> ?</condition><then> <expr><name>event_source</name></expr> </then><else>: <expr><name>DEFAULT_EVENT_SOURCE</name></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>evtHandle</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>evtHandle</name> <operator>=</operator> <name>INVALID_HANDLE_VALUE</name></expr>;</expr_stmt>
			<return>return;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>ReportEvent</name><argument_list>(<argument><expr><name>evtHandle</name></expr></argument>,
				<argument><expr><name>level</name></expr></argument>,
				<argument><expr><literal type="number">0</literal></expr></argument>,
				<argument><expr><literal type="number">0</literal></expr></argument>,				<comment type="block">/* All events are Id 0 */</comment>
				<argument><expr><name>NULL</name></expr></argument>,
				<argument><expr><literal type="number">1</literal></expr></argument>,
				<argument><expr><literal type="number">0</literal></expr></argument>,
				<argument><expr><operator>&amp;</operator><name>line</name></expr></argument>,
				<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
 * Write errors to stderr (or by equal means when stderr is
 * not available).
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>write_stderr</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>fmt</name></decl></parameter>,<parameter><decl><type><modifier>...</modifier></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>va_list</name></type>		<name>ap</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>va_start</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>fmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>WIN32</name></cpp:ifndef>
	<comment type="block">/* On Unix, we just fprintf to stderr */</comment>
	<expr_stmt><expr><call><name>vfprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><name>fmt</name></expr></argument>, <argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

	<comment type="block">/*
	 * On Win32, we print to stderr if running on a console, or write to
	 * eventlog if running as a service
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>pgwin32_is_service</name><argument_list>()</argument_list></call></expr>)</condition>	<comment type="block">/* Running as a service */</comment>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name></type>		<name><name>errbuf</name><index>[<expr><literal type="number">2048</literal></expr>]</index></name></decl>;</decl_stmt>	<comment type="block">/* Arbitrary size? */</comment>

		<expr_stmt><expr><call><name>vsnprintf</name><argument_list>(<argument><expr><name>errbuf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>errbuf</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>fmt</name></expr></argument>, <argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>write_eventlog</name><argument_list>(<argument><expr><name>EVENTLOG_ERROR_TYPE</name></expr></argument>, <argument><expr><name>errbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<comment type="block">/* Not running as service, write to stderr */</comment>
		<expr_stmt><expr><call><name>vfprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><name>fmt</name></expr></argument>, <argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<expr_stmt><expr><call><name>va_end</name><argument_list>(<argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Given an already-localized string, print it to stdout unless the
 * user has specified that no messages should be printed.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>print_msg</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>msg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>silent_mode</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>fputs</name><argument_list>(<argument><expr><name>msg</name></expr></argument>, <argument><expr><name>stdout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>fflush</name><argument_list>(<argument><expr><name>stdout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>pgpid_t</name></type>
<name>get_pgpid</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>is_status_request</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>FILE</name>	   <modifier>*</modifier></type><name>pidf</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>long</name></type>		<name>pid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>stat</name></name></type> <name>statbuf</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>stat</name><argument_list>(<argument><expr><name>pg_data</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>statbuf</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>errno</name> <operator>==</operator> <name>ENOENT</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>write_stderr</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: directory \"%s\" does not exist\n"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>progname</name></expr></argument>,
						 <argument><expr><name>pg_data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>write_stderr</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: could not access directory \"%s\": %s\n"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>progname</name></expr></argument>,
						 <argument><expr><name>pg_data</name></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<comment type="block">/*
		 * The Linux Standard Base Core Specification 3.1 says this should
		 * return '4, program or service status is unknown'
		 * https://refspecs.linuxbase.org/LSB_3.1.0/LSB-Core-generic/LSB-Core-generic/iniscrptact.html
		 */</comment>
		<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><ternary><condition><expr><name>is_status_request</name></expr> ?</condition><then> <expr><literal type="number">4</literal></expr> </then><else>: <expr><literal type="number">1</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>stat</name><argument_list>(<argument><expr><name>version_file</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>statbuf</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>errno</name> <operator>==</operator> <name>ENOENT</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>write_stderr</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: directory \"%s\" is not a database cluster directory\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
					 <argument><expr><name>progname</name></expr></argument>, <argument><expr><name>pg_data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><ternary><condition><expr><name>is_status_request</name></expr> ?</condition><then> <expr><literal type="number">4</literal></expr> </then><else>: <expr><literal type="number">1</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>pidf</name> <operator>=</operator> <call><name>fopen</name><argument_list>(<argument><expr><name>pid_file</name></expr></argument>, <argument><expr><literal type="string">"r"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>pidf</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* No pid file, not an error on startup */</comment>
		<if_stmt><if>if <condition>(<expr><name>errno</name> <operator>==</operator> <name>ENOENT</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><call><name>write_stderr</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: could not open PID file \"%s\": %s\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
						 <argument><expr><name>progname</name></expr></argument>, <argument><expr><name>pid_file</name></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>fscanf</name><argument_list>(<argument><expr><name>pidf</name></expr></argument>, <argument><expr><literal type="string">"%ld"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>pid</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Is the file empty? */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>ftell</name><argument_list>(<argument><expr><name>pidf</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <call><name>feof</name><argument_list>(<argument><expr><name>pidf</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>write_stderr</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: the PID file \"%s\" is empty\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
						 <argument><expr><name>progname</name></expr></argument>, <argument><expr><name>pid_file</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>write_stderr</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: invalid data in PID file \"%s\"\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
						 <argument><expr><name>progname</name></expr></argument>, <argument><expr><name>pid_file</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
		<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>fclose</name><argument_list>(<argument><expr><name>pidf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><operator>(</operator><name>pgpid_t</name><operator>)</operator> <name>pid</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * get the lines from a text file - return NULL if file can't be opened
 *
 * Trailing newlines are deleted from the lines (this is a change from pre-v10)
 *
 * *numlines is set to the number of line pointers returned; there is
 * also an additional NULL pointer after the last real line.
 */</comment>
<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type>
<name>readfile</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>path</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>numlines</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>fd</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>nlines</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	  <modifier>*</modifier><modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>buffer</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>linebegin</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>n</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>len</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>stat</name></name></type> <name>statbuf</name></decl>;</decl_stmt>

	<expr_stmt><expr><operator>*</operator><name>numlines</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>				<comment type="block">/* in case of failure or empty file */</comment>

	<comment type="block">/*
	 * Slurp the file into memory.
	 *
	 * The file can change concurrently, so we read the whole file into memory
	 * with a single read() call. That's not guaranteed to get an atomic
	 * snapshot, but in practice, for a small file, it's close enough for the
	 * current use.
	 */</comment>
	<expr_stmt><expr><name>fd</name> <operator>=</operator> <call><name>open</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>O_RDONLY</name> <operator>|</operator> <name>PG_BINARY</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>fd</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>fstat</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>statbuf</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>statbuf</name><operator>.</operator><name>st_size</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* empty file */</comment>
		<expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>*</operator><operator>)</operator> <call><name>pg_malloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>char</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><operator>*</operator><name>result</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<return>return <expr><name>result</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name>buffer</name> <operator>=</operator> <call><name>pg_malloc</name><argument_list>(<argument><expr><name><name>statbuf</name><operator>.</operator><name>st_size</name></name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>read</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>, <argument><expr><name><name>statbuf</name><operator>.</operator><name>st_size</name></name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>len</name> <operator>!=</operator> <name><name>statbuf</name><operator>.</operator><name>st_size</name></name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* oops, the file size changed between fstat and read */</comment>
		<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Count newlines. We expect there to be a newline after each full line,
	 * including one at the end of file. If there isn't a newline at the end,
	 * any characters after the last newline will be ignored.
	 */</comment>
	<expr_stmt><expr><name>nlines</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>len</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>buffer</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <literal type="char">'\n'</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>nlines</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></for>

	<comment type="block">/* set up the result buffer */</comment>
	<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>*</operator><operator>)</operator> <call><name>pg_malloc</name><argument_list>(<argument><expr><operator>(</operator><name>nlines</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>char</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>numlines</name> <operator>=</operator> <name>nlines</name></expr>;</expr_stmt>

	<comment type="block">/* now split the buffer into lines */</comment>
	<expr_stmt><expr><name>linebegin</name> <operator>=</operator> <name>buffer</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>n</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>len</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>buffer</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <literal type="char">'\n'</literal></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>int</name></type>			<name>slen</name> <init>= <expr><operator>&amp;</operator><name><name>buffer</name><index>[<expr><name>i</name></expr>]</index></name> <operator>-</operator> <name>linebegin</name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>linebuf</name> <init>= <expr><call><name>pg_malloc</name><argument_list>(<argument><expr><name>slen</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>linebuf</name></expr></argument>, <argument><expr><name>linebegin</name></expr></argument>, <argument><expr><name>slen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* we already dropped the \n, but get rid of any \r too */</comment>
			<if_stmt><if>if <condition>(<expr><name>slen</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>linebuf</name><index>[<expr><name>slen</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'\r'</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>slen</name><operator>--</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><name><name>linebuf</name><index>[<expr><name>slen</name></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>result</name><index>[<expr><name>n</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>linebuf</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>linebegin</name> <operator>=</operator> <operator>&amp;</operator><name><name>buffer</name><index>[<expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>
	<expr_stmt><expr><name><name>result</name><index>[<expr><name>n</name></expr>]</index></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * Free memory allocated for optlines through readfile()
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>free_readfile</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>optlines</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>curr_line</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>optlines</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<while>while <condition>(<expr><operator>(</operator><name>curr_line</name> <operator>=</operator> <name><name>optlines</name><index>[<expr><name>i</name><operator>++</operator></expr>]</index></name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>curr_line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></while>

	<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>optlines</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return;</return>
</block_content>}</block></function>

<comment type="block">/*
 * start/test/stop routines
 */</comment>

<comment type="block">/*
 * Start the postmaster and return its PID.
 *
 * Currently, on Windows what we return is the PID of the shell process
 * that launched the postmaster (and, we trust, is waiting for it to exit).
 * So the PID is usable for "is the postmaster still running" checks,
 * but cannot be compared directly to postmaster.pid.
 *
 * On Windows, we also save aside a handle to the shell process in
 * "postmasterProcess", which the caller should close when done with it.
 */</comment>
<function><type><specifier>static</specifier> <name>pgpid_t</name></type>
<name>start_postmaster</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>cmd</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name></decl>;</decl_stmt>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>WIN32</name></cpp:ifndef>
	<decl_stmt><decl><type><name>pgpid_t</name></type>		<name>pm_pid</name></decl>;</decl_stmt>

	<comment type="block">/* Flush stdio channels just before fork, to avoid double-output problems */</comment>
	<expr_stmt><expr><call><name>fflush</name><argument_list>(<argument><expr><name>stdout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>fflush</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>pm_pid</name> <operator>=</operator> <call><name>fork</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>pm_pid</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* fork failed */</comment>
		<expr_stmt><expr><call><name>write_stderr</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: could not start server: %s\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
					 <argument><expr><name>progname</name></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>pm_pid</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* fork succeeded, in parent */</comment>
		<return>return <expr><name>pm_pid</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* fork succeeded, in child */</comment>

	<comment type="block">/*
	 * Since there might be quotes to handle here, it is easier simply to pass
	 * everything to a shell to process them.  Use exec so that the postmaster
	 * has the same PID as the current child process.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>log_file</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>cmd</name></expr></argument>, <argument><expr><name>MAXPGPATH</name></expr></argument>, <argument><expr><literal type="string">"exec \"%s\" %s%s &lt; \"%s\" &gt;&gt; \"%s\" 2&gt;&amp;1"</literal></expr></argument>,
				 <argument><expr><name>exec_path</name></expr></argument>, <argument><expr><name>pgdata_opt</name></expr></argument>, <argument><expr><name>post_opts</name></expr></argument>,
				 <argument><expr><name>DEVNULL</name></expr></argument>, <argument><expr><name>log_file</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>cmd</name></expr></argument>, <argument><expr><name>MAXPGPATH</name></expr></argument>, <argument><expr><literal type="string">"exec \"%s\" %s%s &lt; \"%s\" 2&gt;&amp;1"</literal></expr></argument>,
				 <argument><expr><name>exec_path</name></expr></argument>, <argument><expr><name>pgdata_opt</name></expr></argument>, <argument><expr><name>post_opts</name></expr></argument>, <argument><expr><name>DEVNULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>execl</name><argument_list>(<argument><expr><literal type="string">"/bin/sh"</literal></expr></argument>, <argument><expr><literal type="string">"/bin/sh"</literal></expr></argument>, <argument><expr><literal type="string">"-c"</literal></expr></argument>, <argument><expr><name>cmd</name></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* exec failed */</comment>
	<expr_stmt><expr><call><name>write_stderr</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: could not start server: %s\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
				 <argument><expr><name>progname</name></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><literal type="number">0</literal></expr>;</return>					<comment type="block">/* keep dumb compilers quiet */</comment>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>							<comment type="block">/* WIN32 */</comment>

	<comment type="block">/*
	 * As with the Unix case, it's easiest to use the shell (CMD.EXE) to
	 * handle redirection etc.  Unfortunately CMD.EXE lacks any equivalent of
	 * "exec", so we don't get to find out the postmaster's PID immediately.
	 */</comment>
	<decl_stmt><decl><type><name>PROCESS_INFORMATION</name></type> <name>pi</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>log_file</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>cmd</name></expr></argument>, <argument><expr><name>MAXPGPATH</name></expr></argument>, <argument><expr><literal type="string">"CMD /C \"\"%s\" %s%s &lt; \"%s\" &gt;&gt; \"%s\" 2&gt;&amp;1\""</literal></expr></argument>,
				 <argument><expr><name>exec_path</name></expr></argument>, <argument><expr><name>pgdata_opt</name></expr></argument>, <argument><expr><name>post_opts</name></expr></argument>, <argument><expr><name>DEVNULL</name></expr></argument>, <argument><expr><name>log_file</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>cmd</name></expr></argument>, <argument><expr><name>MAXPGPATH</name></expr></argument>, <argument><expr><literal type="string">"CMD /C \"\"%s\" %s%s &lt; \"%s\" 2&gt;&amp;1\""</literal></expr></argument>,
				 <argument><expr><name>exec_path</name></expr></argument>, <argument><expr><name>pgdata_opt</name></expr></argument>, <argument><expr><name>post_opts</name></expr></argument>, <argument><expr><name>DEVNULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>CreateRestrictedProcess</name><argument_list>(<argument><expr><name>cmd</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pi</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>write_stderr</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: could not start server: error code %lu\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
					 <argument><expr><name>progname</name></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name> <name>long</name><operator>)</operator> <call><name>GetLastError</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* Don't close command process handle here; caller must do so */</comment>
	<expr_stmt><expr><name>postmasterProcess</name> <operator>=</operator> <name><name>pi</name><operator>.</operator><name>hProcess</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>CloseHandle</name><argument_list>(<argument><expr><name><name>pi</name><operator>.</operator><name>hThread</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name><name>pi</name><operator>.</operator><name>dwProcessId</name></name></expr>;</return>		<comment type="block">/* Shell's PID, not postmaster's! */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>							<comment type="block">/* WIN32 */</comment>
</block_content>}</block></function>



<comment type="block">/*
 * Wait for the postmaster to become ready.
 *
 * On Unix, pm_pid is the PID of the just-launched postmaster.  On Windows,
 * it may be the PID of an ancestor shell process, so we can't check the
 * contents of postmaster.pid quite as carefully.
 *
 * On Windows, the static variable postmasterProcess is an implicit argument
 * to this routine; it contains a handle to the postmaster process or an
 * ancestor shell process thereof.
 *
 * Note that the checkpoint parameter enables a Windows service control
 * manager checkpoint, it's got nothing to do with database checkpoints!!
 */</comment>
<function><type><specifier>static</specifier> <name>WaitPMResult</name></type>
<name>wait_for_postmaster</name><parameter_list>(<parameter><decl><type><name>pgpid_t</name></type> <name>pm_pid</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>do_checkpoint</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>wait_seconds</name> <operator>*</operator> <name>WAITS_PER_SEC</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name>	  <modifier>*</modifier><modifier>*</modifier></type><name>optlines</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>numlines</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * Try to read the postmaster.pid file.  If it's not valid, or if the
		 * status line isn't there yet, just keep waiting.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>(</operator><name>optlines</name> <operator>=</operator> <call><name>readfile</name><argument_list>(<argument><expr><name>pid_file</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>numlines</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator>
			<name>numlines</name> <operator>&gt;=</operator> <name>LOCK_FILE_LINE_PM_STATUS</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* File is complete enough for us, parse it */</comment>
			<decl_stmt><decl><type><name>pgpid_t</name></type>		<name>pmpid</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>time_t</name></type>		<name>pmstart</name></decl>;</decl_stmt>

			<comment type="block">/*
			 * Make sanity checks.  If it's for the wrong PID, or the recorded
			 * start time is before pg_ctl started, then either we are looking
			 * at the wrong data directory, or this is a pre-existing pidfile
			 * that hasn't (yet?) been overwritten by our child postmaster.
			 * Allow 2 seconds slop for possible cross-process clock skew.
			 */</comment>
			<expr_stmt><expr><name>pmpid</name> <operator>=</operator> <call><name>atol</name><argument_list>(<argument><expr><name><name>optlines</name><index>[<expr><name>LOCK_FILE_LINE_PID</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>pmstart</name> <operator>=</operator> <call><name>atol</name><argument_list>(<argument><expr><name><name>optlines</name><index>[<expr><name>LOCK_FILE_LINE_START_TIME</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>pmstart</name> <operator>&gt;=</operator> <name>start_time</name> <operator>-</operator> <literal type="number">2</literal> <operator>&amp;&amp;</operator>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>WIN32</name></cpp:ifndef>
				<name>pmpid</name> <operator>==</operator> <name>pm_pid</name>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
			<comment type="block">/* Windows can only reject standalone-backend PIDs */</comment>
				<name>pmpid</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
				)</condition>
			<block>{<block_content>
				<comment type="block">/*
				 * OK, seems to be a valid pidfile from our child.  Check the
				 * status line (this assumes a v10 or later server).
				 */</comment>
				<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>pmstatus</name> <init>= <expr><name><name>optlines</name><index>[<expr><name>LOCK_FILE_LINE_PM_STATUS</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>pmstatus</name></expr></argument>, <argument><expr><name>PM_STATUS_READY</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
					<call><name>strcmp</name><argument_list>(<argument><expr><name>pmstatus</name></expr></argument>, <argument><expr><name>PM_STATUS_STANDBY</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
					<comment type="block">/* POLAR: add terminal state DataMax */</comment>
					<call><name>strcmp</name><argument_list>(<argument><expr><name>pmstatus</name></expr></argument>, <argument><expr><name>PM_STATUS_DATAMAX</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
					<comment type="block">/* POLAR end */</comment>
				<block>{<block_content>
					<comment type="block">/* postmaster is done starting up */</comment>
					<expr_stmt><expr><call><name>free_readfile</name><argument_list>(<argument><expr><name>optlines</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<return>return <expr><name>POSTMASTER_READY</name></expr>;</return>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * Free the results of readfile.
		 *
		 * This is safe to call even if optlines is NULL.
		 */</comment>
		<expr_stmt><expr><call><name>free_readfile</name><argument_list>(<argument><expr><name>optlines</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Check whether the child postmaster process is still alive.  This
		 * lets us exit early if the postmaster fails during startup.
		 *
		 * On Windows, we may be checking the postmaster's parent shell, but
		 * that's fine for this purpose.
		 */</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>WIN32</name></cpp:ifndef>
		<block>{<block_content>
			<decl_stmt><decl><type><name>int</name></type>			<name>exitstatus</name></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>waitpid</name><argument_list>(<argument><expr><operator>(</operator><name>pid_t</name><operator>)</operator> <name>pm_pid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>exitstatus</name></expr></argument>, <argument><expr><name>WNOHANG</name></expr></argument>)</argument_list></call> <operator>==</operator> <operator>(</operator><name>pid_t</name><operator>)</operator> <name>pm_pid</name></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>POSTMASTER_FAILED</name></expr>;</return></block_content></block></if></if_stmt>
		</block_content>}</block>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
		<if_stmt><if>if <condition>(<expr><call><name>WaitForSingleObject</name><argument_list>(<argument><expr><name>postmasterProcess</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call> <operator>==</operator> <name>WAIT_OBJECT_0</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>POSTMASTER_FAILED</name></expr>;</return></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

		<comment type="block">/* Startup still in process; wait, printing a dot once per second */</comment>
		<if_stmt><if>if <condition>(<expr><name>i</name> <operator>%</operator> <name>WAITS_PER_SEC</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WIN32</name></cpp:ifdef>
			<if_stmt><if>if <condition>(<expr><name>do_checkpoint</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/*
				 * Increment the wait hint by 6 secs (connection timeout +
				 * sleep).  We must do this to indicate to the SCM that our
				 * startup time is changing, otherwise it'll usually send a
				 * stop signal after 20 seconds, despite incrementing the
				 * checkpoint counter.
				 */</comment>
				<expr_stmt><expr><name><name>status</name><operator>.</operator><name>dwWaitHint</name></name> <operator>+=</operator> <literal type="number">6000</literal></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>status</name><operator>.</operator><name>dwCheckPoint</name></name><operator>++</operator></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>SetServiceStatus</name><argument_list>(<argument><expr><name>hStatus</name></expr></argument>, <argument><expr><operator>(</operator><name>LPSERVICE_STATUS</name><operator>)</operator> <operator>&amp;</operator><name>status</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else<block type="pseudo"><block_content>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
				<expr_stmt><expr><call><name>print_msg</name><argument_list>(<argument><expr><literal type="string">"."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>pg_usleep</name><argument_list>(<argument><expr><name>USEC_PER_SEC</name> <operator>/</operator> <name>WAITS_PER_SEC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<comment type="block">/* out of patience; report that postmaster is still starting up */</comment>
	<return>return <expr><name>POSTMASTER_STILL_STARTING</name></expr>;</return>
</block_content>}</block></function>


<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_GETRLIMIT</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>defined</name><argument_list>(<argument><expr><name>RLIMIT_CORE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>unlimit_core_size</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name><name>struct</name> <name>rlimit</name></name></type> <name>lim</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>getrlimit</name><argument_list>(<argument><expr><name>RLIMIT_CORE</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>lim</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>lim</name><operator>.</operator><name>rlim_max</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>write_stderr</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: cannot set core file size limit; disallowed by hard limit\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
					 <argument><expr><name>progname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name><name>lim</name><operator>.</operator><name>rlim_max</name></name> <operator>==</operator> <name>RLIM_INFINITY</name> <operator>||</operator> <name><name>lim</name><operator>.</operator><name>rlim_cur</name></name> <operator>&lt;</operator> <name><name>lim</name><operator>.</operator><name>rlim_max</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>lim</name><operator>.</operator><name>rlim_cur</name></name> <operator>=</operator> <name><name>lim</name><operator>.</operator><name>rlim_max</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>setrlimit</name><argument_list>(<argument><expr><name>RLIMIT_CORE</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>lim</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>read_post_opts</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>post_opts</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>post_opts</name> <operator>=</operator> <literal type="string">""</literal></expr>;</expr_stmt>			<comment type="block">/* default */</comment>
		<if_stmt><if>if <condition>(<expr><name>ctl_command</name> <operator>==</operator> <name>RESTART_COMMAND</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>char</name>	  <modifier>*</modifier><modifier>*</modifier></type><name>optlines</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int</name></type>			<name>numlines</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>optlines</name> <operator>=</operator> <call><name>readfile</name><argument_list>(<argument><expr><name>postopts_file</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>numlines</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>optlines</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>write_stderr</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: could not read file \"%s\"\n"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>progname</name></expr></argument>, <argument><expr><name>postopts_file</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if>
			<if type="elseif">else if <condition>(<expr><name>numlines</name> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>write_stderr</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: option file \"%s\" must have exactly one line\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
							 <argument><expr><name>progname</name></expr></argument>, <argument><expr><name>postopts_file</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>optline</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>arg1</name></decl>;</decl_stmt>

				<expr_stmt><expr><name>optline</name> <operator>=</operator> <name><name>optlines</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>

				<comment type="block">/*
				 * Are we at the first option, as defined by space and
				 * double-quote?
				 */</comment>
				<if_stmt><if>if <condition>(<expr><operator>(</operator><name>arg1</name> <operator>=</operator> <call><name>strstr</name><argument_list>(<argument><expr><name>optline</name></expr></argument>, <argument><expr><literal type="string">" \""</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><operator>*</operator><name>arg1</name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>	<comment type="block">/* terminate so we get only program name */</comment>
					<expr_stmt><expr><name>post_opts</name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><name>arg1</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>	<comment type="block">/* point past whitespace */</comment>
				</block_content>}</block></if></if_stmt>
				<if_stmt><if>if <condition>(<expr><name>exec_path</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>exec_path</name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><name>optline</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block></else></if_stmt>

			<comment type="block">/* Free the results of readfile. */</comment>
			<expr_stmt><expr><call><name>free_readfile</name><argument_list>(<argument><expr><name>optlines</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type>
<name>find_other_exec_or_die</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>argv0</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>target</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>versionstr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>ret</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>found_path</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>found_path</name> <operator>=</operator> <call><name>pg_malloc</name><argument_list>(<argument><expr><name>MAXPGPATH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>ret</name> <operator>=</operator> <call><name>find_other_exec</name><argument_list>(<argument><expr><name>argv0</name></expr></argument>, <argument><expr><name>target</name></expr></argument>, <argument><expr><name>versionstr</name></expr></argument>, <argument><expr><name>found_path</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name></type>		<name><name>full_path</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>find_my_exec</name><argument_list>(<argument><expr><name>argv0</name></expr></argument>, <argument><expr><name>full_path</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>strlcpy</name><argument_list>(<argument><expr><name>full_path</name></expr></argument>, <argument><expr><name>progname</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>full_path</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>write_stderr</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"The program \"%s\" is needed by %s "</literal>
						   <literal type="string">"but was not found in the\n"</literal>
						   <literal type="string">"same directory as \"%s\".\n"</literal>
						   <literal type="string">"Check your installation.\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
						 <argument><expr><name>target</name></expr></argument>, <argument><expr><name>progname</name></expr></argument>, <argument><expr><name>full_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>write_stderr</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"The program \"%s\" was found by \"%s\"\n"</literal>
						   <literal type="string">"but was not the same version as %s.\n"</literal>
						   <literal type="string">"Check your installation.\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
						 <argument><expr><name>target</name></expr></argument>, <argument><expr><name>full_path</name></expr></argument>, <argument><expr><name>progname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
		<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>found_path</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>do_init</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>cmd</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>exec_path</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>exec_path</name> <operator>=</operator> <call><name>find_other_exec_or_die</name><argument_list>(<argument><expr><name>argv0</name></expr></argument>, <argument><expr><literal type="string">"initdb"</literal></expr></argument>, <argument><expr><literal type="string">"initdb (PostgreSQL) "</literal> <name>PG_VERSION</name> <literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>pgdata_opt</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>pgdata_opt</name> <operator>=</operator> <literal type="string">""</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>post_opts</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>post_opts</name> <operator>=</operator> <literal type="string">""</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>silent_mode</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>cmd</name></expr></argument>, <argument><expr><name>MAXPGPATH</name></expr></argument>, <argument><expr><literal type="string">"\"%s\" %s%s"</literal></expr></argument>,
				 <argument><expr><name>exec_path</name></expr></argument>, <argument><expr><name>pgdata_opt</name></expr></argument>, <argument><expr><name>post_opts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>cmd</name></expr></argument>, <argument><expr><name>MAXPGPATH</name></expr></argument>, <argument><expr><literal type="string">"\"%s\" %s%s &gt; \"%s\""</literal></expr></argument>,
				 <argument><expr><name>exec_path</name></expr></argument>, <argument><expr><name>pgdata_opt</name></expr></argument>, <argument><expr><name>post_opts</name></expr></argument>, <argument><expr><name>DEVNULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>system</name><argument_list>(<argument><expr><name>cmd</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>write_stderr</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: database system initialization failed\n"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>progname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>do_start</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>pgpid_t</name></type>		<name>old_pid</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>pgpid_t</name></type>		<name>pm_pid</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>ctl_command</name> <operator>!=</operator> <name>RESTART_COMMAND</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>old_pid</name> <operator>=</operator> <call><name>get_pgpid</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>old_pid</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>write_stderr</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: another server might be running; "</literal>
						   <literal type="string">"trying to start server anyway\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
						 <argument><expr><name>progname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>read_post_opts</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* No -D or -D already added during server start */</comment>
	<if_stmt><if>if <condition>(<expr><name>ctl_command</name> <operator>==</operator> <name>RESTART_COMMAND</name> <operator>||</operator> <name>pgdata_opt</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>pgdata_opt</name> <operator>=</operator> <literal type="string">""</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>exec_path</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>exec_path</name> <operator>=</operator> <call><name>find_other_exec_or_die</name><argument_list>(<argument><expr><name>argv0</name></expr></argument>, <argument><expr><literal type="string">"postgres"</literal></expr></argument>, <argument><expr><name>PG_BACKEND_VERSIONSTR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_GETRLIMIT</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>defined</name><argument_list>(<argument><expr><name>RLIMIT_CORE</name></expr></argument>)</argument_list></call></expr></cpp:if>
	<if_stmt><if>if <condition>(<expr><name>allow_core_files</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>unlimit_core_size</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<comment type="block">/*
	 * If possible, tell the postmaster our parent shell's PID (see the
	 * comments in CreateLockFile() for motivation).  Windows hasn't got
	 * getppid() unfortunately.
	 */</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>WIN32</name></cpp:ifndef>
	<block>{<block_content>
		<decl_stmt><decl><type><specifier>static</specifier> <name>char</name></type> <name><name>env_var</name><index>[<expr><literal type="number">32</literal></expr>]</index></name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>env_var</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>env_var</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"PG_GRANDPARENT_PID=%d"</literal></expr></argument>,
				 <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <call><name>getppid</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>putenv</name><argument_list>(<argument><expr><name>env_var</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<expr_stmt><expr><name>pm_pid</name> <operator>=</operator> <call><name>start_postmaster</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>do_wait</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>print_msg</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"waiting for server to start..."</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<switch>switch <condition>(<expr><call><name>wait_for_postmaster</name><argument_list>(<argument><expr><name>pm_pid</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<case>case <expr><name>POSTMASTER_READY</name></expr>:</case>
				<expr_stmt><expr><call><name>print_msg</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">" done\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>print_msg</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"server started\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>POSTMASTER_STILL_STARTING</name></expr>:</case>
				<expr_stmt><expr><call><name>print_msg</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">" stopped waiting\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>write_stderr</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: server did not start in time\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
							 <argument><expr><name>progname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>POSTMASTER_FAILED</name></expr>:</case>
				<expr_stmt><expr><call><name>print_msg</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">" stopped waiting\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>write_stderr</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: could not start server\n"</literal>
							   <literal type="string">"Examine the log output.\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
							 <argument><expr><name>progname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
		</block_content>}</block></switch>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>print_msg</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"server starting\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WIN32</name></cpp:ifdef>
	<comment type="block">/* Now we don't need the handle to the shell process anymore */</comment>
	<expr_stmt><expr><call><name>CloseHandle</name><argument_list>(<argument><expr><name>postmasterProcess</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>postmasterProcess</name> <operator>=</operator> <name>INVALID_HANDLE_VALUE</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>void</name></type>
<name>do_stop</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>cnt</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>pgpid_t</name></type>		<name>pid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>stat</name></name></type> <name>statbuf</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>pid</name> <operator>=</operator> <call><name>get_pgpid</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>pid</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>				<comment type="block">/* no pid file */</comment>
	<block>{<block_content>
		<expr_stmt><expr><call><name>write_stderr</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: PID file \"%s\" does not exist\n"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>progname</name></expr></argument>, <argument><expr><name>pid_file</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>write_stderr</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Is server running?\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>pid</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>			<comment type="block">/* standalone backend, not postmaster */</comment>
	<block>{<block_content>
		<expr_stmt><expr><name>pid</name> <operator>=</operator> <operator>-</operator><name>pid</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>write_stderr</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: cannot stop server; "</literal>
					   <literal type="string">"single-user server is running (PID: %ld)\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
					 <argument><expr><name>progname</name></expr></argument>, <argument><expr><name>pid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>kill</name><argument_list>(<argument><expr><operator>(</operator><name>pid_t</name><operator>)</operator> <name>pid</name></expr></argument>, <argument><expr><name>sig</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>write_stderr</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: could not send stop signal (PID: %ld): %s\n"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>progname</name></expr></argument>, <argument><expr><name>pid</name></expr></argument>,
					 <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>do_wait</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>print_msg</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"server shutting down\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/*
		 * If backup_label exists, an online backup is running. Warn the user
		 * that smart shutdown will wait for it to finish. However, if the
		 * server is in archive recovery, we're recovering from an online
		 * backup instead of performing one.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>shutdown_mode</name> <operator>==</operator> <name>SMART_MODE</name> <operator>&amp;&amp;</operator>
			<call><name>stat</name><argument_list>(<argument><expr><name>backup_file</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>statbuf</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
			<call><name>get_control_dbstate</name><argument_list>()</argument_list></call> <operator>!=</operator> <name>DB_IN_ARCHIVE_RECOVERY</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>print_msg</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"WARNING: online backup mode is active\n"</literal>
						<literal type="string">"Shutdown will not complete until pg_stop_backup() is called.\n\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>print_msg</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"waiting for server to shut down..."</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<for>for <control>(<init><expr><name>cnt</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>cnt</name> <operator>&lt;</operator> <name>wait_seconds</name> <operator>*</operator> <name>WAITS_PER_SEC</name></expr>;</condition> <incr><expr><name>cnt</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><operator>(</operator><name>pid</name> <operator>=</operator> <call><name>get_pgpid</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name>cnt</name> <operator>%</operator> <name>WAITS_PER_SEC</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>print_msg</name><argument_list>(<argument><expr><literal type="string">"."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<expr_stmt><expr><call><name>pg_usleep</name><argument_list>(<argument><expr><name>USEC_PER_SEC</name> <operator>/</operator> <name>WAITS_PER_SEC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else<block type="pseudo"><block_content>
				<break>break;</break></block_content></block></else></if_stmt>
		</block_content>}</block></for>

		<if_stmt><if>if <condition>(<expr><name>pid</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>			<comment type="block">/* pid file still exists */</comment>
		<block>{<block_content>
			<expr_stmt><expr><call><name>print_msg</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">" failed\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>write_stderr</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: server does not shut down\n"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>progname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>shutdown_mode</name> <operator>==</operator> <name>SMART_MODE</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>write_stderr</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"HINT: The \"-m fast\" option immediately disconnects sessions rather than\n"</literal>
							   <literal type="string">"waiting for session-initiated disconnection.\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><call><name>print_msg</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">" done\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>print_msg</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"server stopped\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 *	restart/reload routines
 */</comment>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>do_restart</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>cnt</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>pgpid_t</name></type>		<name>pid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>stat</name></name></type> <name>statbuf</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>pid</name> <operator>=</operator> <call><name>get_pgpid</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>pid</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>				<comment type="block">/* no pid file */</comment>
	<block>{<block_content>
		<expr_stmt><expr><call><name>write_stderr</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: PID file \"%s\" does not exist\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
					 <argument><expr><name>progname</name></expr></argument>, <argument><expr><name>pid_file</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>write_stderr</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Is server running?\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>write_stderr</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"trying to start server anyway\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>do_start</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>pid</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>			<comment type="block">/* standalone backend, not postmaster */</comment>
	<block>{<block_content>
		<expr_stmt><expr><name>pid</name> <operator>=</operator> <operator>-</operator><name>pid</name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>postmaster_is_alive</name><argument_list>(<argument><expr><operator>(</operator><name>pid_t</name><operator>)</operator> <name>pid</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>write_stderr</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: cannot restart server; "</literal>
						   <literal type="string">"single-user server is running (PID: %ld)\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
						 <argument><expr><name>progname</name></expr></argument>, <argument><expr><name>pid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>write_stderr</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Please terminate the single-user server and try again.\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>postmaster_is_alive</name><argument_list>(<argument><expr><operator>(</operator><name>pid_t</name><operator>)</operator> <name>pid</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>kill</name><argument_list>(<argument><expr><operator>(</operator><name>pid_t</name><operator>)</operator> <name>pid</name></expr></argument>, <argument><expr><name>sig</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>write_stderr</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: could not send stop signal (PID: %ld): %s\n"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>progname</name></expr></argument>, <argument><expr><name>pid</name></expr></argument>,
						 <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * If backup_label exists, an online backup is running. Warn the user
		 * that smart shutdown will wait for it to finish. However, if the
		 * server is in archive recovery, we're recovering from an online
		 * backup instead of performing one.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>shutdown_mode</name> <operator>==</operator> <name>SMART_MODE</name> <operator>&amp;&amp;</operator>
			<call><name>stat</name><argument_list>(<argument><expr><name>backup_file</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>statbuf</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
			<call><name>get_control_dbstate</name><argument_list>()</argument_list></call> <operator>!=</operator> <name>DB_IN_ARCHIVE_RECOVERY</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>print_msg</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"WARNING: online backup mode is active\n"</literal>
						<literal type="string">"Shutdown will not complete until pg_stop_backup() is called.\n\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>print_msg</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"waiting for server to shut down..."</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* always wait for restart */</comment>

		<for>for <control>(<init><expr><name>cnt</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>cnt</name> <operator>&lt;</operator> <name>wait_seconds</name> <operator>*</operator> <name>WAITS_PER_SEC</name></expr>;</condition> <incr><expr><name>cnt</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><operator>(</operator><name>pid</name> <operator>=</operator> <call><name>get_pgpid</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name>cnt</name> <operator>%</operator> <name>WAITS_PER_SEC</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>print_msg</name><argument_list>(<argument><expr><literal type="string">"."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<expr_stmt><expr><call><name>pg_usleep</name><argument_list>(<argument><expr><name>USEC_PER_SEC</name> <operator>/</operator> <name>WAITS_PER_SEC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else<block type="pseudo"><block_content>
				<break>break;</break></block_content></block></else></if_stmt>
		</block_content>}</block></for>

		<if_stmt><if>if <condition>(<expr><name>pid</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>			<comment type="block">/* pid file still exists */</comment>
		<block>{<block_content>
			<expr_stmt><expr><call><name>print_msg</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">" failed\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>write_stderr</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: server does not shut down\n"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>progname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>shutdown_mode</name> <operator>==</operator> <name>SMART_MODE</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>write_stderr</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"HINT: The \"-m fast\" option immediately disconnects sessions rather than\n"</literal>
							   <literal type="string">"waiting for session-initiated disconnection.\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>print_msg</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">" done\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>print_msg</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"server stopped\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>write_stderr</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: old server process (PID: %ld) seems to be gone\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
					 <argument><expr><name>progname</name></expr></argument>, <argument><expr><name>pid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>write_stderr</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"starting server anyway\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><call><name>do_start</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>do_reload</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>pgpid_t</name></type>		<name>pid</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>pid</name> <operator>=</operator> <call><name>get_pgpid</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>pid</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>				<comment type="block">/* no pid file */</comment>
	<block>{<block_content>
		<expr_stmt><expr><call><name>write_stderr</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: PID file \"%s\" does not exist\n"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>progname</name></expr></argument>, <argument><expr><name>pid_file</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>write_stderr</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Is server running?\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>pid</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>			<comment type="block">/* standalone backend, not postmaster */</comment>
	<block>{<block_content>
		<expr_stmt><expr><name>pid</name> <operator>=</operator> <operator>-</operator><name>pid</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>write_stderr</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: cannot reload server; "</literal>
					   <literal type="string">"single-user server is running (PID: %ld)\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
					 <argument><expr><name>progname</name></expr></argument>, <argument><expr><name>pid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>write_stderr</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Please terminate the single-user server and try again.\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>kill</name><argument_list>(<argument><expr><operator>(</operator><name>pid_t</name><operator>)</operator> <name>pid</name></expr></argument>, <argument><expr><name>sig</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>write_stderr</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: could not send reload signal (PID: %ld): %s\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
					 <argument><expr><name>progname</name></expr></argument>, <argument><expr><name>pid</name></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>print_msg</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"server signaled\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * promote
 */</comment>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>do_promote</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>FILE</name>	   <modifier>*</modifier></type><name>prmfile</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>pgpid_t</name></type>		<name>pid</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>pid</name> <operator>=</operator> <call><name>get_pgpid</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>pid</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>				<comment type="block">/* no pid file */</comment>
	<block>{<block_content>
		<expr_stmt><expr><call><name>write_stderr</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: PID file \"%s\" does not exist\n"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>progname</name></expr></argument>, <argument><expr><name>pid_file</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>write_stderr</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Is server running?\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>pid</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>			<comment type="block">/* standalone backend, not postmaster */</comment>
	<block>{<block_content>
		<expr_stmt><expr><name>pid</name> <operator>=</operator> <operator>-</operator><name>pid</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>write_stderr</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: cannot promote server; "</literal>
					   <literal type="string">"single-user server is running (PID: %ld)\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
					 <argument><expr><name>progname</name></expr></argument>, <argument><expr><name>pid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>get_control_dbstate</name><argument_list>()</argument_list></call> <operator>!=</operator> <name>DB_IN_ARCHIVE_RECOVERY</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>write_stderr</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: cannot promote server; "</literal>
					   <literal type="string">"server is not in standby mode\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
					 <argument><expr><name>progname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * For 9.3 onwards, "fast" promotion is performed. Promotion with a full
	 * checkpoint is still possible by writing a file called
	 * "fallback_promote" instead of "promote"
	 */</comment>
	<comment type="block">/* POLAR: force promote */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>polar_force_promote</name></expr>)</condition>
	<block>{<block_content>
	<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>promote_file</name></expr></argument>, <argument><expr><name>MAXPGPATH</name></expr></argument>, <argument><expr><literal type="string">"%s/promote"</literal></expr></argument>, <argument><expr><name>pg_data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>prmfile</name> <operator>=</operator> <call><name>fopen</name><argument_list>(<argument><expr><name>promote_file</name></expr></argument>, <argument><expr><literal type="string">"w"</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>write_stderr</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: could not create promote signal file \"%s\": %s\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
					 <argument><expr><name>progname</name></expr></argument>, <argument><expr><name>promote_file</name></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>fclose</name><argument_list>(<argument><expr><name>prmfile</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>write_stderr</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: could not write promote signal file \"%s\": %s\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
					 <argument><expr><name>progname</name></expr></argument>, <argument><expr><name>promote_file</name></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>polar_force_promote_file</name></expr></argument>, <argument><expr><name>MAXPGPATH</name></expr></argument>, <argument><expr><literal type="string">"%s/polar_force_promote"</literal></expr></argument>, <argument><expr><name>pg_data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><operator>(</operator><name>prmfile</name> <operator>=</operator> <call><name>fopen</name><argument_list>(<argument><expr><name>polar_force_promote_file</name></expr></argument>, <argument><expr><literal type="string">"w"</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>write_stderr</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: could not create force promote signal file \"%s\": %s\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
						 <argument><expr><name>progname</name></expr></argument>, <argument><expr><name>polar_force_promote_file</name></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>fclose</name><argument_list>(<argument><expr><name>prmfile</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>write_stderr</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: could not write force promote signal file \"%s\": %s\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
						 <argument><expr><name>progname</name></expr></argument>, <argument><expr><name>polar_force_promote_file</name></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></else></if_stmt>
	<comment type="block">/* POLAR end */</comment>

	<expr_stmt><expr><name>sig</name> <operator>=</operator> <name>SIGUSR1</name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>kill</name><argument_list>(<argument><expr><operator>(</operator><name>pid_t</name><operator>)</operator> <name>pid</name></expr></argument>, <argument><expr><name>sig</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>write_stderr</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: could not send promote signal (PID: %ld): %s\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
					 <argument><expr><name>progname</name></expr></argument>, <argument><expr><name>pid</name></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* POLAR: normal promote */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>polar_force_promote</name></expr>)</condition>
		<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>unlink</name><argument_list>(<argument><expr><name>promote_file</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>write_stderr</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: could not remove promote signal file \"%s\": %s\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
						 <argument><expr><name>progname</name></expr></argument>, <argument><expr><name>promote_file</name></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/* POLAR: unlink force promote */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>unlink</name><argument_list>(<argument><expr><name>polar_force_promote_file</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>write_stderr</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: could not remove force promote signal file \"%s\": %s\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
							 <argument><expr><name>progname</name></expr></argument>, <argument><expr><name>polar_force_promote_file</name></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<comment type="block">/* POLAR end */</comment>
		</block_content>}</block></else></if_stmt>
		<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>do_wait</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>DBState</name></type>		<name>state</name> <init>= <expr><name>DB_STARTUP</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>cnt</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>print_msg</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"waiting for server to promote..."</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<for>for <control>(<init><expr><name>cnt</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>cnt</name> <operator>&lt;</operator> <name>wait_seconds</name> <operator>*</operator> <name>WAITS_PER_SEC</name></expr>;</condition> <incr><expr><name>cnt</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<expr_stmt><expr><name>state</name> <operator>=</operator> <call><name>get_control_dbstate</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>state</name> <operator>==</operator> <name>DB_IN_PRODUCTION</name></expr>)</condition><block type="pseudo"><block_content>
				<break>break;</break></block_content></block></if></if_stmt>

			<comment type="block">/* POLAR */</comment>
			<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>polar_promote_not_allowed</name></expr></argument>, <argument><expr><name>MAXPGPATH</name></expr></argument>, <argument><expr><literal type="string">"%s/polar_promote_not_allowed"</literal></expr></argument>, <argument><expr><name>pg_data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><call><name>access</name><argument_list>(<argument><expr><name>polar_promote_not_allowed</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>print_msg</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">" promote is not allowed, check log for more information\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><call><name>unlink</name><argument_list>(<argument><expr><name>polar_promote_not_allowed</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>write_stderr</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: could not remove promote not allowed file \"%s\": %s\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
								 <argument><expr><name>progname</name></expr></argument>, <argument><expr><name>polar_promote_not_allowed</name></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>		
				<break>break;</break>
			</block_content>}</block></if></if_stmt>		
			<comment type="block">/* POLAR end */</comment>
			<if_stmt><if>if <condition>(<expr><name>cnt</name> <operator>%</operator> <name>WAITS_PER_SEC</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>print_msg</name><argument_list>(<argument><expr><literal type="string">"."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><call><name>pg_usleep</name><argument_list>(<argument><expr><name>USEC_PER_SEC</name> <operator>/</operator> <name>WAITS_PER_SEC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></for>
		<if_stmt><if>if <condition>(<expr><name>state</name> <operator>==</operator> <name>DB_IN_PRODUCTION</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>print_msg</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">" done\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>print_msg</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"server promoted\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><call><name>print_msg</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">" stopped waiting\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>write_stderr</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: server did not promote in time\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
						 <argument><expr><name>progname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>print_msg</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"server promoting\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 *	utility routines
 */</comment>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>postmaster_is_alive</name><parameter_list>(<parameter><decl><type><name>pid_t</name></type> <name>pid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * Test to see if the process is still there.  Note that we do not
	 * consider an EPERM failure to mean that the process is still there;
	 * EPERM must mean that the given PID belongs to some other userid, and
	 * considering the permissions on $PGDATA, that means it's not the
	 * postmaster we are after.
	 *
	 * Don't believe that our own PID or parent shell's PID is the postmaster,
	 * either.  (Windows hasn't got getppid(), though.)
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>pid</name> <operator>==</operator> <call><name>getpid</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>WIN32</name></cpp:ifndef>
	<if_stmt><if>if <condition>(<expr><name>pid</name> <operator>==</operator> <call><name>getppid</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<if_stmt><if>if <condition>(<expr><call><name>kill</name><argument_list>(<argument><expr><name>pid</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>do_status</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>pgpid_t</name></type>		<name>pid</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>pid</name> <operator>=</operator> <call><name>get_pgpid</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* Is there a pid file? */</comment>
	<if_stmt><if>if <condition>(<expr><name>pid</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* standalone backend? */</comment>
		<if_stmt><if>if <condition>(<expr><name>pid</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>pid</name> <operator>=</operator> <operator>-</operator><name>pid</name></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><call><name>postmaster_is_alive</name><argument_list>(<argument><expr><operator>(</operator><name>pid_t</name><operator>)</operator> <name>pid</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: single-user server is running (PID: %ld)\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
					   <argument><expr><name>progname</name></expr></argument>, <argument><expr><name>pid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return;</return>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if>
		<else>else
			<comment type="block">/* must be a postmaster */</comment>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><call><name>postmaster_is_alive</name><argument_list>(<argument><expr><operator>(</operator><name>pid_t</name><operator>)</operator> <name>pid</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>char</name>	  <modifier>*</modifier><modifier>*</modifier></type><name>optlines</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>char</name>	  <modifier>*</modifier><modifier>*</modifier></type><name>curr_line</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>int</name></type>			<name>numlines</name></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: server is running (PID: %ld)\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
					   <argument><expr><name>progname</name></expr></argument>, <argument><expr><name>pid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><name>optlines</name> <operator>=</operator> <call><name>readfile</name><argument_list>(<argument><expr><name>postopts_file</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>numlines</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name>optlines</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
				<block>{<block_content>
					<for>for <control>(<init><expr><name>curr_line</name> <operator>=</operator> <name>optlines</name></expr>;</init> <condition><expr><operator>*</operator><name>curr_line</name> <operator>!=</operator> <name>NULL</name></expr>;</condition> <incr><expr><name>curr_line</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>puts</name><argument_list>(<argument><expr><operator>*</operator><name>curr_line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>

					<comment type="block">/* Free the results of readfile */</comment>
					<expr_stmt><expr><call><name>free_readfile</name><argument_list>(<argument><expr><name>optlines</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
				<return>return;</return>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: no server running\n"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>progname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * The Linux Standard Base Core Specification 3.1 says this should return
	 * '3, program is not running'
	 * https://refspecs.linuxbase.org/LSB_3.1.0/LSB-Core-generic/LSB-Core-generic/iniscrptact.html
	 */</comment>
	<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>



<function><type><specifier>static</specifier> <name>void</name></type>
<name>do_kill</name><parameter_list>(<parameter><decl><type><name>pgpid_t</name></type> <name>pid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><call><name>kill</name><argument_list>(<argument><expr><operator>(</operator><name>pid_t</name><operator>)</operator> <name>pid</name></expr></argument>, <argument><expr><name>sig</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>write_stderr</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: could not send signal %d (PID: %ld): %s\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
					 <argument><expr><name>progname</name></expr></argument>, <argument><expr><name>sig</name></expr></argument>, <argument><expr><name>pid</name></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WIN32</name></cpp:ifdef>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>(</operator><name>_MSC_VER</name> <operator>&lt;</operator> <literal type="number">1800</literal><operator>)</operator></expr></cpp:if>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>IsWindowsXPOrGreater</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>OSVERSIONINFO</name></type> <name>osv</name></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>osv</name><operator>.</operator><name>dwOSVersionInfoSize</name></name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>osv</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>

	<comment type="block">/* Windows XP = Version 5.1 */</comment>
	<return>return <expr><operator>(</operator><operator>!</operator><call><name>GetVersionEx</name><argument_list>(<argument><expr><operator>&amp;</operator><name>osv</name></expr></argument>)</argument_list></call> <operator>||</operator>	<comment type="block">/* could not get version */</comment>
			<name><name>osv</name><operator>.</operator><name>dwMajorVersion</name></name> <operator>&gt;</operator> <literal type="number">5</literal> <operator>||</operator> <operator>(</operator><name><name>osv</name><operator>.</operator><name>dwMajorVersion</name></name> <operator>==</operator> <literal type="number">5</literal> <operator>&amp;&amp;</operator> <name><name>osv</name><operator>.</operator><name>dwMinorVersion</name></name> <operator>&gt;=</operator> <literal type="number">1</literal><operator>)</operator><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>IsWindows7OrGreater</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>OSVERSIONINFO</name></type> <name>osv</name></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>osv</name><operator>.</operator><name>dwOSVersionInfoSize</name></name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>osv</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>

	<comment type="block">/* Windows 7 = Version 6.0 */</comment>
	<return>return <expr><operator>(</operator><operator>!</operator><call><name>GetVersionEx</name><argument_list>(<argument><expr><operator>&amp;</operator><name>osv</name></expr></argument>)</argument_list></call> <operator>||</operator>	<comment type="block">/* could not get version */</comment>
			<name><name>osv</name><operator>.</operator><name>dwMajorVersion</name></name> <operator>&gt;</operator> <literal type="number">6</literal> <operator>||</operator> <operator>(</operator><name><name>osv</name><operator>.</operator><name>dwMajorVersion</name></name> <operator>==</operator> <literal type="number">6</literal> <operator>&amp;&amp;</operator> <name><name>osv</name><operator>.</operator><name>dwMinorVersion</name></name> <operator>&gt;=</operator> <literal type="number">0</literal><operator>)</operator><operator>)</operator></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>pgwin32_IsInstalled</name><parameter_list>(<parameter><decl><type><name>SC_HANDLE</name></type> <name>hSCM</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>SC_HANDLE</name></type>	<name>hService</name> <init>= <expr><call><name>OpenService</name><argument_list>(<argument><expr><name>hSCM</name></expr></argument>, <argument><expr><name>register_servicename</name></expr></argument>, <argument><expr><name>SERVICE_QUERY_CONFIG</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>bResult</name> <init>= <expr><operator>(</operator><name>hService</name> <operator>!=</operator> <name>NULL</name><operator>)</operator></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>bResult</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>CloseServiceHandle</name><argument_list>(<argument><expr><name>hService</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<return>return <expr><name>bResult</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type>
<name>pgwin32_CommandLine</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>registration</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>cmdLine</name> <init>= <expr><call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>cmdPath</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>ret</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>registration</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>find_my_exec</name><argument_list>(<argument><expr><name>argv0</name></expr></argument>, <argument><expr><name>cmdPath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>write_stderr</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: could not find own program executable\n"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>progname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>find_other_exec</name><argument_list>(<argument><expr><name>argv0</name></expr></argument>, <argument><expr><literal type="string">"postgres"</literal></expr></argument>, <argument><expr><name>PG_BACKEND_VERSIONSTR</name></expr></argument>,
							  <argument><expr><name>cmdPath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>write_stderr</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: could not find postgres program executable\n"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>progname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/* if path does not end in .exe, append it */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>strlen</name><argument_list>(<argument><expr><name>cmdPath</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">4</literal> <operator>||</operator>
		<call><name>pg_strcasecmp</name><argument_list>(<argument><expr><name>cmdPath</name> <operator>+</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>cmdPath</name></expr></argument>)</argument_list></call> <operator>-</operator> <literal type="number">4</literal></expr></argument>, <argument><expr><literal type="string">".exe"</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>cmdPath</name> <operator>+</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>cmdPath</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>cmdPath</name></expr></argument>)</argument_list></sizeof> <operator>-</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>cmdPath</name></expr></argument>)</argument_list></call></expr></argument>,
				 <argument><expr><literal type="string">".exe"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* use backslashes in path to avoid problems with some third-party tools */</comment>
	<expr_stmt><expr><call><name>make_native_path</name><argument_list>(<argument><expr><name>cmdPath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* be sure to double-quote the executable's name in the command */</comment>
	<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>cmdLine</name></expr></argument>, <argument><expr><literal type="string">"\"%s\""</literal></expr></argument>, <argument><expr><name>cmdPath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* append assorted switches to the command line, as needed */</comment>

	<if_stmt><if>if <condition>(<expr><name>registration</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>cmdLine</name></expr></argument>, <argument><expr><literal type="string">" runservice -N \"%s\""</literal></expr></argument>,
						  <argument><expr><name>register_servicename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>pg_config</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* We need the -D path to be absolute */</comment>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>dataDir</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><operator>(</operator><name>dataDir</name> <operator>=</operator> <call><name>make_absolute_path</name><argument_list>(<argument><expr><name>pg_config</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* make_absolute_path already reported the error */</comment>
			<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><call><name>make_native_path</name><argument_list>(<argument><expr><name>dataDir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>cmdLine</name></expr></argument>, <argument><expr><literal type="string">" -D \"%s\""</literal></expr></argument>, <argument><expr><name>dataDir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>dataDir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>registration</name> <operator>&amp;&amp;</operator> <name>event_source</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>cmdLine</name></expr></argument>, <argument><expr><literal type="string">" -e \"%s\""</literal></expr></argument>, <argument><expr><name>event_source</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>registration</name> <operator>&amp;&amp;</operator> <name>do_wait</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>cmdLine</name></expr></argument>, <argument><expr><literal type="string">" -w"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Don't propagate a value from an environment variable. */</comment>
	<if_stmt><if>if <condition>(<expr><name>registration</name> <operator>&amp;&amp;</operator> <name>wait_seconds_arg</name> <operator>&amp;&amp;</operator> <name>wait_seconds</name> <operator>!=</operator> <name>DEFAULT_WAIT</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>cmdLine</name></expr></argument>, <argument><expr><literal type="string">" -t %d"</literal></expr></argument>, <argument><expr><name>wait_seconds</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>registration</name> <operator>&amp;&amp;</operator> <name>silent_mode</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>cmdLine</name></expr></argument>, <argument><expr><literal type="string">" -s"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>post_opts</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>registration</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>cmdLine</name></expr></argument>, <argument><expr><literal type="string">" -o \"%s\""</literal></expr></argument>, <argument><expr><name>post_opts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>cmdLine</name></expr></argument>, <argument><expr><literal type="string">" %s"</literal></expr></argument>, <argument><expr><name>post_opts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name><name>cmdLine</name><operator>-&gt;</operator><name>data</name></name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>pgwin32_doRegister</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>SC_HANDLE</name></type>	<name>hService</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SC_HANDLE</name></type>	<name>hSCM</name> <init>= <expr><call><name>OpenSCManager</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>SC_MANAGER_ALL_ACCESS</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>hSCM</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>write_stderr</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: could not open service manager\n"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>progname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>pgwin32_IsInstalled</name><argument_list>(<argument><expr><name>hSCM</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>CloseServiceHandle</name><argument_list>(<argument><expr><name>hSCM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>write_stderr</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: service \"%s\" already registered\n"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>progname</name></expr></argument>, <argument><expr><name>register_servicename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>hService</name> <operator>=</operator> <call><name>CreateService</name><argument_list>(<argument><expr><name>hSCM</name></expr></argument>, <argument><expr><name>register_servicename</name></expr></argument>, <argument><expr><name>register_servicename</name></expr></argument>,
								  <argument><expr><name>SERVICE_ALL_ACCESS</name></expr></argument>, <argument><expr><name>SERVICE_WIN32_OWN_PROCESS</name></expr></argument>,
								  <argument><expr><name>pgctl_start_type</name></expr></argument>, <argument><expr><name>SERVICE_ERROR_NORMAL</name></expr></argument>,
								  <argument><expr><call><name>pgwin32_CommandLine</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></argument>,
								  <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="string">"RPCSS\0"</literal></expr></argument>, <argument><expr><name>register_username</name></expr></argument>, <argument><expr><name>register_password</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>CloseServiceHandle</name><argument_list>(<argument><expr><name>hSCM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>write_stderr</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: could not register service \"%s\": error code %lu\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
					 <argument><expr><name>progname</name></expr></argument>, <argument><expr><name>register_servicename</name></expr></argument>,
					 <argument><expr><operator>(</operator><name>unsigned</name> <name>long</name><operator>)</operator> <call><name>GetLastError</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>CloseServiceHandle</name><argument_list>(<argument><expr><name>hService</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>CloseServiceHandle</name><argument_list>(<argument><expr><name>hSCM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>pgwin32_doUnregister</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>SC_HANDLE</name></type>	<name>hService</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SC_HANDLE</name></type>	<name>hSCM</name> <init>= <expr><call><name>OpenSCManager</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>SC_MANAGER_ALL_ACCESS</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>hSCM</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>write_stderr</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: could not open service manager\n"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>progname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>pgwin32_IsInstalled</name><argument_list>(<argument><expr><name>hSCM</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>CloseServiceHandle</name><argument_list>(<argument><expr><name>hSCM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>write_stderr</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: service \"%s\" not registered\n"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>progname</name></expr></argument>, <argument><expr><name>register_servicename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>hService</name> <operator>=</operator> <call><name>OpenService</name><argument_list>(<argument><expr><name>hSCM</name></expr></argument>, <argument><expr><name>register_servicename</name></expr></argument>, <argument><expr><name>DELETE</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>CloseServiceHandle</name><argument_list>(<argument><expr><name>hSCM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>write_stderr</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: could not open service \"%s\": error code %lu\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
					 <argument><expr><name>progname</name></expr></argument>, <argument><expr><name>register_servicename</name></expr></argument>,
					 <argument><expr><operator>(</operator><name>unsigned</name> <name>long</name><operator>)</operator> <call><name>GetLastError</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>DeleteService</name><argument_list>(<argument><expr><name>hService</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>CloseServiceHandle</name><argument_list>(<argument><expr><name>hService</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>CloseServiceHandle</name><argument_list>(<argument><expr><name>hSCM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>write_stderr</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: could not unregister service \"%s\": error code %lu\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
					 <argument><expr><name>progname</name></expr></argument>, <argument><expr><name>register_servicename</name></expr></argument>,
					 <argument><expr><operator>(</operator><name>unsigned</name> <name>long</name><operator>)</operator> <call><name>GetLastError</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>CloseServiceHandle</name><argument_list>(<argument><expr><name>hService</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>CloseServiceHandle</name><argument_list>(<argument><expr><name>hSCM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>pgwin32_SetServiceStatus</name><parameter_list>(<parameter><decl><type><name>DWORD</name></type> <name>currentState</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><name><name>status</name><operator>.</operator><name>dwCurrentState</name></name> <operator>=</operator> <name>currentState</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SetServiceStatus</name><argument_list>(<argument><expr><name>hStatus</name></expr></argument>, <argument><expr><operator>(</operator><name>LPSERVICE_STATUS</name><operator>)</operator> <operator>&amp;</operator><name>status</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name> <name>WINAPI</name></type>
<name>pgwin32_ServiceHandler</name><parameter_list>(<parameter><decl><type><name>DWORD</name></type> <name>request</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<switch>switch <condition>(<expr><name>request</name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>SERVICE_CONTROL_STOP</name></expr>:</case>
		<case>case <expr><name>SERVICE_CONTROL_SHUTDOWN</name></expr>:</case>

			<comment type="block">/*
			 * We only need a short wait hint here as it just needs to wait
			 * for the next checkpoint. They occur every 5 seconds during
			 * shutdown
			 */</comment>
			<expr_stmt><expr><name><name>status</name><operator>.</operator><name>dwWaitHint</name></name> <operator>=</operator> <literal type="number">10000</literal></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>pgwin32_SetServiceStatus</name><argument_list>(<argument><expr><name>SERVICE_STOP_PENDING</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>SetEvent</name><argument_list>(<argument><expr><name>shutdownEvent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return;</return>

		<case>case <expr><name>SERVICE_CONTROL_PAUSE</name></expr>:</case>
			<comment type="block">/* Win32 config reloading */</comment>
			<expr_stmt><expr><name><name>status</name><operator>.</operator><name>dwWaitHint</name></name> <operator>=</operator> <literal type="number">5000</literal></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>kill</name><argument_list>(<argument><expr><name>postmasterPID</name></expr></argument>, <argument><expr><name>SIGHUP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return;</return>

			<comment type="block">/* FIXME: These could be used to replace other signals etc */</comment>
		<case>case <expr><name>SERVICE_CONTROL_CONTINUE</name></expr>:</case>
		<case>case <expr><name>SERVICE_CONTROL_INTERROGATE</name></expr>:</case>
		<default>default:</default>
			<break>break;</break>
	</block_content>}</block></switch>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name> <name>WINAPI</name></type>
<name>pgwin32_ServiceMain</name><parameter_list>(<parameter><decl><type><name>DWORD</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>LPTSTR</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PROCESS_INFORMATION</name></type> <name>pi</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>DWORD</name></type>		<name>ret</name></decl>;</decl_stmt>

	<comment type="block">/* Initialize variables */</comment>
	<expr_stmt><expr><name><name>status</name><operator>.</operator><name>dwWin32ExitCode</name></name> <operator>=</operator> <name>S_OK</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>status</name><operator>.</operator><name>dwCheckPoint</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>status</name><operator>.</operator><name>dwWaitHint</name></name> <operator>=</operator> <literal type="number">60000</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>status</name><operator>.</operator><name>dwServiceType</name></name> <operator>=</operator> <name>SERVICE_WIN32_OWN_PROCESS</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>status</name><operator>.</operator><name>dwControlsAccepted</name></name> <operator>=</operator> <name>SERVICE_ACCEPT_STOP</name> <operator>|</operator> <name>SERVICE_ACCEPT_SHUTDOWN</name> <operator>|</operator> <name>SERVICE_ACCEPT_PAUSE_CONTINUE</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>status</name><operator>.</operator><name>dwServiceSpecificExitCode</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>status</name><operator>.</operator><name>dwCurrentState</name></name> <operator>=</operator> <name>SERVICE_START_PENDING</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>pi</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>pi</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>read_post_opts</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Register the control request handler */</comment>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>hStatus</name> <operator>=</operator> <call><name>RegisterServiceCtrlHandler</name><argument_list>(<argument><expr><name>register_servicename</name></expr></argument>, <argument><expr><name>pgwin32_ServiceHandler</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <operator>(</operator><name>SERVICE_STATUS_HANDLE</name><operator>)</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>shutdownEvent</name> <operator>=</operator> <call><name>CreateEvent</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/* Start the postmaster */</comment>
	<expr_stmt><expr><call><name>pgwin32_SetServiceStatus</name><argument_list>(<argument><expr><name>SERVICE_START_PENDING</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>CreateRestrictedProcess</name><argument_list>(<argument><expr><call><name>pgwin32_CommandLine</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>pi</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>pgwin32_SetServiceStatus</name><argument_list>(<argument><expr><name>SERVICE_STOPPED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name>postmasterPID</name> <operator>=</operator> <name><name>pi</name><operator>.</operator><name>dwProcessId</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>postmasterProcess</name> <operator>=</operator> <name><name>pi</name><operator>.</operator><name>hProcess</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>CloseHandle</name><argument_list>(<argument><expr><name><name>pi</name><operator>.</operator><name>hThread</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>do_wait</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>write_eventlog</name><argument_list>(<argument><expr><name>EVENTLOG_INFORMATION_TYPE</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Waiting for server startup...\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>wait_for_postmaster</name><argument_list>(<argument><expr><name>postmasterPID</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>POSTMASTER_READY</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>write_eventlog</name><argument_list>(<argument><expr><name>EVENTLOG_ERROR_TYPE</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Timed out waiting for server startup\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>pgwin32_SetServiceStatus</name><argument_list>(<argument><expr><name>SERVICE_STOPPED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return;</return>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><call><name>write_eventlog</name><argument_list>(<argument><expr><name>EVENTLOG_INFORMATION_TYPE</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Server started and accepting connections\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>pgwin32_SetServiceStatus</name><argument_list>(<argument><expr><name>SERVICE_RUNNING</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Wait for quit... */</comment>
	<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>WaitForMultipleObjects</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>shutdownHandles</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>INFINITE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>pgwin32_SetServiceStatus</name><argument_list>(<argument><expr><name>SERVICE_STOP_PENDING</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<switch>switch <condition>(<expr><name>ret</name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>WAIT_OBJECT_0</name></expr>:</case>		<comment type="block">/* shutdown event */</comment>
			<block>{<block_content>
				<comment type="block">/*
				 * status.dwCheckPoint can be incremented by
				 * wait_for_postmaster(), so it might not start from 0.
				 */</comment>
				<decl_stmt><decl><type><name>int</name></type>			<name>maxShutdownCheckPoint</name> <init>= <expr><name><name>status</name><operator>.</operator><name>dwCheckPoint</name></name> <operator>+</operator> <literal type="number">12</literal></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>kill</name><argument_list>(<argument><expr><name>postmasterPID</name></expr></argument>, <argument><expr><name>SIGINT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/*
				 * Increment the checkpoint and try again. Abort after 12
				 * checkpoints as the postmaster has probably hung.
				 */</comment>
				<while>while <condition>(<expr><call><name>WaitForSingleObject</name><argument_list>(<argument><expr><name>postmasterProcess</name></expr></argument>, <argument><expr><literal type="number">5000</literal></expr></argument>)</argument_list></call> <operator>==</operator> <name>WAIT_TIMEOUT</name> <operator>&amp;&amp;</operator> <name><name>status</name><operator>.</operator><name>dwCheckPoint</name></name> <operator>&lt;</operator> <name>maxShutdownCheckPoint</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name><name>status</name><operator>.</operator><name>dwCheckPoint</name></name><operator>++</operator></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>SetServiceStatus</name><argument_list>(<argument><expr><name>hStatus</name></expr></argument>, <argument><expr><operator>(</operator><name>LPSERVICE_STATUS</name><operator>)</operator> <operator>&amp;</operator><name>status</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></while>
				<break>break;</break>
			</block_content>}</block>

		<case>case <expr><operator>(</operator><name>WAIT_OBJECT_0</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr>:</case>	<comment type="block">/* postmaster went down */</comment>
			<break>break;</break>

		<default>default:</default>
			<comment type="block">/* shouldn't get here? */</comment>
			<break>break;</break>
	</block_content>}</block></switch>

	<expr_stmt><expr><call><name>CloseHandle</name><argument_list>(<argument><expr><name>shutdownEvent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>CloseHandle</name><argument_list>(<argument><expr><name>postmasterProcess</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>pgwin32_SetServiceStatus</name><argument_list>(<argument><expr><name>SERVICE_STOPPED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>pgwin32_doRunAsService</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>SERVICE_TABLE_ENTRY</name></type> <name><name>st</name><index>[]</index></name> <init>= <expr><block>{<expr><block>{<expr><name>register_servicename</name></expr>, <expr><name>pgwin32_ServiceMain</name></expr>}</block></expr>,
	<expr><block>{<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>}</block></expr>}</block></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>StartServiceCtrlDispatcher</name><argument_list>(<argument><expr><name>st</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>write_stderr</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: could not start service \"%s\": error code %lu\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
					 <argument><expr><name>progname</name></expr></argument>, <argument><expr><name>register_servicename</name></expr></argument>,
					 <argument><expr><operator>(</operator><name>unsigned</name> <name>long</name><operator>)</operator> <call><name>GetLastError</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * Mingw headers are incomplete, and so are the libraries. So we have to load
 * a whole lot of API functions dynamically. Since we have to do this anyway,
 * also load the couple of functions that *do* exist in minwg headers but not
 * on NT4. That way, we don't break on NT4.
 */</comment>
<typedef>typedef <function_decl><type><name>BOOL</name></type> (<name>WINAPI</name> <modifier>*</modifier> <name>__CreateRestrictedToken</name>) <parameter_list>(<parameter><decl><type><name>HANDLE</name></type></decl></parameter>, <parameter><decl><type><name>DWORD</name></type></decl></parameter>, <parameter><decl><type><name>DWORD</name></type></decl></parameter>, <parameter><decl><type><name>PSID_AND_ATTRIBUTES</name></type></decl></parameter>, <parameter><decl><type><name>DWORD</name></type></decl></parameter>, <parameter><decl><type><name>PLUID_AND_ATTRIBUTES</name></type></decl></parameter>, <parameter><decl><type><name>DWORD</name></type></decl></parameter>, <parameter><decl><type><name>PSID_AND_ATTRIBUTES</name></type></decl></parameter>, <parameter><decl><type><name>PHANDLE</name></type></decl></parameter>)</parameter_list>;</function_decl></typedef>
<typedef>typedef <function_decl><type><name>BOOL</name></type> (<name>WINAPI</name> <modifier>*</modifier> <name>__IsProcessInJob</name>) <parameter_list>(<parameter><decl><type><name>HANDLE</name></type></decl></parameter>, <parameter><decl><type><name>HANDLE</name></type></decl></parameter>, <parameter><decl><type><name>PBOOL</name></type></decl></parameter>)</parameter_list>;</function_decl></typedef>
<typedef>typedef <function_decl><type><name>HANDLE</name></type> (<name>WINAPI</name> <modifier>*</modifier> <name>__CreateJobObject</name>) <parameter_list>(<parameter><decl><type><name>LPSECURITY_ATTRIBUTES</name></type></decl></parameter>, <parameter><decl><type><name>LPCTSTR</name></type></decl></parameter>)</parameter_list>;</function_decl></typedef>
<typedef>typedef <function_decl><type><name>BOOL</name></type> (<name>WINAPI</name> <modifier>*</modifier> <name>__SetInformationJobObject</name>) <parameter_list>(<parameter><decl><type><name>HANDLE</name></type></decl></parameter>, <parameter><decl><type><name>JOBOBJECTINFOCLASS</name></type></decl></parameter>, <parameter><decl><type><name>LPVOID</name></type></decl></parameter>, <parameter><decl><type><name>DWORD</name></type></decl></parameter>)</parameter_list>;</function_decl></typedef>
<typedef>typedef <function_decl><type><name>BOOL</name></type> (<name>WINAPI</name> <modifier>*</modifier> <name>__AssignProcessToJobObject</name>) <parameter_list>(<parameter><decl><type><name>HANDLE</name></type></decl></parameter>, <parameter><decl><type><name>HANDLE</name></type></decl></parameter>)</parameter_list>;</function_decl></typedef>
<typedef>typedef <function_decl><type><name>BOOL</name></type> (<name>WINAPI</name> <modifier>*</modifier> <name>__QueryInformationJobObject</name>) <parameter_list>(<parameter><decl><type><name>HANDLE</name></type></decl></parameter>, <parameter><decl><type><name>JOBOBJECTINFOCLASS</name></type></decl></parameter>, <parameter><decl><type><name>LPVOID</name></type></decl></parameter>, <parameter><decl><type><name>DWORD</name></type></decl></parameter>, <parameter><decl><type><name>LPDWORD</name></type></decl></parameter>)</parameter_list>;</function_decl></typedef>

<comment type="block">/*
 * Create a restricted token, a job object sandbox, and execute the specified
 * process with it.
 *
 * Returns 0 on success, non-zero on failure, same as CreateProcess().
 *
 * On NT4, or any other system not containing the required functions, will
 * launch the process under the current token without doing any modifications.
 *
 * NOTE! Job object will only work when running as a service, because it's
 * automatically destroyed when pg_ctl exits.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>CreateRestrictedProcess</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>cmd</name></decl></parameter>, <parameter><decl><type><name>PROCESS_INFORMATION</name> <modifier>*</modifier></type><name>processInfo</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>as_service</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>r</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BOOL</name></type>		<name>b</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>STARTUPINFO</name></type> <name>si</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HANDLE</name></type>		<name>origToken</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HANDLE</name></type>		<name>restrictedToken</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SID_IDENTIFIER_AUTHORITY</name></type> <name>NtAuthority</name> <init>= <expr><block>{<expr><name>SECURITY_NT_AUTHORITY</name></expr>}</block></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SID_AND_ATTRIBUTES</name></type> <name><name>dropSids</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PTOKEN_PRIVILEGES</name></type> <name>delPrivs</name></decl>;</decl_stmt>

	<comment type="block">/* Functions loaded dynamically */</comment>
	<decl_stmt><decl><type><name>__CreateRestrictedToken</name></type> <name>_CreateRestrictedToken</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>__IsProcessInJob</name></type> <name>_IsProcessInJob</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>__CreateJobObject</name></type> <name>_CreateJobObject</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>__SetInformationJobObject</name></type> <name>_SetInformationJobObject</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>__AssignProcessToJobObject</name></type> <name>_AssignProcessToJobObject</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>__QueryInformationJobObject</name></type> <name>_QueryInformationJobObject</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HANDLE</name></type>		<name>Kernel32Handle</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HANDLE</name></type>		<name>Advapi32Handle</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>ZeroMemory</name><argument_list>(<argument><expr><operator>&amp;</operator><name>si</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>si</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>si</name><operator>.</operator><name>cb</name></name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>si</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>

	<expr_stmt><expr><name>Advapi32Handle</name> <operator>=</operator> <call><name>LoadLibrary</name><argument_list>(<argument><expr><literal type="string">"ADVAPI32.DLL"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>Advapi32Handle</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>_CreateRestrictedToken</name> <operator>=</operator> <operator>(</operator><name>__CreateRestrictedToken</name><operator>)</operator> <call><name>GetProcAddress</name><argument_list>(<argument><expr><name>Advapi32Handle</name></expr></argument>, <argument><expr><literal type="string">"CreateRestrictedToken"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>_CreateRestrictedToken</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * NT4 doesn't have CreateRestrictedToken, so just call ordinary
		 * CreateProcess
		 */</comment>
		<expr_stmt><expr><call><name>write_stderr</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: WARNING: cannot create restricted tokens on this platform\n"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>progname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>Advapi32Handle</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>FreeLibrary</name><argument_list>(<argument><expr><name>Advapi32Handle</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<return>return <expr><call><name>CreateProcess</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>cmd</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>si</name></expr></argument>, <argument><expr><name>processInfo</name></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Open the current token to use as a base for the restricted one */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OpenProcessToken</name><argument_list>(<argument><expr><call><name>GetCurrentProcess</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>TOKEN_ALL_ACCESS</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>origToken</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Most Windows targets make DWORD a 32-bit unsigned long, but in case
		 * it doesn't cast DWORD before printing.
		 */</comment>
		<expr_stmt><expr><call><name>write_stderr</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: could not open process token: error code %lu\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
					 <argument><expr><name>progname</name></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name> <name>long</name><operator>)</operator> <call><name>GetLastError</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><literal type="number">0</literal></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Allocate list of SIDs to remove */</comment>
	<expr_stmt><expr><call><name>ZeroMemory</name><argument_list>(<argument><expr><operator>&amp;</operator><name>dropSids</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>dropSids</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>AllocateAndInitializeSid</name><argument_list>(<argument><expr><operator>&amp;</operator><name>NtAuthority</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>,
								  <argument><expr><name>SECURITY_BUILTIN_DOMAIN_RID</name></expr></argument>, <argument><expr><name>DOMAIN_ALIAS_RID_ADMINS</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
								  <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>dropSids</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>Sid</name></expr></argument>)</argument_list></call> <operator>||</operator>
		<operator>!</operator><call><name>AllocateAndInitializeSid</name><argument_list>(<argument><expr><operator>&amp;</operator><name>NtAuthority</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>,
								  <argument><expr><name>SECURITY_BUILTIN_DOMAIN_RID</name></expr></argument>, <argument><expr><name>DOMAIN_ALIAS_RID_POWER_USERS</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
								  <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>dropSids</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>Sid</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>write_stderr</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: could not allocate SIDs: error code %lu\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
					 <argument><expr><name>progname</name></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name> <name>long</name><operator>)</operator> <call><name>GetLastError</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><literal type="number">0</literal></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Get list of privileges to remove */</comment>
	<expr_stmt><expr><name>delPrivs</name> <operator>=</operator> <call><name>GetPrivilegesToDelete</name><argument_list>(<argument><expr><name>origToken</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>delPrivs</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<comment type="block">/* Error message already printed */</comment>
		<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>b</name> <operator>=</operator> <call><name>_CreateRestrictedToken</name><argument_list>(<argument><expr><name>origToken</name></expr></argument>,
							   <argument><expr><literal type="number">0</literal></expr></argument>,
							   <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>dropSids</name></expr></argument>)</argument_list></sizeof> <operator>/</operator> <sizeof>sizeof<argument_list>(<argument><expr><name><name>dropSids</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></sizeof></expr></argument>,
							   <argument><expr><name>dropSids</name></expr></argument>,
							   <argument><expr><name><name>delPrivs</name><operator>-&gt;</operator><name>PrivilegeCount</name></name></expr></argument>, <argument><expr><name><name>delPrivs</name><operator>-&gt;</operator><name>Privileges</name></name></expr></argument>,
							   <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
							   <argument><expr><operator>&amp;</operator><name>restrictedToken</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>delPrivs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>FreeSid</name><argument_list>(<argument><expr><name><name>dropSids</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>Sid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>FreeSid</name><argument_list>(<argument><expr><name><name>dropSids</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>Sid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>CloseHandle</name><argument_list>(<argument><expr><name>origToken</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>FreeLibrary</name><argument_list>(<argument><expr><name>Advapi32Handle</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>b</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>write_stderr</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: could not create restricted token: error code %lu\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
					 <argument><expr><name>progname</name></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name> <name>long</name><operator>)</operator> <call><name>GetLastError</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><literal type="number">0</literal></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>AddUserToTokenDacl</name><argument_list>(<argument><expr><name>restrictedToken</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>CreateProcessAsUser</name><argument_list>(<argument><expr><name>restrictedToken</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>cmd</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>, <argument><expr><name>CREATE_SUSPENDED</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>si</name></expr></argument>, <argument><expr><name>processInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>Kernel32Handle</name> <operator>=</operator> <call><name>LoadLibrary</name><argument_list>(<argument><expr><literal type="string">"KERNEL32.DLL"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>Kernel32Handle</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>_IsProcessInJob</name> <operator>=</operator> <operator>(</operator><name>__IsProcessInJob</name><operator>)</operator> <call><name>GetProcAddress</name><argument_list>(<argument><expr><name>Kernel32Handle</name></expr></argument>, <argument><expr><literal type="string">"IsProcessInJob"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>_CreateJobObject</name> <operator>=</operator> <operator>(</operator><name>__CreateJobObject</name><operator>)</operator> <call><name>GetProcAddress</name><argument_list>(<argument><expr><name>Kernel32Handle</name></expr></argument>, <argument><expr><literal type="string">"CreateJobObjectA"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>_SetInformationJobObject</name> <operator>=</operator> <operator>(</operator><name>__SetInformationJobObject</name><operator>)</operator> <call><name>GetProcAddress</name><argument_list>(<argument><expr><name>Kernel32Handle</name></expr></argument>, <argument><expr><literal type="string">"SetInformationJobObject"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>_AssignProcessToJobObject</name> <operator>=</operator> <operator>(</operator><name>__AssignProcessToJobObject</name><operator>)</operator> <call><name>GetProcAddress</name><argument_list>(<argument><expr><name>Kernel32Handle</name></expr></argument>, <argument><expr><literal type="string">"AssignProcessToJobObject"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>_QueryInformationJobObject</name> <operator>=</operator> <operator>(</operator><name>__QueryInformationJobObject</name><operator>)</operator> <call><name>GetProcAddress</name><argument_list>(<argument><expr><name>Kernel32Handle</name></expr></argument>, <argument><expr><literal type="string">"QueryInformationJobObject"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Verify that we found all functions */</comment>
	<if_stmt><if>if <condition>(<expr><name>_IsProcessInJob</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name>_CreateJobObject</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name>_SetInformationJobObject</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name>_AssignProcessToJobObject</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name>_QueryInformationJobObject</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * IsProcessInJob() is not available on &lt; WinXP, so there is no need
		 * to log the error every time in that case
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>IsWindowsXPOrGreater</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

			<comment type="block">/*
			 * Log error if we can't get version, or if we're on WinXP/2003 or
			 * newer
			 */</comment>
			<expr_stmt><expr><call><name>write_stderr</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: WARNING: could not locate all job object functions in system API\n"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>progname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<decl_stmt><decl><type><name>BOOL</name></type>		<name>inJob</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>_IsProcessInJob</name><argument_list>(<argument><expr><name><name>processInfo</name><operator>-&gt;</operator><name>hProcess</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>inJob</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>inJob</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/*
				 * Job objects are working, and the new process isn't in one,
				 * so we can create one safely. If any problems show up when
				 * setting it, we're going to ignore them.
				 */</comment>
				<decl_stmt><decl><type><name>HANDLE</name></type>		<name>job</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>char</name></type>		<name><name>jobname</name><index>[<expr><literal type="number">128</literal></expr>]</index></name></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>jobname</name></expr></argument>, <argument><expr><literal type="string">"PostgreSQL_%lu"</literal></expr></argument>,
						<argument><expr><operator>(</operator><name>unsigned</name> <name>long</name><operator>)</operator> <name><name>processInfo</name><operator>-&gt;</operator><name>dwProcessId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><name>job</name> <operator>=</operator> <call><name>_CreateJobObject</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>jobname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name>job</name></expr>)</condition>
				<block>{<block_content>
					<decl_stmt><decl><type><name>JOBOBJECT_BASIC_LIMIT_INFORMATION</name></type> <name>basicLimit</name></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>JOBOBJECT_BASIC_UI_RESTRICTIONS</name></type> <name>uiRestrictions</name></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>JOBOBJECT_SECURITY_LIMIT_INFORMATION</name></type> <name>securityLimit</name></decl>;</decl_stmt>

					<expr_stmt><expr><call><name>ZeroMemory</name><argument_list>(<argument><expr><operator>&amp;</operator><name>basicLimit</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>basicLimit</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>ZeroMemory</name><argument_list>(<argument><expr><operator>&amp;</operator><name>uiRestrictions</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>uiRestrictions</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>ZeroMemory</name><argument_list>(<argument><expr><operator>&amp;</operator><name>securityLimit</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>securityLimit</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<expr_stmt><expr><name><name>basicLimit</name><operator>.</operator><name>LimitFlags</name></name> <operator>=</operator> <name>JOB_OBJECT_LIMIT_DIE_ON_UNHANDLED_EXCEPTION</name> <operator>|</operator> <name>JOB_OBJECT_LIMIT_PRIORITY_CLASS</name></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>basicLimit</name><operator>.</operator><name>PriorityClass</name></name> <operator>=</operator> <name>NORMAL_PRIORITY_CLASS</name></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>_SetInformationJobObject</name><argument_list>(<argument><expr><name>job</name></expr></argument>, <argument><expr><name>JobObjectBasicLimitInformation</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>basicLimit</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>basicLimit</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<expr_stmt><expr><name><name>uiRestrictions</name><operator>.</operator><name>UIRestrictionsClass</name></name> <operator>=</operator> <name>JOB_OBJECT_UILIMIT_DESKTOP</name> <operator>|</operator> <name>JOB_OBJECT_UILIMIT_DISPLAYSETTINGS</name> <operator>|</operator>
						<name>JOB_OBJECT_UILIMIT_EXITWINDOWS</name> <operator>|</operator> <name>JOB_OBJECT_UILIMIT_READCLIPBOARD</name> <operator>|</operator>
						<name>JOB_OBJECT_UILIMIT_SYSTEMPARAMETERS</name> <operator>|</operator> <name>JOB_OBJECT_UILIMIT_WRITECLIPBOARD</name></expr>;</expr_stmt>

					<if_stmt><if>if <condition>(<expr><name>as_service</name></expr>)</condition>
					<block>{<block_content>
						<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsWindows7OrGreater</name><argument_list>()</argument_list></call></expr>)</condition>
						<block>{<block_content>
							<comment type="block">/*
							 * On Windows 7 (and presumably later),
							 * JOB_OBJECT_UILIMIT_HANDLES prevents us from
							 * starting as a service. So we only enable it on
							 * Vista and earlier (version &lt;= 6.0)
							 */</comment>
							<expr_stmt><expr><name><name>uiRestrictions</name><operator>.</operator><name>UIRestrictionsClass</name></name> <operator>|=</operator> <name>JOB_OBJECT_UILIMIT_HANDLES</name></expr>;</expr_stmt>
						</block_content>}</block></if></if_stmt>
					</block_content>}</block></if></if_stmt>
					<expr_stmt><expr><call><name>_SetInformationJobObject</name><argument_list>(<argument><expr><name>job</name></expr></argument>, <argument><expr><name>JobObjectBasicUIRestrictions</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>uiRestrictions</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>uiRestrictions</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<expr_stmt><expr><name><name>securityLimit</name><operator>.</operator><name>SecurityLimitFlags</name></name> <operator>=</operator> <name>JOB_OBJECT_SECURITY_NO_ADMIN</name> <operator>|</operator> <name>JOB_OBJECT_SECURITY_ONLY_TOKEN</name></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>securityLimit</name><operator>.</operator><name>JobToken</name></name> <operator>=</operator> <name>restrictedToken</name></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>_SetInformationJobObject</name><argument_list>(<argument><expr><name>job</name></expr></argument>, <argument><expr><name>JobObjectSecurityLimitInformation</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>securityLimit</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>securityLimit</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<expr_stmt><expr><call><name>_AssignProcessToJobObject</name><argument_list>(<argument><expr><name>job</name></expr></argument>, <argument><expr><name><name>processInfo</name><operator>-&gt;</operator><name>hProcess</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></else></if_stmt>


	<expr_stmt><expr><call><name>CloseHandle</name><argument_list>(<argument><expr><name>restrictedToken</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ResumeThread</name><argument_list>(<argument><expr><name><name>processInfo</name><operator>-&gt;</operator><name>hThread</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>FreeLibrary</name><argument_list>(<argument><expr><name>Kernel32Handle</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * We intentionally don't close the job object handle, because we want the
	 * object to live on until pg_ctl shuts down.
	 */</comment>
	<return>return <expr><name>r</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Get a list of privileges to delete from the access token. We delete all privileges
 * except SeLockMemoryPrivilege which is needed to use large pages, and
 * SeChangeNotifyPrivilege which is enabled by default in DISABLE_MAX_PRIVILEGE.
 */</comment>
<function><type><specifier>static</specifier> <name>PTOKEN_PRIVILEGES</name></type>
<name>GetPrivilegesToDelete</name><parameter_list>(<parameter><decl><type><name>HANDLE</name></type> <name>hToken</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>,
				<decl><type ref="prev"/><name>j</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>DWORD</name></type>		<name>length</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PTOKEN_PRIVILEGES</name></type> <name>tokenPrivs</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>LUID</name></type>		<name>luidLockPages</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>LUID</name></type>		<name>luidChangeNotify</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>LookupPrivilegeValue</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>SE_LOCK_MEMORY_NAME</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>luidLockPages</name></expr></argument>)</argument_list></call> <operator>||</operator>
		<operator>!</operator><call><name>LookupPrivilegeValue</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>SE_CHANGE_NOTIFY_NAME</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>luidChangeNotify</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>write_stderr</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: could not get LUIDs for privileges: error code %lu\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
					 <argument><expr><name>progname</name></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name> <name>long</name><operator>)</operator> <call><name>GetLastError</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>GetTokenInformation</name><argument_list>(<argument><expr><name>hToken</name></expr></argument>, <argument><expr><name>TokenPrivileges</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>length</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
		<call><name>GetLastError</name><argument_list>()</argument_list></call> <operator>!=</operator> <name>ERROR_INSUFFICIENT_BUFFER</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>write_stderr</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: could not get token information: error code %lu\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
					 <argument><expr><name>progname</name></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name> <name>long</name><operator>)</operator> <call><name>GetLastError</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>tokenPrivs</name> <operator>=</operator> <operator>(</operator><name>PTOKEN_PRIVILEGES</name><operator>)</operator> <call><name>malloc</name><argument_list>(<argument><expr><name>length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>tokenPrivs</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>write_stderr</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: out of memory\n"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>progname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>GetTokenInformation</name><argument_list>(<argument><expr><name>hToken</name></expr></argument>, <argument><expr><name>TokenPrivileges</name></expr></argument>, <argument><expr><name>tokenPrivs</name></expr></argument>, <argument><expr><name>length</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>length</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>write_stderr</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: could not get token information: error code %lu\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
					 <argument><expr><name>progname</name></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name> <name>long</name><operator>)</operator> <call><name>GetLastError</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>tokenPrivs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>tokenPrivs</name><operator>-&gt;</operator><name>PrivilegeCount</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>memcmp</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>tokenPrivs</name><operator>-&gt;</operator><name>Privileges</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>Luid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>luidLockPages</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>LUID</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
			<call><name>memcmp</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>tokenPrivs</name><operator>-&gt;</operator><name>Privileges</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>Luid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>luidChangeNotify</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>LUID</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <name>i</name></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name><name>tokenPrivs</name><operator>-&gt;</operator><name>PrivilegeCount</name></name> <operator>-</operator> <literal type="number">1</literal></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>tokenPrivs</name><operator>-&gt;</operator><name>Privileges</name><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <name><name>tokenPrivs</name><operator>-&gt;</operator><name>Privileges</name><index>[<expr><name>j</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt></block_content></block></for>
			<expr_stmt><expr><name><name>tokenPrivs</name><operator>-&gt;</operator><name>PrivilegeCount</name></name><operator>--</operator></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>

	<return>return <expr><name>tokenPrivs</name></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>							<comment type="block">/* WIN32 */</comment>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>do_advice</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>write_stderr</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Try \"%s --help\" for more information.\n"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>progname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>



<function><type><specifier>static</specifier> <name>void</name></type>
<name>do_help</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s is a utility to initialize, start, stop, or control a PostgreSQL server.\n\n"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>progname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Usage:\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"  %s init[db] [-D DATADIR] [-s] [-o OPTIONS]\n"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>progname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"  %s start    [-D DATADIR] [-l FILENAME] [-W] [-t SECS] [-s]\n"</literal>
			 <literal type="string">"                  [-o OPTIONS] [-p PATH] [-c]\n"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>progname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"  %s stop     [-D DATADIR] [-m SHUTDOWN-MODE] [-W] [-t SECS] [-s]\n"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>progname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"  %s restart  [-D DATADIR] [-m SHUTDOWN-MODE] [-W] [-t SECS] [-s]\n"</literal>
			 <literal type="string">"                  [-o OPTIONS] [-c]\n"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>progname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"  %s reload   [-D DATADIR] [-s]\n"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>progname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"  %s status   [-D DATADIR]\n"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>progname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* POLAR */</comment>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"  %s promote  [-D DATADIR] [-W] [-t SECS] [-s] [-f]\n"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>progname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* POLAR end */</comment>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"  %s kill     SIGNALNAME PID\n"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>progname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WIN32</name></cpp:ifdef>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"  %s register [-D DATADIR] [-N SERVICENAME] [-U USERNAME] [-P PASSWORD]\n"</literal>
			 <literal type="string">"                  [-S START-TYPE] [-e SOURCE] [-W] [-t SECS] [-s] [-o OPTIONS]\n"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>progname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"  %s unregister [-N SERVICENAME]\n"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>progname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"\nCommon options:\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"  -D, --pgdata=DATADIR   location of the database storage area\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WIN32</name></cpp:ifdef>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"  -e SOURCE              event source for logging when running as a service\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"  -s, --silent           only print errors, no informational messages\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"  -t, --timeout=SECS     seconds to wait when using -w option\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"  -V, --version          output version information, then exit\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"  -w, --wait             wait until operation completes (default)\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"  -W, --no-wait          do not wait until operation completes\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"  -?, --help             show this help, then exit\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"If the -D option is omitted, the environment variable PGDATA is used.\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"\nOptions for start or restart:\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_GETRLIMIT</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>defined</name><argument_list>(<argument><expr><name>RLIMIT_CORE</name></expr></argument>)</argument_list></call></expr></cpp:if>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"  -c, --core-files       allow postgres to produce core files\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"  -c, --core-files       not applicable on this platform\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"  -l, --log=FILENAME     write (or append) server log to FILENAME\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"  -o, --options=OPTIONS  command line options to pass to postgres\n"</literal>
			 <literal type="string">"                         (PostgreSQL server executable) or initdb\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"  -p PATH-TO-POSTGRES    normally not necessary\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"\nOptions for stop or restart:\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"  -m, --mode=MODE        MODE can be \"smart\", \"fast\", or \"immediate\"\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"\nShutdown modes are:\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"  smart       quit after all clients have disconnected\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"  fast        quit directly, with proper shutdown (default)\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"  immediate   quit without complete shutdown; will lead to recovery on restart\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* POLAR */</comment>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"  -f, --force-promote    force promote without any constraints\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* POLAR end */</comment>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"\nAllowed signal names for kill:\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"  ABRT HUP INT KILL QUIT TERM USR1 USR2\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WIN32</name></cpp:ifdef>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"\nOptions for register and unregister:\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"  -N SERVICENAME  service name with which to register PostgreSQL server\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"  -P PASSWORD     password of account to register PostgreSQL server\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"  -U USERNAME     user name of account to register PostgreSQL server\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"  -S START-TYPE   service start type to register PostgreSQL server\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"\nStart types are:\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"  auto       start service automatically during system startup (default)\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"  demand     start service on demand\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"\nReport bugs to &lt;pgsql-bugs@postgresql.org&gt;.\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>



<function><type><specifier>static</specifier> <name>void</name></type>
<name>set_mode</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>modeopt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>modeopt</name></expr></argument>, <argument><expr><literal type="string">"s"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <call><name>strcmp</name><argument_list>(<argument><expr><name>modeopt</name></expr></argument>, <argument><expr><literal type="string">"smart"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>shutdown_mode</name> <operator>=</operator> <name>SMART_MODE</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>sig</name> <operator>=</operator> <name>SIGTERM</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>modeopt</name></expr></argument>, <argument><expr><literal type="string">"f"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <call><name>strcmp</name><argument_list>(<argument><expr><name>modeopt</name></expr></argument>, <argument><expr><literal type="string">"fast"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>shutdown_mode</name> <operator>=</operator> <name>FAST_MODE</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>sig</name> <operator>=</operator> <name>SIGINT</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>modeopt</name></expr></argument>, <argument><expr><literal type="string">"i"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <call><name>strcmp</name><argument_list>(<argument><expr><name>modeopt</name></expr></argument>, <argument><expr><literal type="string">"immediate"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>shutdown_mode</name> <operator>=</operator> <name>IMMEDIATE_MODE</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>sig</name> <operator>=</operator> <name>SIGQUIT</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>write_stderr</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: unrecognized shutdown mode \"%s\"\n"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>progname</name></expr></argument>, <argument><expr><name>modeopt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>do_advice</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>



<function><type><specifier>static</specifier> <name>void</name></type>
<name>set_sig</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>signame</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>signame</name></expr></argument>, <argument><expr><literal type="string">"HUP"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>sig</name> <operator>=</operator> <name>SIGHUP</name></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>signame</name></expr></argument>, <argument><expr><literal type="string">"INT"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>sig</name> <operator>=</operator> <name>SIGINT</name></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>signame</name></expr></argument>, <argument><expr><literal type="string">"QUIT"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>sig</name> <operator>=</operator> <name>SIGQUIT</name></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>signame</name></expr></argument>, <argument><expr><literal type="string">"ABRT"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>sig</name> <operator>=</operator> <name>SIGABRT</name></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>signame</name></expr></argument>, <argument><expr><literal type="string">"KILL"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>sig</name> <operator>=</operator> <name>SIGKILL</name></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>signame</name></expr></argument>, <argument><expr><literal type="string">"TERM"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>sig</name> <operator>=</operator> <name>SIGTERM</name></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>signame</name></expr></argument>, <argument><expr><literal type="string">"USR1"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>sig</name> <operator>=</operator> <name>SIGUSR1</name></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>signame</name></expr></argument>, <argument><expr><literal type="string">"USR2"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>sig</name> <operator>=</operator> <name>SIGUSR2</name></expr>;</expr_stmt></block_content></block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>write_stderr</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: unrecognized signal name \"%s\"\n"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>progname</name></expr></argument>, <argument><expr><name>signame</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>do_advice</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>


<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WIN32</name></cpp:ifdef>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>set_starttype</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>starttypeopt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>starttypeopt</name></expr></argument>, <argument><expr><literal type="string">"a"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <call><name>strcmp</name><argument_list>(<argument><expr><name>starttypeopt</name></expr></argument>, <argument><expr><literal type="string">"auto"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>pgctl_start_type</name> <operator>=</operator> <name>SERVICE_AUTO_START</name></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>starttypeopt</name></expr></argument>, <argument><expr><literal type="string">"d"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <call><name>strcmp</name><argument_list>(<argument><expr><name>starttypeopt</name></expr></argument>, <argument><expr><literal type="string">"demand"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>pgctl_start_type</name> <operator>=</operator> <name>SERVICE_DEMAND_START</name></expr>;</expr_stmt></block_content></block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>write_stderr</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: unrecognized start type \"%s\"\n"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>progname</name></expr></argument>, <argument><expr><name>starttypeopt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>do_advice</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
 * adjust_data_dir
 *
 * If a configuration-only directory was specified, find the real data dir.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>adjust_data_dir</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>cmd</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name></decl>,
				<decl><type ref="prev"/><name><name>filename</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name>my_exec_path</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>FILE</name>	   <modifier>*</modifier></type><name>fd</name></decl>;</decl_stmt>

	<comment type="block">/* do nothing if we're working without knowledge of data dir */</comment>
	<if_stmt><if>if <condition>(<expr><name>pg_config</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/* If there is no postgresql.conf, it can't be a config-only dir */</comment>
	<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>filename</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>filename</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"%s/postgresql.conf"</literal></expr></argument>, <argument><expr><name>pg_config</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>fd</name> <operator>=</operator> <call><name>fopen</name><argument_list>(<argument><expr><name>filename</name></expr></argument>, <argument><expr><literal type="string">"r"</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>
	<expr_stmt><expr><call><name>fclose</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* If PG_VERSION exists, it can't be a config-only dir */</comment>
	<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>filename</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>filename</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"%s/PG_VERSION"</literal></expr></argument>, <argument><expr><name>pg_config</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>fd</name> <operator>=</operator> <call><name>fopen</name><argument_list>(<argument><expr><name>filename</name></expr></argument>, <argument><expr><literal type="string">"r"</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>fclose</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Must be a configuration directory, so find the data directory */</comment>

	<comment type="block">/* we use a private my_exec_path to avoid interfering with later uses */</comment>
	<if_stmt><if>if <condition>(<expr><name>exec_path</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>my_exec_path</name> <operator>=</operator> <call><name>find_other_exec_or_die</name><argument_list>(<argument><expr><name>argv0</name></expr></argument>, <argument><expr><literal type="string">"postgres"</literal></expr></argument>, <argument><expr><name>PG_BACKEND_VERSIONSTR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>my_exec_path</name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><name>exec_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/* it's important for -C to be the first option, see main.c */</comment>
	<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>cmd</name></expr></argument>, <argument><expr><name>MAXPGPATH</name></expr></argument>, <argument><expr><literal type="string">"\"%s\" -C data_directory %s%s"</literal></expr></argument>,
			 <argument><expr><name>my_exec_path</name></expr></argument>,
			 <argument><expr><ternary><condition><expr><name>pgdata_opt</name></expr> ?</condition><then> <expr><name>pgdata_opt</name></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>,
			 <argument><expr><ternary><condition><expr><name>post_opts</name></expr> ?</condition><then> <expr><name>post_opts</name></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>fd</name> <operator>=</operator> <call><name>popen</name><argument_list>(<argument><expr><name>cmd</name></expr></argument>, <argument><expr><literal type="string">"r"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>fd</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <call><name>fgets</name><argument_list>(<argument><expr><name>filename</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>filename</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>fd</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>write_stderr</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: could not determine the data directory using command \"%s\"\n"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>progname</name></expr></argument>, <argument><expr><name>cmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>pclose</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>my_exec_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Remove trailing newline */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>strchr</name><argument_list>(<argument><expr><name>filename</name></expr></argument>, <argument><expr><literal type="char">'\n'</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><operator>*</operator><call><name>strchr</name><argument_list>(<argument><expr><name>filename</name></expr></argument>, <argument><expr><literal type="char">'\n'</literal></expr></argument>)</argument_list></call> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>pg_data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>pg_data</name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><name>filename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>canonicalize_path</name><argument_list>(<argument><expr><name>pg_data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>DBState</name></type>
<name>get_control_dbstate</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>DBState</name></type>		<name>ret</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>crc_ok</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ControlFileData</name> <modifier>*</modifier></type><name>control_file_data</name> <init>= <expr><call><name>get_controlfile</name><argument_list>(<argument><expr><name>pg_data</name></expr></argument>, <argument><expr><name>progname</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>crc_ok</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>crc_ok</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>write_stderr</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: control file appears to be corrupt\n"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>progname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>ret</name> <operator>=</operator> <name><name>control_file_data</name><operator>-&gt;</operator><name>state</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>control_file_data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>


<function><type><name>int</name></type>
<name>main</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>argv</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>static</specifier> <name><name>struct</name> <name>option</name></name></type> <name><name>long_options</name><index>[]</index></name> <init>= <expr><block>{
		<expr><block>{<expr><literal type="string">"help"</literal></expr>, <expr><name>no_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="char">'?'</literal></expr>}</block></expr>,
		<expr><block>{<expr><literal type="string">"version"</literal></expr>, <expr><name>no_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="char">'V'</literal></expr>}</block></expr>,
		<expr><block>{<expr><literal type="string">"log"</literal></expr>, <expr><name>required_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="char">'l'</literal></expr>}</block></expr>,
		<expr><block>{<expr><literal type="string">"mode"</literal></expr>, <expr><name>required_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="char">'m'</literal></expr>}</block></expr>,
		<expr><block>{<expr><literal type="string">"pgdata"</literal></expr>, <expr><name>required_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="char">'D'</literal></expr>}</block></expr>,
		<expr><block>{<expr><literal type="string">"options"</literal></expr>, <expr><name>required_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="char">'o'</literal></expr>}</block></expr>,
		<expr><block>{<expr><literal type="string">"silent"</literal></expr>, <expr><name>no_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="char">'s'</literal></expr>}</block></expr>,
		<expr><block>{<expr><literal type="string">"timeout"</literal></expr>, <expr><name>required_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="char">'t'</literal></expr>}</block></expr>,
		<expr><block>{<expr><literal type="string">"core-files"</literal></expr>, <expr><name>no_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="char">'c'</literal></expr>}</block></expr>,
		<expr><block>{<expr><literal type="string">"wait"</literal></expr>, <expr><name>no_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="char">'w'</literal></expr>}</block></expr>,
		<expr><block>{<expr><literal type="string">"no-wait"</literal></expr>, <expr><name>no_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="char">'W'</literal></expr>}</block></expr>,
		<expr><block>{<expr><name>NULL</name></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>NULL</name></expr>, <expr><literal type="number">0</literal></expr>}</block></expr>
	}</block></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>env_wait</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>option_index</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>c</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>pgpid_t</name></type>		<name>killproc</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WIN32</name></cpp:ifdef>
	<expr_stmt><expr><call><name>setvbuf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>_IONBF</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<expr_stmt><expr><name>progname</name> <operator>=</operator> <call><name>get_progname</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>set_pglocale_pgservice</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><call><name>PG_TEXTDOMAIN</name><argument_list>(<argument><expr><literal type="string">"pg_ctl"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>start_time</name> <operator>=</operator> <call><name>time</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * save argv[0] so do_start() can look for the postmaster if necessary. we
	 * don't look for postmaster here because in many cases we won't need it.
	 */</comment>
	<expr_stmt><expr><name>argv0</name> <operator>=</operator> <name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>

	<comment type="block">/* Set restrictive mode mask until PGDATA permissions are checked */</comment>
	<expr_stmt><expr><call><name>umask</name><argument_list>(<argument><expr><name>PG_MODE_MASK_OWNER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* support --help and --version even if invoked as root */</comment>
	<if_stmt><if>if <condition>(<expr><name>argc</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"--help"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <call><name>strcmp</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"-?"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>do_help</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"--version"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <call><name>strcmp</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"-V"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>puts</name><argument_list>(<argument><expr><literal type="string">"pg_ctl (PostgreSQL) "</literal> <name>PG_VERSION</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Disallow running as root, to forestall any possible security holes.
	 */</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>WIN32</name></cpp:ifndef>
	<if_stmt><if>if <condition>(<expr><call><name>geteuid</name><argument_list>()</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>write_stderr</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: cannot be run as root\n"</literal>
					   <literal type="string">"Please log in (using, e.g., \"su\") as the "</literal>
					   <literal type="string">"(unprivileged) user that will\n"</literal>
					   <literal type="string">"own the server process.\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
					 <argument><expr><name>progname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<expr_stmt><expr><name>env_wait</name> <operator>=</operator> <call><name>getenv</name><argument_list>(<argument><expr><literal type="string">"PGCTLTIMEOUT"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>env_wait</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>wait_seconds</name> <operator>=</operator> <call><name>atoi</name><argument_list>(<argument><expr><name>env_wait</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * 'Action' can be before or after args so loop over both. Some
	 * getopt_long() implementations will reorder argv[] to place all flags
	 * first (GNU?), but we don't rely on it. Our /port version doesn't do
	 * that.
	 */</comment>
	<expr_stmt><expr><name>optind</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

	<comment type="block">/* process command-line options */</comment>
	<while>while <condition>(<expr><name>optind</name> <operator>&lt;</operator> <name>argc</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* POLAR: add force promote args */</comment>
		<while>while <condition>(<expr><operator>(</operator><name>c</name> <operator>=</operator> <call><name>getopt_long</name><argument_list>(<argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>, <argument><expr><literal type="string">"cD:e:l:m:N:o:p:P:sS:t:U:wWf"</literal></expr></argument>,
								<argument><expr><name>long_options</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>option_index</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>
		<block>{<block_content>
			<switch>switch <condition>(<expr><name>c</name></expr>)</condition>
			<block>{<block_content>
				<case>case <expr><literal type="char">'D'</literal></expr>:</case>
					<block>{<block_content>
						<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>pgdata_D</name></decl>;</decl_stmt>
						<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>env_var</name></decl>;</decl_stmt>

						<expr_stmt><expr><name>pgdata_D</name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><name>optarg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><call><name>canonicalize_path</name><argument_list>(<argument><expr><name>pgdata_D</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><name>env_var</name> <operator>=</operator> <call><name>psprintf</name><argument_list>(<argument><expr><literal type="string">"PGDATA=%s"</literal></expr></argument>, <argument><expr><name>pgdata_D</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><call><name>putenv</name><argument_list>(<argument><expr><name>env_var</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

						<comment type="block">/*
						 * We could pass PGDATA just in an environment
						 * variable but we do -D too for clearer postmaster
						 * 'ps' display
						 */</comment>
						<expr_stmt><expr><name>pgdata_opt</name> <operator>=</operator> <call><name>psprintf</name><argument_list>(<argument><expr><literal type="string">"-D \"%s\" "</literal></expr></argument>, <argument><expr><name>pgdata_D</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<break>break;</break>
					</block_content>}</block>
				<case>case <expr><literal type="char">'e'</literal></expr>:</case>
					<expr_stmt><expr><name>event_source</name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><name>optarg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<break>break;</break>
				<case>case <expr><literal type="char">'l'</literal></expr>:</case>
					<expr_stmt><expr><name>log_file</name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><name>optarg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<break>break;</break>
				<case>case <expr><literal type="char">'m'</literal></expr>:</case>
					<expr_stmt><expr><call><name>set_mode</name><argument_list>(<argument><expr><name>optarg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<break>break;</break>
				<case>case <expr><literal type="char">'N'</literal></expr>:</case>
					<expr_stmt><expr><name>register_servicename</name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><name>optarg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<break>break;</break>
				<case>case <expr><literal type="char">'o'</literal></expr>:</case>
					<comment type="block">/* append option? */</comment>
					<if_stmt><if>if <condition>(<expr><operator>!</operator><name>post_opts</name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><name>post_opts</name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><name>optarg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
					<else>else
					<block>{<block_content>
						<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>old_post_opts</name> <init>= <expr><name>post_opts</name></expr></init></decl>;</decl_stmt>

						<expr_stmt><expr><name>post_opts</name> <operator>=</operator> <call><name>psprintf</name><argument_list>(<argument><expr><literal type="string">"%s %s"</literal></expr></argument>, <argument><expr><name>old_post_opts</name></expr></argument>, <argument><expr><name>optarg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>old_post_opts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block></else></if_stmt>
					<break>break;</break>
				<case>case <expr><literal type="char">'p'</literal></expr>:</case>
					<expr_stmt><expr><name>exec_path</name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><name>optarg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<break>break;</break>
				<case>case <expr><literal type="char">'P'</literal></expr>:</case>
					<expr_stmt><expr><name>register_password</name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><name>optarg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<break>break;</break>
				<case>case <expr><literal type="char">'s'</literal></expr>:</case>
					<expr_stmt><expr><name>silent_mode</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
					<break>break;</break>
				<case>case <expr><literal type="char">'S'</literal></expr>:</case>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WIN32</name></cpp:ifdef>
					<expr_stmt><expr><call><name>set_starttype</name><argument_list>(<argument><expr><name>optarg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
					<expr_stmt><expr><call><name>write_stderr</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: -S option not supported on this platform\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
								 <argument><expr><name>progname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
					<break>break;</break>
				<case>case <expr><literal type="char">'t'</literal></expr>:</case>
					<expr_stmt><expr><name>wait_seconds</name> <operator>=</operator> <call><name>atoi</name><argument_list>(<argument><expr><name>optarg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>wait_seconds_arg</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
					<break>break;</break>
				<case>case <expr><literal type="char">'U'</literal></expr>:</case>
					<if_stmt><if>if <condition>(<expr><call><name>strchr</name><argument_list>(<argument><expr><name>optarg</name></expr></argument>, <argument><expr><literal type="char">'\\'</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><name>register_username</name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><name>optarg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
					<else>else<block type="pseudo"><block_content>
						<comment type="block">/* Prepend .\ for local accounts */</comment>
						<expr_stmt><expr><name>register_username</name> <operator>=</operator> <call><name>psprintf</name><argument_list>(<argument><expr><literal type="string">".\\%s"</literal></expr></argument>, <argument><expr><name>optarg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
					<break>break;</break>
				<case>case <expr><literal type="char">'w'</literal></expr>:</case>
					<expr_stmt><expr><name>do_wait</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
					<break>break;</break>
				<case>case <expr><literal type="char">'W'</literal></expr>:</case>
					<expr_stmt><expr><name>do_wait</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
					<break>break;</break>
				<case>case <expr><literal type="char">'c'</literal></expr>:</case>
					<expr_stmt><expr><name>allow_core_files</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
					<break>break;</break>
				<comment type="block">/* POLAR: force promote */</comment>
				<case>case <expr><literal type="char">'f'</literal></expr>:</case>
					<expr_stmt><expr><name>polar_force_promote</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
					<break>break;</break>
				<comment type="block">/* POLAR end */</comment>
				<default>default:</default>
					<comment type="block">/* getopt_long already issued a suitable error message */</comment>
					<expr_stmt><expr><call><name>do_advice</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></switch>
		</block_content>}</block></while>

		<comment type="block">/* Process an action */</comment>
		<if_stmt><if>if <condition>(<expr><name>optind</name> <operator>&lt;</operator> <name>argc</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>ctl_command</name> <operator>!=</operator> <name>NO_COMMAND</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>write_stderr</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: too many command-line arguments (first is \"%s\")\n"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>progname</name></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><name>optind</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>do_advice</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><name>optind</name></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"init"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal>
				<operator>||</operator> <call><name>strcmp</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><name>optind</name></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"initdb"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>ctl_command</name> <operator>=</operator> <name>INIT_COMMAND</name></expr>;</expr_stmt></block_content></block></if>
			<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><name>optind</name></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"start"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>ctl_command</name> <operator>=</operator> <name>START_COMMAND</name></expr>;</expr_stmt></block_content></block></if>
			<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><name>optind</name></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"stop"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>ctl_command</name> <operator>=</operator> <name>STOP_COMMAND</name></expr>;</expr_stmt></block_content></block></if>
			<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><name>optind</name></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"restart"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>ctl_command</name> <operator>=</operator> <name>RESTART_COMMAND</name></expr>;</expr_stmt></block_content></block></if>
			<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><name>optind</name></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"reload"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>ctl_command</name> <operator>=</operator> <name>RELOAD_COMMAND</name></expr>;</expr_stmt></block_content></block></if>
			<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><name>optind</name></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"status"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>ctl_command</name> <operator>=</operator> <name>STATUS_COMMAND</name></expr>;</expr_stmt></block_content></block></if>
			<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><name>optind</name></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"promote"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>ctl_command</name> <operator>=</operator> <name>PROMOTE_COMMAND</name></expr>;</expr_stmt></block_content></block></if>
			<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><name>optind</name></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"kill"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name>argc</name> <operator>-</operator> <name>optind</name> <operator>&lt;</operator> <literal type="number">3</literal></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>write_stderr</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: missing arguments for kill mode\n"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>progname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>do_advice</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
				<expr_stmt><expr><name>ctl_command</name> <operator>=</operator> <name>KILL_COMMAND</name></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>set_sig</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><operator>++</operator><name>optind</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>killproc</name> <operator>=</operator> <call><name>atol</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><operator>++</operator><name>optind</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WIN32</name></cpp:ifdef>
			<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><name>optind</name></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"register"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>ctl_command</name> <operator>=</operator> <name>REGISTER_COMMAND</name></expr>;</expr_stmt></block_content></block></if>
			<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><name>optind</name></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"unregister"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>ctl_command</name> <operator>=</operator> <name>UNREGISTER_COMMAND</name></expr>;</expr_stmt></block_content></block></if>
			<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><name>optind</name></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"runservice"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>ctl_command</name> <operator>=</operator> <name>RUN_AS_SERVICE_COMMAND</name></expr>;</expr_stmt></block_content></block></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
			<else>else
			<block>{<block_content>
				<expr_stmt><expr><call><name>write_stderr</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: unrecognized operation mode \"%s\"\n"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>progname</name></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><name>optind</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>do_advice</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
			<expr_stmt><expr><name>optind</name><operator>++</operator></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></while>

	<if_stmt><if>if <condition>(<expr><name>ctl_command</name> <operator>==</operator> <name>NO_COMMAND</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>write_stderr</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: no operation specified\n"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>progname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>do_advice</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Note we put any -D switch into the env var above */</comment>
	<expr_stmt><expr><name>pg_config</name> <operator>=</operator> <call><name>getenv</name><argument_list>(<argument><expr><literal type="string">"PGDATA"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>pg_config</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>pg_config</name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><name>pg_config</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>canonicalize_path</name><argument_list>(<argument><expr><name>pg_config</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>pg_data</name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><name>pg_config</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* -D might point at config-only directory; if so find the real PGDATA */</comment>
	<expr_stmt><expr><call><name>adjust_data_dir</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Complain if -D needed and not provided */</comment>
	<if_stmt><if>if <condition>(<expr><name>pg_config</name> <operator>==</operator> <name>NULL</name> <operator>&amp;&amp;</operator>
		<name>ctl_command</name> <operator>!=</operator> <name>KILL_COMMAND</name> <operator>&amp;&amp;</operator> <name>ctl_command</name> <operator>!=</operator> <name>UNREGISTER_COMMAND</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>write_stderr</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: no database directory specified and environment variable PGDATA unset\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
					 <argument><expr><name>progname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>do_advice</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>ctl_command</name> <operator>==</operator> <name>RELOAD_COMMAND</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>sig</name> <operator>=</operator> <name>SIGHUP</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>do_wait</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>pg_data</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>postopts_file</name></expr></argument>, <argument><expr><name>MAXPGPATH</name></expr></argument>, <argument><expr><literal type="string">"%s/postmaster.opts"</literal></expr></argument>, <argument><expr><name>pg_data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>version_file</name></expr></argument>, <argument><expr><name>MAXPGPATH</name></expr></argument>, <argument><expr><literal type="string">"%s/PG_VERSION"</literal></expr></argument>, <argument><expr><name>pg_data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>pid_file</name></expr></argument>, <argument><expr><name>MAXPGPATH</name></expr></argument>, <argument><expr><literal type="string">"%s/postmaster.pid"</literal></expr></argument>, <argument><expr><name>pg_data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>backup_file</name></expr></argument>, <argument><expr><name>MAXPGPATH</name></expr></argument>, <argument><expr><literal type="string">"%s/backup_label"</literal></expr></argument>, <argument><expr><name>pg_data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Set mask based on PGDATA permissions,
		 *
		 * Don't error here if the data directory cannot be stat'd. This is
		 * handled differently based on the command and we don't want to
		 * interfere with that logic.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>GetDataDirectoryCreatePerm</name><argument_list>(<argument><expr><name>pg_data</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>umask</name><argument_list>(<argument><expr><name>pg_mode_mask</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<switch>switch <condition>(<expr><name>ctl_command</name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>INIT_COMMAND</name></expr>:</case>
			<expr_stmt><expr><call><name>do_init</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>STATUS_COMMAND</name></expr>:</case>
			<expr_stmt><expr><call><name>do_status</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>START_COMMAND</name></expr>:</case>
			<expr_stmt><expr><call><name>do_start</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>STOP_COMMAND</name></expr>:</case>
			<expr_stmt><expr><call><name>do_stop</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>RESTART_COMMAND</name></expr>:</case>
			<expr_stmt><expr><call><name>do_restart</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>RELOAD_COMMAND</name></expr>:</case>
			<expr_stmt><expr><call><name>do_reload</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>PROMOTE_COMMAND</name></expr>:</case>
			<expr_stmt><expr><call><name>do_promote</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>KILL_COMMAND</name></expr>:</case>
			<expr_stmt><expr><call><name>do_kill</name><argument_list>(<argument><expr><name>killproc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WIN32</name></cpp:ifdef>
		<case>case <expr><name>REGISTER_COMMAND</name></expr>:</case>
			<expr_stmt><expr><call><name>pgwin32_doRegister</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>UNREGISTER_COMMAND</name></expr>:</case>
			<expr_stmt><expr><call><name>pgwin32_doUnregister</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>RUN_AS_SERVICE_COMMAND</name></expr>:</case>
			<expr_stmt><expr><call><name>pgwin32_doRunAsService</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
		<default>default:</default>
			<break>break;</break>
	</block_content>}</block></switch>

	<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
</unit>
