<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/PolarDB-for-PostgreSQL/src/bin/scripts/vacuumdb.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * vacuumdb
 *
 * Portions Copyright (c) 1996-2018, PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, Regents of the University of California
 *
 * src/bin/scripts/vacuumdb.c
 *
 *-------------------------------------------------------------------------
 */</comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WIN32</name></cpp:ifdef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FD_SETSIZE</name></cpp:macro> <cpp:value>1024</cpp:value></cpp:define>			<comment type="block">/* must set before winsock2.h is included */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres_fe.h"</cpp:file></cpp:include>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_SYS_SELECT_H</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/select.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_class_d.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"common.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"fe_utils/simple_list.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"fe_utils/string_utils.h"</cpp:file></cpp:include>


<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ERRCODE_UNDEFINED_TABLE</name></cpp:macro>  <cpp:value>"42P01"</cpp:value></cpp:define>

<comment type="block">/* Parallel vacuuming stuff */</comment>
<typedef>typedef <type><struct>struct <name>ParallelSlot</name>
<block>{
	<decl_stmt><decl><type><name>PGconn</name>	   <modifier>*</modifier></type><name>connection</name></decl>;</decl_stmt>		<comment type="block">/* One connection */</comment>
	<decl_stmt><decl><type><name>bool</name></type>		<name>isFree</name></decl>;</decl_stmt>			<comment type="block">/* Is it known to be idle? */</comment>
}</block></struct></type> <name>ParallelSlot</name>;</typedef>

<comment type="block">/* vacuum options controlled by user flags */</comment>
<typedef>typedef <type><struct>struct <name>vacuumingOptions</name>
<block>{
	<decl_stmt><decl><type><name>bool</name></type>		<name>analyze_only</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>verbose</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>and_analyze</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>full</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>freeze</name></decl>;</decl_stmt>
}</block></struct></type> <name>vacuumingOptions</name>;</typedef>


<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>vacuum_one_database</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>dbname</name></decl></parameter>, <parameter><decl><type><name>vacuumingOptions</name> <modifier>*</modifier></type><name>vacopts</name></decl></parameter>,
					<parameter><decl><type><name>int</name></type> <name>stage</name></decl></parameter>,
					<parameter><decl><type><name>SimpleStringList</name> <modifier>*</modifier></type><name>tables</name></decl></parameter>,
					<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>host</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>port</name></decl></parameter>,
					<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>username</name></decl></parameter>, <parameter><decl><type><name><name>enum</name> <name>trivalue</name></name></type> <name>prompt_password</name></decl></parameter>,
					<parameter><decl><type><name>int</name></type> <name>concurrentCons</name></decl></parameter>,
					<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>progname</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>echo</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>quiet</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>vacuum_all_databases</name><parameter_list>(<parameter><decl><type><name>vacuumingOptions</name> <modifier>*</modifier></type><name>vacopts</name></decl></parameter>,
					 <parameter><decl><type><name>bool</name></type> <name>analyze_in_stages</name></decl></parameter>,
					 <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>maintenance_db</name></decl></parameter>,
					 <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>host</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>port</name></decl></parameter>,
					 <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>username</name></decl></parameter>, <parameter><decl><type><name><name>enum</name> <name>trivalue</name></name></type> <name>prompt_password</name></decl></parameter>,
					 <parameter><decl><type><name>int</name></type> <name>concurrentCons</name></decl></parameter>,
					 <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>progname</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>echo</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>quiet</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>prepare_vacuum_command</name><parameter_list>(<parameter><decl><type><name>PQExpBuffer</name></type> <name>sql</name></decl></parameter>, <parameter><decl><type><name>PGconn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>,
					   <parameter><decl><type><name>vacuumingOptions</name> <modifier>*</modifier></type><name>vacopts</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>table</name></decl></parameter>,
					   <parameter><decl><type><name>bool</name></type> <name>table_pre_qualified</name></decl></parameter>,
					   <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>progname</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>echo</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>run_vacuum_command</name><parameter_list>(<parameter><decl><type><name>PGconn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>sql</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>echo</name></decl></parameter>,
				   <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>table</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>progname</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>async</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>ParallelSlot</name> <modifier>*</modifier></type><name>GetIdleSlot</name><parameter_list>(<parameter><decl><type><name>ParallelSlot</name></type> <name><name>slots</name><index>[]</index></name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>numslots</name></decl></parameter>,
			<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>progname</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>ProcessQueryResult</name><parameter_list>(<parameter><decl><type><name>PGconn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>, <parameter><decl><type><name>PGresult</name> <modifier>*</modifier></type><name>result</name></decl></parameter>,
				   <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>progname</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>GetQueryResult</name><parameter_list>(<parameter><decl><type><name>PGconn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>progname</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>DisconnectDatabase</name><parameter_list>(<parameter><decl><type><name>ParallelSlot</name> <modifier>*</modifier></type><name>slot</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>int</name></type>	<name>select_loop</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>maxFd</name></decl></parameter>, <parameter><decl><type><name>fd_set</name> <modifier>*</modifier></type><name>workerset</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>aborting</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>init_slot</name><parameter_list>(<parameter><decl><type><name>ParallelSlot</name> <modifier>*</modifier></type><name>slot</name></decl></parameter>, <parameter><decl><type><name>PGconn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>help</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>progname</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/* For analyze-in-stages mode */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ANALYZE_NO_STAGE</name></cpp:macro>	<cpp:value>-1</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ANALYZE_NUM_STAGES</name></cpp:macro>	<cpp:value>3</cpp:value></cpp:define>


<function><type><name>int</name></type>
<name>main</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name><name>argv</name><index>[]</index></name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>static</specifier> <name><name>struct</name> <name>option</name></name></type> <name><name>long_options</name><index>[]</index></name> <init>= <expr><block>{
		<expr><block>{<expr><literal type="string">"host"</literal></expr>, <expr><name>required_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="char">'h'</literal></expr>}</block></expr>,
		<expr><block>{<expr><literal type="string">"port"</literal></expr>, <expr><name>required_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="char">'p'</literal></expr>}</block></expr>,
		<expr><block>{<expr><literal type="string">"username"</literal></expr>, <expr><name>required_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="char">'U'</literal></expr>}</block></expr>,
		<expr><block>{<expr><literal type="string">"no-password"</literal></expr>, <expr><name>no_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="char">'w'</literal></expr>}</block></expr>,
		<expr><block>{<expr><literal type="string">"password"</literal></expr>, <expr><name>no_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="char">'W'</literal></expr>}</block></expr>,
		<expr><block>{<expr><literal type="string">"echo"</literal></expr>, <expr><name>no_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="char">'e'</literal></expr>}</block></expr>,
		<expr><block>{<expr><literal type="string">"quiet"</literal></expr>, <expr><name>no_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="char">'q'</literal></expr>}</block></expr>,
		<expr><block>{<expr><literal type="string">"dbname"</literal></expr>, <expr><name>required_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="char">'d'</literal></expr>}</block></expr>,
		<expr><block>{<expr><literal type="string">"analyze"</literal></expr>, <expr><name>no_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="char">'z'</literal></expr>}</block></expr>,
		<expr><block>{<expr><literal type="string">"analyze-only"</literal></expr>, <expr><name>no_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="char">'Z'</literal></expr>}</block></expr>,
		<expr><block>{<expr><literal type="string">"freeze"</literal></expr>, <expr><name>no_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="char">'F'</literal></expr>}</block></expr>,
		<expr><block>{<expr><literal type="string">"all"</literal></expr>, <expr><name>no_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="char">'a'</literal></expr>}</block></expr>,
		<expr><block>{<expr><literal type="string">"table"</literal></expr>, <expr><name>required_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="char">'t'</literal></expr>}</block></expr>,
		<expr><block>{<expr><literal type="string">"full"</literal></expr>, <expr><name>no_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="char">'f'</literal></expr>}</block></expr>,
		<expr><block>{<expr><literal type="string">"verbose"</literal></expr>, <expr><name>no_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="char">'v'</literal></expr>}</block></expr>,
		<expr><block>{<expr><literal type="string">"jobs"</literal></expr>, <expr><name>required_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="char">'j'</literal></expr>}</block></expr>,
		<expr><block>{<expr><literal type="string">"maintenance-db"</literal></expr>, <expr><name>required_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="number">2</literal></expr>}</block></expr>,
		<expr><block>{<expr><literal type="string">"analyze-in-stages"</literal></expr>, <expr><name>no_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="number">3</literal></expr>}</block></expr>,
		<expr><block>{<expr><name>NULL</name></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>NULL</name></expr>, <expr><literal type="number">0</literal></expr>}</block></expr>
	}</block></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>progname</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>optindex</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>c</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>dbname</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>maintenance_db</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>host</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>port</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>username</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>enum</name> <name>trivalue</name></name></type> <name>prompt_password</name> <init>= <expr><name>TRI_DEFAULT</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>echo</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>quiet</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>vacuumingOptions</name></type> <name>vacopts</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>analyze_in_stages</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>alldb</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SimpleStringList</name></type> <name>tables</name> <init>= <expr><block>{<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>}</block></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>concurrentCons</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>tbl_count</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<comment type="block">/* initialize options to all false */</comment>
	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>vacopts</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>vacopts</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>progname</name> <operator>=</operator> <call><name>get_progname</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>set_pglocale_pgservice</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><call><name>PG_TEXTDOMAIN</name><argument_list>(<argument><expr><literal type="string">"pgscripts"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>handle_help_version_opts</name><argument_list>(<argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>, <argument><expr><literal type="string">"vacuumdb"</literal></expr></argument>, <argument><expr><name>help</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<while>while <condition>(<expr><operator>(</operator><name>c</name> <operator>=</operator> <call><name>getopt_long</name><argument_list>(<argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>, <argument><expr><literal type="string">"h:p:U:wWeqd:zZFat:fvj:"</literal></expr></argument>, <argument><expr><name>long_options</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>optindex</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<switch>switch <condition>(<expr><name>c</name></expr>)</condition>
		<block>{<block_content>
			<case>case <expr><literal type="char">'h'</literal></expr>:</case>
				<expr_stmt><expr><name>host</name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><name>optarg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><literal type="char">'p'</literal></expr>:</case>
				<expr_stmt><expr><name>port</name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><name>optarg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><literal type="char">'U'</literal></expr>:</case>
				<expr_stmt><expr><name>username</name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><name>optarg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><literal type="char">'w'</literal></expr>:</case>
				<expr_stmt><expr><name>prompt_password</name> <operator>=</operator> <name>TRI_NO</name></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><literal type="char">'W'</literal></expr>:</case>
				<expr_stmt><expr><name>prompt_password</name> <operator>=</operator> <name>TRI_YES</name></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><literal type="char">'e'</literal></expr>:</case>
				<expr_stmt><expr><name>echo</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><literal type="char">'q'</literal></expr>:</case>
				<expr_stmt><expr><name>quiet</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><literal type="char">'d'</literal></expr>:</case>
				<expr_stmt><expr><name>dbname</name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><name>optarg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><literal type="char">'z'</literal></expr>:</case>
				<expr_stmt><expr><name><name>vacopts</name><operator>.</operator><name>and_analyze</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><literal type="char">'Z'</literal></expr>:</case>
				<expr_stmt><expr><name><name>vacopts</name><operator>.</operator><name>analyze_only</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><literal type="char">'F'</literal></expr>:</case>
				<expr_stmt><expr><name><name>vacopts</name><operator>.</operator><name>freeze</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><literal type="char">'a'</literal></expr>:</case>
				<expr_stmt><expr><name>alldb</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><literal type="char">'t'</literal></expr>:</case>
				<block>{<block_content>
					<expr_stmt><expr><call><name>simple_string_list_append</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tables</name></expr></argument>, <argument><expr><name>optarg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>tbl_count</name><operator>++</operator></expr>;</expr_stmt>
					<break>break;</break>
				</block_content>}</block>
			<case>case <expr><literal type="char">'f'</literal></expr>:</case>
				<expr_stmt><expr><name><name>vacopts</name><operator>.</operator><name>full</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><literal type="char">'v'</literal></expr>:</case>
				<expr_stmt><expr><name><name>vacopts</name><operator>.</operator><name>verbose</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><literal type="char">'j'</literal></expr>:</case>
				<expr_stmt><expr><name>concurrentCons</name> <operator>=</operator> <call><name>atoi</name><argument_list>(<argument><expr><name>optarg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name>concurrentCons</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: number of parallel jobs must be at least 1\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
							<argument><expr><name>progname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
				<break>break;</break>
			<case>case <expr><literal type="number">2</literal></expr>:</case>
				<expr_stmt><expr><name>maintenance_db</name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><name>optarg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><literal type="number">3</literal></expr>:</case>
				<expr_stmt><expr><name>analyze_in_stages</name> <operator>=</operator> <name><name>vacopts</name><operator>.</operator><name>analyze_only</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<break>break;</break>
			<default>default:</default>
				<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Try \"%s --help\" for more information.\n"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>progname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></switch>
	</block_content>}</block></while>

	<comment type="block">/*
	 * Non-option argument specifies database name as long as it wasn't
	 * already specified with -d / --dbname
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>optind</name> <operator>&lt;</operator> <name>argc</name> <operator>&amp;&amp;</operator> <name>dbname</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>dbname</name> <operator>=</operator> <name><name>argv</name><index>[<expr><name>optind</name></expr>]</index></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>optind</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>optind</name> <operator>&lt;</operator> <name>argc</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: too many command-line arguments (first is \"%s\")\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
				<argument><expr><name>progname</name></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><name>optind</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Try \"%s --help\" for more information.\n"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>progname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>vacopts</name><operator>.</operator><name>analyze_only</name></name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>vacopts</name><operator>.</operator><name>full</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: cannot use the \"%s\" option when performing only analyze\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
					<argument><expr><name>progname</name></expr></argument>, <argument><expr><literal type="string">"full"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>vacopts</name><operator>.</operator><name>freeze</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: cannot use the \"%s\" option when performing only analyze\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
					<argument><expr><name>progname</name></expr></argument>, <argument><expr><literal type="string">"freeze"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<comment type="block">/* allow 'and_analyze' with 'analyze_only' */</comment>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>setup_cancel_handler</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Avoid opening extra connections. */</comment>
	<if_stmt><if>if <condition>(<expr><name>tbl_count</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>concurrentCons</name> <operator>&gt;</operator> <name>tbl_count</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>concurrentCons</name> <operator>=</operator> <name>tbl_count</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>alldb</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>dbname</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: cannot vacuum all databases and a specific one at the same time\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
					<argument><expr><name>progname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>tables</name><operator>.</operator><name>head</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: cannot vacuum specific table(s) in all databases\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
					<argument><expr><name>progname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>vacuum_all_databases</name><argument_list>(<argument><expr><operator>&amp;</operator><name>vacopts</name></expr></argument>,
							 <argument><expr><name>analyze_in_stages</name></expr></argument>,
							 <argument><expr><name>maintenance_db</name></expr></argument>,
							 <argument><expr><name>host</name></expr></argument>, <argument><expr><name>port</name></expr></argument>, <argument><expr><name>username</name></expr></argument>, <argument><expr><name>prompt_password</name></expr></argument>,
							 <argument><expr><name>concurrentCons</name></expr></argument>,
							 <argument><expr><name>progname</name></expr></argument>, <argument><expr><name>echo</name></expr></argument>, <argument><expr><name>quiet</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>dbname</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><call><name>getenv</name><argument_list>(<argument><expr><literal type="string">"PGDATABASE"</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>dbname</name> <operator>=</operator> <call><name>getenv</name><argument_list>(<argument><expr><literal type="string">"PGDATABASE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<if type="elseif">else if <condition>(<expr><call><name>getenv</name><argument_list>(<argument><expr><literal type="string">"PGUSER"</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>dbname</name> <operator>=</operator> <call><name>getenv</name><argument_list>(<argument><expr><literal type="string">"PGUSER"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name>dbname</name> <operator>=</operator> <call><name>get_user_name_or_exit</name><argument_list>(<argument><expr><name>progname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>analyze_in_stages</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>int</name></type>			<name>stage</name></decl>;</decl_stmt>

			<for>for <control>(<init><expr><name>stage</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>stage</name> <operator>&lt;</operator> <name>ANALYZE_NUM_STAGES</name></expr>;</condition> <incr><expr><name>stage</name><operator>++</operator></expr></incr>)</control>
			<block>{<block_content>
				<expr_stmt><expr><call><name>vacuum_one_database</name><argument_list>(<argument><expr><name>dbname</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>vacopts</name></expr></argument>,
									<argument><expr><name>stage</name></expr></argument>,
									<argument><expr><operator>&amp;</operator><name>tables</name></expr></argument>,
									<argument><expr><name>host</name></expr></argument>, <argument><expr><name>port</name></expr></argument>, <argument><expr><name>username</name></expr></argument>, <argument><expr><name>prompt_password</name></expr></argument>,
									<argument><expr><name>concurrentCons</name></expr></argument>,
									<argument><expr><name>progname</name></expr></argument>, <argument><expr><name>echo</name></expr></argument>, <argument><expr><name>quiet</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></for>
		</block_content>}</block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>vacuum_one_database</name><argument_list>(<argument><expr><name>dbname</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>vacopts</name></expr></argument>,
								<argument><expr><name>ANALYZE_NO_STAGE</name></expr></argument>,
								<argument><expr><operator>&amp;</operator><name>tables</name></expr></argument>,
								<argument><expr><name>host</name></expr></argument>, <argument><expr><name>port</name></expr></argument>, <argument><expr><name>username</name></expr></argument>, <argument><expr><name>prompt_password</name></expr></argument>,
								<argument><expr><name>concurrentCons</name></expr></argument>,
								<argument><expr><name>progname</name></expr></argument>, <argument><expr><name>echo</name></expr></argument>, <argument><expr><name>quiet</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * vacuum_one_database
 *
 * Process tables in the given database.  If the 'tables' list is empty,
 * process all tables in the database.
 *
 * Note that this function is only concerned with running exactly one stage
 * when in analyze-in-stages mode; caller must iterate on us if necessary.
 *
 * If concurrentCons is &gt; 1, multiple connections are used to vacuum tables
 * in parallel.  In this case and if the table list is empty, we first obtain
 * a list of tables from the database.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>vacuum_one_database</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>dbname</name></decl></parameter>, <parameter><decl><type><name>vacuumingOptions</name> <modifier>*</modifier></type><name>vacopts</name></decl></parameter>,
					<parameter><decl><type><name>int</name></type> <name>stage</name></decl></parameter>,
					<parameter><decl><type><name>SimpleStringList</name> <modifier>*</modifier></type><name>tables</name></decl></parameter>,
					<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>host</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>port</name></decl></parameter>,
					<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>username</name></decl></parameter>, <parameter><decl><type><name><name>enum</name> <name>trivalue</name></name></type> <name>prompt_password</name></decl></parameter>,
					<parameter><decl><type><name>int</name></type> <name>concurrentCons</name></decl></parameter>,
					<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>progname</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>echo</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>quiet</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PQExpBufferData</name></type> <name>sql</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PGconn</name>	   <modifier>*</modifier></type><name>conn</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SimpleStringListCell</name> <modifier>*</modifier></type><name>cell</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ParallelSlot</name> <modifier>*</modifier></type><name>slots</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SimpleStringList</name></type> <name>dbtables</name> <init>= <expr><block>{<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>}</block></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>failed</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>parallel</name> <init>= <expr><name>concurrentCons</name> <operator>&gt;</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name><name>stage_commands</name><index>[]</index></name> <init>= <expr><block>{
		<expr><literal type="string">"SET default_statistics_target=1; SET vacuum_cost_delay=0;"</literal></expr>,
		<expr><literal type="string">"SET default_statistics_target=10; RESET vacuum_cost_delay;"</literal></expr>,
		<expr><literal type="string">"RESET default_statistics_target;"</literal></expr>
	}</block></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name><name>stage_messages</name><index>[]</index></name> <init>= <expr><block>{
		<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Generating minimal optimizer statistics (1 target)"</literal></expr></argument>)</argument_list></call></expr>,
		<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Generating medium optimizer statistics (10 targets)"</literal></expr></argument>)</argument_list></call></expr>,
		<macro><name>gettext_noop</name><argument_list>(<argument><literal type="string">"Generating default (full) optimizer statistics"</literal></argument>)</argument_list></macro>
	}</block></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>stage</name> <operator>==</operator> <name>ANALYZE_NO_STAGE</name> <operator>||</operator>
		   <operator>(</operator><name>stage</name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>stage</name> <operator>&lt;</operator> <name>ANALYZE_NUM_STAGES</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>conn</name> <operator>=</operator> <call><name>connectDatabase</name><argument_list>(<argument><expr><name>dbname</name></expr></argument>, <argument><expr><name>host</name></expr></argument>, <argument><expr><name>port</name></expr></argument>, <argument><expr><name>username</name></expr></argument>, <argument><expr><name>prompt_password</name></expr></argument>,
						   <argument><expr><name>progname</name></expr></argument>, <argument><expr><name>echo</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>quiet</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>stage</name> <operator>!=</operator> <name>ANALYZE_NO_STAGE</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: processing database \"%s\": %s\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
				   <argument><expr><name>progname</name></expr></argument>, <argument><expr><call><name>PQdb</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><name><name>stage_messages</name><index>[<expr><name>stage</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: vacuuming database \"%s\"\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
				   <argument><expr><name>progname</name></expr></argument>, <argument><expr><call><name>PQdb</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
		<expr_stmt><expr><call><name>fflush</name><argument_list>(<argument><expr><name>stdout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>initPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If a table list is not provided and we're using multiple connections,
	 * prepare the list of tables by querying the catalogs.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>parallel</name> <operator>&amp;&amp;</operator> <operator>(</operator><operator>!</operator><name>tables</name> <operator>||</operator> <operator>!</operator><name><name>tables</name><operator>-&gt;</operator><name>head</name></name><operator>)</operator></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>PQExpBufferData</name></type> <name>buf</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>ntups</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>initPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>executeQuery</name><argument_list>(<argument><expr><name>conn</name></expr></argument>,
						   <argument><expr><literal type="string">"SELECT c.relname, ns.nspname"</literal>
						   <literal type="string">" FROM pg_class c, pg_namespace ns\n"</literal>
						   <literal type="string">" WHERE relkind IN ("</literal>
						   <call><name>CppAsString2</name><argument_list>(<argument><expr><name>RELKIND_RELATION</name></expr></argument>)</argument_list></call> <literal type="string">", "</literal>
						   <call><name>CppAsString2</name><argument_list>(<argument><expr><name>RELKIND_MATVIEW</name></expr></argument>)</argument_list></call> <literal type="string">")"</literal>
						   <literal type="string">" AND c.relnamespace = ns.oid\n"</literal>
						   <literal type="string">" ORDER BY c.relpages DESC;"</literal></expr></argument>,
						   <argument><expr><name>progname</name></expr></argument>, <argument><expr><name>echo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>ntups</name> <operator>=</operator> <call><name>PQntuples</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>ntups</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
								 <argument><expr><call><name>fmtQualifiedId</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>,
												<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>simple_string_list_append</name><argument_list>(<argument><expr><operator>&amp;</operator><name>dbtables</name></expr></argument>, <argument><expr><name><name>buf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>resetPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></for>

		<expr_stmt><expr><call><name>termPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>tables</name> <operator>=</operator> <operator>&amp;</operator><name>dbtables</name></expr>;</expr_stmt>

		<comment type="block">/*
		 * If there are more connections than vacuumable relations, we don't
		 * need to use them all.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>concurrentCons</name> <operator>&gt;</operator> <name>ntups</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>concurrentCons</name> <operator>=</operator> <name>ntups</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name>concurrentCons</name> <operator>&lt;=</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>parallel</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Setup the database connections. We reuse the connection we already have
	 * for the first slot.  If not in parallel mode, the first slot in the
	 * array contains the connection.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>concurrentCons</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>concurrentCons</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>slots</name> <operator>=</operator> <operator>(</operator><name>ParallelSlot</name> <operator>*</operator><operator>)</operator> <call><name>pg_malloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ParallelSlot</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>concurrentCons</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>init_slot</name><argument_list>(<argument><expr><name>slots</name></expr></argument>, <argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>parallel</name></expr>)</condition>
	<block>{<block_content>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>concurrentCons</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<expr_stmt><expr><name>conn</name> <operator>=</operator> <call><name>connectDatabase</name><argument_list>(<argument><expr><name>dbname</name></expr></argument>, <argument><expr><name>host</name></expr></argument>, <argument><expr><name>port</name></expr></argument>, <argument><expr><name>username</name></expr></argument>, <argument><expr><name>prompt_password</name></expr></argument>,
								   <argument><expr><name>progname</name></expr></argument>, <argument><expr><name>echo</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * Fail and exit immediately if trying to use a socket in an
			 * unsupported range.  POSIX requires open(2) to use the lowest
			 * unused file descriptor and the hint given relies on that.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>PQsocket</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <name>FD_SETSIZE</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>,
						<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: too many jobs for this platform -- try %d\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
						<argument><expr><name>progname</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<expr_stmt><expr><call><name>init_slot</name><argument_list>(<argument><expr><name>slots</name> <operator>+</operator> <name>i</name></expr></argument>, <argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></for>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Prepare all the connections to run the appropriate analyze stage, if
	 * caller requested that mode.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>stage</name> <operator>!=</operator> <name>ANALYZE_NO_STAGE</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>j</name></decl>;</decl_stmt>

		<comment type="block">/* We already emitted the message above */</comment>

		<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>concurrentCons</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>executeCommand</name><argument_list>(<argument><expr><operator>(</operator><name>slots</name> <operator>+</operator> <name>j</name><operator>)</operator><operator>-&gt;</operator><name>connection</name></expr></argument>,
						   <argument><expr><name><name>stage_commands</name><index>[<expr><name>stage</name></expr>]</index></name></expr></argument>, <argument><expr><name>progname</name></expr></argument>, <argument><expr><name>echo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>cell</name> <operator>=</operator> <ternary><condition><expr><name>tables</name></expr> ?</condition><then> <expr><name><name>tables</name><operator>-&gt;</operator><name>head</name></name></expr> </then><else>: <expr><name>NULL</name></expr></else></ternary></expr>;</expr_stmt>
	<do>do
	<block>{<block_content>
		<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>tabname</name> <init>= <expr><ternary><condition><expr><name>cell</name></expr> ?</condition><then> <expr><name><name>cell</name><operator>-&gt;</operator><name>val</name></name></expr> </then><else>: <expr><name>NULL</name></expr></else></ternary></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ParallelSlot</name> <modifier>*</modifier></type><name>free_slot</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>CancelRequested</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>failed</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<goto>goto <name>finish</name>;</goto>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * Get the connection slot to use.  If in parallel mode, here we wait
		 * for one connection to become available if none already is.  In
		 * non-parallel mode we simply use the only slot we have, which we
		 * know to be free.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>parallel</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * Get a free slot, waiting until one becomes free if none
			 * currently is.
			 */</comment>
			<expr_stmt><expr><name>free_slot</name> <operator>=</operator> <call><name>GetIdleSlot</name><argument_list>(<argument><expr><name>slots</name></expr></argument>, <argument><expr><name>concurrentCons</name></expr></argument>, <argument><expr><name>progname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>free_slot</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>failed</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<goto>goto <name>finish</name>;</goto>
			</block_content>}</block></if></if_stmt>

			<expr_stmt><expr><name><name>free_slot</name><operator>-&gt;</operator><name>isFree</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>free_slot</name> <operator>=</operator> <name>slots</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<comment type="block">/*
		 * Prepare the vacuum command.  Note that in some cases this requires
		 * query execution, so be sure to use the free connection.
		 */</comment>
		<expr_stmt><expr><call><name>prepare_vacuum_command</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sql</name></expr></argument>, <argument><expr><name><name>free_slot</name><operator>-&gt;</operator><name>connection</name></name></expr></argument>, <argument><expr><name>vacopts</name></expr></argument>, <argument><expr><name>tabname</name></expr></argument>,
							   <argument><expr><name>tables</name> <operator>==</operator> <operator>&amp;</operator><name>dbtables</name></expr></argument>, <argument><expr><name>progname</name></expr></argument>, <argument><expr><name>echo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Execute the vacuum.  If not in parallel mode, this terminates the
		 * program in case of an error.  (The parallel case handles query
		 * errors in ProcessQueryResult through GetIdleSlot.)
		 */</comment>
		<expr_stmt><expr><call><name>run_vacuum_command</name><argument_list>(<argument><expr><name><name>free_slot</name><operator>-&gt;</operator><name>connection</name></name></expr></argument>, <argument><expr><name><name>sql</name><operator>.</operator><name>data</name></name></expr></argument>,
						   <argument><expr><name>echo</name></expr></argument>, <argument><expr><name>tabname</name></expr></argument>, <argument><expr><name>progname</name></expr></argument>, <argument><expr><name>parallel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>cell</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>cell</name> <operator>=</operator> <name><name>cell</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block> while <condition>(<expr><name>cell</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>;</do>

	<if_stmt><if>if <condition>(<expr><name>parallel</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>j</name></decl>;</decl_stmt>

		<comment type="block">/* wait for all connections to finish */</comment>
		<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>concurrentCons</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>GetQueryResult</name><argument_list>(<argument><expr><operator>(</operator><name>slots</name> <operator>+</operator> <name>j</name><operator>)</operator><operator>-&gt;</operator><name>connection</name></expr></argument>, <argument><expr><name>progname</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>failed</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<goto>goto <name>finish</name>;</goto>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></for>
	</block_content>}</block></if></if_stmt>

<label><name>finish</name>:</label>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>concurrentCons</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>DisconnectDatabase</name><argument_list>(<argument><expr><name>slots</name> <operator>+</operator> <name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>slots</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>termPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>failed</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Vacuum/analyze all connectable databases.
 *
 * In analyze-in-stages mode, we process all databases in one stage before
 * moving on to the next stage.  That ensure minimal stats are available
 * quickly everywhere before generating more detailed ones.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>vacuum_all_databases</name><parameter_list>(<parameter><decl><type><name>vacuumingOptions</name> <modifier>*</modifier></type><name>vacopts</name></decl></parameter>,
					 <parameter><decl><type><name>bool</name></type> <name>analyze_in_stages</name></decl></parameter>,
					 <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>maintenance_db</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>host</name></decl></parameter>,
					 <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>port</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>username</name></decl></parameter>,
					 <parameter><decl><type><name><name>enum</name> <name>trivalue</name></name></type> <name>prompt_password</name></decl></parameter>,
					 <parameter><decl><type><name>int</name></type> <name>concurrentCons</name></decl></parameter>,
					 <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>progname</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>echo</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>quiet</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PGconn</name>	   <modifier>*</modifier></type><name>conn</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PQExpBufferData</name></type> <name>connstr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>stage</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>conn</name> <operator>=</operator> <call><name>connectMaintenanceDatabase</name><argument_list>(<argument><expr><name>maintenance_db</name></expr></argument>, <argument><expr><name>host</name></expr></argument>, <argument><expr><name>port</name></expr></argument>, <argument><expr><name>username</name></expr></argument>,
									  <argument><expr><name>prompt_password</name></expr></argument>, <argument><expr><name>progname</name></expr></argument>, <argument><expr><name>echo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>executeQuery</name><argument_list>(<argument><expr><name>conn</name></expr></argument>,
						  <argument><expr><literal type="string">"SELECT datname FROM pg_database WHERE datallowconn ORDER BY 1;"</literal></expr></argument>,
						  <argument><expr><name>progname</name></expr></argument>, <argument><expr><name>echo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PQfinish</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>initPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>connstr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>analyze_in_stages</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * When analyzing all databases in stages, we analyze them all in the
		 * fastest stage first, so that initial statistics become available
		 * for all of them as soon as possible.
		 *
		 * This means we establish several times as many connections, but
		 * that's a secondary consideration.
		 */</comment>
		<for>for <control>(<init><expr><name>stage</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>stage</name> <operator>&lt;</operator> <name>ANALYZE_NUM_STAGES</name></expr>;</condition> <incr><expr><name>stage</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <call><name>PQntuples</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
			<block>{<block_content>
				<expr_stmt><expr><call><name>resetPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>connstr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>connstr</name></expr></argument>, <argument><expr><literal type="string">"dbname="</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>appendConnStrVal</name><argument_list>(<argument><expr><operator>&amp;</operator><name>connstr</name></expr></argument>, <argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><call><name>vacuum_one_database</name><argument_list>(<argument><expr><name><name>connstr</name><operator>.</operator><name>data</name></name></expr></argument>, <argument><expr><name>vacopts</name></expr></argument>,
									<argument><expr><name>stage</name></expr></argument>,
									<argument><expr><name>NULL</name></expr></argument>,
									<argument><expr><name>host</name></expr></argument>, <argument><expr><name>port</name></expr></argument>, <argument><expr><name>username</name></expr></argument>, <argument><expr><name>prompt_password</name></expr></argument>,
									<argument><expr><name>concurrentCons</name></expr></argument>,
									<argument><expr><name>progname</name></expr></argument>, <argument><expr><name>echo</name></expr></argument>, <argument><expr><name>quiet</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></for>
		</block_content>}</block></for>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <call><name>PQntuples</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<expr_stmt><expr><call><name>resetPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>connstr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>connstr</name></expr></argument>, <argument><expr><literal type="string">"dbname="</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>appendConnStrVal</name><argument_list>(<argument><expr><operator>&amp;</operator><name>connstr</name></expr></argument>, <argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>vacuum_one_database</name><argument_list>(<argument><expr><name><name>connstr</name><operator>.</operator><name>data</name></name></expr></argument>, <argument><expr><name>vacopts</name></expr></argument>,
								<argument><expr><name>ANALYZE_NO_STAGE</name></expr></argument>,
								<argument><expr><name>NULL</name></expr></argument>,
								<argument><expr><name>host</name></expr></argument>, <argument><expr><name>port</name></expr></argument>, <argument><expr><name>username</name></expr></argument>, <argument><expr><name>prompt_password</name></expr></argument>,
								<argument><expr><name>concurrentCons</name></expr></argument>,
								<argument><expr><name>progname</name></expr></argument>, <argument><expr><name>echo</name></expr></argument>, <argument><expr><name>quiet</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></for>
	</block_content>}</block></else></if_stmt>
	<expr_stmt><expr><call><name>termPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>connstr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Construct a vacuum/analyze command to run based on the given options, in the
 * given string buffer, which may contain previous garbage.
 *
 * An optional table name can be passed; this must be already be properly
 * quoted.  The command is semicolon-terminated.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>prepare_vacuum_command</name><parameter_list>(<parameter><decl><type><name>PQExpBuffer</name></type> <name>sql</name></decl></parameter>, <parameter><decl><type><name>PGconn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>,
					   <parameter><decl><type><name>vacuumingOptions</name> <modifier>*</modifier></type><name>vacopts</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>table</name></decl></parameter>,
					   <parameter><decl><type><name>bool</name></type> <name>table_pre_qualified</name></decl></parameter>,
					   <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>progname</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>echo</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>resetPQExpBuffer</name><argument_list>(<argument><expr><name>sql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>vacopts</name><operator>-&gt;</operator><name>analyze_only</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>sql</name></expr></argument>, <argument><expr><literal type="string">"ANALYZE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>vacopts</name><operator>-&gt;</operator><name>verbose</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>sql</name></expr></argument>, <argument><expr><literal type="string">" VERBOSE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>sql</name></expr></argument>, <argument><expr><literal type="string">"VACUUM"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>PQserverVersion</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <literal type="number">90000</literal></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>paren</name> <init>= <expr><literal type="string">" ("</literal></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>comma</name> <init>= <expr><literal type="string">", "</literal></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>sep</name> <init>= <expr><name>paren</name></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>vacopts</name><operator>-&gt;</operator><name>full</name></name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>sql</name></expr></argument>, <argument><expr><literal type="string">"%sFULL"</literal></expr></argument>, <argument><expr><name>sep</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>sep</name> <operator>=</operator> <name>comma</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>vacopts</name><operator>-&gt;</operator><name>freeze</name></name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>sql</name></expr></argument>, <argument><expr><literal type="string">"%sFREEZE"</literal></expr></argument>, <argument><expr><name>sep</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>sep</name> <operator>=</operator> <name>comma</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>vacopts</name><operator>-&gt;</operator><name>verbose</name></name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>sql</name></expr></argument>, <argument><expr><literal type="string">"%sVERBOSE"</literal></expr></argument>, <argument><expr><name>sep</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>sep</name> <operator>=</operator> <name>comma</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>vacopts</name><operator>-&gt;</operator><name>and_analyze</name></name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>sql</name></expr></argument>, <argument><expr><literal type="string">"%sANALYZE"</literal></expr></argument>, <argument><expr><name>sep</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>sep</name> <operator>=</operator> <name>comma</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><name>sep</name> <operator>!=</operator> <name>paren</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>appendPQExpBufferChar</name><argument_list>(<argument><expr><name>sql</name></expr></argument>, <argument><expr><literal type="char">')'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name><name>vacopts</name><operator>-&gt;</operator><name>full</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>sql</name></expr></argument>, <argument><expr><literal type="string">" FULL"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>vacopts</name><operator>-&gt;</operator><name>freeze</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>sql</name></expr></argument>, <argument><expr><literal type="string">" FREEZE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>vacopts</name><operator>-&gt;</operator><name>verbose</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>sql</name></expr></argument>, <argument><expr><literal type="string">" VERBOSE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>vacopts</name><operator>-&gt;</operator><name>and_analyze</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>sql</name></expr></argument>, <argument><expr><literal type="string">" ANALYZE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>table</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendPQExpBufferChar</name><argument_list>(<argument><expr><name>sql</name></expr></argument>, <argument><expr><literal type="char">' '</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>table_pre_qualified</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>sql</name></expr></argument>, <argument><expr><name>table</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendQualifiedRelation</name><argument_list>(<argument><expr><name>sql</name></expr></argument>, <argument><expr><name>table</name></expr></argument>, <argument><expr><name>conn</name></expr></argument>, <argument><expr><name>progname</name></expr></argument>, <argument><expr><name>echo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>appendPQExpBufferChar</name><argument_list>(<argument><expr><name>sql</name></expr></argument>, <argument><expr><literal type="char">';'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Send a vacuum/analyze command to the server.  In async mode, return after
 * sending the command; else, wait for it to finish.
 *
 * Any errors during command execution are reported to stderr.  If async is
 * false, this function exits the program after reporting the error.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>run_vacuum_command</name><parameter_list>(<parameter><decl><type><name>PGconn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>sql</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>echo</name></decl></parameter>,
				   <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>table</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>progname</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>async</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type>		<name>status</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>async</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>echo</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"%s\n"</literal></expr></argument>, <argument><expr><name>sql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>status</name> <operator>=</operator> <call><name>PQsendQuery</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>sql</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>status</name> <operator>=</operator> <call><name>executeMaintenanceCommand</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>sql</name></expr></argument>, <argument><expr><name>echo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>status</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>table</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>,
					<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: vacuuming of table \"%s\" in database \"%s\" failed: %s"</literal></expr></argument>)</argument_list></call></expr></argument>,
					<argument><expr><name>progname</name></expr></argument>, <argument><expr><name>table</name></expr></argument>, <argument><expr><call><name>PQdb</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>PQerrorMessage</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: vacuuming of database \"%s\" failed: %s"</literal></expr></argument>)</argument_list></call></expr></argument>,
					<argument><expr><name>progname</name></expr></argument>, <argument><expr><call><name>PQdb</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>PQerrorMessage</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>async</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>PQfinish</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * GetIdleSlot
 *		Return a connection slot that is ready to execute a command.
 *
 * We return the first slot we find that is marked isFree, if one is;
 * otherwise, we loop on select() until one socket becomes available.  When
 * this happens, we read the whole set and mark as free all sockets that become
 * available.
 *
 * If an error occurs, NULL is returned.
 */</comment>
<function><type><specifier>static</specifier> <name>ParallelSlot</name> <modifier>*</modifier></type>
<name>GetIdleSlot</name><parameter_list>(<parameter><decl><type><name>ParallelSlot</name></type> <name><name>slots</name><index>[]</index></name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>numslots</name></decl></parameter>,
			<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>progname</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>firstFree</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

	<comment type="block">/* Any connection already known free? */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>numslots</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>slots</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>isFree</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>slots</name> <operator>+</operator> <name>i</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></for>

	<comment type="block">/*
	 * No free slot found, so wait until one of the connections has finished
	 * its task and return the available slot.
	 */</comment>
	<while>while <condition>(<expr><name>firstFree</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>fd_set</name></type>		<name>slotset</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>maxFd</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>aborting</name></decl>;</decl_stmt>

		<comment type="block">/* We must reconstruct the fd_set for each call to select_loop */</comment>
		<expr_stmt><expr><call><name>FD_ZERO</name><argument_list>(<argument><expr><operator>&amp;</operator><name>slotset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>numslots</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>int</name></type>			<name>sock</name> <init>= <expr><call><name>PQsocket</name><argument_list>(<argument><expr><name><name>slots</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>connection</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<comment type="block">/*
			 * We don't really expect any connections to lose their sockets
			 * after startup, but just in case, cope by ignoring them.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name>sock</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>

			<expr_stmt><expr><call><name>FD_SET</name><argument_list>(<argument><expr><name>sock</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>slotset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>sock</name> <operator>&gt;</operator> <name>maxFd</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>maxFd</name> <operator>=</operator> <name>sock</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></for>

		<expr_stmt><expr><call><name>SetCancelConn</name><argument_list>(<argument><expr><name><name>slots</name><operator>-&gt;</operator><name>connection</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>i</name> <operator>=</operator> <call><name>select_loop</name><argument_list>(<argument><expr><name>maxFd</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>slotset</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>aborting</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ResetCancelConn</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>aborting</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * We set the cancel-receiving connection to the one in the zeroth
			 * slot above, so fetch the error from there.
			 */</comment>
			<expr_stmt><expr><call><name>GetQueryResult</name><argument_list>(<argument><expr><name><name>slots</name><operator>-&gt;</operator><name>connection</name></name></expr></argument>, <argument><expr><name>progname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>NULL</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>i</name> <operator>!=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>numslots</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>int</name></type>			<name>sock</name> <init>= <expr><call><name>PQsocket</name><argument_list>(<argument><expr><name><name>slots</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>connection</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name>sock</name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <call><name>FD_ISSET</name><argument_list>(<argument><expr><name>sock</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>slotset</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* select() says input is available, so consume it */</comment>
				<expr_stmt><expr><call><name>PQconsumeInput</name><argument_list>(<argument><expr><name><name>slots</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>connection</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/* Collect result(s) as long as any are available */</comment>
			<while>while <condition>(<expr><operator>!</operator><call><name>PQisBusy</name><argument_list>(<argument><expr><name><name>slots</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>connection</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier></type><name>result</name> <init>= <expr><call><name>PQgetResult</name><argument_list>(<argument><expr><name><name>slots</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>connection</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><name>result</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/* Check and discard the command result */</comment>
					<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ProcessQueryResult</name><argument_list>(<argument><expr><name><name>slots</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>connection</name></expr></argument>, <argument><expr><name>result</name></expr></argument>,
											<argument><expr><name>progname</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
						<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
				</block_content>}</block></if>
				<else>else
				<block>{<block_content>
					<comment type="block">/* This connection has become idle */</comment>
					<expr_stmt><expr><name><name>slots</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>isFree</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
					<if_stmt><if>if <condition>(<expr><name>firstFree</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><name>firstFree</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
					<break>break;</break>
				</block_content>}</block></else></if_stmt>
			</block_content>}</block></while>
		</block_content>}</block></for>
	</block_content>}</block></while>

	<return>return <expr><name>slots</name> <operator>+</operator> <name>firstFree</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * ProcessQueryResult
 *
 * Process (and delete) a query result.  Returns true if there's no error,
 * false otherwise -- but errors about trying to vacuum a missing relation
 * are reported and subsequently ignored.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>ProcessQueryResult</name><parameter_list>(<parameter><decl><type><name>PGconn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>, <parameter><decl><type><name>PGresult</name> <modifier>*</modifier></type><name>result</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>progname</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * If it's an error, report it.  Errors about a missing table are harmless
	 * so we continue processing; but die for other errors.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>PQresultStatus</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>PGRES_COMMAND_OK</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>sqlState</name> <init>= <expr><call><name>PQresultErrorField</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>PG_DIAG_SQLSTATE</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: vacuuming of database \"%s\" failed: %s"</literal></expr></argument>)</argument_list></call></expr></argument>,
				<argument><expr><name>progname</name></expr></argument>, <argument><expr><call><name>PQdb</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>PQerrorMessage</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>sqlState</name> <operator>&amp;&amp;</operator> <call><name>strcmp</name><argument_list>(<argument><expr><name>sqlState</name></expr></argument>, <argument><expr><name>ERRCODE_UNDEFINED_TABLE</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>false</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * GetQueryResult
 *
 * Pump the conn till it's dry of results; return false if any are errors.
 * Note that this will block if the conn is busy.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>GetQueryResult</name><parameter_list>(<parameter><decl><type><name>PGconn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>progname</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type>		<name>ok</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>SetCancelConn</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<while>while <condition>(<expr><operator>(</operator><name>result</name> <operator>=</operator> <call><name>PQgetResult</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ProcessQueryResult</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>result</name></expr></argument>, <argument><expr><name>progname</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>ok</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></while>
	<expr_stmt><expr><call><name>ResetCancelConn</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>ok</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * DisconnectDatabase
 *		Disconnect the connection associated with the given slot
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>DisconnectDatabase</name><parameter_list>(<parameter><decl><type><name>ParallelSlot</name> <modifier>*</modifier></type><name>slot</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>errbuf</name><index>[<expr><literal type="number">256</literal></expr>]</index></name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>slot</name><operator>-&gt;</operator><name>connection</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>PQtransactionStatus</name><argument_list>(<argument><expr><name><name>slot</name><operator>-&gt;</operator><name>connection</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <name>PQTRANS_ACTIVE</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>PGcancel</name>   <modifier>*</modifier></type><name>cancel</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><operator>(</operator><name>cancel</name> <operator>=</operator> <call><name>PQgetCancel</name><argument_list>(<argument><expr><name><name>slot</name><operator>-&gt;</operator><name>connection</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>PQcancel</name><argument_list>(<argument><expr><name>cancel</name></expr></argument>, <argument><expr><name>errbuf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>errbuf</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>PQfreeCancel</name><argument_list>(<argument><expr><name>cancel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>PQfinish</name><argument_list>(<argument><expr><name><name>slot</name><operator>-&gt;</operator><name>connection</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>slot</name><operator>-&gt;</operator><name>connection</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Loop on select() until a descriptor from the given set becomes readable.
 *
 * If we get a cancel request while we're waiting, we forego all further
 * processing and set the *aborting flag to true.  The return value must be
 * ignored in this case.  Otherwise, *aborting is set to false.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>select_loop</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>maxFd</name></decl></parameter>, <parameter><decl><type><name>fd_set</name> <modifier>*</modifier></type><name>workerset</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>aborting</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>fd_set</name></type>		<name>saveSet</name> <init>= <expr><operator>*</operator><name>workerset</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>CancelRequested</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><operator>*</operator><name>aborting</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><operator>*</operator><name>aborting</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
	<block>{<block_content>
		<comment type="block">/*
		 * On Windows, we need to check once in a while for cancel requests;
		 * on other platforms we rely on select() returning when interrupted.
		 */</comment>
		<decl_stmt><decl><type><name><name>struct</name> <name>timeval</name></name> <modifier>*</modifier></type><name>tvp</name></decl>;</decl_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WIN32</name></cpp:ifdef>
		<decl_stmt><decl><type><name><name>struct</name> <name>timeval</name></name></type> <name>tv</name> <init>= <expr><block>{<expr><literal type="number">0</literal></expr>, <expr><literal type="number">1000000</literal></expr>}</block></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>tvp</name> <operator>=</operator> <operator>&amp;</operator><name>tv</name></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
		<expr_stmt><expr><name>tvp</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

		<expr_stmt><expr><operator>*</operator><name>workerset</name> <operator>=</operator> <name>saveSet</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>i</name> <operator>=</operator> <call><name>select</name><argument_list>(<argument><expr><name>maxFd</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>workerset</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>tvp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WIN32</name></cpp:ifdef>
		<if_stmt><if>if <condition>(<expr><name>i</name> <operator>==</operator> <name>SOCKET_ERROR</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>i</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>WSAGetLastError</name><argument_list>()</argument_list></call> <operator>==</operator> <name>WSAEINTR</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>errno</name> <operator>=</operator> <name>EINTR</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

		<if_stmt><if>if <condition>(<expr><name>i</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>errno</name> <operator>==</operator> <name>EINTR</name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>			<comment type="block">/* ignore this */</comment>
		<if_stmt><if>if <condition>(<expr><name>i</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator> <name>CancelRequested</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><operator>*</operator><name>aborting</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>	<comment type="block">/* but not this */</comment>
		<if_stmt><if>if <condition>(<expr><name>i</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>			<comment type="block">/* timeout (Win32 only) */</comment>
		<break>break;</break>
	</block_content>}</block></for>

	<return>return <expr><name>i</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>init_slot</name><parameter_list>(<parameter><decl><type><name>ParallelSlot</name> <modifier>*</modifier></type><name>slot</name></decl></parameter>, <parameter><decl><type><name>PGconn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><name><name>slot</name><operator>-&gt;</operator><name>connection</name></name> <operator>=</operator> <name>conn</name></expr>;</expr_stmt>
	<comment type="block">/* Initially assume connection is idle */</comment>
	<expr_stmt><expr><name><name>slot</name><operator>-&gt;</operator><name>isFree</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>help</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>progname</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s cleans and analyzes a PostgreSQL database.\n\n"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>progname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Usage:\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"  %s [OPTION]... [DBNAME]\n"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>progname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"\nOptions:\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"  -a, --all                       vacuum all databases\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"  -d, --dbname=DBNAME             database to vacuum\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"  -e, --echo                      show the commands being sent to the server\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"  -f, --full                      do full vacuuming\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"  -F, --freeze                    freeze row transaction information\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"  -j, --jobs=NUM                  use this many concurrent connections to vacuum\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"  -q, --quiet                     don't write any messages\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"  -t, --table='TABLE[(COLUMNS)]'  vacuum specific table(s) only\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"  -v, --verbose                   write a lot of output\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"  -V, --version                   output version information, then exit\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"  -z, --analyze                   update optimizer statistics\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"  -Z, --analyze-only              only update optimizer statistics; no vacuum\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"      --analyze-in-stages         only update optimizer statistics, in multiple\n"</literal>
			 <literal type="string">"                                  stages for faster results; no vacuum\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"  -?, --help                      show this help, then exit\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"\nConnection options:\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"  -h, --host=HOSTNAME       database server host or socket directory\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"  -p, --port=PORT           database server port\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"  -U, --username=USERNAME   user name to connect as\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"  -w, --no-password         never prompt for password\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"  -W, --password            force password prompt\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"  --maintenance-db=DBNAME   alternate maintenance database\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"\nRead the description of the SQL command VACUUM for details.\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"\nReport bugs to &lt;pgsql-bugs@postgresql.org&gt;.\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
</unit>
