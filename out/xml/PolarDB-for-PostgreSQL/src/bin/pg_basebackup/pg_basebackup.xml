<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/PolarDB-for-PostgreSQL/src/bin/pg_basebackup/pg_basebackup.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * pg_basebackup.c - receive a base backup using streaming replication protocol
 *
 * Author: Magnus Hagander &lt;magnus@hagander.net&gt;
 *
 * Portions Copyright (c) 1996-2018, PostgreSQL Global Development Group
 *
 * IDENTIFICATION
 *		  src/bin/pg_basebackup/pg_basebackup.c
 *-------------------------------------------------------------------------
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres_fe.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;unistd.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;dirent.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/stat.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/wait.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;signal.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;time.h&gt;</cpp:file></cpp:include>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_SYS_SELECT_H</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/select.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_LIBZ</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;zlib.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/xlog_internal.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"common/file_perm.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"common/file_utils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"common/string.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"common/polar_fs_fe.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"fe_utils/string_utils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"getopt_long.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"libpq-fe.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pqexpbuffer.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pgtar.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pgtime.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"receivelog.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"replication/basebackup.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"streamutil.h"</cpp:file></cpp:include>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ERRCODE_DATA_CORRUPTED</name></cpp:macro>	<cpp:value>"XX001"</cpp:value></cpp:define>

<typedef>typedef <type><struct>struct <name>TablespaceListCell</name>
<block>{
	<decl_stmt><decl><type><name><name>struct</name> <name>TablespaceListCell</name></name> <modifier>*</modifier></type><name>next</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>old_dir</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>new_dir</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name></decl>;</decl_stmt>
}</block></struct></type> <name>TablespaceListCell</name>;</typedef>

<typedef>typedef <type><struct>struct <name>TablespaceList</name>
<block>{
	<decl_stmt><decl><type><name>TablespaceListCell</name> <modifier>*</modifier></type><name>head</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TablespaceListCell</name> <modifier>*</modifier></type><name>tail</name></decl>;</decl_stmt>
}</block></struct></type> <name>TablespaceList</name>;</typedef>

<comment type="block">/*
 * pg_xlog has been renamed to pg_wal in version 10.  This version number
 * should be compared with PQserverVersion().
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MINIMUM_VERSION_FOR_PG_WAL</name></cpp:macro>	<cpp:value>100000</cpp:value></cpp:define>

<comment type="block">/*
 * Temporary replication slots are supported from version 10.
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MINIMUM_VERSION_FOR_TEMP_SLOTS</name></cpp:macro> <cpp:value>100000</cpp:value></cpp:define>

<comment type="block">/*
 * Different ways to include WAL
 */</comment>
<typedef>typedef <type><enum>enum
<block>{
	<decl><name>NO_WAL</name></decl>,
	<decl><name>FETCH_WAL</name></decl>,
	<decl><name>STREAM_WAL</name></decl>
}</block></enum></type> <name>IncludeWal</name>;</typedef>

<comment type="block">/* Global options */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>basedir</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>datadir</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>TablespaceList</name></type> <name>tablespace_dirs</name> <init>= <expr><block>{<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>}</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>xlog_dir</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name></type> <name>format</name> <init>= <expr><literal type="char">'p'</literal></expr></init></decl>;</decl_stmt>		<comment type="block">/* p(lain)/t(ar) */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>label</name> <init>= <expr><literal type="string">"pg_basebackup base backup"</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type> <name>noclean</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type> <name>checksum_failure</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type> <name>showprogress</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type>	<name>verbose</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type>	<name>compresslevel</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>IncludeWal</name></type> <name>includewal</name> <init>= <expr><name>STREAM_WAL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type> <name>fastcheckpoint</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type> <name>writerecoveryconf</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type> <name>do_sync</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type>	<name>standby_message_timeout</name> <init>= <expr><literal type="number">10</literal> <operator>*</operator> <literal type="number">1000</literal></expr></init></decl>;</decl_stmt>	<comment type="block">/* 10 sec = default */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>pg_time_t</name></type> <name>last_progress_report</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>int32</name></type> <name>maxrate</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>		<comment type="block">/* no limit by default */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>replication_slot</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type> <name>temp_replication_slot</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type> <name>create_slot</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type> <name>no_slot</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type> <name>verify_checksums</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type> <name>success</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type> <name>made_new_pgdata</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type> <name>made_new_pgbase</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type> <name>found_existing_pgdata</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type> <name>found_existing_poalrdata</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type> <name>made_new_xlogdir</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type> <name>found_existing_xlogdir</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type> <name>made_tablespace_dirs</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type> <name>found_tablespace_dirs</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>is_pfs_mode</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>is_polar_mode</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

<comment type="block">/* Progress counters */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>uint64</name></type> <name>totalsize</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>uint64</name></type> <name>totaldone</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type>	<name>tablespacecount</name></decl>;</decl_stmt>

<comment type="block">/* Pipe to communicate with background wal receiver process */</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>WIN32</name></cpp:ifndef>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type>	<name><name>bgpipe</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <init>= <expr><block>{<expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><operator>-</operator><literal type="number">1</literal></expr>}</block></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* Handle to child process */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>pid_t</name></type> <name>bgchild</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type> <name>in_log_streamer</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

<comment type="block">/* End position for xlog streaming, empty string if unknown yet */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>XLogRecPtr</name></type> <name>xlogendptr</name></decl>;</decl_stmt>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>WIN32</name></cpp:ifndef>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type>	<name>has_xlogendptr</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>volatile</specifier> <name>LONG</name></type> <name>has_xlogendptr</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* Contents of recovery.conf to be generated */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>PQExpBuffer</name></type> <name>recoveryconfcontents</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<comment type="block">/* Function headers */</comment>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>usage</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>disconnect_and_exit</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>code</name></decl></parameter>)</parameter_list> pg_attribute_noreturn<parameter_list>()</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>verify_dir_is_empty_or_create</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>dirname</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>created</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>found</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>is_pfs</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>progress_report</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>tablespacenum</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>filename</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>force</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ReceiveTarFile</name><parameter_list>(<parameter><decl><type><name>PGconn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>, <parameter><decl><type><name>PGresult</name> <modifier>*</modifier></type><name>res</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>rownum</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ReceiveAndUnpackTarFile</name><parameter_list>(<parameter><decl><type><name>PGconn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>, <parameter><decl><type><name>PGresult</name> <modifier>*</modifier></type><name>res</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>rownum</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>GenerateRecoveryConf</name><parameter_list>(<parameter><decl><type><name>PGconn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>WriteRecoveryConf</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>BaseBackup</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>reached_end_position</name><parameter_list>(<parameter><decl><type><name>XLogRecPtr</name></type> <name>segendpos</name></decl></parameter>, <parameter><decl><type><name>uint32</name></type> <name>timeline</name></decl></parameter>,
					 <parameter><decl><type><name>bool</name></type> <name>segment_finished</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>get_tablespace_mapping</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>dir</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>tablespace_list_append</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>;</function_decl>


<function><type><specifier>static</specifier> <name>void</name></type>
<name>cleanup_directories_atexit</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>success</name> <operator>||</operator> <name>in_log_streamer</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>noclean</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>checksum_failure</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>made_new_pgbase</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: removing data directory \"%s\"\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
					<argument><expr><name>progname</name></expr></argument>, <argument><expr><name>basedir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>rmtree</name><argument_list>(<argument><expr><name>basedir</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: failed to remove data directory\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
						<argument><expr><name>progname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name>found_existing_pgdata</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>,
					<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: removing contents of data directory \"%s\"\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
					<argument><expr><name>progname</name></expr></argument>, <argument><expr><name>basedir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>rmtree</name><argument_list>(<argument><expr><name>basedir</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: failed to remove contents of data directory\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
						<argument><expr><name>progname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>made_new_pgdata</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: removing data directory \"%s\"\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
					<argument><expr><name>progname</name></expr></argument>, <argument><expr><name>datadir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>polar_rmtree</name><argument_list>(<argument><expr><name>datadir</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>is_pfs_mode</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: failed to remove data directory\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
						<argument><expr><name>progname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name>found_existing_poalrdata</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>,
					<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: removing contents of data directory \"%s\"\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
					<argument><expr><name>progname</name></expr></argument>, <argument><expr><name>datadir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>polar_rmtree</name><argument_list>(<argument><expr><name>datadir</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>is_pfs_mode</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: failed to remove contents of data directory\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
						<argument><expr><name>progname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
		

		<if_stmt><if>if <condition>(<expr><name>made_new_xlogdir</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: removing WAL directory \"%s\"\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
					<argument><expr><name>progname</name></expr></argument>, <argument><expr><name>xlog_dir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>polar_rmtree</name><argument_list>(<argument><expr><name>xlog_dir</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>is_pfs_mode</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: failed to remove WAL directory\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
						<argument><expr><name>progname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name>found_existing_xlogdir</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>,
					<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: removing contents of WAL directory \"%s\"\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
					<argument><expr><name>progname</name></expr></argument>, <argument><expr><name>xlog_dir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>polar_rmtree</name><argument_list>(<argument><expr><name>xlog_dir</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>is_pfs_mode</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: failed to remove contents of WAL directory\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
						<argument><expr><name>progname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>(</operator><name>made_new_pgdata</name> <operator>||</operator> <name>found_existing_pgdata</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>!</operator><name>checksum_failure</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>,
					<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: data directory \"%s\" not removed at user's request\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
					<argument><expr><name>progname</name></expr></argument>, <argument><expr><name>basedir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><operator>(</operator><name>made_new_pgdata</name> <operator>||</operator> <name>found_existing_poalrdata</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>!</operator><name>checksum_failure</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>,
					<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: data directory \"%s\" not removed at user's request\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
					<argument><expr><name>progname</name></expr></argument>, <argument><expr><name>datadir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>made_new_xlogdir</name> <operator>||</operator> <name>found_existing_xlogdir</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>,
					<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: WAL directory \"%s\" not removed at user's request\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
					<argument><expr><name>progname</name></expr></argument>, <argument><expr><name>xlog_dir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>made_tablespace_dirs</name> <operator>||</operator> <name>found_tablespace_dirs</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>!</operator><name>checksum_failure</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>,
				<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: changes to tablespace directories will not be undone\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
				<argument><expr><name>progname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>disconnect_and_exit</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>code</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>conn</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PQfinish</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>WIN32</name></cpp:ifndef>

	<comment type="block">/*
	 * On windows, our background thread dies along with the process. But on
	 * Unix, if we have started a subprocess, we want to kill it off so it
	 * doesn't remain running trying to stream data.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>bgchild</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>kill</name><argument_list>(<argument><expr><name>bgchild</name></expr></argument>, <argument><expr><name>SIGTERM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><name>code</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * Split argument into old_dir and new_dir and append to tablespace mapping
 * list.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>tablespace_list_append</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TablespaceListCell</name> <modifier>*</modifier></type><name>cell</name> <init>= <expr><operator>(</operator><name>TablespaceListCell</name> <operator>*</operator><operator>)</operator> <call><name>pg_malloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>TablespaceListCell</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>dst</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>dst_ptr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>arg_ptr</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>dst_ptr</name> <operator>=</operator> <name>dst</name> <operator>=</operator> <name><name>cell</name><operator>-&gt;</operator><name>old_dir</name></name></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>arg_ptr</name> <operator>=</operator> <name>arg</name></expr>;</init> <condition><expr><operator>*</operator><name>arg_ptr</name></expr>;</condition> <incr><expr><name>arg_ptr</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>dst_ptr</name> <operator>-</operator> <name>dst</name> <operator>&gt;=</operator> <name>MAXPGPATH</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: directory name too long\n"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>progname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><operator>*</operator><name>arg_ptr</name> <operator>==</operator> <literal type="char">'\\'</literal> <operator>&amp;&amp;</operator> <operator>*</operator><operator>(</operator><name>arg_ptr</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>==</operator> <literal type="char">'='</literal></expr>)</condition><block type="pseudo"><block_content>
			<empty_stmt>;</empty_stmt></block_content></block></if>					<comment type="block">/* skip backslash escaping = */</comment>
		<if type="elseif">else if <condition>(<expr><operator>*</operator><name>arg_ptr</name> <operator>==</operator> <literal type="char">'='</literal> <operator>&amp;&amp;</operator> <operator>(</operator><name>arg_ptr</name> <operator>==</operator> <name>arg</name> <operator>||</operator> <operator>*</operator><operator>(</operator><name>arg_ptr</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator> <operator>!=</operator> <literal type="char">'\\'</literal><operator>)</operator></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><operator>*</operator><name><name>cell</name><operator>-&gt;</operator><name>new_dir</name></name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: multiple \"=\" signs in tablespace mapping\n"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>progname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name>dst</name> <operator>=</operator> <name>dst_ptr</name> <operator>=</operator> <name><name>cell</name><operator>-&gt;</operator><name>new_dir</name></name></expr>;</expr_stmt></block_content></block></else></if_stmt>
		</block_content>}</block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><operator>*</operator><name>dst_ptr</name><operator>++</operator> <operator>=</operator> <operator>*</operator><name>arg_ptr</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></for>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>*</operator><name><name>cell</name><operator>-&gt;</operator><name>old_dir</name></name> <operator>||</operator> <operator>!</operator><operator>*</operator><name><name>cell</name><operator>-&gt;</operator><name>new_dir</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>,
				<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: invalid tablespace mapping format \"%s\", must be \"OLDDIR=NEWDIR\"\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
				<argument><expr><name>progname</name></expr></argument>, <argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * This check isn't absolutely necessary.  But all tablespaces are created
	 * with absolute directories, so specifying a non-absolute path here would
	 * just never match, possibly confusing users.  It's also good to be
	 * consistent with the new_dir check.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>is_absolute_path</name><argument_list>(<argument><expr><name><name>cell</name><operator>-&gt;</operator><name>old_dir</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: old directory is not an absolute path in tablespace mapping: %s\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
				<argument><expr><name>progname</name></expr></argument>, <argument><expr><name><name>cell</name><operator>-&gt;</operator><name>old_dir</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>is_absolute_path</name><argument_list>(<argument><expr><name><name>cell</name><operator>-&gt;</operator><name>new_dir</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: new directory is not an absolute path in tablespace mapping: %s\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
				<argument><expr><name>progname</name></expr></argument>, <argument><expr><name><name>cell</name><operator>-&gt;</operator><name>new_dir</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Comparisons done with these values should involve similarly
	 * canonicalized path values.  This is particularly sensitive on Windows
	 * where path values may not necessarily use Unix slashes.
	 */</comment>
	<expr_stmt><expr><call><name>canonicalize_path</name><argument_list>(<argument><expr><name><name>cell</name><operator>-&gt;</operator><name>old_dir</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>canonicalize_path</name><argument_list>(<argument><expr><name><name>cell</name><operator>-&gt;</operator><name>new_dir</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>tablespace_dirs</name><operator>.</operator><name>tail</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>tablespace_dirs</name><operator>.</operator><name>tail</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name>cell</name></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>tablespace_dirs</name><operator>.</operator><name>head</name></name> <operator>=</operator> <name>cell</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
	<expr_stmt><expr><name><name>tablespace_dirs</name><operator>.</operator><name>tail</name></name> <operator>=</operator> <name>cell</name></expr>;</expr_stmt>
</block_content>}</block></function>


<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_LIBZ</name></cpp:ifdef>
<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>
<name>get_gz_error</name><parameter_list>(<parameter><decl><type><name>gzFile</name></type> <name>gzf</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>errnum</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>errmsg</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>errmsg</name> <operator>=</operator> <call><name>gzerror</name><argument_list>(<argument><expr><name>gzf</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>errnum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>errnum</name> <operator>==</operator> <name>Z_ERRNO</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<return>return <expr><name>errmsg</name></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>usage</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s takes a base backup of a running PostgreSQL server.\n\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
		   <argument><expr><name>progname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Usage:\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"  %s [OPTION]...\n"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>progname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"\nOptions controlling the output:\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"  -D, --pgdata=DIRECTORY receive base backup into directory\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"  -F, --format=p|t       output format (plain (default), tar)\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"  -r, --max-rate=RATE    maximum transfer rate to transfer data directory\n"</literal>
			 <literal type="string">"                         (in kB/s, or use suffix \"k\" or \"M\")\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"  -R, --write-recovery-conf\n"</literal>
			 <literal type="string">"                         write recovery.conf for replication\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"  -T, --tablespace-mapping=OLDDIR=NEWDIR\n"</literal>
			 <literal type="string">"                         relocate tablespace in OLDDIR to NEWDIR\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"      --waldir=WALDIR    location for the write-ahead log directory\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"  -X, --wal-method=none|fetch|stream\n"</literal>
			 <literal type="string">"                         include required WAL files with specified method\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"  -z, --gzip             compress tar output\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"  -Z, --compress=0-9     compress tar output with given compression level\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"\nGeneral options:\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"  -c, --checkpoint=fast|spread\n"</literal>
			 <literal type="string">"                         set fast or spread checkpointing\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"  -C, --create-slot      create replication slot\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"  -l, --label=LABEL      set backup label\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"  -n, --no-clean         do not clean up after errors\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"  -N, --no-sync          do not wait for changes to be written safely to disk\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"  -P, --progress         show progress information\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"  -S, --slot=SLOTNAME    replication slot to use\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"  -v, --verbose          output verbose messages\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"  -V, --version          output version information, then exit\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"      --no-slot          prevent creation of temporary replication slot\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"      --no-verify-checksums\n"</literal>
			 <literal type="string">"                         do not verify checksums\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"  -?, --help             show this help, then exit\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"\nConnection options:\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"  -d, --dbname=CONNSTR   connection string\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"  -h, --host=HOSTNAME    database server host or socket directory\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"  -p, --port=PORT        database server port number\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"  -s, --status-interval=INTERVAL\n"</literal>
			 <literal type="string">"                         time between status packets sent to server (in seconds)\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"  -U, --username=NAME    connect as specified database user\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"  -w, --no-password      never prompt for password\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"  -W, --password         force password prompt (should happen automatically)\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"      --polardata=datadir  receive polar data backup into directory\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"      --polar_disk_home=disk  polar_disk_home for polar data backup \n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"      --polar_host_id=host_id  polar_host_id for polar data backup\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"      --polar_storage_cluster_name=cluster_name  polar_storage_cluster_name for polar data backup\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"\nReport bugs to &lt;support@alibaba.com&gt;.\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * Called in the background process every time data is received.
 * On Unix, we check to see if there is any data on our pipe
 * (which would mean we have a stop position), and if it is, check if
 * it is time to stop.
 * On Windows, we are in a single process, so we can just check if it's
 * time to stop.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>reached_end_position</name><parameter_list>(<parameter><decl><type><name>XLogRecPtr</name></type> <name>segendpos</name></decl></parameter>, <parameter><decl><type><name>uint32</name></type> <name>timeline</name></decl></parameter>,
					 <parameter><decl><type><name>bool</name></type> <name>segment_finished</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>has_xlogendptr</name></expr>)</condition>
	<block>{<block_content>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>WIN32</name></cpp:ifndef>
		<decl_stmt><decl><type><name>fd_set</name></type>		<name>fds</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name><name>struct</name> <name>timeval</name></name></type> <name>tv</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>r</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * Don't have the end pointer yet - check our pipe to see if it has
		 * been sent yet.
		 */</comment>
		<expr_stmt><expr><call><name>FD_ZERO</name><argument_list>(<argument><expr><operator>&amp;</operator><name>fds</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>FD_SET</name><argument_list>(<argument><expr><name><name>bgpipe</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>fds</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tv</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>tv</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>select</name><argument_list>(<argument><expr><name><name>bgpipe</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>fds</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>r</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>char</name></type>		<name><name>xlogend</name><index>[<expr><literal type="number">64</literal></expr>]</index></name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>uint32</name></type>		<name>hi</name></decl>,
						<decl><type ref="prev"/><name>lo</name></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><name>xlogend</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>xlogend</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>read</name><argument_list>(<argument><expr><name><name>bgpipe</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name>xlogend</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>xlogend</name></expr></argument>)</argument_list></sizeof> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>r</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: could not read from ready pipe: %s\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
						<argument><expr><name>progname</name></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>sscanf</name><argument_list>(<argument><expr><name>xlogend</name></expr></argument>, <argument><expr><literal type="string">"%X/%X"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>hi</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>lo</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">2</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>,
						<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: could not parse write-ahead log location \"%s\"\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
						<argument><expr><name>progname</name></expr></argument>, <argument><expr><name>xlogend</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			<expr_stmt><expr><name>xlogendptr</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>uint64</name><operator>)</operator> <name>hi</name><operator>)</operator> <operator>&lt;&lt;</operator> <literal type="number">32</literal> <operator>|</operator> <name>lo</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>has_xlogendptr</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

			<comment type="block">/*
			 * Fall through to check if we've reached the point further
			 * already.
			 */</comment>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/*
			 * No data received on the pipe means we don't know the end
			 * position yet - so just say it's not time to stop yet.
			 */</comment>
			<return>return <expr><name>false</name></expr>;</return>
		</block_content>}</block></else></if_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

		<comment type="block">/*
		 * On win32, has_xlogendptr is set by the main thread, so if it's not
		 * set here, we just go back and wait until it shows up.
		 */</comment>
		<return>return <expr><name>false</name></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * At this point we have an end pointer, so compare it to the current
	 * position to figure out if it's time to stop.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>segendpos</name> <operator>&gt;=</operator> <name>xlogendptr</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Have end pointer, but haven't reached it yet - so tell the caller to
	 * keep streaming.
	 */</comment>
	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<typedef>typedef <type><struct>struct
<block>{
	<decl_stmt><decl><type><name>PGconn</name>	   <modifier>*</modifier></type><name>bgconn</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>XLogRecPtr</name></type>	<name>startptr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>xlog</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name></decl>;</decl_stmt>	<comment type="block">/* directory or tarfile depending on mode */</comment>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>sysidentifier</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>timeline</name></decl>;</decl_stmt>
}</block></struct></type> <name>logstreamer_param</name>;</typedef>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>LogStreamerMain</name><parameter_list>(<parameter><decl><type><name>logstreamer_param</name> <modifier>*</modifier></type><name>param</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>StreamCtl</name></type>	<name>stream</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>in_log_streamer</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><operator>&amp;</operator><name>stream</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>stream</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>stream</name><operator>.</operator><name>startpos</name></name> <operator>=</operator> <name><name>param</name><operator>-&gt;</operator><name>startptr</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>stream</name><operator>.</operator><name>timeline</name></name> <operator>=</operator> <name><name>param</name><operator>-&gt;</operator><name>timeline</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>stream</name><operator>.</operator><name>sysidentifier</name></name> <operator>=</operator> <name><name>param</name><operator>-&gt;</operator><name>sysidentifier</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>stream</name><operator>.</operator><name>stream_stop</name></name> <operator>=</operator> <name>reached_end_position</name></expr>;</expr_stmt>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>WIN32</name></cpp:ifndef>
	<expr_stmt><expr><name><name>stream</name><operator>.</operator><name>stop_socket</name></name> <operator>=</operator> <name><name>bgpipe</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	<expr_stmt><expr><name><name>stream</name><operator>.</operator><name>stop_socket</name></name> <operator>=</operator> <name>PGINVALID_SOCKET</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<expr_stmt><expr><name><name>stream</name><operator>.</operator><name>standby_message_timeout</name></name> <operator>=</operator> <name>standby_message_timeout</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>stream</name><operator>.</operator><name>synchronous</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<comment type="block">/* fsync happens at the end of pg_basebackup for all data */</comment>
	<expr_stmt><expr><name><name>stream</name><operator>.</operator><name>do_sync</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>stream</name><operator>.</operator><name>mark_done</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>stream</name><operator>.</operator><name>partial_suffix</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>stream</name><operator>.</operator><name>replication_slot</name></name> <operator>=</operator> <name>replication_slot</name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>format</name> <operator>==</operator> <literal type="char">'p'</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>stream</name><operator>.</operator><name>walmethod</name></name> <operator>=</operator> <call><name>CreateWalDirectoryMethod</name><argument_list>(<argument><expr><name><name>param</name><operator>-&gt;</operator><name>xlog</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
													<argument><expr><name><name>stream</name><operator>.</operator><name>do_sync</name></name></expr></argument>, <argument><expr><name>is_pfs_mode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>stream</name><operator>.</operator><name>walmethod</name></name> <operator>=</operator> <call><name>CreateWalTarMethod</name><argument_list>(<argument><expr><name><name>param</name><operator>-&gt;</operator><name>xlog</name></name></expr></argument>, <argument><expr><name>compresslevel</name></expr></argument>,
											  <argument><expr><name><name>stream</name><operator>.</operator><name>do_sync</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ReceiveXlogStream</name><argument_list>(<argument><expr><name><name>param</name><operator>-&gt;</operator><name>bgconn</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>stream</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

		<comment type="block">/*
		 * Any errors will already have been reported in the function process,
		 * but we need to tell the parent that we didn't shutdown in a nice
		 * way.
		 */</comment>
		<return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>stream</name><operator>.</operator><name>walmethod</name><operator>-&gt;</operator><name>finish</name></name><argument_list>()</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>,
				<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: could not finish writing WAL files: %s\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
				<argument><expr><name>progname</name></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><literal type="number">1</literal></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>PQfinish</name><argument_list>(<argument><expr><name><name>param</name><operator>-&gt;</operator><name>bgconn</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>format</name> <operator>==</operator> <literal type="char">'p'</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>FreeWalDirectoryMethod</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>FreeWalTarMethod</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	<expr_stmt><expr><call><name>pg_free</name><argument_list>(<argument><expr><name><name>stream</name><operator>.</operator><name>walmethod</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Initiate background process for receiving xlog during the backup.
 * The background stream will use its own database connection so we can
 * stream the logfile in parallel with the backups.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>StartLogStreamer</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>startpos</name></decl></parameter>, <parameter><decl><type><name>uint32</name></type> <name>timeline</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>sysidentifier</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>logstreamer_param</name> <modifier>*</modifier></type><name>param</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32</name></type>		<name>hi</name></decl>,
				<decl><type ref="prev"/><name>lo</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>statusdir</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name></decl>;</decl_stmt>

	<expr_stmt><expr><name>param</name> <operator>=</operator> <call><name>pg_malloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>logstreamer_param</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>param</name><operator>-&gt;</operator><name>timeline</name></name> <operator>=</operator> <name>timeline</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>param</name><operator>-&gt;</operator><name>sysidentifier</name></name> <operator>=</operator> <name>sysidentifier</name></expr>;</expr_stmt>

	<comment type="block">/* Convert the starting position */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>sscanf</name><argument_list>(<argument><expr><name>startpos</name></expr></argument>, <argument><expr><literal type="string">"%X/%X"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>hi</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>lo</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">2</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>,
				<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: could not parse write-ahead log location \"%s\"\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
				<argument><expr><name>progname</name></expr></argument>, <argument><expr><name>startpos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>disconnect_and_exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name><name>param</name><operator>-&gt;</operator><name>startptr</name></name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>uint64</name><operator>)</operator> <name>hi</name><operator>)</operator> <operator>&lt;&lt;</operator> <literal type="number">32</literal> <operator>|</operator> <name>lo</name></expr>;</expr_stmt>
	<comment type="block">/* Round off to even segment position */</comment>
	<expr_stmt><expr><name><name>param</name><operator>-&gt;</operator><name>startptr</name></name> <operator>-=</operator> <call><name>XLogSegmentOffset</name><argument_list>(<argument><expr><name><name>param</name><operator>-&gt;</operator><name>startptr</name></name></expr></argument>, <argument><expr><name>WalSegSz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>WIN32</name></cpp:ifndef>
	<comment type="block">/* Create our background pipe */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>pipe</name><argument_list>(<argument><expr><name>bgpipe</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>,
				<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: could not create pipe for background process: %s\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
				<argument><expr><name>progname</name></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>disconnect_and_exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<comment type="block">/* Get a second connection */</comment>
	<expr_stmt><expr><name><name>param</name><operator>-&gt;</operator><name>bgconn</name></name> <operator>=</operator> <call><name>GetConnection</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>param</name><operator>-&gt;</operator><name>bgconn</name></name></expr>)</condition><block type="pseudo"><block_content>
		<comment type="block">/* Error message already written in GetConnection() */</comment>
		<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* In post-10 cluster, pg_xlog has been renamed to pg_wal */</comment>
	<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name><name>param</name><operator>-&gt;</operator><name>xlog</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>param</name><operator>-&gt;</operator><name>xlog</name></name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"%s/%s"</literal></expr></argument>,
			 <argument><expr><name>datadir</name></expr></argument>,
			 <argument><expr><ternary><condition><expr><call><name>PQserverVersion</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <name>MINIMUM_VERSION_FOR_PG_WAL</name></expr> ?</condition><then>
			 <expr><literal type="string">"pg_xlog"</literal></expr> </then><else>: <expr><literal type="string">"pg_wal"</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Temporary replication slots are only supported in 10 and newer */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>PQserverVersion</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <name>MINIMUM_VERSION_FOR_TEMP_SLOTS</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>temp_replication_slot</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Create replication slot if requested
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>temp_replication_slot</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>replication_slot</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>replication_slot</name> <operator>=</operator> <call><name>psprintf</name><argument_list>(<argument><expr><literal type="string">"pg_basebackup_%d"</literal></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <call><name>PQbackendPID</name><argument_list>(<argument><expr><name><name>param</name><operator>-&gt;</operator><name>bgconn</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>temp_replication_slot</name> <operator>||</operator> <name>create_slot</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>CreateReplicationSlot</name><argument_list>(<argument><expr><name><name>param</name><operator>-&gt;</operator><name>bgconn</name></name></expr></argument>, <argument><expr><name>replication_slot</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
								   <argument><expr><name>temp_replication_slot</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>disconnect_and_exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>verbose</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>temp_replication_slot</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: created temporary replication slot \"%s\"\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
						<argument><expr><name>progname</name></expr></argument>, <argument><expr><name>replication_slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: created replication slot \"%s\"\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
						<argument><expr><name>progname</name></expr></argument>, <argument><expr><name>replication_slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>format</name> <operator>==</operator> <literal type="char">'p'</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Create pg_wal/archive_status or pg_xlog/archive_status (and thus
		 * pg_wal or pg_xlog) depending on the target server so we can write
		 * to basedir/pg_wal or basedir/pg_xlog as the directory entry in the
		 * tar file may arrive later.
		 */</comment>
		<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>statusdir</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>statusdir</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"%s/%s/archive_status"</literal></expr></argument>,
				 <argument><expr><name>datadir</name></expr></argument>,
				 <argument><expr><ternary><condition><expr><call><name>PQserverVersion</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <name>MINIMUM_VERSION_FOR_PG_WAL</name></expr> ?</condition><then>
				 <expr><literal type="string">"pg_xlog"</literal></expr> </then><else>: <expr><literal type="string">"pg_wal"</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>polar_mkdir_p</name><argument_list>(<argument><expr><name>statusdir</name></expr></argument>, <argument><expr><name>pg_dir_create_mode</name></expr></argument>, <argument><expr><name>is_pfs_mode</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>errno</name> <operator>!=</operator> <name>EEXIST</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>,
					<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: could not create directory \"%s\": %s\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
					<argument><expr><name>progname</name></expr></argument>, <argument><expr><name>statusdir</name></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>disconnect_and_exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Start a child process and tell it to start streaming. On Unix, this is
	 * a fork(). On Windows, we create a thread.
	 */</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>WIN32</name></cpp:ifndef>
	<expr_stmt><expr><name>bgchild</name> <operator>=</operator> <call><name>fork</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>bgchild</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* in child process */</comment>
		<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><call><name>LogStreamerMain</name><argument_list>(<argument><expr><name>param</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>bgchild</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: could not create background process: %s\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
				<argument><expr><name>progname</name></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>disconnect_and_exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Else we are in the parent process and all is well.
	 */</comment>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>							<comment type="block">/* WIN32 */</comment>
	<expr_stmt><expr><name>bgchild</name> <operator>=</operator> <call><name>_beginthreadex</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>LogStreamerMain</name></expr></argument>, <argument><expr><name>param</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>bgchild</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: could not create background thread: %s\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
				<argument><expr><name>progname</name></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>disconnect_and_exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>

<comment type="block">/*
 * Verify that the given directory exists and is empty. If it does not
 * exist, it is created. If it exists but is not empty, an error will
 * be given and the process ended.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>verify_dir_is_empty_or_create</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>dirname</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>created</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>found</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>is_pfs</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<switch>switch <condition>(<expr><call><name>polar_check_dir</name><argument_list>(<argument><expr><name>dirname</name></expr></argument>, <argument><expr><name>is_pfs</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><literal type="number">0</literal></expr>:</case>

			<comment type="block">/*
			 * Does not exist, so create
			 */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>polar_mkdir_p</name><argument_list>(<argument><expr><name>dirname</name></expr></argument>, <argument><expr><name>pg_dir_create_mode</name></expr></argument>, <argument><expr><name>is_pfs</name></expr></argument>)</argument_list></call> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>,
						<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: could not create directory \"%s\": %s\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
						<argument><expr><name>progname</name></expr></argument>, <argument><expr><name>dirname</name></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>disconnect_and_exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><name>created</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><operator>*</operator><name>created</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<return>return;</return>
		<case>case <expr><literal type="number">1</literal></expr>:</case>

			<comment type="block">/*
			 * Exists, empty
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name>found</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><operator>*</operator><name>found</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<return>return;</return>
		<case>case <expr><literal type="number">2</literal></expr>:</case>
		<case>case <expr><literal type="number">3</literal></expr>:</case>
		<case>case <expr><literal type="number">4</literal></expr>:</case>

			<comment type="block">/*
			 * Exists, not empty
			 */</comment>
			<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>,
					<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: directory \"%s\" exists but is not empty\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
					<argument><expr><name>progname</name></expr></argument>, <argument><expr><name>dirname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>disconnect_and_exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<case>case <expr><operator>-</operator><literal type="number">1</literal></expr>:</case>

			<comment type="block">/*
			 * Access problem
			 */</comment>
			<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: could not access directory \"%s\": %s\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
					<argument><expr><name>progname</name></expr></argument>, <argument><expr><name>dirname</name></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>disconnect_and_exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></switch>
</block_content>}</block></function>


<comment type="block">/*
 * Print a progress report based on the global variables. If verbose output
 * is enabled, also print the current file name.
 *
 * Progress report is written at maximum once per second, unless the
 * force parameter is set to true.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>progress_report</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>tablespacenum</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>filename</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>force</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>percent</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>totaldone_str</name><index>[<expr><literal type="number">32</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>totalsize_str</name><index>[<expr><literal type="number">32</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>pg_time_t</name></type>	<name>now</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>showprogress</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>now</name> <operator>=</operator> <call><name>time</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>now</name> <operator>==</operator> <name>last_progress_report</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>force</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>					<comment type="block">/* Max once per second */</comment>

	<expr_stmt><expr><name>last_progress_report</name> <operator>=</operator> <name>now</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>percent</name> <operator>=</operator> <ternary><condition><expr><name>totalsize</name></expr> ?</condition><then> <expr><operator>(</operator><name>int</name><operator>)</operator> <operator>(</operator><operator>(</operator><name>totaldone</name> <operator>/</operator> <literal type="number">1024</literal><operator>)</operator> <operator>*</operator> <literal type="number">100</literal> <operator>/</operator> <name>totalsize</name><operator>)</operator></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr>;</expr_stmt>

	<comment type="block">/*
	 * Avoid overflowing past 100% or the full size. This may make the total
	 * size number change as we approach the end of the backup (the estimate
	 * will always be wrong if WAL is included), but that's better than having
	 * the done column be bigger than the total.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>percent</name> <operator>&gt;</operator> <literal type="number">100</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>percent</name> <operator>=</operator> <literal type="number">100</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>totaldone</name> <operator>/</operator> <literal type="number">1024</literal> <operator>&gt;</operator> <name>totalsize</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>totalsize</name> <operator>=</operator> <name>totaldone</name> <operator>/</operator> <literal type="number">1024</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Separate step to keep platform-dependent format code out of
	 * translatable strings.  And we only test for INT64_FORMAT availability
	 * in snprintf, not fprintf.
	 */</comment>
	<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>totaldone_str</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>totaldone_str</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>INT64_FORMAT</name></expr></argument>,
			 <argument><expr><name>totaldone</name> <operator>/</operator> <literal type="number">1024</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>totalsize_str</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>totalsize_str</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>INT64_FORMAT</name></expr></argument>, <argument><expr><name>totalsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>VERBOSE_FILENAME_LENGTH</name></cpp:macro> <cpp:value>35</cpp:value></cpp:define>
	<if_stmt><if>if <condition>(<expr><name>verbose</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>filename</name></expr>)</condition><block type="pseudo"><block_content>

			<comment type="block">/*
			 * No filename given, so clear the status line (used for last
			 * call)
			 */</comment>
			<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>,
					<argument><expr><call><name>ngettext</name><argument_list>(<argument><expr><literal type="string">"%*s/%s kB (100%%), %d/%d tablespace %*s"</literal></expr></argument>,
							 <argument><expr><literal type="string">"%*s/%s kB (100%%), %d/%d tablespaces %*s"</literal></expr></argument>,
							 <argument><expr><name>tablespacecount</name></expr></argument>)</argument_list></call></expr></argument>,
					<argument><expr><operator>(</operator><name>int</name><operator>)</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>totalsize_str</name></expr></argument>)</argument_list></call></expr></argument>,
					<argument><expr><name>totaldone_str</name></expr></argument>, <argument><expr><name>totalsize_str</name></expr></argument>,
					<argument><expr><name>tablespacenum</name></expr></argument>, <argument><expr><name>tablespacecount</name></expr></argument>,
					<argument><expr><name>VERBOSE_FILENAME_LENGTH</name> <operator>+</operator> <literal type="number">5</literal></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else
		<block>{<block_content>
			<decl_stmt><decl><type><name>bool</name></type>		<name>truncate</name> <init>= <expr><operator>(</operator><call><name>strlen</name><argument_list>(<argument><expr><name>filename</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <name>VERBOSE_FILENAME_LENGTH</name><operator>)</operator></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>,
					<argument><expr><call><name>ngettext</name><argument_list>(<argument><expr><literal type="string">"%*s/%s kB (%d%%), %d/%d tablespace (%s%-*.*s)"</literal></expr></argument>,
							 <argument><expr><literal type="string">"%*s/%s kB (%d%%), %d/%d tablespaces (%s%-*.*s)"</literal></expr></argument>,
							 <argument><expr><name>tablespacecount</name></expr></argument>)</argument_list></call></expr></argument>,
					<argument><expr><operator>(</operator><name>int</name><operator>)</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>totalsize_str</name></expr></argument>)</argument_list></call></expr></argument>,
					<argument><expr><name>totaldone_str</name></expr></argument>, <argument><expr><name>totalsize_str</name></expr></argument>, <argument><expr><name>percent</name></expr></argument>,
					<argument><expr><name>tablespacenum</name></expr></argument>, <argument><expr><name>tablespacecount</name></expr></argument>,
			<comment type="block">/* Prefix with "..." if we do leading truncation */</comment>
					<argument><expr><ternary><condition><expr><name>truncate</name></expr> ?</condition><then> <expr><literal type="string">"..."</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>,
					<argument><expr><ternary><condition><expr><name>truncate</name></expr> ?</condition><then> <expr><name>VERBOSE_FILENAME_LENGTH</name> <operator>-</operator> <literal type="number">3</literal></expr> </then><else>: <expr><name>VERBOSE_FILENAME_LENGTH</name></expr></else></ternary></expr></argument>,
					<argument><expr><ternary><condition><expr><name>truncate</name></expr> ?</condition><then> <expr><name>VERBOSE_FILENAME_LENGTH</name> <operator>-</operator> <literal type="number">3</literal></expr> </then><else>: <expr><name>VERBOSE_FILENAME_LENGTH</name></expr></else></ternary></expr></argument>,
			<comment type="block">/* Truncate filename at beginning if it's too long */</comment>
					<argument><expr><ternary><condition><expr><name>truncate</name></expr> ?</condition><then> <expr><name>filename</name> <operator>+</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>filename</name></expr></argument>)</argument_list></call> <operator>-</operator> <name>VERBOSE_FILENAME_LENGTH</name> <operator>+</operator> <literal type="number">3</literal></expr> </then><else>: <expr><name>filename</name></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>,
				<argument><expr><call><name>ngettext</name><argument_list>(<argument><expr><literal type="string">"%*s/%s kB (%d%%), %d/%d tablespace"</literal></expr></argument>,
						 <argument><expr><literal type="string">"%*s/%s kB (%d%%), %d/%d tablespaces"</literal></expr></argument>,
						 <argument><expr><name>tablespacecount</name></expr></argument>)</argument_list></call></expr></argument>,
				<argument><expr><operator>(</operator><name>int</name><operator>)</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>totalsize_str</name></expr></argument>)</argument_list></call></expr></argument>,
				<argument><expr><name>totaldone_str</name></expr></argument>, <argument><expr><name>totalsize_str</name></expr></argument>, <argument><expr><name>percent</name></expr></argument>,
				<argument><expr><name>tablespacenum</name></expr></argument>, <argument><expr><name>tablespacecount</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>isatty</name><argument_list>(<argument><expr><call><name>fileno</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"\r"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int32</name></type>
<name>parse_max_rate</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>src</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>double</name></type>		<name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>after_num</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>suffix</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>errno</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>strtod</name><argument_list>(<argument><expr><name>src</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>after_num</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>src</name> <operator>==</operator> <name>after_num</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>,
				<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: transfer rate \"%s\" is not a valid value\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
				<argument><expr><name>progname</name></expr></argument>, <argument><expr><name>src</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>errno</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>,
				<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: invalid transfer rate \"%s\": %s\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
				<argument><expr><name>progname</name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>result</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Reject obviously wrong values here.
		 */</comment>
		<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: transfer rate must be greater than zero\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
				<argument><expr><name>progname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Evaluate suffix, after skipping over possible whitespace. Lack of
	 * suffix means kilobytes.
	 */</comment>
	<while>while <condition>(<expr><operator>*</operator><name>after_num</name> <operator>!=</operator> <literal type="char">'\0'</literal> <operator>&amp;&amp;</operator> <call><name>isspace</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator> <operator>*</operator><name>after_num</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>after_num</name><operator>++</operator></expr>;</expr_stmt></block_content></block></while>

	<if_stmt><if>if <condition>(<expr><operator>*</operator><name>after_num</name> <operator>!=</operator> <literal type="char">'\0'</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>suffix</name> <operator>=</operator> <name>after_num</name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>*</operator><name>after_num</name> <operator>==</operator> <literal type="char">'k'</literal></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* kilobyte is the expected unit. */</comment>
			<expr_stmt><expr><name>after_num</name><operator>++</operator></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><operator>*</operator><name>after_num</name> <operator>==</operator> <literal type="char">'M'</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>after_num</name><operator>++</operator></expr>;</expr_stmt>
			<expr_stmt><expr><name>result</name> <operator>*=</operator> <literal type="number">1024.0</literal></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* The rest can only consist of white space. */</comment>
	<while>while <condition>(<expr><operator>*</operator><name>after_num</name> <operator>!=</operator> <literal type="char">'\0'</literal> <operator>&amp;&amp;</operator> <call><name>isspace</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator> <operator>*</operator><name>after_num</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>after_num</name><operator>++</operator></expr>;</expr_stmt></block_content></block></while>

	<if_stmt><if>if <condition>(<expr><operator>*</operator><name>after_num</name> <operator>!=</operator> <literal type="char">'\0'</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>,
				<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: invalid --max-rate unit: \"%s\"\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
				<argument><expr><name>progname</name></expr></argument>, <argument><expr><name>suffix</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Valid integer? */</comment>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>uint64</name><operator>)</operator> <name>result</name> <operator>!=</operator> <operator>(</operator><name>uint64</name><operator>)</operator> <operator>(</operator><operator>(</operator><name>uint32</name><operator>)</operator> <name>result</name><operator>)</operator></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>,
				<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: transfer rate \"%s\" exceeds integer range\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
				<argument><expr><name>progname</name></expr></argument>, <argument><expr><name>src</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * The range is checked on the server side too, but avoid the server
	 * connection if a nonsensical value was passed.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>result</name> <argument_list type="generic">&lt; <argument><expr><name>MAX_RATE_LOWER</name> <operator>||</operator> <name>result</name></expr></argument> &gt;</argument_list></name> <name>MAX_RATE_UPPER</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>,
				<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: transfer rate \"%s\" is out of range\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
				<argument><expr><name>progname</name></expr></argument>, <argument><expr><name>src</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><operator>(</operator><name>int32</name><operator>)</operator> <name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Write a piece of tar data
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>writeTarData</name><parameter_list>(
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_LIBZ</name></cpp:ifdef>
			 <parameter><decl><type><name>gzFile</name></type> <name>ztarfile</name></decl></parameter>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
			 <parameter><decl><type><name>FILE</name> <modifier>*</modifier></type><name>tarfile</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>r</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>current_file</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_LIBZ</name></cpp:ifdef>
	<if_stmt><if>if <condition>(<expr><name>ztarfile</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>errno</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>gzwrite</name><argument_list>(<argument><expr><name>ztarfile</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>r</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>r</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* if write didn't set errno, assume problem is no disk space */</comment>
			<if_stmt><if>if <condition>(<expr><name>errno</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>errno</name> <operator>=</operator> <name>ENOSPC</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>,
					<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: could not write to compressed file \"%s\": %s\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
					<argument><expr><name>progname</name></expr></argument>, <argument><expr><name>current_file</name></expr></argument>, <argument><expr><call><name>get_gz_error</name><argument_list>(<argument><expr><name>ztarfile</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>disconnect_and_exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if>
	<else>else
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<block>{<block_content>
		<expr_stmt><expr><name>errno</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>fwrite</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>tarfile</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* if write didn't set errno, assume problem is no disk space */</comment>
			<if_stmt><if>if <condition>(<expr><name>errno</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>errno</name> <operator>=</operator> <name>ENOSPC</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: could not write to file \"%s\": %s\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
					<argument><expr><name>progname</name></expr></argument>, <argument><expr><name>current_file</name></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>disconnect_and_exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_LIBZ</name></cpp:ifdef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>WRITE_TAR_DATA</name><parameter_list>(<parameter><type><name>buf</name></type></parameter>, <parameter><type><name>sz</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>writeTarData(ztarfile, tarfile, buf, sz, filename)</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>WRITE_TAR_DATA</name><parameter_list>(<parameter><type><name>buf</name></type></parameter>, <parameter><type><name>sz</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>writeTarData(tarfile, buf, sz, filename)</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
 * Receive a tar format file from the connection to the server, and write
 * the data from this file directly into a tar file. If compression is
 * enabled, the data will be compressed while written to the file.
 *
 * The file will be named base.tar[.gz] if it's for the main data directory
 * or &lt;tablespaceoid&gt;.tar[.gz] if it's for another tablespace.
 *
 * No attempt to inspect or validate the contents of the file is done.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ReceiveTarFile</name><parameter_list>(<parameter><decl><type><name>PGconn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>, <parameter><decl><type><name>PGresult</name> <modifier>*</modifier></type><name>res</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>rownum</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>filename</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>copybuf</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>FILE</name>	   <modifier>*</modifier></type><name>tarfile</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>tarhdr</name><index>[<expr><literal type="number">512</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>basetablespace</name> <init>= <expr><call><name>PQgetisnull</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>rownum</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>in_tarhdr</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>skip_file</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>size_t</name></type>		<name>tarhdrsz</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>pgoff_t</name></type>		<name>filesz</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_LIBZ</name></cpp:ifdef>
	<decl_stmt><decl><type><name>gzFile</name></type>		<name>ztarfile</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<comment type="block">/* POLAR: Is this tar streaming for polar data? */</comment>
	<decl_stmt><decl><type><name>bool</name></type>		<name>polar_data</name> <init>= <expr><operator>!</operator><call><name>PQgetisnull</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>rownum</name></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>basetablespace</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Base tablespaces
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>basedir</name></expr></argument>, <argument><expr><literal type="string">"-"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WIN32</name></cpp:ifdef>
			<expr_stmt><expr><call><name>_setmode</name><argument_list>(<argument><expr><call><name>fileno</name><argument_list>(<argument><expr><name>stdout</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>_O_BINARY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_LIBZ</name></cpp:ifdef>
			<if_stmt><if>if <condition>(<expr><name>compresslevel</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>ztarfile</name> <operator>=</operator> <call><name>gzdopen</name><argument_list>(<argument><expr><call><name>dup</name><argument_list>(<argument><expr><call><name>fileno</name><argument_list>(<argument><expr><name>stdout</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"wb"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><call><name>gzsetparams</name><argument_list>(<argument><expr><name>ztarfile</name></expr></argument>, <argument><expr><name>compresslevel</name></expr></argument>,
								<argument><expr><name>Z_DEFAULT_STRATEGY</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>Z_OK</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>,
							<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: could not set compression level %d: %s\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
							<argument><expr><name>progname</name></expr></argument>, <argument><expr><name>compresslevel</name></expr></argument>, <argument><expr><call><name>get_gz_error</name><argument_list>(<argument><expr><name>ztarfile</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>disconnect_and_exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></if>
			<else>else<block type="pseudo"><block_content>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
				<expr_stmt><expr><name>tarfile</name> <operator>=</operator> <name>stdout</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
			<expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>filename</name></expr></argument>, <argument><expr><literal type="string">"-"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/*
			 * POLAR:
			 * There are two basetablespaces during server was in polar mode
			 * which including data_directory and polar_datadir. We consume that
			 * polar_datadir's tar streaming is fllowing by data_directory. If server
			 * changes these two basetablespaces's streaming order, please update
			 * here at the same time.
			 */</comment>
			<decl_stmt><decl><type><name>char</name></type> <name><name>polar_mode</name><index>[<expr><literal type="number">4</literal></expr>]</index></name> <init>= <expr><block>{<expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt>
			<if_stmt><if>if <condition>(<expr><name>polar_data</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>strlcpy</name><argument_list>(<argument><expr><name>polar_mode</name></expr></argument>, <argument><expr><literal type="string">"ab"</literal></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>strlcpy</name><argument_list>(<argument><expr><name>polar_mode</name></expr></argument>, <argument><expr><literal type="string">"wb"</literal></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_LIBZ</name></cpp:ifdef>
			<if_stmt><if>if <condition>(<expr><name>compresslevel</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>filename</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>filename</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"%s/base.tar.gz"</literal></expr></argument>, <argument><expr><name>basedir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>ztarfile</name> <operator>=</operator> <call><name>gzopen</name><argument_list>(<argument><expr><name>filename</name></expr></argument>, <argument><expr><name>polar_mode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><call><name>gzsetparams</name><argument_list>(<argument><expr><name>ztarfile</name></expr></argument>, <argument><expr><name>compresslevel</name></expr></argument>,
								<argument><expr><name>Z_DEFAULT_STRATEGY</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>Z_OK</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>,
							<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: could not set compression level %d: %s\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
							<argument><expr><name>progname</name></expr></argument>, <argument><expr><name>compresslevel</name></expr></argument>, <argument><expr><call><name>get_gz_error</name><argument_list>(<argument><expr><name>ztarfile</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>disconnect_and_exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></if>
			<else>else
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
			<block>{<block_content>
				<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>filename</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>filename</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"%s/base.tar"</literal></expr></argument>, <argument><expr><name>basedir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>tarfile</name> <operator>=</operator> <call><name>fopen</name><argument_list>(<argument><expr><name>filename</name></expr></argument>, <argument><expr><name>polar_mode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/*
		 * Specific tablespace
		 */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_LIBZ</name></cpp:ifdef>
		<if_stmt><if>if <condition>(<expr><name>compresslevel</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>filename</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>filename</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"%s/%s.tar.gz"</literal></expr></argument>, <argument><expr><name>basedir</name></expr></argument>,
					 <argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>rownum</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>ztarfile</name> <operator>=</operator> <call><name>gzopen</name><argument_list>(<argument><expr><name>filename</name></expr></argument>, <argument><expr><literal type="string">"wb"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><call><name>gzsetparams</name><argument_list>(<argument><expr><name>ztarfile</name></expr></argument>, <argument><expr><name>compresslevel</name></expr></argument>,
							<argument><expr><name>Z_DEFAULT_STRATEGY</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>Z_OK</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>,
						<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: could not set compression level %d: %s\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
						<argument><expr><name>progname</name></expr></argument>, <argument><expr><name>compresslevel</name></expr></argument>, <argument><expr><call><name>get_gz_error</name><argument_list>(<argument><expr><name>ztarfile</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>disconnect_and_exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if>
		<else>else
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
		<block>{<block_content>
			<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>filename</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>filename</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"%s/%s.tar"</literal></expr></argument>, <argument><expr><name>basedir</name></expr></argument>,
					 <argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>rownum</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>tarfile</name> <operator>=</operator> <call><name>fopen</name><argument_list>(<argument><expr><name>filename</name></expr></argument>, <argument><expr><literal type="string">"wb"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></else></if_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_LIBZ</name></cpp:ifdef>
	<if_stmt><if>if <condition>(<expr><name>compresslevel</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>ztarfile</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Compression is in use */</comment>
			<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>,
					<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: could not create compressed file \"%s\": %s\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
					<argument><expr><name>progname</name></expr></argument>, <argument><expr><name>filename</name></expr></argument>, <argument><expr><call><name>get_gz_error</name><argument_list>(<argument><expr><name>ztarfile</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>disconnect_and_exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if>
	<else>else
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<block>{<block_content>
		<comment type="block">/* Either no zlib support, or zlib support but compresslevel = 0 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>tarfile</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: could not create file \"%s\": %s\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
					<argument><expr><name>progname</name></expr></argument>, <argument><expr><name>filename</name></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>disconnect_and_exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/*
	 * Get the COPY data stream
	 */</comment>
	<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>PQgetResult</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>PQresultStatus</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>PGRES_COPY_OUT</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: could not get COPY data stream: %s"</literal></expr></argument>)</argument_list></call></expr></argument>,
				<argument><expr><name>progname</name></expr></argument>, <argument><expr><call><name>PQerrorMessage</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>disconnect_and_exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<while>while <condition>(<expr><literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>r</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>copybuf</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>PQfreemem</name><argument_list>(<argument><expr><name>copybuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>copybuf</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>PQgetCopyData</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>copybuf</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>r</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * End of chunk. If requested, and this is the base tablespace,
			 * write recovery.conf into the tarfile. When done, close the file
			 * (but not stdout).
			 *
			 * Also, write two completely empty blocks at the end of the tar
			 * file, as required by some tar programs.
			 */</comment>
			<decl_stmt><decl><type><name>char</name></type>		<name><name>zerobuf</name><index>[<expr><literal type="number">1024</literal></expr>]</index></name></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><name>zerobuf</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>zerobuf</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* POLAR: In case of forgetting the last tar header. */</comment>
			<if_stmt><if>if <condition>(<expr><name>in_tarhdr</name> <operator>&amp;&amp;</operator>
				<name>tarhdrsz</name> <operator>==</operator> <literal type="number">512</literal> <operator>&amp;&amp;</operator>
				<operator>!</operator><name>skip_file</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>WRITE_TAR_DATA</name><argument_list>(<argument><expr><name>tarhdr</name></expr></argument>, <argument><expr><literal type="number">512</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<comment type="block">/* POLAR: Only write recovery in non-polar basetablespace. */</comment>
			<if_stmt><if>if <condition>(<expr><name>basetablespace</name> <operator>&amp;&amp;</operator> <name>writerecoveryconf</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>polar_data</name></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>char</name></type>		<name><name>header</name><index>[<expr><literal type="number">512</literal></expr>]</index></name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>int</name></type>			<name>padding</name></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>tarCreateHeader</name><argument_list>(<argument><expr><name>header</name></expr></argument>, <argument><expr><literal type="string">"recovery.conf"</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
								<argument><expr><name><name>recoveryconfcontents</name><operator>-&gt;</operator><name>len</name></name></expr></argument>,
								<argument><expr><name>pg_file_create_mode</name></expr></argument>, <argument><expr><literal type="number">04000</literal></expr></argument>, <argument><expr><literal type="number">02000</literal></expr></argument>,
								<argument><expr><call><name>time</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><name>padding</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name><name>recoveryconfcontents</name><operator>-&gt;</operator><name>len</name></name> <operator>+</operator> <literal type="number">511</literal><operator>)</operator> <operator>&amp;</operator> <operator>~</operator><literal type="number">511</literal><operator>)</operator> <operator>-</operator> <name><name>recoveryconfcontents</name><operator>-&gt;</operator><name>len</name></name></expr>;</expr_stmt>

				<expr_stmt><expr><call><name>WRITE_TAR_DATA</name><argument_list>(<argument><expr><name>header</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>header</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>WRITE_TAR_DATA</name><argument_list>(<argument><expr><name><name>recoveryconfcontents</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name><name>recoveryconfcontents</name><operator>-&gt;</operator><name>len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name>padding</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>WRITE_TAR_DATA</name><argument_list>(<argument><expr><name>zerobuf</name></expr></argument>, <argument><expr><name>padding</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/*
			 * POLAR: Append zero to compelete tar file.
			 * (1) original basebackup tool can just append zero.
			 * (2) polar basebackup tool can't append zero until polar_datadir was received.
			 * There are two basetablespaces during server was in polar mode
			 * which including data_directory and polar_datadir. We consume that
			 * polar_datadir's tar streaming is fllowing by data_directory. If server
			 * changes these two basetablespaces's streaming order, please update
			 * here at the same time.
			 *
			 * 2 * 512 bytes empty data at end of file
			 */</comment>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>is_polar_mode</name> <operator>||</operator>
				<operator>(</operator><name>is_polar_mode</name> <operator>&amp;&amp;</operator> <name>polar_data</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>WRITE_TAR_DATA</name><argument_list>(<argument><expr><name>zerobuf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>zerobuf</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_LIBZ</name></cpp:ifdef>
			<if_stmt><if>if <condition>(<expr><name>ztarfile</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><call><name>gzclose</name><argument_list>(<argument><expr><name>ztarfile</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>,
							<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: could not close compressed file \"%s\": %s\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
							<argument><expr><name>progname</name></expr></argument>, <argument><expr><name>filename</name></expr></argument>, <argument><expr><call><name>get_gz_error</name><argument_list>(<argument><expr><name>ztarfile</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>disconnect_and_exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></if>
			<else>else
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>basedir</name></expr></argument>, <argument><expr><literal type="string">"-"</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
				<block>{<block_content>
					<if_stmt><if>if <condition>(<expr><call><name>fclose</name><argument_list>(<argument><expr><name>tarfile</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>,
								<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: could not close file \"%s\": %s\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
								<argument><expr><name>progname</name></expr></argument>, <argument><expr><name>filename</name></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><call><name>disconnect_and_exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block></if></if_stmt>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></else></if_stmt>

			<break>break;</break>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name>r</name> <operator>==</operator> <operator>-</operator><literal type="number">2</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: could not read COPY data: %s"</literal></expr></argument>)</argument_list></call></expr></argument>,
					<argument><expr><name>progname</name></expr></argument>, <argument><expr><call><name>PQerrorMessage</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>disconnect_and_exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>writerecoveryconf</name> <operator>||</operator> <operator>!</operator><name>basetablespace</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * When not writing recovery.conf, or when not working on the base
			 * tablespace, we never have to look for an existing recovery.conf
			 * file in the stream.
			 */</comment>
			<expr_stmt><expr><call><name>WRITE_TAR_DATA</name><argument_list>(<argument><expr><name>copybuf</name></expr></argument>, <argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/*
			 * Look for a recovery.conf in the existing tar stream. If it's
			 * there, we must skip it so we can later overwrite it with our
			 * own version of the file.
			 *
			 * To do this, we have to process the individual files inside the
			 * TAR stream. The stream consists of a header and zero or more
			 * chunks, all 512 bytes long. The stream from the server is
			 * broken up into smaller pieces, so we have to track the size of
			 * the files to find the next header structure.
			 */</comment>
			<decl_stmt><decl><type><name>int</name></type>			<name>rr</name> <init>= <expr><name>r</name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int</name></type>			<name>pos</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>POLAR_TAR_NAME_MAX_LEN</name></cpp:macro> <cpp:value>100</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>POLAR_TAR_NAME_PREFIX</name></cpp:macro> <cpp:value>POLAR_SHARED_DATA</cpp:value></cpp:define>
			<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type> <name>polar_create_shared_datadir</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>char</name></type>		<name><name>polar_file_name</name><index>[<expr><name>POLAR_TAR_NAME_MAX_LEN</name></expr>]</index></name></decl>;</decl_stmt>

			<while>while <condition>(<expr><name>rr</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name>in_tarhdr</name></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/*
					 * We're currently reading a header structure inside the
					 * TAR stream, i.e. the file metadata.
					 */</comment>
					<if_stmt><if>if <condition>(<expr><name>tarhdrsz</name> <operator>&lt;</operator> <literal type="number">512</literal></expr>)</condition>
					<block>{<block_content>
						<comment type="block">/*
						 * Copy the header structure into tarhdr in case the
						 * header is not aligned to 512 bytes or it's not
						 * returned in whole by the last PQgetCopyData call.
						 */</comment>
						<decl_stmt><decl><type><name>int</name></type>			<name>hdrleft</name></decl>;</decl_stmt>
						<decl_stmt><decl><type><name>int</name></type>			<name>bytes2copy</name></decl>;</decl_stmt>

						<expr_stmt><expr><name>hdrleft</name> <operator>=</operator> <literal type="number">512</literal> <operator>-</operator> <name>tarhdrsz</name></expr>;</expr_stmt>
						<expr_stmt><expr><name>bytes2copy</name> <operator>=</operator> <operator>(</operator><ternary><condition><expr><name>rr</name> <operator>&gt;</operator> <name>hdrleft</name></expr> ?</condition><then> <expr><name>hdrleft</name></expr> </then><else>: <expr><name>rr</name></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>

						<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>tarhdr</name><index>[<expr><name>tarhdrsz</name></expr>]</index></name></expr></argument>, <argument><expr><name>copybuf</name> <operator>+</operator> <name>pos</name></expr></argument>, <argument><expr><name>bytes2copy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

						<expr_stmt><expr><name>rr</name> <operator>-=</operator> <name>bytes2copy</name></expr>;</expr_stmt>
						<expr_stmt><expr><name>pos</name> <operator>+=</operator> <name>bytes2copy</name></expr>;</expr_stmt>
						<expr_stmt><expr><name>tarhdrsz</name> <operator>+=</operator> <name>bytes2copy</name></expr>;</expr_stmt>
					</block_content>}</block></if>
					<else>else
					<block>{<block_content>
						<comment type="block">/*
						 * We have the complete header structure in tarhdr,
						 * look at the file metadata: - the subsequent file
						 * contents have to be skipped if the filename is
						 * recovery.conf - find out the size of the file
						 * padded to the next multiple of 512
						 */</comment>
						<decl_stmt><decl><type><name>int</name></type>			<name>padding</name></decl>;</decl_stmt>

						<expr_stmt><expr><name>skip_file</name> <operator>=</operator> <operator>(</operator><call><name>strcmp</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>tarhdr</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"recovery.conf"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr>;</expr_stmt>

						<expr_stmt><expr><name>filesz</name> <operator>=</operator> <call><name>read_tar_number</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>tarhdr</name><index>[<expr><literal type="number">124</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">12</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

						<expr_stmt><expr><name>padding</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>filesz</name> <operator>+</operator> <literal type="number">511</literal><operator>)</operator> <operator>&amp;</operator> <operator>~</operator><literal type="number">511</literal><operator>)</operator> <operator>-</operator> <name>filesz</name></expr>;</expr_stmt>
						<expr_stmt><expr><name>filesz</name> <operator>+=</operator> <name>padding</name></expr>;</expr_stmt>

						<comment type="block">/* Next part is the file, not the header */</comment>
						<expr_stmt><expr><name>in_tarhdr</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

						<comment type="block">/*
						 * POLAR:
						 * In order to make these two basetablespaces into one,
						 * we append polar tar streaming to the tail of non-polar
						 * tar streaming. In case of polar_datadir path was missing,
						 * we need to add one dir tar head to create polar_datadir which
						 * is default set to POLAR_SHARED_DATA.
						 * Besides, we need to change every file or directory's tar header
						 * to make path correct. The max length of path is 100 bytes.
						 */</comment>
						<if_stmt><if>if <condition>(<expr><name>polar_data</name></expr>)</condition>
						<block>{<block_content>
							<if_stmt><if>if <condition>(<expr><operator>!</operator><name>polar_create_shared_datadir</name></expr>)</condition>
							<block>{<block_content>
								<decl_stmt><decl><type><name>char</name></type>		<name><name>header</name><index>[<expr><literal type="number">512</literal></expr>]</index></name></decl>;</decl_stmt>
								<expr_stmt><expr><call><name>tarCreateHeader</name><argument_list>(<argument><expr><name>header</name></expr></argument>, <argument><expr><name>POLAR_TAR_NAME_PREFIX</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
												<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>S_IFDIR</name> <operator>|</operator> <name>pg_dir_create_mode</name></expr></argument>, <argument><expr><literal type="number">04000</literal></expr></argument>, <argument><expr><literal type="number">02000</literal></expr></argument>,
												<argument><expr><call><name>time</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
								<expr_stmt><expr><call><name>WRITE_TAR_DATA</name><argument_list>(<argument><expr><name>header</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>header</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
								<expr_stmt><expr><name>polar_create_shared_datadir</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
							</block_content>}</block></if></if_stmt>
							<comment type="block">/* POLAR: POLAR_TAR_NAME_PREFIX + "/" + &amp;tarhdr[0] is the true path. */</comment>
							<if_stmt><if>if <condition>(<expr><call><name>strlen</name><argument_list>(<argument><expr><name>POLAR_TAR_NAME_PREFIX</name></expr></argument>)</argument_list></call> <operator>+</operator> <call><name>strlen</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>tarhdr</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal> <operator>&gt;=</operator> <name>POLAR_TAR_NAME_MAX_LEN</name></expr>)</condition>
							<block>{<block_content>
								<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: Polar tar name is too long: %s%s(%zu)"</literal></expr></argument>)</argument_list></call></expr></argument>,
										<argument><expr><name>progname</name></expr></argument>, <argument><expr><name>POLAR_TAR_NAME_PREFIX</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>tarhdr</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,
										<argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>POLAR_TAR_NAME_PREFIX</name></expr></argument>)</argument_list></call> <operator>+</operator> <call><name>strlen</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>tarhdr</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
								<expr_stmt><expr><call><name>disconnect_and_exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							</block_content>}</block></if>
							<else>else
							<block>{<block_content>
								<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>polar_file_name</name></expr></argument>, <argument><expr><literal type="number">0x0</literal></expr></argument>, <argument><expr><name>POLAR_TAR_NAME_MAX_LEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
								<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>polar_file_name</name></expr></argument>, <argument><expr><name>POLAR_TAR_NAME_MAX_LEN</name></expr></argument>,
										 <argument><expr><literal type="string">"%s/%s"</literal></expr></argument>, <argument><expr><name>POLAR_TAR_NAME_PREFIX</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>tarhdr</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
								<expr_stmt><expr><call><name>strlcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>tarhdr</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name>polar_file_name</name></expr></argument>, <argument><expr><name>POLAR_TAR_NAME_MAX_LEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
								<expr_stmt><expr><call><name>print_tar_number</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>tarhdr</name><index>[<expr><literal type="number">148</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>, <argument><expr><call><name>tarChecksum</name><argument_list>(<argument><expr><name>tarhdr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							</block_content>}</block></else></if_stmt>
						</block_content>}</block></if></if_stmt>

						<comment type="block">/*
						 * If we're not skipping the file, write the tar
						 * header unmodified.
						 */</comment>
						<if_stmt><if>if <condition>(<expr><operator>!</operator><name>skip_file</name></expr>)</condition><block type="pseudo"><block_content>
							<expr_stmt><expr><call><name>WRITE_TAR_DATA</name><argument_list>(<argument><expr><name>tarhdr</name></expr></argument>, <argument><expr><literal type="number">512</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
					</block_content>}</block></else></if_stmt>
				</block_content>}</block></if>
				<else>else
				<block>{<block_content>
					<comment type="block">/*
					 * We're processing a file's contents.
					 */</comment>
					<if_stmt><if>if <condition>(<expr><name>filesz</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
					<block>{<block_content>
						<comment type="block">/*
						 * We still have data to read (and possibly write).
						 */</comment>
						<decl_stmt><decl><type><name>int</name></type>			<name>bytes2write</name></decl>;</decl_stmt>

						<expr_stmt><expr><name>bytes2write</name> <operator>=</operator> <operator>(</operator><ternary><condition><expr><name>filesz</name> <operator>&gt;</operator> <name>rr</name></expr> ?</condition><then> <expr><name>rr</name></expr> </then><else>: <expr><name>filesz</name></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>

						<if_stmt><if>if <condition>(<expr><operator>!</operator><name>skip_file</name></expr>)</condition><block type="pseudo"><block_content>
							<expr_stmt><expr><call><name>WRITE_TAR_DATA</name><argument_list>(<argument><expr><name>copybuf</name> <operator>+</operator> <name>pos</name></expr></argument>, <argument><expr><name>bytes2write</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

						<expr_stmt><expr><name>rr</name> <operator>-=</operator> <name>bytes2write</name></expr>;</expr_stmt>
						<expr_stmt><expr><name>pos</name> <operator>+=</operator> <name>bytes2write</name></expr>;</expr_stmt>
						<expr_stmt><expr><name>filesz</name> <operator>-=</operator> <name>bytes2write</name></expr>;</expr_stmt>
					</block_content>}</block></if>
					<else>else
					<block>{<block_content>
						<comment type="block">/*
						 * No more data in the current file, the next piece of
						 * data (if any) will be a new file header structure.
						 */</comment>
						<expr_stmt><expr><name>in_tarhdr</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
						<expr_stmt><expr><name>skip_file</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
						<expr_stmt><expr><name>tarhdrsz</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
						<expr_stmt><expr><name>filesz</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
					</block_content>}</block></else></if_stmt>
				</block_content>}</block></else></if_stmt>
			</block_content>}</block></while>
		</block_content>}</block></else></if_stmt>
		<expr_stmt><expr><name>totaldone</name> <operator>+=</operator> <name>r</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>progress_report</name><argument_list>(<argument><expr><name>rownum</name></expr></argument>, <argument><expr><name>filename</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></while>							<comment type="block">/* while (1) */</comment>
	<expr_stmt><expr><call><name>progress_report</name><argument_list>(<argument><expr><name>rownum</name></expr></argument>, <argument><expr><name>filename</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>copybuf</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PQfreemem</name><argument_list>(<argument><expr><name>copybuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Do not sync the resulting tar file yet, all files are synced once at
	 * the end.
	 */</comment>
</block_content>}</block></function>


<comment type="block">/*
 * Retrieve tablespace path, either relocated or original depending on whether
 * -T was passed or not.
 */</comment>
<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>
<name>get_tablespace_mapping</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>dir</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TablespaceListCell</name> <modifier>*</modifier></type><name>cell</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>canon_dir</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name></decl>;</decl_stmt>

	<comment type="block">/* Canonicalize path for comparison consistency */</comment>
	<expr_stmt><expr><call><name>strlcpy</name><argument_list>(<argument><expr><name>canon_dir</name></expr></argument>, <argument><expr><name>dir</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>canon_dir</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>canonicalize_path</name><argument_list>(<argument><expr><name>canon_dir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>cell</name> <operator>=</operator> <name><name>tablespace_dirs</name><operator>.</operator><name>head</name></name></expr>;</init> <condition><expr><name>cell</name></expr>;</condition> <incr><expr><name>cell</name> <operator>=</operator> <name><name>cell</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control><block type="pseudo"><block_content>
		<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>canon_dir</name></expr></argument>, <argument><expr><name><name>cell</name><operator>-&gt;</operator><name>old_dir</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name><name>cell</name><operator>-&gt;</operator><name>new_dir</name></name></expr>;</return></block_content></block></if></if_stmt></block_content></block></for>

	<return>return <expr><name>dir</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * Receive a tar format stream from the connection to the server, and unpack
 * the contents of it into a directory. Only files, directories and
 * symlinks are supported, no other kinds of special files.
 *
 * If the data is for the main data directory, it will be restored in the
 * specified directory. If it's for another tablespace, it will be restored
 * in the original or mapped directory.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ReceiveAndUnpackTarFile</name><parameter_list>(<parameter><decl><type><name>PGconn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>, <parameter><decl><type><name>PGresult</name> <modifier>*</modifier></type><name>res</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>rownum</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>current_path</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>filename</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>mapped_tblspc_path</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>pgoff_t</name></type>		<name>current_len_left</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>current_padding</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>basetablespace</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> 		<name>polar_data</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>need_pfs</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>copybuf</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>fd</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>basetablespace</name> <operator>=</operator> <call><name>PQgetisnull</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>rownum</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>polar_data</name> <operator>=</operator> <operator>!</operator><call><name>PQgetisnull</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>rownum</name></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>basetablespace</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>polar_data</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>strlcpy</name><argument_list>(<argument><expr><name>current_path</name></expr></argument>, <argument><expr><name>datadir</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>current_path</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>strlcpy</name><argument_list>(<argument><expr><name>current_path</name></expr></argument>, <argument><expr><name>basedir</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>current_path</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>strlcpy</name><argument_list>(<argument><expr><name>current_path</name></expr></argument>,
				<argument><expr><call><name>get_tablespace_mapping</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>rownum</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
				<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>current_path</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<expr_stmt><expr><name>need_pfs</name> <operator>=</operator> <name>polar_data</name> <operator>&amp;&amp;</operator> <name>is_pfs_mode</name></expr>;</expr_stmt>
	<comment type="block">/*
	 * Get the COPY data
	 */</comment>
	<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>PQgetResult</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>PQresultStatus</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>PGRES_COPY_OUT</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: could not get COPY data stream: %s"</literal></expr></argument>)</argument_list></call></expr></argument>,
				<argument><expr><name>progname</name></expr></argument>, <argument><expr><call><name>PQerrorMessage</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>disconnect_and_exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<while>while <condition>(<expr><literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>r</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>copybuf</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>PQfreemem</name><argument_list>(<argument><expr><name>copybuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>copybuf</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>PQgetCopyData</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>copybuf</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>r</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * End of chunk
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name>fd</name> <operator>&gt;</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>polar_close</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name>need_pfs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<break>break;</break>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name>r</name> <operator>==</operator> <operator>-</operator><literal type="number">2</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: could not read COPY data: %s"</literal></expr></argument>)</argument_list></call></expr></argument>,
					<argument><expr><name>progname</name></expr></argument>, <argument><expr><call><name>PQerrorMessage</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>disconnect_and_exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>fd</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>int</name></type>			<name>filemode</name></decl>;</decl_stmt>

			<comment type="block">/*
			 * No current file, so this must be the header for a new file
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name>r</name> <operator>!=</operator> <literal type="number">512</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: invalid tar block header size: %d\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
						<argument><expr><name>progname</name></expr></argument>, <argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>disconnect_and_exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			<expr_stmt><expr><name>totaldone</name> <operator>+=</operator> <literal type="number">512</literal></expr>;</expr_stmt>

			<expr_stmt><expr><name>current_len_left</name> <operator>=</operator> <call><name>read_tar_number</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>copybuf</name><index>[<expr><literal type="number">124</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">12</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* Set permissions on the file */</comment>
			<expr_stmt><expr><name>filemode</name> <operator>=</operator> <call><name>read_tar_number</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>copybuf</name><index>[<expr><literal type="number">100</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * All files are padded up to 512 bytes
			 */</comment>
			<expr_stmt><expr><name>current_padding</name> <operator>=</operator>
				<operator>(</operator><operator>(</operator><name>current_len_left</name> <operator>+</operator> <literal type="number">511</literal><operator>)</operator> <operator>&amp;</operator> <operator>~</operator><literal type="number">511</literal><operator>)</operator> <operator>-</operator> <name>current_len_left</name></expr>;</expr_stmt>

			<comment type="block">/*
			 * First part of header is zero terminated filename
			 */</comment>
			<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>filename</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>filename</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"%s/%s"</literal></expr></argument>, <argument><expr><name>current_path</name></expr></argument>,
					 <argument><expr><name>copybuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>filename</name><index>[<expr><call><name>strlen</name><argument_list>(<argument><expr><name>filename</name></expr></argument>)</argument_list></call> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'/'</literal></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/*
				 * Ends in a slash means directory or symlink to directory
				 */</comment>
				<if_stmt><if>if <condition>(<expr><name><name>copybuf</name><index>[<expr><literal type="number">156</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'5'</literal></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/*
					 * Directory
					 */</comment>
					<expr_stmt><expr><name><name>filename</name><index>[<expr><call><name>strlen</name><argument_list>(<argument><expr><name>filename</name></expr></argument>)</argument_list></call> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>	<comment type="block">/* Remove trailing slash */</comment>
					<if_stmt><if>if <condition>(<expr><call><name>polar_mkdir</name><argument_list>(<argument><expr><name>filename</name></expr></argument>, <argument><expr><name>pg_dir_create_mode</name></expr></argument>, <argument><expr><name>need_pfs</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
					<block>{<block_content>
						<comment type="block">/*
						 * When streaming WAL, pg_wal (or pg_xlog for pre-9.6
						 * clusters) will have been created by the wal
						 * receiver process. Also, when the WAL directory
						 * location was specified, pg_wal (or pg_xlog) has
						 * already been created as a symbolic link before
						 * starting the actual backup. So just ignore creation
						 * failures on related directories.
						 */</comment>
						<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><operator>(</operator><call><name>pg_str_endswith</name><argument_list>(<argument><expr><name>filename</name></expr></argument>, <argument><expr><literal type="string">"/pg_wal"</literal></expr></argument>)</argument_list></call> <operator>||</operator>
							   <call><name>pg_str_endswith</name><argument_list>(<argument><expr><name>filename</name></expr></argument>, <argument><expr><literal type="string">"/pg_xlog"</literal></expr></argument>)</argument_list></call> <operator>||</operator>
							   <call><name>pg_str_endswith</name><argument_list>(<argument><expr><name>filename</name></expr></argument>, <argument><expr><literal type="string">"/archive_status"</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>&amp;&amp;</operator>
							  <name>errno</name> <operator>==</operator> <name>EEXIST</name><operator>)</operator></expr>)</condition>
						<block>{<block_content>
							<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>,
									<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: could not create directory \"%s\": %s\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
									<argument><expr><name>progname</name></expr></argument>, <argument><expr><name>filename</name></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							<expr_stmt><expr><call><name>disconnect_and_exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						</block_content>}</block></if></if_stmt>
					</block_content>}</block></if></if_stmt>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>WIN32</name></cpp:ifndef>
					<if_stmt><if>if <condition>(<expr><call><name>polar_chmod</name><argument_list>(<argument><expr><name>filename</name></expr></argument>, <argument><expr><operator>(</operator><name>mode_t</name><operator>)</operator> <name>filemode</name></expr></argument>, <argument><expr><name>need_pfs</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>,
								<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: could not set permissions on directory \"%s\": %s\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
								<argument><expr><name>progname</name></expr></argument>, <argument><expr><name>filename</name></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
				</block_content>}</block></if>
				<if type="elseif">else if <condition>(<expr><name><name>copybuf</name><index>[<expr><literal type="number">156</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'2'</literal></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/*
					 * Symbolic link
					 *
					 * It's most likely a link in pg_tblspc directory, to the
					 * location of a tablespace. Apply any tablespace mapping
					 * given on the command line (--tablespace-mapping). (We
					 * blindly apply the mapping without checking that the
					 * link really is inside pg_tblspc. We don't expect there
					 * to be other symlinks in a data directory, but if there
					 * are, you can call it an undocumented feature that you
					 * can map them too.)
					 */</comment>
					<expr_stmt><expr><name><name>filename</name><index>[<expr><call><name>strlen</name><argument_list>(<argument><expr><name>filename</name></expr></argument>)</argument_list></call> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>	<comment type="block">/* Remove trailing slash */</comment>

					<expr_stmt><expr><name>mapped_tblspc_path</name> <operator>=</operator> <call><name>get_tablespace_mapping</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>copybuf</name><index>[<expr><literal type="number">157</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<if_stmt><if>if <condition>(<expr><call><name>symlink</name><argument_list>(<argument><expr><name>mapped_tblspc_path</name></expr></argument>, <argument><expr><name>filename</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>,
								<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: could not create symbolic link from \"%s\" to \"%s\": %s\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
								<argument><expr><name>progname</name></expr></argument>, <argument><expr><name>filename</name></expr></argument>, <argument><expr><name>mapped_tblspc_path</name></expr></argument>,
								<argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><call><name>disconnect_and_exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block></if></if_stmt>
				</block_content>}</block></if>
				<else>else
				<block>{<block_content>
					<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>,
							<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: unrecognized link indicator \"%c\"\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
							<argument><expr><name>progname</name></expr></argument>, <argument><expr><name><name>copybuf</name><index>[<expr><literal type="number">156</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>disconnect_and_exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></else></if_stmt>
				<continue>continue;</continue>		<comment type="block">/* directory or link handled */</comment>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/*
			 * regular file
			 */</comment>
			<expr_stmt><expr><name>fd</name> <operator>=</operator> <call><name>polar_open</name><argument_list>(<argument><expr><name>filename</name></expr></argument>, <argument><expr><name>O_WRONLY</name> <operator>|</operator> <name>O_CREAT</name> <operator>|</operator> <name>PG_BINARY</name></expr></argument>, <argument><expr><name>pg_file_create_mode</name></expr></argument>, <argument><expr><name>need_pfs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>fd</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: could not create file \"%s\": %s\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
						<argument><expr><name>progname</name></expr></argument>, <argument><expr><name>filename</name></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>disconnect_and_exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>WIN32</name></cpp:ifndef>
			<if_stmt><if>if <condition>(<expr><call><name>polar_chmod</name><argument_list>(<argument><expr><name>filename</name></expr></argument>, <argument><expr><operator>(</operator><name>mode_t</name><operator>)</operator> <name>filemode</name></expr></argument>, <argument><expr><name>need_pfs</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: could not set permissions on file \"%s\": %s\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
						<argument><expr><name>progname</name></expr></argument>, <argument><expr><name>filename</name></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

			<if_stmt><if>if <condition>(<expr><name>current_len_left</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/*
				 * Done with this file, next one will be a new tar header
				 */</comment>
				<expr_stmt><expr><call><name>polar_close</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name>need_pfs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>fd</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
				<continue>continue;</continue>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if>						<comment type="block">/* new file */</comment>
		<else>else
		<block>{<block_content>
			<comment type="block">/*
			 * Continuing blocks in existing file
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name>current_len_left</name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>r</name> <operator>==</operator> <name>current_padding</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/*
				 * Received the padding block for this file, ignore it and
				 * close the file, then move on to the next tar header.
				 */</comment>
				<expr_stmt><expr><call><name>polar_close</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name>need_pfs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>fd</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
				<expr_stmt><expr><name>totaldone</name> <operator>+=</operator> <name>r</name></expr>;</expr_stmt>
				<continue>continue;</continue>
			</block_content>}</block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>polar_write</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name>copybuf</name></expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><name>need_pfs</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* if write didn't set errno, assume problem is no disk space */</comment>
				<if_stmt><if>if <condition>(<expr><name>errno</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>errno</name> <operator>=</operator> <name>ENOSPC</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: could not write to file \"%s\": %s\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
						<argument><expr><name>progname</name></expr></argument>, <argument><expr><name>filename</name></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>disconnect_and_exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			<expr_stmt><expr><name>totaldone</name> <operator>+=</operator> <name>r</name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>progress_report</name><argument_list>(<argument><expr><name>rownum</name></expr></argument>, <argument><expr><name>filename</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name>current_len_left</name> <operator>-=</operator> <name>r</name></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>current_len_left</name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>current_padding</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/*
				 * Received the last block, and there is no padding to be
				 * expected. Close the file and move on to the next tar
				 * header.
				 */</comment>
				<expr_stmt><expr><call><name>polar_close</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name>need_pfs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>fd</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
				<continue>continue;</continue>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></else></if_stmt>						<comment type="block">/* continuing data in existing file */</comment>
	</block_content>}</block></while>							<comment type="block">/* loop over all data blocks */</comment>
	<expr_stmt><expr><call><name>progress_report</name><argument_list>(<argument><expr><name>rownum</name></expr></argument>, <argument><expr><name>filename</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>fd</name> <operator>&gt;</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>,
				<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: COPY stream ended before last file was finished\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
				<argument><expr><name>progname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>disconnect_and_exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>copybuf</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PQfreemem</name><argument_list>(<argument><expr><name>copybuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>basetablespace</name> <operator>&amp;&amp;</operator> <name>writerecoveryconf</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>WriteRecoveryConf</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * No data is synced here, everything is done for all tablespaces at the
	 * end.
	 */</comment>
</block_content>}</block></function>

<comment type="block">/*
 * Escape a string so that it can be used as a value in a key-value pair
 * a configuration file.
 */</comment>
<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type>
<name>escape_quotes</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>src</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>result</name> <init>= <expr><call><name>escape_single_quotes_ascii</name><argument_list>(<argument><expr><name>src</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>result</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: out of memory\n"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>progname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Create a recovery.conf file in memory using a PQExpBuffer
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>GenerateRecoveryConf</name><parameter_list>(<parameter><decl><type><name>PGconn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PQconninfoOption</name> <modifier>*</modifier></type><name>connOptions</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PQconninfoOption</name> <modifier>*</modifier></type><name>option</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PQExpBufferData</name></type> <name>conninfo_buf</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>escaped</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>recoveryconfcontents</name> <operator>=</operator> <call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>recoveryconfcontents</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: out of memory\n"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>progname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>disconnect_and_exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>connOptions</name> <operator>=</operator> <call><name>PQconninfo</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>connOptions</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: out of memory\n"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>progname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>disconnect_and_exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>recoveryconfcontents</name></expr></argument>, <argument><expr><literal type="string">"standby_mode = 'on'\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>initPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>conninfo_buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>option</name> <operator>=</operator> <name>connOptions</name></expr>;</init> <condition><expr><name>option</name> <operator>&amp;&amp;</operator> <name><name>option</name><operator>-&gt;</operator><name>keyword</name></name></expr>;</condition> <incr><expr><name>option</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<comment type="block">/*
		 * Do not emit this setting if: - the setting is "replication",
		 * "dbname" or "fallback_application_name", since these would be
		 * overridden by the libpqwalreceiver module anyway. - not set or
		 * empty.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>option</name><operator>-&gt;</operator><name>keyword</name></name></expr></argument>, <argument><expr><literal type="string">"replication"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
			<call><name>strcmp</name><argument_list>(<argument><expr><name><name>option</name><operator>-&gt;</operator><name>keyword</name></name></expr></argument>, <argument><expr><literal type="string">"dbname"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
			<call><name>strcmp</name><argument_list>(<argument><expr><name><name>option</name><operator>-&gt;</operator><name>keyword</name></name></expr></argument>, <argument><expr><literal type="string">"fallback_application_name"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
			<operator>(</operator><name><name>option</name><operator>-&gt;</operator><name>val</name></name> <operator>==</operator> <name>NULL</name><operator>)</operator> <operator>||</operator>
			<operator>(</operator><name><name>option</name><operator>-&gt;</operator><name>val</name></name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name><name>option</name><operator>-&gt;</operator><name>val</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'\0'</literal><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<comment type="block">/* Separate key-value pairs with spaces */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>conninfo_buf</name><operator>.</operator><name>len</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendPQExpBufferChar</name><argument_list>(<argument><expr><operator>&amp;</operator><name>conninfo_buf</name></expr></argument>, <argument><expr><literal type="char">' '</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * Write "keyword=value" pieces, the value string is escaped and/or
		 * quoted if necessary.
		 */</comment>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>conninfo_buf</name></expr></argument>, <argument><expr><literal type="string">"%s="</literal></expr></argument>, <argument><expr><name><name>option</name><operator>-&gt;</operator><name>keyword</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>appendConnStrVal</name><argument_list>(<argument><expr><operator>&amp;</operator><name>conninfo_buf</name></expr></argument>, <argument><expr><name><name>option</name><operator>-&gt;</operator><name>val</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<comment type="block">/*
	 * Escape the connection string, so that it can be put in the config file.
	 * Note that this is different from the escaping of individual connection
	 * options above!
	 */</comment>
	<expr_stmt><expr><name>escaped</name> <operator>=</operator> <call><name>escape_quotes</name><argument_list>(<argument><expr><name><name>conninfo_buf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>recoveryconfcontents</name></expr></argument>, <argument><expr><literal type="string">"primary_conninfo = '%s'\n"</literal></expr></argument>, <argument><expr><name>escaped</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>escaped</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>replication_slot</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* unescaped: ReplicationSlotValidateName allows [a-z0-9_] only */</comment>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>recoveryconfcontents</name></expr></argument>, <argument><expr><literal type="string">"primary_slot_name = '%s'\n"</literal></expr></argument>,
						  <argument><expr><name>replication_slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>PQExpBufferBroken</name><argument_list>(<argument><expr><name>recoveryconfcontents</name></expr></argument>)</argument_list></call> <operator>||</operator>
		<call><name>PQExpBufferDataBroken</name><argument_list>(<argument><expr><name>conninfo_buf</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: out of memory\n"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>progname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>disconnect_and_exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>termPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>conninfo_buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PQconninfoFree</name><argument_list>(<argument><expr><name>connOptions</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * Write a recovery.conf file into the directory specified in basedir,
 * with the contents already collected in memory.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>WriteRecoveryConf</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>filename</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>FILE</name>	   <modifier>*</modifier></type><name>cf</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>filename</name></expr></argument>, <argument><expr><literal type="string">"%s/recovery.conf"</literal></expr></argument>, <argument><expr><name>basedir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>cf</name> <operator>=</operator> <call><name>fopen</name><argument_list>(<argument><expr><name>filename</name></expr></argument>, <argument><expr><literal type="string">"w"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>cf</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: could not create file \"%s\": %s\n"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>progname</name></expr></argument>, <argument><expr><name>filename</name></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>disconnect_and_exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>fwrite</name><argument_list>(<argument><expr><name><name>recoveryconfcontents</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name><name>recoveryconfcontents</name><operator>-&gt;</operator><name>len</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>cf</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>,
				<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: could not write to file \"%s\": %s\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
				<argument><expr><name>progname</name></expr></argument>, <argument><expr><name>filename</name></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>disconnect_and_exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>fclose</name><argument_list>(<argument><expr><name>cf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>void</name></type>
<name>BaseBackup</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>sysidentifier</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TimeLineID</name></type>	<name>latesttli</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TimeLineID</name></type>	<name>starttli</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>basebkp</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>escaped_label</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>maxrate_clause</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>xlogstart</name><index>[<expr><literal type="number">64</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>xlogend</name><index>[<expr><literal type="number">64</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>minServerMajor</name></decl>,
				<decl><type ref="prev"/><name>maxServerMajor</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>serverVersion</name></decl>,
				<decl><type ref="prev"/><name>serverMajor</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>conn</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Check server version. BASE_BACKUP command was introduced in 9.1, so we
	 * can't work with servers older than 9.1.
	 */</comment>
	<expr_stmt><expr><name>minServerMajor</name> <operator>=</operator> <literal type="number">901</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>maxServerMajor</name> <operator>=</operator> <name>PG_VERSION_NUM</name> <operator>/</operator> <literal type="number">100</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>serverVersion</name> <operator>=</operator> <call><name>PQserverVersion</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>serverMajor</name> <operator>=</operator> <name>serverVersion</name> <operator>/</operator> <literal type="number">100</literal></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>serverMajor</name> <argument_list type="generic">&lt; <argument><expr><name>minServerMajor</name> <operator>||</operator> <name>serverMajor</name></expr></argument> &gt;</argument_list></name> <name>maxServerMajor</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>serverver</name> <init>= <expr><call><name>PQparameterStatus</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><literal type="string">"server_version"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: incompatible server version %s\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
				<argument><expr><name>progname</name></expr></argument>, <argument><expr><ternary><condition><expr><name>serverver</name></expr> ?</condition><then> <expr><name>serverver</name></expr> </then><else>: <expr><literal type="string">"'unknown'"</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>disconnect_and_exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * If WAL streaming was requested, also check that the server is new
	 * enough for that.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>includewal</name> <operator>==</operator> <name>STREAM_WAL</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>CheckServerVersionForStreaming</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Error message already written in CheckServerVersionForStreaming(),
		 * but add a hint about using -X none.
		 */</comment>
		<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"HINT: use -X none or -X fetch to disable log streaming\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>disconnect_and_exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Build contents of recovery.conf if requested
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>writerecoveryconf</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>GenerateRecoveryConf</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Run IDENTIFY_SYSTEM so we can get the timeline
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>RunIdentifySystem</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sysidentifier</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>latesttli</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>disconnect_and_exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Start the actual backup
	 */</comment>
	<expr_stmt><expr><call><name>PQescapeStringConn</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>escaped_label</name></expr></argument>, <argument><expr><name>label</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>escaped_label</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><operator>&amp;</operator><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>maxrate</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>maxrate_clause</name> <operator>=</operator> <call><name>psprintf</name><argument_list>(<argument><expr><literal type="string">"MAX_RATE %u"</literal></expr></argument>, <argument><expr><name>maxrate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>verbose</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>,
				<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: initiating base backup, waiting for checkpoint to complete\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
				<argument><expr><name>progname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>showprogress</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>verbose</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"waiting for checkpoint"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>isatty</name><argument_list>(<argument><expr><call><name>fileno</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"\r"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>basebkp</name> <operator>=</operator>
		<call><name>psprintf</name><argument_list>(<argument><expr><literal type="string">"BASE_BACKUP LABEL '%s' %s %s %s %s %s %s %s"</literal></expr></argument>,
				 <argument><expr><name>escaped_label</name></expr></argument>,
				 <argument><expr><ternary><condition><expr><name>showprogress</name></expr> ?</condition><then> <expr><literal type="string">"PROGRESS"</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>,
				 <argument><expr><ternary><condition><expr><name>includewal</name> <operator>==</operator> <name>FETCH_WAL</name></expr> ?</condition><then> <expr><literal type="string">"WAL"</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>,
				 <argument><expr><ternary><condition><expr><name>fastcheckpoint</name></expr> ?</condition><then> <expr><literal type="string">"FAST"</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>,
				 <argument><expr><ternary><condition><expr><name>includewal</name> <operator>==</operator> <name>NO_WAL</name></expr> ?</condition><then> <expr><literal type="string">""</literal></expr> </then><else>: <expr><literal type="string">"NOWAIT"</literal></expr></else></ternary></expr></argument>,
				 <argument><expr><ternary><condition><expr><name>maxrate_clause</name></expr> ?</condition><then> <expr><name>maxrate_clause</name></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>,
				 <argument><expr><ternary><condition><expr><name>format</name> <operator>==</operator> <literal type="char">'t'</literal></expr> ?</condition><then> <expr><literal type="string">"TABLESPACE_MAP"</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>,
				 <argument><expr><ternary><condition><expr><name>verify_checksums</name></expr> ?</condition><then> <expr><literal type="string">""</literal></expr> </then><else>: <expr><literal type="string">"NOVERIFY_CHECKSUMS"</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>PQsendQuery</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>basebkp</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: could not send replication command \"%s\": %s"</literal></expr></argument>)</argument_list></call></expr></argument>,
				<argument><expr><name>progname</name></expr></argument>, <argument><expr><literal type="string">"BASE_BACKUP"</literal></expr></argument>, <argument><expr><call><name>PQerrorMessage</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>disconnect_and_exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Get the starting WAL location
	 */</comment>
	<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>PQgetResult</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>PQresultStatus</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>PGRES_TUPLES_OK</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: could not initiate base backup: %s"</literal></expr></argument>)</argument_list></call></expr></argument>,
				<argument><expr><name>progname</name></expr></argument>, <argument><expr><call><name>PQerrorMessage</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>disconnect_and_exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>PQntuples</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>,
				<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: server returned unexpected response to BASE_BACKUP command; got %d rows and %d fields, expected %d rows and %d fields\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
				<argument><expr><name>progname</name></expr></argument>, <argument><expr><call><name>PQntuples</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>PQnfields</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>disconnect_and_exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>strlcpy</name><argument_list>(<argument><expr><name>xlogstart</name></expr></argument>, <argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>xlogstart</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>verbose</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: checkpoint completed\n"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>progname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * 9.3 and later sends the TLI of the starting point. With older servers,
	 * assume it's the same as the latest timeline reported by
	 * IDENTIFY_SYSTEM.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>PQnfields</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <literal type="number">2</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>starttli</name> <operator>=</operator> <call><name>atoi</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>starttli</name> <operator>=</operator> <name>latesttli</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
	<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><name>xlogend</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>xlogend</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>verbose</name> <operator>&amp;&amp;</operator> <name>includewal</name> <operator>!=</operator> <name>NO_WAL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: write-ahead log start point: %s on timeline %u\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
				<argument><expr><name>progname</name></expr></argument>, <argument><expr><name>xlogstart</name></expr></argument>, <argument><expr><name>starttli</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Get the header
	 */</comment>
	<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>PQgetResult</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>PQresultStatus</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>PGRES_TUPLES_OK</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: could not get backup header: %s"</literal></expr></argument>)</argument_list></call></expr></argument>,
				<argument><expr><name>progname</name></expr></argument>, <argument><expr><call><name>PQerrorMessage</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>disconnect_and_exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>PQntuples</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: no data returned from server\n"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>progname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>disconnect_and_exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Sum up the total size, for progress reporting
	 */</comment>
	<expr_stmt><expr><name>totalsize</name> <operator>=</operator> <name>totaldone</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>tablespacecount</name> <operator>=</operator> <call><name>PQntuples</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <call><name>PQntuples</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><name>totalsize</name> <operator>+=</operator> <call><name>atol</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Verify tablespace directories are empty. Don't bother with the
		 * first once since it can be relocated, and it will be checked before
		 * we do anything anyway.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>format</name> <operator>==</operator> <literal type="char">'p'</literal> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>PQgetisnull</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>path</name> <init>= <expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>get_tablespace_mapping</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>verify_dir_is_empty_or_create</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>made_tablespace_dirs</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>found_tablespace_dirs</name></expr></argument>, <argument><expr><name>is_pfs_mode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>PQgetisnull</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>is_polar_mode</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* In pfs mode, you must specify polardata. */</comment>
				<if_stmt><if>if <condition>(<expr><name>is_pfs_mode</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: In pfs mode, polardata cannot be empty.\n"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>progname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>disconnect_and_exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if>
				<else>else
				<block>{<block_content>
					<comment type="block">/* If polardata is not specified, the default value is ./POLAR_SHARED_DATA */</comment>
					<decl_stmt><decl><type><name>char</name></type> <name><name>tmpdata</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name></decl>;</decl_stmt>
					<expr_stmt><expr><name>is_polar_mode</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>tmpdata</name></expr></argument>, <argument><expr><literal type="string">"%s/%s"</literal></expr></argument>, <argument><expr><name>basedir</name></expr></argument>, <argument><expr><name>POLAR_SHARED_DATA</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>datadir</name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><name>tmpdata</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<if_stmt><if>if <condition>(<expr><name>format</name> <operator>==</operator> <literal type="char">'p'</literal></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>verify_dir_is_empty_or_create</name><argument_list>(<argument><expr><name>datadir</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>made_new_pgdata</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>found_existing_poalrdata</name></expr></argument>, <argument><expr><name>is_pfs_mode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				</block_content>}</block></else></if_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>

	<comment type="block">/*
	 * When writing to stdout, require a single tablespace
	 *
	 * POLAR:
	 * There are two basetablespaces when server is in polar mode. But we will
	 * combine these two basetablespaces into one.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>format</name> <operator>==</operator> <literal type="char">'t'</literal> <operator>&amp;&amp;</operator> <call><name>strcmp</name><argument_list>(<argument><expr><name>basedir</name></expr></argument>, <argument><expr><literal type="string">"-"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <call><name>PQntuples</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <operator>!</operator><name>is_polar_mode</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>,
				<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: can only write single tablespace to stdout, database has %d\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
				<argument><expr><name>progname</name></expr></argument>, <argument><expr><call><name>PQntuples</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>disconnect_and_exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * If we're streaming WAL, start the streaming session before we start
	 * receiving the actual data chunks.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>includewal</name> <operator>==</operator> <name>STREAM_WAL</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>verbose</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: starting background WAL receiver\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
					<argument><expr><name>progname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>StartLogStreamer</name><argument_list>(<argument><expr><name>xlogstart</name></expr></argument>, <argument><expr><name>starttli</name></expr></argument>, <argument><expr><name>sysidentifier</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Start receiving chunks
	 */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <call><name>PQntuples</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>format</name> <operator>==</operator> <literal type="char">'t'</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ReceiveTarFile</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ReceiveAndUnpackTarFile</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></for>							<comment type="block">/* Loop over all tablespaces */</comment>

	<if_stmt><if>if <condition>(<expr><name>showprogress</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>progress_report</name><argument_list>(<argument><expr><call><name>PQntuples</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>isatty</name><argument_list>(<argument><expr><call><name>fileno</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>	<comment type="block">/* Need to move to next line */</comment>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Get the stop position
	 */</comment>
	<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>PQgetResult</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>PQresultStatus</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>PGRES_TUPLES_OK</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>,
				<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: could not get write-ahead log end position from server: %s"</literal></expr></argument>)</argument_list></call></expr></argument>,
				<argument><expr><name>progname</name></expr></argument>, <argument><expr><call><name>PQerrorMessage</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>disconnect_and_exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>PQntuples</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>,
				<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: no write-ahead log end position returned from server\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
				<argument><expr><name>progname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>disconnect_and_exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>strlcpy</name><argument_list>(<argument><expr><name>xlogend</name></expr></argument>, <argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>xlogend</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>verbose</name> <operator>&amp;&amp;</operator> <name>includewal</name> <operator>!=</operator> <name>NO_WAL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: write-ahead log end point: %s\n"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>progname</name></expr></argument>, <argument><expr><name>xlogend</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>PQgetResult</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>PQresultStatus</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>PGRES_COMMAND_OK</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>sqlstate</name> <init>= <expr><call><name>PQresultErrorField</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>PG_DIAG_SQLSTATE</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>sqlstate</name> <operator>&amp;&amp;</operator>
			<call><name>strcmp</name><argument_list>(<argument><expr><name>sqlstate</name></expr></argument>, <argument><expr><name>ERRCODE_DATA_CORRUPTED</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: checksum error occurred\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
					<argument><expr><name>progname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>checksum_failure</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: final receive failed: %s"</literal></expr></argument>)</argument_list></call></expr></argument>,
					<argument><expr><name>progname</name></expr></argument>, <argument><expr><call><name>PQerrorMessage</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
		<expr_stmt><expr><call><name>disconnect_and_exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>bgchild</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>WIN32</name></cpp:ifndef>
		<decl_stmt><decl><type><name>int</name></type>			<name>status</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>pid_t</name></type>		<name>r</name></decl>;</decl_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
		<decl_stmt><decl><type><name>DWORD</name></type>		<name>status</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * get a pointer sized version of bgchild to avoid warnings about
		 * casting to a different size on WIN64.
		 */</comment>
		<decl_stmt><decl><type><name>intptr_t</name></type>	<name>bgchild_handle</name> <init>= <expr><name>bgchild</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>uint32</name></type>		<name>hi</name></decl>,
					<decl><type ref="prev"/><name>lo</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

		<if_stmt><if>if <condition>(<expr><name>verbose</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>,
					<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: waiting for background process to finish streaming ...\n"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>progname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>WIN32</name></cpp:ifndef>
		<if_stmt><if>if <condition>(<expr><call><name>write</name><argument_list>(<argument><expr><name><name>bgpipe</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name>xlogend</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>xlogend</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>!=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>xlogend</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>,
					<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: could not send command to background pipe: %s\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
					<argument><expr><name>progname</name></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>disconnect_and_exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* Just wait for the background process to exit */</comment>
		<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>waitpid</name><argument_list>(<argument><expr><name>bgchild</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>status</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>r</name> <operator>==</operator> <operator>(</operator><name>pid_t</name><operator>)</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: could not wait for child process: %s\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
					<argument><expr><name>progname</name></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>disconnect_and_exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name>r</name> <operator>!=</operator> <name>bgchild</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: child %d died, expected %d\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
					<argument><expr><name>progname</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name>r</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name>bgchild</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>disconnect_and_exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name>status</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"%s: %s\n"</literal></expr></argument>,
					<argument><expr><name>progname</name></expr></argument>, <argument><expr><call><name>wait_result_to_str</name><argument_list>(<argument><expr><name>status</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>disconnect_and_exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<comment type="block">/* Exited normally, we're happy! */</comment>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>							<comment type="block">/* WIN32 */</comment>

		<comment type="block">/*
		 * On Windows, since we are in the same process, we can just store the
		 * value directly in the variable, and then set the flag that says
		 * it's there.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>sscanf</name><argument_list>(<argument><expr><name>xlogend</name></expr></argument>, <argument><expr><literal type="string">"%X/%X"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>hi</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>lo</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">2</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>,
					<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: could not parse write-ahead log location \"%s\"\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
					<argument><expr><name>progname</name></expr></argument>, <argument><expr><name>xlogend</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>disconnect_and_exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><name>xlogendptr</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>uint64</name><operator>)</operator> <name>hi</name><operator>)</operator> <operator>&lt;&lt;</operator> <literal type="number">32</literal> <operator>|</operator> <name>lo</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>InterlockedIncrement</name><argument_list>(<argument><expr><operator>&amp;</operator><name>has_xlogendptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* First wait for the thread to exit */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>WaitForSingleObjectEx</name><argument_list>(<argument><expr><operator>(</operator><name>HANDLE</name><operator>)</operator> <name>bgchild_handle</name></expr></argument>, <argument><expr><name>INFINITE</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>)</argument_list></call> <operator>!=</operator>
			<name>WAIT_OBJECT_0</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>_dosmaperr</name><argument_list>(<argument><expr><call><name>GetLastError</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: could not wait for child thread: %s\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
					<argument><expr><name>progname</name></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>disconnect_and_exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>GetExitCodeThread</name><argument_list>(<argument><expr><operator>(</operator><name>HANDLE</name><operator>)</operator> <name>bgchild_handle</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>status</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>_dosmaperr</name><argument_list>(<argument><expr><call><name>GetLastError</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: could not get child thread exit status: %s\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
					<argument><expr><name>progname</name></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>disconnect_and_exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name>status</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: child thread exited with error %u\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
					<argument><expr><name>progname</name></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name> <name>int</name><operator>)</operator> <name>status</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>disconnect_and_exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<comment type="block">/* Exited normally, we're happy */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Free the recovery.conf contents */</comment>
	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>recoveryconfcontents</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * End of copy data. Final result is already checked inside the loop.
	 */</comment>
	<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PQfinish</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Make data persistent on disk once backup is completed. For tar format
	 * sync the parent directory and all its contents as each tar file was not
	 * synced after being completed.  In plain format, all the data of the
	 * base directory is synced, taking into account all the tablespaces.
	 * Errors are not considered fatal.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>do_sync</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>format</name> <operator>==</operator> <literal type="char">'t'</literal></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>basedir</name></expr></argument>, <argument><expr><literal type="string">"-"</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>fsync_dir_recurse</name><argument_list>(<argument><expr><name>basedir</name></expr></argument>, <argument><expr><name>progname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>is_polar_mode</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>polar_fsync_pgdata</name><argument_list>(<argument><expr><name>basedir</name></expr></argument>, <argument><expr><name>progname</name></expr></argument>, <argument><expr><name>serverVersion</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><name>is_pfs_mode</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>polar_fsync_pgdata</name><argument_list>(<argument><expr><name>datadir</name></expr></argument>, <argument><expr><name>progname</name></expr></argument>, <argument><expr><name>serverVersion</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>fsync_pgdata</name><argument_list>(<argument><expr><name>basedir</name></expr></argument>, <argument><expr><name>progname</name></expr></argument>, <argument><expr><name>serverVersion</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>verbose</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: base backup completed\n"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>progname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>


<function><type><name>int</name></type>
<name>main</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>argv</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>static</specifier> <name><name>struct</name> <name>option</name></name></type> <name><name>long_options</name><index>[]</index></name> <init>= <expr><block>{
		<expr><block>{<expr><literal type="string">"help"</literal></expr>, <expr><name>no_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="char">'?'</literal></expr>}</block></expr>,
		<expr><block>{<expr><literal type="string">"version"</literal></expr>, <expr><name>no_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="char">'V'</literal></expr>}</block></expr>,
		<expr><block>{<expr><literal type="string">"pgdata"</literal></expr>, <expr><name>required_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="char">'D'</literal></expr>}</block></expr>,
		<expr><block>{<expr><literal type="string">"format"</literal></expr>, <expr><name>required_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="char">'F'</literal></expr>}</block></expr>,
		<expr><block>{<expr><literal type="string">"checkpoint"</literal></expr>, <expr><name>required_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="char">'c'</literal></expr>}</block></expr>,
		<expr><block>{<expr><literal type="string">"create-slot"</literal></expr>, <expr><name>no_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="char">'C'</literal></expr>}</block></expr>,
		<expr><block>{<expr><literal type="string">"max-rate"</literal></expr>, <expr><name>required_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="char">'r'</literal></expr>}</block></expr>,
		<expr><block>{<expr><literal type="string">"write-recovery-conf"</literal></expr>, <expr><name>no_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="char">'R'</literal></expr>}</block></expr>,
		<expr><block>{<expr><literal type="string">"slot"</literal></expr>, <expr><name>required_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="char">'S'</literal></expr>}</block></expr>,
		<expr><block>{<expr><literal type="string">"tablespace-mapping"</literal></expr>, <expr><name>required_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="char">'T'</literal></expr>}</block></expr>,
		<expr><block>{<expr><literal type="string">"wal-method"</literal></expr>, <expr><name>required_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="char">'X'</literal></expr>}</block></expr>,
		<expr><block>{<expr><literal type="string">"gzip"</literal></expr>, <expr><name>no_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="char">'z'</literal></expr>}</block></expr>,
		<expr><block>{<expr><literal type="string">"compress"</literal></expr>, <expr><name>required_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="char">'Z'</literal></expr>}</block></expr>,
		<expr><block>{<expr><literal type="string">"label"</literal></expr>, <expr><name>required_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="char">'l'</literal></expr>}</block></expr>,
		<expr><block>{<expr><literal type="string">"no-clean"</literal></expr>, <expr><name>no_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="char">'n'</literal></expr>}</block></expr>,
		<expr><block>{<expr><literal type="string">"no-sync"</literal></expr>, <expr><name>no_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="char">'N'</literal></expr>}</block></expr>,
		<expr><block>{<expr><literal type="string">"dbname"</literal></expr>, <expr><name>required_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="char">'d'</literal></expr>}</block></expr>,
		<expr><block>{<expr><literal type="string">"host"</literal></expr>, <expr><name>required_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="char">'h'</literal></expr>}</block></expr>,
		<expr><block>{<expr><literal type="string">"port"</literal></expr>, <expr><name>required_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="char">'p'</literal></expr>}</block></expr>,
		<expr><block>{<expr><literal type="string">"username"</literal></expr>, <expr><name>required_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="char">'U'</literal></expr>}</block></expr>,
		<expr><block>{<expr><literal type="string">"no-password"</literal></expr>, <expr><name>no_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="char">'w'</literal></expr>}</block></expr>,
		<expr><block>{<expr><literal type="string">"password"</literal></expr>, <expr><name>no_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="char">'W'</literal></expr>}</block></expr>,
		<expr><block>{<expr><literal type="string">"status-interval"</literal></expr>, <expr><name>required_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="char">'s'</literal></expr>}</block></expr>,
		<expr><block>{<expr><literal type="string">"verbose"</literal></expr>, <expr><name>no_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="char">'v'</literal></expr>}</block></expr>,
		<expr><block>{<expr><literal type="string">"progress"</literal></expr>, <expr><name>no_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="char">'P'</literal></expr>}</block></expr>,
		<expr><block>{<expr><literal type="string">"waldir"</literal></expr>, <expr><name>required_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="number">1</literal></expr>}</block></expr>,
		<expr><block>{<expr><literal type="string">"no-slot"</literal></expr>, <expr><name>no_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="number">2</literal></expr>}</block></expr>,
		<expr><block>{<expr><literal type="string">"no-verify-checksums"</literal></expr>, <expr><name>no_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="number">3</literal></expr>}</block></expr>,
		<expr><block>{<expr><literal type="string">"polardata"</literal></expr>, <expr><name>required_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="number">4</literal></expr>}</block></expr>,
		<expr><block>{<expr><literal type="string">"polar_disk_name"</literal></expr>, <expr><name>required_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="number">5</literal></expr>}</block></expr>,
		<expr><block>{<expr><literal type="string">"polar_host_id"</literal></expr>, <expr><name>required_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="number">6</literal></expr>}</block></expr>,
		<expr><block>{<expr><literal type="string">"polar_storage_cluster_name"</literal></expr>, <expr><name>required_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="number">7</literal></expr>}</block></expr>,
		<expr><block>{<expr><name>NULL</name></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>NULL</name></expr>, <expr><literal type="number">0</literal></expr>}</block></expr>
	}</block></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>c</name></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>int</name></type>			<name>option_index</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>		<modifier>*</modifier></type><name>polar_disk_name</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>		<modifier>*</modifier></type><name>polar_storage_cluster_name</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>polar_hostid</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>progname</name> <operator>=</operator> <call><name>get_progname</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>set_pglocale_pgservice</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><call><name>PG_TEXTDOMAIN</name><argument_list>(<argument><expr><literal type="string">"pg_basebackup"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>argc</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"--help"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <call><name>strcmp</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"-?"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>usage</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"-V"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal>
				 <operator>||</operator> <call><name>strcmp</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"--version"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>puts</name><argument_list>(<argument><expr><literal type="string">"pg_basebackup (PostgreSQL) "</literal> <name>PG_VERSION</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>atexit</name><argument_list>(<argument><expr><name>cleanup_directories_atexit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<while>while <condition>(<expr><operator>(</operator><name>c</name> <operator>=</operator> <call><name>getopt_long</name><argument_list>(<argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>, <argument><expr><literal type="string">"CD:F:r:RS:T:X:l:nNzZ:d:c:h:p:U:s:wWkvP"</literal></expr></argument>,
							<argument><expr><name>long_options</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>option_index</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<switch>switch <condition>(<expr><name>c</name></expr>)</condition>
		<block>{<block_content>
			<case>case <expr><literal type="char">'C'</literal></expr>:</case>
				<expr_stmt><expr><name>create_slot</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><literal type="char">'D'</literal></expr>:</case>
				<expr_stmt><expr><name>basedir</name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><name>optarg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case  <expr><literal type="number">4</literal></expr> :</case>
				<expr_stmt><expr><name>datadir</name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><name>optarg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><literal type="number">5</literal></expr> :</case>
				<expr_stmt><expr><name>polar_disk_name</name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><name>optarg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><literal type="number">6</literal></expr> :</case>
				<expr_stmt><expr><name>polar_hostid</name> <operator>=</operator> <call><name>atoi</name><argument_list>(<argument><expr><name>optarg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><literal type="number">7</literal></expr> :</case>
				<expr_stmt><expr><name>polar_storage_cluster_name</name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><name>optarg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><literal type="char">'F'</literal></expr>:</case>
				<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>optarg</name></expr></argument>, <argument><expr><literal type="string">"p"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <call><name>strcmp</name><argument_list>(<argument><expr><name>optarg</name></expr></argument>, <argument><expr><literal type="string">"plain"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>format</name> <operator>=</operator> <literal type="char">'p'</literal></expr>;</expr_stmt></block_content></block></if>
				<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>optarg</name></expr></argument>, <argument><expr><literal type="string">"t"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <call><name>strcmp</name><argument_list>(<argument><expr><name>optarg</name></expr></argument>, <argument><expr><literal type="string">"tar"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>format</name> <operator>=</operator> <literal type="char">'t'</literal></expr>;</expr_stmt></block_content></block></if>
				<else>else
				<block>{<block_content>
					<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>,
							<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: invalid output format \"%s\", must be \"plain\" or \"tar\"\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
							<argument><expr><name>progname</name></expr></argument>, <argument><expr><name>optarg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></else></if_stmt>
				<break>break;</break>
			<case>case <expr><literal type="char">'r'</literal></expr>:</case>
				<expr_stmt><expr><name>maxrate</name> <operator>=</operator> <call><name>parse_max_rate</name><argument_list>(<argument><expr><name>optarg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><literal type="char">'R'</literal></expr>:</case>
				<expr_stmt><expr><name>writerecoveryconf</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><literal type="char">'S'</literal></expr>:</case>

				<comment type="block">/*
				 * When specifying replication slot name, use a permanent
				 * slot.
				 */</comment>
				<expr_stmt><expr><name>replication_slot</name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><name>optarg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>temp_replication_slot</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><literal type="number">2</literal></expr>:</case>
				<expr_stmt><expr><name>no_slot</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><literal type="char">'T'</literal></expr>:</case>
				<expr_stmt><expr><call><name>tablespace_list_append</name><argument_list>(<argument><expr><name>optarg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><literal type="char">'X'</literal></expr>:</case>
				<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>optarg</name></expr></argument>, <argument><expr><literal type="string">"n"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
					<call><name>strcmp</name><argument_list>(<argument><expr><name>optarg</name></expr></argument>, <argument><expr><literal type="string">"none"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name>includewal</name> <operator>=</operator> <name>NO_WAL</name></expr>;</expr_stmt>
				</block_content>}</block></if>
				<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>optarg</name></expr></argument>, <argument><expr><literal type="string">"f"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
						 <call><name>strcmp</name><argument_list>(<argument><expr><name>optarg</name></expr></argument>, <argument><expr><literal type="string">"fetch"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name>includewal</name> <operator>=</operator> <name>FETCH_WAL</name></expr>;</expr_stmt>
				</block_content>}</block></if>
				<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>optarg</name></expr></argument>, <argument><expr><literal type="string">"s"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
						 <call><name>strcmp</name><argument_list>(<argument><expr><name>optarg</name></expr></argument>, <argument><expr><literal type="string">"stream"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name>includewal</name> <operator>=</operator> <name>STREAM_WAL</name></expr>;</expr_stmt>
				</block_content>}</block></if>
				<else>else
				<block>{<block_content>
					<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>,
							<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: invalid wal-method option \"%s\", must be \"fetch\", \"stream\", or \"none\"\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
							<argument><expr><name>progname</name></expr></argument>, <argument><expr><name>optarg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></else></if_stmt>
				<break>break;</break>
			<case>case <expr><literal type="number">1</literal></expr>:</case>
				<expr_stmt><expr><name>xlog_dir</name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><name>optarg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><literal type="char">'l'</literal></expr>:</case>
				<expr_stmt><expr><name>label</name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><name>optarg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><literal type="char">'n'</literal></expr>:</case>
				<expr_stmt><expr><name>noclean</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><literal type="char">'N'</literal></expr>:</case>
				<expr_stmt><expr><name>do_sync</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><literal type="char">'z'</literal></expr>:</case>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_LIBZ</name></cpp:ifdef>
				<expr_stmt><expr><name>compresslevel</name> <operator>=</operator> <name>Z_DEFAULT_COMPRESSION</name></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
				<expr_stmt><expr><name>compresslevel</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>	<comment type="block">/* will be rejected below */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
				<break>break;</break>
			<case>case <expr><literal type="char">'Z'</literal></expr>:</case>
				<expr_stmt><expr><name>compresslevel</name> <operator>=</operator> <call><name>atoi</name><argument_list>(<argument><expr><name>optarg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name><name>compresslevel</name> <argument_list type="generic">&lt; <argument><expr><literal type="number">0</literal> <operator>||</operator> <name>compresslevel</name></expr></argument> &gt;</argument_list></name> <literal type="number">9</literal></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: invalid compression level \"%s\"\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
							<argument><expr><name>progname</name></expr></argument>, <argument><expr><name>optarg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
				<break>break;</break>
			<case>case <expr><literal type="char">'c'</literal></expr>:</case>
				<if_stmt><if>if <condition>(<expr><call><name>pg_strcasecmp</name><argument_list>(<argument><expr><name>optarg</name></expr></argument>, <argument><expr><literal type="string">"fast"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>fastcheckpoint</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if>
				<if type="elseif">else if <condition>(<expr><call><name>pg_strcasecmp</name><argument_list>(<argument><expr><name>optarg</name></expr></argument>, <argument><expr><literal type="string">"spread"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>fastcheckpoint</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></if>
				<else>else
				<block>{<block_content>
					<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: invalid checkpoint argument \"%s\", must be \"fast\" or \"spread\"\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
							<argument><expr><name>progname</name></expr></argument>, <argument><expr><name>optarg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></else></if_stmt>
				<break>break;</break>
			<case>case <expr><literal type="char">'d'</literal></expr>:</case>
				<expr_stmt><expr><name>connection_string</name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><name>optarg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><literal type="char">'h'</literal></expr>:</case>
				<expr_stmt><expr><name>dbhost</name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><name>optarg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><literal type="char">'p'</literal></expr>:</case>
				<expr_stmt><expr><name>dbport</name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><name>optarg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><literal type="char">'U'</literal></expr>:</case>
				<expr_stmt><expr><name>dbuser</name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><name>optarg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><literal type="char">'w'</literal></expr>:</case>
				<expr_stmt><expr><name>dbgetpassword</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><literal type="char">'W'</literal></expr>:</case>
				<expr_stmt><expr><name>dbgetpassword</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><literal type="char">'s'</literal></expr>:</case>
				<expr_stmt><expr><name>standby_message_timeout</name> <operator>=</operator> <call><name>atoi</name><argument_list>(<argument><expr><name>optarg</name></expr></argument>)</argument_list></call> <operator>*</operator> <literal type="number">1000</literal></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name>standby_message_timeout</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: invalid status interval \"%s\"\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
							<argument><expr><name>progname</name></expr></argument>, <argument><expr><name>optarg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
				<break>break;</break>
			<case>case <expr><literal type="char">'v'</literal></expr>:</case>
				<expr_stmt><expr><name>verbose</name><operator>++</operator></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><literal type="char">'P'</literal></expr>:</case>
				<expr_stmt><expr><name>showprogress</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><literal type="number">3</literal></expr>:</case>
				<expr_stmt><expr><name>verify_checksums</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
				<break>break;</break>
			<default>default:</default>

				<comment type="block">/*
				 * getopt_long already emitted a complaint
				 */</comment>
				<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Try \"%s --help\" for more information.\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
						<argument><expr><name>progname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></switch>
	</block_content>}</block></while>

	<comment type="block">/*
	 * Any non-option arguments?
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>optind</name> <operator>&lt;</operator> <name>argc</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>,
				<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: too many command-line arguments (first is \"%s\")\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
				<argument><expr><name>progname</name></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><name>optind</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Try \"%s --help\" for more information.\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
				<argument><expr><name>progname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Required arguments
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>basedir</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: no target directory specified\n"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>progname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Try \"%s --help\" for more information.\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
				<argument><expr><name>progname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>basedir</name></expr></argument>, <argument><expr><literal type="string">"-"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>datadir</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: In polar mode, backup sets cannot be output to standard outputs.\n"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>progname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if<condition>(<expr><name>datadir</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>polar_disk_name</name> <operator>!=</operator> <name>NULL</name> <operator>||</operator> <name>polar_hostid</name> <operator>!=</operator> <literal type="number">0</literal> <operator>||</operator> <name>polar_storage_cluster_name</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: In polar mode, The polardata, polar_disk_name and polar_host_id parameters must be specified or not.\n"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>progname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name>is_pfs_mode</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>is_polar_mode</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>datadir</name> <operator>=</operator> <name>basedir</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>polar_disk_name</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>polar_hostid</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: In polar mode, polar_disk_name and polar_host_id must be specified.\n"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>progname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			<expr_stmt><expr><name>is_pfs_mode</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>is_polar_mode</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<if_stmt><if>if <condition>( <expr><name>polar_hostid</name> <operator>!=</operator> <literal type="number">0</literal> <operator>||</operator> <name>polar_storage_cluster_name</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: In polar mode, The polardata, polar_disk_name and polar_host_id parameters must be specified or not.\n"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>progname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			<expr_stmt><expr><name>is_pfs_mode</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>is_polar_mode</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>format</name> <operator>==</operator> <literal type="char">'t'</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>,
					<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: In polar mode, tar mode is not supported.\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
					<argument><expr><name>progname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/*
	 * Mutually exclusive arguments
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>format</name> <operator>==</operator> <literal type="char">'p'</literal> <operator>&amp;&amp;</operator> <name>compresslevel</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>,
				<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: only tar mode backups can be compressed\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
				<argument><expr><name>progname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Try \"%s --help\" for more information.\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
				<argument><expr><name>progname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>format</name> <operator>==</operator> <literal type="char">'t'</literal> <operator>&amp;&amp;</operator> <name>includewal</name> <operator>==</operator> <name>STREAM_WAL</name> <operator>&amp;&amp;</operator> <call><name>strcmp</name><argument_list>(<argument><expr><name>basedir</name></expr></argument>, <argument><expr><literal type="string">"-"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>,
				<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: cannot stream write-ahead logs in tar mode to stdout\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
				<argument><expr><name>progname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Try \"%s --help\" for more information.\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
				<argument><expr><name>progname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>replication_slot</name> <operator>&amp;&amp;</operator> <name>includewal</name> <operator>!=</operator> <name>STREAM_WAL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>,
				<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: replication slots can only be used with WAL streaming\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
				<argument><expr><name>progname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Try \"%s --help\" for more information.\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
				<argument><expr><name>progname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>no_slot</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>replication_slot</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>,
					<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: --no-slot cannot be used with slot name\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
					<argument><expr><name>progname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Try \"%s --help\" for more information.\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
					<argument><expr><name>progname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><name>temp_replication_slot</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>create_slot</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>replication_slot</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>,
					<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: %s needs a slot to be specified using --slot\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
					<argument><expr><name>progname</name></expr></argument>, <argument><expr><literal type="string">"--create-slot"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Try \"%s --help\" for more information.\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
					<argument><expr><name>progname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>no_slot</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>,
					<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: --create-slot and --no-slot are incompatible options\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
					<argument><expr><name>progname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Try \"%s --help\" for more information.\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
					<argument><expr><name>progname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>xlog_dir</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>format</name> <operator>!=</operator> <literal type="char">'p'</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>,
					<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: WAL directory location can only be specified in plain mode\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
					<argument><expr><name>progname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Try \"%s --help\" for more information.\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
					<argument><expr><name>progname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* clean up xlog directory name, check it's absolute */</comment>
		<expr_stmt><expr><call><name>canonicalize_path</name><argument_list>(<argument><expr><name>xlog_dir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>is_absolute_path</name><argument_list>(<argument><expr><name>xlog_dir</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: WAL directory location must be "</literal>
							  <literal type="string">"an absolute path\n"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>progname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Try \"%s --help\" for more information.\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
					<argument><expr><name>progname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>HAVE_LIBZ</name></cpp:ifndef>
	<if_stmt><if>if <condition>(<expr><name>compresslevel</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>,
				<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: this build does not support compression\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
				<argument><expr><name>progname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<expr_stmt><expr><call><name>polar_fs_init</name><argument_list>(<argument><expr><name>is_pfs_mode</name></expr></argument>, <argument><expr><name>polar_storage_cluster_name</name></expr></argument>, <argument><expr><name>polar_disk_name</name></expr></argument>, <argument><expr><name>polar_hostid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* connection in replication mode to server */</comment>
	<expr_stmt><expr><name>conn</name> <operator>=</operator> <call><name>GetConnection</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>conn</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Error message already written in GetConnection() */</comment>
		<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Set umask so that directories/files are created with the same
	 * permissions as directories/files in the source data directory.
	 *
	 * pg_mode_mask is set to owner-only by default and then updated in
	 * GetConnection() where we get the mode from the server-side with
	 * RetrieveDataDirCreatePerm() and then call SetDataDirectoryCreatePerm().
	 */</comment>
	<expr_stmt><expr><call><name>umask</name><argument_list>(<argument><expr><name>pg_mode_mask</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Verify that the target directory exists, or create it. For plaintext
	 * backups, always require the directory. For tar backups, require it
	 * unless we are writing to stdout.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>format</name> <operator>==</operator> <literal type="char">'p'</literal> <operator>||</operator> <call><name>strcmp</name><argument_list>(<argument><expr><name>basedir</name></expr></argument>, <argument><expr><literal type="string">"-"</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>verify_dir_is_empty_or_create</name><argument_list>(<argument><expr><name>basedir</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>made_new_pgbase</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>found_existing_pgdata</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>is_polar_mode</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>verify_dir_is_empty_or_create</name><argument_list>(<argument><expr><name>datadir</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>made_new_pgdata</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>found_existing_poalrdata</name></expr></argument>, <argument><expr><name>is_pfs_mode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* determine remote server's xlog segment size */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>RetrieveWalSegSize</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>disconnect_and_exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Create pg_wal symlink, if required */</comment>
	<if_stmt><if>if <condition>(<expr><name>xlog_dir</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>linkloc</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>verify_dir_is_empty_or_create</name><argument_list>(<argument><expr><name>xlog_dir</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>made_new_xlogdir</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>found_existing_xlogdir</name></expr></argument>, <argument><expr><name>is_pfs_mode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Form name of the place where the symlink must go. pg_xlog has been
		 * renamed to pg_wal in post-10 clusters.
		 */</comment>
		<expr_stmt><expr><name>linkloc</name> <operator>=</operator> <call><name>psprintf</name><argument_list>(<argument><expr><literal type="string">"%s/%s"</literal></expr></argument>, <argument><expr><name>basedir</name></expr></argument>,
						   <argument><expr><ternary><condition><expr><call><name>PQserverVersion</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <name>MINIMUM_VERSION_FOR_PG_WAL</name></expr> ?</condition><then>
						   <expr><literal type="string">"pg_xlog"</literal></expr> </then><else>: <expr><literal type="string">"pg_wal"</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_SYMLINK</name></cpp:ifdef>
		<if_stmt><if>if <condition>(<expr><call><name>symlink</name><argument_list>(<argument><expr><name>xlog_dir</name></expr></argument>, <argument><expr><name>linkloc</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: could not create symbolic link \"%s\": %s\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
					<argument><expr><name>progname</name></expr></argument>, <argument><expr><name>linkloc</name></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>disconnect_and_exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
		<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: symlinks are not supported on this platform\n"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>progname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>disconnect_and_exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
		<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>linkloc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>BaseBackup</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>success</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>polar_fs_destory</name><argument_list>(<argument><expr><name>is_pfs_mode</name></expr></argument>, <argument><expr><name>polar_disk_name</name></expr></argument>, <argument><expr><name>polar_hostid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>
</unit>
