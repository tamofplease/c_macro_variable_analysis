<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/PolarDB-for-PostgreSQL/src/bin/pg_basebackup/receivelog.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * receivelog.c - receive WAL files using the streaming
 *				  replication protocol.
 *
 * Author: Magnus Hagander &lt;magnus@hagander.net&gt;
 *
 * Portions Copyright (c) 1996-2018, PostgreSQL Global Development Group
 *
 * IDENTIFICATION
 *		  src/bin/pg_basebackup/receivelog.c
 *-------------------------------------------------------------------------
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres_fe.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/stat.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;unistd.h&gt;</cpp:file></cpp:include>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_SYS_SELECT_H</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/select.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* local includes */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"receivelog.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"streamutil.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"libpq-fe.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/xlog_internal.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"common/file_utils.h"</cpp:file></cpp:include>


<comment type="block">/* fd and filename for currently open WAL file */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>Walfile</name> <modifier>*</modifier></type><name>walfile</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name></type> <name><name>current_walfile_name</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name> <init>= <expr><literal type="string">""</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type> <name>reportFlushPosition</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>XLogRecPtr</name></type> <name>lastFlushPosition</name> <init>= <expr><name>InvalidXLogRecPtr</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type> <name>still_sending</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>	<comment type="block">/* feedback still needs to be sent? */</comment>

<function_decl><type><specifier>static</specifier> <name>PGresult</name> <modifier>*</modifier></type><name>HandleCopyStream</name><parameter_list>(<parameter><decl><type><name>PGconn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>, <parameter><decl><type><name>StreamCtl</name> <modifier>*</modifier></type><name>stream</name></decl></parameter>,
				 <parameter><decl><type><name>XLogRecPtr</name> <modifier>*</modifier></type><name>stoppos</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type>	<name>CopyStreamPoll</name><parameter_list>(<parameter><decl><type><name>PGconn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>, <parameter><decl><type><name>long</name></type> <name>timeout_ms</name></decl></parameter>, <parameter><decl><type><name>pgsocket</name></type> <name>stop_socket</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>CopyStreamReceive</name><parameter_list>(<parameter><decl><type><name>PGconn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>, <parameter><decl><type><name>long</name></type> <name>timeout</name></decl></parameter>, <parameter><decl><type><name>pgsocket</name></type> <name>stop_socket</name></decl></parameter>,
				  <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>buffer</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>ProcessKeepaliveMsg</name><parameter_list>(<parameter><decl><type><name>PGconn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>, <parameter><decl><type><name>StreamCtl</name> <modifier>*</modifier></type><name>stream</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>copybuf</name></decl></parameter>,
					<parameter><decl><type><name>int</name></type> <name>len</name></decl></parameter>, <parameter><decl><type><name>XLogRecPtr</name></type> <name>blockpos</name></decl></parameter>, <parameter><decl><type><name>TimestampTz</name> <modifier>*</modifier></type><name>last_status</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>ProcessXLogDataMsg</name><parameter_list>(<parameter><decl><type><name>PGconn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>, <parameter><decl><type><name>StreamCtl</name> <modifier>*</modifier></type><name>stream</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>copybuf</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>len</name></decl></parameter>,
				   <parameter><decl><type><name>XLogRecPtr</name> <modifier>*</modifier></type><name>blockpos</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>PGresult</name> <modifier>*</modifier></type><name>HandleEndOfCopyStream</name><parameter_list>(<parameter><decl><type><name>PGconn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>, <parameter><decl><type><name>StreamCtl</name> <modifier>*</modifier></type><name>stream</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>copybuf</name></decl></parameter>,
					  <parameter><decl><type><name>XLogRecPtr</name></type> <name>blockpos</name></decl></parameter>, <parameter><decl><type><name>XLogRecPtr</name> <modifier>*</modifier></type><name>stoppos</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>CheckCopyStreamStop</name><parameter_list>(<parameter><decl><type><name>PGconn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>, <parameter><decl><type><name>StreamCtl</name> <modifier>*</modifier></type><name>stream</name></decl></parameter>, <parameter><decl><type><name>XLogRecPtr</name></type> <name>blockpos</name></decl></parameter>,
					<parameter><decl><type><name>XLogRecPtr</name> <modifier>*</modifier></type><name>stoppos</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>long</name></type> <name>CalculateCopyStreamSleeptime</name><parameter_list>(<parameter><decl><type><name>TimestampTz</name></type> <name>now</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>standby_message_timeout</name></decl></parameter>,
							 <parameter><decl><type><name>TimestampTz</name></type> <name>last_status</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>ReadEndOfStreamingResult</name><parameter_list>(<parameter><decl><type><name>PGresult</name> <modifier>*</modifier></type><name>res</name></decl></parameter>, <parameter><decl><type><name>XLogRecPtr</name> <modifier>*</modifier></type><name>startpos</name></decl></parameter>,
						 <parameter><decl><type><name>uint32</name> <modifier>*</modifier></type><name>timeline</name></decl></parameter>)</parameter_list>;</function_decl>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>mark_file_as_archived</name><parameter_list>(<parameter><decl><type><name>StreamCtl</name> <modifier>*</modifier></type><name>stream</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>fname</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Walfile</name>    <modifier>*</modifier></type><name>f</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>static</specifier> <name>char</name></type> <name><name>tmppath</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>tmppath</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>tmppath</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"archive_status/%s.done"</literal></expr></argument>,
			 <argument><expr><name>fname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>f</name> <operator>=</operator> <call><name><name>stream</name><operator>-&gt;</operator><name>walmethod</name><operator>-&gt;</operator><name>open_for_write</name></name><argument_list>(<argument><expr><name>tmppath</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>f</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: could not create archive status file \"%s\": %s\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
				<argument><expr><name>progname</name></expr></argument>, <argument><expr><name>tmppath</name></expr></argument>, <argument><expr><call><name><name>stream</name><operator>-&gt;</operator><name>walmethod</name><operator>-&gt;</operator><name>getlasterror</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name><name>stream</name><operator>-&gt;</operator><name>walmethod</name><operator>-&gt;</operator><name>close</name></name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><name>CLOSE_NORMAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Open a new WAL file in the specified directory.
 *
 * Returns true if OK; on failure, returns false after printing an error msg.
 * On success, 'walfile' is set to the FD for the file, and the base filename
 * (without partial_suffix) is stored in 'current_walfile_name'.
 *
 * The file will be padded to 16Mb with zeroes.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>open_walfile</name><parameter_list>(<parameter><decl><type><name>StreamCtl</name> <modifier>*</modifier></type><name>stream</name></decl></parameter>, <parameter><decl><type><name>XLogRecPtr</name></type> <name>startpoint</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Walfile</name>    <modifier>*</modifier></type><name>f</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>fn</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ssize_t</name></type>		<name>size</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>XLogSegNo</name></type>	<name>segno</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>XLByteToSeg</name><argument_list>(<argument><expr><name>startpoint</name></expr></argument>, <argument><expr><name>segno</name></expr></argument>, <argument><expr><name>WalSegSz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>XLogFileName</name><argument_list>(<argument><expr><name>current_walfile_name</name></expr></argument>, <argument><expr><name><name>stream</name><operator>-&gt;</operator><name>timeline</name></name></expr></argument>, <argument><expr><name>segno</name></expr></argument>, <argument><expr><name>WalSegSz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>fn</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>fn</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"%s%s"</literal></expr></argument>, <argument><expr><name>current_walfile_name</name></expr></argument>,
			 <argument><expr><ternary><condition><expr><name><name>stream</name><operator>-&gt;</operator><name>partial_suffix</name></name></expr> ?</condition><then> <expr><name><name>stream</name><operator>-&gt;</operator><name>partial_suffix</name></name></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * When streaming to files, if an existing file exists we verify that it's
	 * either empty (just created), or a complete WalSegSz segment (in which
	 * case it has been created and padded). Anything else indicates a corrupt
	 * file.
	 *
	 * When streaming to tar, no file with this name will exist before, so we
	 * never have to verify a size.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name><name>stream</name><operator>-&gt;</operator><name>walmethod</name><operator>-&gt;</operator><name>existsfile</name></name><argument_list>(<argument><expr><name>fn</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>size</name> <operator>=</operator> <call><name><name>stream</name><operator>-&gt;</operator><name>walmethod</name><operator>-&gt;</operator><name>get_file_size</name></name><argument_list>(<argument><expr><name>fn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>size</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>,
					<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: could not get size of write-ahead log file \"%s\": %s\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
					<argument><expr><name>progname</name></expr></argument>, <argument><expr><name>fn</name></expr></argument>, <argument><expr><call><name><name>stream</name><operator>-&gt;</operator><name>walmethod</name><operator>-&gt;</operator><name>getlasterror</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>false</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name>size</name> <operator>==</operator> <name>WalSegSz</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Already padded file. Open it for use */</comment>
			<expr_stmt><expr><name>f</name> <operator>=</operator> <call><name><name>stream</name><operator>-&gt;</operator><name>walmethod</name><operator>-&gt;</operator><name>open_for_write</name></name><argument_list>(<argument><expr><name>current_walfile_name</name></expr></argument>, <argument><expr><name><name>stream</name><operator>-&gt;</operator><name>partial_suffix</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>f</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>,
						<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: could not open existing write-ahead log file \"%s\": %s\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
						<argument><expr><name>progname</name></expr></argument>, <argument><expr><name>fn</name></expr></argument>, <argument><expr><call><name><name>stream</name><operator>-&gt;</operator><name>walmethod</name><operator>-&gt;</operator><name>getlasterror</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr><name>false</name></expr>;</return>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/* fsync file in case of a previous crash */</comment>
			<if_stmt><if>if <condition>(<expr><call><name><name>stream</name><operator>-&gt;</operator><name>walmethod</name><operator>-&gt;</operator><name>sync</name></name><argument_list>(<argument><expr><name>f</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>,
						<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: could not fsync existing write-ahead log file \"%s\": %s\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
						<argument><expr><name>progname</name></expr></argument>, <argument><expr><name>fn</name></expr></argument>, <argument><expr><call><name><name>stream</name><operator>-&gt;</operator><name>walmethod</name><operator>-&gt;</operator><name>getlasterror</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name><name>stream</name><operator>-&gt;</operator><name>walmethod</name><operator>-&gt;</operator><name>close</name></name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><name>CLOSE_UNLINK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr><name>false</name></expr>;</return>
			</block_content>}</block></if></if_stmt>

			<expr_stmt><expr><name>walfile</name> <operator>=</operator> <name>f</name></expr>;</expr_stmt>
			<return>return <expr><name>true</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name>size</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* if write didn't set errno, assume problem is no disk space */</comment>
			<if_stmt><if>if <condition>(<expr><name>errno</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>errno</name> <operator>=</operator> <name>ENOSPC</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>,
					<argument><expr><call><name>ngettext</name><argument_list>(<argument><expr><literal type="string">"%s: write-ahead log file \"%s\" has %d byte, should be 0 or %d\n"</literal></expr></argument>,
							 <argument><expr><literal type="string">"%s: write-ahead log file \"%s\" has %d bytes, should be 0 or %d\n"</literal></expr></argument>,
							 <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr></argument>,
					<argument><expr><name>progname</name></expr></argument>, <argument><expr><name>fn</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name>size</name></expr></argument>, <argument><expr><name>WalSegSz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>false</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
		<comment type="block">/* File existed and was empty, so fall through and open */</comment>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* No file existed, so create one */</comment>

	<expr_stmt><expr><name>f</name> <operator>=</operator> <call><name><name>stream</name><operator>-&gt;</operator><name>walmethod</name><operator>-&gt;</operator><name>open_for_write</name></name><argument_list>(<argument><expr><name>current_walfile_name</name></expr></argument>,
										  <argument><expr><name><name>stream</name><operator>-&gt;</operator><name>partial_suffix</name></name></expr></argument>, <argument><expr><name>WalSegSz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>f</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>,
				<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: could not open write-ahead log file \"%s\": %s\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
				<argument><expr><name>progname</name></expr></argument>, <argument><expr><name>fn</name></expr></argument>, <argument><expr><call><name><name>stream</name><operator>-&gt;</operator><name>walmethod</name><operator>-&gt;</operator><name>getlasterror</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>walfile</name> <operator>=</operator> <name>f</name></expr>;</expr_stmt>
	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Close the current WAL file (if open), and rename it to the correct
 * filename if it's complete. On failure, prints an error message to stderr
 * and returns false, otherwise returns true.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>close_walfile</name><parameter_list>(<parameter><decl><type><name>StreamCtl</name> <modifier>*</modifier></type><name>stream</name></decl></parameter>, <parameter><decl><type><name>XLogRecPtr</name></type> <name>pos</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>off_t</name></type>		<name>currpos</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>r</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>walfile</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>currpos</name> <operator>=</operator> <call><name><name>stream</name><operator>-&gt;</operator><name>walmethod</name><operator>-&gt;</operator><name>get_current_pos</name></name><argument_list>(<argument><expr><name>walfile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>currpos</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>,
				<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: could not determine seek position in file \"%s\": %s\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
				<argument><expr><name>progname</name></expr></argument>, <argument><expr><name>current_walfile_name</name></expr></argument>, <argument><expr><call><name><name>stream</name><operator>-&gt;</operator><name>walmethod</name><operator>-&gt;</operator><name>getlasterror</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name><name>stream</name><operator>-&gt;</operator><name>walmethod</name><operator>-&gt;</operator><name>close</name></name><argument_list>(<argument><expr><name>walfile</name></expr></argument>, <argument><expr><name>CLOSE_UNLINK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>walfile</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>stream</name><operator>-&gt;</operator><name>partial_suffix</name></name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>currpos</name> <operator>==</operator> <name>WalSegSz</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name><name>stream</name><operator>-&gt;</operator><name>walmethod</name><operator>-&gt;</operator><name>close</name></name><argument_list>(<argument><expr><name>walfile</name></expr></argument>, <argument><expr><name>CLOSE_NORMAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>,
					<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: not renaming \"%s%s\", segment is not complete\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
					<argument><expr><name>progname</name></expr></argument>, <argument><expr><name>current_walfile_name</name></expr></argument>, <argument><expr><name><name>stream</name><operator>-&gt;</operator><name>partial_suffix</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name><name>stream</name><operator>-&gt;</operator><name>walmethod</name><operator>-&gt;</operator><name>close</name></name><argument_list>(<argument><expr><name>walfile</name></expr></argument>, <argument><expr><name>CLOSE_NO_RENAME</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name><name>stream</name><operator>-&gt;</operator><name>walmethod</name><operator>-&gt;</operator><name>close</name></name><argument_list>(<argument><expr><name>walfile</name></expr></argument>, <argument><expr><name>CLOSE_NORMAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<expr_stmt><expr><name>walfile</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>r</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: could not close file \"%s\": %s\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
				<argument><expr><name>progname</name></expr></argument>, <argument><expr><name>current_walfile_name</name></expr></argument>, <argument><expr><call><name><name>stream</name><operator>-&gt;</operator><name>walmethod</name><operator>-&gt;</operator><name>getlasterror</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Mark file as archived if requested by the caller - pg_basebackup needs
	 * to do so as files can otherwise get archived again after promotion of a
	 * new node. This is in line with walreceiver.c always doing a
	 * XLogArchiveForceDone() after a complete segment.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>currpos</name> <operator>==</operator> <name>WalSegSz</name> <operator>&amp;&amp;</operator> <name><name>stream</name><operator>-&gt;</operator><name>mark_done</name></name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* writes error message if failed */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>mark_file_as_archived</name><argument_list>(<argument><expr><name>stream</name></expr></argument>, <argument><expr><name>current_walfile_name</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>lastFlushPosition</name> <operator>=</operator> <name>pos</name></expr>;</expr_stmt>
	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * Check if a timeline history file exists.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>existsTimeLineHistoryFile</name><parameter_list>(<parameter><decl><type><name>StreamCtl</name> <modifier>*</modifier></type><name>stream</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>histfname</name><index>[<expr><name>MAXFNAMELEN</name></expr>]</index></name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Timeline 1 never has a history file. We treat that as if it existed,
	 * since we never need to stream it.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>stream</name><operator>-&gt;</operator><name>timeline</name></name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>TLHistoryFileName</name><argument_list>(<argument><expr><name>histfname</name></expr></argument>, <argument><expr><name><name>stream</name><operator>-&gt;</operator><name>timeline</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><call><name><name>stream</name><operator>-&gt;</operator><name>walmethod</name><operator>-&gt;</operator><name>existsfile</name></name><argument_list>(<argument><expr><name>histfname</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>writeTimeLineHistoryFile</name><parameter_list>(<parameter><decl><type><name>StreamCtl</name> <modifier>*</modifier></type><name>stream</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>filename</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>content</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>size</name> <init>= <expr><call><name>strlen</name><argument_list>(<argument><expr><name>content</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>histfname</name><index>[<expr><name>MAXFNAMELEN</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Walfile</name>    <modifier>*</modifier></type><name>f</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Check that the server's idea of how timeline history files should be
	 * named matches ours.
	 */</comment>
	<expr_stmt><expr><call><name>TLHistoryFileName</name><argument_list>(<argument><expr><name>histfname</name></expr></argument>, <argument><expr><name><name>stream</name><operator>-&gt;</operator><name>timeline</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>histfname</name></expr></argument>, <argument><expr><name>filename</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: server reported unexpected history file name for timeline %u: %s\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
				<argument><expr><name>progname</name></expr></argument>, <argument><expr><name><name>stream</name><operator>-&gt;</operator><name>timeline</name></name></expr></argument>, <argument><expr><name>filename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>f</name> <operator>=</operator> <call><name><name>stream</name><operator>-&gt;</operator><name>walmethod</name><operator>-&gt;</operator><name>open_for_write</name></name><argument_list>(<argument><expr><name>histfname</name></expr></argument>, <argument><expr><literal type="string">".tmp"</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>f</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: could not create timeline history file \"%s\": %s\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
				<argument><expr><name>progname</name></expr></argument>, <argument><expr><name>histfname</name></expr></argument>, <argument><expr><call><name><name>stream</name><operator>-&gt;</operator><name>walmethod</name><operator>-&gt;</operator><name>getlasterror</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>int</name><operator>)</operator> <call><name><name>stream</name><operator>-&gt;</operator><name>walmethod</name><operator>-&gt;</operator><name>write</name></name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><name>content</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>size</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: could not write timeline history file \"%s\": %s\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
				<argument><expr><name>progname</name></expr></argument>, <argument><expr><name>histfname</name></expr></argument>, <argument><expr><call><name><name>stream</name><operator>-&gt;</operator><name>walmethod</name><operator>-&gt;</operator><name>getlasterror</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * If we fail to make the file, delete it to release disk space
		 */</comment>
		<expr_stmt><expr><call><name><name>stream</name><operator>-&gt;</operator><name>walmethod</name><operator>-&gt;</operator><name>close</name></name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><name>CLOSE_UNLINK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name><name>stream</name><operator>-&gt;</operator><name>walmethod</name><operator>-&gt;</operator><name>close</name></name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><name>CLOSE_NORMAL</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: could not close file \"%s\": %s\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
				<argument><expr><name>progname</name></expr></argument>, <argument><expr><name>histfname</name></expr></argument>, <argument><expr><call><name><name>stream</name><operator>-&gt;</operator><name>walmethod</name><operator>-&gt;</operator><name>getlasterror</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Maintain archive_status, check close_walfile() for details. */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>stream</name><operator>-&gt;</operator><name>mark_done</name></name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* writes error message if failed */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>mark_file_as_archived</name><argument_list>(<argument><expr><name>stream</name></expr></argument>, <argument><expr><name>histfname</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Send a Standby Status Update message to server.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>sendFeedback</name><parameter_list>(<parameter><decl><type><name>PGconn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>, <parameter><decl><type><name>XLogRecPtr</name></type> <name>blockpos</name></decl></parameter>, <parameter><decl><type><name>TimestampTz</name></type> <name>now</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>replyRequested</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>replybuf</name><index>[<expr><literal type="number">1</literal> <operator>+</operator> <literal type="number">8</literal> <operator>+</operator> <literal type="number">8</literal> <operator>+</operator> <literal type="number">8</literal> <operator>+</operator> <literal type="number">8</literal> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>len</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>replybuf</name><index>[<expr><name>len</name></expr>]</index></name> <operator>=</operator> <literal type="char">'r'</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>len</name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>fe_sendint64</name><argument_list>(<argument><expr><name>blockpos</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>replybuf</name><index>[<expr><name>len</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* write */</comment>
	<expr_stmt><expr><name>len</name> <operator>+=</operator> <literal type="number">8</literal></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>reportFlushPosition</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>fe_sendint64</name><argument_list>(<argument><expr><name>lastFlushPosition</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>replybuf</name><index>[<expr><name>len</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>	<comment type="block">/* flush */</comment>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>fe_sendint64</name><argument_list>(<argument><expr><name>InvalidXLogRecPtr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>replybuf</name><index>[<expr><name>len</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>	<comment type="block">/* flush */</comment>
	<expr_stmt><expr><name>len</name> <operator>+=</operator> <literal type="number">8</literal></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>fe_sendint64</name><argument_list>(<argument><expr><name>InvalidXLogRecPtr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>replybuf</name><index>[<expr><name>len</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>	<comment type="block">/* apply */</comment>
	<expr_stmt><expr><name>len</name> <operator>+=</operator> <literal type="number">8</literal></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>fe_sendint64</name><argument_list>(<argument><expr><name>now</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>replybuf</name><index>[<expr><name>len</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>	<comment type="block">/* sendTime */</comment>
	<expr_stmt><expr><name>len</name> <operator>+=</operator> <literal type="number">8</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>replybuf</name><index>[<expr><name>len</name></expr>]</index></name> <operator>=</operator> <ternary><condition><expr><name>replyRequested</name></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr>;</expr_stmt> <comment type="block">/* replyRequested */</comment>
	<expr_stmt><expr><name>len</name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>PQputCopyData</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>replybuf</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call> <operator>&lt;=</operator> <literal type="number">0</literal> <operator>||</operator> <call><name>PQflush</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: could not send feedback packet: %s"</literal></expr></argument>)</argument_list></call></expr></argument>,
				<argument><expr><name>progname</name></expr></argument>, <argument><expr><call><name>PQerrorMessage</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Check that the server version we're connected to is supported by
 * ReceiveXlogStream().
 *
 * If it's not, an error message is printed to stderr, and false is returned.
 */</comment>
<function><type><name>bool</name></type>
<name>CheckServerVersionForStreaming</name><parameter_list>(<parameter><decl><type><name>PGconn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>minServerMajor</name></decl>,
				<decl><type ref="prev"/><name>maxServerMajor</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>serverMajor</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * The message format used in streaming replication changed in 9.3, so we
	 * cannot stream from older servers. And we don't support servers newer
	 * than the client; it might work, but we don't know, so err on the safe
	 * side.
	 */</comment>
	<expr_stmt><expr><name>minServerMajor</name> <operator>=</operator> <literal type="number">903</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>maxServerMajor</name> <operator>=</operator> <name>PG_VERSION_NUM</name> <operator>/</operator> <literal type="number">100</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>serverMajor</name> <operator>=</operator> <call><name>PQserverVersion</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call> <operator>/</operator> <literal type="number">100</literal></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>serverMajor</name> <operator>&lt;</operator> <name>minServerMajor</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>serverver</name> <init>= <expr><call><name>PQparameterStatus</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><literal type="string">"server_version"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: incompatible server version %s; client does not support streaming from server versions older than %s\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
				<argument><expr><name>progname</name></expr></argument>,
				<argument><expr><ternary><condition><expr><name>serverver</name></expr> ?</condition><then> <expr><name>serverver</name></expr> </then><else>: <expr><literal type="string">"'unknown'"</literal></expr></else></ternary></expr></argument>,
				<argument><expr><literal type="string">"9.3"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>serverMajor</name> <operator>&gt;</operator> <name>maxServerMajor</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>serverver</name> <init>= <expr><call><name>PQparameterStatus</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><literal type="string">"server_version"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: incompatible server version %s; client does not support streaming from server versions newer than %s\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
				<argument><expr><name>progname</name></expr></argument>,
				<argument><expr><ternary><condition><expr><name>serverver</name></expr> ?</condition><then> <expr><name>serverver</name></expr> </then><else>: <expr><literal type="string">"'unknown'"</literal></expr></else></ternary></expr></argument>,
				<argument><expr><name>PG_VERSION</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Receive a log stream starting at the specified position.
 *
 * Individual parameters are passed through the StreamCtl structure.
 *
 * If sysidentifier is specified, validate that both the system
 * identifier and the timeline matches the specified ones
 * (by sending an extra IDENTIFY_SYSTEM command)
 *
 * All received segments will be written to the directory
 * specified by basedir. This will also fetch any missing timeline history
 * files.
 *
 * The stream_stop callback will be called every time data
 * is received, and whenever a segment is completed. If it returns
 * true, the streaming will stop and the function
 * return. As long as it returns false, streaming will continue
 * indefinitely.
 *
 * If stream_stop() checks for external input, stop_socket should be set to
 * the FD it checks.  This will allow such input to be detected promptly
 * rather than after standby_message_timeout (which might be indefinite).
 * Note that signals will interrupt waits for input as well, but that is
 * race-y since a signal received while busy won't interrupt the wait.
 *
 * standby_message_timeout controls how often we send a message
 * back to the master letting it know our progress, in milliseconds.
 * Zero means no messages are sent.
 * This message will only contain the write location, and never
 * flush or replay.
 *
 * If 'partial_suffix' is not NULL, files are initially created with the
 * given suffix, and the suffix is removed once the file is finished. That
 * allows you to tell the difference between partial and completed files,
 * so that you can continue later where you left.
 *
 * If 'synchronous' is true, the received WAL is flushed as soon as written,
 * otherwise only when the WAL file is closed.
 *
 * Note: The WAL location *must* be at a log segment start!
 */</comment>
<function><type><name>bool</name></type>
<name>ReceiveXlogStream</name><parameter_list>(<parameter><decl><type><name>PGconn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>, <parameter><decl><type><name>StreamCtl</name> <modifier>*</modifier></type><name>stream</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>query</name><index>[<expr><literal type="number">128</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>slotcmd</name><index>[<expr><literal type="number">128</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>XLogRecPtr</name></type>	<name>stoppos</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * The caller should've checked the server version already, but doesn't do
	 * any harm to check it here too.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>CheckServerVersionForStreaming</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Decide whether we want to report the flush position. If we report the
	 * flush position, the primary will know what WAL we'll possibly
	 * re-request, and it can then remove older WAL safely. We must always do
	 * that when we are using slots.
	 *
	 * Reporting the flush position makes one eligible as a synchronous
	 * replica. People shouldn't include generic names in
	 * synchronous_standby_names, but we've protected them against it so far,
	 * so let's continue to do so unless specifically requested.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>stream</name><operator>-&gt;</operator><name>replication_slot</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>reportFlushPosition</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>slotcmd</name></expr></argument>, <argument><expr><literal type="string">"SLOT \"%s\" "</literal></expr></argument>, <argument><expr><name><name>stream</name><operator>-&gt;</operator><name>replication_slot</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>stream</name><operator>-&gt;</operator><name>synchronous</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>reportFlushPosition</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>reportFlushPosition</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
		<expr_stmt><expr><name><name>slotcmd</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>stream</name><operator>-&gt;</operator><name>sysidentifier</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Validate system identifier hasn't changed */</comment>
		<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>PQexec</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><literal type="string">"IDENTIFY_SYSTEM"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>PQresultStatus</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>PGRES_TUPLES_OK</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>,
					<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: could not send replication command \"%s\": %s"</literal></expr></argument>)</argument_list></call></expr></argument>,
					<argument><expr><name>progname</name></expr></argument>, <argument><expr><literal type="string">"IDENTIFY_SYSTEM"</literal></expr></argument>, <argument><expr><call><name>PQerrorMessage</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>false</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>PQntuples</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">1</literal> <operator>||</operator> <call><name>PQnfields</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">3</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>,
					<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: could not identify system: got %d rows and %d fields, expected %d rows and %d or more fields\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
					<argument><expr><name>progname</name></expr></argument>, <argument><expr><call><name>PQntuples</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>PQnfields</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>false</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>stream</name><operator>-&gt;</operator><name>sysidentifier</name></name></expr></argument>, <argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>,
					<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: system identifier does not match between base backup and streaming connection\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
					<argument><expr><name>progname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>false</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>stream</name><operator>-&gt;</operator><name>timeline</name></name> <operator>&gt;</operator> <call><name>atoi</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>,
					<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: starting timeline %u is not present in the server\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
					<argument><expr><name>progname</name></expr></argument>, <argument><expr><name><name>stream</name><operator>-&gt;</operator><name>timeline</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>false</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * initialize flush position to starting point, it's the caller's
	 * responsibility that that's sane.
	 */</comment>
	<expr_stmt><expr><name>lastFlushPosition</name> <operator>=</operator> <name><name>stream</name><operator>-&gt;</operator><name>startpos</name></name></expr>;</expr_stmt>

	<while>while <condition>(<expr><literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Fetch the timeline history file for this timeline, if we don't have
		 * it already. When streaming log to tar, this will always return
		 * false, as we are never streaming into an existing file and
		 * therefore there can be no pre-existing timeline history file.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>existsTimeLineHistoryFile</name><argument_list>(<argument><expr><name>stream</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"TIMELINE_HISTORY %u"</literal></expr></argument>, <argument><expr><name><name>stream</name><operator>-&gt;</operator><name>timeline</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>PQexec</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><call><name>PQresultStatus</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>PGRES_TUPLES_OK</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* FIXME: we might send it ok, but get an error */</comment>
				<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: could not send replication command \"%s\": %s"</literal></expr></argument>)</argument_list></call></expr></argument>,
						<argument><expr><name>progname</name></expr></argument>, <argument><expr><literal type="string">"TIMELINE_HISTORY"</literal></expr></argument>, <argument><expr><call><name>PQresultErrorMessage</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr><name>false</name></expr>;</return>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/*
			 * The response to TIMELINE_HISTORY is a single row result set
			 * with two fields: filename and content
			 */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>PQnfields</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">2</literal> <operator>||</operator> <call><name>PQntuples</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>,
						<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: unexpected response to TIMELINE_HISTORY command: got %d rows and %d fields, expected %d rows and %d fields\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
						<argument><expr><name>progname</name></expr></argument>, <argument><expr><call><name>PQntuples</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>PQnfields</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/* Write the history file to disk */</comment>
			<expr_stmt><expr><call><name>writeTimeLineHistoryFile</name><argument_list>(<argument><expr><name>stream</name></expr></argument>,
									 <argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>,
									 <argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * Before we start streaming from the requested location, check if the
		 * callback tells us to stop here.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name><name>stream</name><operator>-&gt;</operator><name>stream_stop</name></name><argument_list>(<argument><expr><name><name>stream</name><operator>-&gt;</operator><name>startpos</name></name></expr></argument>, <argument><expr><name><name>stream</name><operator>-&gt;</operator><name>timeline</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

		<comment type="block">/* Initiate the replication stream at specified location */</comment>
		<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"START_REPLICATION %s%X/%X TIMELINE %u"</literal></expr></argument>,
				 <argument><expr><name>slotcmd</name></expr></argument>,
				 <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <operator>(</operator><name><name>stream</name><operator>-&gt;</operator><name>startpos</name></name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr></argument>, <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <name><name>stream</name><operator>-&gt;</operator><name>startpos</name></name></expr></argument>,
				 <argument><expr><name><name>stream</name><operator>-&gt;</operator><name>timeline</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>PQexec</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>PQresultStatus</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>PGRES_COPY_BOTH</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: could not send replication command \"%s\": %s"</literal></expr></argument>)</argument_list></call></expr></argument>,
					<argument><expr><name>progname</name></expr></argument>, <argument><expr><literal type="string">"START_REPLICATION"</literal></expr></argument>, <argument><expr><call><name>PQresultErrorMessage</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>false</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Stream the WAL */</comment>
		<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>HandleCopyStream</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>stream</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>stoppos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>res</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<goto>goto <name>error</name>;</goto></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * Streaming finished.
		 *
		 * There are two possible reasons for that: a controlled shutdown, or
		 * we reached the end of the current timeline. In case of
		 * end-of-timeline, the server sends a result set after Copy has
		 * finished, containing information about the next timeline. Read
		 * that, and restart streaming from the next timeline. In case of
		 * controlled shutdown, stop here.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>PQresultStatus</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>PGRES_TUPLES_OK</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * End-of-timeline. Read the next timeline's ID and starting
			 * position. Usually, the starting position will match the end of
			 * the previous timeline, but there are corner cases like if the
			 * server had sent us half of a WAL record, when it was promoted.
			 * The new timeline will begin at the end of the last complete
			 * record in that case, overlapping the partial WAL record on the
			 * old timeline.
			 */</comment>
			<decl_stmt><decl><type><name>uint32</name></type>		<name>newtimeline</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>bool</name></type>		<name>parsed</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>parsed</name> <operator>=</operator> <call><name>ReadEndOfStreamingResult</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>stream</name><operator>-&gt;</operator><name>startpos</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>newtimeline</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>parsed</name></expr>)</condition><block type="pseudo"><block_content>
				<goto>goto <name>error</name>;</goto></block_content></block></if></if_stmt>

			<comment type="block">/* Sanity check the values the server gave us */</comment>
			<if_stmt><if>if <condition>(<expr><name>newtimeline</name> <operator>&lt;=</operator> <name><name>stream</name><operator>-&gt;</operator><name>timeline</name></name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>,
						<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: server reported unexpected next timeline %u, following timeline %u\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
						<argument><expr><name>progname</name></expr></argument>, <argument><expr><name>newtimeline</name></expr></argument>, <argument><expr><name><name>stream</name><operator>-&gt;</operator><name>timeline</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<goto>goto <name>error</name>;</goto>
			</block_content>}</block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>stream</name><operator>-&gt;</operator><name>startpos</name></name> <operator>&gt;</operator> <name>stoppos</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>,
						<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: server stopped streaming timeline %u at %X/%X, but reported next timeline %u to begin at %X/%X\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
						<argument><expr><name>progname</name></expr></argument>,
						<argument><expr><name><name>stream</name><operator>-&gt;</operator><name>timeline</name></name></expr></argument>, <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <operator>(</operator><name>stoppos</name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr></argument>, <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <name>stoppos</name></expr></argument>,
						<argument><expr><name>newtimeline</name></expr></argument>, <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <operator>(</operator><name><name>stream</name><operator>-&gt;</operator><name>startpos</name></name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr></argument>, <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <name><name>stream</name><operator>-&gt;</operator><name>startpos</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<goto>goto <name>error</name>;</goto>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/* Read the final result, which should be CommandComplete. */</comment>
			<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>PQgetResult</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><call><name>PQresultStatus</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>PGRES_COMMAND_OK</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>,
						<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: unexpected termination of replication stream: %s"</literal></expr></argument>)</argument_list></call></expr></argument>,
						<argument><expr><name>progname</name></expr></argument>, <argument><expr><call><name>PQresultErrorMessage</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<goto>goto <name>error</name>;</goto>
			</block_content>}</block></if></if_stmt>
			<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * Loop back to start streaming from the new timeline. Always
			 * start streaming at the beginning of a segment.
			 */</comment>
			<expr_stmt><expr><name><name>stream</name><operator>-&gt;</operator><name>timeline</name></name> <operator>=</operator> <name>newtimeline</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>stream</name><operator>-&gt;</operator><name>startpos</name></name> <operator>=</operator> <name><name>stream</name><operator>-&gt;</operator><name>startpos</name></name> <operator>-</operator>
				<call><name>XLogSegmentOffset</name><argument_list>(<argument><expr><name><name>stream</name><operator>-&gt;</operator><name>startpos</name></name></expr></argument>, <argument><expr><name>WalSegSz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<continue>continue;</continue>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><call><name>PQresultStatus</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>PGRES_COMMAND_OK</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * End of replication (ie. controlled shut down of the server).
			 *
			 * Check if the callback thinks it's OK to stop here. If not,
			 * complain.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><call><name><name>stream</name><operator>-&gt;</operator><name>stream_stop</name></name><argument_list>(<argument><expr><name>stoppos</name></expr></argument>, <argument><expr><name><name>stream</name><operator>-&gt;</operator><name>timeline</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>true</name></expr>;</return></block_content></block></if>
			<else>else
			<block>{<block_content>
				<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: replication stream was terminated before stop point\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
						<argument><expr><name>progname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<goto>goto <name>error</name>;</goto>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/* Server returned an error. */</comment>
			<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>,
					<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: unexpected termination of replication stream: %s"</literal></expr></argument>)</argument_list></call></expr></argument>,
					<argument><expr><name>progname</name></expr></argument>, <argument><expr><call><name>PQresultErrorMessage</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<goto>goto <name>error</name>;</goto>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></while>

<label><name>error</name>:</label>
	<if_stmt><if>if <condition>(<expr><name>walfile</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <call><name><name>stream</name><operator>-&gt;</operator><name>walmethod</name><operator>-&gt;</operator><name>close</name></name><argument_list>(<argument><expr><name>walfile</name></expr></argument>, <argument><expr><name>CLOSE_NO_RENAME</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: could not close file \"%s\": %s\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
				<argument><expr><name>progname</name></expr></argument>, <argument><expr><name>current_walfile_name</name></expr></argument>, <argument><expr><call><name><name>stream</name><operator>-&gt;</operator><name>walmethod</name><operator>-&gt;</operator><name>getlasterror</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>walfile</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Helper function to parse the result set returned by server after streaming
 * has finished. On failure, prints an error to stderr and returns false.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>ReadEndOfStreamingResult</name><parameter_list>(<parameter><decl><type><name>PGresult</name> <modifier>*</modifier></type><name>res</name></decl></parameter>, <parameter><decl><type><name>XLogRecPtr</name> <modifier>*</modifier></type><name>startpos</name></decl></parameter>, <parameter><decl><type><name>uint32</name> <modifier>*</modifier></type><name>timeline</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>uint32</name></type>		<name>startpos_xlogid</name></decl>,
				<decl><type ref="prev"/><name>startpos_xrecoff</name></decl>;</decl_stmt>

	<comment type="block">/*----------
	 * The result set consists of one row and two columns, e.g:
	 *
	 *	next_tli | next_tli_startpos
	 * ----------+-------------------
	 *		   4 | 0/9949AE0
	 *
	 * next_tli is the timeline ID of the next timeline after the one that
	 * just finished streaming. next_tli_startpos is the WAL location where
	 * the server switched to it.
	 *----------
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>PQnfields</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">2</literal> <operator>||</operator> <call><name>PQntuples</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>,
				<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: unexpected result set after end-of-timeline: got %d rows and %d fields, expected %d rows and %d fields\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
				<argument><expr><name>progname</name></expr></argument>, <argument><expr><call><name>PQntuples</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>PQnfields</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><operator>*</operator><name>timeline</name> <operator>=</operator> <call><name>atoi</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>sscanf</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"%X/%X"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>startpos_xlogid</name></expr></argument>,
			   <argument><expr><operator>&amp;</operator><name>startpos_xrecoff</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">2</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>,
				<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: could not parse next timeline's starting point \"%s\"\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
				<argument><expr><name>progname</name></expr></argument>, <argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><operator>*</operator><name>startpos</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>uint64</name><operator>)</operator> <name>startpos_xlogid</name> <operator>&lt;&lt;</operator> <literal type="number">32</literal><operator>)</operator> <operator>|</operator> <name>startpos_xrecoff</name></expr>;</expr_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * The main loop of ReceiveXlogStream. Handles the COPY stream after
 * initiating streaming with the START_REPLICATION command.
 *
 * If the COPY ends (not necessarily successfully) due a message from the
 * server, returns a PGresult and sets *stoppos to the last byte written.
 * On any other sort of error, returns NULL.
 */</comment>
<function><type><specifier>static</specifier> <name>PGresult</name> <modifier>*</modifier></type>
<name>HandleCopyStream</name><parameter_list>(<parameter><decl><type><name>PGconn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>, <parameter><decl><type><name>StreamCtl</name> <modifier>*</modifier></type><name>stream</name></decl></parameter>,
				 <parameter><decl><type><name>XLogRecPtr</name> <modifier>*</modifier></type><name>stoppos</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>copybuf</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TimestampTz</name></type> <name>last_status</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>XLogRecPtr</name></type>	<name>blockpos</name> <init>= <expr><name><name>stream</name><operator>-&gt;</operator><name>startpos</name></name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>still_sending</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

	<while>while <condition>(<expr><literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>r</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>TimestampTz</name></type> <name>now</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>long</name></type>		<name>sleeptime</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * Check if we should continue streaming, or abort at this point.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>CheckCopyStreamStop</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>stream</name></expr></argument>, <argument><expr><name>blockpos</name></expr></argument>, <argument><expr><name>stoppos</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<goto>goto <name>error</name>;</goto></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>now</name> <operator>=</operator> <call><name>feGetCurrentTimestamp</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * If synchronous option is true, issue sync command as soon as there
		 * are WAL data which has not been flushed yet.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>stream</name><operator>-&gt;</operator><name>synchronous</name></name> <operator>&amp;&amp;</operator> <name>lastFlushPosition</name> <operator>&lt;</operator> <name>blockpos</name> <operator>&amp;&amp;</operator> <name>walfile</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><call><name><name>stream</name><operator>-&gt;</operator><name>walmethod</name><operator>-&gt;</operator><name>sync</name></name><argument_list>(<argument><expr><name>walfile</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: could not fsync file \"%s\": %s\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
						<argument><expr><name>progname</name></expr></argument>, <argument><expr><name>current_walfile_name</name></expr></argument>, <argument><expr><call><name><name>stream</name><operator>-&gt;</operator><name>walmethod</name><operator>-&gt;</operator><name>getlasterror</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<goto>goto <name>error</name>;</goto>
			</block_content>}</block></if></if_stmt>
			<expr_stmt><expr><name>lastFlushPosition</name> <operator>=</operator> <name>blockpos</name></expr>;</expr_stmt>

			<comment type="block">/*
			 * Send feedback so that the server sees the latest WAL locations
			 * immediately.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>sendFeedback</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>blockpos</name></expr></argument>, <argument><expr><name>now</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<goto>goto <name>error</name>;</goto></block_content></block></if></if_stmt>
			<expr_stmt><expr><name>last_status</name> <operator>=</operator> <name>now</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * Potentially send a status message to the master
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>still_sending</name> <operator>&amp;&amp;</operator> <name><name>stream</name><operator>-&gt;</operator><name>standby_message_timeout</name></name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
			<call><name>feTimestampDifferenceExceeds</name><argument_list>(<argument><expr><name>last_status</name></expr></argument>, <argument><expr><name>now</name></expr></argument>,
										 <argument><expr><name><name>stream</name><operator>-&gt;</operator><name>standby_message_timeout</name></name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Time to send feedback! */</comment>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>sendFeedback</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>blockpos</name></expr></argument>, <argument><expr><name>now</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<goto>goto <name>error</name>;</goto></block_content></block></if></if_stmt>
			<expr_stmt><expr><name>last_status</name> <operator>=</operator> <name>now</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * Calculate how long send/receive loops should sleep
		 */</comment>
		<expr_stmt><expr><name>sleeptime</name> <operator>=</operator> <call><name>CalculateCopyStreamSleeptime</name><argument_list>(<argument><expr><name>now</name></expr></argument>, <argument><expr><name><name>stream</name><operator>-&gt;</operator><name>standby_message_timeout</name></name></expr></argument>,
												 <argument><expr><name>last_status</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>CopyStreamReceive</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>sleeptime</name></expr></argument>, <argument><expr><name><name>stream</name><operator>-&gt;</operator><name>stop_socket</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>copybuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<while>while <condition>(<expr><name>r</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>r</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
				<goto>goto <name>error</name>;</goto></block_content></block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><name>r</name> <operator>==</operator> <operator>-</operator><literal type="number">2</literal></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier></type><name>res</name> <init>= <expr><call><name>HandleEndOfCopyStream</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>stream</name></expr></argument>, <argument><expr><name>copybuf</name></expr></argument>, <argument><expr><name>blockpos</name></expr></argument>, <argument><expr><name>stoppos</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><name>res</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
					<goto>goto <name>error</name>;</goto></block_content></block></if>
				<else>else<block type="pseudo"><block_content>
					<return>return <expr><name>res</name></expr>;</return></block_content></block></else></if_stmt>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/* Check the message type. */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>copybuf</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'k'</literal></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ProcessKeepaliveMsg</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>stream</name></expr></argument>, <argument><expr><name>copybuf</name></expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><name>blockpos</name></expr></argument>,
										 <argument><expr><operator>&amp;</operator><name>last_status</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<goto>goto <name>error</name>;</goto></block_content></block></if></if_stmt>
			</block_content>}</block></if>
			<if type="elseif">else if <condition>(<expr><name><name>copybuf</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'w'</literal></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ProcessXLogDataMsg</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>stream</name></expr></argument>, <argument><expr><name>copybuf</name></expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>blockpos</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<goto>goto <name>error</name>;</goto></block_content></block></if></if_stmt>

				<comment type="block">/*
				 * Check if we should continue streaming, or abort at this
				 * point.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>CheckCopyStreamStop</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>stream</name></expr></argument>, <argument><expr><name>blockpos</name></expr></argument>, <argument><expr><name>stoppos</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<goto>goto <name>error</name>;</goto></block_content></block></if></if_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: unrecognized streaming header: \"%c\"\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
						<argument><expr><name>progname</name></expr></argument>, <argument><expr><name><name>copybuf</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<goto>goto <name>error</name>;</goto>
			</block_content>}</block></else></if_stmt>

			<comment type="block">/*
			 * Process the received data, and any subsequent data we can read
			 * without blocking.
			 */</comment>
			<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>CopyStreamReceive</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>stream</name><operator>-&gt;</operator><name>stop_socket</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>copybuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></while>
	</block_content>}</block></while>

<label><name>error</name>:</label>
	<if_stmt><if>if <condition>(<expr><name>copybuf</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PQfreemem</name><argument_list>(<argument><expr><name>copybuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Wait until we can read a CopyData message,
 * or timeout, or occurrence of a signal or input on the stop_socket.
 * (timeout_ms &lt; 0 means wait indefinitely; 0 means don't wait.)
 *
 * Returns 1 if data has become available for reading, 0 if timed out
 * or interrupted by signal or stop_socket input, and -1 on an error.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>CopyStreamPoll</name><parameter_list>(<parameter><decl><type><name>PGconn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>, <parameter><decl><type><name>long</name></type> <name>timeout_ms</name></decl></parameter>, <parameter><decl><type><name>pgsocket</name></type> <name>stop_socket</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>ret</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>fd_set</name></type>		<name>input_mask</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>connsocket</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>maxfd</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>timeval</name></name></type> <name>timeout</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>timeval</name></name> <modifier>*</modifier></type><name>timeoutptr</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>connsocket</name> <operator>=</operator> <call><name>PQsocket</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>connsocket</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: invalid socket: %s"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>progname</name></expr></argument>,
				<argument><expr><call><name>PQerrorMessage</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>FD_ZERO</name><argument_list>(<argument><expr><operator>&amp;</operator><name>input_mask</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>FD_SET</name><argument_list>(<argument><expr><name>connsocket</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>input_mask</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>maxfd</name> <operator>=</operator> <name>connsocket</name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>stop_socket</name> <operator>!=</operator> <name>PGINVALID_SOCKET</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>FD_SET</name><argument_list>(<argument><expr><name>stop_socket</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>input_mask</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>maxfd</name> <operator>=</operator> <call><name>Max</name><argument_list>(<argument><expr><name>maxfd</name></expr></argument>, <argument><expr><name>stop_socket</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>timeout_ms</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>timeoutptr</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name><name>timeout</name><operator>.</operator><name>tv_sec</name></name> <operator>=</operator> <name>timeout_ms</name> <operator>/</operator> <literal type="number">1000L</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>timeout</name><operator>.</operator><name>tv_usec</name></name> <operator>=</operator> <operator>(</operator><name>timeout_ms</name> <operator>%</operator> <literal type="number">1000L</literal><operator>)</operator> <operator>*</operator> <literal type="number">1000L</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name>timeoutptr</name> <operator>=</operator> <operator>&amp;</operator><name>timeout</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>select</name><argument_list>(<argument><expr><name>maxfd</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>input_mask</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>timeoutptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>errno</name> <operator>==</operator> <name>EINTR</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>			<comment type="block">/* Got a signal, so not an error */</comment>
		<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: select() failed: %s\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
				<argument><expr><name>progname</name></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <call><name>FD_ISSET</name><argument_list>(<argument><expr><name>connsocket</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>input_mask</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>				<comment type="block">/* Got input on connection socket */</comment>

	<return>return <expr><literal type="number">0</literal></expr>;</return>					<comment type="block">/* Got timeout or input on stop_socket */</comment>
</block_content>}</block></function>

<comment type="block">/*
 * Receive CopyData message available from XLOG stream, blocking for
 * maximum of 'timeout' ms.
 *
 * If data was received, returns the length of the data. *buffer is set to
 * point to a buffer holding the received message. The buffer is only valid
 * until the next CopyStreamReceive call.
 *
 * Returns 0 if no data was available within timeout, or if wait was
 * interrupted by signal or stop_socket input.
 * -1 on error. -2 if the server ended the COPY.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>CopyStreamReceive</name><parameter_list>(<parameter><decl><type><name>PGconn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>, <parameter><decl><type><name>long</name></type> <name>timeout</name></decl></parameter>, <parameter><decl><type><name>pgsocket</name></type> <name>stop_socket</name></decl></parameter>,
				  <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>buffer</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>copybuf</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>rawlen</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>*</operator><name>buffer</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PQfreemem</name><argument_list>(<argument><expr><operator>*</operator><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><operator>*</operator><name>buffer</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<comment type="block">/* Try to receive a CopyData message */</comment>
	<expr_stmt><expr><name>rawlen</name> <operator>=</operator> <call><name>PQgetCopyData</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>copybuf</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>rawlen</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>ret</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * No data available.  Wait for some to appear, but not longer than
		 * the specified timeout, so that we can ping the server.  Also stop
		 * waiting if input appears on stop_socket.
		 */</comment>
		<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>CopyStreamPoll</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>timeout</name></expr></argument>, <argument><expr><name>stop_socket</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>ret</name></expr>;</return></block_content></block></if></if_stmt>

		<comment type="block">/* Now there is actually data on the socket */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>PQconsumeInput</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>,
					<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: could not receive data from WAL stream: %s"</literal></expr></argument>)</argument_list></call></expr></argument>,
					<argument><expr><name>progname</name></expr></argument>, <argument><expr><call><name>PQerrorMessage</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* Now that we've consumed some input, try again */</comment>
		<expr_stmt><expr><name>rawlen</name> <operator>=</operator> <call><name>PQgetCopyData</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>copybuf</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>rawlen</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>rawlen</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>			<comment type="block">/* end-of-streaming or error */</comment>
		<return>return <expr><operator>-</operator><literal type="number">2</literal></expr>;</return></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>rawlen</name> <operator>==</operator> <operator>-</operator><literal type="number">2</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: could not read COPY data: %s"</literal></expr></argument>)</argument_list></call></expr></argument>,
				<argument><expr><name>progname</name></expr></argument>, <argument><expr><call><name>PQerrorMessage</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Return received messages to caller */</comment>
	<expr_stmt><expr><operator>*</operator><name>buffer</name> <operator>=</operator> <name>copybuf</name></expr>;</expr_stmt>
	<return>return <expr><name>rawlen</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Process the keepalive message.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>ProcessKeepaliveMsg</name><parameter_list>(<parameter><decl><type><name>PGconn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>, <parameter><decl><type><name>StreamCtl</name> <modifier>*</modifier></type><name>stream</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>copybuf</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>len</name></decl></parameter>,
					<parameter><decl><type><name>XLogRecPtr</name></type> <name>blockpos</name></decl></parameter>, <parameter><decl><type><name>TimestampTz</name> <modifier>*</modifier></type><name>last_status</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>pos</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>replyRequested</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TimestampTz</name></type> <name>now</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Parse the keepalive message, enclosed in the CopyData message. We just
	 * check if the server requested a reply, and ignore the rest.
	 */</comment>
	<expr_stmt><expr><name>pos</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>					<comment type="block">/* skip msgtype 'k' */</comment>
	<expr_stmt><expr><name>pos</name> <operator>+=</operator> <literal type="number">8</literal></expr>;</expr_stmt>					<comment type="block">/* skip walEnd */</comment>
	<expr_stmt><expr><name>pos</name> <operator>+=</operator> <literal type="number">8</literal></expr>;</expr_stmt>					<comment type="block">/* skip sendTime */</comment>

	<if_stmt><if>if <condition>(<expr><name>len</name> <operator>&lt;</operator> <name>pos</name> <operator>+</operator> <literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: streaming header too small: %d\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
				<argument><expr><name>progname</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name>replyRequested</name> <operator>=</operator> <name><name>copybuf</name><index>[<expr><name>pos</name></expr>]</index></name></expr>;</expr_stmt>

	<comment type="block">/* If the server requested an immediate reply, send one. */</comment>
	<if_stmt><if>if <condition>(<expr><name>replyRequested</name> <operator>&amp;&amp;</operator> <name>still_sending</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>reportFlushPosition</name> <operator>&amp;&amp;</operator> <name>lastFlushPosition</name> <operator>&lt;</operator> <name>blockpos</name> <operator>&amp;&amp;</operator>
			<name>walfile</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * If a valid flush location needs to be reported, flush the
			 * current WAL file so that the latest flush location is sent back
			 * to the server. This is necessary to see whether the last WAL
			 * data has been successfully replicated or not, at the normal
			 * shutdown of the server.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><call><name><name>stream</name><operator>-&gt;</operator><name>walmethod</name><operator>-&gt;</operator><name>sync</name></name><argument_list>(<argument><expr><name>walfile</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: could not fsync file \"%s\": %s\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
						<argument><expr><name>progname</name></expr></argument>, <argument><expr><name>current_walfile_name</name></expr></argument>, <argument><expr><call><name><name>stream</name><operator>-&gt;</operator><name>walmethod</name><operator>-&gt;</operator><name>getlasterror</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr><name>false</name></expr>;</return>
			</block_content>}</block></if></if_stmt>
			<expr_stmt><expr><name>lastFlushPosition</name> <operator>=</operator> <name>blockpos</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name>now</name> <operator>=</operator> <call><name>feGetCurrentTimestamp</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>sendFeedback</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>blockpos</name></expr></argument>, <argument><expr><name>now</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
		<expr_stmt><expr><operator>*</operator><name>last_status</name> <operator>=</operator> <name>now</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Process XLogData message.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>ProcessXLogDataMsg</name><parameter_list>(<parameter><decl><type><name>PGconn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>, <parameter><decl><type><name>StreamCtl</name> <modifier>*</modifier></type><name>stream</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>copybuf</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>len</name></decl></parameter>,
				   <parameter><decl><type><name>XLogRecPtr</name> <modifier>*</modifier></type><name>blockpos</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>xlogoff</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>bytes_left</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>bytes_written</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>hdr_len</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Once we've decided we don't want to receive any more, just ignore any
	 * subsequent XLogData messages.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>still_sending</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Read the header of the XLogData message, enclosed in the CopyData
	 * message. We only need the WAL location field (dataStart), the rest of
	 * the header is ignored.
	 */</comment>
	<expr_stmt><expr><name>hdr_len</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>				<comment type="block">/* msgtype 'w' */</comment>
	<expr_stmt><expr><name>hdr_len</name> <operator>+=</operator> <literal type="number">8</literal></expr>;</expr_stmt>				<comment type="block">/* dataStart */</comment>
	<expr_stmt><expr><name>hdr_len</name> <operator>+=</operator> <literal type="number">8</literal></expr>;</expr_stmt>				<comment type="block">/* walEnd */</comment>
	<expr_stmt><expr><name>hdr_len</name> <operator>+=</operator> <literal type="number">8</literal></expr>;</expr_stmt>				<comment type="block">/* sendTime */</comment>
	<if_stmt><if>if <condition>(<expr><name>len</name> <operator>&lt;</operator> <name>hdr_len</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: streaming header too small: %d\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
				<argument><expr><name>progname</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><operator>*</operator><name>blockpos</name> <operator>=</operator> <call><name>fe_recvint64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>copybuf</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Extract WAL location for this block */</comment>
	<expr_stmt><expr><name>xlogoff</name> <operator>=</operator> <call><name>XLogSegmentOffset</name><argument_list>(<argument><expr><operator>*</operator><name>blockpos</name></expr></argument>, <argument><expr><name>WalSegSz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Verify that the initial location in the stream matches where we think
	 * we are.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>walfile</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* No file open yet */</comment>
		<if_stmt><if>if <condition>(<expr><name>xlogoff</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>,
					<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: received write-ahead log record for offset %u with no file open\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
					<argument><expr><name>progname</name></expr></argument>, <argument><expr><name>xlogoff</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>false</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* More data in existing segment */</comment>
		<if_stmt><if>if <condition>(<expr><call><name><name>stream</name><operator>-&gt;</operator><name>walmethod</name><operator>-&gt;</operator><name>get_current_pos</name></name><argument_list>(<argument><expr><name>walfile</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>xlogoff</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>,
					<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: got WAL data offset %08x, expected %08x\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
					<argument><expr><name>progname</name></expr></argument>, <argument><expr><name>xlogoff</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <call><name><name>stream</name><operator>-&gt;</operator><name>walmethod</name><operator>-&gt;</operator><name>get_current_pos</name></name><argument_list>(<argument><expr><name>walfile</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>false</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><name>bytes_left</name> <operator>=</operator> <name>len</name> <operator>-</operator> <name>hdr_len</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>bytes_written</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<while>while <condition>(<expr><name>bytes_left</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>bytes_to_write</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * If crossing a WAL boundary, only write up until we reach wal
		 * segment size.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>xlogoff</name> <operator>+</operator> <name>bytes_left</name> <operator>&gt;</operator> <name>WalSegSz</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>bytes_to_write</name> <operator>=</operator> <name>WalSegSz</name> <operator>-</operator> <name>xlogoff</name></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>bytes_to_write</name> <operator>=</operator> <name>bytes_left</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>walfile</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>open_walfile</name><argument_list>(<argument><expr><name>stream</name></expr></argument>, <argument><expr><operator>*</operator><name>blockpos</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* Error logged by open_walfile */</comment>
				<return>return <expr><name>false</name></expr>;</return>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><call><name><name>stream</name><operator>-&gt;</operator><name>walmethod</name><operator>-&gt;</operator><name>write</name></name><argument_list>(<argument><expr><name>walfile</name></expr></argument>, <argument><expr><name>copybuf</name> <operator>+</operator> <name>hdr_len</name> <operator>+</operator> <name>bytes_written</name></expr></argument>,
									 <argument><expr><name>bytes_to_write</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>bytes_to_write</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>,
					<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: could not write %u bytes to WAL file \"%s\": %s\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
					<argument><expr><name>progname</name></expr></argument>, <argument><expr><name>bytes_to_write</name></expr></argument>, <argument><expr><name>current_walfile_name</name></expr></argument>,
					<argument><expr><call><name><name>stream</name><operator>-&gt;</operator><name>walmethod</name><operator>-&gt;</operator><name>getlasterror</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>false</name></expr>;</return>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* Write was successful, advance our position */</comment>
		<expr_stmt><expr><name>bytes_written</name> <operator>+=</operator> <name>bytes_to_write</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>bytes_left</name> <operator>-=</operator> <name>bytes_to_write</name></expr>;</expr_stmt>
		<expr_stmt><expr><operator>*</operator><name>blockpos</name> <operator>+=</operator> <name>bytes_to_write</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>xlogoff</name> <operator>+=</operator> <name>bytes_to_write</name></expr>;</expr_stmt>

		<comment type="block">/* Did we reach the end of a WAL segment? */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>XLogSegmentOffset</name><argument_list>(<argument><expr><operator>*</operator><name>blockpos</name></expr></argument>, <argument><expr><name>WalSegSz</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>close_walfile</name><argument_list>(<argument><expr><name>stream</name></expr></argument>, <argument><expr><operator>*</operator><name>blockpos</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<comment type="block">/* Error message written in close_walfile() */</comment>
				<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

			<expr_stmt><expr><name>xlogoff</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name>still_sending</name> <operator>&amp;&amp;</operator> <call><name><name>stream</name><operator>-&gt;</operator><name>stream_stop</name></name><argument_list>(<argument><expr><operator>*</operator><name>blockpos</name></expr></argument>, <argument><expr><name><name>stream</name><operator>-&gt;</operator><name>timeline</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><call><name>PQputCopyEnd</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call> <operator>&lt;=</operator> <literal type="number">0</literal> <operator>||</operator> <call><name>PQflush</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: could not send copy-end packet: %s"</literal></expr></argument>)</argument_list></call></expr></argument>,
							<argument><expr><name>progname</name></expr></argument>, <argument><expr><call><name>PQerrorMessage</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<return>return <expr><name>false</name></expr>;</return>
				</block_content>}</block></if></if_stmt>
				<expr_stmt><expr><name>still_sending</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
				<return>return <expr><name>true</name></expr>;</return>	<comment type="block">/* ignore the rest of this XLogData packet */</comment>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></while>
	<comment type="block">/* No more data left to write, receive next copy packet */</comment>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Handle end of the copy stream.
 */</comment>
<function><type><specifier>static</specifier> <name>PGresult</name> <modifier>*</modifier></type>
<name>HandleEndOfCopyStream</name><parameter_list>(<parameter><decl><type><name>PGconn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>, <parameter><decl><type><name>StreamCtl</name> <modifier>*</modifier></type><name>stream</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>copybuf</name></decl></parameter>,
					  <parameter><decl><type><name>XLogRecPtr</name></type> <name>blockpos</name></decl></parameter>, <parameter><decl><type><name>XLogRecPtr</name> <modifier>*</modifier></type><name>stoppos</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier></type><name>res</name> <init>= <expr><call><name>PQgetResult</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * The server closed its end of the copy stream.  If we haven't closed
	 * ours already, we need to do so now, unless the server threw an error,
	 * in which case we don't.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>still_sending</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>close_walfile</name><argument_list>(<argument><expr><name>stream</name></expr></argument>, <argument><expr><name>blockpos</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Error message written in close_walfile() */</comment>
			<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>NULL</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>PQresultStatus</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>PGRES_COPY_IN</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><call><name>PQputCopyEnd</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call> <operator>&lt;=</operator> <literal type="number">0</literal> <operator>||</operator> <call><name>PQflush</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>,
						<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: could not send copy-end packet: %s"</literal></expr></argument>)</argument_list></call></expr></argument>,
						<argument><expr><name>progname</name></expr></argument>, <argument><expr><call><name>PQerrorMessage</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr><name>NULL</name></expr>;</return>
			</block_content>}</block></if></if_stmt>
			<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>PQgetResult</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><name>still_sending</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>copybuf</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PQfreemem</name><argument_list>(<argument><expr><name>copybuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><operator>*</operator><name>stoppos</name> <operator>=</operator> <name>blockpos</name></expr>;</expr_stmt>
	<return>return <expr><name>res</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Check if we should continue streaming, or abort at this point.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>CheckCopyStreamStop</name><parameter_list>(<parameter><decl><type><name>PGconn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>, <parameter><decl><type><name>StreamCtl</name> <modifier>*</modifier></type><name>stream</name></decl></parameter>, <parameter><decl><type><name>XLogRecPtr</name></type> <name>blockpos</name></decl></parameter>,
					<parameter><decl><type><name>XLogRecPtr</name> <modifier>*</modifier></type><name>stoppos</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>still_sending</name> <operator>&amp;&amp;</operator> <call><name><name>stream</name><operator>-&gt;</operator><name>stream_stop</name></name><argument_list>(<argument><expr><name>blockpos</name></expr></argument>, <argument><expr><name><name>stream</name><operator>-&gt;</operator><name>timeline</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>close_walfile</name><argument_list>(<argument><expr><name>stream</name></expr></argument>, <argument><expr><name>blockpos</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Potential error message is written by close_walfile */</comment>
			<return>return <expr><name>false</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>PQputCopyEnd</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call> <operator>&lt;=</operator> <literal type="number">0</literal> <operator>||</operator> <call><name>PQflush</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: could not send copy-end packet: %s"</literal></expr></argument>)</argument_list></call></expr></argument>,
					<argument><expr><name>progname</name></expr></argument>, <argument><expr><call><name>PQerrorMessage</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>false</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><name>still_sending</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Calculate how long send/receive loops should sleep
 */</comment>
<function><type><specifier>static</specifier> <name>long</name></type>
<name>CalculateCopyStreamSleeptime</name><parameter_list>(<parameter><decl><type><name>TimestampTz</name></type> <name>now</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>standby_message_timeout</name></decl></parameter>,
							 <parameter><decl><type><name>TimestampTz</name></type> <name>last_status</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TimestampTz</name></type> <name>status_targettime</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>long</name></type>		<name>sleeptime</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>standby_message_timeout</name> <operator>&amp;&amp;</operator> <name>still_sending</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>status_targettime</name> <operator>=</operator> <name>last_status</name> <operator>+</operator>
			<operator>(</operator><name>standby_message_timeout</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator> <operator>*</operator> <operator>(</operator><operator>(</operator><name>int64</name><operator>)</operator> <literal type="number">1000</literal><operator>)</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>status_targettime</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>long</name></type>		<name>secs</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>usecs</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>feTimestampDifference</name><argument_list>(<argument><expr><name>now</name></expr></argument>,
							  <argument><expr><name>status_targettime</name></expr></argument>,
							  <argument><expr><operator>&amp;</operator><name>secs</name></expr></argument>,
							  <argument><expr><operator>&amp;</operator><name>usecs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* Always sleep at least 1 sec */</comment>
		<if_stmt><if>if <condition>(<expr><name>secs</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>secs</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name>usecs</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name>sleeptime</name> <operator>=</operator> <name>secs</name> <operator>*</operator> <literal type="number">1000</literal> <operator>+</operator> <name>usecs</name> <operator>/</operator> <literal type="number">1000</literal></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>sleeptime</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<return>return <expr><name>sleeptime</name></expr>;</return>
</block_content>}</block></function>
</unit>
