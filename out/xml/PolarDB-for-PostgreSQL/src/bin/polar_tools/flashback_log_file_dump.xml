<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/PolarDB-for-PostgreSQL/src/bin/polar_tools/flashback_log_file_dump.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * flashback_log_file_dump.c - decode and display flashback log
 *
 * Copyright (c) 2020, Alibaba Group Holding Limited
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * IDENTIFICATION
 *        src/bin/polar_tools/flashback_log_file_dump.c
 *-------------------------------------------------------------------------
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;dirent.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdio.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/stat.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;unistd.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/xlogdefs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/transam.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"common/pg_lzcompress.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"polar_flashback/polar_flashback_log_file.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"polar_flashback/polar_flashback_log_reader.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"polar_flashback/polar_flashback_log_record.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"polar_tools.h"</cpp:file></cpp:include>

<comment type="block">/*no cover begin*/</comment>
<comment type="block">/*  checksum_impl.h uses Assert, which doesn't work outside the server */</comment>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>Assert</name></cpp:undef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>Assert</name><parameter_list>(<parameter><type><name>X</name></type></parameter>)</parameter_list></cpp:macro></cpp:define>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/checksum.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/checksum_impl.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/bufpage.h"</cpp:file></cpp:include>

<comment type="block">/* size of the buffer allocated for error message. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MAX_ERRORMSG_LEN</name></cpp:macro> <cpp:value>1000</cpp:value></cpp:define>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>progname</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type>  <name>segment_size</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type> <name>just_version</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type> <name>just_one_record_without_check</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FLASHBACK_LOG_REC_TYPES</name></cpp:macro> <cpp:value>(1)</cpp:value></cpp:define>

<comment type="block">/* load the flashback log switch ptrs */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>load_switch_ptrs</name><parameter_list>(<parameter><type><name>dir</name></type></parameter>, <parameter><type><name>ptrs</name></type></parameter>)</parameter_list></cpp:macro> \
	<cpp:value>(ptrs != NIL? ptrs : flog_read_history_file(dir))</cpp:value></cpp:define>

<typedef>typedef <type><struct>struct <name>dump_private</name>
<block>{
	<decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>inpath</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>polar_flog_rec_ptr</name></type>  <name>startptr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>polar_flog_rec_ptr</name></type>  <name>endptr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>        <name>endptr_reached</name></decl>;</decl_stmt>
}</block></struct></type> <name>dump_private</name>;</typedef>

<typedef>typedef <type><struct>struct <name>dump_config</name>
<block>{
	<comment type="block">/* display options */</comment>
	<decl_stmt><decl><type><name>bool</name></type>        <name>bkp_details</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>         <name>stop_after_records</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>         <name>already_displayed_records</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>        <name>follow</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>        <name>checksum</name></decl>;</decl_stmt>

	<comment type="block">/* filter options */</comment>
	<decl_stmt><decl><type><name>uint8</name></type>           <name>filter_by_type</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RelFileNode</name></type>     <name>rel_file_node</name></decl>;</decl_stmt>
}</block></struct></type> <name>dump_config</name>;</typedef>

<comment type="block">/* an flashback log_BLCKSZ-sized buffer */</comment>
<typedef>typedef <type><union>union <name>pg_aligned_flashback_log_blk</name>
<block>{
	<decl_stmt><decl><type><name>char</name></type>        <name><name>data</name><index>[<expr><name>POLAR_FLOG_BLCKSZ</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type>      <name>force_align_d</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int64</name></type>       <name>force_align_i64</name></decl>;</decl_stmt>
}</block></union></type> <name>pg_aligned_flashback_log_blk</name>;</typedef>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name><name>flashback_log_record_types</name><index>[<expr><name>FLASHBACK_LOG_REC_TYPES</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name> <init>=
<expr><block>{
	<expr><literal type="string">"original_page"</literal></expr>,
	<expr><name>NULL</name></expr>
}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type><name>switch_ptr_list</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>fatal_error</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>fmt</name></decl></parameter>, <parameter><decl><type><modifier>...</modifier></type></decl></parameter>)</parameter_list> pg_attribute_printf<parameter_list>(</parameter_list>1<operator>,</operator> 2</function_decl>)<empty_stmt>;</empty_stmt>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>report_invalid_flog_record</name><parameter_list>(<parameter><decl><type><name>flog_reader_state</name> <modifier>*</modifier></type><name>state</name></decl></parameter>,
									   <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>fmt</name></decl></parameter>, <parameter><decl><type><modifier>...</modifier></type></decl></parameter>)</parameter_list> pg_attribute_printf<parameter_list>(</parameter_list>2<operator>,</operator> 3</function_decl>)<empty_stmt>;</empty_stmt>

<comment type="block">/*
 * Big red button to push when things go horribly wrong.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>fatal_error</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>fmt</name></decl></parameter>, <parameter><decl><type><modifier>...</modifier></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>va_list</name></type>     <name>args</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>fflush</name><argument_list>(<argument><expr><name>stdout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"\n%s: FATAL:  "</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>progname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>va_start</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><name>fmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>vfprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><name>fmt</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>va_end</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>fputc</name><argument_list>(<argument><expr><literal type="char">'\n'</literal></expr></argument>, <argument><expr><name>stderr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><name>EXIT_FAILURE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>print_type_list</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>         <name>i</name></decl>;</decl_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>FLASHBACK_LOG_REC_TYPES</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"%s\n"</literal></expr></argument>, <argument><expr><name><name>flashback_log_record_types</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
</block_content>}</block></function>

<comment type="block">/*
 * Check whether directory exists and whether we can open it. Keep errno set so
 * that the caller can report errors somewhat more accurately.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>verify_directory</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>directory</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>DIR</name>        <modifier>*</modifier></type><name>dir</name> <init>= <expr><call><name>opendir</name><argument_list>(<argument><expr><name>directory</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>dir</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>closedir</name><argument_list>(<argument><expr><name>dir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Allocate readRecordBuf to fit a record of at least the given length.
 * Returns true if successful, false if out of memory.
 *
 * readRecordBufSize is set to the new buffer size.
 *
 * To avoid useless small increases, round its size to a multiple of
 * POLAR_FLASHBACK_LOG_BLCKSZ, and make sure it's at least 3*Max(BLCKSZ, POLAR_FLASHBACK_LOG_BLCKSZ) to start
 * with.  (That is enough for all "normal" records, but very large commit or
 * abort records might need more space.)
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>allocate_flog_recordbuf</name><parameter_list>(<parameter><decl><type><name>flog_reader_state</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>uint32</name></type> <name>reclength</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>uint32</name></type>      <name>newSize</name> <init>= <expr><name>reclength</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>newSize</name> <operator>+=</operator> <name>POLAR_FLOG_BLCKSZ</name> <operator>-</operator> <operator>(</operator><name>newSize</name> <operator>%</operator> <name>POLAR_FLOG_BLCKSZ</name><operator>)</operator></expr>;</expr_stmt>
	<expr_stmt><expr><name>newSize</name> <operator>=</operator> <call><name>Max</name><argument_list>(<argument><expr><name>newSize</name></expr></argument>, <argument><expr><literal type="number">3</literal> <operator>*</operator> <call><name>Max</name><argument_list>(<argument><expr><name>BLCKSZ</name></expr></argument>, <argument><expr><name>POLAR_FLOG_BLCKSZ</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>read_record_buf</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>read_record_buf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>read_record_buf</name></name> <operator>=</operator>
		<operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>palloc_extended</name><argument_list>(<argument><expr><name>newSize</name></expr></argument>, <argument><expr><name>MCXT_ALLOC_NO_OOM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>read_record_buf</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>read_record_buf_size</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>read_record_buf_size</name></name> <operator>=</operator> <name>newSize</name></expr>;</expr_stmt>
	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Allocate and initialize a new flashback log reader.
 * A copy from polar_flashback_reader.c.
 *
 * Returns NULL if the flashback log reader couldn't be allocated.
 */</comment>
<function><type><specifier>static</specifier> <name>flog_reader_state</name> <modifier>*</modifier></type>
<name>flog_reader_allocate</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>segment_size</name></decl></parameter>, <parameter><decl><type><name>page_read_callback</name></type> <name>pagereadfunc</name></decl></parameter>,
					 <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>private_data</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>flog_reader_state</name> <modifier>*</modifier></type><name>state</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>state</name> <operator>=</operator> <operator>(</operator><name>flog_reader_state</name> <operator>*</operator><operator>)</operator>
			<call><name>palloc_extended</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>flog_reader_state</name></expr></argument>)</argument_list></sizeof></expr></argument>,
							<argument><expr><name>MCXT_ALLOC_NO_OOM</name> <operator>|</operator> <name>MCXT_ALLOC_ZERO</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>state</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Permanently allocate readBuf.  We do it this way, rather than just
	 * making a static array, for two reasons: (1) no need to waste the
	 * storage in most instantiations of the backend; (2) a static char array
	 * isn't guaranteed to have any particular alignment, whereas
	 * palloc_extended() will provide MAXALIGN'd storage.
	 */</comment>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>read_buf</name></name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>palloc_extended</name><argument_list>(<argument><expr><name>POLAR_FLOG_BLCKSZ</name></expr></argument>,
											   <argument><expr><name>MCXT_ALLOC_NO_OOM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>state</name><operator>-&gt;</operator><name>read_buf</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>segment_size</name></name> <operator>=</operator> <name>segment_size</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>read_page</name></name> <operator>=</operator> <name>pagereadfunc</name></expr>;</expr_stmt>
	<comment type="block">/* system_identifier initialized to zeroes above */</comment>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>private_data</name></name> <operator>=</operator> <name>private_data</name></expr>;</expr_stmt>
	<comment type="block">/* ReadRecPtr and EndRecPtr initialized to zeroes above */</comment>
	<comment type="block">/* readSegNo, readOff, readLen, readPageTLI initialized to zeroes above */</comment>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>errormsg_buf</name></name> <operator>=</operator> <call><name>palloc_extended</name><argument_list>(<argument><expr><name>MAX_ERRORMSG_LEN</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>,
										  <argument><expr><name>MCXT_ALLOC_NO_OOM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>state</name><operator>-&gt;</operator><name>errormsg_buf</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>read_buf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>errormsg_buf</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>switch_ptrs</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>in_switch_region</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Allocate an initial readRecordBuf of minimal size, which can later be
	 * enlarged if necessary.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>allocate_flog_recordbuf</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>errormsg_buf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>read_buf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>state</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>flog_reader_free</name><parameter_list>(<parameter><decl><type><name>flog_reader_state</name> <modifier>*</modifier></type><name>state</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>errormsg_buf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>read_record_buf</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>read_record_buf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>read_buf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Invalidate the flashback_log_reader's read state to force a re-read.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>flog_inval_read_state</name><parameter_list>(<parameter><decl><type><name>flog_reader_state</name> <modifier>*</modifier></type><name>state</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>read_seg_no</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>read_off</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>read_len</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Construct a string in state-&gt;errormsg_buf explaining what's wrong with
 * the current record being read.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>report_invalid_flog_record</name><parameter_list>(<parameter><decl><type><name>flog_reader_state</name> <modifier>*</modifier></type><name>state</name></decl></parameter>,
						   <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>fmt</name></decl></parameter>, <parameter><decl><type><modifier>...</modifier></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>va_list</name></type>     <name>args</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>fmt</name> <operator>=</operator> <call><name>_</name><argument_list>(<argument><expr><name>fmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>va_start</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><name>fmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>vsnprintf</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>errormsg_buf</name></name></expr></argument>, <argument><expr><name>MAX_ERRORMSG_LEN</name></expr></argument>, <argument><expr><name>fmt</name></expr></argument>, <argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>va_end</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>is_file_exist</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>path</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name><name>struct</name> <name>stat</name></name></type> <name>st</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>stat</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>st</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>ssize_t</name></type>
<name>read_line</name><parameter_list>(<parameter><decl><type><name>FILE</name> <modifier>*</modifier></type><name>fp</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>buffer</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>n</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>size_t</name></type> <name>tot_read</name></decl>;</decl_stmt>                     <comment type="block">/* Total bytes read so far */</comment>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>buf</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type> <name>ch</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>n</name> <operator>&lt;=</operator> <literal type="number">0</literal> <operator>||</operator> <name>buffer</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>errno</name> <operator>=</operator> <name>EINVAL</name></expr>;</expr_stmt>
		<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>buf</name> <operator>=</operator> <name>buffer</name></expr>;</expr_stmt>                       <comment type="block">/* No pointer arithmetic on "void *" */</comment>

	<expr_stmt><expr><name>tot_read</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
	<block>{<block_content>
		<expr_stmt><expr><name>ch</name> <operator>=</operator> <call><name>fgetc</name><argument_list>(<argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>ch</name> <operator>==</operator> <name>EOF</name></expr>)</condition>       <comment type="block">/* EOF */</comment>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>tot_read</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>           <comment type="block">/* No bytes read; return 0 */</comment>
				<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if>
			<else>else<block type="pseudo"><block_content>                        <comment type="block">/* Some bytes read; add '\0' */</comment>
				<break>break;</break></block_content></block></else></if_stmt>
		</block_content>}</block></if>
		<else>else                            <comment type="block">/* 'numRead' must be 1 if we get here */</comment>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>tot_read</name> <operator>&lt;</operator> <name>n</name> <operator>-</operator> <literal type="number">1</literal></expr>)</condition>        <comment type="block">/* Discard &gt; (n - 1) bytes */</comment>
			<block>{<block_content>
				<expr_stmt><expr><name>tot_read</name><operator>++</operator></expr>;</expr_stmt>
				<expr_stmt><expr><operator>*</operator><name>buf</name><operator>++</operator> <operator>=</operator> <name>ch</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><name>ch</name> <operator>==</operator> <literal type="char">'\n'</literal></expr>)</condition><block type="pseudo"><block_content>
				<break>break;</break></block_content></block></if></if_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><operator>*</operator><name>buf</name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
	<return>return <expr><name>tot_read</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* ---------------------List ------------------------ */</comment>

<comment type="block">/*
 * -------------
 *  Definitions
 * -------------
 */</comment>

<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>new_list</name><parameter_list>(<parameter><decl><type><name>NodeTag</name></type> <name>type</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>new_list</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>new_head</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>new_head</name> <operator>=</operator> <operator>(</operator><name>ListCell</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>new_head</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>new_head</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<comment type="block">/* new_head-&gt;data is left undefined! */</comment>

	<expr_stmt><expr><name>new_list</name> <operator>=</operator> <operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>new_list</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>new_list</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name>type</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>new_list</name><operator>-&gt;</operator><name>length</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>new_list</name><operator>-&gt;</operator><name>head</name></name> <operator>=</operator> <name>new_head</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>new_list</name><operator>-&gt;</operator><name>tail</name></name> <operator>=</operator> <name>new_head</name></expr>;</expr_stmt>

	<return>return <expr><name>new_list</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>new_head_cell</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>list</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>new_head</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>new_head</name> <operator>=</operator> <operator>(</operator><name>ListCell</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>new_head</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>new_head</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name><name>list</name><operator>-&gt;</operator><name>head</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>list</name><operator>-&gt;</operator><name>head</name></name> <operator>=</operator> <name>new_head</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>list</name><operator>-&gt;</operator><name>length</name></name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>check_list_invariants</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>List</name> <modifier>*</modifier></type><name>list</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>list</name> <operator>==</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>list</name><operator>-&gt;</operator><name>length</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>list</name><operator>-&gt;</operator><name>head</name></name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>list</name><operator>-&gt;</operator><name>tail</name></name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>list</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>T_List</name> <operator>||</operator>
		   <name><name>list</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>T_IntList</name> <operator>||</operator>
		   <name><name>list</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>T_OidList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>list</name><operator>-&gt;</operator><name>length</name></name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>list</name><operator>-&gt;</operator><name>head</name></name> <operator>==</operator> <name><name>list</name><operator>-&gt;</operator><name>tail</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>list</name><operator>-&gt;</operator><name>length</name></name> <operator>==</operator> <literal type="number">2</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>list</name><operator>-&gt;</operator><name>head</name><operator>-&gt;</operator><name>next</name></name> <operator>==</operator> <name><name>list</name><operator>-&gt;</operator><name>tail</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>list</name><operator>-&gt;</operator><name>tail</name><operator>-&gt;</operator><name>next</name></name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>List</name> <modifier>*</modifier></type>
<name>lcons</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>datum</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>list</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>IsPointerList</name><argument_list>(<argument><expr><name>list</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>list</name> <operator>==</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>list</name> <operator>=</operator> <call><name>new_list</name><argument_list>(<argument><expr><name>T_List</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>new_head_cell</name><argument_list>(<argument><expr><name>list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<expr_stmt><expr><call><name>lfirst</name><argument_list>(<argument><expr><name><name>list</name><operator>-&gt;</operator><name>head</name></name></expr></argument>)</argument_list></call> <operator>=</operator> <name>datum</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>check_list_invariants</name><argument_list>(<argument><expr><name>list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>list</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * POLAR: Try to read a flashback log history file.
 *
 * The history content is stored in the switch_ptr_list.
 */</comment>
<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>flog_read_history_file</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>dir</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name></type>        <name><name>path</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>        <name><name>fline</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>polar_flog_rec_ptr</name></type> <name>switch_ptr</name> <init>= <expr><name>POLAR_INVALID_FLOG_REC_PTR</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>polar_flog_rec_ptr</name></type> <name>last_ptr</name> <init>= <expr><name>POLAR_INVALID_FLOG_REC_PTR</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>polar_flog_rec_ptr</name></type> <name>next_ptr</name> <init>= <expr><name>POLAR_INVALID_FLOG_REC_PTR</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>FILE</name> <modifier>*</modifier></type><name>fp</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>list</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>MAXPGPATH</name></expr></argument>, <argument><expr><literal type="string">"%s/%s"</literal></expr></argument>, <argument><expr><name>dir</name></expr></argument>, <argument><expr><name>FLOG_HISTORY_FILE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>is_file_exist</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>list</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>fp</name> <operator>=</operator> <call><name>fopen</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><literal type="string">"r"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if<condition>(<expr><name>fp</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>fatal_error</name><argument_list>(<argument><expr><literal type="string">"could not open file \"%s\": %s"</literal></expr></argument>,
					<argument><expr><name>path</name></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<while>while <condition>(<expr><call><name>read_line</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><name>fline</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>fline</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>uint32</name></type>      <name>switchpoint_hi</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>uint32</name></type>      <name>switchpoint_lo</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>uint32</name></type>      <name>nextpoint_hi</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>uint32</name></type>      <name>nextpoint_lo</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>TimeLineID</name></type>  <name>tli</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>         <name>nfields</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>ptr</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>flog_history_entry</name> <modifier>*</modifier></type><name>entry</name></decl>;</decl_stmt>

		<comment type="block">/* skip leading whitespace and check for # comment */</comment>
		<for>for <control>(<init><expr><name>ptr</name> <operator>=</operator> <name>fline</name></expr>;</init> <condition><expr><operator>*</operator><name>ptr</name></expr>;</condition> <incr><expr><name>ptr</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>isspace</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator> <operator>*</operator><name>ptr</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<break>break;</break></block_content></block></if></if_stmt>
		</block_content>}</block></for>

		<if_stmt><if>if <condition>(<expr><operator>*</operator><name>ptr</name> <operator>==</operator> <literal type="char">'\0'</literal> <operator>||</operator> <operator>*</operator><name>ptr</name> <operator>==</operator> <literal type="char">'#'</literal></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>nfields</name> <operator>=</operator> <call><name>sscanf</name><argument_list>(<argument><expr><name>fline</name></expr></argument>, <argument><expr><literal type="string">"%u\t%08X/%08X\t%08X/%08X"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>tli</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>switchpoint_hi</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>switchpoint_lo</name></expr></argument>,
						 <argument><expr><operator>&amp;</operator><name>nextpoint_hi</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nextpoint_lo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>nfields</name> <operator>!=</operator> <name>HISTORY_FILE_FIELDS</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>fatal_error</name><argument_list>(<argument><expr><literal type="string">"syntax error in flashback log history file: %s. "</literal>
						<literal type="string">"Expected a flashback log switch point and next point location."</literal></expr></argument>,
						<argument><expr><name>fline</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>switch_ptr</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>polar_flog_rec_ptr</name><operator>)</operator><operator>(</operator><name>switchpoint_hi</name><operator>)</operator><operator>)</operator> <operator>&lt;&lt;</operator> <literal type="number">32</literal> <operator>|</operator>
					 <operator>(</operator><name>polar_flog_rec_ptr</name><operator>)</operator> <name>switchpoint_lo</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>next_ptr</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>polar_flog_rec_ptr</name><operator>)</operator><operator>(</operator><name>nextpoint_hi</name><operator>)</operator><operator>)</operator> <operator>&lt;&lt;</operator> <literal type="number">32</literal> <operator>|</operator>
				   <operator>(</operator><name>polar_flog_rec_ptr</name><operator>)</operator> <name>nextpoint_lo</name></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>next_ptr</name> <operator>==</operator> <name>POLAR_INVALID_FLOG_REC_PTR</name> <operator>||</operator>
				<name>switch_ptr</name> <operator>&gt;=</operator> <name>next_ptr</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>fatal_error</name><argument_list>(<argument><expr><literal type="string">"invalid data in flashback log history file: %s. "</literal>
						<literal type="string">"switch point and next point must be valid and next point"</literal>
						<literal type="string">" is larger than or equal to switch point."</literal></expr></argument>, <argument><expr><name>fline</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>last_ptr</name> <operator>&amp;&amp;</operator> <name>last_ptr</name> <operator>&gt;</operator> <name>switch_ptr</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>fatal_error</name><argument_list>(<argument><expr><literal type="string">"invalid data in flashback log history file: %s. "</literal>
						<literal type="string">"switch point location must be in increasing sequence"</literal></expr></argument>, <argument><expr><name>fline</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>entry</name> <operator>=</operator> <operator>(</operator><name>flog_history_entry</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>flog_history_entry</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>tli</name></name> <operator>=</operator> <name>tli</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>switch_ptr</name></name> <operator>=</operator> <name>switch_ptr</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>next_ptr</name></name> <operator>=</operator> <name>next_ptr</name></expr>;</expr_stmt>
		<comment type="block">/* Build list with newest item first */</comment>
		<expr_stmt><expr><name>list</name> <operator>=</operator> <call><name>lcons</name><argument_list>(<argument><expr><name>entry</name></expr></argument>, <argument><expr><name>list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>last_ptr</name> <operator>=</operator> <name>next_ptr</name></expr>;</expr_stmt>
		<comment type="block">/* we ignore the remainder of each line */</comment>
	</block_content>}</block></while>
	<return>return <expr><name>list</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Converts a "usable byte position" to polar_flog_rec_ptr. A usable byte position
 * is the position starting from the beginning of flashback log, excluding all flashback log
 * page headers.
 */</comment>
<function><type><specifier>static</specifier> <name>polar_flog_rec_ptr</name></type>
<name>flog_pos2ptr</name><parameter_list>(<parameter><decl><type><name>uint64</name></type> <name>bytepos</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>uint64</name></type>      <name>fullsegs</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint64</name></type>      <name>fullpages</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint64</name></type>      <name>bytesleft</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32</name></type>      <name>seg_offset</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>polar_flog_rec_ptr</name></type>  <name>result</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>fullsegs</name> <operator>=</operator> <name>bytepos</name> <operator>/</operator> <name>USABLE_BYTES_IN_SEG</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>bytesleft</name> <operator>=</operator> <name>bytepos</name> <operator>%</operator> <name>USABLE_BYTES_IN_SEG</name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>bytesleft</name> <operator>&lt;</operator> <name>POLAR_FLOG_BLCKSZ</name> <operator>-</operator> <name>FLOG_LONG_PHD_SIZE</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* fits on first page of segment */</comment>
		<expr_stmt><expr><name>seg_offset</name> <operator>=</operator> <name>bytesleft</name> <operator>+</operator> <name>FLOG_LONG_PHD_SIZE</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* account for the first page on segment with long header */</comment>
		<expr_stmt><expr><name>seg_offset</name> <operator>=</operator> <name>POLAR_FLOG_BLCKSZ</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>bytesleft</name> <operator>-=</operator> <name>POLAR_FLOG_BLCKSZ</name> <operator>-</operator> <name>FLOG_LONG_PHD_SIZE</name></expr>;</expr_stmt>

		<expr_stmt><expr><name>fullpages</name> <operator>=</operator> <name>bytesleft</name> <operator>/</operator> <name>USABLE_BYTES_IN_PAGE</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>bytesleft</name> <operator>=</operator> <name>bytesleft</name> <operator>%</operator> <name>USABLE_BYTES_IN_PAGE</name></expr>;</expr_stmt>

		<expr_stmt><expr><name>seg_offset</name> <operator>+=</operator> <name>fullpages</name> <operator>*</operator> <name>POLAR_FLOG_BLCKSZ</name> <operator>+</operator> <name>bytesleft</name> <operator>+</operator> <name>FLOG_SHORT_PHD_SIZE</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><call><name>flog_seg_offset_to_ptr</name><argument_list>(<argument><expr><name>fullsegs</name></expr></argument>, <argument><expr><name>seg_offset</name></expr></argument>, <argument><expr><name>POLAR_FLOG_SEG_SIZE</name></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Convert an flashback log ptr to a "usable byte position".
 */</comment>
<function><type><specifier>static</specifier> <name>uint64</name></type>
<name>flog_ptr2pos</name><parameter_list>(<parameter><decl><type><name>polar_flog_rec_ptr</name></type> <name>ptr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>uint64</name></type>      <name>fullsegs</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32</name></type>      <name>fullpages</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32</name></type>      <name>offset</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint64</name></type>      <name>result</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>fullsegs</name> <operator>=</operator> <call><name>flog_ptr_to_seg</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>POLAR_FLOG_SEG_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>fullpages</name> <operator>=</operator> <operator>(</operator><call><name>FLOG_SEGMENT_OFFSET</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>POLAR_FLOG_SEG_SIZE</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>/</operator> <name>POLAR_FLOG_BLCKSZ</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>offset</name> <operator>=</operator> <name>ptr</name> <operator>%</operator> <name>POLAR_FLOG_BLCKSZ</name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>fullpages</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <name>fullsegs</name> <operator>*</operator> <name>USABLE_BYTES_IN_SEG</name></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>offset</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>offset</name> <operator>&gt;=</operator> <name>FLOG_LONG_PHD_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>result</name> <operator>+=</operator> <name>offset</name> <operator>-</operator> <name>FLOG_LONG_PHD_SIZE</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <name>fullsegs</name> <operator>*</operator> <name>USABLE_BYTES_IN_SEG</name> <operator>+</operator>
				 <operator>(</operator><name>POLAR_FLOG_BLCKSZ</name> <operator>-</operator> <name>FLOG_LONG_PHD_SIZE</name><operator>)</operator> <operator>+</operator> <comment type="block">/* account for first page */</comment>
				 <operator>(</operator><name>fullpages</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator> <operator>*</operator> <name>USABLE_BYTES_IN_PAGE</name></expr>;</expr_stmt>    <comment type="block">/* full pages */</comment>

		<if_stmt><if>if <condition>(<expr><name>offset</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>offset</name> <operator>&gt;=</operator> <name>FLOG_SHORT_PHD_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>result</name> <operator>+=</operator> <name>offset</name> <operator>-</operator> <name>FLOG_SHORT_PHD_SIZE</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></else></if_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * POLAR: If the flashback log point a switch point whose prev_lsn is wrong.
 *
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>check_switch_ptr_prev_lsn</name><parameter_list>(<parameter><decl><type><name>polar_flog_rec_ptr</name></type> <name>ptr</name></decl></parameter>,
						  <parameter><decl><type><name>flog_record</name> <modifier>*</modifier></type><name>rec</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>cell</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>ptr</name> <operator>-=</operator> <name>FLOG_LONG_PHD_SIZE</name></expr>;</expr_stmt>

	<comment type="block">/* Check first */</comment>
	<if_stmt><if>if <condition>(<expr><name>ptr</name> <operator>%</operator> <name>POLAR_FLOG_SEG_SIZE</name> <operator>!=</operator> <literal type="number">0</literal> <operator>||</operator>
			<name><name>rec</name><operator>-&gt;</operator><name>xl_prev</name></name> <operator>!=</operator> <name>POLAR_INVALID_FLOG_REC_PTR</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* Check strictly */</comment>
	<macro><name>foreach</name> <argument_list>(<argument>cell</argument>, <argument>switch_ptr_list</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>flog_history_entry</name> <modifier>*</modifier></type><name>tle</name> <init>= <expr><operator>(</operator><name>flog_history_entry</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>cell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>tle</name><operator>-&gt;</operator><name>next_ptr</name></name> <operator>==</operator> <name>ptr</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block>

	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Validate an flashback log record header.
 *
 * This is just a convenience subroutine to avoid duplicated code in
 * polar_read_flashback_log_record.  It's not intended for use from anywhere else.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>valid_flog_rec_header</name><parameter_list>(<parameter><decl><type><name>flog_reader_state</name> <modifier>*</modifier></type><name>state</name></decl></parameter>,
					  <parameter><decl><type><name>polar_flog_rec_ptr</name></type> <name>RecPtr</name></decl></parameter>, <parameter><decl><type><name>polar_flog_rec_ptr</name></type> <name>PrevRecPtr</name></decl></parameter>,
					  <parameter><decl><type><name>flog_record</name> <modifier>*</modifier></type><name>record</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>randAccess</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name><name>record</name><operator>-&gt;</operator><name>xl_tot_len</name></name> <operator>&lt;</operator> <name>FLOG_REC_HEADER_SIZE</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>report_invalid_flog_record</name><argument_list>(<argument><expr><name>state</name></expr></argument>,
								   <argument><expr><literal type="string">"invalid flashback log record length at %X/%X: wanted larger than or "</literal>
								   <literal type="string">"equal to %u, got %u"</literal></expr></argument>,
								   <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator><operator>(</operator><name>RecPtr</name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr></argument>, <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <name>RecPtr</name></expr></argument>,
								   <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <name>FLOG_REC_HEADER_SIZE</name></expr></argument>, <argument><expr><name><name>record</name><operator>-&gt;</operator><name>xl_tot_len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>randAccess</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * We can't exactly verify the prev-link, but surely it should be less
		 * than the record's own address.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>record</name><operator>-&gt;</operator><name>xl_prev</name></name> <operator>&gt;=</operator> <name>RecPtr</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>report_invalid_flog_record</name><argument_list>(<argument><expr><name>state</name></expr></argument>,
									   <argument><expr><literal type="string">"flashback log record with incorrect prev-link %X/%X at %X/%X"</literal></expr></argument>,
									   <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator><operator>(</operator><name><name>record</name><operator>-&gt;</operator><name>xl_prev</name></name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr></argument>,
									   <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <name><name>record</name><operator>-&gt;</operator><name>xl_prev</name></name></expr></argument>,
									   <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator><operator>(</operator><name>RecPtr</name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr></argument>, <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <name>RecPtr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>false</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/*
		 * Record's prev-link should exactly match our previous location. This
		 * check guards against torn flashbakc log pages where a stale but valid-looking
		 * flashback log record starts on a sector boundary.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>record</name><operator>-&gt;</operator><name>xl_prev</name></name> <operator>!=</operator> <name>PrevRecPtr</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><call><name>check_switch_ptr_prev_lsn</name><argument_list>(<argument><expr><name>RecPtr</name></expr></argument>, <argument><expr><name>record</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

			<expr_stmt><expr><call><name>report_invalid_flog_record</name><argument_list>(<argument><expr><name>state</name></expr></argument>,
									   <argument><expr><literal type="string">"flashback log record with incorrect prev-link %X/%X at %X/%X"</literal></expr></argument>,
									   <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator><operator>(</operator><name><name>record</name><operator>-&gt;</operator><name>xl_prev</name></name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr></argument>,
									   <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <name><name>record</name><operator>-&gt;</operator><name>xl_prev</name></name></expr></argument>,
									   <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator><operator>(</operator><name>RecPtr</name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr></argument>, <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <name>RecPtr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>false</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></else></if_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * CRC-check an flashback log record.  We do not believe the contents of an
 * flashback log record (other than to the minimal extent of computing
 * the amount of data to read in) until we've checked the CRCs.
 *
 * We assume all of the record (that is, xl_tot_len bytes) has been read
 * into memory at *record.  Also, flog_page_header_validate()
 * has accepted the record's header, which means in particular that
 * xl_tot_len is at least FLASHBACK_LOG_REC_SIZE.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>valid_flog_rec</name><parameter_list>(<parameter><decl><type><name>flog_reader_state</name> <modifier>*</modifier></type><name>state</name></decl></parameter>,
			   <parameter><decl><type><name>flog_record</name> <modifier>*</modifier></type><name>record</name></decl></parameter>, <parameter><decl><type><name>polar_flog_rec_ptr</name></type> <name>recptr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>pg_crc32c</name></type>   <name>crc</name></decl>;</decl_stmt>

	<comment type="block">/* Calculate the CRC */</comment>
	<expr_stmt><expr><call><name>INIT_CRC32C</name><argument_list>(<argument><expr><name>crc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMP_CRC32C</name><argument_list>(<argument><expr><name>crc</name></expr></argument>, <argument><expr><operator>(</operator><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>record</name><operator>)</operator> <operator>+</operator> <name>FLOG_REC_HEADER_SIZE</name></expr></argument>,
				<argument><expr><name><name>record</name><operator>-&gt;</operator><name>xl_tot_len</name></name> <operator>-</operator> <name>FLOG_REC_HEADER_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* include the record header last */</comment>
	<expr_stmt><expr><call><name>COMP_CRC32C</name><argument_list>(<argument><expr><name>crc</name></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>record</name></expr></argument>, <argument><expr><call><name>offsetof</name><argument_list>(<argument><expr><name>flog_record</name></expr></argument>, <argument><expr><name>xl_crc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>FIN_CRC32C</name><argument_list>(<argument><expr><name>crc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>EQ_CRC32C</name><argument_list>(<argument><expr><name><name>record</name><operator>-&gt;</operator><name>xl_crc</name></name></expr></argument>, <argument><expr><name>crc</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>report_invalid_flog_record</name><argument_list>(<argument><expr><name>state</name></expr></argument>,
								   <argument><expr><literal type="string">"incorrect data crc in flashback log "</literal>
								   <literal type="string">"record at %X/%X"</literal></expr></argument>,
								   <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator><operator>(</operator><name>recptr</name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr></argument>, <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <name>recptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Validate a flsahback log page header.
 *
 * Check if 'phdr' is valid as the header of the flashback log page at position
 * 'recptr'.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>flog_page_header_validate</name><parameter_list>(<parameter><decl><type><name>flog_reader_state</name> <modifier>*</modifier></type><name>state</name></decl></parameter>,
						  <parameter><decl><type><name>polar_flog_rec_ptr</name></type> <name>recptr</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>phdr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>polar_flog_rec_ptr</name></type>  <name>recaddr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint64</name></type>  <name>segno</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name></type>       <name>offset</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>flog_page_header</name></type> <name>hdr</name> <init>= <expr><operator>(</operator><name>flog_page_header</name><operator>)</operator> <name>phdr</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>(</operator><name>recptr</name> <operator>%</operator> <name>POLAR_FLOG_BLCKSZ</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>segno</name> <operator>=</operator> <call><name>flog_ptr_to_seg</name><argument_list>(<argument><expr><name>recptr</name></expr></argument>, <argument><expr><name><name>state</name><operator>-&gt;</operator><name>segment_size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>offset</name> <operator>=</operator> <call><name>FLOG_SEGMENT_OFFSET</name><argument_list>(<argument><expr><name>recptr</name></expr></argument>, <argument><expr><name><name>state</name><operator>-&gt;</operator><name>segment_size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>flog_seg_offset_to_ptr</name><argument_list>(<argument><expr><name>segno</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>, <argument><expr><name><name>state</name><operator>-&gt;</operator><name>segment_size</name></name></expr></argument>, <argument><expr><name>recaddr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>hdr</name><operator>-&gt;</operator><name>xlp_magic</name></name> <operator>!=</operator> <name>FLOG_PAGE_MAGIC</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name></type>        <name><name>fname</name><index>[<expr><name>FLOG_MAX_FNAME_LEN</name></expr>]</index></name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>get_flog_fname</name><argument_list>(<argument><expr><name>fname</name></expr></argument>, <argument><expr><name>segno</name></expr></argument>, <argument><expr><name><name>state</name><operator>-&gt;</operator><name>segment_size</name></name></expr></argument>, <argument><expr><name>FLOG_DEFAULT_TIMELINE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>report_invalid_flog_record</name><argument_list>(<argument><expr><name>state</name></expr></argument>,
								   <argument><expr><literal type="string">"invalid magic number %04X in flashback log segment %s, offset %u"</literal></expr></argument>,
								   <argument><expr><name><name>hdr</name><operator>-&gt;</operator><name>xlp_magic</name></name></expr></argument>,
								   <argument><expr><name>fname</name></expr></argument>,
								   <argument><expr><name>offset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>hdr</name><operator>-&gt;</operator><name>xlp_version</name></name> <operator>&lt;</operator> <name>FLOG_PAGE_VERSION</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name></type>        <name><name>fname</name><index>[<expr><name>FLOG_MAX_FNAME_LEN</name></expr>]</index></name></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>get_flog_fname</name><argument_list>(<argument><expr><name>fname</name></expr></argument>, <argument><expr><name>segno</name></expr></argument>, <argument><expr><name><name>state</name><operator>-&gt;</operator><name>segment_size</name></name></expr></argument>, <argument><expr><name>FLOG_DEFAULT_TIMELINE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>report_invalid_flog_record</name><argument_list>(<argument><expr><name>state</name></expr></argument>,
								   <argument><expr><literal type="string">"invalid version %04X in flashback log segment %s, offset %u"</literal></expr></argument>,
								   <argument><expr><name><name>hdr</name><operator>-&gt;</operator><name>xlp_version</name></name></expr></argument>,
								   <argument><expr><name>fname</name></expr></argument>,
								   <argument><expr><name>offset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>hdr</name><operator>-&gt;</operator><name>xlp_info</name></name> <operator>&amp;</operator> <operator>~</operator><name>FLOG_ALL_FLAGS</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name></type>        <name><name>fname</name><index>[<expr><name>FLOG_MAX_FNAME_LEN</name></expr>]</index></name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>get_flog_fname</name><argument_list>(<argument><expr><name>fname</name></expr></argument>, <argument><expr><name>segno</name></expr></argument>, <argument><expr><name><name>state</name><operator>-&gt;</operator><name>segment_size</name></name></expr></argument>, <argument><expr><name>FLOG_DEFAULT_TIMELINE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>report_invalid_flog_record</name><argument_list>(<argument><expr><name>state</name></expr></argument>,
								   <argument><expr><literal type="string">"invalid info bits %04X in flashback log segment %s, offset %u"</literal></expr></argument>,
								   <argument><expr><name><name>hdr</name><operator>-&gt;</operator><name>xlp_info</name></name></expr></argument>,
								   <argument><expr><name>fname</name></expr></argument>,
								   <argument><expr><name>offset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>hdr</name><operator>-&gt;</operator><name>xlp_info</name></name> <operator>&amp;</operator> <name>FLOG_LONG_PAGE_HEADER</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>polar_long_page_header</name></type> <name>longhdr</name> <init>= <expr><operator>(</operator><name>polar_long_page_header</name><operator>)</operator> <name>hdr</name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>system_identifier</name></name> <operator>&amp;&amp;</operator>
				<name><name>longhdr</name><operator>-&gt;</operator><name>xlp_sysid</name></name> <operator>!=</operator> <name><name>state</name><operator>-&gt;</operator><name>system_identifier</name></name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>char</name></type>        <name><name>fhdrident_str</name><index>[<expr><literal type="number">32</literal></expr>]</index></name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>char</name></type>        <name><name>sysident_str</name><index>[<expr><literal type="number">32</literal></expr>]</index></name></decl>;</decl_stmt>

			<comment type="block">/*
			 * Format sysids separately to keep platform-dependent format code
			 * out of the translatable message string.
			 */</comment>
			<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>fhdrident_str</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>fhdrident_str</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>UINT64_FORMAT</name></expr></argument>,
					 <argument><expr><name><name>longhdr</name><operator>-&gt;</operator><name>xlp_sysid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>sysident_str</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>sysident_str</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>UINT64_FORMAT</name></expr></argument>,
					 <argument><expr><name><name>state</name><operator>-&gt;</operator><name>system_identifier</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>report_invalid_flog_record</name><argument_list>(<argument><expr><name>state</name></expr></argument>,
									   <argument><expr><literal type="string">"flashback log file is from different database system: "</literal>
									   <literal type="string">"flashback log file database system identifier is %s, "</literal>
									   <literal type="string">"pg_control database system identifier is %s"</literal></expr></argument>,
									   <argument><expr><name>fhdrident_str</name></expr></argument>, <argument><expr><name>sysident_str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>false</name></expr>;</return>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name><name>longhdr</name><operator>-&gt;</operator><name>xlp_seg_size</name></name> <operator>!=</operator> <name><name>state</name><operator>-&gt;</operator><name>segment_size</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>report_invalid_flog_record</name><argument_list>(<argument><expr><name>state</name></expr></argument>,
									   <argument><expr><literal type="string">"flashback log file is from different database system: "</literal>
									   <literal type="string">"incorrect segment size in page header"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>false</name></expr>;</return>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name><name>longhdr</name><operator>-&gt;</operator><name>xlp_blcksz</name></name> <operator>!=</operator> <name>POLAR_FLOG_BLCKSZ</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>report_invalid_flog_record</name><argument_list>(<argument><expr><name>state</name></expr></argument>,
									   <argument><expr><literal type="string">"flashback log file is from different database system: "</literal>
									   <literal type="string">"incorrect POLAR_FLASHBACK_LOG_BLCKSZ in page header"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>false</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>offset</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name></type>        <name><name>fname</name><index>[<expr><name>FLOG_MAX_FNAME_LEN</name></expr>]</index></name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>get_flog_fname</name><argument_list>(<argument><expr><name>fname</name></expr></argument>, <argument><expr><name>segno</name></expr></argument>, <argument><expr><name><name>state</name><operator>-&gt;</operator><name>segment_size</name></name></expr></argument>, <argument><expr><name>FLOG_DEFAULT_TIMELINE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* hmm, first page of file doesn't have a long header? */</comment>
		<expr_stmt><expr><call><name>report_invalid_flog_record</name><argument_list>(<argument><expr><name>state</name></expr></argument>,
								   <argument><expr><literal type="string">"invalid info bits %04X in flashback log segment %s, offset %u"</literal></expr></argument>,
								   <argument><expr><name><name>hdr</name><operator>-&gt;</operator><name>xlp_info</name></name></expr></argument>,
								   <argument><expr><name>fname</name></expr></argument>,
								   <argument><expr><name>offset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Check that the address on the page agrees with what we expected. This
	 * check typically fails when an old flashback log segment is recycled,
	 * and hasn't yet been overwritten with new data yet.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>hdr</name><operator>-&gt;</operator><name>xlp_pageaddr</name></name> <operator>!=</operator> <name>recaddr</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name></type>        <name><name>fname</name><index>[<expr><name>FLOG_MAX_FNAME_LEN</name></expr>]</index></name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>get_flog_fname</name><argument_list>(<argument><expr><name>fname</name></expr></argument>, <argument><expr><name>segno</name></expr></argument>, <argument><expr><name><name>state</name><operator>-&gt;</operator><name>segment_size</name></name></expr></argument>, <argument><expr><name>FLOG_DEFAULT_TIMELINE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>report_invalid_flog_record</name><argument_list>(<argument><expr><name>state</name></expr></argument>,
								   <argument><expr><literal type="string">"unexpected pageaddr %X/%X in flashback log segment %s, offset %u"</literal></expr></argument>,
								   <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator><operator>(</operator><name><name>hdr</name><operator>-&gt;</operator><name>xlp_pageaddr</name></name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr></argument>, <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <name><name>hdr</name><operator>-&gt;</operator><name>xlp_pageaddr</name></name></expr></argument>,
								   <argument><expr><name>fname</name></expr></argument>,
								   <argument><expr><name>offset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>latest_page_ptr</name></name> <operator>=</operator> <name>recptr</name></expr>;</expr_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* POLAR: Get the end+1 of the flashback log */</comment>
<function><type><specifier>static</specifier> <name>polar_flog_rec_ptr</name></type>
<name>get_flog_end_ptr</name><parameter_list>(<parameter><decl><type><name>polar_flog_rec_ptr</name></type> <name>ptr</name></decl></parameter>, <parameter><decl><type><name>uint32</name></type> <name>log_len</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>polar_flog_rec_ptr</name></type> <name>next_ptr</name> <init>= <expr><name>POLAR_INVALID_FLOG_REC_PTR</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>polar_flog_rec_ptr</name></type> <name>pos</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>log_len</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>ptr</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>pos</name> <operator>=</operator> <call><name>flog_ptr2pos</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>)</argument_list></call> <operator>+</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><name>log_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>next_ptr</name> <operator>=</operator> <call><name>flog_pos2ptr</name><argument_list>(<argument><expr><name>pos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>next_ptr</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * POLAR: Check the invaild flashback log record is expected?
 *
 * Change the ptr to next_ptr.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>is_flog_rec_ignore</name><parameter_list>(<parameter><decl><type><name>polar_flog_rec_ptr</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>, <parameter><decl><type><name>uint32</name></type> <name>log_len</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>cell</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>polar_flog_rec_ptr</name></type> <name>end_ptr</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>end_ptr</name> <operator>=</operator> <call><name>get_flog_end_ptr</name><argument_list>(<argument><expr><operator>*</operator><name>ptr</name></expr></argument>, <argument><expr><name>log_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<macro><name>foreach</name> <argument_list>(<argument>cell</argument>, <argument>switch_ptr_list</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>flog_history_entry</name> <modifier>*</modifier></type><name>tle</name> <init>= <expr><operator>(</operator><name>flog_history_entry</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>cell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><operator>(</operator><name>end_ptr</name> <operator>&gt;</operator> <name><name>tle</name><operator>-&gt;</operator><name>switch_ptr</name></name> <operator>&amp;&amp;</operator> <operator>*</operator><name>ptr</name> <operator>&lt;</operator> <name><name>tle</name><operator>-&gt;</operator><name>next_ptr</name></name><operator>)</operator> <operator>||</operator>
				<operator>*</operator><name>ptr</name> <operator>==</operator> <name><name>tle</name><operator>-&gt;</operator><name>switch_ptr</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"\nThe flashback log record at %X/%X will be ignore. and switch to "</literal>
				   <literal type="string">"%X/%X\n"</literal></expr></argument>, <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator><operator>(</operator><operator>*</operator><name>ptr</name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr></argument>, <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator><operator>(</operator><operator>*</operator><name>ptr</name><operator>)</operator></expr></argument>,
				   <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator><operator>(</operator><operator>(</operator><name><name>tle</name><operator>-&gt;</operator><name>next_ptr</name></name> <operator>+</operator> <name>FLOG_LONG_PHD_SIZE</name><operator>)</operator> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr></argument>,
				   <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator><operator>(</operator><name><name>tle</name><operator>-&gt;</operator><name>next_ptr</name></name> <operator>+</operator> <name>FLOG_LONG_PHD_SIZE</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><operator>*</operator><name>ptr</name> <operator>=</operator> <name><name>tle</name><operator>-&gt;</operator><name>next_ptr</name></name> <operator>+</operator> <name>FLOG_LONG_PHD_SIZE</name></expr>;</expr_stmt>
			<return>return <expr><name>true</name></expr>;</return>
		</block_content>}</block></if>
		<comment type="block">/* We have check it in the before */</comment>
		<if type="elseif">else if <condition>(<expr><operator>*</operator><name>ptr</name> <operator>&gt;</operator> <name><name>tle</name><operator>-&gt;</operator><name>next_ptr</name></name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block>

	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Make the invalid ptr to first record ptr in flashback log */</comment>
<function><type><specifier>static</specifier> <name>polar_flog_rec_ptr</name></type>
<name>valid_flog_ptr</name><parameter_list>(<parameter><decl><type><name>polar_flog_rec_ptr</name></type> <name>ptr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>polar_flog_rec_ptr</name></type> <name>valid_ptr</name> <init>= <expr><name>ptr</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>valid_ptr</name> <operator>%</operator> <name>POLAR_FLOG_SEG_SIZE</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>valid_ptr</name> <operator>+=</operator> <name>FLOG_LONG_PHD_SIZE</name></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><name>valid_ptr</name> <operator>%</operator> <name>POLAR_FLOG_BLCKSZ</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>valid_ptr</name> <operator>+=</operator> <name>FLOG_SHORT_PHD_SIZE</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>valid_ptr</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Read a single flashback log page including at least [pageptr, reqLen] of valid data
 * via the read_page() callback.
 *
 * Returns -1 if the required page cannot be read for some reason; errormsg_buf
 * is set in that case (unless the error occurs in the read_page callback).
 *
 * We fetch the page from a reader-local cache if we know we have the required
 * data and if there hasn't been any error since caching the data.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>read_flog_page_internal</name><parameter_list>(<parameter><decl><type><name>flog_reader_state</name> <modifier>*</modifier></type><name>state</name></decl></parameter>,
						<parameter><decl><type><name>polar_flog_rec_ptr</name></type> <name>pageptr</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>reqLen</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>         <name>readLen</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32</name></type>      <name>targetPageOff</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint64</name></type>      <name>targetSegNo</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>flog_page_header</name></type> <name>hdr</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>(</operator><name>pageptr</name> <operator>%</operator> <name>POLAR_FLOG_BLCKSZ</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>targetSegNo</name> <operator>=</operator> <call><name>flog_ptr_to_seg</name><argument_list>(<argument><expr><name>pageptr</name></expr></argument>, <argument><expr><name><name>state</name><operator>-&gt;</operator><name>segment_size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>targetPageOff</name> <operator>=</operator> <call><name>FLOG_SEGMENT_OFFSET</name><argument_list>(<argument><expr><name>pageptr</name></expr></argument>, <argument><expr><name><name>state</name><operator>-&gt;</operator><name>segment_size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* check whether we have all the requested data already */</comment>
	<if_stmt><if>if <condition>(<expr><name>targetSegNo</name> <operator>==</operator> <name><name>state</name><operator>-&gt;</operator><name>read_seg_no</name></name> <operator>&amp;&amp;</operator> <name>targetPageOff</name> <operator>==</operator> <name><name>state</name><operator>-&gt;</operator><name>read_off</name></name> <operator>&amp;&amp;</operator>
			<name>reqLen</name> <operator>&lt;</operator> <name><name>state</name><operator>-&gt;</operator><name>read_len</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name><name>state</name><operator>-&gt;</operator><name>read_len</name></name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Data is not in our buffer.
	 *
	 * Every time we actually read the page, even if we looked at parts of it
	 * before, we need to do verification as the read_page callback might now
	 * be rereading data from a different source.
	 *
	 * Whenever switching to a new segment, we read the first page of the
	 * file and validate its header, even if that's not where the target
	 * record is.  This is so that we can check the additional identification
	 * info that is present in the first page's "long" header.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>targetSegNo</name> <operator>!=</operator> <name><name>state</name><operator>-&gt;</operator><name>read_seg_no</name></name> <operator>&amp;&amp;</operator> <name>targetPageOff</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>polar_flog_rec_ptr</name></type>  <name>targetSegmentPtr</name> <init>= <expr><name>pageptr</name> <operator>-</operator> <name>targetPageOff</name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>readLen</name> <operator>=</operator> <call><name><name>state</name><operator>-&gt;</operator><name>read_page</name></name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>targetSegmentPtr</name></expr></argument>, <argument><expr><name>POLAR_FLOG_BLCKSZ</name></expr></argument>,
								   <argument><expr><name><name>state</name><operator>-&gt;</operator><name>curr_rec_ptr</name></name></expr></argument>, <argument><expr><name><name>state</name><operator>-&gt;</operator><name>read_buf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>readLen</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<goto>goto <name>err</name>;</goto></block_content></block></if></if_stmt>

		<comment type="block">/* we can be sure to have enough flashback log available, we scrolled back */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>read_len</name> <operator>==</operator> <name>POLAR_FLOG_BLCKSZ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>flog_page_header_validate</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>targetSegmentPtr</name></expr></argument>,
									   <argument><expr><name><name>state</name><operator>-&gt;</operator><name>read_buf</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<goto>goto <name>err</name>;</goto></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * First, read the requested data length, but at least a short page header
	 * so that we can validate it.
	 */</comment>
	<expr_stmt><expr><name>readLen</name> <operator>=</operator> <call><name><name>state</name><operator>-&gt;</operator><name>read_page</name></name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>pageptr</name></expr></argument>, <argument><expr><call><name>Max</name><argument_list>(<argument><expr><name>reqLen</name></expr></argument>, <argument><expr><name>FLOG_SHORT_PHD_SIZE</name></expr></argument>)</argument_list></call></expr></argument>,
							   <argument><expr><name><name>state</name><operator>-&gt;</operator><name>curr_rec_ptr</name></name></expr></argument>, <argument><expr><name><name>state</name><operator>-&gt;</operator><name>read_buf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>readLen</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<goto>goto <name>err</name>;</goto></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>read_len</name> <operator>&lt;=</operator> <name>POLAR_FLOG_BLCKSZ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Do we have enough data to check the header length? */</comment>
	<if_stmt><if>if <condition>(<expr><name>readLen</name> <operator>&lt;=</operator> <name>FLOG_SHORT_PHD_SIZE</name></expr>)</condition><block type="pseudo"><block_content>
		<goto>goto <name>err</name>;</goto></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>read_len</name> <operator>&gt;=</operator> <name>reqLen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>hdr</name> <operator>=</operator> <operator>(</operator><name>flog_page_header</name><operator>)</operator> <name><name>state</name><operator>-&gt;</operator><name>read_buf</name></name></expr>;</expr_stmt>

	<comment type="block">/* still not enough */</comment>
	<if_stmt><if>if <condition>(<expr><name>readLen</name> <operator>&lt;</operator> <call><name>FLOG_PAGE_HEADER_SIZE</name><argument_list>(<argument><expr><name>hdr</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>readLen</name> <operator>=</operator> <call><name><name>state</name><operator>-&gt;</operator><name>read_page</name></name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>pageptr</name></expr></argument>, <argument><expr><call><name>FLOG_PAGE_HEADER_SIZE</name><argument_list>(<argument><expr><name>hdr</name></expr></argument>)</argument_list></call></expr></argument>,
								   <argument><expr><name><name>state</name><operator>-&gt;</operator><name>curr_rec_ptr</name></name></expr></argument>, <argument><expr><name><name>state</name><operator>-&gt;</operator><name>read_buf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>readLen</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<goto>goto <name>err</name>;</goto></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Now that we know we have the full header, validate it.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>flog_page_header_validate</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>pageptr</name></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>hdr</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<goto>goto <name>err</name>;</goto></block_content></block></if></if_stmt>

	<comment type="block">/* update read state information */</comment>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>read_seg_no</name></name> <operator>=</operator> <name>targetSegNo</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>read_off</name></name> <operator>=</operator> <name>targetPageOff</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>read_len</name></name> <operator>=</operator> <name>readLen</name></expr>;</expr_stmt>

	<return>return <expr><name>readLen</name></expr>;</return>

<label><name>err</name>:</label>
	<expr_stmt><expr><call><name>flog_inval_read_state</name><argument_list>(<argument><expr><name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Attempt to read an flashback log record. A copy from polar_flashback_log_reader.c.
 *
 * If RecPtr is valid, try to read a record at that position.  Otherwise
 * try to read a record just after the last one previously read.
 *
 * If the read_page callback fails to read the requested data, NULL is
 * returned.  The callback is expected to have reported the error; errormsg
 * is set to NULL.
 *
 * If the reading fails for some other reason, NULL is also returned, and
 * *errormsg is set to a string with details of the failure.
 *
 * The returned pointer (or *errormsg) points to an internal buffer that's
 * valid until the next call to read_flog_record.
 */</comment>
<function><type><specifier>static</specifier> <name>flog_record</name> <modifier>*</modifier></type>
<name>read_flog_record</name><parameter_list>(<parameter><decl><type><name>flog_reader_state</name> <modifier>*</modifier></type><name>state</name></decl></parameter>,
				 <parameter><decl><type><name>polar_flog_rec_ptr</name></type> <name>RecPtr</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>errormsg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>flog_record</name> <modifier>*</modifier></type><name>record</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>polar_flog_rec_ptr</name></type>  <name>targetPagePtr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32</name></type>      <name>len</name></decl>,
				<decl><type ref="prev"/><name>total_len</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32</name></type>      <name>targetRecOff</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32</name></type>      <name>pageHeaderSize</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>        <name>gotheader</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>         <name>readOff</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32</name></type>      <name>gotlen</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>randAccess</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>polar_flog_rec_ptr</name></type> <name>next_ptr</name></decl>;</decl_stmt>

	<comment type="block">/* reset error state */</comment>
	<expr_stmt><expr><operator>*</operator><name>errormsg</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>errormsg_buf</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>in_switch_region</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>RecPtr</name> <operator>==</operator> <name>POLAR_INVALID_FLOG_REC_PTR</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* No explicit start point; read the record after the one we just read */</comment>
		<expr_stmt><expr><name>RecPtr</name> <operator>=</operator> <name><name>state</name><operator>-&gt;</operator><name>end_rec_ptr</name></name></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>read_rec_ptr</name></name> <operator>==</operator> <name>POLAR_INVALID_FLOG_REC_PTR</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>randAccess</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * RecPtr is pointing to end+1 of the previous flashback log record.  If we're
		 * at a page boundary, no more records can fit on the current page. We
		 * must skip over the page header, but we can't do that until we've
		 * read in the page, since the header size is variable.
		 */</comment>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/*
		 * Caller supplied a position to start at.
		 *
		 * In this case, the passed-in record pointer should already be
		 * pointing to a valid record starting position.
		 */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>FLOG_REC_PTR_IS_VAILD</name><argument_list>(<argument><expr><name>RecPtr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>randAccess</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>curr_rec_ptr</name></name> <operator>=</operator> <name>RecPtr</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>targetPagePtr</name> <operator>=</operator> <name>RecPtr</name> <operator>-</operator> <operator>(</operator><name>RecPtr</name> <operator>%</operator> <name>POLAR_FLOG_BLCKSZ</name><operator>)</operator></expr>;</expr_stmt>
	<expr_stmt><expr><name>targetRecOff</name> <operator>=</operator> <name>RecPtr</name> <operator>%</operator> <name>POLAR_FLOG_BLCKSZ</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Read the page containing the record into state-&gt;readBuf. Request enough
	 * byte to cover the whole record header, or at least the part of it that
	 * fits on the same page.
	 */</comment>
	<expr_stmt><expr><name>readOff</name> <operator>=</operator> <call><name>read_flog_page_internal</name><argument_list>(<argument><expr><name>state</name></expr></argument>,
									  <argument><expr><name>targetPagePtr</name></expr></argument>,
									  <argument><expr><call><name>Min</name><argument_list>(<argument><expr><name>targetRecOff</name> <operator>+</operator> <name>FLOG_REC_HEADER_SIZE</name></expr></argument>, <argument><expr><name>POLAR_FLOG_BLCKSZ</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>readOff</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<goto>goto <name>err</name>;</goto></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>gotlen</name> <operator>=</operator> <name>readOff</name> <operator>-</operator> <name>targetRecOff</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * ReadPageInternal always returns at least the page header, so we can
	 * examine it now.
	 */</comment>
	<expr_stmt><expr><name>pageHeaderSize</name> <operator>=</operator> <call><name>FLOG_PAGE_HEADER_SIZE</name><argument_list>(<argument><expr><operator>(</operator><name>flog_page_header</name><operator>)</operator> <name><name>state</name><operator>-&gt;</operator><name>read_buf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>targetRecOff</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * At page start, so skip over page header.
		 */</comment>
		<expr_stmt><expr><name>RecPtr</name> <operator>+=</operator> <name>pageHeaderSize</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>targetRecOff</name> <operator>=</operator> <name>pageHeaderSize</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>targetRecOff</name> <operator>&lt;</operator> <name>pageHeaderSize</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>report_invalid_flog_record</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><literal type="string">"invalid flashback log record offset at %X/%X"</literal></expr></argument>,
								   <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator><operator>(</operator><name>RecPtr</name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr></argument>, <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <name>RecPtr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<goto>goto <name>err</name>;</goto>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Can't read flashback log from contrecord ptr */</comment>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><operator>(</operator><operator>(</operator><name>flog_page_header</name><operator>)</operator> <name><name>state</name><operator>-&gt;</operator><name>read_buf</name></name><operator>)</operator><operator>-&gt;</operator><name>xlp_info</name> <operator>&amp;</operator> <name>FLOG_FIRST_IS_CONTRECORD</name><operator>)</operator> <operator>&amp;&amp;</operator>
			<name>targetRecOff</name> <operator>==</operator> <name>pageHeaderSize</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>report_invalid_flog_record</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><literal type="string">"contrecord flashback log is requested by %X/%X"</literal></expr></argument>,
								   <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator><operator>(</operator><name>RecPtr</name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr></argument>, <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <name>RecPtr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<goto>goto <name>err</name>;</goto>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* ReadPageInternal has verified the page header */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>pageHeaderSize</name> <operator>&lt;=</operator> <name>read_off</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Read the record length.
	 *
	 * NB: Even though we use an polar_flashback_log_record pointer here, the whole record
	 * header might not fit on this page. xl_tot_len is the first field of the
	 * struct, so it must be on this page (the records are MAXALIGNed), but we
	 * cannot access any other fields until we've verified that we got the
	 * whole header.
	 */</comment>
	<expr_stmt><expr><name>record</name> <operator>=</operator> <operator>(</operator><name>flog_record</name> <operator>*</operator><operator>)</operator><operator>(</operator><name><name>state</name><operator>-&gt;</operator><name>read_buf</name></name> <operator>+</operator> <name>RecPtr</name> <operator>%</operator> <name>POLAR_FLOG_BLCKSZ</name><operator>)</operator></expr>;</expr_stmt>
	<expr_stmt><expr><name>total_len</name> <operator>=</operator> <name><name>record</name><operator>-&gt;</operator><name>xl_tot_len</name></name></expr>;</expr_stmt>

	<comment type="block">/*
	 * If the whole record header is on this page, validate it immediately.
	 * Otherwise do just a basic sanity check on xl_tot_len, and validate the
	 * rest of the header after reading it from the next page.  The xl_tot_len
	 * check is necessary here to ensure that we enter the "Need to reassemble
	 * record" code path below; otherwise we might fail to apply
	 * valid_flog_rec_header at all.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>targetRecOff</name> <operator>&lt;=</operator> <name>POLAR_FLOG_BLCKSZ</name> <operator>-</operator> <name>FLOG_REC_HEADER_SIZE</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>just_one_record_without_check</name> <operator>&amp;&amp;</operator>
				<operator>!</operator><call><name>valid_flog_rec_header</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>RecPtr</name></expr></argument>, <argument><expr><name><name>state</name><operator>-&gt;</operator><name>read_rec_ptr</name></name></expr></argument>,
									   <argument><expr><name>record</name></expr></argument>, <argument><expr><name>randAccess</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<goto>goto <name>err</name>;</goto></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>gotheader</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* XXX: more validation should be done here */</comment>
		<if_stmt><if>if <condition>(<expr><name>total_len</name> <operator>&lt;</operator> <name>FLOG_REC_HEADER_SIZE</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>report_invalid_flog_record</name><argument_list>(<argument><expr><name>state</name></expr></argument>,
									   <argument><expr><literal type="string">"invalid flashback log record length at %X/%X: wanted %u, got %u"</literal></expr></argument>,
									   <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator><operator>(</operator><name>RecPtr</name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr></argument>, <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <name>RecPtr</name></expr></argument>,
									   <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <name>FLOG_REC_HEADER_SIZE</name></expr></argument>, <argument><expr><name>total_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<goto>goto <name>err</name>;</goto>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name>gotheader</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/*
	 * Enlarge readRecordBuf as needed.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>total_len</name> <operator>&gt;</operator> <name><name>state</name><operator>-&gt;</operator><name>read_record_buf_size</name></name> <operator>&amp;&amp;</operator>
			<operator>!</operator><call><name>allocate_flog_recordbuf</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>total_len</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* We treat this as a "bogus data" condition */</comment>
		<expr_stmt><expr><call><name>report_invalid_flog_record</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><literal type="string">"record length %u at %X/%X too long"</literal></expr></argument>,
								   <argument><expr><name>total_len</name></expr></argument>,
								   <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator><operator>(</operator><name>RecPtr</name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr></argument>, <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <name>RecPtr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<goto>goto <name>err</name>;</goto>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>len</name> <operator>=</operator> <name>POLAR_FLOG_BLCKSZ</name> <operator>-</operator> <name>RecPtr</name> <operator>%</operator> <name>POLAR_FLOG_BLCKSZ</name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>total_len</name> <operator>&gt;</operator> <name>len</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Need to reassemble record */</comment>
		<decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>contdata</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>flog_page_header</name></type> <name>pageHeader</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>buffer</name></decl>;</decl_stmt>

		<comment type="block">/* Copy the first fragment of the record from the first page. */</comment>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>read_record_buf</name></name></expr></argument>,
			   <argument><expr><name><name>state</name><operator>-&gt;</operator><name>read_buf</name></name> <operator>+</operator> <name>RecPtr</name> <operator>%</operator> <name>POLAR_FLOG_BLCKSZ</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>buffer</name> <operator>=</operator> <name><name>state</name><operator>-&gt;</operator><name>read_record_buf</name></name> <operator>+</operator> <name>len</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>gotlen</name> <operator>=</operator> <name>len</name></expr>;</expr_stmt>

		<do>do
		<block>{<block_content>
			<comment type="block">/* Calculate pointer to beginning of next page */</comment>
			<expr_stmt><expr><name>targetPagePtr</name> <operator>+=</operator> <name>POLAR_FLOG_BLCKSZ</name></expr>;</expr_stmt>

			<comment type="block">/* Wait for the next page to become available */</comment>
			<expr_stmt><expr><name>readOff</name> <operator>=</operator> <call><name>read_flog_page_internal</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>targetPagePtr</name></expr></argument>,
											  <argument><expr><call><name>Min</name><argument_list>(<argument><expr><name>total_len</name> <operator>-</operator> <name>gotlen</name> <operator>+</operator> <name>FLOG_SHORT_PHD_SIZE</name></expr></argument>,
												  <argument><expr><name>POLAR_FLOG_BLCKSZ</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name>readOff</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<goto>goto <name>err</name>;</goto></block_content></block></if></if_stmt>

			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>FLOG_SHORT_PHD_SIZE</name> <operator>&lt;=</operator> <name>read_off</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* Check that the continuation on next page looks valid */</comment>
			<expr_stmt><expr><name>pageHeader</name> <operator>=</operator> <operator>(</operator><name>flog_page_header</name><operator>)</operator> <name><name>state</name><operator>-&gt;</operator><name>read_buf</name></name></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name><name>pageHeader</name><operator>-&gt;</operator><name>xlp_info</name></name> <operator>&amp;</operator> <name>FLOG_FIRST_IS_CONTRECORD</name><operator>)</operator></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>report_invalid_flog_record</name><argument_list>(<argument><expr><name>state</name></expr></argument>,
										   <argument><expr><literal type="string">"there is no contrecord flag at flashback log %X/%X"</literal></expr></argument>,
										   <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator><operator>(</operator><name>RecPtr</name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr></argument>, <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <name>RecPtr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<goto>goto <name>err</name>;</goto>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/*
			 * Cross-check that xlp_rem_len agrees with how much of the record
			 * we expect there to be left.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>pageHeader</name><operator>-&gt;</operator><name>xlp_rem_len</name></name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
					<name>total_len</name> <operator>!=</operator> <operator>(</operator><name><name>pageHeader</name><operator>-&gt;</operator><name>xlp_rem_len</name></name> <operator>+</operator> <name>gotlen</name><operator>)</operator></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>report_invalid_flog_record</name><argument_list>(<argument><expr><name>state</name></expr></argument>,
										   <argument><expr><literal type="string">"invalid contrecord length %u at flashback log %X/%X"</literal></expr></argument>,
										   <argument><expr><name><name>pageHeader</name><operator>-&gt;</operator><name>xlp_rem_len</name></name></expr></argument>,
										   <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator><operator>(</operator><name>RecPtr</name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr></argument>, <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <name>RecPtr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<goto>goto <name>err</name>;</goto>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/* Append the continuation from this page to the buffer */</comment>
			<expr_stmt><expr><name>pageHeaderSize</name> <operator>=</operator> <call><name>FLOG_PAGE_HEADER_SIZE</name><argument_list>(<argument><expr><name>pageHeader</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name>readOff</name> <operator>&lt;</operator> <name>pageHeaderSize</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>readOff</name> <operator>=</operator> <call><name>read_flog_page_internal</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>targetPagePtr</name></expr></argument>,
												  <argument><expr><name>pageHeaderSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>pageHeaderSize</name> <operator>&lt;=</operator> <name>read_off</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name>contdata</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name><name>state</name><operator>-&gt;</operator><name>read_buf</name></name> <operator>+</operator> <name>pageHeaderSize</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>len</name> <operator>=</operator> <name>POLAR_FLOG_BLCKSZ</name> <operator>-</operator> <name>pageHeaderSize</name></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>pageHeader</name><operator>-&gt;</operator><name>xlp_rem_len</name></name> <operator>&lt;</operator> <name>len</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>len</name> <operator>=</operator> <name><name>pageHeader</name><operator>-&gt;</operator><name>xlp_rem_len</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><name>readOff</name> <operator>&lt;</operator> <name>pageHeaderSize</name> <operator>+</operator> <name>len</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>readOff</name> <operator>=</operator> <call><name>read_flog_page_internal</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>targetPagePtr</name></expr></argument>,
												  <argument><expr><name>pageHeaderSize</name> <operator>+</operator> <name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>contdata</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>buffer</name> <operator>+=</operator> <name>len</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>gotlen</name> <operator>+=</operator> <name>len</name></expr>;</expr_stmt>

			<comment type="block">/* If we just reassembled the record header, validate it. */</comment>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>gotheader</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>record</name> <operator>=</operator> <operator>(</operator><name>flog_record</name> <operator>*</operator><operator>)</operator> <name><name>state</name><operator>-&gt;</operator><name>read_record_buf</name></name></expr>;</expr_stmt>

				<if_stmt><if>if <condition>(<expr><operator>!</operator><name>just_one_record_without_check</name> <operator>&amp;&amp;</operator>
						<operator>!</operator><call><name>valid_flog_rec_header</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>RecPtr</name></expr></argument>, <argument><expr><name><name>state</name><operator>-&gt;</operator><name>read_rec_ptr</name></name></expr></argument>,
											   <argument><expr><name>record</name></expr></argument>, <argument><expr><name>randAccess</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<goto>goto <name>err</name>;</goto></block_content></block></if></if_stmt>

				<expr_stmt><expr><name>gotheader</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block>
		while <condition>(<expr><name>gotlen</name> <operator>&lt;</operator> <name>total_len</name></expr>)</condition>;</do>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>gotheader</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>record</name> <operator>=</operator> <operator>(</operator><name>flog_record</name> <operator>*</operator><operator>)</operator> <name><name>state</name><operator>-&gt;</operator><name>read_record_buf</name></name></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>just_one_record_without_check</name> <operator>&amp;&amp;</operator>
				<operator>!</operator><call><name>valid_flog_rec</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>record</name></expr></argument>, <argument><expr><name>RecPtr</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<goto>goto <name>err</name>;</goto></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>pageHeaderSize</name> <operator>=</operator> <call><name>FLOG_PAGE_HEADER_SIZE</name><argument_list>(<argument><expr><operator>(</operator><name>flog_page_header</name><operator>)</operator> <name><name>state</name><operator>-&gt;</operator><name>read_buf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>read_rec_ptr</name></name> <operator>=</operator> <name>RecPtr</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>end_rec_ptr</name></name> <operator>=</operator> <name>targetPagePtr</name> <operator>+</operator> <name>pageHeaderSize</name>
							 <operator>+</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><name><name>pageHeader</name><operator>-&gt;</operator><name>xlp_rem_len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* Wait for the record data to become available */</comment>
		<expr_stmt><expr><name>readOff</name> <operator>=</operator> <call><name>read_flog_page_internal</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>targetPagePtr</name></expr></argument>,
										  <argument><expr><call><name>Min</name><argument_list>(<argument><expr><name>targetRecOff</name> <operator>+</operator> <name>total_len</name></expr></argument>, <argument><expr><name>POLAR_FLOG_BLCKSZ</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>readOff</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<goto>goto <name>err</name>;</goto></block_content></block></if></if_stmt>

		<comment type="block">/* Record does not cross a page boundary */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>just_one_record_without_check</name> <operator>&amp;&amp;</operator>
				<operator>!</operator><call><name>valid_flog_rec</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>record</name></expr></argument>, <argument><expr><name>RecPtr</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<goto>goto <name>err</name>;</goto></block_content></block></if></if_stmt>

		<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>end_rec_ptr</name></name> <operator>=</operator> <name>RecPtr</name> <operator>+</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><name>total_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>read_rec_ptr</name></name> <operator>=</operator> <name>RecPtr</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>read_record_buf</name></name></expr></argument>, <argument><expr><name>record</name></expr></argument>, <argument><expr><name>total_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<return>return <expr><name>record</name></expr>;</return>

<label><name>err</name>:</label>

	<comment type="block">/*
	 * Invalidate the read state. We might read from a different source after
	 * failure.
	 */</comment>
	<expr_stmt><expr><call><name>flog_inval_read_state</name><argument_list>(<argument><expr><name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


	<if_stmt><if>if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>errormsg_buf</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'\0'</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><operator>*</operator><name>errormsg</name> <operator>=</operator> <name><name>state</name><operator>-&gt;</operator><name>errormsg_buf</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Is the record in the switch region */</comment>
	<expr_stmt><expr><name>next_ptr</name> <operator>=</operator> <name><name>state</name><operator>-&gt;</operator><name>curr_rec_ptr</name></name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>is_flog_rec_ignore</name><argument_list>(<argument><expr><operator>&amp;</operator><name>next_ptr</name></expr></argument>, <argument><expr><name>total_len</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>in_switch_region</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>end_rec_ptr</name></name> <operator>=</operator> <name>next_ptr</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Find the first record with an lsn &gt;= RecPtr.
 *
 * Useful for checking whether RecPtr is a valid flashback log address for reading, and
 * to find the first valid address after some address when dumping records for
 * debugging purposes.
 */</comment>
<function><type><specifier>static</specifier> <name>polar_flog_rec_ptr</name></type>
<name>find_first_flog_rec</name><parameter_list>(<parameter><decl><type><name>flog_reader_state</name> <modifier>*</modifier></type><name>state</name></decl></parameter>,
					<parameter><decl><type><name>polar_flog_rec_ptr</name></type> <name>RecPtr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>flog_reader_state</name></type> <name>saved_state</name> <init>= <expr><operator>*</operator><name>state</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>polar_flog_rec_ptr</name></type>  <name>tmpRecPtr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>polar_flog_rec_ptr</name></type>  <name>found</name> <init>= <expr><name>POLAR_INVALID_FLOG_REC_PTR</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>flog_page_header</name></type> <name>header</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>errormsg</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>RecPtr</name> <operator>!=</operator> <name>POLAR_INVALID_FLOG_REC_PTR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * skip over potential continuation data, keeping in mind that it may span
	 * multiple pages
	 */</comment>
	<expr_stmt><expr><name>tmpRecPtr</name> <operator>=</operator> <name>RecPtr</name></expr>;</expr_stmt>

	<while>while <condition>(<expr><name>true</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>polar_flog_rec_ptr</name></type>  <name>targetPagePtr</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>         <name>targetRecOff</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>uint32</name></type>      <name>pageHeaderSize</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>         <name>readLen</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * Compute targetRecOff. It should typically be equal or greater than
		 * short page-header since a valid record can't start anywhere before
		 * that, except when caller has explicitly specified the offset that
		 * falls somewhere there or when we are skipping multi-page
		 * continuation record. It doesn't matter though because
		 * ReadPageInternal() is prepared to handle that and will read at
		 * least short page-header worth of data
		 */</comment>
		<expr_stmt><expr><name>targetRecOff</name> <operator>=</operator> <name>tmpRecPtr</name> <operator>%</operator> <name>POLAR_FLOG_BLCKSZ</name></expr>;</expr_stmt>

		<comment type="block">/* scroll back to page boundary */</comment>
		<expr_stmt><expr><name>targetPagePtr</name> <operator>=</operator> <name>tmpRecPtr</name> <operator>-</operator> <name>targetRecOff</name></expr>;</expr_stmt>

		<comment type="block">/* Read the page containing the record */</comment>
		<expr_stmt><expr><name>readLen</name> <operator>=</operator> <call><name>read_flog_page_internal</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>targetPagePtr</name></expr></argument>, <argument><expr><name>targetRecOff</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>readLen</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<goto>goto <name>err</name>;</goto></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>header</name> <operator>=</operator> <operator>(</operator><name>flog_page_header</name><operator>)</operator> <name><name>state</name><operator>-&gt;</operator><name>read_buf</name></name></expr>;</expr_stmt>

		<expr_stmt><expr><name>pageHeaderSize</name> <operator>=</operator> <call><name>FLOG_PAGE_HEADER_SIZE</name><argument_list>(<argument><expr><name>header</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* make sure we have enough data for the page header */</comment>
		<expr_stmt><expr><name>readLen</name> <operator>=</operator> <call><name>read_flog_page_internal</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>targetPagePtr</name></expr></argument>, <argument><expr><name>pageHeaderSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>readLen</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<goto>goto <name>err</name>;</goto></block_content></block></if></if_stmt>

		<comment type="block">/* skip over potential continuation data */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>header</name><operator>-&gt;</operator><name>xlp_info</name></name> <operator>&amp;</operator> <name>FLOG_FIRST_IS_CONTRECORD</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * If the length of the remaining continuation data is more than
			 * what can fit in this page, the continuation record crosses over
			 * this page. Read the next page and try again. xlp_rem_len in the
			 * next page header will contain the remaining length of the
			 * continuation data
			 *
			 * Note that record headers are MAXALIGN'ed
			 */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>MAXALIGN</name><argument_list>(<argument><expr><name><name>header</name><operator>-&gt;</operator><name>xlp_rem_len</name></name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <operator>(</operator><name>POLAR_FLOG_BLCKSZ</name> <operator>-</operator> <name>pageHeaderSize</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>tmpRecPtr</name> <operator>=</operator> <name>targetPagePtr</name> <operator>+</operator> <name>POLAR_FLOG_BLCKSZ</name></expr>;</expr_stmt></block_content></block></if>
			<else>else
			<block>{<block_content>
				<comment type="block">/*
				 * The previous continuation record ends in this page. Set
				 * tmpRecPtr to point to the first valid record
				 */</comment>
				<expr_stmt><expr><name>tmpRecPtr</name> <operator>=</operator> <name>targetPagePtr</name> <operator>+</operator> <name>pageHeaderSize</name>
							<operator>+</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><name><name>header</name><operator>-&gt;</operator><name>xlp_rem_len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><name>tmpRecPtr</name> <operator>=</operator> <name>targetPagePtr</name> <operator>+</operator> <name>pageHeaderSize</name></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></while>

	<comment type="block">/*
	 * we know now that tmpRecPtr is an address pointing to a valid XLogRecord
	 * because either we're at the first record after the beginning of a page
	 * or we just jumped over the remaining data of a continuation.
	 */</comment>
	<while>while <condition>(<expr><call><name>read_flog_record</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>tmpRecPtr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>errormsg</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* continue after the record */</comment>
		<expr_stmt><expr><name>tmpRecPtr</name> <operator>=</operator> <name>POLAR_INVALID_FLOG_REC_PTR</name></expr>;</expr_stmt>

		<comment type="block">/* past the record we've found, break out */</comment>
		<if_stmt><if>if <condition>(<expr><name>RecPtr</name> <operator>&lt;=</operator> <name><name>state</name><operator>-&gt;</operator><name>read_rec_ptr</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>found</name> <operator>=</operator> <name><name>state</name><operator>-&gt;</operator><name>read_rec_ptr</name></name></expr>;</expr_stmt>
			<goto>goto <name>out</name>;</goto>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></while>

<label><name>err</name>:</label>

	<if_stmt><if>if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>in_switch_region</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>found</name> <operator>=</operator> <name><name>state</name><operator>-&gt;</operator><name>end_rec_ptr</name></name></expr>;</expr_stmt>
		<goto>goto <name>out</name>;</goto>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>errormsg_buf</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'\0'</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>errormsg</name> <operator>=</operator> <name><name>state</name><operator>-&gt;</operator><name>errormsg_buf</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>fatal_error</name><argument_list>(<argument><expr><literal type="string">"Read the flashback log record error at %X/%X: %s"</literal></expr></argument>,
				<argument><expr><operator>(</operator><name>uint32</name><operator>)</operator><operator>(</operator><name><name>state</name><operator>-&gt;</operator><name>curr_rec_ptr</name></name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr></argument>,
				<argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <name><name>state</name><operator>-&gt;</operator><name>curr_rec_ptr</name></name></expr></argument>, <argument><expr><name>errormsg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<label><name>out</name>:</label>
	<comment type="block">/* Reset state to what we had before finding the record */</comment>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>read_rec_ptr</name></name> <operator>=</operator> <name><name>saved_state</name><operator>.</operator><name>read_rec_ptr</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>end_rec_ptr</name></name> <operator>=</operator> <name><name>saved_state</name><operator>.</operator><name>end_rec_ptr</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>flog_inval_read_state</name><argument_list>(<argument><expr><name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>found</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Split a pathname as dirname(1) and basename(1) would.
 *
 * XXX this probably doesn't do very well on Windows.  We probably need to
 * apply canonicalize_path(), at the very least.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>split_path</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>path</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>dir</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>fname</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>sep</name></decl>;</decl_stmt>

	<comment type="block">/* split filepath into directory &amp; filename */</comment>
	<expr_stmt><expr><name>sep</name> <operator>=</operator> <call><name>strrchr</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><literal type="char">'/'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* directory path */</comment>
	<if_stmt><if>if <condition>(<expr><name>sep</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><operator>*</operator><name>dir</name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><operator>(</operator><operator>*</operator><name>dir</name><operator>)</operator><index>[<expr><operator>(</operator><name>sep</name> <operator>-</operator> <name>path</name><operator>)</operator> <operator>+</operator> <literal type="number">1</literal></expr>]</index> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>    <comment type="block">/* no strndup */</comment>
		<expr_stmt><expr><operator>*</operator><name>fname</name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><name>sep</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<comment type="block">/* local directory */</comment>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><operator>*</operator><name>dir</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><operator>*</operator><name>fname</name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Open the file in the valid target directory.
 *
 * return a read only fd
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>open_file_in_directory</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>directory</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>fname</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>         <name>fd</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>        <name><name>fpath</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>directory</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>fpath</name></expr></argument>, <argument><expr><name>MAXPGPATH</name></expr></argument>, <argument><expr><literal type="string">"%s/%s"</literal></expr></argument>, <argument><expr><name>directory</name></expr></argument>, <argument><expr><name>fname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>fd</name> <operator>=</operator> <call><name>open</name><argument_list>(<argument><expr><name>fpath</name></expr></argument>, <argument><expr><name>O_RDONLY</name> <operator>|</operator> <name>PG_BINARY</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>fd</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>errno</name> <operator>!=</operator> <name>ENOENT</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>fatal_error</name><argument_list>(<argument><expr><literal type="string">"could not open file \"%s\": %s"</literal></expr></argument>,
					<argument><expr><name>fname</name></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>fd</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Try to find fname in the given directory. Returns true if it is found,
 * false otherwise. If fname is NULL, search the complete directory for any
 * file with a valid WAL file name. If file is successfully opened, set the
 * wal segment size.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>search_directory</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>directory</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>fname</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>         <name>fd</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>DIR</name>        <modifier>*</modifier></type><name>xldir</name></decl>;</decl_stmt>

	<comment type="block">/* open file if valid filename is provided */</comment>
	<if_stmt><if>if <condition>(<expr><name>fname</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>fd</name> <operator>=</operator> <call><name>open_file_in_directory</name><argument_list>(<argument><expr><name>directory</name></expr></argument>, <argument><expr><name>fname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>

	<comment type="block">/*
	 * A valid file name is not passed, so search the complete directory.  If
	 * we find any file whose name is a valid WAL file name then try to open
	 * it.  If we cannot open it, bail out.
	 */</comment>
	<if type="elseif">else if <condition>(<expr><operator>(</operator><name>xldir</name> <operator>=</operator> <call><name>opendir</name><argument_list>(<argument><expr><name>directory</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name><name>struct</name> <name>dirent</name></name> <modifier>*</modifier></type><name>xlde</name></decl>;</decl_stmt>

		<while>while <condition>(<expr><operator>(</operator><name>xlde</name> <operator>=</operator> <call><name>readdir</name><argument_list>(<argument><expr><name>xldir</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><call><name>is_flashback_log_file</name><argument_list>(<argument><expr><name><name>xlde</name><operator>-&gt;</operator><name>d_name</name></name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>fd</name> <operator>=</operator> <call><name>open_file_in_directory</name><argument_list>(<argument><expr><name>directory</name></expr></argument>, <argument><expr><name><name>xlde</name><operator>-&gt;</operator><name>d_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>fname</name> <operator>=</operator> <name><name>xlde</name><operator>-&gt;</operator><name>d_name</name></name></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></while>

		<expr_stmt><expr><call><name>closedir</name><argument_list>(<argument><expr><name>xldir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* set segment_size if file is successfully opened */</comment>
	<if_stmt><if>if <condition>(<expr><name>fd</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>pg_aligned_flashback_log_blk</name></type> <name>buf</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>read</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name><name>buf</name><operator>.</operator><name>data</name></name></expr></argument>, <argument><expr><name>POLAR_FLOG_BLCKSZ</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>POLAR_FLOG_BLCKSZ</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>polar_long_page_header</name></type> <name>longhdr</name> <init>= <expr><operator>(</operator><name>polar_long_page_header</name><operator>)</operator> <name><name>buf</name><operator>.</operator><name>data</name></name></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><name>segment_size</name> <operator>=</operator> <name><name>longhdr</name><operator>-&gt;</operator><name>xlp_seg_size</name></name></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name>segment_size</name> <operator>!=</operator> <name>POLAR_FLOG_SEG_SIZE</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>fatal_error</name><argument_list>(<argument><expr><literal type="string">"Flashback log segment size in the binary is %d, "</literal>
							<literal type="string">"but the flashback log file \"%s\" header specifies %d byte"</literal></expr></argument>,
							<argument><expr><name>POLAR_FLOG_SEG_SIZE</name></expr></argument>, <argument><expr><name>fname</name></expr></argument>, <argument><expr><name>segment_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><name>just_version</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"The flashback log segment file page struct version no is: %hu"</literal></expr></argument>,
					   <argument><expr><name><name>longhdr</name><operator>-&gt;</operator><name>std</name><operator>.</operator><name>xlp_version</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><name>EXIT_SUCCESS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>errno</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>fatal_error</name><argument_list>(<argument><expr><literal type="string">"could not read file \"%s\": %s"</literal></expr></argument>,
							<argument><expr><name>fname</name></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>fatal_error</name><argument_list>(<argument><expr><literal type="string">"not enough data in file \"%s\""</literal></expr></argument>, <argument><expr><name>fname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
		</block_content>}</block></else></if_stmt>

		<expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Identify the target directory and set segment size.
 *
 * Try to find the file in several places:
 * if directory != NULL:
 *   directory /
 *   directory / POLAR_FLASHBACK_LOG_DEFAULT_DIR /
 * else
 *   .
 *   POLAR_FLASHBACK_LOG_DEFAULT_DIR /
 *   $PGDATA / POLAR_FLASHBACK_LOG_DEFAULT_DIR /
 *
 * Set the valid target directory in private-&gt;inpath.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>identify_target_directory</name><parameter_list>(<parameter><decl><type><name>dump_private</name> <modifier>*</modifier></type><name>private</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>directory</name></decl></parameter>,
						  <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>fname</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name></type>        <name><name>fpath</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>directory</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>search_directory</name><argument_list>(<argument><expr><name>directory</name></expr></argument>, <argument><expr><name>fname</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>private</name><operator>-&gt;</operator><name>inpath</name></name> <operator>=</operator> <call><name>strdup</name><argument_list>(<argument><expr><name>directory</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return;</return>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* directory / POLAR_FLASHBACK_LOG_DEFAULT_DIR */</comment>
		<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>fpath</name></expr></argument>, <argument><expr><name>MAXPGPATH</name></expr></argument>, <argument><expr><literal type="string">"%s/%s"</literal></expr></argument>, <argument><expr><name>directory</name></expr></argument>, <argument><expr><name>POLAR_FL_DEFAULT_DIR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>search_directory</name><argument_list>(<argument><expr><name>fpath</name></expr></argument>, <argument><expr><name>fname</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>private</name><operator>-&gt;</operator><name>inpath</name></name> <operator>=</operator> <call><name>strdup</name><argument_list>(<argument><expr><name>fpath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>datadir</name></decl>;</decl_stmt>

		<comment type="block">/* current directory */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>search_directory</name><argument_list>(<argument><expr><literal type="string">"."</literal></expr></argument>, <argument><expr><name>fname</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>private</name><operator>-&gt;</operator><name>inpath</name></name> <operator>=</operator> <call><name>strdup</name><argument_list>(<argument><expr><literal type="string">"."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return;</return>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* POLAR_FLASHBACK_LOG_DEFAULT_DIR */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>search_directory</name><argument_list>(<argument><expr><name>POLAR_FL_DEFAULT_DIR</name></expr></argument>, <argument><expr><name>fname</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>private</name><operator>-&gt;</operator><name>inpath</name></name> <operator>=</operator> <call><name>strdup</name><argument_list>(<argument><expr><name>POLAR_FL_DEFAULT_DIR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return;</return>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name>datadir</name> <operator>=</operator> <call><name>getenv</name><argument_list>(<argument><expr><literal type="string">"PGDATA"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* $PGDATA / POLAR_FLASHBACK_LOG_DEFAULT_DIR */</comment>
		<if_stmt><if>if <condition>(<expr><name>datadir</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>fpath</name></expr></argument>, <argument><expr><name>MAXPGPATH</name></expr></argument>, <argument><expr><literal type="string">"%s/%s"</literal></expr></argument>, <argument><expr><name>datadir</name></expr></argument>, <argument><expr><name>POLAR_FL_DEFAULT_DIR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>search_directory</name><argument_list>(<argument><expr><name>fpath</name></expr></argument>, <argument><expr><name>fname</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name><name>private</name><operator>-&gt;</operator><name>inpath</name></name> <operator>=</operator> <call><name>strdup</name><argument_list>(<argument><expr><name>fpath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return;</return>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/* could not locate WAL file */</comment>
	<if_stmt><if>if <condition>(<expr><name>fname</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>fatal_error</name><argument_list>(<argument><expr><literal type="string">"could not locate flashback log file \"%s\""</literal></expr></argument>, <argument><expr><name>fname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>fatal_error</name><argument_list>(<argument><expr><literal type="string">"could not find any flashback log file"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Read count bytes from a segment file in the specified directory,
 * containing the specified record pointer; store the data in
 * the passed buffer.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>flog_dump_read</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>directory</name></decl></parameter>, <parameter><decl><type><name>polar_flog_rec_ptr</name></type> <name>startptr</name></decl></parameter>,
			   <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><name>Size</name></type> <name>count</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>polar_flog_rec_ptr</name></type>  <name>recptr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Size</name></type>        <name>nbytes</name></decl>;</decl_stmt>

	<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type>  <name>sendFile</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>static</specifier> <name>uint64</name></type> <name>sendSegNo</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>static</specifier> <name>uint32</name></type> <name>sendOff</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>p</name> <operator>=</operator> <name>buf</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>recptr</name> <operator>=</operator> <name>startptr</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>nbytes</name> <operator>=</operator> <name>count</name></expr>;</expr_stmt>

	<while>while <condition>(<expr><name>nbytes</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>uint32</name></type>      <name>startoff</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>         <name>segbytes</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>         <name>readbytes</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>startoff</name> <operator>=</operator> <call><name>FLOG_SEGMENT_OFFSET</name><argument_list>(<argument><expr><name>recptr</name></expr></argument>, <argument><expr><name>segment_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>sendFile</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator> <operator>!</operator><call><name>ptr_in_flog_seg</name><argument_list>(<argument><expr><name>recptr</name></expr></argument>, <argument><expr><name>sendSegNo</name></expr></argument>, <argument><expr><name>segment_size</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>char</name></type>        <name><name>fname</name><index>[<expr><name>FLOG_MAX_FNAME_LEN</name></expr>]</index></name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int</name></type>         <name>tries</name></decl>;</decl_stmt>

			<comment type="block">/* Switch to another logfile segment */</comment>
			<if_stmt><if>if <condition>(<expr><name>sendFile</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name>sendFile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<expr_stmt><expr><name>sendSegNo</name> <operator>=</operator> <call><name>flog_ptr_to_seg</name><argument_list>(<argument><expr><name>recptr</name></expr></argument>, <argument><expr><name>segment_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>get_flog_fname</name><argument_list>(<argument><expr><name>fname</name></expr></argument>, <argument><expr><name>sendSegNo</name></expr></argument>, <argument><expr><name>segment_size</name></expr></argument>, <argument><expr><name>FLOG_DEFAULT_TIMELINE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * In follow mode there is a short period of time after the server
			 * has written the end of the previous file before the new file is
			 * available. So we loop for 5 seconds looking for the file to
			 * appear before giving up.
			 */</comment>
			<for>for <control>(<init><expr><name>tries</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>tries</name> <operator>&lt;</operator> <literal type="number">10</literal></expr>;</condition> <incr><expr><name>tries</name><operator>++</operator></expr></incr>)</control>
			<block>{<block_content>
				<expr_stmt><expr><name>sendFile</name> <operator>=</operator> <call><name>open_file_in_directory</name><argument_list>(<argument><expr><name>directory</name></expr></argument>, <argument><expr><name>fname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<if_stmt><if>if <condition>(<expr><name>sendFile</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
					<break>break;</break></block_content></block></if></if_stmt>

				<if_stmt><if>if <condition>(<expr><name>errno</name> <operator>==</operator> <name>ENOENT</name></expr>)</condition>
				<block>{<block_content>
					<decl_stmt><decl><type><name>int</name></type>         <name>save_errno</name> <init>= <expr><name>errno</name></expr></init></decl>;</decl_stmt>

					<comment type="block">/* File not there yet, try again */</comment>
					<expr_stmt><expr><call><name>pg_usleep</name><argument_list>(<argument><expr><literal type="number">500</literal> <operator>*</operator> <literal type="number">1000</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<expr_stmt><expr><name>errno</name> <operator>=</operator> <name>save_errno</name></expr>;</expr_stmt>
					<continue>continue;</continue>
				</block_content>}</block></if></if_stmt>

				<comment type="block">/* Any other error, fall through and fail */</comment>
				<break>break;</break>
			</block_content>}</block></for>


			<if_stmt><if>if <condition>(<expr><name>sendFile</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>fatal_error</name><argument_list>(<argument><expr><literal type="string">"could not find file \"%s\": %s"</literal></expr></argument>,
							<argument><expr><name>fname</name></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<expr_stmt><expr><name>sendOff</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* Need to seek in the file? */</comment>
		<if_stmt><if>if <condition>(<expr><name>sendOff</name> <operator>!=</operator> <name>startoff</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><call><name>lseek</name><argument_list>(<argument><expr><name>sendFile</name></expr></argument>, <argument><expr><operator>(</operator><name>off_t</name><operator>)</operator> <name>startoff</name></expr></argument>, <argument><expr><name>SEEK_SET</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>int</name></type>         <name>err</name> <init>= <expr><name>errno</name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>char</name></type>        <name><name>fname</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>get_flog_fname</name><argument_list>(<argument><expr><name>fname</name></expr></argument>, <argument><expr><name>sendSegNo</name></expr></argument>, <argument><expr><name>segment_size</name></expr></argument>, <argument><expr><name>FLOG_DEFAULT_TIMELINE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><call><name>fatal_error</name><argument_list>(<argument><expr><literal type="string">"could not seek in log file %s to offset %u: %s"</literal></expr></argument>,
							<argument><expr><name>fname</name></expr></argument>, <argument><expr><name>startoff</name></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>err</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<expr_stmt><expr><name>sendOff</name> <operator>=</operator> <name>startoff</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* How many bytes are within this segment? */</comment>
		<if_stmt><if>if <condition>(<expr><name>nbytes</name> <operator>&gt;</operator> <operator>(</operator><name>segment_size</name> <operator>-</operator> <name>startoff</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>segbytes</name> <operator>=</operator> <name>segment_size</name> <operator>-</operator> <name>startoff</name></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>segbytes</name> <operator>=</operator> <name>nbytes</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<expr_stmt><expr><name>readbytes</name> <operator>=</operator> <call><name>read</name><argument_list>(<argument><expr><name>sendFile</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>segbytes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>readbytes</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>int</name></type>         <name>err</name> <init>= <expr><name>errno</name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>char</name></type>        <name><name>fname</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>get_flog_fname</name><argument_list>(<argument><expr><name>fname</name></expr></argument>, <argument><expr><name>sendSegNo</name></expr></argument>, <argument><expr><name>segment_size</name></expr></argument>, <argument><expr><name>FLOG_DEFAULT_TIMELINE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>fatal_error</name><argument_list>(<argument><expr><literal type="string">"could not read from log file %s, offset %u, length %d: %s"</literal></expr></argument>,
						<argument><expr><name>fname</name></expr></argument>, <argument><expr><name>sendOff</name></expr></argument>, <argument><expr><name>segbytes</name></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>err</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* Update state for read */</comment>
		<expr_stmt><expr><name>recptr</name> <operator>+=</operator> <name>readbytes</name></expr>;</expr_stmt>

		<expr_stmt><expr><name>sendOff</name> <operator>+=</operator> <name>readbytes</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>nbytes</name> <operator>-=</operator> <name>readbytes</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>p</name> <operator>+=</operator> <name>readbytes</name></expr>;</expr_stmt>
	</block_content>}</block></while>
</block_content>}</block></function>

<comment type="block">/*
 * flashback log read_page callback
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>flog_dump_read_page</name><parameter_list>(<parameter><decl><type><name>flog_reader_state</name> <modifier>*</modifier></type><name>state</name></decl></parameter>,
					<parameter><decl><type><name>polar_flog_rec_ptr</name></type> <name>targetPagePtr</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>reqLen</name></decl></parameter>,
					<parameter><decl><type><name>polar_flog_rec_ptr</name></type> <name>targetRecPtr</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>cur_page</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>dump_private</name> <modifier>*</modifier></type><name>private</name> <init>= <expr><name><name>state</name><operator>-&gt;</operator><name>private_data</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>         <name>count</name> <init>= <expr><name>POLAR_FLOG_BLCKSZ</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>private</name><operator>-&gt;</operator><name>endptr</name></name> <operator>!=</operator> <name>POLAR_INVALID_FLOG_REC_PTR</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>targetPagePtr</name> <operator>+</operator> <name>POLAR_FLOG_BLCKSZ</name> <operator>&lt;=</operator> <name><name>private</name><operator>-&gt;</operator><name>endptr</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>count</name> <operator>=</operator> <name>POLAR_FLOG_BLCKSZ</name></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><name>targetPagePtr</name> <operator>+</operator> <name>reqLen</name> <operator>&lt;=</operator> <name><name>private</name><operator>-&gt;</operator><name>endptr</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>count</name> <operator>=</operator> <name><name>private</name><operator>-&gt;</operator><name>endptr</name></name> <operator>-</operator> <name>targetPagePtr</name></expr>;</expr_stmt></block_content></block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><name><name>private</name><operator>-&gt;</operator><name>endptr_reached</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>flog_dump_read</name><argument_list>(<argument><expr><name><name>private</name><operator>-&gt;</operator><name>inpath</name></name></expr></argument>, <argument><expr><name>targetPagePtr</name></expr></argument>,
				   <argument><expr><name>cur_page</name></expr></argument>, <argument><expr><name>count</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>count</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>
<name>get_flog_rec_type</name><parameter_list>(<parameter><decl><type><name>flog_record</name> <modifier>*</modifier></type><name>record</name></decl></parameter>, <parameter><decl><type><name>polar_flog_rec_ptr</name></type> <name>lsn</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>RmgrId</name></type>      <name>xl_rmgr</name> <init>= <expr><name><name>record</name><operator>-&gt;</operator><name>xl_rmid</name></name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>xl_rmgr</name> <operator>&lt;</operator> <name>FLASHBACK_LOG_REC_TYPES</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name><name>flashback_log_record_types</name><index>[<expr><name>xl_rmgr</name></expr>]</index></name></expr>;</return></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>fatal_error</name><argument_list>(<argument><expr><literal type="string">"The type of the record %X/%08X is wrong, \n"</literal></expr></argument>,
					<argument><expr><operator>(</operator><name>uint32</name><operator>)</operator><operator>(</operator><name>lsn</name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr></argument>, <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator><name>lsn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Print a record to stdout
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>flog_display_rec</name><parameter_list>(<parameter><decl><type><name>dump_config</name> <modifier>*</modifier></type><name>config</name></decl></parameter>, <parameter><decl><type><name>flog_record</name> <modifier>*</modifier></type><name>record</name></decl></parameter>,
				 <parameter><decl><type><name>polar_flog_rec_ptr</name></type> <name>lsn</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>uint32</name></type>      <name>rec_len</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint8</name></type>       <name>info</name> <init>= <expr><name><name>record</name><operator>-&gt;</operator><name>xl_info</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>polar_flog_rec_ptr</name></type>  <name>xl_prev</name> <init>= <expr><name><name>record</name><operator>-&gt;</operator><name>xl_prev</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BufferTag</name></type>   <name>tag</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RmgrId</name></type>      <name>rmid</name></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>fl_rec_img_header</name> <modifier>*</modifier></type><name>img</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>fl_rec_img_comp_header</name> <modifier>*</modifier></type><name>c_img</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>record_data</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>record_data_len</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint16</name></type> <name>hole_length</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PGAlignedBlock</name></type> <name>tmp</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PGAlignedBlock</name></type> <name>page</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint16</name></type> <name>checksum</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PageHeader</name></type>  <name>p</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>XLogRecPtr</name></type>  <name>redo_lsn</name> <init>= <expr><name>InvalidXLogRecPtr</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>from_origin_buf</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>CLEAR_BUFFERTAG</name><argument_list>(<argument><expr><name>tag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>rec_len</name> <operator>=</operator> <name><name>record</name><operator>-&gt;</operator><name>xl_tot_len</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>rmid</name> <operator>=</operator> <name><name>record</name><operator>-&gt;</operator><name>xl_rmid</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>record_data</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>record</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"type: %16s total_len: %6u, tx: %10u, lsn: %X/%08X, prev %X/%08X, "</literal></expr></argument>,
		   <argument><expr><call><name>get_flog_rec_type</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><name>lsn</name></expr></argument>)</argument_list></call></expr></argument>,
		   <argument><expr><name>rec_len</name></expr></argument>, <argument><expr><name><name>record</name><operator>-&gt;</operator><name>xl_xid</name></name></expr></argument>, <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator><operator>(</operator><name>lsn</name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr></argument>, <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <name>lsn</name></expr></argument>,
		   <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator><operator>(</operator><name>xl_prev</name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr></argument>, <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <name>xl_prev</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>rmid</name> <operator>==</operator> <name>ORIGIN_PAGE_ID</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>uint8</name></type> <name>type</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>tag</name> <operator>=</operator> <call><name>FL_GET_ORIGIN_PAGE_REC_DATA</name><argument_list>(<argument><expr><name>record</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>tag</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>redo_lsn</name> <operator>=</operator> <call><name>FL_GET_ORIGIN_PAGE_REC_DATA</name><argument_list>(<argument><expr><name>record</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>redo_lsn</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>type</name> <operator>=</operator> <name>info</name> <operator>&amp;</operator> <name>ORIGIN_PAGE_TYPE_MASK</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>from_origin_buf</name> <operator>=</operator> <name>info</name> <operator>&amp;</operator> <name>FROM_ORIGIN_BUF</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"desc: %s, "</literal></expr></argument>, <argument><expr><ternary><condition><expr><name>type</name> <operator>==</operator> <name>ORIGIN_PAGE_EMPTY</name></expr> ?</condition><then> <expr><literal type="string">"empty page"</literal></expr> </then><else>: <expr><literal type="string">"full  page"</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>config</name><operator>-&gt;</operator><name>bkp_details</name></name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>rmid</name> <operator>==</operator> <name>ORIGIN_PAGE_ID</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"rel %u/%u/%u fork %s blk %u; WAL redo lsn %X/%08X"</literal></expr></argument>,
				   <argument><expr><name><name>tag</name><operator>.</operator><name>rnode</name><operator>.</operator><name>spcNode</name></name></expr></argument>, <argument><expr><name><name>tag</name><operator>.</operator><name>rnode</name><operator>.</operator><name>dbNode</name></name></expr></argument>, <argument><expr><name><name>tag</name><operator>.</operator><name>rnode</name><operator>.</operator><name>relNode</name></name></expr></argument>,
				   <argument><expr><name><name>forkNames</name><index>[<expr><name><name>tag</name><operator>.</operator><name>forkNum</name></name></expr>]</index></name></expr></argument>, <argument><expr><name><name>tag</name><operator>.</operator><name>blockNum</name></name></expr></argument>,
				   <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator><operator>(</operator><name>redo_lsn</name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr></argument>, <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <name>redo_lsn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>putchar</name><argument_list>(<argument><expr><literal type="char">'\n'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* print block references (detailed format) */</comment>
		<expr_stmt><expr><call><name>putchar</name><argument_list>(<argument><expr><literal type="char">'\n'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>rmid</name> <operator>==</operator> <name>ORIGIN_PAGE_ID</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>origin_page_source</name></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name>from_origin_buf</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>origin_page_source</name> <operator>=</operator> <literal type="string">"from origin page buffer"</literal></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name>origin_page_source</name> <operator>=</operator> <literal type="string">"from disk"</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>

			<expr_stmt><expr><name>info</name> <operator>&amp;=</operator> <name>ORIGIN_PAGE_TYPE_MASK</name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"\trel %u/%u/%u fork %s blk %u; WAL redo lsn %X/%08X"</literal></expr></argument>,
				   <argument><expr><name><name>tag</name><operator>.</operator><name>rnode</name><operator>.</operator><name>spcNode</name></name></expr></argument>, <argument><expr><name><name>tag</name><operator>.</operator><name>rnode</name><operator>.</operator><name>dbNode</name></name></expr></argument>, <argument><expr><name><name>tag</name><operator>.</operator><name>rnode</name><operator>.</operator><name>relNode</name></name></expr></argument>,
				   <argument><expr><name><name>forkNames</name><index>[<expr><name><name>tag</name><operator>.</operator><name>forkNum</name></name></expr>]</index></name></expr></argument>, <argument><expr><name><name>tag</name><operator>.</operator><name>blockNum</name></name></expr></argument>,
				   <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator><operator>(</operator><name>redo_lsn</name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr></argument>, <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <name>redo_lsn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name>info</name> <operator>==</operator> <name>ORIGIN_PAGE_EMPTY</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">" (empty original page %s)"</literal></expr></argument>, <argument><expr><name>origin_page_source</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<if type="elseif">else if <condition>(<expr><name>info</name> <operator>==</operator> <name>ORIGIN_PAGE_FULL</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>img</name> <operator>=</operator> <call><name>FL_GET_ORIGIN_PAGE_IMG_HEADER</name><argument_list>(<argument><expr><name>record</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>record_data</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>img</name> <operator>+</operator> <name>FL_REC_IMG_HEADER_SIZE</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>record_data_len</name> <operator>=</operator> <name><name>img</name><operator>-&gt;</operator><name>length</name></name></expr>;</expr_stmt>

				<if_stmt><if>if <condition>(<expr><name><name>img</name><operator>-&gt;</operator><name>bimg_info</name></name> <operator>&amp;</operator> <name>IMAGE_IS_COMPRESSED</name></expr>)</condition>
				<block>{<block_content>
					<if_stmt><if>if <condition>(<expr><name><name>img</name><operator>-&gt;</operator><name>bimg_info</name></name> <operator>&amp;</operator> <name>IMAGE_HAS_HOLE</name></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><name>c_img</name> <operator>=</operator> <operator>(</operator><name>fl_rec_img_comp_header</name> <operator>*</operator><operator>)</operator> <name>record_data</name></expr>;</expr_stmt>
						<expr_stmt><expr><name>record_data</name> <operator>+=</operator> <name>FL_REC_IMG_COMP_HEADER_SIZE</name></expr>;</expr_stmt>
						<expr_stmt><expr><name>hole_length</name> <operator>=</operator> <name><name>c_img</name><operator>-&gt;</operator><name>hole_length</name></name></expr>;</expr_stmt>
					</block_content>}</block></if></if_stmt>

					<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">" (full original page %s); hole: offset: %u, length: %u, "</literal>
						   <literal type="string">"compression saved: %u"</literal></expr></argument>, <argument><expr><name>origin_page_source</name></expr></argument>, <argument><expr><name><name>img</name><operator>-&gt;</operator><name>hole_offset</name></name></expr></argument>,
						   <argument><expr><name>hole_length</name></expr></argument>, <argument><expr><name><name>img</name><operator>-&gt;</operator><name>length</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<if_stmt><if>if <condition>(<expr><name><name>config</name><operator>-&gt;</operator><name>checksum</name></name></expr>)</condition>
					<block>{<block_content>
						<if_stmt><if>if <condition>(<expr><call><name>pglz_decompress</name><argument_list>(<argument><expr><name>record_data</name></expr></argument>, <argument><expr><name>record_data_len</name></expr></argument>, <argument><expr><name><name>tmp</name><operator>.</operator><name>data</name></name></expr></argument>,
											<argument><expr><name>BLCKSZ</name> <operator>-</operator> <name>hole_length</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
							<expr_stmt><expr><call><name>fatal_error</name><argument_list>(<argument><expr><literal type="string">"invalid compressed origin page at %X/%X"</literal></expr></argument>,
										<argument><expr><operator>(</operator><name>uint32</name><operator>)</operator><operator>(</operator><name>lsn</name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr></argument>, <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <name>lsn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

						<expr_stmt><expr><name>record_data</name> <operator>=</operator> <name><name>tmp</name><operator>.</operator><name>data</name></name></expr>;</expr_stmt>
					</block_content>}</block></if></if_stmt>
				</block_content>}</block></if>
				<if type="elseif">else if <condition>(<expr><name><name>img</name><operator>-&gt;</operator><name>bimg_info</name></name> <operator>&amp;</operator> <name>IMAGE_HAS_HOLE</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name>hole_length</name> <operator>=</operator> <name>BLCKSZ</name> <operator>-</operator> <name><name>img</name><operator>-&gt;</operator><name>length</name></name></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">" (full original page %s); hole: offset: %u, length: %u; data length: %u"</literal></expr></argument>,
							<argument><expr><name>origin_page_source</name></expr></argument>, <argument><expr><name><name>img</name><operator>-&gt;</operator><name>hole_offset</name></name></expr></argument>, <argument><expr><name>hole_length</name></expr></argument>, <argument><expr><name><name>img</name><operator>-&gt;</operator><name>length</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">" (full original page %s); data length: %u"</literal></expr></argument>, <argument><expr><name>origin_page_source</name></expr></argument>, <argument><expr><name><name>img</name><operator>-&gt;</operator><name>length</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

				<if_stmt><if>if <condition>(<expr><name><name>config</name><operator>-&gt;</operator><name>checksum</name></name></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/* generate page, taking into account hole if necessary */</comment>
					<if_stmt><if>if <condition>(<expr><name>hole_length</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>img</name><operator>-&gt;</operator><name>length</name></name> <operator>==</operator> <name>BLCKSZ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>page</name><operator>.</operator><name>data</name></name></expr></argument>, <argument><expr><name>record_data</name></expr></argument>, <argument><expr><name>BLCKSZ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block></if>
					<else>else
					<block>{<block_content>
						<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>page</name><operator>.</operator><name>data</name></name></expr></argument>, <argument><expr><name>record_data</name></expr></argument>, <argument><expr><name><name>img</name><operator>-&gt;</operator><name>hole_offset</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<comment type="block">/* must zero-fill the hole */</comment>
						<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><name><name>page</name><operator>.</operator><name>data</name></name> <operator>+</operator> <name><name>img</name><operator>-&gt;</operator><name>hole_offset</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>hole_length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>page</name><operator>.</operator><name>data</name></name> <operator>+</operator> <operator>(</operator><name><name>img</name><operator>-&gt;</operator><name>hole_offset</name></name> <operator>+</operator> <name>hole_length</name><operator>)</operator></expr></argument>,
							   <argument><expr><name>record_data</name> <operator>+</operator> <name><name>img</name><operator>-&gt;</operator><name>hole_offset</name></name></expr></argument>,
							   <argument><expr><name>BLCKSZ</name> <operator>-</operator> <operator>(</operator><name><name>img</name><operator>-&gt;</operator><name>hole_offset</name></name> <operator>+</operator> <name>hole_length</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block></else></if_stmt>

					<comment type="block">/* Checksum again */</comment>
					<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>PageIsNew</name><argument_list>(<argument><expr><name><name>page</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><name>checksum</name> <operator>=</operator> <call><name>pg_checksum_page</name><argument_list>(<argument><expr><name><name>page</name><operator>.</operator><name>data</name></name></expr></argument>, <argument><expr><name><name>tag</name><operator>.</operator><name>blockNum</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><name>p</name> <operator>=</operator> <operator>(</operator><name>PageHeader</name><operator>)</operator> <name><name>page</name><operator>.</operator><name>data</name></name></expr>;</expr_stmt>

						<if_stmt><if>if <condition>(<expr><name>checksum</name> <operator>!=</operator> <name><name>p</name><operator>-&gt;</operator><name>pd_checksum</name></name></expr>)</condition><block type="pseudo"><block_content>
							<expr_stmt><expr><call><name>fatal_error</name><argument_list>(<argument><expr><literal type="string">"\nError: invalid checksum of origin page at %X/%X, "</literal>
										<literal type="string">"expected is %d, but is %d"</literal></expr></argument>,
										<argument><expr><operator>(</operator><name>uint32</name><operator>)</operator><operator>(</operator><name>lsn</name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr></argument>, <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <name>lsn</name></expr></argument>,
										<argument><expr><name>checksum</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>pd_checksum</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
					</block_content>}</block></if></if_stmt>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>fatal_error</name><argument_list>(<argument><expr><literal type="string">"invalid xl_info %d for the record at %X/%X"</literal></expr></argument>, <argument><expr><name>info</name></expr></argument>,
							<argument><expr><operator>(</operator><name>uint32</name><operator>)</operator><operator>(</operator><name>lsn</name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr></argument>, <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <name>lsn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

			<expr_stmt><expr><call><name>putchar</name><argument_list>(<argument><expr><literal type="char">'\n'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>fatal_error</name><argument_list>(<argument><expr><literal type="string">"invalid rmid %d for the record at %X/%X"</literal></expr></argument>, <argument><expr><name>rmid</name></expr></argument>,
						<argument><expr><operator>(</operator><name>uint32</name><operator>)</operator><operator>(</operator><name>lsn</name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr></argument>, <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <name>lsn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>usage</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s decodes and displays PolarDB flashback logs for debugging.\n\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
		   <argument><expr><name>progname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Usage:\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"  %s [OPTION]... [STARTSEG [ENDSEG]]\n"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>progname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"\nOptions:\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"  -b, --bkp-details      output detailed information about original pages\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"  -c, --checksum         check the checksum of the original page \n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"  -e, --end=RECPTR       stop reading at flashback log location xx/xx\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"  -f, --follow           keep retrying after reaching end of flashback log \n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"  -n, --limit=N          number of records to display\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"  -p, --path=PATH        directory in which to find log segment files or a\n"</literal>
			 <literal type="string">"                         directory with a ./polar_flshbak_log that contains such files\n"</literal>
			 <literal type="string">"                         (default: current directory, ./polar_flshbak_log, $PGDATA/polar_flshbak_log)\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"  -t, --type=type        only show records within one type,\n"</literal>
			 <literal type="string">"                         use --type=list to list valid flashback log record types\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"  -s, --start=RECPTR     start reading at flashback log location xx/xx\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"  -o, --just-one-rec=PTR just parse one record without check at flashback log location xx/xx\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"  -V, --version          output flashback log page version information, then exit\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"  -r, --relfilenode      only show records within the relfilenode which format is xx/xx/xx\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"  -?, --help             show this help, then exit\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>int</name></type>
<name>flashback_log_file_dump_main</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>argv</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>dump_config</name></type> <name>config</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32</name></type>      <name>xlogid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32</name></type>      <name>xrecoff</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>dump_private</name></type> <name>private</name></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>flog_reader_state</name> <modifier>*</modifier></type><name>xlogreader_state</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>flog_record</name> <modifier>*</modifier></type><name>record</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>polar_flog_rec_ptr</name></type>  <name>first_record</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>errormsg</name></decl>;</decl_stmt>

	<decl_stmt><decl><type><specifier>static</specifier> <name><name>struct</name> <name>option</name></name></type> <name><name>long_options</name><index>[]</index></name> <init>=
	<expr><block>{
		<expr><block>{<expr><literal type="string">"bkp-details"</literal></expr>, <expr><name>no_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="char">'b'</literal></expr>}</block></expr>,
		<expr><block>{<expr><literal type="string">"checksum"</literal></expr>, <expr><name>no_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="char">'c'</literal></expr>}</block></expr>,
		<expr><block>{<expr><literal type="string">"end"</literal></expr>, <expr><name>required_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="char">'e'</literal></expr>}</block></expr>,
		<expr><block>{<expr><literal type="string">"follow"</literal></expr>, <expr><name>no_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="char">'f'</literal></expr>}</block></expr>,
		<expr><block>{<expr><literal type="string">"help"</literal></expr>, <expr><name>no_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="char">'?'</literal></expr>}</block></expr>,
		<expr><block>{<expr><literal type="string">"limit"</literal></expr>, <expr><name>required_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="char">'n'</literal></expr>}</block></expr>,
		<expr><block>{<expr><literal type="string">"path"</literal></expr>, <expr><name>required_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="char">'p'</literal></expr>}</block></expr>,
		<expr><block>{<expr><literal type="string">"type"</literal></expr>, <expr><name>required_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="char">'t'</literal></expr>}</block></expr>,
		<expr><block>{<expr><literal type="string">"start"</literal></expr>, <expr><name>required_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="char">'s'</literal></expr>}</block></expr>,
		<expr><block>{<expr><literal type="string">"version"</literal></expr>, <expr><name>no_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="char">'V'</literal></expr>}</block></expr>,
		<expr><block>{<expr><literal type="string">"relfilenode"</literal></expr>, <expr><name>required_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="char">'r'</literal></expr>}</block></expr>,
		<expr><block>{<expr><literal type="string">"just-one-rec"</literal></expr>, <expr><name>required_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="char">'o'</literal></expr>}</block></expr>,
		<expr><block>{<expr><name>NULL</name></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>NULL</name></expr>, <expr><literal type="number">0</literal></expr>}</block></expr>
	}</block></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>int</name></type>         <name>option</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>         <name>optindex</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32</name></type>      <name>spcnode</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32</name></type>      <name>dbnode</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32</name></type>      <name>relnode</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>progname</name> <operator>=</operator> <call><name>get_progname</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>private</name><operator>.</operator><name>startptr</name></name> <operator>=</operator> <name>POLAR_INVALID_FLOG_REC_PTR</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>private</name><operator>.</operator><name>endptr</name></name> <operator>=</operator> <name>POLAR_INVALID_FLOG_REC_PTR</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>private</name><operator>.</operator><name>endptr_reached</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>config</name><operator>.</operator><name>bkp_details</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>config</name><operator>.</operator><name>stop_after_records</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>config</name><operator>.</operator><name>already_displayed_records</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>config</name><operator>.</operator><name>follow</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<comment type="block">/* Set filter_by_type max_uint8 */</comment>
	<expr_stmt><expr><name><name>config</name><operator>.</operator><name>filter_by_type</name></name> <operator>=</operator> <literal type="number">255</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>config</name><operator>.</operator><name>checksum</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>config</name><operator>.</operator><name>rel_file_node</name><operator>.</operator><name>spcNode</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>argc</name> <operator>&lt;=</operator> <literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: no arguments specified\n"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>progname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<goto>goto <name>bad_argument</name>;</goto>
	</block_content>}</block></if></if_stmt>

	<while>while <condition>(<expr><operator>(</operator><name>option</name> <operator>=</operator> <call><name>getopt_long</name><argument_list>(<argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>, <argument><expr><literal type="string">"bce:?fn:o:p:s:t:Vr:"</literal></expr></argument>,
								 <argument><expr><name>long_options</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>optindex</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<switch>switch <condition>(<expr><name>option</name></expr>)</condition>
		<block>{<block_content>
			<case>case <expr><literal type="char">'b'</literal></expr>:</case>
				<expr_stmt><expr><name><name>config</name><operator>.</operator><name>bkp_details</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><literal type="char">'c'</literal></expr>:</case>
				<expr_stmt><expr><name><name>config</name><operator>.</operator><name>checksum</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><literal type="char">'e'</literal></expr>:</case>
				<if_stmt><if>if <condition>(<expr><call><name>sscanf</name><argument_list>(<argument><expr><name>optarg</name></expr></argument>, <argument><expr><literal type="string">"%X/%X"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>xlogid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>xrecoff</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">2</literal></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: could not parse end flashback log location \"%s\"\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
							<argument><expr><name>progname</name></expr></argument>, <argument><expr><name>optarg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<goto>goto <name>bad_argument</name>;</goto>
				</block_content>}</block></if></if_stmt>

				<expr_stmt><expr><name><name>private</name><operator>.</operator><name>endptr</name></name> <operator>=</operator> <operator>(</operator><name>uint64</name><operator>)</operator> <name>xlogid</name> <operator>&lt;&lt;</operator> <literal type="number">32</literal> <operator>|</operator> <name>xrecoff</name></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><literal type="char">'f'</literal></expr>:</case>
				<expr_stmt><expr><name><name>config</name><operator>.</operator><name>follow</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><literal type="char">'?'</literal></expr>:</case>
				<expr_stmt><expr><call><name>usage</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><name>EXIT_SUCCESS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><literal type="char">'n'</literal></expr>:</case>
				<if_stmt><if>if <condition>(<expr><call><name>sscanf</name><argument_list>(<argument><expr><name>optarg</name></expr></argument>, <argument><expr><literal type="string">"%d"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>config</name><operator>.</operator><name>stop_after_records</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: could not parse limit \"%s\"\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
							<argument><expr><name>progname</name></expr></argument>, <argument><expr><name>optarg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<goto>goto <name>bad_argument</name>;</goto>
				</block_content>}</block></if></if_stmt>

				<break>break;</break>

			<case>case <expr><literal type="char">'p'</literal></expr>:</case>
				<expr_stmt><expr><name><name>private</name><operator>.</operator><name>inpath</name></name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><name>optarg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><literal type="char">'t'</literal></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>uint8</name></type>           <name>i</name></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><call><name>pg_strcasecmp</name><argument_list>(<argument><expr><name>optarg</name></expr></argument>, <argument><expr><literal type="string">"list"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>print_type_list</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><name>EXIT_SUCCESS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>

				<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>FLASHBACK_LOG_REC_TYPES</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
				<block>{<block_content>
					<if_stmt><if>if <condition>(<expr><call><name>pg_strcasecmp</name><argument_list>(<argument><expr><name>optarg</name></expr></argument>, <argument><expr><name><name>flashback_log_record_types</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><name><name>config</name><operator>.</operator><name>filter_by_type</name></name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
						<break>break;</break>
					</block_content>}</block></if></if_stmt>
				</block_content>}</block></for>

				<if_stmt><if>if <condition>(<expr><name><name>config</name><operator>.</operator><name>filter_by_type</name></name> <operator>&gt;</operator> <name>FLASHBACK_LOG_REC_TYPES</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: type \"%s\" does not exist\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
							<argument><expr><name>progname</name></expr></argument>, <argument><expr><name>optarg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<goto>goto <name>bad_argument</name>;</goto>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block>
			<break>break;</break>

			<case>case <expr><literal type="char">'s'</literal></expr>:</case>
				<if_stmt><if>if <condition>(<expr><name><name>private</name><operator>.</operator><name>startptr</name></name> <operator>!=</operator> <name>POLAR_INVALID_FLOG_REC_PTR</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: could not run with option -s and option -o\n"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>progname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<goto>goto <name>bad_argument</name>;</goto>
				</block_content>}</block></if></if_stmt>

				<if_stmt><if>if <condition>(<expr><call><name>sscanf</name><argument_list>(<argument><expr><name>optarg</name></expr></argument>, <argument><expr><literal type="string">"%X/%X"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>xlogid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>xrecoff</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">2</literal></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: could not parse start flashback log location \"%s\"\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
							<argument><expr><name>progname</name></expr></argument>, <argument><expr><name>optarg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<goto>goto <name>bad_argument</name>;</goto>
				</block_content>}</block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><name><name>private</name><operator>.</operator><name>startptr</name></name> <operator>=</operator> <operator>(</operator><name>uint64</name><operator>)</operator> <name>xlogid</name> <operator>&lt;&lt;</operator> <literal type="number">32</literal> <operator>|</operator> <name>xrecoff</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

				<break>break;</break>

			<case>case <expr><literal type="char">'V'</literal></expr>:</case>
				<expr_stmt><expr><name>just_version</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><literal type="char">'o'</literal></expr>:</case>
				<if_stmt><if>if <condition>(<expr><name><name>private</name><operator>.</operator><name>startptr</name></name> <operator>!=</operator> <name>POLAR_INVALID_FLOG_REC_PTR</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: could not run with option -s and option -o\n"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>progname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<goto>goto <name>bad_argument</name>;</goto>
				</block_content>}</block></if></if_stmt>

				<if_stmt><if>if <condition>(<expr><call><name>sscanf</name><argument_list>(<argument><expr><name>optarg</name></expr></argument>, <argument><expr><literal type="string">"%X/%X"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>xlogid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>xrecoff</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">2</literal></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: could not parse the flashback log location \"%s\"\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
							<argument><expr><name>progname</name></expr></argument>, <argument><expr><name>optarg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<goto>goto <name>bad_argument</name>;</goto>
				</block_content>}</block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><name><name>private</name><operator>.</operator><name>startptr</name></name> <operator>=</operator> <operator>(</operator><name>uint64</name><operator>)</operator> <name>xlogid</name> <operator>&lt;&lt;</operator> <literal type="number">32</literal> <operator>|</operator> <name>xrecoff</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

				<expr_stmt><expr><name>just_one_record_without_check</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><literal type="char">'r'</literal></expr>:</case>
				<if_stmt><if>if <condition>(<expr><call><name>sscanf</name><argument_list>(<argument><expr><name>optarg</name></expr></argument>, <argument><expr><literal type="string">"%u/%u/%u"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>spcnode</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>dbnode</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>relnode</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">3</literal></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: could not parse relation flie node filter \"%s\"\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
							<argument><expr><name>progname</name></expr></argument>, <argument><expr><name>optarg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<goto>goto <name>bad_argument</name>;</goto>
				</block_content>}</block></if></if_stmt>

				<expr_stmt><expr><name><name>config</name><operator>.</operator><name>rel_file_node</name><operator>.</operator><name>spcNode</name></name> <operator>=</operator> <name>spcnode</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>config</name><operator>.</operator><name>rel_file_node</name><operator>.</operator><name>dbNode</name></name> <operator>=</operator> <name>dbnode</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>config</name><operator>.</operator><name>rel_file_node</name><operator>.</operator><name>relNode</name></name> <operator>=</operator> <name>relnode</name></expr>;</expr_stmt>
				<break>break;</break>

			<default>default:</default>
				<goto>goto <name>bad_argument</name>;</goto>
		</block_content>}</block></switch>
	</block_content>}</block></while>

	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>optind</name> <operator>+</operator> <literal type="number">2</literal><operator>)</operator> <operator>&lt;</operator> <name>argc</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>,
				<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: too many command-line arguments (first is \"%s\")\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
				<argument><expr><name>progname</name></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><name>optind</name> <operator>+</operator> <literal type="number">2</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<goto>goto <name>bad_argument</name>;</goto>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>private</name><operator>.</operator><name>inpath</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* validate path points to directory */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>verify_directory</name><argument_list>(<argument><expr><name><name>private</name><operator>.</operator><name>inpath</name></name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>,
					<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: path \"%s\" could not be opened: %s\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
					<argument><expr><name>progname</name></expr></argument>, <argument><expr><name><name>private</name><operator>.</operator><name>inpath</name></name></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<goto>goto <name>bad_argument</name>;</goto>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* parse files as start/end boundaries, extract path if not specified */</comment>
	<if_stmt><if>if <condition>(<expr><name>optind</name> <operator>&lt;</operator> <name>argc</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>directory</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>fname</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>         <name>fd</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>uint64</name></type>  <name>segno</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>split_path</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><name>optind</name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>directory</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>fname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>private</name><operator>.</operator><name>inpath</name></name> <operator>==</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name>directory</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>private</name><operator>.</operator><name>inpath</name></name> <operator>=</operator> <name>directory</name></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>verify_directory</name><argument_list>(<argument><expr><name><name>private</name><operator>.</operator><name>inpath</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>fatal_error</name><argument_list>(<argument><expr><literal type="string">"%s: could not open directory \"%s\": %s"</literal></expr></argument>,
							<argument><expr><name>progname</name></expr></argument>, <argument><expr><name><name>private</name><operator>.</operator><name>inpath</name></name></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>identify_target_directory</name><argument_list>(<argument><expr><operator>&amp;</operator><name>private</name></expr></argument>, <argument><expr><name><name>private</name><operator>.</operator><name>inpath</name></name></expr></argument>, <argument><expr><name>fname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>fd</name> <operator>=</operator> <call><name>open_file_in_directory</name><argument_list>(<argument><expr><name><name>private</name><operator>.</operator><name>inpath</name></name></expr></argument>, <argument><expr><name>fname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>fd</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>fatal_error</name><argument_list>(<argument><expr><literal type="string">"could not open file \"%s\""</literal></expr></argument>, <argument><expr><name>fname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* parse position from file */</comment>
		<expr_stmt><expr><call><name>get_flog_seg_from_fname</name><argument_list>(<argument><expr><name>fname</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>segno</name></expr></argument>, <argument><expr><name>segment_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>private</name><operator>.</operator><name>startptr</name></name> <operator>==</operator> <name>POLAR_INVALID_FLOG_REC_PTR</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>flog_seg_offset_to_ptr</name><argument_list>(<argument><expr><name>segno</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
								   <argument><expr><name>segment_size</name></expr></argument>, <argument><expr><name><name>private</name><operator>.</operator><name>startptr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>private</name><operator>.</operator><name>startptr</name></name> <operator>=</operator> <ternary><condition><expr><name><name>private</name><operator>.</operator><name>startptr</name></name> <operator>==</operator> <name>POLAR_INVALID_FLOG_REC_PTR</name></expr> ?</condition><then>
							   <expr><name>FLOG_LONG_PHD_SIZE</name></expr> </then><else>: <expr><name><name>private</name><operator>.</operator><name>startptr</name></name></expr></else></ternary></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>ptr_in_flog_seg</name><argument_list>(<argument><expr><name><name>private</name><operator>.</operator><name>startptr</name></name></expr></argument>, <argument><expr><name>segno</name></expr></argument>, <argument><expr><name>segment_size</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>,
					<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: start flashback log location "</literal>
					  <literal type="string">"%X/%X is not inside file \"%s\"\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
					<argument><expr><name>progname</name></expr></argument>,
					<argument><expr><operator>(</operator><name>uint32</name><operator>)</operator><operator>(</operator><name><name>private</name><operator>.</operator><name>startptr</name></name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr></argument>,
					<argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <name><name>private</name><operator>.</operator><name>startptr</name></name></expr></argument>,
					<argument><expr><name>fname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<goto>goto <name>bad_argument</name>;</goto>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* no second file specified, set end position */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>optind</name> <operator>+</operator> <literal type="number">1</literal> <operator>&lt;</operator> <name>argc</name><operator>)</operator> <operator>&amp;&amp;</operator> <name><name>private</name><operator>.</operator><name>endptr</name></name> <operator>==</operator> <name>POLAR_INVALID_FLOG_REC_PTR</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>flog_seg_offset_to_ptr</name><argument_list>(<argument><expr><name>segno</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
								   <argument><expr><name>segment_size</name></expr></argument>, <argument><expr><name><name>private</name><operator>.</operator><name>endptr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/* parse ENDSEG if passed */</comment>
		<if_stmt><if>if <condition>(<expr><name>optind</name> <operator>+</operator> <literal type="number">1</literal> <operator>&lt;</operator> <name>argc</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>uint64</name></type>  <name>endsegno</name></decl>;</decl_stmt>

			<comment type="block">/* ignore directory, already have that */</comment>
			<expr_stmt><expr><call><name>split_path</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><name>optind</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>directory</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>fname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name>fd</name> <operator>=</operator> <call><name>open_file_in_directory</name><argument_list>(<argument><expr><name><name>private</name><operator>.</operator><name>inpath</name></name></expr></argument>, <argument><expr><name>fname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name>fd</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>fatal_error</name><argument_list>(<argument><expr><literal type="string">"could not open file \"%s\""</literal></expr></argument>, <argument><expr><name>fname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* parse position from file */</comment>
			<expr_stmt><expr><call><name>get_flog_seg_from_fname</name><argument_list>(<argument><expr><name>fname</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>endsegno</name></expr></argument>, <argument><expr><name>segment_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name>endsegno</name> <operator>&lt;</operator> <name>segno</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>fatal_error</name><argument_list>(<argument><expr><literal type="string">"ENDSEG %s is before STARTSEG %s"</literal></expr></argument>,
							<argument><expr><name><name>argv</name><index>[<expr><name>optind</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><name>optind</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>private</name><operator>.</operator><name>endptr</name></name> <operator>==</operator> <name>POLAR_INVALID_FLOG_REC_PTR</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>flog_seg_offset_to_ptr</name><argument_list>(<argument><expr><name>endsegno</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
									   <argument><expr><name>segment_size</name></expr></argument>, <argument><expr><name><name>private</name><operator>.</operator><name>endptr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<comment type="block">/* set segno to endsegno for check of --end */</comment>
			<expr_stmt><expr><name>segno</name> <operator>=</operator> <name>endsegno</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ptr_in_flog_seg</name><argument_list>(<argument><expr><name><name>private</name><operator>.</operator><name>endptr</name></name></expr></argument>, <argument><expr><name>segno</name></expr></argument>, <argument><expr><name>segment_size</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
				<name><name>private</name><operator>.</operator><name>endptr</name></name> <operator>!=</operator> <operator>(</operator><name>segno</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>*</operator> <name>segment_size</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>,
					<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: end flashback log location %X/%X is not inside file \"%s\"\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
					<argument><expr><name>progname</name></expr></argument>, <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator><operator>(</operator><name><name>private</name><operator>.</operator><name>endptr</name></name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr></argument>,
					<argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <name><name>private</name><operator>.</operator><name>endptr</name></name></expr></argument>,
					<argument><expr><name><name>argv</name><index>[<expr><name>argc</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<goto>goto <name>bad_argument</name>;</goto>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>identify_target_directory</name><argument_list>(<argument><expr><operator>&amp;</operator><name>private</name></expr></argument>, <argument><expr><name><name>private</name><operator>.</operator><name>inpath</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/* we don't know what to print */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>private</name><operator>.</operator><name>startptr</name></name> <operator>==</operator> <name>POLAR_INVALID_FLOG_REC_PTR</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: no start flashback log location given\n"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>progname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<goto>goto <name>bad_argument</name>;</goto>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Get the switch ptr list first.
	 */</comment>
	<expr_stmt><expr><name>switch_ptr_list</name> <operator>=</operator> <call><name>load_switch_ptrs</name><argument_list>(<argument><expr><name><name>private</name><operator>.</operator><name>inpath</name></name></expr></argument>, <argument><expr><name>switch_ptr_list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* done with argument parsing, do the actual work */</comment>

	<comment type="block">/* we have everything we need, start reading */</comment>
	<expr_stmt><expr><name>xlogreader_state</name> <operator>=</operator> <call><name>flog_reader_allocate</name><argument_list>(<argument><expr><name>segment_size</name></expr></argument>,
											<argument><expr><name>flog_dump_read_page</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>private</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>xlogreader_state</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>fatal_error</name><argument_list>(<argument><expr><literal type="string">"out of memory"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* first find a valid recptr to start from */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>just_one_record_without_check</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>first_record</name> <operator>=</operator> <call><name>find_first_flog_rec</name><argument_list>(<argument><expr><name>xlogreader_state</name></expr></argument>, <argument><expr><name><name>private</name><operator>.</operator><name>startptr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>first_record</name> <operator>=</operator> <call><name>valid_flog_ptr</name><argument_list>(<argument><expr><name><name>private</name><operator>.</operator><name>startptr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>first_record</name> <operator>==</operator> <name>POLAR_INVALID_FLOG_REC_PTR</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>fatal_error</name><argument_list>(<argument><expr><literal type="string">"could not find a valid record after %X/%X"</literal></expr></argument>,
					<argument><expr><operator>(</operator><name>uint32</name><operator>)</operator><operator>(</operator><name><name>private</name><operator>.</operator><name>startptr</name></name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr></argument>,
					<argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <name><name>private</name><operator>.</operator><name>startptr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>first_record</name> <operator>&gt;=</operator> <name><name>private</name><operator>.</operator><name>endptr</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>fatal_error</name><argument_list>(<argument><expr><literal type="string">"could not find a valid record between %X/%X and %X/%X"</literal></expr></argument>,
					<argument><expr><operator>(</operator><name>uint32</name><operator>)</operator><operator>(</operator><name><name>private</name><operator>.</operator><name>startptr</name></name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr></argument>,
					<argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <name><name>private</name><operator>.</operator><name>startptr</name></name></expr></argument>,
					<argument><expr><operator>(</operator><name>uint32</name><operator>)</operator><operator>(</operator><name><name>private</name><operator>.</operator><name>endptr</name></name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr></argument>,
					<argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <name><name>private</name><operator>.</operator><name>endptr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Display a message that we're skipping data if `from` wasn't a pointer
	 * to the start of a record and also wasn't a pointer to the beginning of
	 * a segment (e.g. we were used in file mode).
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>first_record</name> <operator>!=</operator> <name><name>private</name><operator>.</operator><name>startptr</name></name> <operator>&amp;&amp;</operator>
			<call><name>FLOG_SEGMENT_OFFSET</name><argument_list>(<argument><expr><name><name>private</name><operator>.</operator><name>startptr</name></name></expr></argument>, <argument><expr><name>segment_size</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"first record is after %X/%X, at %X/%X, skipping over %u byte\n"</literal></expr></argument>,
			   <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator><operator>(</operator><name><name>private</name><operator>.</operator><name>startptr</name></name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr></argument>, <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <name><name>private</name><operator>.</operator><name>startptr</name></name></expr></argument>,
			   <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator><operator>(</operator><name>first_record</name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr></argument>, <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <name>first_record</name></expr></argument>,
			   <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator><operator>(</operator><name>first_record</name> <operator>-</operator> <name><name>private</name><operator>.</operator><name>startptr</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
	<block>{<block_content>
		<comment type="block">/* try to read the next record */</comment>
		<expr_stmt><expr><name>record</name> <operator>=</operator> <call><name>read_flog_record</name><argument_list>(<argument><expr><name>xlogreader_state</name></expr></argument>, <argument><expr><name>first_record</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>errormsg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>record</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name><name>xlogreader_state</name><operator>-&gt;</operator><name>in_switch_region</name></name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>first_record</name> <operator>=</operator> <name>POLAR_INVALID_FLOG_REC_PTR</name></expr>;</expr_stmt>
				<continue>continue;</continue>
			</block_content>}</block></if>
			<if type="elseif">else if <condition>(<expr><operator>!</operator><name><name>config</name><operator>.</operator><name>follow</name></name> <operator>||</operator> <name><name>private</name><operator>.</operator><name>endptr_reached</name></name></expr>)</condition><block type="pseudo"><block_content>
				<break>break;</break></block_content></block></if>
			<else>else
			<block>{<block_content>
				<expr_stmt><expr><call><name>pg_usleep</name><argument_list>(<argument><expr><literal type="number">1000000L</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>    <comment type="block">/* 1 second */</comment>
				<continue>continue;</continue>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* after reading the first record, continue at next one */</comment>
		<expr_stmt><expr><name>first_record</name> <operator>=</operator> <name>POLAR_INVALID_FLOG_REC_PTR</name></expr>;</expr_stmt>

		<comment type="block">/* apply all specified filters */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>config</name><operator>.</operator><name>filter_by_type</name></name> <operator>!=</operator> <literal type="number">255</literal> <operator>&amp;&amp;</operator>
				<name><name>config</name><operator>.</operator><name>filter_by_type</name></name> <operator>!=</operator> <name><name>record</name><operator>-&gt;</operator><name>xl_rmid</name></name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>record</name><operator>-&gt;</operator><name>xl_rmid</name></name> <operator>==</operator> <name>ORIGIN_PAGE_ID</name> <operator>&amp;&amp;</operator> <name><name>config</name><operator>.</operator><name>rel_file_node</name><operator>.</operator><name>spcNode</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>fl_origin_page_rec_data</name>       <modifier>*</modifier></type><name>rec_data</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>rec_data</name> <operator>=</operator> <call><name>FL_GET_ORIGIN_PAGE_REC_DATA</name><argument_list>(<argument><expr><name>record</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>config</name><operator>.</operator><name>rel_file_node</name><operator>.</operator><name>spcNode</name></name> <operator>!=</operator> <name><name>rec_data</name><operator>-&gt;</operator><name>tag</name><operator>.</operator><name>rnode</name><operator>.</operator><name>spcNode</name></name> <operator>||</operator>
					<name><name>config</name><operator>.</operator><name>rel_file_node</name><operator>.</operator><name>dbNode</name></name> <operator>!=</operator> <name><name>rec_data</name><operator>-&gt;</operator><name>tag</name><operator>.</operator><name>rnode</name><operator>.</operator><name>dbNode</name></name> <operator>||</operator>
					<name><name>config</name><operator>.</operator><name>rel_file_node</name><operator>.</operator><name>relNode</name></name> <operator>!=</operator> <name><name>rec_data</name><operator>-&gt;</operator><name>tag</name><operator>.</operator><name>rnode</name><operator>.</operator><name>relNode</name></name></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>flog_display_rec</name><argument_list>(<argument><expr><operator>&amp;</operator><name>config</name></expr></argument>, <argument><expr><name>record</name></expr></argument>, <argument><expr><name><name>xlogreader_state</name><operator>-&gt;</operator><name>read_rec_ptr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* check whether we printed enough */</comment>
		<expr_stmt><expr><name><name>config</name><operator>.</operator><name>already_displayed_records</name></name><operator>++</operator></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>config</name><operator>.</operator><name>stop_after_records</name></name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
				<name><name>config</name><operator>.</operator><name>already_displayed_records</name></name> <operator>&gt;=</operator> <name><name>config</name><operator>.</operator><name>stop_after_records</name></name></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>just_one_record_without_check</name></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>
	</block_content>}</block></for>

	<if_stmt><if>if <condition>(<expr><name>errormsg</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>fatal_error</name><argument_list>(<argument><expr><literal type="string">"error in flashback log record at %X/%X: %s"</literal></expr></argument>,
					<argument><expr><operator>(</operator><name>uint32</name><operator>)</operator><operator>(</operator><name><name>xlogreader_state</name><operator>-&gt;</operator><name>curr_rec_ptr</name></name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr></argument>,
					<argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <name><name>xlogreader_state</name><operator>-&gt;</operator><name>curr_rec_ptr</name></name></expr></argument>,
					<argument><expr><name>errormsg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>flog_reader_free</name><argument_list>(<argument><expr><name>xlogreader_state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>EXIT_SUCCESS</name></expr>;</return>

<label><name>bad_argument</name>:</label>
	<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Try \"%s --help\" for more information.\n"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>progname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>EXIT_FAILURE</name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/*no cover end*/</comment>
</unit>
