<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/PolarDB-for-PostgreSQL/src/common/exec.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * exec.c
 *		Functions for finding and validating executable files
 *
 *
 * Portions Copyright (c) 1996-2018, PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, Regents of the University of California
 *
 *
 * IDENTIFICATION
 *	  src/common/exec.c
 *
 *-------------------------------------------------------------------------
 */</comment>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>FRONTEND</name></cpp:ifndef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres_fe.h"</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;signal.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/stat.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/wait.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;unistd.h&gt;</cpp:file></cpp:include>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>FRONTEND</name></cpp:ifndef>
<comment type="block">/* We use only 3- and 4-parameter elog calls in this file, for simplicity */</comment>
<comment type="block">/* NOTE: caller must provide gettext call around str! */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>log_error</name><parameter_list>(<parameter><type><name>str</name></type></parameter>, <parameter><type><name>param</name></type></parameter>)</parameter_list></cpp:macro>	<cpp:value>elog(LOG, str, param)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>log_error4</name><parameter_list>(<parameter><type><name>str</name></type></parameter>, <parameter><type><name>param</name></type></parameter>, <parameter><type><name>arg1</name></type></parameter>)</parameter_list></cpp:macro>	<cpp:value>elog(LOG, str, param, arg1)</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>log_error</name><parameter_list>(<parameter><type><name>str</name></type></parameter>, <parameter><type><name>param</name></type></parameter>)</parameter_list></cpp:macro>	<cpp:value>(fprintf(stderr, str, param), fputc('\n', stderr))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>log_error4</name><parameter_list>(<parameter><type><name>str</name></type></parameter>, <parameter><type><name>param</name></type></parameter>, <parameter><type><name>arg1</name></type></parameter>)</parameter_list></cpp:macro>	<cpp:value>(fprintf(stderr, str, param, arg1), fputc('\n', stderr))</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_MSC_VER</name></cpp:ifdef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>getcwd</name><parameter_list>(<parameter><type><name>cwd</name></type></parameter>,<parameter><type><name>len</name></type></parameter>)</parameter_list></cpp:macro>  <cpp:value>GetCurrentDirectory(len, cwd)</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function_decl><type><specifier>static</specifier> <name>int</name></type>	<name>validate_exec</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>path</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type>	<name>resolve_symlinks</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>path</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>pipe_read_line</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>cmd</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>line</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>maxsize</name></decl></parameter>)</parameter_list>;</function_decl>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WIN32</name></cpp:ifdef>
<function_decl><type><specifier>static</specifier> <name>BOOL</name></type> <name>GetTokenUser</name><parameter_list>(<parameter><decl><type><name>HANDLE</name></type> <name>hToken</name></decl></parameter>, <parameter><decl><type><name>PTOKEN_USER</name> <modifier>*</modifier></type><name>ppTokenUser</name></decl></parameter>)</parameter_list>;</function_decl>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
 * validate_exec -- validate "path" as an executable file
 *
 * returns 0 if the file is found and no error is encountered.
 *		  -1 if the regular file "path" does not exist or cannot be executed.
 *		  -2 if the file is otherwise valid but cannot be read.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>validate_exec</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>path</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name><name>struct</name> <name>stat</name></name></type> <name>buf</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>is_r</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>is_x</name></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WIN32</name></cpp:ifdef>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>path_exe</name><index>[<expr><name>MAXPGPATH</name> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><literal type="string">".exe"</literal></expr></argument>)</argument_list></sizeof> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>

	<comment type="block">/* Win32 requires a .exe suffix for stat() */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>strlen</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <call><name>strlen</name><argument_list>(<argument><expr><literal type="string">".exe"</literal></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
		<call><name>pg_strcasecmp</name><argument_list>(<argument><expr><name>path</name> <operator>+</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call> <operator>-</operator> <call><name>strlen</name><argument_list>(<argument><expr><literal type="string">".exe"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">".exe"</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>strlcpy</name><argument_list>(<argument><expr><name>path_exe</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>path_exe</name></expr></argument>)</argument_list></sizeof> <operator>-</operator> <literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>strcat</name><argument_list>(<argument><expr><name>path_exe</name></expr></argument>, <argument><expr><literal type="string">".exe"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>path</name> <operator>=</operator> <name>path_exe</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<comment type="block">/*
	 * Ensure that the file exists and is a regular file.
	 *
	 * XXX if you have a broken system where stat() looks at the symlink
	 * instead of the underlying file, you lose.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>stat</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>S_ISREG</name><argument_list>(<argument><expr><name><name>buf</name><operator>.</operator><name>st_mode</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Ensure that the file is both executable and readable (required for
	 * dynamic loading).
	 */</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>WIN32</name></cpp:ifndef>
	<expr_stmt><expr><name>is_r</name> <operator>=</operator> <operator>(</operator><call><name>access</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>R_OK</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr>;</expr_stmt>
	<expr_stmt><expr><name>is_x</name> <operator>=</operator> <operator>(</operator><call><name>access</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>X_OK</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	<expr_stmt><expr><name>is_r</name> <operator>=</operator> <name><name>buf</name><operator>.</operator><name>st_mode</name></name> <operator>&amp;</operator> <name>S_IRUSR</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>is_x</name> <operator>=</operator> <name><name>buf</name><operator>.</operator><name>st_mode</name></name> <operator>&amp;</operator> <name>S_IXUSR</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<return>return <expr><ternary><condition><expr><name>is_x</name></expr> ?</condition><then> <expr><operator>(</operator><ternary><condition><expr><name>is_r</name></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><operator>-</operator><literal type="number">2</literal></expr></else></ternary><operator>)</operator></expr> </then><else>: <expr><operator>-</operator><literal type="number">1</literal></expr></else></ternary></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * find_my_exec -- find an absolute path to a valid executable
 *
 *	argv0 is the name passed on the command line
 *	retpath is the output area (must be of size MAXPGPATH)
 *	Returns 0 if OK, -1 if error.
 *
 * The reason we have to work so hard to find an absolute path is that
 * on some platforms we can't do dynamic loading unless we know the
 * executable's location.  Also, we need a full path not a relative
 * path because we will later change working directory.  Finally, we want
 * a true path not a symlink location, so that we can locate other files
 * that are part of our installation relative to the executable.
 */</comment>
<function><type><name>int</name></type>
<name>find_my_exec</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>argv0</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>retpath</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>cwd</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name></decl>,
				<decl><type ref="prev"/><name><name>test_path</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>path</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>getcwd</name><argument_list>(<argument><expr><name>cwd</name></expr></argument>, <argument><expr><name>MAXPGPATH</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>log_error</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"could not identify current directory: %s"</literal></expr></argument>)</argument_list></call></expr></argument>,
				  <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * If argv0 contains a separator, then PATH wasn't used.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>first_dir_separator</name><argument_list>(<argument><expr><name>argv0</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>is_absolute_path</name><argument_list>(<argument><expr><name>argv0</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>StrNCpy</name><argument_list>(<argument><expr><name>retpath</name></expr></argument>, <argument><expr><name>argv0</name></expr></argument>, <argument><expr><name>MAXPGPATH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>join_path_components</name><argument_list>(<argument><expr><name>retpath</name></expr></argument>, <argument><expr><name>cwd</name></expr></argument>, <argument><expr><name>argv0</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
		<expr_stmt><expr><call><name>canonicalize_path</name><argument_list>(<argument><expr><name>retpath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>validate_exec</name><argument_list>(<argument><expr><name>retpath</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><call><name>resolve_symlinks</name><argument_list>(<argument><expr><name>retpath</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>log_error</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"invalid binary \"%s\""</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>retpath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
	</block_content>}</block></if></if_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WIN32</name></cpp:ifdef>
	<comment type="block">/* Win32 checks the current directory first for names without slashes */</comment>
	<expr_stmt><expr><call><name>join_path_components</name><argument_list>(<argument><expr><name>retpath</name></expr></argument>, <argument><expr><name>cwd</name></expr></argument>, <argument><expr><name>argv0</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>validate_exec</name><argument_list>(<argument><expr><name>retpath</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><call><name>resolve_symlinks</name><argument_list>(<argument><expr><name>retpath</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<comment type="block">/*
	 * Since no explicit path was supplied, the user must have been relying on
	 * PATH.  We'll search the same PATH.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>path</name> <operator>=</operator> <call><name>getenv</name><argument_list>(<argument><expr><literal type="string">"PATH"</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>&amp;&amp;</operator> <operator>*</operator><name>path</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>startp</name> <init>= <expr><name>NULL</name></expr></init></decl>,
				   <decl><type ref="prev"><modifier>*</modifier></type><name>endp</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

		<do>do
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>startp</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>startp</name> <operator>=</operator> <name>path</name></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name>startp</name> <operator>=</operator> <name>endp</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>

			<expr_stmt><expr><name>endp</name> <operator>=</operator> <call><name>first_path_var_separator</name><argument_list>(<argument><expr><name>startp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>endp</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>endp</name> <operator>=</operator> <name>startp</name> <operator>+</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>startp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt> <comment type="block">/* point to end */</comment>

			<expr_stmt><expr><call><name>StrNCpy</name><argument_list>(<argument><expr><name>test_path</name></expr></argument>, <argument><expr><name>startp</name></expr></argument>, <argument><expr><call><name>Min</name><argument_list>(<argument><expr><name>endp</name> <operator>-</operator> <name>startp</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>MAXPGPATH</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>is_absolute_path</name><argument_list>(<argument><expr><name>test_path</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>join_path_components</name><argument_list>(<argument><expr><name>retpath</name></expr></argument>, <argument><expr><name>test_path</name></expr></argument>, <argument><expr><name>argv0</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else
			<block>{<block_content>
				<expr_stmt><expr><call><name>join_path_components</name><argument_list>(<argument><expr><name>retpath</name></expr></argument>, <argument><expr><name>cwd</name></expr></argument>, <argument><expr><name>test_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>join_path_components</name><argument_list>(<argument><expr><name>retpath</name></expr></argument>, <argument><expr><name>retpath</name></expr></argument>, <argument><expr><name>argv0</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
			<expr_stmt><expr><call><name>canonicalize_path</name><argument_list>(<argument><expr><name>retpath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<switch>switch <condition>(<expr><call><name>validate_exec</name><argument_list>(<argument><expr><name>retpath</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<case>case <expr><literal type="number">0</literal></expr>:</case>			<comment type="block">/* found ok */</comment>
					<return>return <expr><call><name>resolve_symlinks</name><argument_list>(<argument><expr><name>retpath</name></expr></argument>)</argument_list></call></expr>;</return>
				<case>case <expr><operator>-</operator><literal type="number">1</literal></expr>:</case>		<comment type="block">/* wasn't even a candidate, keep looking */</comment>
					<break>break;</break>
				<case>case <expr><operator>-</operator><literal type="number">2</literal></expr>:</case>		<comment type="block">/* found but disqualified */</comment>
					<expr_stmt><expr><call><name>log_error</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"could not read binary \"%s\""</literal></expr></argument>)</argument_list></call></expr></argument>,
							  <argument><expr><name>retpath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<break>break;</break>
			</block_content>}</block></switch>
		</block_content>}</block> while <condition>(<expr><operator>*</operator><name>endp</name></expr>)</condition>;</do>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>log_error</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"could not find a \"%s\" to execute"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>argv0</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * resolve_symlinks - resolve symlinks to the underlying file
 *
 * Replace "path" by the absolute path to the referenced file.
 *
 * Returns 0 if OK, -1 if error.
 *
 * Note: we are not particularly tense about producing nice error messages
 * because we are not really expecting error here; we just determined that
 * the symlink does point to a valid executable.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>resolve_symlinks</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>path</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_READLINK</name></cpp:ifdef>
	<decl_stmt><decl><type><name><name>struct</name> <name>stat</name></name></type> <name>buf</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>orig_wd</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name></decl>,
				<decl><type ref="prev"/><name><name>link_buf</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>fname</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * To resolve a symlink properly, we have to chdir into its directory and
	 * then chdir to where the symlink points; otherwise we may fail to
	 * resolve relative links correctly (consider cases involving mount
	 * points, for example).  After following the final symlink, we use
	 * getcwd() to figure out where the heck we're at.
	 *
	 * One might think we could skip all this if path doesn't point to a
	 * symlink to start with, but that's wrong.  We also want to get rid of
	 * any directory symlinks that are present in the given path. We expect
	 * getcwd() to give us an accurate, symlink-free path.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>getcwd</name><argument_list>(<argument><expr><name>orig_wd</name></expr></argument>, <argument><expr><name>MAXPGPATH</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>log_error</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"could not identify current directory: %s"</literal></expr></argument>)</argument_list></call></expr></argument>,
				  <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>lsep</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>rllen</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>lsep</name> <operator>=</operator> <call><name>last_dir_separator</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>lsep</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><operator>*</operator><name>lsep</name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><call><name>chdir</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>log_error4</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"could not change directory to \"%s\": %s"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
			</block_content>}</block></if></if_stmt>
			<expr_stmt><expr><name>fname</name> <operator>=</operator> <name>lsep</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>fname</name> <operator>=</operator> <name>path</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>lstat</name><argument_list>(<argument><expr><name>fname</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator>
			<operator>!</operator><call><name>S_ISLNK</name><argument_list>(<argument><expr><name><name>buf</name><operator>.</operator><name>st_mode</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>rllen</name> <operator>=</operator> <call><name>readlink</name><argument_list>(<argument><expr><name>fname</name></expr></argument>, <argument><expr><name>link_buf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>link_buf</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>rllen</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator> <name>rllen</name> <operator>&gt;=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>link_buf</name></expr></argument>)</argument_list></sizeof></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>log_error</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"could not read symbolic link \"%s\""</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>fname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><name><name>link_buf</name><index>[<expr><name>rllen</name></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>link_buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<comment type="block">/* must copy final component out of 'path' temporarily */</comment>
	<expr_stmt><expr><call><name>strlcpy</name><argument_list>(<argument><expr><name>link_buf</name></expr></argument>, <argument><expr><name>fname</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>link_buf</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>getcwd</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>MAXPGPATH</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>log_error</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"could not identify current directory: %s"</literal></expr></argument>)</argument_list></call></expr></argument>,
				  <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>join_path_components</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>link_buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>canonicalize_path</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>chdir</name><argument_list>(<argument><expr><name>orig_wd</name></expr></argument>)</argument_list></call> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>log_error4</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"could not change directory to \"%s\": %s"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>orig_wd</name></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
	</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>							<comment type="block">/* HAVE_READLINK */</comment>

	<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * Find another program in our binary's directory,
 * then make sure it is the proper version.
 */</comment>
<function><type><name>int</name></type>
<name>find_other_exec</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>argv0</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>target</name></decl></parameter>,
				<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>versionstr</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>retpath</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>cmd</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>line</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>find_my_exec</name><argument_list>(<argument><expr><name>argv0</name></expr></argument>, <argument><expr><name>retpath</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* Trim off program name and keep just directory */</comment>
	<expr_stmt><expr><operator>*</operator><call><name>last_dir_separator</name><argument_list>(<argument><expr><name>retpath</name></expr></argument>)</argument_list></call> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>canonicalize_path</name><argument_list>(<argument><expr><name>retpath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Now append the other program's name */</comment>
	<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>retpath</name> <operator>+</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>retpath</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>MAXPGPATH</name> <operator>-</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>retpath</name></expr></argument>)</argument_list></call></expr></argument>,
			 <argument><expr><literal type="string">"/%s%s"</literal></expr></argument>, <argument><expr><name>target</name></expr></argument>, <argument><expr><name>EXE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>validate_exec</name><argument_list>(<argument><expr><name>retpath</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>cmd</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>cmd</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"\"%s\" -V"</literal></expr></argument>, <argument><expr><name>retpath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>pipe_read_line</name><argument_list>(<argument><expr><name>cmd</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>line</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>line</name></expr></argument>, <argument><expr><name>versionstr</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><operator>-</operator><literal type="number">2</literal></expr>;</return></block_content></block></if></if_stmt>

	<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * The runtime library's popen() on win32 does not work when being
 * called from a service when running on windows &lt;= 2000, because
 * there is no stdin/stdout/stderr.
 *
 * Executing a command in a pipe and reading the first line from it
 * is all we need.
 */</comment>
<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type>
<name>pipe_read_line</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>cmd</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>line</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>maxsize</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>WIN32</name></cpp:ifndef>
	<decl_stmt><decl><type><name>FILE</name>	   <modifier>*</modifier></type><name>pgver</name></decl>;</decl_stmt>

	<comment type="block">/* flush output buffers in case popen does not... */</comment>
	<expr_stmt><expr><call><name>fflush</name><argument_list>(<argument><expr><name>stdout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>fflush</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>errno</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>pgver</name> <operator>=</operator> <call><name>popen</name><argument_list>(<argument><expr><name>cmd</name></expr></argument>, <argument><expr><literal type="string">"r"</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>perror</name><argument_list>(<argument><expr><literal type="string">"popen failure"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>errno</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>fgets</name><argument_list>(<argument><expr><name>line</name></expr></argument>, <argument><expr><name>maxsize</name></expr></argument>, <argument><expr><name>pgver</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>feof</name><argument_list>(<argument><expr><name>pgver</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"no data was returned by command \"%s\"\n"</literal></expr></argument>, <argument><expr><name>cmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>perror</name><argument_list>(<argument><expr><literal type="string">"fgets failure"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
		<expr_stmt><expr><call><name>pclose</name><argument_list>(<argument><expr><name>pgver</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>			<comment type="block">/* no error checking */</comment>
		<return>return <expr><name>NULL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>pclose_check</name><argument_list>(<argument><expr><name>pgver</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

	<return>return <expr><name>line</name></expr>;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>							<comment type="block">/* WIN32 */</comment>

	<decl_stmt><decl><type><name>SECURITY_ATTRIBUTES</name></type> <name>sattr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HANDLE</name></type>		<name>childstdoutrd</name></decl>,
				<decl><type ref="prev"/><name>childstdoutwr</name></decl>,
				<decl><type ref="prev"/><name>childstdoutrddup</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PROCESS_INFORMATION</name></type> <name>pi</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>STARTUPINFO</name></type> <name>si</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>retval</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>sattr</name><operator>.</operator><name>nLength</name></name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>SECURITY_ATTRIBUTES</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>sattr</name><operator>.</operator><name>bInheritHandle</name></name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>sattr</name><operator>.</operator><name>lpSecurityDescriptor</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>CreatePipe</name><argument_list>(<argument><expr><operator>&amp;</operator><name>childstdoutrd</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>childstdoutwr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sattr</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>DuplicateHandle</name><argument_list>(<argument><expr><call><name>GetCurrentProcess</name><argument_list>()</argument_list></call></expr></argument>,
						 <argument><expr><name>childstdoutrd</name></expr></argument>,
						 <argument><expr><call><name>GetCurrentProcess</name><argument_list>()</argument_list></call></expr></argument>,
						 <argument><expr><operator>&amp;</operator><name>childstdoutrddup</name></expr></argument>,
						 <argument><expr><literal type="number">0</literal></expr></argument>,
						 <argument><expr><name>FALSE</name></expr></argument>,
						 <argument><expr><name>DUPLICATE_SAME_ACCESS</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>CloseHandle</name><argument_list>(<argument><expr><name>childstdoutrd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>CloseHandle</name><argument_list>(<argument><expr><name>childstdoutwr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>CloseHandle</name><argument_list>(<argument><expr><name>childstdoutrd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ZeroMemory</name><argument_list>(<argument><expr><operator>&amp;</operator><name>pi</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>pi</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ZeroMemory</name><argument_list>(<argument><expr><operator>&amp;</operator><name>si</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>si</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>si</name><operator>.</operator><name>cb</name></name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>si</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>si</name><operator>.</operator><name>dwFlags</name></name> <operator>=</operator> <name>STARTF_USESTDHANDLES</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>si</name><operator>.</operator><name>hStdError</name></name> <operator>=</operator> <name>childstdoutwr</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>si</name><operator>.</operator><name>hStdOutput</name></name> <operator>=</operator> <name>childstdoutwr</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>si</name><operator>.</operator><name>hStdInput</name></name> <operator>=</operator> <name>INVALID_HANDLE_VALUE</name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>CreateProcess</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>,
					  <argument><expr><name>cmd</name></expr></argument>,
					  <argument><expr><name>NULL</name></expr></argument>,
					  <argument><expr><name>NULL</name></expr></argument>,
					  <argument><expr><name>TRUE</name></expr></argument>,
					  <argument><expr><literal type="number">0</literal></expr></argument>,
					  <argument><expr><name>NULL</name></expr></argument>,
					  <argument><expr><name>NULL</name></expr></argument>,
					  <argument><expr><operator>&amp;</operator><name>si</name></expr></argument>,
					  <argument><expr><operator>&amp;</operator><name>pi</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Successfully started the process */</comment>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>lineptr</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>ZeroMemory</name><argument_list>(<argument><expr><name>line</name></expr></argument>, <argument><expr><name>maxsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Try to read at least one line from the pipe */</comment>
		<comment type="block">/* This may require more than one wait/read attempt */</comment>
		<for>for <control>(<init><expr><name>lineptr</name> <operator>=</operator> <name>line</name></expr>;</init> <condition><expr><name>lineptr</name> <operator>&lt;</operator> <name>line</name> <operator>+</operator> <name>maxsize</name> <operator>-</operator> <literal type="number">1</literal></expr>;</condition><incr/>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>DWORD</name></type>		<name>bytesread</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

			<comment type="block">/* Let's see if we can read */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>WaitForSingleObject</name><argument_list>(<argument><expr><name>childstdoutrddup</name></expr></argument>, <argument><expr><literal type="number">10000</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <name>WAIT_OBJECT_0</name></expr>)</condition><block type="pseudo"><block_content>
				<break>break;</break></block_content></block></if></if_stmt>			<comment type="block">/* Timeout, but perhaps we got a line already */</comment>

			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ReadFile</name><argument_list>(<argument><expr><name>childstdoutrddup</name></expr></argument>, <argument><expr><name>lineptr</name></expr></argument>, <argument><expr><name>maxsize</name> <operator>-</operator> <operator>(</operator><name>lineptr</name> <operator>-</operator> <name>line</name><operator>)</operator></expr></argument>,
						  <argument><expr><operator>&amp;</operator><name>bytesread</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<break>break;</break></block_content></block></if></if_stmt>			<comment type="block">/* Error, but perhaps we got a line already */</comment>

			<expr_stmt><expr><name>lineptr</name> <operator>+=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>lineptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>bytesread</name></expr>)</condition><block type="pseudo"><block_content>
				<break>break;</break></block_content></block></if></if_stmt>			<comment type="block">/* EOF */</comment>

			<if_stmt><if>if <condition>(<expr><call><name>strchr</name><argument_list>(<argument><expr><name>line</name></expr></argument>, <argument><expr><literal type="char">'\n'</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<break>break;</break></block_content></block></if></if_stmt>			<comment type="block">/* One or more lines read */</comment>
		</block_content>}</block></for>

		<if_stmt><if>if <condition>(<expr><name>lineptr</name> <operator>!=</operator> <name>line</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* OK, we read some data */</comment>
			<decl_stmt><decl><type><name>int</name></type>			<name>len</name></decl>;</decl_stmt>

			<comment type="block">/* If we got more than one line, cut off after the first \n */</comment>
			<expr_stmt><expr><name>lineptr</name> <operator>=</operator> <call><name>strchr</name><argument_list>(<argument><expr><name>line</name></expr></argument>, <argument><expr><literal type="char">'\n'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>lineptr</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><operator>*</operator><operator>(</operator><name>lineptr</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * If EOL is \r\n, convert to just \n. Because stdout is a
			 * text-mode stream, the \n output by the child process is
			 * received as \r\n, so we convert it to \n.  The server main.c
			 * sets setvbuf(stdout, NULL, _IONBF, 0) which has the effect of
			 * disabling \n to \r\n expansion for stdout.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name>len</name> <operator>&gt;=</operator> <literal type="number">2</literal> <operator>&amp;&amp;</operator> <name><name>line</name><index>[<expr><name>len</name> <operator>-</operator> <literal type="number">2</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'\r'</literal> <operator>&amp;&amp;</operator> <name><name>line</name><index>[<expr><name>len</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'\n'</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name><name>line</name><index>[<expr><name>len</name> <operator>-</operator> <literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'\n'</literal></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>line</name><index>[<expr><name>len</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
				<expr_stmt><expr><name>len</name><operator>--</operator></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/*
			 * We emulate fgets() behaviour. So if there is no newline at the
			 * end, we add one...
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name>len</name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <name><name>line</name><index>[<expr><name>len</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'\n'</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>strcat</name><argument_list>(<argument><expr><name>line</name></expr></argument>, <argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<expr_stmt><expr><name>retval</name> <operator>=</operator> <name>line</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>CloseHandle</name><argument_list>(<argument><expr><name><name>pi</name><operator>.</operator><name>hProcess</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>CloseHandle</name><argument_list>(<argument><expr><name><name>pi</name><operator>.</operator><name>hThread</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>CloseHandle</name><argument_list>(<argument><expr><name>childstdoutwr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>CloseHandle</name><argument_list>(<argument><expr><name>childstdoutrddup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>retval</name></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>							<comment type="block">/* WIN32 */</comment>
</block_content>}</block></function>


<comment type="block">/*
 * pclose() plus useful error reporting
 */</comment>
<function><type><name>int</name></type>
<name>pclose_check</name><parameter_list>(<parameter><decl><type><name>FILE</name> <modifier>*</modifier></type><name>stream</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>exitstatus</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>reason</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>exitstatus</name> <operator>=</operator> <call><name>pclose</name><argument_list>(<argument><expr><name>stream</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>exitstatus</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>				<comment type="block">/* all is well */</comment>

	<if_stmt><if>if <condition>(<expr><name>exitstatus</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* pclose() itself failed, and hopefully set errno */</comment>
		<expr_stmt><expr><call><name>log_error</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"pclose failed: %s"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name>reason</name> <operator>=</operator> <call><name>wait_result_to_str</name><argument_list>(<argument><expr><name>exitstatus</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>log_error</name><argument_list>(<argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name>reason</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>FRONTEND</name></cpp:ifdef>
		<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>reason</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>reason</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	</block_content>}</block></else></if_stmt>
	<return>return <expr><name>exitstatus</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 *	set_pglocale_pgservice
 *
 *	Set application-specific locale and service directory
 *
 *	This function takes the value of argv[0] rather than a full path.
 *
 * (You may be wondering why this is in exec.c.  It requires this module's
 * services and doesn't introduce any new dependencies, so this seems as
 * good as anyplace.)
 */</comment>
<function><type><name>void</name></type>
<name>set_pglocale_pgservice</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>argv0</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>app</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>path</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>my_exec_path</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>env_path</name><index>[<expr><name>MAXPGPATH</name> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><literal type="string">"PGSYSCONFDIR="</literal></expr></argument>)</argument_list></sizeof></expr>]</index></name></decl>;</decl_stmt>	<comment type="block">/* longer than
																 * PGLOCALEDIR */</comment>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>dup_path</name></decl>;</decl_stmt>

	<comment type="block">/* don't set LC_ALL in the backend */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>app</name></expr></argument>, <argument><expr><call><name>PG_TEXTDOMAIN</name><argument_list>(<argument><expr><literal type="string">"postgres"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>setlocale</name><argument_list>(<argument><expr><name>LC_ALL</name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * One could make a case for reproducing here PostmasterMain()'s test
		 * for whether the process is multithreaded.  Unlike the postmaster,
		 * no frontend program calls sigprocmask() or otherwise provides for
		 * mutual exclusion between signal handlers.  While frontends using
		 * fork(), if multithreaded, are formally exposed to undefined
		 * behavior, we have not witnessed a concrete bug.  Therefore,
		 * complaining about multithreading here may be mere pedantry.
		 */</comment>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>find_my_exec</name><argument_list>(<argument><expr><name>argv0</name></expr></argument>, <argument><expr><name>my_exec_path</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>ENABLE_NLS</name></cpp:ifdef>
	<expr_stmt><expr><call><name>get_locale_path</name><argument_list>(<argument><expr><name>my_exec_path</name></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>bindtextdomain</name><argument_list>(<argument><expr><name>app</name></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>textdomain</name><argument_list>(<argument><expr><name>app</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>getenv</name><argument_list>(<argument><expr><literal type="string">"PGLOCALEDIR"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* set for libpq to use */</comment>
		<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>env_path</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>env_path</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"PGLOCALEDIR=%s"</literal></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>canonicalize_path</name><argument_list>(<argument><expr><name>env_path</name> <operator>+</operator> <literal type="number">12</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>dup_path</name> <operator>=</operator> <call><name>strdup</name><argument_list>(<argument><expr><name>env_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>dup_path</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>putenv</name><argument_list>(<argument><expr><name>dup_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<if_stmt><if>if <condition>(<expr><call><name>getenv</name><argument_list>(<argument><expr><literal type="string">"PGSYSCONFDIR"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>get_etc_path</name><argument_list>(<argument><expr><name>my_exec_path</name></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* set for libpq to use */</comment>
		<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>env_path</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>env_path</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"PGSYSCONFDIR=%s"</literal></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>canonicalize_path</name><argument_list>(<argument><expr><name>env_path</name> <operator>+</operator> <literal type="number">13</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>dup_path</name> <operator>=</operator> <call><name>strdup</name><argument_list>(<argument><expr><name>env_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>dup_path</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>putenv</name><argument_list>(<argument><expr><name>dup_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WIN32</name></cpp:ifdef>

<comment type="block">/*
 * AddUserToTokenDacl(HANDLE hToken)
 *
 * This function adds the current user account to the restricted
 * token used when we create a restricted process.
 *
 * This is required because of some security changes in Windows
 * that appeared in patches to XP/2K3 and in Vista/2008.
 *
 * On these machines, the Administrator account is not included in
 * the default DACL - you just get Administrators + System. For
 * regular users you get User + System. Because we strip Administrators
 * when we create the restricted token, we are left with only System
 * in the DACL which leads to access denied errors for later CreatePipe()
 * and CreateProcess() calls when running as Administrator.
 *
 * This function fixes this problem by modifying the DACL of the
 * token the process will use, and explicitly re-adding the current
 * user account.  This is still secure because the Administrator account
 * inherits its privileges from the Administrators group - it doesn't
 * have any of its own.
 */</comment>
<function><type><name>BOOL</name></type>
<name>AddUserToTokenDacl</name><parameter_list>(<parameter><decl><type><name>HANDLE</name></type> <name>hToken</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ACL_SIZE_INFORMATION</name></type> <name>asi</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ACCESS_ALLOWED_ACE</name> <modifier>*</modifier></type><name>pace</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>DWORD</name></type>		<name>dwNewAclSize</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>DWORD</name></type>		<name>dwSize</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>DWORD</name></type>		<name>dwTokenInfoLength</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PACL</name></type>		<name>pacl</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PTOKEN_USER</name></type> <name>pTokenUser</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TOKEN_DEFAULT_DACL</name></type> <name>tddNew</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TOKEN_DEFAULT_DACL</name> <modifier>*</modifier></type><name>ptdd</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TOKEN_INFORMATION_CLASS</name></type> <name>tic</name> <init>= <expr><name>TokenDefaultDacl</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BOOL</name></type>		<name>ret</name> <init>= <expr><name>FALSE</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* Figure out the buffer size for the DACL info */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>GetTokenInformation</name><argument_list>(<argument><expr><name>hToken</name></expr></argument>, <argument><expr><name>tic</name></expr></argument>, <argument><expr><operator>(</operator><name>LPVOID</name><operator>)</operator> <name>NULL</name></expr></argument>, <argument><expr><name>dwTokenInfoLength</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>dwSize</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>GetLastError</name><argument_list>()</argument_list></call> <operator>==</operator> <name>ERROR_INSUFFICIENT_BUFFER</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>ptdd</name> <operator>=</operator> <operator>(</operator><name>TOKEN_DEFAULT_DACL</name> <operator>*</operator><operator>)</operator> <call><name>LocalAlloc</name><argument_list>(<argument><expr><name>LPTR</name></expr></argument>, <argument><expr><name>dwSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>ptdd</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>log_error</name><argument_list>(<argument><expr><literal type="string">"could not allocate %lu bytes of memory"</literal></expr></argument>, <argument><expr><name>dwSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<goto>goto <name>cleanup</name>;</goto>
			</block_content>}</block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>GetTokenInformation</name><argument_list>(<argument><expr><name>hToken</name></expr></argument>, <argument><expr><name>tic</name></expr></argument>, <argument><expr><operator>(</operator><name>LPVOID</name><operator>)</operator> <name>ptdd</name></expr></argument>, <argument><expr><name>dwSize</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>dwSize</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>log_error</name><argument_list>(<argument><expr><literal type="string">"could not get token information: error code %lu"</literal></expr></argument>, <argument><expr><call><name>GetLastError</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<goto>goto <name>cleanup</name>;</goto>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><call><name>log_error</name><argument_list>(<argument><expr><literal type="string">"could not get token information buffer size: error code %lu"</literal></expr></argument>, <argument><expr><call><name>GetLastError</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<goto>goto <name>cleanup</name>;</goto>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Get the ACL info */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>GetAclInformation</name><argument_list>(<argument><expr><name><name>ptdd</name><operator>-&gt;</operator><name>DefaultDacl</name></name></expr></argument>, <argument><expr><operator>(</operator><name>LPVOID</name><operator>)</operator> <operator>&amp;</operator><name>asi</name></expr></argument>,
						   <argument><expr><operator>(</operator><name>DWORD</name><operator>)</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ACL_SIZE_INFORMATION</name></expr></argument>)</argument_list></sizeof></expr></argument>,
						   <argument><expr><name>AclSizeInformation</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>log_error</name><argument_list>(<argument><expr><literal type="string">"could not get ACL information: error code %lu"</literal></expr></argument>, <argument><expr><call><name>GetLastError</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<goto>goto <name>cleanup</name>;</goto>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Get the current user SID */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>GetTokenUser</name><argument_list>(<argument><expr><name>hToken</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pTokenUser</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<goto>goto <name>cleanup</name>;</goto></block_content></block></if></if_stmt>			<comment type="block">/* callee printed a message */</comment>

	<comment type="block">/* Figure out the size of the new ACL */</comment>
	<expr_stmt><expr><name>dwNewAclSize</name> <operator>=</operator> <name><name>asi</name><operator>.</operator><name>AclBytesInUse</name></name> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ACCESS_ALLOWED_ACE</name></expr></argument>)</argument_list></sizeof> <operator>+</operator>
		<call><name>GetLengthSid</name><argument_list>(<argument><expr><name><name>pTokenUser</name><operator>-&gt;</operator><name>User</name><operator>.</operator><name>Sid</name></name></expr></argument>)</argument_list></call> <operator>-</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>DWORD</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>

	<comment type="block">/* Allocate the ACL buffer &amp; initialize it */</comment>
	<expr_stmt><expr><name>pacl</name> <operator>=</operator> <operator>(</operator><name>PACL</name><operator>)</operator> <call><name>LocalAlloc</name><argument_list>(<argument><expr><name>LPTR</name></expr></argument>, <argument><expr><name>dwNewAclSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>pacl</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>log_error</name><argument_list>(<argument><expr><literal type="string">"could not allocate %lu bytes of memory"</literal></expr></argument>, <argument><expr><name>dwNewAclSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<goto>goto <name>cleanup</name>;</goto>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>InitializeAcl</name><argument_list>(<argument><expr><name>pacl</name></expr></argument>, <argument><expr><name>dwNewAclSize</name></expr></argument>, <argument><expr><name>ACL_REVISION</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>log_error</name><argument_list>(<argument><expr><literal type="string">"could not initialize ACL: error code %lu"</literal></expr></argument>, <argument><expr><call><name>GetLastError</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<goto>goto <name>cleanup</name>;</goto>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Loop through the existing ACEs, and build the new ACL */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <operator>(</operator><name>int</name><operator>)</operator> <name><name>asi</name><operator>.</operator><name>AceCount</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>GetAce</name><argument_list>(<argument><expr><name><name>ptdd</name><operator>-&gt;</operator><name>DefaultDacl</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><operator>(</operator><name>LPVOID</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>pace</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>log_error</name><argument_list>(<argument><expr><literal type="string">"could not get ACE: error code %lu"</literal></expr></argument>, <argument><expr><call><name>GetLastError</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<goto>goto <name>cleanup</name>;</goto>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>AddAce</name><argument_list>(<argument><expr><name>pacl</name></expr></argument>, <argument><expr><name>ACL_REVISION</name></expr></argument>, <argument><expr><name>MAXDWORD</name></expr></argument>, <argument><expr><name>pace</name></expr></argument>, <argument><expr><operator>(</operator><operator>(</operator><name>PACE_HEADER</name><operator>)</operator> <name>pace</name><operator>)</operator><operator>-&gt;</operator><name>AceSize</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>log_error</name><argument_list>(<argument><expr><literal type="string">"could not add ACE: error code %lu"</literal></expr></argument>, <argument><expr><call><name>GetLastError</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<goto>goto <name>cleanup</name>;</goto>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>

	<comment type="block">/* Add the new ACE for the current user */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>AddAccessAllowedAceEx</name><argument_list>(<argument><expr><name>pacl</name></expr></argument>, <argument><expr><name>ACL_REVISION</name></expr></argument>, <argument><expr><name>OBJECT_INHERIT_ACE</name></expr></argument>, <argument><expr><name>GENERIC_ALL</name></expr></argument>, <argument><expr><name><name>pTokenUser</name><operator>-&gt;</operator><name>User</name><operator>.</operator><name>Sid</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>log_error</name><argument_list>(<argument><expr><literal type="string">"could not add access allowed ACE: error code %lu"</literal></expr></argument>, <argument><expr><call><name>GetLastError</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<goto>goto <name>cleanup</name>;</goto>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Set the new DACL in the token */</comment>
	<expr_stmt><expr><name><name>tddNew</name><operator>.</operator><name>DefaultDacl</name></name> <operator>=</operator> <name>pacl</name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>SetTokenInformation</name><argument_list>(<argument><expr><name>hToken</name></expr></argument>, <argument><expr><name>tic</name></expr></argument>, <argument><expr><operator>(</operator><name>LPVOID</name><operator>)</operator> <operator>&amp;</operator><name>tddNew</name></expr></argument>, <argument><expr><name>dwNewAclSize</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>log_error</name><argument_list>(<argument><expr><literal type="string">"could not set token information: error code %lu"</literal></expr></argument>, <argument><expr><call><name>GetLastError</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<goto>goto <name>cleanup</name>;</goto>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>ret</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>

<label><name>cleanup</name>:</label>
	<if_stmt><if>if <condition>(<expr><name>pTokenUser</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>LocalFree</name><argument_list>(<argument><expr><operator>(</operator><name>HLOCAL</name><operator>)</operator> <name>pTokenUser</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>pacl</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>LocalFree</name><argument_list>(<argument><expr><operator>(</operator><name>HLOCAL</name><operator>)</operator> <name>pacl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>ptdd</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>LocalFree</name><argument_list>(<argument><expr><operator>(</operator><name>HLOCAL</name><operator>)</operator> <name>ptdd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * GetTokenUser(HANDLE hToken, PTOKEN_USER *ppTokenUser)
 *
 * Get the users token information from a process token.
 *
 * The caller of this function is responsible for calling LocalFree() on the
 * returned TOKEN_USER memory.
 */</comment>
<function><type><specifier>static</specifier> <name>BOOL</name></type>
<name>GetTokenUser</name><parameter_list>(<parameter><decl><type><name>HANDLE</name></type> <name>hToken</name></decl></parameter>, <parameter><decl><type><name>PTOKEN_USER</name> <modifier>*</modifier></type><name>ppTokenUser</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>DWORD</name></type>		<name>dwLength</name></decl>;</decl_stmt>

	<expr_stmt><expr><operator>*</operator><name>ppTokenUser</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>GetTokenInformation</name><argument_list>(<argument><expr><name>hToken</name></expr></argument>,
							 <argument><expr><name>TokenUser</name></expr></argument>,
							 <argument><expr><name>NULL</name></expr></argument>,
							 <argument><expr><literal type="number">0</literal></expr></argument>,
							 <argument><expr><operator>&amp;</operator><name>dwLength</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>GetLastError</name><argument_list>()</argument_list></call> <operator>==</operator> <name>ERROR_INSUFFICIENT_BUFFER</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><operator>*</operator><name>ppTokenUser</name> <operator>=</operator> <operator>(</operator><name>PTOKEN_USER</name><operator>)</operator> <call><name>LocalAlloc</name><argument_list>(<argument><expr><name>LPTR</name></expr></argument>, <argument><expr><name>dwLength</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><operator>*</operator><name>ppTokenUser</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>log_error</name><argument_list>(<argument><expr><literal type="string">"could not allocate %lu bytes of memory"</literal></expr></argument>, <argument><expr><name>dwLength</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr><name>FALSE</name></expr>;</return>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><call><name>log_error</name><argument_list>(<argument><expr><literal type="string">"could not get token information buffer size: error code %lu"</literal></expr></argument>, <argument><expr><call><name>GetLastError</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>FALSE</name></expr>;</return>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>GetTokenInformation</name><argument_list>(<argument><expr><name>hToken</name></expr></argument>,
							 <argument><expr><name>TokenUser</name></expr></argument>,
							 <argument><expr><operator>*</operator><name>ppTokenUser</name></expr></argument>,
							 <argument><expr><name>dwLength</name></expr></argument>,
							 <argument><expr><operator>&amp;</operator><name>dwLength</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>LocalFree</name><argument_list>(<argument><expr><operator>*</operator><name>ppTokenUser</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><operator>*</operator><name>ppTokenUser</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>log_error</name><argument_list>(<argument><expr><literal type="string">"could not get token information: error code %lu"</literal></expr></argument>, <argument><expr><call><name>GetLastError</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>FALSE</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Memory in *ppTokenUser is LocalFree():d by the caller */</comment>
	<return>return <expr><name>TRUE</name></expr>;</return>
</block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</unit>
