<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/PolarDB-for-PostgreSQL/src/common/polar_fs_fe.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * polar_fs_fe.c - 
 *
 * Author: 
 *
 * Copyright (c) 2021, Alibaba Group Holding Limited
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * IDENTIFICATION
 *		  src/common/polar_fs_fe.c
 *-------------------------------------------------------------------------
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"common/polar_fs_fe.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"common/file_utils.h"</cpp:file></cpp:include>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_PFSD</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pfsd_sdk.h"</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LOCAL_IO_INDEX</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PFS_IO_INDEX</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>

<typedef>typedef <function_decl><type><name>int</name></type>	(<modifier>*</modifier><name>vfs_open_type</name>)<parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>path</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>, <parameter><decl><type><name>mode_t</name></type> <name>mode</name></decl></parameter>)</parameter_list>;</function_decl></typedef>
<typedef>typedef <type><struct>struct <name>vfs_mgr</name>
<block>{
	<function_decl><type><name>int</name></type> (<modifier>*</modifier><name>vfs_open</name>)<parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>path</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>, <parameter><decl><type><name>mode_t</name></type> <name>mode</name></decl></parameter>)</parameter_list>;</function_decl>
	<function_decl><type><name>int</name></type> (<modifier>*</modifier><name>vfs_creat</name>)<parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>path</name></decl></parameter>, <parameter><decl><type><name>mode_t</name></type> <name>mode</name></decl></parameter>)</parameter_list>;</function_decl>
	<function_decl><type><name>int</name></type> (<modifier>*</modifier><name>vfs_close</name>)<parameter_list>(<parameter><decl><type><name>int</name></type> <name>fd</name></decl></parameter>)</parameter_list>;</function_decl>
	<function_decl><type><name>ssize_t</name></type> (<modifier>*</modifier><name>vfs_read</name>)<parameter_list>(<parameter><decl><type><name>int</name></type> <name>fd</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>len</name></decl></parameter>)</parameter_list>;</function_decl>
	<function_decl><type><name>ssize_t</name></type> (<modifier>*</modifier><name>vfs_write</name>)<parameter_list>(<parameter><decl><type><name>int</name></type> <name>fd</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>len</name></decl></parameter>)</parameter_list>;</function_decl>
	<function_decl><type><name>ssize_t</name></type> (<modifier>*</modifier><name>vfs_pread</name>)<parameter_list>(<parameter><decl><type><name>int</name></type> <name>fd</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>len</name></decl></parameter>, <parameter><decl><type><name>off_t</name></type> <name>offset</name></decl></parameter>)</parameter_list>;</function_decl>
	<function_decl><type><name>ssize_t</name></type> (<modifier>*</modifier><name>vfs_pwrite</name>)<parameter_list>(<parameter><decl><type><name>int</name></type> <name>fd</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>len</name></decl></parameter>, <parameter><decl><type><name>off_t</name></type> <name>offset</name></decl></parameter>)</parameter_list>;</function_decl>
	<function_decl><type><name>int</name></type> (<modifier>*</modifier><name>vfs_stat</name>)<parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>path</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>stat</name></name> <modifier>*</modifier></type><name>buf</name></decl></parameter>)</parameter_list>;</function_decl>
	<function_decl><type><name>int</name></type> (<modifier>*</modifier><name>vfs_fstat</name>)<parameter_list>(<parameter><decl><type><name>int</name></type> <name>fd</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>stat</name></name> <modifier>*</modifier></type><name>buf</name></decl></parameter>)</parameter_list>;</function_decl>
	<function_decl><type><name>int</name></type> (<modifier>*</modifier><name>vfs_lstat</name>)<parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>path</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>stat</name></name> <modifier>*</modifier></type><name>buf</name></decl></parameter>)</parameter_list>;</function_decl>
	<function_decl><type><name>off_t</name></type> (<modifier>*</modifier><name>vfs_lseek</name>)<parameter_list>(<parameter><decl><type><name>int</name></type> <name>fd</name></decl></parameter>, <parameter><decl><type><name>off_t</name></type> <name>offset</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>whence</name></decl></parameter>)</parameter_list>;</function_decl>
	<function_decl><type><name>off_t</name></type> (<modifier>*</modifier><name>vfs_lseek_cache</name>)<parameter_list>(<parameter><decl><type><name>int</name></type> <name>fd</name></decl></parameter>, <parameter><decl><type><name>off_t</name></type> <name>offset</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>whence</name></decl></parameter>)</parameter_list>;</function_decl>
	<function_decl><type><name>int</name></type> (<modifier>*</modifier><name>vfs_access</name>)<parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>path</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>mode</name></decl></parameter>)</parameter_list>;</function_decl>
	<function_decl><type><name>int</name></type> (<modifier>*</modifier><name>vfs_fsync</name>)<parameter_list>(<parameter><decl><type><name>int</name></type> <name>fd</name></decl></parameter>)</parameter_list>;</function_decl>
	<function_decl><type><name>int</name></type> (<modifier>*</modifier><name>vfs_unlink</name>)<parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>path</name></decl></parameter>)</parameter_list>;</function_decl>
	<function_decl><type><name>int</name></type> (<modifier>*</modifier><name>vfs_rename</name>)<parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>oldpath</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>newpath</name></decl></parameter>)</parameter_list>;</function_decl>
	<function_decl><type><name>int</name></type> (<modifier>*</modifier><name>vfs_fallocate</name>)<parameter_list>(<parameter><decl><type><name>int</name></type> <name>fd</name></decl></parameter>, <parameter><decl><type><name>off_t</name></type> <name>offset</name></decl></parameter>, <parameter><decl><type><name>off_t</name></type> <name>len</name></decl></parameter>)</parameter_list>;</function_decl>
	<function_decl><type><name>int</name></type> (<modifier>*</modifier><name>vfs_ftruncate</name>)<parameter_list>(<parameter><decl><type><name>int</name></type> <name>fd</name></decl></parameter>, <parameter><decl><type><name>off_t</name></type> <name>len</name></decl></parameter>)</parameter_list>;</function_decl>
	<function_decl><type><name>DIR</name> <modifier>*</modifier></type>(<modifier>*</modifier><name>vfs_opendir</name>)<parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>path</name></decl></parameter>)</parameter_list>;</function_decl>
	<function_decl><type><name><name>struct</name> <name>dirent</name></name> <modifier>*</modifier></type>(<modifier>*</modifier><name>vfs_readdir</name>)<parameter_list>(<parameter><decl><type><name>DIR</name> <modifier>*</modifier></type><name>dir</name></decl></parameter>)</parameter_list>;</function_decl>
	<function_decl><type><name>int</name></type> (<modifier>*</modifier><name>vfs_closedir</name>)<parameter_list>(<parameter><decl><type><name>DIR</name> <modifier>*</modifier></type><name>dir</name></decl></parameter>)</parameter_list>;</function_decl>
	<function_decl><type><name>int</name></type> (<modifier>*</modifier><name>vfs_mkdir</name>)<parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>path</name></decl></parameter>, <parameter><decl><type><name>mode_t</name></type> <name>mode</name></decl></parameter>)</parameter_list>;</function_decl>
	<function_decl><type><name>int</name></type> (<modifier>*</modifier><name>vfs_rmdir</name>)<parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>path</name></decl></parameter>)</parameter_list>;</function_decl>
	<function_decl><type><name>int</name></type> (<modifier>*</modifier><name>vfs_chmod</name>) <parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>file</name></decl></parameter>, <parameter><decl><type><name>mode_t</name></type> <name>mode</name></decl></parameter>)</parameter_list>;</function_decl>
}</block></struct></type> <name>vfs_mgr</name>;</typedef>

<typedef>typedef <type><struct>struct <name>vfs_vfd</name>
<block>{
	<decl_stmt><decl><type><name>int</name></type>				<name>fd</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>				<name>kind</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>			<modifier>*</modifier></type><name>file_name</name></decl>;</decl_stmt>
}</block></struct></type> <name>vfs_vfd</name>;</typedef>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>vfs_mgr</name></type> <name><name>vfs</name><index>[]</index></name> <init>= 
<expr><block>{
	<expr><block>{
		<expr><operator>.</operator><name>vfs_open</name> <operator>=</operator><operator>(</operator><name>vfs_open_type</name><operator>)</operator><name>open</name></expr>,
		<expr><operator>.</operator><name>vfs_creat</name> <operator>=</operator> <name>creat</name></expr>,
		<expr><operator>.</operator><name>vfs_close</name> <operator>=</operator> <name>close</name></expr>,
		<expr><operator>.</operator><name>vfs_read</name> <operator>=</operator> <name>read</name></expr>,
		<expr><operator>.</operator><name>vfs_write</name> <operator>=</operator> <name>write</name></expr>,
		<expr><operator>.</operator><name>vfs_pread</name> <operator>=</operator> <name>pread</name></expr>,
		<expr><operator>.</operator><name>vfs_pwrite</name> <operator>=</operator> <name>pwrite</name></expr>,
		<expr><operator>.</operator><name>vfs_stat</name> <operator>=</operator> <name>stat</name></expr>,
		<expr><operator>.</operator><name>vfs_fstat</name> <operator>=</operator> <name>fstat</name></expr>,
		<expr><operator>.</operator><name>vfs_lstat</name> <operator>=</operator> <name>lstat</name></expr>,
		<expr><operator>.</operator><name>vfs_lseek</name> <operator>=</operator> <name>lseek</name></expr>,
		<expr><operator>.</operator><name>vfs_lseek_cache</name> <operator>=</operator> <name>lseek</name></expr>,
		<expr><operator>.</operator><name>vfs_access</name> <operator>=</operator> <name>access</name></expr>,
		<expr><operator>.</operator><name>vfs_fsync</name> <operator>=</operator> <name>fsync</name></expr>,
		<expr><operator>.</operator><name>vfs_unlink</name> <operator>=</operator> <name>unlink</name></expr>,
		<expr><operator>.</operator><name>vfs_rename</name> <operator>=</operator> <name>rename</name></expr>,
		<expr><operator>.</operator><name>vfs_fallocate</name> <operator>=</operator> <name>posix_fallocate</name></expr>,
		<expr><operator>.</operator><name>vfs_ftruncate</name> <operator>=</operator> <name>ftruncate</name></expr>,
		<expr><operator>.</operator><name>vfs_opendir</name> <operator>=</operator> <name>opendir</name></expr>,
		<expr><operator>.</operator><name>vfs_readdir</name> <operator>=</operator> <name>readdir</name></expr>,
		<expr><operator>.</operator><name>vfs_closedir</name> <operator>=</operator> <name>closedir</name></expr>,
		<expr><operator>.</operator><name>vfs_mkdir</name> <operator>=</operator> <name>mkdir</name></expr>,
		<expr><operator>.</operator><name>vfs_rmdir</name> <operator>=</operator> <name>rmdir</name></expr>,
		<expr><operator>.</operator><name>vfs_chmod</name> <operator>=</operator> <name>chmod</name></expr>
	}</block></expr>,
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_PFSD</name></cpp:ifdef>
	<expr><block>{
		<expr><operator>.</operator><name>vfs_open</name> <operator>=</operator> <name>pfsd_open</name></expr>,
		<expr><operator>.</operator><name>vfs_creat</name> <operator>=</operator> <name>pfsd_creat</name></expr>,
		<expr><operator>.</operator><name>vfs_close</name> <operator>=</operator> <name>pfsd_close</name></expr>,
		<expr><operator>.</operator><name>vfs_read</name> <operator>=</operator> <name>pfsd_read</name></expr>,
		<expr><operator>.</operator><name>vfs_write</name> <operator>=</operator> <name>pfsd_write</name></expr>,
		<expr><operator>.</operator><name>vfs_pread</name> <operator>=</operator> <name>pfsd_pread</name></expr>,
		<expr><operator>.</operator><name>vfs_pwrite</name> <operator>=</operator> <name>pfsd_pwrite</name></expr>,
		<expr><operator>.</operator><name>vfs_stat</name> <operator>=</operator> <name>pfsd_stat</name></expr>,
		<expr><operator>.</operator><name>vfs_fstat</name> <operator>=</operator> <name>pfsd_fstat</name></expr>,
		<expr><operator>.</operator><name>vfs_lstat</name> <operator>=</operator> <name>pfsd_stat</name></expr>,
		<expr><operator>.</operator><name>vfs_lseek</name> <operator>=</operator> <name>pfsd_lseek</name></expr>,
		<expr><operator>.</operator><name>vfs_lseek_cache</name> <operator>=</operator> <name>pfsd_lseek</name></expr>,
		<expr><operator>.</operator><name>vfs_access</name> <operator>=</operator> <name>pfsd_access</name></expr>,
		<expr><operator>.</operator><name>vfs_fsync</name> <operator>=</operator> <name>pfsd_fsync</name></expr>,
		<expr><operator>.</operator><name>vfs_unlink</name> <operator>=</operator> <name>pfsd_unlink</name></expr>,
		<expr><operator>.</operator><name>vfs_rename</name> <operator>=</operator> <name>pfsd_rename</name></expr>,
		<expr><operator>.</operator><name>vfs_fallocate</name> <operator>=</operator> <name>pfsd_posix_fallocate</name></expr>,
		<expr><operator>.</operator><name>vfs_ftruncate</name> <operator>=</operator> <name>pfsd_ftruncate</name></expr>,
		<expr><operator>.</operator><name>vfs_opendir</name> <operator>=</operator> <name>pfsd_opendir</name></expr>,
		<expr><operator>.</operator><name>vfs_readdir</name> <operator>=</operator> <name>pfsd_readdir</name></expr>,
		<expr><operator>.</operator><name>vfs_closedir</name> <operator>=</operator> <name>pfsd_closedir</name></expr>,
		<expr><operator>.</operator><name>vfs_mkdir</name> <operator>=</operator> <name>pfsd_mkdir</name></expr>,
		<expr><operator>.</operator><name>vfs_rmdir</name> <operator>=</operator> <name>pfsd_rmdir</name></expr>,
		<expr><operator>.</operator><name>vfs_chmod</name> <operator>=</operator> <name>pfsd_chmod</name></expr>
	}</block></expr>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block></expr></init></decl>;</decl_stmt>

<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>polar_vfs_kind</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>is_pfs</name></decl></parameter>)</parameter_list>;</function_decl>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_PFSD</name></cpp:ifdef>
<function><type><name>void</name></type> <name>polar_fs_init</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>is_pfs</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>polar_storage_cluster_name</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>polar_disk_name</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>polar_hostid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>is_pfs</name></expr>)</condition>
	<block>{<block_content>
		<return>return;</return>
	</block_content>}</block></if></if_stmt> 

	<if_stmt><if>if <condition>(<expr><name>polar_disk_name</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name>polar_hostid</name> <operator>&lt;=</operator> <literal type="number">0</literal> <operator>||</operator>
		<call><name>pg_strcasecmp</name><argument_list>(<argument><expr><name>polar_disk_name</name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>polar_disk_name</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"invalid polar_disk_name or polar_hostid"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>pfsd_mount</name><argument_list>(<argument><expr><name>polar_storage_cluster_name</name></expr></argument>, <argument><expr><name>polar_disk_name</name></expr></argument>,
				  <argument><expr><name>polar_hostid</name></expr></argument>, <argument><expr><name>PFS_RDWR</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"can't mount cluster %s PBD %s, id %d"</literal></expr></argument>)</argument_list></call></expr></argument>, 
		<argument><expr><name>polar_storage_cluster_name</name></expr></argument>, 
		<argument><expr><name>polar_disk_name</name></expr></argument>, <argument><expr><name>polar_hostid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>polar_fs_destory</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>is_pfs</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>polar_disk_name</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>polar_hostid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>is_pfs</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>pfsd_umount_force</name><argument_list>(<argument><expr><name>polar_disk_name</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"can't mount PBD %s, id %d"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>polar_disk_name</name></expr></argument>, <argument><expr><name>polar_hostid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<function><type><name>void</name></type> <name>polar_fs_init</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>is_pfs</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>polar_storage_cluster_name</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>polar_disk_name</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>polar_hostid</name></decl></parameter>)</parameter_list> <block>{<block_content/>}</block></function>
<function><type><name>void</name></type> <name>polar_fs_destory</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>is_pfs</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>polar_disk_name</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>polar_hostid</name></decl></parameter>)</parameter_list> <block>{<block_content/>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><name>int</name></type> <name>polar_chmod</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>path</name></decl></parameter>, <parameter><decl><type><name>mode_t</name></type> <name>mode</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>is_pfs</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>io_kind</name> <init>= <expr><call><name>polar_vfs_kind</name><argument_list>(<argument><expr><name>is_pfs</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<return>return <expr><name><name>vfs</name><index>[<expr><name>io_kind</name></expr>]</index></name><operator>.</operator><call><name>vfs_chmod</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>mode</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type> <name>polar_mkdir</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>path</name></decl></parameter>, <parameter><decl><type><name>mode_t</name></type> <name>mode</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>is_pfs</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>io_kind</name> <init>= <expr><call><name>polar_vfs_kind</name><argument_list>(<argument><expr><name>is_pfs</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<return>return <expr><name><name>vfs</name><index>[<expr><name>io_kind</name></expr>]</index></name><operator>.</operator><call><name>vfs_mkdir</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>mode</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type> <name>polar_open</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>path</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>, <parameter><decl><type><name>mode_t</name></type> <name>mode</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>is_pfs</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>io_kind</name> <init>= <expr><call><name>polar_vfs_kind</name><argument_list>(<argument><expr><name>is_pfs</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<return>return <expr><name><name>vfs</name><index>[<expr><name>io_kind</name></expr>]</index></name><operator>.</operator><call><name>vfs_open</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>, <argument><expr><name>mode</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type> <name>polar_close</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>fd</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>is_pfs</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>io_kind</name> <init>= <expr><call><name>polar_vfs_kind</name><argument_list>(<argument><expr><name>is_pfs</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<return>return <expr><name><name>vfs</name><index>[<expr><name>io_kind</name></expr>]</index></name><operator>.</operator><call><name>vfs_close</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type> <name>polar_write</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>fd</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>len</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>is_pfs</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>io_kind</name> <init>= <expr><call><name>polar_vfs_kind</name><argument_list>(<argument><expr><name>is_pfs</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<return>return <expr><name><name>vfs</name><index>[<expr><name>io_kind</name></expr>]</index></name><operator>.</operator><call><name>vfs_write</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type> <name>polar_read</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>fd</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>len</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>is_pfs</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>io_kind</name> <init>= <expr><call><name>polar_vfs_kind</name><argument_list>(<argument><expr><name>is_pfs</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<return>return <expr><name><name>vfs</name><index>[<expr><name>io_kind</name></expr>]</index></name><operator>.</operator><call><name>vfs_read</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type> <name>polar_fsync</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>fd</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>is_pfs</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>io_kind</name> <init>= <expr><call><name>polar_vfs_kind</name><argument_list>(<argument><expr><name>is_pfs</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<return>return <expr><name><name>vfs</name><index>[<expr><name>io_kind</name></expr>]</index></name><operator>.</operator><call><name>vfs_fsync</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type> <name>polar_closedir</name><parameter_list>(<parameter><decl><type><name>DIR</name> <modifier>*</modifier></type><name>dir</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>is_pfs</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>io_kind</name> <init>= <expr><call><name>polar_vfs_kind</name><argument_list>(<argument><expr><name>is_pfs</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<return>return <expr><name><name>vfs</name><index>[<expr><name>io_kind</name></expr>]</index></name><operator>.</operator><call><name>vfs_closedir</name><argument_list>(<argument><expr><name>dir</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>DIR</name> <modifier>*</modifier></type><name>polar_opendir</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>path</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>is_pfs</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>io_kind</name> <init>= <expr><call><name>polar_vfs_kind</name><argument_list>(<argument><expr><name>is_pfs</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<return>return <expr><name><name>vfs</name><index>[<expr><name>io_kind</name></expr>]</index></name><operator>.</operator><call><name>vfs_opendir</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name><name>struct</name> <name>dirent</name></name> <modifier>*</modifier></type><name>polar_readdir</name><parameter_list>(<parameter><decl><type><name>DIR</name> <modifier>*</modifier></type><name>dir</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>is_pfs</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>io_kind</name> <init>= <expr><call><name>polar_vfs_kind</name><argument_list>(<argument><expr><name>is_pfs</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<return>return <expr><name><name>vfs</name><index>[<expr><name>io_kind</name></expr>]</index></name><operator>.</operator><call><name>vfs_readdir</name><argument_list>(<argument><expr><name>dir</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type> <name>polar_stat</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>path</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>stat</name></name> <modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>is_pfs</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>io_kind</name> <init>= <expr><call><name>polar_vfs_kind</name><argument_list>(<argument><expr><name>is_pfs</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<return>return <expr><name><name>vfs</name><index>[<expr><name>io_kind</name></expr>]</index></name><operator>.</operator><call><name>vfs_stat</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type> <name>polar_lstat</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>path</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>stat</name></name> <modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>is_pfs</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>io_kind</name> <init>= <expr><call><name>polar_vfs_kind</name><argument_list>(<argument><expr><name>is_pfs</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<return>return <expr><name><name>vfs</name><index>[<expr><name>io_kind</name></expr>]</index></name><operator>.</operator><call><name>vfs_lstat</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>off_t</name></type> <name>polar_lseek</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>fd</name></decl></parameter>, <parameter><decl><type><name>off_t</name></type> <name>offset</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>whence</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>is_pfs</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>io_kind</name> <init>= <expr><call><name>polar_vfs_kind</name><argument_list>(<argument><expr><name>is_pfs</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<return>return <expr><name><name>vfs</name><index>[<expr><name>io_kind</name></expr>]</index></name><operator>.</operator><call><name>vfs_lseek</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>, <argument><expr><name>whence</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type> <name>polar_rename</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>oldpath</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>newpath</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>is_pfs</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>io_kind</name> <init>= <expr><call><name>polar_vfs_kind</name><argument_list>(<argument><expr><name>is_pfs</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<return>return <expr><name><name>vfs</name><index>[<expr><name>io_kind</name></expr>]</index></name><operator>.</operator><call><name>vfs_rename</name><argument_list>(<argument><expr><name>oldpath</name></expr></argument>, <argument><expr><name>newpath</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type> <name>polar_unlink</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>path</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>is_pfs</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>io_kind</name> <init>= <expr><call><name>polar_vfs_kind</name><argument_list>(<argument><expr><name>is_pfs</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<return>return <expr><name><name>vfs</name><index>[<expr><name>io_kind</name></expr>]</index></name><operator>.</operator><call><name>vfs_unlink</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type> <name>polar_rmdir</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>path</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>is_pfs</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>io_kind</name> <init>= <expr><call><name>polar_vfs_kind</name><argument_list>(<argument><expr><name>is_pfs</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<return>return <expr><name><name>vfs</name><index>[<expr><name>io_kind</name></expr>]</index></name><operator>.</operator><call><name>vfs_rmdir</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type>
<name>polar_check_dir</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>dir</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>is_pfs</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>result</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>DIR</name>		   <modifier>*</modifier></type><name>chkdir</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>dirent</name></name> <modifier>*</modifier></type><name>file</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>dot_found</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>mount_found</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>readdir_errno</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>chkdir</name> <operator>=</operator> <call><name>polar_opendir</name><argument_list>(<argument><expr><name>dir</name></expr></argument>, <argument><expr><name>is_pfs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>chkdir</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><ternary><condition><expr><operator>(</operator><name>errno</name> <operator>==</operator> <name>ENOENT</name><operator>)</operator></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><operator>-</operator><literal type="number">1</literal></expr></else></ternary></expr>;</return></block_content></block></if></if_stmt>

	<while>while <condition>(<expr><name>errno</name> <operator>=</operator> <literal type="number">0</literal></expr><operator>,</operator> <expr><operator>(</operator><name>file</name> <operator>=</operator> <call><name>polar_readdir</name><argument_list>(<argument><expr><name>chkdir</name></expr></argument>, <argument><expr><name>is_pfs</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><literal type="string">"."</literal></expr></argument>, <argument><expr><name><name>file</name><operator>-&gt;</operator><name>d_name</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
			<call><name>strcmp</name><argument_list>(<argument><expr><literal type="string">".."</literal></expr></argument>, <argument><expr><name><name>file</name><operator>-&gt;</operator><name>d_name</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* skip this and parent directory */</comment>
			<continue>continue;</continue>
		</block_content>}</block></if>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>WIN32</name></cpp:ifndef>
		<comment type="block">/* file starts with "." */</comment>
		<if type="elseif">else if <condition>(<expr><name><name>file</name><operator>-&gt;</operator><name>d_name</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'.'</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>dot_found</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<comment type="block">/* lost+found directory */</comment>
		<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><literal type="string">"lost+found"</literal></expr></argument>, <argument><expr><name><name>file</name><operator>-&gt;</operator><name>d_name</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>mount_found</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <literal type="number">4</literal></expr>;</expr_stmt>			<comment type="block">/* not empty */</comment>
			<break>break;</break>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></while>

	<if_stmt><if>if <condition>(<expr><name>errno</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>			<comment type="block">/* some kind of I/O error? */</comment>

	<comment type="block">/* Close chkdir and avoid overwriting the readdir errno on success */</comment>
	<expr_stmt><expr><name>readdir_errno</name> <operator>=</operator> <name>errno</name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>polar_closedir</name><argument_list>(<argument><expr><name>chkdir</name></expr></argument>, <argument><expr><name>is_pfs</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if>			<comment type="block">/* error executing closedir */</comment>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>errno</name> <operator>=</operator> <name>readdir_errno</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/* We report on mount point if we find a lost+found directory */</comment>
	<if_stmt><if>if <condition>(<expr><name>result</name> <operator>==</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <name>mount_found</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <literal type="number">3</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* We report on dot-files if we _only_ find dot files */</comment>
	<if_stmt><if>if <condition>(<expr><name>result</name> <operator>==</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <name>dot_found</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type>
<name>polar_mkdir_p</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>path</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>omode</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>is_pfs</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name><name>struct</name> <name>stat</name></name></type> <name>sb</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>mode_t</name></type>		<name>numask</name></decl>,
				<decl><type ref="prev"/><name>oumask</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>last</name></decl>,
				<decl><type ref="prev"/><name>retval</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>	<name>is_polar_disk_name</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>retval</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>p</name> <operator>=</operator> <name>path</name></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WIN32</name></cpp:ifdef>
	<comment type="block">/* skip network and drive specifiers for win32 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>strlen</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <literal type="number">2</literal></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'/'</literal> <operator>&amp;&amp;</operator> <name><name>p</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'/'</literal></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* network drive */</comment>
			<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>strstr</name><argument_list>(<argument><expr><name>p</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>, <argument><expr><literal type="string">"/"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>p</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>errno</name> <operator>=</operator> <name>EINVAL</name></expr>;</expr_stmt>
				<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name><name>p</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">':'</literal> <operator>&amp;&amp;</operator>
				 <operator>(</operator><operator>(</operator><name><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&gt;=</operator> <literal type="char">'a'</literal> <operator>&amp;&amp;</operator> <name><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&lt;=</operator> <literal type="char">'z'</literal><operator>)</operator> <operator>||</operator>
				  <operator>(</operator><name><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&gt;=</operator> <literal type="char">'A'</literal> <operator>&amp;&amp;</operator> <name><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&lt;=</operator> <literal type="char">'Z'</literal><operator>)</operator><operator>)</operator></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* local drive */</comment>
			<expr_stmt><expr><name>p</name> <operator>+=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<comment type="block">/*
	 * POSIX 1003.2: For each dir operand that does not name an existing
	 * directory, effects equivalent to those caused by the following command
	 * shall occur:
	 *
	 * mkdir -p -m $(umask -S),u+wx $(dirname dir) &amp;&amp; mkdir [-m mode] dir
	 *
	 * We change the user's umask and then restore it, instead of doing
	 * chmod's.  Note we assume umask() can't change errno.
	 */</comment>
	<expr_stmt><expr><name>oumask</name> <operator>=</operator> <call><name>umask</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>numask</name> <operator>=</operator> <name>oumask</name> <operator>&amp;</operator> <operator>~</operator><operator>(</operator><name>S_IWUSR</name> <operator>|</operator> <name>S_IXUSR</name><operator>)</operator></expr>;</expr_stmt>
	<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>umask</name><argument_list>(<argument><expr><name>numask</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'/'</literal></expr>)</condition><block type="pseudo"><block_content>			<comment type="block">/* Skip leading '/'. */</comment>
		<expr_stmt><expr><operator>++</operator><name>p</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<for>for <control>(<init><expr><name>last</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><operator>!</operator><name>last</name></expr>;</condition> <incr><expr><operator>++</operator><name>p</name></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'\0'</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>last</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><name><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'/'</literal></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>
		
		<if_stmt><if>if <condition>(<expr><name>is_pfs</name> <operator>&amp;&amp;</operator> <name>is_polar_disk_name</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>is_polar_disk_name</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><operator>*</operator><name>p</name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>last</name> <operator>&amp;&amp;</operator> <name><name>p</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'\0'</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>last</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>last</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>umask</name><argument_list>(<argument><expr><name>oumask</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/* check for pre-existing directory */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>polar_stat</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sb</name></expr></argument>, <argument><expr><name>is_pfs</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>S_ISDIR</name><argument_list>(<argument><expr><name><name>sb</name><operator>.</operator><name>st_mode</name></name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name>last</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>errno</name> <operator>=</operator> <name>EEXIST</name></expr>;</expr_stmt></block_content></block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><name>errno</name> <operator>=</operator> <name>ENOTDIR</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
				<expr_stmt><expr><name>retval</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><call><name>polar_mkdir</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><ternary><condition><expr><name>last</name></expr> ?</condition><then> <expr><name>omode</name></expr> </then><else>: <expr><name>S_IRWXU</name> <operator>|</operator> <name>S_IRWXG</name> <operator>|</operator> <name>S_IRWXO</name></expr></else></ternary></expr></argument>, <argument><expr><name>is_pfs</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>retval</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>last</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><operator>*</operator><name>p</name> <operator>=</operator> <literal type="char">'/'</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></for>

	<comment type="block">/* ensure we restored umask */</comment>
	<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>umask</name><argument_list>(<argument><expr><name>oumask</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>retval</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * fsync_fname -- Try to fsync a file or directory
 *
 * Ignores errors trying to open unreadable files, or trying to fsync
 * directories on systems where that isn't allowed/required.  Reports
 * other errors non-fatally.
 */</comment>
<function><type><name>int</name></type>
<name>polar_fsync_fname</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>fname</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>isdir</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>progname</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>is_pfs</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>fd</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>flags</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>returncode</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Some OSs require directories to be opened read-only whereas other
	 * systems don't allow us to fsync files opened read-only; so we need both
	 * cases here.  Using O_RDWR will cause us to fail to fsync files that are
	 * not writable by our userid, but we assume that's OK.
	 */</comment>
	<expr_stmt><expr><name>flags</name> <operator>=</operator> <name>PG_BINARY</name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>isdir</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>flags</name> <operator>|=</operator> <name>O_RDWR</name></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>flags</name> <operator>|=</operator> <name>O_RDONLY</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/*
	 * Open the file, silently ignoring errors about unreadable files (or
	 * unsupported operations, e.g. opening a directory under Windows), and
	 * logging others.
	 */</comment>
	<expr_stmt><expr><name>fd</name> <operator>=</operator> <call><name>polar_open</name><argument_list>(<argument><expr><name>fname</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>is_pfs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>fd</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>errno</name> <operator>==</operator> <name>EACCES</name> <operator>||</operator> <operator>(</operator><name>isdir</name> <operator>&amp;&amp;</operator> <name>errno</name> <operator>==</operator> <name>EISDIR</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: could not open file \"%s\": %s\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
				<argument><expr><name>progname</name></expr></argument>, <argument><expr><name>fname</name></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>returncode</name> <operator>=</operator> <call><name>polar_fsync</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name>is_pfs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Some OSes don't allow us to fsync directories at all, so we can ignore
	 * those errors. Anything else needs to be reported.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>returncode</name> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>!</operator><operator>(</operator><name>isdir</name> <operator>&amp;&amp;</operator> <name>errno</name> <operator>==</operator> <name>EBADF</name><operator>)</operator></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: could not fsync file \"%s\": %s\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
				<argument><expr><name>progname</name></expr></argument>, <argument><expr><name>fname</name></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>polar_close</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name>is_pfs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>polar_close</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name>is_pfs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * fsync_parent_path -- fsync the parent path of a file or directory
 *
 * This is aimed at making file operations persistent on disk in case of
 * an OS crash or power failure.
 */</comment>
<function><type><name>int</name></type>
<name>polar_fsync_parent_path</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>fname</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>progname</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>is_pfs</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>parentpath</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>strlcpy</name><argument_list>(<argument><expr><name>parentpath</name></expr></argument>, <argument><expr><name>fname</name></expr></argument>, <argument><expr><name>MAXPGPATH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>get_parent_directory</name><argument_list>(<argument><expr><name>parentpath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * get_parent_directory() returns an empty string if the input argument is
	 * just a file name (see comments in path.c), so handle that as being the
	 * current directory.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>strlen</name><argument_list>(<argument><expr><name>parentpath</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>strlcpy</name><argument_list>(<argument><expr><name>parentpath</name></expr></argument>, <argument><expr><literal type="string">"."</literal></expr></argument>, <argument><expr><name>MAXPGPATH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>polar_fsync_fname</name><argument_list>(<argument><expr><name>parentpath</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>progname</name></expr></argument>, <argument><expr><name>is_pfs</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

	<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * durable_rename -- rename(2) wrapper, issuing fsyncs required for durability
 *
 * Wrapper around rename, similar to the backend version.
 */</comment>
<function><type><name>int</name></type>
<name>polar_durable_rename</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>oldfile</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>newfile</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>progname</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>is_pfs</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>fd</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * First fsync the old and target path (if it exists), to ensure that they
	 * are properly persistent on disk. Syncing the target file is not
	 * strictly necessary, but it makes it easier to reason about crashes;
	 * because it's then guaranteed that either source or target file exists
	 * after a crash.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>polar_fsync_fname</name><argument_list>(<argument><expr><name>oldfile</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>progname</name></expr></argument>, <argument><expr><name>is_pfs</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>fd</name> <operator>=</operator> <call><name>polar_open</name><argument_list>(<argument><expr><name>newfile</name></expr></argument>, <argument><expr><name>PG_BINARY</name> <operator>|</operator> <name>O_RDWR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>is_pfs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>fd</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>errno</name> <operator>!=</operator> <name>ENOENT</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: could not open file \"%s\": %s\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
					<argument><expr><name>progname</name></expr></argument>, <argument><expr><name>newfile</name></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>polar_fsync</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name>is_pfs</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: could not fsync file \"%s\": %s\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
					<argument><expr><name>progname</name></expr></argument>, <argument><expr><name>newfile</name></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>polar_close</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name>is_pfs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><call><name>polar_close</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name>is_pfs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/* Time to do the real deal... */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>polar_rename</name><argument_list>(<argument><expr><name>oldfile</name></expr></argument>, <argument><expr><name>newfile</name></expr></argument>, <argument><expr><name>is_pfs</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: could not rename file \"%s\" to \"%s\": %s\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
				<argument><expr><name>progname</name></expr></argument>, <argument><expr><name>oldfile</name></expr></argument>, <argument><expr><name>newfile</name></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * To guarantee renaming the file is persistent, fsync the file with its
	 * new name, and its containing directory.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>polar_fsync_fname</name><argument_list>(<argument><expr><name>newfile</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>progname</name></expr></argument>, <argument><expr><name>is_pfs</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>polar_fsync_parent_path</name><argument_list>(<argument><expr><name>newfile</name></expr></argument>, <argument><expr><name>progname</name></expr></argument>, <argument><expr><name>is_pfs</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

	<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 *	polar_rmtree
 *
 *	Delete a directory tree recursively.
 *	Assumes path points to a valid directory.
 *	Deletes everything under path.
 *	If rmtopdir is true deletes the directory too.
 *	Returns true if successful, false if there was any problem.
 *	(The details of the problem are reported already, so caller
 *	doesn't really have to say anything more, but most do.)
 *
 *  POLAR: for BACKEND support local or shared storage
 */</comment>
<function><type><name>bool</name></type>
<name>polar_rmtree</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>path</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>rmtopdir</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>is_pfs</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type>		<name>result</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>pathbuf</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	  <modifier>*</modifier><modifier>*</modifier></type><name>filenames</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	  <modifier>*</modifier><modifier>*</modifier></type><name>filename</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>stat</name></name></type> <name>statbuf</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * we copy all the names out of the directory before we start modifying
	 * it.
	 */</comment>
	<expr_stmt><expr><name>filenames</name> <operator>=</operator> <call><name>polarfnames</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>is_pfs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>filenames</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* now we have the names we can start removing things */</comment>
	<for>for <control>(<init><expr><name>filename</name> <operator>=</operator> <name>filenames</name></expr>;</init> <condition><expr><operator>*</operator><name>filename</name></expr>;</condition> <incr><expr><name>filename</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>pathbuf</name></expr></argument>, <argument><expr><name>MAXPGPATH</name></expr></argument>, <argument><expr><literal type="string">"%s/%s"</literal></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><operator>*</operator><name>filename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * It's ok if the file is not there anymore; we were just about to
		 * delete it anyway.
		 *
		 * This is not an academic possibility. One scenario where this
		 * happens is when bgwriter has a pending unlink request for a file in
		 * a database that's being dropped. In dropdb(), we call
		 * ForgetDatabaseFsyncRequests() to flush out any such pending unlink
		 * requests, but because that's asynchronous, it's not guaranteed that
		 * the bgwriter receives the message in time.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>polar_lstat</name><argument_list>(<argument><expr><name>pathbuf</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>statbuf</name></expr></argument>, <argument><expr><name>is_pfs</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>errno</name> <operator>!=</operator> <name>ENOENT</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"could not stat file or directory \"%s\": %s\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
						<argument><expr><name>pathbuf</name></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>result</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>S_ISDIR</name><argument_list>(<argument><expr><name><name>statbuf</name><operator>.</operator><name>st_mode</name></name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* call ourselves recursively for a directory */</comment>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>polar_rmtree</name><argument_list>(<argument><expr><name>pathbuf</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>is_pfs</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* we already reported the error */</comment>
				<expr_stmt><expr><name>result</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><call><name>polar_unlink</name><argument_list>(<argument><expr><name>pathbuf</name></expr></argument>, <argument><expr><name>is_pfs</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name>errno</name> <operator>!=</operator> <name>ENOENT</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"could not remove file or directory \"%s\": %s\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
							<argument><expr><name>pathbuf</name></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>result</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></for>

	<if_stmt><if>if <condition>(<expr><name>rmtopdir</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>polar_rmdir</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>is_pfs</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"could not remove file or directory \"%s\": %s\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
					<argument><expr><name>path</name></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>polarfnames_cleanup</name><argument_list>(<argument><expr><name>filenames</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * polarfnames
 *
 * return a list of the names of objects in the argument directory.  Caller
 * must call pgfnames_cleanup later to free the memory allocated by this
 * function.
 */</comment>
<function><type><name>char</name>	  <modifier>*</modifier><modifier>*</modifier></type>
<name>polarfnames</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>path</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>is_pfs</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>DIR</name>		   <modifier>*</modifier></type><name>dir</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>dirent</name></name> <modifier>*</modifier></type><name>file</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	  <modifier>*</modifier><modifier>*</modifier></type><name>filenames</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>numnames</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>fnsize</name> <init>= <expr><literal type="number">200</literal></expr></init></decl>;</decl_stmt>	<comment type="block">/* enough for many small dbs */</comment>

	<expr_stmt><expr><name>dir</name> <operator>=</operator> <call><name>polar_opendir</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>is_pfs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>dir</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"could not open directory \"%s\": %s\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
				<argument><expr><name>path</name></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>filenames</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>fnsize</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>char</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<while>while <condition>(<expr><name>errno</name> <operator>=</operator> <literal type="number">0</literal></expr><operator>,</operator> <expr><operator>(</operator><name>file</name> <operator>=</operator> <call><name>polar_readdir</name><argument_list>(<argument><expr><name>dir</name></expr></argument>, <argument><expr><name>is_pfs</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>file</name><operator>-&gt;</operator><name>d_name</name></name></expr></argument>, <argument><expr><literal type="string">"."</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <call><name>strcmp</name><argument_list>(<argument><expr><name><name>file</name><operator>-&gt;</operator><name>d_name</name></name></expr></argument>, <argument><expr><literal type="string">".."</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>numnames</name> <operator>+</operator> <literal type="number">1</literal> <operator>&gt;=</operator> <name>fnsize</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>fnsize</name> <operator>*=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
				<expr_stmt><expr><name>filenames</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>*</operator><operator>)</operator> <call><name>repalloc</name><argument_list>(<argument><expr><name>filenames</name></expr></argument>,
											   <argument><expr><name>fnsize</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>char</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			<expr_stmt><expr><name><name>filenames</name><index>[<expr><name>numnames</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><name><name>file</name><operator>-&gt;</operator><name>d_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></while>

	<if_stmt><if>if <condition>(<expr><name>errno</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"could not read directory \"%s\": %s\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
				<argument><expr><name>path</name></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name><name>filenames</name><index>[<expr><name>numnames</name></expr>]</index></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>polar_closedir</name><argument_list>(<argument><expr><name>dir</name></expr></argument>, <argument><expr><name>is_pfs</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"could not close directory \"%s\": %s\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
				<argument><expr><name>path</name></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>filenames</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 *	pgfnames_cleanup
 *
 *	deallocate memory used for filenames
 */</comment>
<function><type><name>void</name></type>
<name>polarfnames_cleanup</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>filenames</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	  <modifier>*</modifier><modifier>*</modifier></type><name>fn</name></decl>;</decl_stmt>

	<for>for <control>(<init><expr><name>fn</name> <operator>=</operator> <name>filenames</name></expr>;</init> <condition><expr><operator>*</operator><name>fn</name></expr>;</condition> <incr><expr><name>fn</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><operator>*</operator><name>fn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>

	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>filenames</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>polar_vfs_kind</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>is_pfs</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return  <expr><ternary><condition><expr><name>is_pfs</name></expr> ?</condition><then> <expr><name>PFS_IO_INDEX</name></expr></then><else>: <expr><name>LOCAL_IO_INDEX</name></expr></else></ternary></expr>;</return><empty_stmt>;</empty_stmt>
</block_content>}</block></function>
</unit>
