<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/PolarDB-for-PostgreSQL/src/interfaces/ecpg/preproc/ecpg.c"><comment type="block">/* src/interfaces/ecpg/preproc/ecpg.c */</comment>

<comment type="block">/* Main for ecpg, the PostgreSQL embedded SQL precompiler. */</comment>
<comment type="block">/* Copyright (c) 1996-2018, PostgreSQL Global Development Group */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres_fe.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;unistd.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"getopt_long.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"extern.h"</cpp:file></cpp:include>

<decl_stmt><decl><type><name>int</name></type>			<name>ret_value</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type>		<name>autocommit</name> <init>= <expr><name>false</name></expr></init></decl>,
			<decl><type ref="prev"/><name>auto_create_c</name> <init>= <expr><name>false</name></expr></init></decl>,
			<decl><type ref="prev"/><name>system_includes</name> <init>= <expr><name>false</name></expr></init></decl>,
			<decl><type ref="prev"/><name>force_indicator</name> <init>= <expr><name>true</name></expr></init></decl>,
			<decl><type ref="prev"/><name>questionmarks</name> <init>= <expr><name>false</name></expr></init></decl>,
			<decl><type ref="prev"/><name>regression_mode</name> <init>= <expr><name>false</name></expr></init></decl>,
			<decl><type ref="prev"/><name>auto_prepare</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>output_filename</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>enum</name> <name>COMPAT_MODE</name></name></type> <name>compat</name> <init>= <expr><name>ECPG_COMPAT_PGSQL</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>_include_path</name></name> <modifier>*</modifier></type><name>include_paths</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>cursor</name></name> <modifier>*</modifier></type><name>cur</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>typedefs</name></name> <modifier>*</modifier></type><name>types</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>_defines</name></name> <modifier>*</modifier></type><name>defines</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>help</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>progname</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s is the PostgreSQL embedded SQL preprocessor for C programs.\n\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
		   <argument><expr><name>progname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Usage:\n"</literal>
			 <literal type="string">"  %s [OPTION]... FILE...\n\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
		   <argument><expr><name>progname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Options:\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"  -c             automatically generate C code from embedded SQL code;\n"</literal>
			 <literal type="string">"                 this affects EXEC SQL TYPE\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"  -C MODE        set compatibility mode; MODE can be one of\n"</literal>
			 <literal type="string">"                 \"INFORMIX\", \"INFORMIX_SE\", \"ORACLE\"\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>YYDEBUG</name></cpp:ifdef>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"  -d             generate parser debug output\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"  -D SYMBOL      define SYMBOL\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"  -h             parse a header file, this option includes option \"-c\"\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"  -i             parse system include files as well\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"  -I DIRECTORY   search DIRECTORY for include files\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"  -o OUTFILE     write result to OUTFILE\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"  -r OPTION      specify run-time behavior; OPTION can be:\n"</literal>
			 <literal type="string">"                 \"no_indicator\", \"prepare\", \"questionmarks\"\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"  --regression   run in regression testing mode\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"  -t             turn on autocommit of transactions\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"  -V, --version  output version information, then exit\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"  -?, --help     show this help, then exit\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"\nIf no output file is specified, the name is formed by adding .c to the\n"</literal>
			 <literal type="string">"input file name, after stripping off .pgc if present.\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"\nReport bugs to &lt;pgsql-bugs@postgresql.org&gt;.\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>add_include_path</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>path</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name><name>struct</name> <name>_include_path</name></name> <modifier>*</modifier></type><name>ip</name> <init>= <expr><name>include_paths</name></expr></init></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name>new</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>new</name> <operator>=</operator> <call><name>mm_alloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr>struct <name>_include_path</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>new</name><operator>-&gt;</operator><name>path</name></name> <operator>=</operator> <name>path</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>new</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>ip</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>include_paths</name> <operator>=</operator> <name>new</name></expr>;</expr_stmt></block_content></block></if>
	<else>else
	<block>{<block_content>
		<for>for <control>(<init>;</init> <condition><expr><name><name>ip</name><operator>-&gt;</operator><name>next</name></name> <operator>!=</operator> <name>NULL</name></expr>;</condition> <incr><expr><name>ip</name> <operator>=</operator> <name><name>ip</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control><block type="pseudo"><block_content><empty_stmt>;</empty_stmt></block_content></block></for>
		<expr_stmt><expr><name><name>ip</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name>new</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>add_preprocessor_define</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>define</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name><name>struct</name> <name>_defines</name></name> <modifier>*</modifier></type><name>pd</name> <init>= <expr><name>defines</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>ptr</name></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name>define_copy</name> <init>= <expr><call><name>mm_strdup</name><argument_list>(<argument><expr><name>define</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>defines</name> <operator>=</operator> <call><name>mm_alloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr>struct <name>_defines</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* look for = sign */</comment>
	<expr_stmt><expr><name>ptr</name> <operator>=</operator> <call><name>strchr</name><argument_list>(<argument><expr><name>define_copy</name></expr></argument>, <argument><expr><literal type="char">'='</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>ptr</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>tmp</name></decl>;</decl_stmt>

		<comment type="block">/* symbol has a value */</comment>
		<for>for <control>(<init><expr><name>tmp</name> <operator>=</operator> <name>ptr</name> <operator>-</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><operator>*</operator><name>tmp</name> <operator>==</operator> <literal type="char">' '</literal></expr>;</condition> <incr><expr><name>tmp</name><operator>--</operator></expr></incr>)</control><block type="pseudo"><block_content><empty_stmt>;</empty_stmt></block_content></block></for>
		<expr_stmt><expr><name><name>tmp</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>defines</name><operator>-&gt;</operator><name>old</name></name> <operator>=</operator> <name>define_copy</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>defines</name><operator>-&gt;</operator><name>new</name></name> <operator>=</operator> <name>ptr</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name><name>defines</name><operator>-&gt;</operator><name>old</name></name> <operator>=</operator> <name>define_copy</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>defines</name><operator>-&gt;</operator><name>new</name></name> <operator>=</operator> <call><name>mm_strdup</name><argument_list>(<argument><expr><literal type="string">"1"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
	<expr_stmt><expr><name><name>defines</name><operator>-&gt;</operator><name>pertinent</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>defines</name><operator>-&gt;</operator><name>used</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>defines</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name>pd</name></expr>;</expr_stmt>
</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ECPG_GETOPT_LONG_REGRESSION</name></cpp:macro>		<cpp:value>1</cpp:value></cpp:define>
<function><type><name>int</name></type>
<name>main</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><specifier>const</specifier></type> <name><name>argv</name><index>[]</index></name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>static</specifier> <name><name>struct</name> <name>option</name></name></type> <name><name>ecpg_options</name><index>[]</index></name> <init>= <expr><block>{
		<expr><block>{<expr><literal type="string">"regression"</literal></expr>, <expr><name>no_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><name>ECPG_GETOPT_LONG_REGRESSION</name></expr>}</block></expr>,
		<expr><block>{<expr><name>NULL</name></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>NULL</name></expr>, <expr><literal type="number">0</literal></expr>}</block></expr>
	}</block></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>int</name></type>			<name>fnr</name></decl>,
				<decl><type ref="prev"/><name>c</name></decl>,
				<decl><type ref="prev"/><name>out_option</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>verbose</name> <init>= <expr><name>false</name></expr></init></decl>,
				<decl><type ref="prev"/><name>header_mode</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>_include_path</name></name> <modifier>*</modifier></type><name>ip</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>progname</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>my_exec_path</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>include_path</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>set_pglocale_pgservice</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><call><name>PG_TEXTDOMAIN</name><argument_list>(<argument><expr><literal type="string">"ecpg"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>progname</name> <operator>=</operator> <call><name>get_progname</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>find_my_exec</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name>my_exec_path</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: could not locate my own executable path\n"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>ILLEGAL_OPTION</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>argc</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"--help"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <call><name>strcmp</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"-?"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>help</name><argument_list>(<argument><expr><name>progname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"--version"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <call><name>strcmp</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"-V"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"ecpg (PostgreSQL) %s\n"</literal></expr></argument>, <argument><expr><name>PG_VERSION</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>output_filename</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<while>while <condition>(<expr><operator>(</operator><name>c</name> <operator>=</operator> <call><name>getopt_long</name><argument_list>(<argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>, <argument><expr><literal type="string">"vcio:I:tD:dC:r:h"</literal></expr></argument>, <argument><expr><name>ecpg_options</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<switch>switch <condition>(<expr><name>c</name></expr>)</condition>
		<block>{<block_content>
			<case>case <expr><name>ECPG_GETOPT_LONG_REGRESSION</name></expr>:</case>
				<expr_stmt><expr><name>regression_mode</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><literal type="char">'o'</literal></expr>:</case>
				<expr_stmt><expr><name>output_filename</name> <operator>=</operator> <call><name>mm_strdup</name><argument_list>(<argument><expr><name>optarg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>output_filename</name></expr></argument>, <argument><expr><literal type="string">"-"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>base_yyout</name> <operator>=</operator> <name>stdout</name></expr>;</expr_stmt></block_content></block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><name>base_yyout</name> <operator>=</operator> <call><name>fopen</name><argument_list>(<argument><expr><name>output_filename</name></expr></argument>, <argument><expr><name>PG_BINARY_W</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

				<if_stmt><if>if <condition>(<expr><name>base_yyout</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: could not open file \"%s\": %s\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
							<argument><expr><name>progname</name></expr></argument>, <argument><expr><name>output_filename</name></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>output_filename</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
				</block_content>}</block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><name>out_option</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>
				<break>break;</break>
			<case>case <expr><literal type="char">'I'</literal></expr>:</case>
				<expr_stmt><expr><call><name>add_include_path</name><argument_list>(<argument><expr><name>optarg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><literal type="char">'t'</literal></expr>:</case>
				<expr_stmt><expr><name>autocommit</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><literal type="char">'v'</literal></expr>:</case>
				<expr_stmt><expr><name>verbose</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><literal type="char">'h'</literal></expr>:</case>
				<expr_stmt><expr><name>header_mode</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<comment type="block">/* this must include "-c" to make sense, so fall through */</comment>
				<comment type="block">/* FALLTHROUGH */</comment>
			<case>case <expr><literal type="char">'c'</literal></expr>:</case>
				<expr_stmt><expr><name>auto_create_c</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><literal type="char">'i'</literal></expr>:</case>
				<expr_stmt><expr><name>system_includes</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><literal type="char">'C'</literal></expr>:</case>
				<if_stmt><if>if <condition>(<expr><call><name>pg_strcasecmp</name><argument_list>(<argument><expr><name>optarg</name></expr></argument>, <argument><expr><literal type="string">"INFORMIX"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <call><name>pg_strcasecmp</name><argument_list>(<argument><expr><name>optarg</name></expr></argument>, <argument><expr><literal type="string">"INFORMIX_SE"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
				<block>{<block_content>
					<decl_stmt><decl><type><name>char</name></type>		<name><name>pkginclude_path</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>char</name></type>		<name><name>informix_path</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name></decl>;</decl_stmt>

					<expr_stmt><expr><name>compat</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><call><name>pg_strcasecmp</name><argument_list>(<argument><expr><name>optarg</name></expr></argument>, <argument><expr><literal type="string">"INFORMIX"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr> ?</condition><then> <expr><name>ECPG_COMPAT_INFORMIX</name></expr> </then><else>: <expr><name>ECPG_COMPAT_INFORMIX_SE</name></expr></else></ternary></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>get_pkginclude_path</name><argument_list>(<argument><expr><name>my_exec_path</name></expr></argument>, <argument><expr><name>pkginclude_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>informix_path</name></expr></argument>, <argument><expr><name>MAXPGPATH</name></expr></argument>, <argument><expr><literal type="string">"%s/informix/esql"</literal></expr></argument>, <argument><expr><name>pkginclude_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>add_include_path</name><argument_list>(<argument><expr><name>informix_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if>
				<if type="elseif">else if <condition>(<expr><call><name>strncmp</name><argument_list>(<argument><expr><name>optarg</name></expr></argument>, <argument><expr><literal type="string">"ORACLE"</literal></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><literal type="string">"ORACLE"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name>compat</name> <operator>=</operator> <name>ECPG_COMPAT_ORACLE</name></expr>;</expr_stmt>
				</block_content>}</block></if>
				<else>else
				<block>{<block_content>
					<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Try \"%s --help\" for more information.\n"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<return>return <expr><name>ILLEGAL_OPTION</name></expr>;</return>
				</block_content>}</block></else></if_stmt>
				<break>break;</break>
			<case>case <expr><literal type="char">'r'</literal></expr>:</case>
				<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>optarg</name></expr></argument>, <argument><expr><literal type="string">"no_indicator"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>force_indicator</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></if>
				<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>optarg</name></expr></argument>, <argument><expr><literal type="string">"prepare"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>auto_prepare</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if>
				<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>optarg</name></expr></argument>, <argument><expr><literal type="string">"questionmarks"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>questionmarks</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if>
				<else>else
				<block>{<block_content>
					<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Try \"%s --help\" for more information.\n"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<return>return <expr><name>ILLEGAL_OPTION</name></expr>;</return>
				</block_content>}</block></else></if_stmt>
				<break>break;</break>
			<case>case <expr><literal type="char">'D'</literal></expr>:</case>
				<expr_stmt><expr><call><name>add_preprocessor_define</name><argument_list>(<argument><expr><name>optarg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><literal type="char">'d'</literal></expr>:</case>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>YYDEBUG</name></cpp:ifdef>
				<expr_stmt><expr><name>base_yydebug</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
				<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: parser debug support (-d) not available\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
						<argument><expr><name>progname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
				<break>break;</break>
			<default>default:</default>
				<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Try \"%s --help\" for more information.\n"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr><name>ILLEGAL_OPTION</name></expr>;</return>
		</block_content>}</block></switch>
	</block_content>}</block></while>

	<expr_stmt><expr><call><name>add_include_path</name><argument_list>(<argument><expr><literal type="string">"."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>add_include_path</name><argument_list>(<argument><expr><literal type="string">"/usr/local/include"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>get_include_path</name><argument_list>(<argument><expr><name>my_exec_path</name></expr></argument>, <argument><expr><name>include_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>add_include_path</name><argument_list>(<argument><expr><name>include_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>add_include_path</name><argument_list>(<argument><expr><literal type="string">"/usr/include"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>verbose</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>,
				<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s, the PostgreSQL embedded C preprocessor, version %s\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
				<argument><expr><name>progname</name></expr></argument>, <argument><expr><name>PG_VERSION</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"EXEC SQL INCLUDE ... search starts here:\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<for>for <control>(<init><expr><name>ip</name> <operator>=</operator> <name>include_paths</name></expr>;</init> <condition><expr><name>ip</name> <operator>!=</operator> <name>NULL</name></expr>;</condition> <incr><expr><name>ip</name> <operator>=</operator> <name><name>ip</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">" %s\n"</literal></expr></argument>, <argument><expr><name><name>ip</name><operator>-&gt;</operator><name>path</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
		<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"end of search list\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><literal type="number">0</literal></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>optind</name> <operator>&gt;=</operator> <name>argc</name></expr>)</condition>			<comment type="block">/* no files specified */</comment>
	<block>{<block_content>
		<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: no input files specified\n"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>progname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Try \"%s --help\" for more information.\n"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>ILLEGAL_OPTION</name></expr>;</return>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* after the options there must not be anything but filenames */</comment>
		<for>for <control>(<init><expr><name>fnr</name> <operator>=</operator> <name>optind</name></expr>;</init> <condition><expr><name>fnr</name> <operator>&lt;</operator> <name>argc</name></expr>;</condition> <incr><expr><name>fnr</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>ptr2ext</name></decl>;</decl_stmt>

			<comment type="block">/* If argv[fnr] is "-" we have to read from stdin */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><name>fnr</name></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"-"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>input_filename</name> <operator>=</operator> <call><name>mm_alloc</name><argument_list>(<argument><expr><call><name>strlen</name><argument_list>(<argument><expr><literal type="string">"stdin"</literal></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>input_filename</name></expr></argument>, <argument><expr><literal type="string">"stdin"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>base_yyin</name> <operator>=</operator> <name>stdin</name></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<expr_stmt><expr><name>input_filename</name> <operator>=</operator> <call><name>mm_alloc</name><argument_list>(<argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><name>fnr</name></expr>]</index></name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">5</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>input_filename</name></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><name>fnr</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/* take care of relative paths */</comment>
				<expr_stmt><expr><name>ptr2ext</name> <operator>=</operator> <call><name>last_dir_separator</name><argument_list>(<argument><expr><name>input_filename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>ptr2ext</name> <operator>=</operator> <operator>(</operator><ternary><condition><expr><name>ptr2ext</name></expr> ?</condition><then> <expr><call><name>strrchr</name><argument_list>(<argument><expr><name>ptr2ext</name></expr></argument>, <argument><expr><literal type="char">'.'</literal></expr></argument>)</argument_list></call></expr> </then><else>: <expr><call><name>strrchr</name><argument_list>(<argument><expr><name>input_filename</name></expr></argument>, <argument><expr><literal type="char">'.'</literal></expr></argument>)</argument_list></call></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>

				<comment type="block">/* no extension? */</comment>
				<if_stmt><if>if <condition>(<expr><name>ptr2ext</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name>ptr2ext</name> <operator>=</operator> <name>input_filename</name> <operator>+</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>input_filename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<comment type="block">/* no extension =&gt; add .pgc or .pgh */</comment>
					<expr_stmt><expr><name><name>ptr2ext</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'.'</literal></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>ptr2ext</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'p'</literal></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>ptr2ext</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'g'</literal></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>ptr2ext</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name>header_mode</name> <operator>==</operator> <name>true</name><operator>)</operator></expr> ?</condition><then> <expr><literal type="char">'h'</literal></expr> </then><else>: <expr><literal type="char">'c'</literal></expr></else></ternary></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>ptr2ext</name><index>[<expr><literal type="number">4</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>

				<expr_stmt><expr><name>base_yyin</name> <operator>=</operator> <call><name>fopen</name><argument_list>(<argument><expr><name>input_filename</name></expr></argument>, <argument><expr><name>PG_BINARY_R</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>

			<if_stmt><if>if <condition>(<expr><name>out_option</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>	<comment type="block">/* calculate the output name */</comment>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>input_filename</name></expr></argument>, <argument><expr><literal type="string">"stdin"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>base_yyout</name> <operator>=</operator> <name>stdout</name></expr>;</expr_stmt></block_content></block></if>
				<else>else
				<block>{<block_content>
					<expr_stmt><expr><name>output_filename</name> <operator>=</operator> <call><name>mm_alloc</name><argument_list>(<argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>input_filename</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>output_filename</name></expr></argument>, <argument><expr><name>input_filename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<expr_stmt><expr><name>ptr2ext</name> <operator>=</operator> <call><name>strrchr</name><argument_list>(<argument><expr><name>output_filename</name></expr></argument>, <argument><expr><literal type="char">'.'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<comment type="block">/* make extension = .c resp. .h */</comment>
					<expr_stmt><expr><name><name>ptr2ext</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name>header_mode</name> <operator>==</operator> <name>true</name><operator>)</operator></expr> ?</condition><then> <expr><literal type="char">'h'</literal></expr> </then><else>: <expr><literal type="char">'c'</literal></expr></else></ternary></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>ptr2ext</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>

					<expr_stmt><expr><name>base_yyout</name> <operator>=</operator> <call><name>fopen</name><argument_list>(<argument><expr><name>output_filename</name></expr></argument>, <argument><expr><name>PG_BINARY_W</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<if_stmt><if>if <condition>(<expr><name>base_yyout</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: could not open file \"%s\": %s\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
								<argument><expr><name>progname</name></expr></argument>, <argument><expr><name>output_filename</name></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>output_filename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><name>output_filename</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
						<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>input_filename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<continue>continue;</continue>
					</block_content>}</block></if></if_stmt>
				</block_content>}</block></else></if_stmt>
			</block_content>}</block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><name>base_yyin</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: could not open file \"%s\": %s\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
						<argument><expr><name>progname</name></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><name>fnr</name></expr>]</index></name></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else
			<block>{<block_content>
				<decl_stmt><decl><type><name><name>struct</name> <name>cursor</name></name> <modifier>*</modifier></type><name>ptr</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name><name>struct</name> <name>_defines</name></name> <modifier>*</modifier></type><name>defptr</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name><name>struct</name> <name>typedefs</name></name> <modifier>*</modifier></type><name>typeptr</name></decl>;</decl_stmt>

				<comment type="block">/* remove old cursor definitions if any are still there */</comment>
				<for>for <control>(<init><expr><name>ptr</name> <operator>=</operator> <name>cur</name></expr>;</init> <condition><expr><name>ptr</name> <operator>!=</operator> <name>NULL</name></expr>;</condition><incr/>)</control>
				<block>{<block_content>
					<decl_stmt><decl><type><name><name>struct</name> <name>cursor</name></name> <modifier>*</modifier></type><name>this</name> <init>= <expr><name>ptr</name></expr></init></decl>;</decl_stmt>
					<decl_stmt><decl><type><name><name>struct</name> <name>arguments</name></name> <modifier>*</modifier></type><name>l1</name></decl>,
							   <decl><type ref="prev"><modifier>*</modifier></type><name>l2</name></decl>;</decl_stmt>

					<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>ptr</name><operator>-&gt;</operator><name>command</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>ptr</name><operator>-&gt;</operator><name>connection</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>ptr</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<for>for <control>(<init><expr><name>l1</name> <operator>=</operator> <name><name>ptr</name><operator>-&gt;</operator><name>argsinsert</name></name></expr>;</init> <condition><expr><name>l1</name></expr>;</condition> <incr><expr><name>l1</name> <operator>=</operator> <name>l2</name></expr></incr>)</control>
					<block>{<block_content>
						<expr_stmt><expr><name>l2</name> <operator>=</operator> <name><name>l1</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>
						<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>l1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block></for>
					<for>for <control>(<init><expr><name>l1</name> <operator>=</operator> <name><name>ptr</name><operator>-&gt;</operator><name>argsresult</name></name></expr>;</init> <condition><expr><name>l1</name></expr>;</condition> <incr><expr><name>l1</name> <operator>=</operator> <name>l2</name></expr></incr>)</control>
					<block>{<block_content>
						<expr_stmt><expr><name>l2</name> <operator>=</operator> <name><name>l1</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>
						<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>l1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block></for>
					<expr_stmt><expr><name>ptr</name> <operator>=</operator> <name><name>ptr</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></for>
				<expr_stmt><expr><name>cur</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

				<comment type="block">/* remove non-pertinent old defines as well */</comment>
				<while>while <condition>(<expr><name>defines</name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>defines</name><operator>-&gt;</operator><name>pertinent</name></name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name>defptr</name> <operator>=</operator> <name>defines</name></expr>;</expr_stmt>
					<expr_stmt><expr><name>defines</name> <operator>=</operator> <name><name>defines</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>

					<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>defptr</name><operator>-&gt;</operator><name>new</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>defptr</name><operator>-&gt;</operator><name>old</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>defptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></while>

				<for>for <control>(<init><expr><name>defptr</name> <operator>=</operator> <name>defines</name></expr>;</init> <condition><expr><name>defptr</name> <operator>!=</operator> <name>NULL</name></expr>;</condition> <incr><expr><name>defptr</name> <operator>=</operator> <name><name>defptr</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control>
				<block>{<block_content>
					<decl_stmt><decl><type><name><name>struct</name> <name>_defines</name></name> <modifier>*</modifier></type><name>this</name> <init>= <expr><name><name>defptr</name><operator>-&gt;</operator><name>next</name></name></expr></init></decl>;</decl_stmt>

					<if_stmt><if>if <condition>(<expr><name>this</name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>this</name><operator>-&gt;</operator><name>pertinent</name></name></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><name><name>defptr</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name><name>this</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>

						<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>this</name><operator>-&gt;</operator><name>new</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>this</name><operator>-&gt;</operator><name>old</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block></if></if_stmt>
				</block_content>}</block></for>

				<comment type="block">/* and old typedefs */</comment>
				<for>for <control>(<init><expr><name>typeptr</name> <operator>=</operator> <name>types</name></expr>;</init> <condition><expr><name>typeptr</name> <operator>!=</operator> <name>NULL</name></expr>;</condition><incr/>)</control>
				<block>{<block_content>
					<decl_stmt><decl><type><name><name>struct</name> <name>typedefs</name></name> <modifier>*</modifier></type><name>this</name> <init>= <expr><name>typeptr</name></expr></init></decl>;</decl_stmt>

					<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>typeptr</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>ECPGfree_struct_member</name><argument_list>(<argument><expr><name><name>typeptr</name><operator>-&gt;</operator><name>struct_member_list</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>typeptr</name><operator>-&gt;</operator><name>type</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>typeptr</name> <operator>=</operator> <name><name>typeptr</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></for>
				<expr_stmt><expr><name>types</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

				<comment type="block">/* initialize whenever structures */</comment>
				<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>when_error</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>struct <name>when</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>when_nf</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>struct <name>when</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>when_warn</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>struct <name>when</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/* and structure member lists */</comment>
				<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>struct_member_list</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>struct_member_list</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/*
				 * and our variable counter for out of scope cursors'
				 * variables
				 */</comment>
				<expr_stmt><expr><name>ecpg_internal_var</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

				<comment type="block">/* finally the actual connection */</comment>
				<expr_stmt><expr><name>connection</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

				<comment type="block">/* initialize lex */</comment>
				<expr_stmt><expr><call><name>lex_init</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/* we need several includes */</comment>
				<comment type="block">/* but not if we are in header mode */</comment>
				<if_stmt><if>if <condition>(<expr><name>regression_mode</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>base_yyout</name></expr></argument>, <argument><expr><literal type="string">"/* Processed by ecpg (regression mode) */\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>base_yyout</name></expr></argument>, <argument><expr><literal type="string">"/* Processed by ecpg (%s) */\n"</literal></expr></argument>, <argument><expr><name>PG_VERSION</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

				<if_stmt><if>if <condition>(<expr><name>header_mode</name> <operator>==</operator> <name>false</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>base_yyout</name></expr></argument>, <argument><expr><literal type="string">"/* These include files are added by the preprocessor */\n#include &lt;ecpglib.h&gt;\n#include &lt;ecpgerrno.h&gt;\n#include &lt;sqlca.h&gt;\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<comment type="block">/* add some compatibility headers */</comment>
					<if_stmt><if>if <condition>(<expr><name>INFORMIX_MODE</name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>base_yyout</name></expr></argument>, <argument><expr><literal type="string">"/* Needed for informix compatibility */\n#include &lt;ecpg_informix.h&gt;\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

					<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>base_yyout</name></expr></argument>, <argument><expr><literal type="string">"/* End of automatic include section */\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>

				<if_stmt><if>if <condition>(<expr><name>regression_mode</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>base_yyout</name></expr></argument>, <argument><expr><literal type="string">"#define ECPGdebug(X,Y) ECPGdebug((X)+100,(Y))\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

				<expr_stmt><expr><call><name>output_line_number</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/* and parse the source */</comment>
				<expr_stmt><expr><call><name>base_yyparse</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/*
				 * Check whether all cursors were indeed opened.  It does not
				 * really make sense to declare a cursor but not open it.
				 */</comment>
				<for>for <control>(<init><expr><name>ptr</name> <operator>=</operator> <name>cur</name></expr>;</init> <condition><expr><name>ptr</name> <operator>!=</operator> <name>NULL</name></expr>;</condition> <incr><expr><name>ptr</name> <operator>=</operator> <name><name>ptr</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control><block type="pseudo"><block_content>
					<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name><name>ptr</name><operator>-&gt;</operator><name>opened</name></name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>mmerror</name><argument_list>(<argument><expr><name>PARSE_ERROR</name></expr></argument>, <argument><expr><name>ET_WARNING</name></expr></argument>, <argument><expr><literal type="string">"cursor \"%s\" has been declared but not opened"</literal></expr></argument>, <argument><expr><name><name>ptr</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt></block_content></block></for>

				<if_stmt><if>if <condition>(<expr><name>base_yyin</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name>base_yyin</name> <operator>!=</operator> <name>stdin</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>fclose</name><argument_list>(<argument><expr><name>base_yyin</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<if_stmt><if>if <condition>(<expr><name>out_option</name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>base_yyout</name> <operator>!=</operator> <name>stdout</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>fclose</name><argument_list>(<argument><expr><name>base_yyout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

				<comment type="block">/*
				 * If there was an error, delete the output file.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><name>ret_value</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
				<block>{<block_content>
					<if_stmt><if>if <condition>(<expr><name>output_filename</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <call><name>strcmp</name><argument_list>(<argument><expr><name>output_filename</name></expr></argument>, <argument><expr><literal type="string">"-"</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <call><name>unlink</name><argument_list>(<argument><expr><name>output_filename</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"could not remove output file \"%s\"\n"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>output_filename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></else></if_stmt>

			<if_stmt><if>if <condition>(<expr><name>output_filename</name> <operator>&amp;&amp;</operator> <name>out_option</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>output_filename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>output_filename</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>input_filename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></for>
	</block_content>}</block></else></if_stmt>
	<return>return <expr><name>ret_value</name></expr>;</return>
</block_content>}</block></function>
</unit>
