<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/PolarDB-for-PostgreSQL/src/interfaces/ecpg/ecpglib/prepare.c"><comment type="block">/* src/interfaces/ecpg/ecpglib/prepare.c */</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>POSTGRES_ECPG_INTERNAL</name></cpp:macro></cpp:define>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres_fe.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;ctype.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"ecpgtype.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"ecpglib.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"ecpgerrno.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"extern.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"sqlca.h"</cpp:file></cpp:include>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>STMTID_SIZE</name></cpp:macro> <cpp:value>32</cpp:value></cpp:define>

<typedef>typedef <type><struct>struct
<block>{
	<decl_stmt><decl><type><name>int</name></type>			<name>lineno</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>stmtID</name><index>[<expr><name>STMTID_SIZE</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>ecpgQuery</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>long</name></type>		<name>execs</name></decl>;</decl_stmt>			<comment type="block">/* # of executions		*/</comment>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>connection</name></decl>;</decl_stmt>		<comment type="block">/* connection for the statement		*/</comment>
}</block></struct></type> <name>stmtCacheEntry</name>;</typedef>

<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type>	<name>nextStmtID</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>int</name></type> <name>stmtCacheNBuckets</name> <init>= <expr><literal type="number">2039</literal></expr></init></decl>;</decl_stmt>	<comment type="block">/* # buckets - a prime # */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>int</name></type> <name>stmtCacheEntPerBucket</name> <init>= <expr><literal type="number">8</literal></expr></init></decl>;</decl_stmt> <comment type="block">/* # entries/bucket		*/</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>stmtCacheEntry</name></type> <name><name>stmtCacheEntries</name><index>[<expr><literal type="number">16384</literal></expr>]</index></name> <init>= <expr><block>{<expr><block>{<expr><literal type="number">0</literal></expr>, <expr><block>{<expr><literal type="number">0</literal></expr>}</block></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>}</block></expr>}</block></expr></init></decl>;</decl_stmt>

<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>deallocate_one</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>lineno</name></decl></parameter>, <parameter><decl><type><name><name>enum</name> <name>COMPAT_MODE</name></name></type> <name>c</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>connection</name></name> <modifier>*</modifier></type><name>con</name></decl></parameter>,
			   <parameter><decl><type><name><name>struct</name> <name>prepared_statement</name></name> <modifier>*</modifier></type><name>prev</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>prepared_statement</name></name> <modifier>*</modifier></type><name>this</name></decl></parameter>)</parameter_list>;</function_decl>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>isvarchar</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>char</name></type> <name>c</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><call><name>isalnum</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>c</name> <operator>==</operator> <literal type="char">'_'</literal> <operator>||</operator> <name>c</name> <operator>==</operator> <literal type="char">'&gt;'</literal> <operator>||</operator> <name>c</name> <operator>==</operator> <literal type="char">'-'</literal> <operator>||</operator> <name>c</name> <operator>==</operator> <literal type="char">'.'</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>c</name> <operator>&gt;=</operator> <literal type="number">128</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>replace_variables</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>text</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>lineno</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type>		<name>string</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>counter</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>,
				<decl><type ref="prev"/><name>ptr</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<for>for <control>(<init>;</init> <condition><expr><operator>(</operator><operator>*</operator><name>text</name><operator>)</operator><index>[<expr><name>ptr</name></expr>]</index> <operator>!=</operator> <literal type="char">'\0'</literal></expr>;</condition> <incr><expr><name>ptr</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>(</operator><operator>*</operator><name>text</name><operator>)</operator><index>[<expr><name>ptr</name></expr>]</index> <operator>==</operator> <literal type="char">'\''</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>string</name> <operator>=</operator> <ternary><condition><expr><name>string</name></expr> ?</condition><then> <expr><name>false</name></expr> </then><else>: <expr><name>true</name></expr></else></ternary></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>string</name> <operator>||</operator> <operator>(</operator><operator>(</operator><operator>(</operator><operator>*</operator><name>text</name><operator>)</operator><index>[<expr><name>ptr</name></expr>]</index> <operator>!=</operator> <literal type="char">':'</literal><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><operator>(</operator><operator>*</operator><name>text</name><operator>)</operator><index>[<expr><name>ptr</name></expr>]</index> <operator>!=</operator> <literal type="char">'?'</literal><operator>)</operator><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><operator>(</operator><operator>(</operator><operator>*</operator><name>text</name><operator>)</operator><index>[<expr><name>ptr</name></expr>]</index> <operator>==</operator> <literal type="char">':'</literal><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><operator>(</operator><operator>*</operator><name>text</name><operator>)</operator><index>[<expr><name>ptr</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index> <operator>==</operator> <literal type="char">':'</literal><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>ptr</name> <operator>+=</operator> <literal type="number">2</literal></expr>;</expr_stmt></block_content></block></if>			<comment type="block">/* skip  '::' */</comment>
		<else>else
		<block>{<block_content>
			<decl_stmt><decl><type><name>int</name></type>			<name>len</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int</name></type>			<name>buffersize</name> <init>= <expr><sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>CHAR_BIT</name> <operator>*</operator> <literal type="number">10</literal> <operator>/</operator> <literal type="number">3</literal></expr></init></decl>;</decl_stmt>	<comment type="block">/* a rough guess of the
																		 * size we need */</comment>
			<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>buffer</name></decl>,
					   <decl><type ref="prev"><modifier>*</modifier></type><name>newcopy</name></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>buffer</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>ecpg_alloc</name><argument_list>(<argument><expr><name>buffersize</name></expr></argument>, <argument><expr><name>lineno</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

			<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>buffersize</name></expr></argument>, <argument><expr><literal type="string">"$%d"</literal></expr></argument>, <argument><expr><name>counter</name><operator>++</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<for>for <control>(<init><expr><name>len</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><operator>(</operator><operator>*</operator><name>text</name><operator>)</operator><index>[<expr><name>ptr</name> <operator>+</operator> <name>len</name></expr>]</index> <operator>&amp;&amp;</operator> <call><name>isvarchar</name><argument_list>(<argument><expr><operator>(</operator><operator>*</operator><name>text</name><operator>)</operator><index>[<expr><name>ptr</name> <operator>+</operator> <name>len</name></expr>]</index></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>len</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content><empty_stmt>;</empty_stmt></block_content></block></for>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>newcopy</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>ecpg_alloc</name><argument_list>(<argument><expr><call><name>strlen</name><argument_list>(<argument><expr><operator>*</operator><name>text</name></expr></argument>)</argument_list></call> <operator>-</operator><name>len</name> <operator>+</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>lineno</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>ecpg_free</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr><name>false</name></expr>;</return>
			</block_content>}</block></if></if_stmt>

			<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>newcopy</name></expr></argument>, <argument><expr><operator>*</operator><name>text</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>newcopy</name> <operator>+</operator> <name>ptr</name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>strcat</name><argument_list>(<argument><expr><name>newcopy</name></expr></argument>, <argument><expr><operator>(</operator><operator>*</operator><name>text</name><operator>)</operator> <operator>+</operator><name>ptr</name> <operator>+</operator> <name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>ecpg_free</name><argument_list>(<argument><expr><operator>*</operator><name>text</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>ecpg_free</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><operator>*</operator><name>text</name> <operator>=</operator> <name>newcopy</name></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><operator>(</operator><operator>*</operator><name>text</name><operator>)</operator><index>[<expr><name>ptr</name></expr>]</index> <operator>==</operator> <literal type="char">'\0'</literal></expr>)</condition><block type="pseudo"><block_content>	<comment type="block">/* we reached the end */</comment>
				<expr_stmt><expr><name>ptr</name><operator>--</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>			<comment type="block">/* since we will (*text)[ptr]++ in the top
								 * level for loop */</comment>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></for>
	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>prepare_common</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>lineno</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>connection</name></name> <modifier>*</modifier></type><name>con</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>variable</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name><name>struct</name> <name>statement</name></name> <modifier>*</modifier></type><name>stmt</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>prepared_statement</name></name> <modifier>*</modifier></type><name>this</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier></type><name>query</name></decl>;</decl_stmt>

	<comment type="block">/* allocate new statement */</comment>
	<expr_stmt><expr><name>this</name> <operator>=</operator> <operator>(</operator>struct <name>prepared_statement</name> <operator>*</operator><operator>)</operator> <call><name>ecpg_alloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr>struct <name>prepared_statement</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>lineno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>this</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>stmt</name> <operator>=</operator> <operator>(</operator>struct <name>statement</name> <operator>*</operator><operator>)</operator> <call><name>ecpg_alloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr>struct <name>statement</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>lineno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>stmt</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ecpg_free</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* create statement */</comment>
	<expr_stmt><expr><name><name>stmt</name><operator>-&gt;</operator><name>lineno</name></name> <operator>=</operator> <name>lineno</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>stmt</name><operator>-&gt;</operator><name>connection</name></name> <operator>=</operator> <name>con</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>stmt</name><operator>-&gt;</operator><name>command</name></name> <operator>=</operator> <call><name>ecpg_strdup</name><argument_list>(<argument><expr><name>variable</name></expr></argument>, <argument><expr><name>lineno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>stmt</name><operator>-&gt;</operator><name>inlist</name></name> <operator>=</operator> <name><name>stmt</name><operator>-&gt;</operator><name>outlist</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<comment type="block">/* if we have C variables in our statement replace them with '?' */</comment>
	<expr_stmt><expr><call><name>replace_variables</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>stmt</name><operator>-&gt;</operator><name>command</name></name><operator>)</operator></expr></argument>, <argument><expr><name>lineno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* add prepared statement to our list */</comment>
	<expr_stmt><expr><name><name>this</name><operator>-&gt;</operator><name>name</name></name> <operator>=</operator> <call><name>ecpg_strdup</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>lineno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>this</name><operator>-&gt;</operator><name>stmt</name></name> <operator>=</operator> <name>stmt</name></expr>;</expr_stmt>

	<comment type="block">/* and finally really prepare the statement */</comment>
	<expr_stmt><expr><name>query</name> <operator>=</operator> <call><name>PQprepare</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>connection</name><operator>-&gt;</operator><name>connection</name></name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>command</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ecpg_check_PQresult</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>lineno</name></name></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>connection</name><operator>-&gt;</operator><name>connection</name></name></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>compat</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ecpg_free</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>command</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ecpg_free</name><argument_list>(<argument><expr><name><name>this</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ecpg_free</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ecpg_free</name><argument_list>(<argument><expr><name>stmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>ecpg_log</name><argument_list>(<argument><expr><literal type="string">"prepare_common on line %d: name %s; query: \"%s\"\n"</literal></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>lineno</name></name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>command</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>this</name><operator>-&gt;</operator><name>prepared</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>con</name><operator>-&gt;</operator><name>prep_stmts</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>this</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>this</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name><name>con</name><operator>-&gt;</operator><name>prep_stmts</name></name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<expr_stmt><expr><name><name>con</name><operator>-&gt;</operator><name>prep_stmts</name></name> <operator>=</operator> <name>this</name></expr>;</expr_stmt>
	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* handle the EXEC SQL PREPARE statement */</comment>
<comment type="block">/* questionmarks is not needed but remains in there for the time being to not change the API */</comment>
<function><type><name>bool</name></type>
<name>ECPGprepare</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>lineno</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>connection_name</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>bool</name></type> <name>questionmarks</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>variable</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name><name>struct</name> <name>connection</name></name> <modifier>*</modifier></type><name>con</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>prepared_statement</name></name> <modifier>*</modifier></type><name>this</name></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name>prev</name></decl>;</decl_stmt>

	<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <name>questionmarks</name></expr>;</expr_stmt>		<comment type="block">/* quiet the compiler */</comment>
	<expr_stmt><expr><name>con</name> <operator>=</operator> <call><name>ecpg_get_connection</name><argument_list>(<argument><expr><name>connection_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ecpg_init</name><argument_list>(<argument><expr><name>con</name></expr></argument>, <argument><expr><name>connection_name</name></expr></argument>, <argument><expr><name>lineno</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* check if we already have prepared this statement */</comment>
	<expr_stmt><expr><name>this</name> <operator>=</operator> <call><name>ecpg_find_prepared_statement</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>con</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>prev</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>this</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>deallocate_one</name><argument_list>(<argument><expr><name>lineno</name></expr></argument>, <argument><expr><name>ECPG_COMPAT_PGSQL</name></expr></argument>, <argument><expr><name>con</name></expr></argument>, <argument><expr><name>prev</name></expr></argument>, <argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<return>return <expr><call><name>prepare_common</name><argument_list>(<argument><expr><name>lineno</name></expr></argument>, <argument><expr><name>con</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>variable</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name><name>struct</name> <name>prepared_statement</name></name> <modifier>*</modifier></type>
<name>ecpg_find_prepared_statement</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>,
							 <parameter><decl><type><name><name>struct</name> <name>connection</name></name> <modifier>*</modifier></type><name>con</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>prepared_statement</name></name> <modifier>*</modifier><modifier>*</modifier></type><name>prev_</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name><name>struct</name> <name>prepared_statement</name></name> <modifier>*</modifier></type><name>this</name></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name>prev</name></decl>;</decl_stmt>

	<for>for <control>(<init><expr><name>this</name> <operator>=</operator> <name><name>con</name><operator>-&gt;</operator><name>prep_stmts</name></name></expr><operator>,</operator> <expr><name>prev</name> <operator>=</operator> <name>NULL</name></expr>;</init> <condition><expr><name>this</name> <operator>!=</operator> <name>NULL</name></expr>;</condition> <incr><expr><name>prev</name> <operator>=</operator> <name>this</name></expr><operator>,</operator> <expr><name>this</name> <operator>=</operator> <name><name>this</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>this</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>prev_</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><operator>*</operator><name>prev_</name> <operator>=</operator> <name>prev</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<return>return <expr><name>this</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>
	<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>deallocate_one</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>lineno</name></decl></parameter>, <parameter><decl><type><name><name>enum</name> <name>COMPAT_MODE</name></name></type> <name>c</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>connection</name></name> <modifier>*</modifier></type><name>con</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>prepared_statement</name></name> <modifier>*</modifier></type><name>prev</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>prepared_statement</name></name> <modifier>*</modifier></type><name>this</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type>		<name>r</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>ecpg_log</name><argument_list>(<argument><expr><literal type="string">"deallocate_one on line %d: name %s\n"</literal></expr></argument>, <argument><expr><name>lineno</name></expr></argument>, <argument><expr><name><name>this</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* first deallocate the statement in the backend */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>this</name><operator>-&gt;</operator><name>prepared</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>text</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier></type><name>query</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>text</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>ecpg_alloc</name><argument_list>(<argument><expr><call><name>strlen</name><argument_list>(<argument><expr><literal type="string">"deallocate \"\" "</literal></expr></argument>)</argument_list></call> <operator>+</operator> <call><name>strlen</name><argument_list>(<argument><expr><name><name>this</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>this</name><operator>-&gt;</operator><name>stmt</name><operator>-&gt;</operator><name>lineno</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>text</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>text</name></expr></argument>, <argument><expr><literal type="string">"deallocate \"%s\""</literal></expr></argument>, <argument><expr><name><name>this</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>query</name> <operator>=</operator> <call><name>PQexec</name><argument_list>(<argument><expr><name><name>this</name><operator>-&gt;</operator><name>stmt</name><operator>-&gt;</operator><name>connection</name><operator>-&gt;</operator><name>connection</name></name></expr></argument>, <argument><expr><name>text</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>ecpg_free</name><argument_list>(<argument><expr><name>text</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><call><name>ecpg_check_PQresult</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><name>lineno</name></expr></argument>, <argument><expr><name><name>this</name><operator>-&gt;</operator><name>stmt</name><operator>-&gt;</operator><name>connection</name><operator>-&gt;</operator><name>connection</name></name></expr></argument>, <argument><expr><name><name>this</name><operator>-&gt;</operator><name>stmt</name><operator>-&gt;</operator><name>compat</name></name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>r</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Just ignore all errors since we do not know the list of cursors we are
	 * allowed to free. We have to trust the software.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>r</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>INFORMIX_MODE</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ecpg_raise</name><argument_list>(<argument><expr><name>lineno</name></expr></argument>, <argument><expr><name>ECPG_INVALID_STMT</name></expr></argument>, <argument><expr><name>ECPG_SQLSTATE_INVALID_SQL_STATEMENT_NAME</name></expr></argument>, <argument><expr><name><name>this</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* okay, free all the resources */</comment>
	<expr_stmt><expr><call><name>ecpg_free</name><argument_list>(<argument><expr><name><name>this</name><operator>-&gt;</operator><name>stmt</name><operator>-&gt;</operator><name>command</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ecpg_free</name><argument_list>(<argument><expr><name><name>this</name><operator>-&gt;</operator><name>stmt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ecpg_free</name><argument_list>(<argument><expr><name><name>this</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>prev</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>prev</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name><name>this</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>con</name><operator>-&gt;</operator><name>prep_stmts</name></name> <operator>=</operator> <name><name>this</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<expr_stmt><expr><call><name>ecpg_free</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* handle the EXEC SQL DEALLOCATE PREPARE statement */</comment>
<function><type><name>bool</name></type>
<name>ECPGdeallocate</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>lineno</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>c</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>connection_name</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name><name>struct</name> <name>connection</name></name> <modifier>*</modifier></type><name>con</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>prepared_statement</name></name> <modifier>*</modifier></type><name>this</name></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name>prev</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>con</name> <operator>=</operator> <call><name>ecpg_get_connection</name><argument_list>(<argument><expr><name>connection_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ecpg_init</name><argument_list>(<argument><expr><name>con</name></expr></argument>, <argument><expr><name>connection_name</name></expr></argument>, <argument><expr><name>lineno</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>this</name> <operator>=</operator> <call><name>ecpg_find_prepared_statement</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>con</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>prev</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>this</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><call><name>deallocate_one</name><argument_list>(<argument><expr><name>lineno</name></expr></argument>, <argument><expr><name>c</name></expr></argument>, <argument><expr><name>con</name></expr></argument>, <argument><expr><name>prev</name></expr></argument>, <argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* prepared statement is not found */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>INFORMIX_MODE</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
	<expr_stmt><expr><call><name>ecpg_raise</name><argument_list>(<argument><expr><name>lineno</name></expr></argument>, <argument><expr><name>ECPG_INVALID_STMT</name></expr></argument>, <argument><expr><name>ECPG_SQLSTATE_INVALID_SQL_STATEMENT_NAME</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>bool</name></type>
<name>ecpg_deallocate_all_conn</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>lineno</name></decl></parameter>, <parameter><decl><type><name><name>enum</name> <name>COMPAT_MODE</name></name></type> <name>c</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>connection</name></name> <modifier>*</modifier></type><name>con</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* deallocate all prepared statements */</comment>
	<while>while <condition>(<expr><name><name>con</name><operator>-&gt;</operator><name>prep_stmts</name></name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>deallocate_one</name><argument_list>(<argument><expr><name>lineno</name></expr></argument>, <argument><expr><name>c</name></expr></argument>, <argument><expr><name>con</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name><name>con</name><operator>-&gt;</operator><name>prep_stmts</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></while>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>bool</name></type>
<name>ECPGdeallocate_all</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>lineno</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>compat</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>connection_name</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>ecpg_deallocate_all_conn</name><argument_list>(<argument><expr><name>lineno</name></expr></argument>, <argument><expr><name>compat</name></expr></argument>, <argument><expr><call><name>ecpg_get_connection</name><argument_list>(<argument><expr><name>connection_name</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>char</name> <modifier>*</modifier></type>
<name>ecpg_prepared</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>connection</name></name> <modifier>*</modifier></type><name>con</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name><name>struct</name> <name>prepared_statement</name></name> <modifier>*</modifier></type><name>this</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>this</name> <operator>=</operator> <call><name>ecpg_find_prepared_statement</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>con</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><ternary><condition><expr><name>this</name></expr> ?</condition><then> <expr><name><name>this</name><operator>-&gt;</operator><name>stmt</name><operator>-&gt;</operator><name>command</name></name></expr> </then><else>: <expr><name>NULL</name></expr></else></ternary></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* return the prepared statement */</comment>
<comment type="block">/* lineno is not used here, but kept in to not break API */</comment>
<function><type><name>char</name> <modifier>*</modifier></type>
<name>ECPGprepared_statement</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>connection_name</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>lineno</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <name>lineno</name></expr>;</expr_stmt>				<comment type="block">/* keep the compiler quiet */</comment>
	<return>return <expr><call><name>ecpg_prepared</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><call><name>ecpg_get_connection</name><argument_list>(<argument><expr><name>connection_name</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * hash a SQL statement -  returns entry # of first entry in the bucket
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>HashStmt</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>ecpgQuery</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>stmtIx</name></decl>,
				<decl><type ref="prev"/><name>bucketNo</name></decl>,
				<decl><type ref="prev"/><name>hashLeng</name></decl>,
				<decl><type ref="prev"/><name>stmtLeng</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>long</name> <name>long</name></type>	<name>hashVal</name></decl>,
				<decl><type ref="prev"/><name>rotVal</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>stmtLeng</name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>ecpgQuery</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>hashLeng</name> <operator>=</operator> <literal type="number">50</literal></expr>;</expr_stmt>				<comment type="block">/* use 1st 50 characters of statement		*/</comment>
	<if_stmt><if>if <condition>(<expr><name>hashLeng</name> <operator>&gt;</operator> <name>stmtLeng</name></expr>)</condition><block type="pseudo"><block_content>	<comment type="block">/* if the statement isn't that long         */</comment>
		<expr_stmt><expr><name>hashLeng</name> <operator>=</operator> <name>stmtLeng</name></expr>;</expr_stmt></block_content></block></if></if_stmt>	<comment type="block">/* use its actual length			   */</comment>

	<expr_stmt><expr><name>hashVal</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>stmtIx</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>stmtIx</name> <operator>&lt;</operator> <name>hashLeng</name></expr>;</condition> <incr><expr><operator>++</operator><name>stmtIx</name></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><name>hashVal</name> <operator>=</operator> <name>hashVal</name> <operator>+</operator> <operator>(</operator><name>int</name><operator>)</operator> <name><name>ecpgQuery</name><index>[<expr><name>stmtIx</name></expr>]</index></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>hashVal</name> <operator>=</operator> <name>hashVal</name> <operator>&lt;&lt;</operator> <literal type="number">13</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name>rotVal</name> <operator>=</operator> <operator>(</operator><name>hashVal</name> <operator>&amp;</operator> <literal type="number">0x1fff00000000LL</literal><operator>)</operator> <operator>&gt;&gt;</operator> <literal type="number">32</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name>hashVal</name> <operator>=</operator> <operator>(</operator><name>hashVal</name> <operator>&amp;</operator> <literal type="number">0xffffffffLL</literal><operator>)</operator> <operator>|</operator> <name>rotVal</name></expr>;</expr_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><name>bucketNo</name> <operator>=</operator> <name>hashVal</name> <operator>%</operator> <name>stmtCacheNBuckets</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>bucketNo</name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>				<comment type="block">/* don't use bucket # 0         */</comment>

	<return>return <expr><operator>(</operator><name>bucketNo</name> <operator>*</operator> <name>stmtCacheEntPerBucket</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * search the statement cache - search for entry with matching ECPG-format query
 * Returns entry # in cache if found
 *	 OR  zero if not present (zero'th entry isn't used)
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>SearchStmtCache</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>ecpgQuery</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>entNo</name></decl>,
				<decl><type ref="prev"/><name>entIx</name></decl>;</decl_stmt>

<comment type="block">/* hash the statement			*/</comment>
	<expr_stmt><expr><name>entNo</name> <operator>=</operator> <call><name>HashStmt</name><argument_list>(<argument><expr><name>ecpgQuery</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/* search the cache		*/</comment>
	<for>for <control>(<init><expr><name>entIx</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>entIx</name> <operator>&lt;</operator> <name>stmtCacheEntPerBucket</name></expr>;</condition> <incr><expr><operator>++</operator><name>entIx</name></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>stmtCacheEntries</name><index>[<expr><name>entNo</name></expr>]</index></name><operator>.</operator><name><name>stmtID</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>)</condition>	<comment type="block">/* check if entry is in use		*/</comment>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>ecpgQuery</name></expr></argument>, <argument><expr><name><name>stmtCacheEntries</name><index>[<expr><name>entNo</name></expr>]</index></name><operator>.</operator><name>ecpgQuery</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<break>break;</break></block_content></block></if></if_stmt>			<comment type="block">/* found it		*/</comment>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><operator>++</operator><name>entNo</name></expr>;</expr_stmt>				<comment type="block">/* incr entry #		*/</comment>
	</block_content>}</block></for>

<comment type="block">/* if entry wasn't found - set entry # to zero  */</comment>
	<if_stmt><if>if <condition>(<expr><name>entIx</name> <operator>&gt;=</operator> <name>stmtCacheEntPerBucket</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>entNo</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>entNo</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * free an entry in the statement cache
 * Returns entry # in cache used
 *	 OR  negative error code
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>ecpg_freeStmtCacheEntry</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>lineno</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>compat</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>entNo</name></decl></parameter>)</parameter_list>	<comment type="block">/* entry # to free */</comment>
<block>{<block_content>
	<decl_stmt><decl><type><name>stmtCacheEntry</name> <modifier>*</modifier></type><name>entry</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>connection</name></name> <modifier>*</modifier></type><name>con</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>prepared_statement</name></name> <modifier>*</modifier></type><name>this</name></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name>prev</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>entry</name> <operator>=</operator> <operator>&amp;</operator><name><name>stmtCacheEntries</name><index>[<expr><name>entNo</name></expr>]</index></name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>entry</name><operator>-&gt;</operator><name>stmtID</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>		<comment type="block">/* return if the entry isn't in use     */</comment>
		<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>con</name> <operator>=</operator> <call><name>ecpg_get_connection</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>connection</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* free the 'prepared_statement' list entry		  */</comment>
	<expr_stmt><expr><name>this</name> <operator>=</operator> <call><name>ecpg_find_prepared_statement</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>stmtID</name></name></expr></argument>, <argument><expr><name>con</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>prev</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>this</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>deallocate_one</name><argument_list>(<argument><expr><name>lineno</name></expr></argument>, <argument><expr><name>compat</name></expr></argument>, <argument><expr><name>con</name></expr></argument>, <argument><expr><name>prev</name></expr></argument>, <argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>stmtID</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>

	<comment type="block">/* free the memory used by the cache entry		*/</comment>
	<if_stmt><if>if <condition>(<expr><name><name>entry</name><operator>-&gt;</operator><name>ecpgQuery</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ecpg_free</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>ecpgQuery</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>ecpgQuery</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>entNo</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * add an entry to the statement cache
 * returns entry # in cache used  OR  negative error code
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>AddStmtToCache</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>lineno</name></decl></parameter>,		<comment type="block">/* line # of statement		*/</comment>
			   <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>stmtID</name></decl></parameter>,	<comment type="block">/* statement ID				*/</comment>
			   <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>connection</name></decl></parameter>,	<comment type="block">/* connection				*/</comment>
			   <parameter><decl><type><name>int</name></type> <name>compat</name></decl></parameter>,		<comment type="block">/* compatibility level */</comment>
			   <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>ecpgQuery</name></decl></parameter>)</parameter_list>	<comment type="block">/* query					*/</comment>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>ix</name></decl>,
				<decl><type ref="prev"/><name>initEntNo</name></decl>,
				<decl><type ref="prev"/><name>luEntNo</name></decl>,
				<decl><type ref="prev"/><name>entNo</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>stmtCacheEntry</name> <modifier>*</modifier></type><name>entry</name></decl>;</decl_stmt>

<comment type="block">/* hash the statement																	*/</comment>
	<expr_stmt><expr><name>initEntNo</name> <operator>=</operator> <call><name>HashStmt</name><argument_list>(<argument><expr><name>ecpgQuery</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/* search for an unused entry															*/</comment>
	<expr_stmt><expr><name>entNo</name> <operator>=</operator> <name>initEntNo</name></expr>;</expr_stmt>			<comment type="block">/* start with the initial entry # for the
								 * bucket	 */</comment>
	<expr_stmt><expr><name>luEntNo</name> <operator>=</operator> <name>initEntNo</name></expr>;</expr_stmt>		<comment type="block">/* use it as the initial 'least used' entry			*/</comment>
	<for>for <control>(<init><expr><name>ix</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>ix</name> <operator>&lt;</operator> <name>stmtCacheEntPerBucket</name></expr>;</condition> <incr><expr><operator>++</operator><name>ix</name></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><name>entry</name> <operator>=</operator> <operator>&amp;</operator><name><name>stmtCacheEntries</name><index>[<expr><name>entNo</name></expr>]</index></name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>entry</name><operator>-&gt;</operator><name>stmtID</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>	<comment type="block">/* unused entry  -	use it			*/</comment>
			<break>break;</break></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>entry</name><operator>-&gt;</operator><name>execs</name></name> <operator>&lt;</operator> <name><name>stmtCacheEntries</name><index>[<expr><name>luEntNo</name></expr>]</index></name><operator>.</operator><name>execs</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>luEntNo</name> <operator>=</operator> <name>entNo</name></expr>;</expr_stmt></block_content></block></if></if_stmt>	<comment type="block">/* save new 'least used' entry		*/</comment>
		<expr_stmt><expr><operator>++</operator><name>entNo</name></expr>;</expr_stmt>				<comment type="block">/* increment entry #				*/</comment>
	</block_content>}</block></for>

<comment type="block">/* if no unused entries were found - use the 'least used' entry found in the bucket		*/</comment>
	<if_stmt><if>if <condition>(<expr><name>ix</name> <operator>&gt;=</operator> <name>stmtCacheEntPerBucket</name></expr>)</condition><block type="pseudo"><block_content>	<comment type="block">/* if no unused entries were found	*/</comment>
		<expr_stmt><expr><name>entNo</name> <operator>=</operator> <name>luEntNo</name></expr>;</expr_stmt></block_content></block></if></if_stmt>		<comment type="block">/* re-use the 'least used' entry	*/</comment>

<comment type="block">/* 'entNo' is the entry to use - make sure its free										*/</comment>
	<if_stmt><if>if <condition>(<expr><call><name>ecpg_freeStmtCacheEntry</name><argument_list>(<argument><expr><name>lineno</name></expr></argument>, <argument><expr><name>compat</name></expr></argument>, <argument><expr><name>entNo</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

<comment type="block">/* add the query to the entry															*/</comment>
	<expr_stmt><expr><name>entry</name> <operator>=</operator> <operator>&amp;</operator><name><name>stmtCacheEntries</name><index>[<expr><name>entNo</name></expr>]</index></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>lineno</name></name> <operator>=</operator> <name>lineno</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>ecpgQuery</name></name> <operator>=</operator> <call><name>ecpg_strdup</name><argument_list>(<argument><expr><name>ecpgQuery</name></expr></argument>, <argument><expr><name>lineno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>connection</name></name> <operator>=</operator> <name>connection</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>execs</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>stmtID</name></name></expr></argument>, <argument><expr><name>stmtID</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>stmtID</name></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>entNo</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* handle cache and preparation of statements in auto-prepare mode */</comment>
<function><type><name>bool</name></type>
<name>ecpg_auto_prepare</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>lineno</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>connection_name</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>int</name></type> <name>compat</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>name</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>query</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>entNo</name></decl>;</decl_stmt>

	<comment type="block">/* search the statement cache for this statement	*/</comment>
	<expr_stmt><expr><name>entNo</name> <operator>=</operator> <call><name>SearchStmtCache</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* if not found - add the statement to the cache	*/</comment>
	<if_stmt><if>if <condition>(<expr><name>entNo</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>stmtID</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name><name>struct</name> <name>connection</name></name> <modifier>*</modifier></type><name>con</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name><name>struct</name> <name>prepared_statement</name></name> <modifier>*</modifier></type><name>prep</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>ecpg_log</name><argument_list>(<argument><expr><literal type="string">"ecpg_auto_prepare on line %d: statement found in cache; entry %d\n"</literal></expr></argument>, <argument><expr><name>lineno</name></expr></argument>, <argument><expr><name>entNo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>stmtID</name> <operator>=</operator> <name><name>stmtCacheEntries</name><index>[<expr><name>entNo</name></expr>]</index></name><operator>.</operator><name>stmtID</name></expr>;</expr_stmt>

		<expr_stmt><expr><name>con</name> <operator>=</operator> <call><name>ecpg_get_connection</name><argument_list>(<argument><expr><name>connection_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>prep</name> <operator>=</operator> <call><name>ecpg_find_prepared_statement</name><argument_list>(<argument><expr><name>stmtID</name></expr></argument>, <argument><expr><name>con</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* This prepared name doesn't exist on this connection. */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>prep</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>prepare_common</name><argument_list>(<argument><expr><name>lineno</name></expr></argument>, <argument><expr><name>con</name></expr></argument>, <argument><expr><name>stmtID</name></expr></argument>, <argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

		<expr_stmt><expr><operator>*</operator><name>name</name> <operator>=</operator> <call><name>ecpg_strdup</name><argument_list>(<argument><expr><name>stmtID</name></expr></argument>, <argument><expr><name>lineno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name></type>		<name><name>stmtID</name><index>[<expr><name>STMTID_SIZE</name></expr>]</index></name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>ecpg_log</name><argument_list>(<argument><expr><literal type="string">"ecpg_auto_prepare on line %d: statement not in cache; inserting\n"</literal></expr></argument>, <argument><expr><name>lineno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* generate a statement ID */</comment>
		<expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>stmtID</name></expr></argument>, <argument><expr><literal type="string">"ecpg%d"</literal></expr></argument>, <argument><expr><name>nextStmtID</name><operator>++</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ECPGprepare</name><argument_list>(<argument><expr><name>lineno</name></expr></argument>, <argument><expr><name>connection_name</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>stmtID</name></expr></argument>, <argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>AddStmtToCache</name><argument_list>(<argument><expr><name>lineno</name></expr></argument>, <argument><expr><name>stmtID</name></expr></argument>, <argument><expr><name>connection_name</name></expr></argument>, <argument><expr><name>compat</name></expr></argument>, <argument><expr><name>query</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

		<expr_stmt><expr><operator>*</operator><name>name</name> <operator>=</operator> <call><name>ecpg_strdup</name><argument_list>(<argument><expr><name>stmtID</name></expr></argument>, <argument><expr><name>lineno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/* increase usage counter */</comment>
	<expr_stmt><expr><name><name>stmtCacheEntries</name><index>[<expr><name>entNo</name></expr>]</index></name><operator>.</operator><name>execs</name><operator>++</operator></expr>;</expr_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>
</unit>
