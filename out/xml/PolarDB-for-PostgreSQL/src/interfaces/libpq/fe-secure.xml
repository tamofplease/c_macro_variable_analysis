<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/PolarDB-for-PostgreSQL/src/interfaces/libpq/fe-secure.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * fe-secure.c
 *	  functions related to setting up a secure connection to the backend.
 *	  Secure connections are expected to provide confidentiality,
 *	  message integrity and endpoint authentication.
 *
 *
 * Portions Copyright (c) 1996-2018, PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, Regents of the University of California
 *
 *
 * IDENTIFICATION
 *	  src/interfaces/libpq/fe-secure.c
 *
 * NOTES
 *
 *	  We don't provide informational callbacks here (like
 *	  info_cb() in be-secure.c), since there's no good mechanism to
 *	  display such information to the user.
 *
 *-------------------------------------------------------------------------
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres_fe.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;signal.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;fcntl.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;ctype.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"libpq-fe.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"fe-auth.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"libpq-int.h"</cpp:file></cpp:include>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WIN32</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"win32.h"</cpp:file></cpp:include>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/socket.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;unistd.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;netdb.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;netinet/in.h&gt;</cpp:file></cpp:include>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_NETINET_TCP_H</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;netinet/tcp.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;arpa/inet.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/stat.h&gt;</cpp:file></cpp:include>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>ENABLE_THREAD_SAFETY</name></cpp:ifdef>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WIN32</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pthread-win32.h"</cpp:file></cpp:include>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;pthread.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
 * Macros to handle disabling and then restoring the state of SIGPIPE handling.
 * On Windows, these are all no-ops since there's no SIGPIPEs.
 */</comment>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>WIN32</name></cpp:ifndef>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SIGPIPE_MASKED</name><parameter_list>(<parameter><type><name>conn</name></type></parameter>)</parameter_list></cpp:macro>	<cpp:value>((conn)-&gt;sigpipe_so || (conn)-&gt;sigpipe_flag)</cpp:value></cpp:define>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>ENABLE_THREAD_SAFETY</name></cpp:ifdef>

<struct>struct <name>sigpipe_info</name>
<block>{
	<decl_stmt><decl><type><name>sigset_t</name></type>	<name>oldsigmask</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>sigpipe_pending</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>got_epipe</name></decl>;</decl_stmt>
}</block>;</struct>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DECLARE_SIGPIPE_INFO</name><parameter_list>(<parameter><type><name>spinfo</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>struct sigpipe_info spinfo</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DISABLE_SIGPIPE</name><parameter_list>(<parameter><type><name>conn</name></type></parameter>, <parameter><type><name>spinfo</name></type></parameter>, <parameter><type><name>failaction</name></type></parameter>)</parameter_list></cpp:macro> \
	<cpp:value>do { \
		(spinfo).got_epipe = false; \
		if (!SIGPIPE_MASKED(conn)) \
		{ \
			if (pq_block_sigpipe(&amp;(spinfo).oldsigmask, \
								 &amp;(spinfo).sigpipe_pending) &lt; 0) \
				failaction; \
		} \
	} while (0)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>REMEMBER_EPIPE</name><parameter_list>(<parameter><type><name>spinfo</name></type></parameter>, <parameter><type><name>cond</name></type></parameter>)</parameter_list></cpp:macro> \
	<cpp:value>do { \
		if (cond) \
			(spinfo).got_epipe = true; \
	} while (0)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RESTORE_SIGPIPE</name><parameter_list>(<parameter><type><name>conn</name></type></parameter>, <parameter><type><name>spinfo</name></type></parameter>)</parameter_list></cpp:macro> \
	<cpp:value>do { \
		if (!SIGPIPE_MASKED(conn)) \
			pq_reset_sigpipe(&amp;(spinfo).oldsigmask, (spinfo).sigpipe_pending, \
							 (spinfo).got_epipe); \
	} while (0)</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>							<comment type="block">/* !ENABLE_THREAD_SAFETY */</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DECLARE_SIGPIPE_INFO</name><parameter_list>(<parameter><type><name>spinfo</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>pqsigfunc spinfo = NULL</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DISABLE_SIGPIPE</name><parameter_list>(<parameter><type><name>conn</name></type></parameter>, <parameter><type><name>spinfo</name></type></parameter>, <parameter><type><name>failaction</name></type></parameter>)</parameter_list></cpp:macro> \
	<cpp:value>do { \
		if (!SIGPIPE_MASKED(conn)) \
			spinfo = pqsignal(SIGPIPE, SIG_IGN); \
	} while (0)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>REMEMBER_EPIPE</name><parameter_list>(<parameter><type><name>spinfo</name></type></parameter>, <parameter><type><name>cond</name></type></parameter>)</parameter_list></cpp:macro></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RESTORE_SIGPIPE</name><parameter_list>(<parameter><type><name>conn</name></type></parameter>, <parameter><type><name>spinfo</name></type></parameter>)</parameter_list></cpp:macro> \
	<cpp:value>do { \
		if (!SIGPIPE_MASKED(conn)) \
			pqsignal(SIGPIPE, spinfo); \
	} while (0)</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>							<comment type="block">/* ENABLE_THREAD_SAFETY */</comment>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>							<comment type="block">/* WIN32 */</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DECLARE_SIGPIPE_INFO</name><parameter_list>(<parameter><type><name>spinfo</name></type></parameter>)</parameter_list></cpp:macro></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DISABLE_SIGPIPE</name><parameter_list>(<parameter><type><name>conn</name></type></parameter>, <parameter><type><name>spinfo</name></type></parameter>, <parameter><type><name>failaction</name></type></parameter>)</parameter_list></cpp:macro></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>REMEMBER_EPIPE</name><parameter_list>(<parameter><type><name>spinfo</name></type></parameter>, <parameter><type><name>cond</name></type></parameter>)</parameter_list></cpp:macro></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RESTORE_SIGPIPE</name><parameter_list>(<parameter><type><name>conn</name></type></parameter>, <parameter><type><name>spinfo</name></type></parameter>)</parameter_list></cpp:macro></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>							<comment type="block">/* WIN32 */</comment>

<comment type="block">/* ------------------------------------------------------------ */</comment>
<comment type="block">/*			 Procedures common to all secure sessions			*/</comment>
<comment type="block">/* ------------------------------------------------------------ */</comment>


<function><type><name>int</name></type>
<name>PQsslInUse</name><parameter_list>(<parameter><decl><type><name>PGconn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>conn</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
	<return>return <expr><name><name>conn</name><operator>-&gt;</operator><name>ssl_in_use</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 *	Exported function to allow application to tell us it's already
 *	initialized OpenSSL.
 */</comment>
<function><type><name>void</name></type>
<name>PQinitSSL</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>do_init</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_SSL</name></cpp:ifdef>
	<expr_stmt><expr><call><name>pgtls_init_library</name><argument_list>(<argument><expr><name>do_init</name></expr></argument>, <argument><expr><name>do_init</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>

<comment type="block">/*
 *	Exported function to allow application to tell us it's already
 *	initialized OpenSSL and/or libcrypto.
 */</comment>
<function><type><name>void</name></type>
<name>PQinitOpenSSL</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>do_ssl</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>do_crypto</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_SSL</name></cpp:ifdef>
	<expr_stmt><expr><call><name>pgtls_init_library</name><argument_list>(<argument><expr><name>do_ssl</name></expr></argument>, <argument><expr><name>do_crypto</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>

<comment type="block">/*
 *	Initialize global SSL context
 */</comment>
<function><type><name>int</name></type>
<name>pqsecure_initialize</name><parameter_list>(<parameter><decl><type><name>PGconn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>r</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_SSL</name></cpp:ifdef>
	<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>pgtls_init</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<return>return <expr><name>r</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 *	Begin or continue negotiating a secure session.
 */</comment>
<function><type><name>PostgresPollingStatusType</name></type>
<name>pqsecure_open_client</name><parameter_list>(<parameter><decl><type><name>PGconn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_SSL</name></cpp:ifdef>
	<return>return <expr><call><name>pgtls_open_client</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	<comment type="block">/* shouldn't get here */</comment>
	<return>return <expr><name>PGRES_POLLING_FAILED</name></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>

<comment type="block">/*
 *	Close secure session.
 */</comment>
<function><type><name>void</name></type>
<name>pqsecure_close</name><parameter_list>(<parameter><decl><type><name>PGconn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_SSL</name></cpp:ifdef>
	<if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>ssl_in_use</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>pgtls_close</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>

<comment type="block">/*
 *	Read data from a secure connection.
 *
 * On failure, this function is responsible for putting a suitable message
 * into conn-&gt;errorMessage.  The caller must still inspect errno, but only
 * to determine whether to continue/retry after error.
 */</comment>
<function><type><name>ssize_t</name></type>
<name>pqsecure_read</name><parameter_list>(<parameter><decl><type><name>PGconn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>len</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ssize_t</name></type>		<name>n</name></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_SSL</name></cpp:ifdef>
	<if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>ssl_in_use</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>pgtls_read</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<block>{<block_content>
		<expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>pqsecure_raw_read</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<return>return <expr><name>n</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>ssize_t</name></type>
<name>pqsecure_raw_read</name><parameter_list>(<parameter><decl><type><name>PGconn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>len</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ssize_t</name></type>		<name>n</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>result_errno</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>sebuf</name><index>[<expr><literal type="number">256</literal></expr>]</index></name></decl>;</decl_stmt>

	<expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>recv</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>sock</name></name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>n</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>result_errno</name> <operator>=</operator> <name>SOCK_ERRNO</name></expr>;</expr_stmt>

		<comment type="block">/* Set error message if appropriate */</comment>
		<switch>switch <condition>(<expr><name>result_errno</name></expr>)</condition>
		<block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>EAGAIN</name></cpp:ifdef>
			<case>case <expr><name>EAGAIN</name></expr>:</case>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>EWOULDBLOCK</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>(</operator><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>EAGAIN</name></expr></argument>)</argument_list></call> <operator>||</operator> <operator>(</operator><name>EWOULDBLOCK</name> <operator>!=</operator> <name>EAGAIN</name><operator>)</operator><operator>)</operator></expr></cpp:if>
			<case>case <expr><name>EWOULDBLOCK</name></expr>:</case>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
			<case>case <expr><name>EINTR</name></expr>:</case>
				<comment type="block">/* no error message, caller is expected to retry */</comment>
				<break>break;</break>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>ECONNRESET</name></cpp:ifdef>
			<case>case <expr><name>ECONNRESET</name></expr>:</case>
				<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conn</name><operator>-&gt;</operator><name>errorMessage</name></name></expr></argument>,
								  <argument><expr><call><name>libpq_gettext</name><argument_list>(
												<argument><expr><literal type="string">"server closed the connection unexpectedly\n"</literal>
												<literal type="string">"\tThis probably means the server terminated abnormally\n"</literal>
												<literal type="string">"\tbefore or while processing the request.\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

			<default>default:</default>
				<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conn</name><operator>-&gt;</operator><name>errorMessage</name></name></expr></argument>,
								  <argument><expr><call><name>libpq_gettext</name><argument_list>(<argument><expr><literal type="string">"could not receive data from server: %s\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
								  <argument><expr><call><name>SOCK_STRERROR</name><argument_list>(<argument><expr><name>result_errno</name></expr></argument>,
												<argument><expr><name>sebuf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>sebuf</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
		</block_content>}</block></switch>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* ensure we return the intended errno to caller */</comment>
	<expr_stmt><expr><call><name>SOCK_ERRNO_SET</name><argument_list>(<argument><expr><name>result_errno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>n</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 *	Write data to a secure connection.
 *
 * On failure, this function is responsible for putting a suitable message
 * into conn-&gt;errorMessage.  The caller must still inspect errno, but only
 * to determine whether to continue/retry after error.
 */</comment>
<function><type><name>ssize_t</name></type>
<name>pqsecure_write</name><parameter_list>(<parameter><decl><type><name>PGconn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>len</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ssize_t</name></type>		<name>n</name></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_SSL</name></cpp:ifdef>
	<if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>ssl_in_use</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>pgtls_write</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<block>{<block_content>
		<expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>pqsecure_raw_write</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<return>return <expr><name>n</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>ssize_t</name></type>
<name>pqsecure_raw_write</name><parameter_list>(<parameter><decl><type><name>PGconn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>len</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ssize_t</name></type>		<name>n</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>flags</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>result_errno</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>sebuf</name><index>[<expr><literal type="number">256</literal></expr>]</index></name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>DECLARE_SIGPIPE_INFO</name><argument_list>(<argument><expr><name>spinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>MSG_NOSIGNAL</name></cpp:ifdef>
	<if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>sigpipe_flag</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>flags</name> <operator>|=</operator> <name>MSG_NOSIGNAL</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<label><name>retry_masked</name>:</label>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>							<comment type="block">/* MSG_NOSIGNAL */</comment>

	<macro><name>DISABLE_SIGPIPE</name><argument_list>(<argument>conn</argument>, <argument>spinfo</argument>, <argument>return -<literal type="number">1</literal></argument>)</argument_list></macro><empty_stmt>;</empty_stmt>

	<expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>send</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>sock</name></name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>n</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>result_errno</name> <operator>=</operator> <name>SOCK_ERRNO</name></expr>;</expr_stmt>

		<comment type="block">/*
		 * If we see an EINVAL, it may be because MSG_NOSIGNAL isn't available
		 * on this machine.  So, clear sigpipe_flag so we don't try the flag
		 * again, and retry the send().
		 */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>MSG_NOSIGNAL</name></cpp:ifdef>
		<if_stmt><if>if <condition>(<expr><name>flags</name> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>result_errno</name> <operator>==</operator> <name>EINVAL</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>sigpipe_flag</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>flags</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			<goto>goto <name>retry_masked</name>;</goto>
		</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>							<comment type="block">/* MSG_NOSIGNAL */</comment>

		<comment type="block">/* Set error message if appropriate */</comment>
		<switch>switch <condition>(<expr><name>result_errno</name></expr>)</condition>
		<block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>EAGAIN</name></cpp:ifdef>
			<case>case <expr><name>EAGAIN</name></expr>:</case>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>EWOULDBLOCK</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>(</operator><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>EAGAIN</name></expr></argument>)</argument_list></call> <operator>||</operator> <operator>(</operator><name>EWOULDBLOCK</name> <operator>!=</operator> <name>EAGAIN</name><operator>)</operator><operator>)</operator></expr></cpp:if>
			<case>case <expr><name>EWOULDBLOCK</name></expr>:</case>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
			<case>case <expr><name>EINTR</name></expr>:</case>
				<comment type="block">/* no error message, caller is expected to retry */</comment>
				<break>break;</break>

			<case>case <expr><name>EPIPE</name></expr>:</case>
				<comment type="block">/* Set flag for EPIPE */</comment>
				<expr_stmt><expr><call><name>REMEMBER_EPIPE</name><argument_list>(<argument><expr><name>spinfo</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>ECONNRESET</name></cpp:ifdef>
				<comment type="block">/* FALL THRU */</comment>

			<case>case <expr><name>ECONNRESET</name></expr>:</case>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
				<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conn</name><operator>-&gt;</operator><name>errorMessage</name></name></expr></argument>,
								  <argument><expr><call><name>libpq_gettext</name><argument_list>(
												<argument><expr><literal type="string">"server closed the connection unexpectedly\n"</literal>
												<literal type="string">"\tThis probably means the server terminated abnormally\n"</literal>
												<literal type="string">"\tbefore or while processing the request.\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>

			<default>default:</default>
				<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conn</name><operator>-&gt;</operator><name>errorMessage</name></name></expr></argument>,
								  <argument><expr><call><name>libpq_gettext</name><argument_list>(<argument><expr><literal type="string">"could not send data to server: %s\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
								  <argument><expr><call><name>SOCK_STRERROR</name><argument_list>(<argument><expr><name>result_errno</name></expr></argument>,
												<argument><expr><name>sebuf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>sebuf</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
		</block_content>}</block></switch>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>RESTORE_SIGPIPE</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>spinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* ensure we return the intended errno to caller */</comment>
	<expr_stmt><expr><call><name>SOCK_ERRNO_SET</name><argument_list>(<argument><expr><name>result_errno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>n</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Dummy versions of SSL info functions, when built without SSL support */</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>USE_SSL</name></cpp:ifndef>

<function><type><name>void</name> <modifier>*</modifier></type>
<name>PQgetssl</name><parameter_list>(<parameter><decl><type><name>PGconn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name> <modifier>*</modifier></type>
<name>PQsslStruct</name><parameter_list>(<parameter><decl><type><name>PGconn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>struct_name</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>
<name>PQsslAttribute</name><parameter_list>(<parameter><decl><type><name>PGconn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>attribute_name</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>const</specifier> <modifier>*</modifier></type>
<name>PQsslAttributeNames</name><parameter_list>(<parameter><decl><type><name>PGconn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>const</specifier></type> <name><name>result</name><index>[]</index></name> <init>= <expr><block>{<expr><name>NULL</name></expr>}</block></expr></init></decl>;</decl_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>							<comment type="block">/* USE_SSL */</comment>


<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>ENABLE_THREAD_SAFETY</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>WIN32</name></expr></argument>)</argument_list></call></expr></cpp:if>

<comment type="block">/*
 *	Block SIGPIPE for this thread.  This prevents send()/write() from exiting
 *	the application.
 */</comment>
<function><type><name>int</name></type>
<name>pq_block_sigpipe</name><parameter_list>(<parameter><decl><type><name>sigset_t</name> <modifier>*</modifier></type><name>osigset</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>sigpipe_pending</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>sigset_t</name></type>	<name>sigpipe_sigset</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>sigset_t</name></type>	<name>sigset</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>sigemptyset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sigpipe_sigset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>sigaddset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sigpipe_sigset</name></expr></argument>, <argument><expr><name>SIGPIPE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Block SIGPIPE and save previous mask for later reset */</comment>
	<expr_stmt><expr><call><name>SOCK_ERRNO_SET</name><argument_list>(<argument><expr><call><name>pthread_sigmask</name><argument_list>(<argument><expr><name>SIG_BLOCK</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sigpipe_sigset</name></expr></argument>, <argument><expr><name>osigset</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>SOCK_ERRNO</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* We can have a pending SIGPIPE only if it was blocked before */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>sigismember</name><argument_list>(<argument><expr><name>osigset</name></expr></argument>, <argument><expr><name>SIGPIPE</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Is there a pending SIGPIPE? */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>sigpending</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sigset</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>sigismember</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sigset</name></expr></argument>, <argument><expr><name>SIGPIPE</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><operator>*</operator><name>sigpipe_pending</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><operator>*</operator><name>sigpipe_pending</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><operator>*</operator><name>sigpipe_pending</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 *	Discard any pending SIGPIPE and reset the signal mask.
 *
 * Note: we are effectively assuming here that the C library doesn't queue
 * up multiple SIGPIPE events.  If it did, then we'd accidentally leave
 * ours in the queue when an event was already pending and we got another.
 * As long as it doesn't queue multiple events, we're OK because the caller
 * can't tell the difference.
 *
 * The caller should say got_epipe = false if it is certain that it
 * didn't get an EPIPE error; in that case we'll skip the clear operation
 * and things are definitely OK, queuing or no.  If it got one or might have
 * gotten one, pass got_epipe = true.
 *
 * We do not want this to change errno, since if it did that could lose
 * the error code from a preceding send().  We essentially assume that if
 * we were able to do pq_block_sigpipe(), this can't fail.
 */</comment>
<function><type><name>void</name></type>
<name>pq_reset_sigpipe</name><parameter_list>(<parameter><decl><type><name>sigset_t</name> <modifier>*</modifier></type><name>osigset</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>sigpipe_pending</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>got_epipe</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>save_errno</name> <init>= <expr><name>SOCK_ERRNO</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>signo</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>sigset_t</name></type>	<name>sigset</name></decl>;</decl_stmt>

	<comment type="block">/* Clear SIGPIPE only if none was pending */</comment>
	<if_stmt><if>if <condition>(<expr><name>got_epipe</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>sigpipe_pending</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>sigpending</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sigset</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
			<call><name>sigismember</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sigset</name></expr></argument>, <argument><expr><name>SIGPIPE</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>sigset_t</name></type>	<name>sigpipe_sigset</name></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>sigemptyset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sigpipe_sigset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>sigaddset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sigpipe_sigset</name></expr></argument>, <argument><expr><name>SIGPIPE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>sigwait</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sigpipe_sigset</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>signo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Restore saved block mask */</comment>
	<expr_stmt><expr><call><name>pthread_sigmask</name><argument_list>(<argument><expr><name>SIG_SETMASK</name></expr></argument>, <argument><expr><name>osigset</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>SOCK_ERRNO_SET</name><argument_list>(<argument><expr><name>save_errno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>							<comment type="block">/* ENABLE_THREAD_SAFETY &amp;&amp; !WIN32 */</comment>
</unit>
