<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/PolarDB-for-PostgreSQL/src/interfaces/libpq/fe-protocol3.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * fe-protocol3.c
 *	  functions that are specific to frontend/backend protocol version 3
 *
 * Portions Copyright (c) 1996-2018, PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, Regents of the University of California
 *
 *
 * IDENTIFICATION
 *	  src/interfaces/libpq/fe-protocol3.c
 *
 *-------------------------------------------------------------------------
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres_fe.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;ctype.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;fcntl.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"libpq-fe.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"libpq-int.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"mb/pg_wchar.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"port/pg_bswap.h"</cpp:file></cpp:include>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WIN32</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"win32.h"</cpp:file></cpp:include>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;unistd.h&gt;</cpp:file></cpp:include>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_NETINET_TCP_H</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;netinet/tcp.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>


<comment type="block">/*
 * This macro lists the backend message types that could be "long" (more
 * than a couple of kilobytes).
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>VALID_LONG_MESSAGE_TYPE</name><parameter_list>(<parameter><type><name>id</name></type></parameter>)</parameter_list></cpp:macro> \
	<cpp:value>((id) == 'T' || (id) == 'D' || (id) == 'd' || (id) == 'V' || \
	 (id) == 'E' || (id) == 'N' || (id) == 'A')</cpp:value></cpp:define>


<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>handleSyncLoss</name><parameter_list>(<parameter><decl><type><name>PGconn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>, <parameter><decl><type><name>char</name></type> <name>id</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>msgLength</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type>	<name>getRowDescriptions</name><parameter_list>(<parameter><decl><type><name>PGconn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>msgLength</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type>	<name>getParamDescriptions</name><parameter_list>(<parameter><decl><type><name>PGconn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>msgLength</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type>	<name>getAnotherTuple</name><parameter_list>(<parameter><decl><type><name>PGconn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>msgLength</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type>	<name>getParameterStatus</name><parameter_list>(<parameter><decl><type><name>PGconn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type>	<name>getNotify</name><parameter_list>(<parameter><decl><type><name>PGconn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type>	<name>getCopyStart</name><parameter_list>(<parameter><decl><type><name>PGconn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>, <parameter><decl><type><name>ExecStatusType</name></type> <name>copytype</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type>	<name>getReadyForQuery</name><parameter_list>(<parameter><decl><type><name>PGconn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>reportErrorPosition</name><parameter_list>(<parameter><decl><type><name>PQExpBuffer</name></type> <name>msg</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>query</name></decl></parameter>,
					<parameter><decl><type><name>int</name></type> <name>loc</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>encoding</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>build_startup_packet</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>PGconn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>packet</name></decl></parameter>,
					 <parameter><decl><type><specifier>const</specifier> <name>PQEnvironmentOption</name> <modifier>*</modifier></type><name>options</name></decl></parameter>)</parameter_list>;</function_decl>
<comment type="block">/* POLAR px */</comment>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>savePxStatMsg</name><parameter_list>(<parameter><decl><type><name>PGresult</name> <modifier>*</modifier></type><name>result</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>data</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>len</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/*
 * parseInput: if appropriate, parse input data from backend
 * until input is exhausted or a stopping state is reached.
 * Note that this function will NOT attempt to read more data from the backend.
 */</comment>
<function><type><name>void</name></type>
<name>pqParseInput3</name><parameter_list>(<parameter><decl><type><name>PGconn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name></type>		<name>id</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>msgLength</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>avail</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Loop to parse successive complete messages available in the buffer.
	 */</comment>
	<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
	<block>{<block_content>
		<comment type="block">/*
		 * Try to read a message.  First get the type code and length. Return
		 * if not enough data.
		 */</comment>
		<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>inCursor</name></name> <operator>=</operator> <name><name>conn</name><operator>-&gt;</operator><name>inStart</name></name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>pqGetc</name><argument_list>(<argument><expr><operator>&amp;</operator><name>id</name></expr></argument>, <argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<return>return;</return></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>pqGetInt</name><argument_list>(<argument><expr><operator>&amp;</operator><name>msgLength</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>, <argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<return>return;</return></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * Try to validate message type/length here.  A length less than 4 is
		 * definitely broken.  Large lengths should only be believed for a few
		 * message types.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>msgLength</name> <operator>&lt;</operator> <literal type="number">4</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>handleSyncLoss</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>id</name></expr></argument>, <argument><expr><name>msgLength</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return;</return>
		</block_content>}</block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name>msgLength</name> <operator>&gt;</operator> <literal type="number">30000</literal> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>VALID_LONG_MESSAGE_TYPE</name><argument_list>(<argument><expr><name>id</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>handleSyncLoss</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>id</name></expr></argument>, <argument><expr><name>msgLength</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return;</return>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * Can't process if message body isn't all here yet.
		 */</comment>
		<expr_stmt><expr><name>msgLength</name> <operator>-=</operator> <literal type="number">4</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name>avail</name> <operator>=</operator> <name><name>conn</name><operator>-&gt;</operator><name>inEnd</name></name> <operator>-</operator> <name><name>conn</name><operator>-&gt;</operator><name>inCursor</name></name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>avail</name> <operator>&lt;</operator> <name>msgLength</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * Before returning, enlarge the input buffer if needed to hold
			 * the whole message.  This is better than leaving it to
			 * pqReadData because we can avoid multiple cycles of realloc()
			 * when the message is large; also, we can implement a reasonable
			 * recovery strategy if we are unable to make the buffer big
			 * enough.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>pqCheckInBufferSpace</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>inCursor</name></name> <operator>+</operator> <operator>(</operator><name>size_t</name><operator>)</operator> <name>msgLength</name></expr></argument>,
									 <argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/*
				 * XXX add some better recovery code... plan is to skip over
				 * the message using its length, then report an error. For the
				 * moment, just treat this like loss of sync (which indeed it
				 * might be!)
				 */</comment>
				<expr_stmt><expr><call><name>handleSyncLoss</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>id</name></expr></argument>, <argument><expr><name>msgLength</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			<return>return;</return>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * NOTIFY and NOTICE messages can happen in any state; always process
		 * them right away.
		 *
		 * Most other messages should only be processed while in BUSY state.
		 * (In particular, in READY state we hold off further parsing until
		 * the application collects the current PGresult.)
		 *
		 * However, if the state is IDLE then we got trouble; we need to deal
		 * with the unexpected message somehow.
		 *
		 * ParameterStatus ('S') messages are a special case: in IDLE state we
		 * must process 'em (this case could happen if a new value was adopted
		 * from config file due to SIGHUP), but otherwise we hold off until
		 * BUSY state.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>id</name> <operator>==</operator> <literal type="char">'A'</literal></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><call><name>getNotify</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<return>return;</return></block_content></block></if></if_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name>id</name> <operator>==</operator> <literal type="char">'N'</literal></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><call><name>pqGetErrorNotice3</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<return>return;</return></block_content></block></if></if_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>asyncStatus</name></name> <operator>!=</operator> <name>PGASYNC_BUSY</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* If not IDLE state, just wait ... */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>asyncStatus</name></name> <operator>!=</operator> <name>PGASYNC_IDLE</name></expr>)</condition><block type="pseudo"><block_content>
				<return>return;</return></block_content></block></if></if_stmt>

			<comment type="block">/*
			 * Unexpected message in IDLE state; need to recover somehow.
			 * ERROR messages are handled using the notice processor;
			 * ParameterStatus is handled normally; anything else is just
			 * dropped on the floor after displaying a suitable warning
			 * notice.  (An ERROR is very possibly the backend telling us why
			 * it is about to close the connection, so we don't want to just
			 * discard it...)
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name>id</name> <operator>==</operator> <literal type="char">'E'</literal></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><call><name>pqGetErrorNotice3</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>false</name></expr></argument> <comment type="block">/* treat as notice */</comment> )</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<return>return;</return></block_content></block></if></if_stmt>
			</block_content>}</block></if>
			<if type="elseif">else if <condition>(<expr><name>id</name> <operator>==</operator> <literal type="char">'S'</literal></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><call><name>getParameterStatus</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<return>return;</return></block_content></block></if></if_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<expr_stmt><expr><call><name>pqInternalNotice</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conn</name><operator>-&gt;</operator><name>noticeHooks</name></name></expr></argument>,
								 <argument><expr><literal type="string">"message type 0x%02x arrived from server while idle"</literal></expr></argument>,
								 <argument><expr><name>id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<comment type="block">/* Discard the unexpected message */</comment>
				<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>inCursor</name></name> <operator>+=</operator> <name>msgLength</name></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/*
			 * In BUSY state, we can process everything.
			 */</comment>
			<switch>switch <condition>(<expr><name>id</name></expr>)</condition>
			<block>{<block_content>
				<case>case <expr><literal type="char">'C'</literal></expr>:</case>		<comment type="block">/* command complete */</comment>
					<if_stmt><if>if <condition>(<expr><call><name>pqGets</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conn</name><operator>-&gt;</operator><name>workBuffer</name></name></expr></argument>, <argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
						<return>return;</return></block_content></block></if></if_stmt>
					<if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>result</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>result</name></name> <operator>=</operator> <call><name>PQmakeEmptyPGresult</name><argument_list>(<argument><expr><name>conn</name></expr></argument>,
														   <argument><expr><name>PGRES_COMMAND_OK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>conn</name><operator>-&gt;</operator><name>result</name></name></expr>)</condition>
						<block>{<block_content>
							<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conn</name><operator>-&gt;</operator><name>errorMessage</name></name></expr></argument>,
											  <argument><expr><call><name>libpq_gettext</name><argument_list>(<argument><expr><literal type="string">"out of memory"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							<expr_stmt><expr><call><name>pqSaveErrorResult</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						</block_content>}</block></if></if_stmt>
					</block_content>}</block></if></if_stmt>
					<if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>result</name></name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>strlcpy</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>result</name><operator>-&gt;</operator><name>cmdStatus</name></name></expr></argument>, <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>workBuffer</name><operator>.</operator><name>data</name></name></expr></argument>,
								<argument><expr><name>CMDSTATUS_LEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
					<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>asyncStatus</name></name> <operator>=</operator> <name>PGASYNC_READY</name></expr>;</expr_stmt>
					<break>break;</break>
				<case>case <expr><literal type="char">'E'</literal></expr>:</case>		<comment type="block">/* error return */</comment>
					<if_stmt><if>if <condition>(<expr><call><name>pqGetErrorNotice3</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
						<return>return;</return></block_content></block></if></if_stmt>
					<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>asyncStatus</name></name> <operator>=</operator> <name>PGASYNC_READY</name></expr>;</expr_stmt>
					<break>break;</break>
				<case>case <expr><literal type="char">'Z'</literal></expr>:</case>		<comment type="block">/* backend is ready for new query */</comment>
					<if_stmt><if>if <condition>(<expr><call><name>getReadyForQuery</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
						<return>return;</return></block_content></block></if></if_stmt>
					<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>asyncStatus</name></name> <operator>=</operator> <name>PGASYNC_IDLE</name></expr>;</expr_stmt>
					<break>break;</break>
				<case>case <expr><literal type="char">'I'</literal></expr>:</case>		<comment type="block">/* empty query */</comment>
					<if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>result</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>result</name></name> <operator>=</operator> <call><name>PQmakeEmptyPGresult</name><argument_list>(<argument><expr><name>conn</name></expr></argument>,
														   <argument><expr><name>PGRES_EMPTY_QUERY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>conn</name><operator>-&gt;</operator><name>result</name></name></expr>)</condition>
						<block>{<block_content>
							<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conn</name><operator>-&gt;</operator><name>errorMessage</name></name></expr></argument>,
											  <argument><expr><call><name>libpq_gettext</name><argument_list>(<argument><expr><literal type="string">"out of memory"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							<expr_stmt><expr><call><name>pqSaveErrorResult</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						</block_content>}</block></if></if_stmt>
					</block_content>}</block></if></if_stmt>
					<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>asyncStatus</name></name> <operator>=</operator> <name>PGASYNC_READY</name></expr>;</expr_stmt>
					<break>break;</break>
				<case>case <expr><literal type="char">'1'</literal></expr>:</case>		<comment type="block">/* Parse Complete */</comment>
					<comment type="block">/* If we're doing PQprepare, we're done; else ignore */</comment>
					<if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>queryclass</name></name> <operator>==</operator> <name>PGQUERY_PREPARE</name></expr>)</condition>
					<block>{<block_content>
						<if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>result</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
						<block>{<block_content>
							<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>result</name></name> <operator>=</operator> <call><name>PQmakeEmptyPGresult</name><argument_list>(<argument><expr><name>conn</name></expr></argument>,
															   <argument><expr><name>PGRES_COMMAND_OK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>conn</name><operator>-&gt;</operator><name>result</name></name></expr>)</condition>
							<block>{<block_content>
								<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conn</name><operator>-&gt;</operator><name>errorMessage</name></name></expr></argument>,
												  <argument><expr><call><name>libpq_gettext</name><argument_list>(<argument><expr><literal type="string">"out of memory"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
								<expr_stmt><expr><call><name>pqSaveErrorResult</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							</block_content>}</block></if></if_stmt>
						</block_content>}</block></if></if_stmt>
						<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>asyncStatus</name></name> <operator>=</operator> <name>PGASYNC_READY</name></expr>;</expr_stmt>
					</block_content>}</block></if></if_stmt>
					<break>break;</break>
				<case>case <expr><literal type="char">'2'</literal></expr>:</case>		<comment type="block">/* Bind Complete */</comment>
				<case>case <expr><literal type="char">'3'</literal></expr>:</case>		<comment type="block">/* Close Complete */</comment>
					<comment type="block">/* Nothing to do for these message types */</comment>
					<break>break;</break>
				<case>case <expr><literal type="char">'S'</literal></expr>:</case>		<comment type="block">/* parameter status */</comment>
					<if_stmt><if>if <condition>(<expr><call><name>getParameterStatus</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
						<return>return;</return></block_content></block></if></if_stmt>
					<break>break;</break>
				<case>case <expr><literal type="char">'K'</literal></expr>:</case>		<comment type="block">/* secret key data from the backend */</comment>

					<comment type="block">/*
					 * This is expected only during backend startup, but it's
					 * just as easy to handle it as part of the main loop.
					 * Save the data and continue processing.
					 */</comment>
					<if_stmt><if>if <condition>(<expr><call><name>pqGetInt</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>conn</name><operator>-&gt;</operator><name>be_pid</name></name><operator>)</operator></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>, <argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
						<return>return;</return></block_content></block></if></if_stmt>
					<if_stmt><if>if <condition>(<expr><call><name>pqGetInt</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>conn</name><operator>-&gt;</operator><name>be_key</name></name><operator>)</operator></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>, <argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
						<return>return;</return></block_content></block></if></if_stmt>
					<break>break;</break>
				<case>case <expr><literal type="char">'T'</literal></expr>:</case>		<comment type="block">/* Row Description */</comment>
					<if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>result</name></name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator>
						<name><name>conn</name><operator>-&gt;</operator><name>result</name><operator>-&gt;</operator><name>resultStatus</name></name> <operator>==</operator> <name>PGRES_FATAL_ERROR</name></expr>)</condition>
					<block>{<block_content>
						<comment type="block">/*
						 * We've already choked for some reason.  Just discard
						 * the data till we get to the end of the query.
						 */</comment>
						<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>inCursor</name></name> <operator>+=</operator> <name>msgLength</name></expr>;</expr_stmt>
					</block_content>}</block></if>
					<if type="elseif">else if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>result</name></name> <operator>==</operator> <name>NULL</name> <operator>||</operator>
							 <name><name>conn</name><operator>-&gt;</operator><name>queryclass</name></name> <operator>==</operator> <name>PGQUERY_DESCRIBE</name></expr>)</condition>
					<block>{<block_content>
						<comment type="block">/* First 'T' in a query sequence */</comment>
						<if_stmt><if>if <condition>(<expr><call><name>getRowDescriptions</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>msgLength</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
							<return>return;</return></block_content></block></if></if_stmt>
						<comment type="block">/* getRowDescriptions() moves inStart itself */</comment>
						<continue>continue;</continue>
					</block_content>}</block></if>
					<else>else
					<block>{<block_content>
						<comment type="block">/*
						 * A new 'T' message is treated as the start of
						 * another PGresult.  (It is not clear that this is
						 * really possible with the current backend.) We stop
						 * parsing until the application accepts the current
						 * result.
						 */</comment>
						<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>asyncStatus</name></name> <operator>=</operator> <name>PGASYNC_READY</name></expr>;</expr_stmt>
						<return>return;</return>
					</block_content>}</block></else></if_stmt>
					<break>break;</break>
				<case>case <expr><literal type="char">'n'</literal></expr>:</case>		<comment type="block">/* No Data */</comment>

					<comment type="block">/*
					 * NoData indicates that we will not be seeing a
					 * RowDescription message because the statement or portal
					 * inquired about doesn't return rows.
					 *
					 * If we're doing a Describe, we have to pass something
					 * back to the client, so set up a COMMAND_OK result,
					 * instead of TUPLES_OK.  Otherwise we can just ignore
					 * this message.
					 */</comment>
					<if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>queryclass</name></name> <operator>==</operator> <name>PGQUERY_DESCRIBE</name></expr>)</condition>
					<block>{<block_content>
						<if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>result</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
						<block>{<block_content>
							<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>result</name></name> <operator>=</operator> <call><name>PQmakeEmptyPGresult</name><argument_list>(<argument><expr><name>conn</name></expr></argument>,
															   <argument><expr><name>PGRES_COMMAND_OK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>conn</name><operator>-&gt;</operator><name>result</name></name></expr>)</condition>
							<block>{<block_content>
								<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conn</name><operator>-&gt;</operator><name>errorMessage</name></name></expr></argument>,
												  <argument><expr><call><name>libpq_gettext</name><argument_list>(<argument><expr><literal type="string">"out of memory"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
								<expr_stmt><expr><call><name>pqSaveErrorResult</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							</block_content>}</block></if></if_stmt>
						</block_content>}</block></if></if_stmt>
						<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>asyncStatus</name></name> <operator>=</operator> <name>PGASYNC_READY</name></expr>;</expr_stmt>
					</block_content>}</block></if></if_stmt>
					<break>break;</break>
				<case>case <expr><literal type="char">'t'</literal></expr>:</case>		<comment type="block">/* Parameter Description */</comment>
					<if_stmt><if>if <condition>(<expr><call><name>getParamDescriptions</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>msgLength</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
						<return>return;</return></block_content></block></if></if_stmt>
					<comment type="block">/* getParamDescriptions() moves inStart itself */</comment>
					<continue>continue;</continue>
				<case>case <expr><literal type="char">'D'</literal></expr>:</case>		<comment type="block">/* Data Row */</comment>
					<if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>result</name></name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator>
						<name><name>conn</name><operator>-&gt;</operator><name>result</name><operator>-&gt;</operator><name>resultStatus</name></name> <operator>==</operator> <name>PGRES_TUPLES_OK</name></expr>)</condition>
					<block>{<block_content>
						<comment type="block">/* Read another tuple of a normal query response */</comment>
						<if_stmt><if>if <condition>(<expr><call><name>getAnotherTuple</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>msgLength</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
							<return>return;</return></block_content></block></if></if_stmt>
						<comment type="block">/* getAnotherTuple() moves inStart itself */</comment>
						<continue>continue;</continue>
					</block_content>}</block></if>
					<if type="elseif">else if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>result</name></name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator>
							 <name><name>conn</name><operator>-&gt;</operator><name>result</name><operator>-&gt;</operator><name>resultStatus</name></name> <operator>==</operator> <name>PGRES_FATAL_ERROR</name></expr>)</condition>
					<block>{<block_content>
						<comment type="block">/*
						 * We've already choked for some reason.  Just discard
						 * tuples till we get to the end of the query.
						 */</comment>
						<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>inCursor</name></name> <operator>+=</operator> <name>msgLength</name></expr>;</expr_stmt>
					</block_content>}</block></if>
					<else>else
					<block>{<block_content>
						<comment type="block">/* Set up to report error at end of query */</comment>
						<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conn</name><operator>-&gt;</operator><name>errorMessage</name></name></expr></argument>,
										  <argument><expr><call><name>libpq_gettext</name><argument_list>(<argument><expr><literal type="string">"server sent data (\"D\" message) without prior row description (\"T\" message)\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><call><name>pqSaveErrorResult</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<comment type="block">/* Discard the unexpected message */</comment>
						<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>inCursor</name></name> <operator>+=</operator> <name>msgLength</name></expr>;</expr_stmt>
					</block_content>}</block></else></if_stmt>
					<break>break;</break>
				<case>case <expr><literal type="char">'G'</literal></expr>:</case>		<comment type="block">/* Start Copy In */</comment>
					<if_stmt><if>if <condition>(<expr><call><name>getCopyStart</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>PGRES_COPY_IN</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
						<return>return;</return></block_content></block></if></if_stmt>
					<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>asyncStatus</name></name> <operator>=</operator> <name>PGASYNC_COPY_IN</name></expr>;</expr_stmt>
					<break>break;</break>
				<case>case <expr><literal type="char">'H'</literal></expr>:</case>		<comment type="block">/* Start Copy Out */</comment>
					<if_stmt><if>if <condition>(<expr><call><name>getCopyStart</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>PGRES_COPY_OUT</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
						<return>return;</return></block_content></block></if></if_stmt>
					<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>asyncStatus</name></name> <operator>=</operator> <name>PGASYNC_COPY_OUT</name></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>copy_already_done</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
					<break>break;</break>
				<case>case <expr><literal type="char">'W'</literal></expr>:</case>		<comment type="block">/* Start Copy Both */</comment>
					<if_stmt><if>if <condition>(<expr><call><name>getCopyStart</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>PGRES_COPY_BOTH</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
						<return>return;</return></block_content></block></if></if_stmt>
					<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>asyncStatus</name></name> <operator>=</operator> <name>PGASYNC_COPY_BOTH</name></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>copy_already_done</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
					<break>break;</break>
				<case>case <expr><literal type="char">'d'</literal></expr>:</case>		<comment type="block">/* Copy Data */</comment>

					<comment type="block">/*
					 * If we see Copy Data, just silently drop it.  This would
					 * only occur if application exits COPY OUT mode too
					 * early.
					 */</comment>
					<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>inCursor</name></name> <operator>+=</operator> <name>msgLength</name></expr>;</expr_stmt>
					<break>break;</break>
				<case>case <expr><literal type="char">'c'</literal></expr>:</case>		<comment type="block">/* Copy Done */</comment>

					<comment type="block">/*
					 * If we see Copy Done, just silently drop it.  This is
					 * the normal case during PQendcopy.  We will keep
					 * swallowing data, expecting to see command-complete for
					 * the COPY command.
					 */</comment>
					<break>break;</break>
				<case>case <expr><literal type="char">'Y'</literal></expr>:</case>
					<comment type="block">/* POLAR px: statistical response from PX to QC */</comment>
					<comment type="block">/* for certain queries, the stats may arrive
					 * before the completion status -- for this case
					 * we're responsible for allocating the result
					 * struct */</comment>
					<if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>result</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>result</name></name> <operator>=</operator> <call><name>PQmakeEmptyPGresult</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>PGRES_COMMAND_OK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
					<if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>result</name></name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>savePxStatMsg</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>result</name></name></expr></argument>,
									   <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>inBuffer</name></name> <operator>+</operator> <name><name>conn</name><operator>-&gt;</operator><name>inCursor</name></name></expr></argument>,
									   <argument><expr><name>msgLength</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
					<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>inCursor</name></name> <operator>+=</operator> <name>msgLength</name></expr>;</expr_stmt>
					<break>break;</break>
					<comment type="block">/* Polar end */</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>FRONTEND</name></cpp:ifndef>
				<case>case <expr><literal type="char">'j'</literal></expr>:</case>
					<comment type="block">/*
					 * PX COPY reports number of rejected rows to the QC COPY
					 * in single row error handling mode.
					 */</comment>
					<if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>result</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>result</name></name> <operator>=</operator> <call><name>PQmakeEmptyPGresult</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>PGRES_COMMAND_OK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>conn</name><operator>-&gt;</operator><name>result</name></name></expr>)</condition><block type="pseudo"><block_content>
							<return>return;</return></block_content></block></if></if_stmt>
					</block_content>}</block></if></if_stmt>

					<if_stmt><if>if <condition>(<expr><call><name>pqGetInt64</name><argument_list>(<argument><expr><operator>&amp;</operator><name>numRejected</name></expr></argument>, <argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
						<return>return;</return></block_content></block></if></if_stmt>

					<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>result</name><operator>-&gt;</operator><name>numRejected</name></name> <operator>+=</operator> <name>numRejected</name></expr>;</expr_stmt>

					<comment type="block">/* Optionally receive completed number when COPY FROM ON SEGMENT */</comment>
					<if_stmt><if>if <condition>(<expr><name>msgLength</name> <operator>&gt;=</operator> <literal type="number">12</literal> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>pqGetInt64</name><argument_list>(<argument><expr><operator>&amp;</operator><name>numCompleted</name></expr></argument>, <argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>result</name><operator>-&gt;</operator><name>numCompleted</name></name> <operator>+=</operator> <name>numCompleted</name></expr>;</expr_stmt>
					</block_content>}</block></if></if_stmt>

					<break>break;</break>
				<case>case <expr><literal type="char">'y'</literal></expr>:</case>
					<comment type="block">/*
					 * POLAR px: for gang management and stats collection for Vacuum/Analyze
					 * commands.
					 */</comment>
					<if_stmt><if>if <condition>(<expr><call><name>pqGets</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conn</name><operator>-&gt;</operator><name>workBuffer</name></name></expr></argument>, <argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
						<return>return;</return></block_content></block></if></if_stmt>
					<if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>result</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>result</name></name> <operator>=</operator> <call><name>PQmakeEmptyPGresult</name><argument_list>(<argument><expr><name>conn</name></expr></argument>,
														   <argument><expr><name>PGRES_COMMAND_OK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>conn</name><operator>-&gt;</operator><name>result</name></name></expr>)</condition><block type="pseudo"><block_content>
							<return>return;</return></block_content></block></if></if_stmt>
					</block_content>}</block></if></if_stmt>
					<expr_stmt><expr><call><name>strlcpy</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>result</name><operator>-&gt;</operator><name>cmdStatus</name></name></expr></argument>, <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>workBuffer</name><operator>.</operator><name>data</name></name></expr></argument>,
							<argument><expr><name>CMDSTATUS_LEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<if_stmt><if>if <condition>(<expr><call><name>pqGetInt</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conn</name><operator>-&gt;</operator><name>result</name><operator>-&gt;</operator><name>extraslen</name></name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>, <argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
						<return>return;</return></block_content></block></if></if_stmt>
					<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>result</name><operator>-&gt;</operator><name>extras</name></name> <operator>=</operator> <call><name>malloc</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>result</name><operator>-&gt;</operator><name>extraslen</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<if_stmt><if>if <condition>(<expr><call><name>pqGetnchar</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name><name>conn</name><operator>-&gt;</operator><name>result</name><operator>-&gt;</operator><name>extras</name></name></expr></argument>, <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>result</name><operator>-&gt;</operator><name>extraslen</name></name></expr></argument>, <argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
						<return>return;</return></block_content></block></if></if_stmt>
					<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>asyncStatus</name></name> <operator>=</operator> <name>PGASYNC_READY</name></expr>;</expr_stmt>

					<break>break;</break>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

				<default>default:</default>
					<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conn</name><operator>-&gt;</operator><name>errorMessage</name></name></expr></argument>,
									  <argument><expr><call><name>libpq_gettext</name><argument_list>(
													<argument><expr><literal type="string">"unexpected response from server; first received character was \"%c\"\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
									  <argument><expr><name>id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<comment type="block">/* build an error result holding the error message */</comment>
					<expr_stmt><expr><call><name>pqSaveErrorResult</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<comment type="block">/* not sure if we will see more, so go to ready state */</comment>
					<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>asyncStatus</name></name> <operator>=</operator> <name>PGASYNC_READY</name></expr>;</expr_stmt>
					<comment type="block">/* Discard the unexpected message */</comment>
					<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>inCursor</name></name> <operator>+=</operator> <name>msgLength</name></expr>;</expr_stmt>
					<break>break;</break>
			</block_content>}</block></switch>					<comment type="block">/* switch on protocol character */</comment>
		</block_content>}</block></else></if_stmt>
		<comment type="block">/* Successfully consumed this message */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>inCursor</name></name> <operator>==</operator> <name><name>conn</name><operator>-&gt;</operator><name>inStart</name></name> <operator>+</operator> <literal type="number">5</literal> <operator>+</operator> <name>msgLength</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Normal case: parsing agrees with specified length */</comment>
			<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>inStart</name></name> <operator>=</operator> <name><name>conn</name><operator>-&gt;</operator><name>inCursor</name></name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/* Trouble --- report it */</comment>
			<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conn</name><operator>-&gt;</operator><name>errorMessage</name></name></expr></argument>,
							  <argument><expr><call><name>libpq_gettext</name><argument_list>(<argument><expr><literal type="string">"message contents do not agree with length in message type \"%c\"\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
							  <argument><expr><name>id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* build an error result holding the error message */</comment>
			<expr_stmt><expr><call><name>pqSaveErrorResult</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>asyncStatus</name></name> <operator>=</operator> <name>PGASYNC_READY</name></expr>;</expr_stmt>
			<comment type="block">/* trust the specified message length as what to skip */</comment>
			<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>inStart</name></name> <operator>+=</operator> <literal type="number">5</literal> <operator>+</operator> <name>msgLength</name></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></for>
</block_content>}</block></function>

<comment type="block">/*
 * handleSyncLoss: clean up after loss of message-boundary sync
 *
 * There isn't really a lot we can do here except abandon the connection.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>handleSyncLoss</name><parameter_list>(<parameter><decl><type><name>PGconn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>, <parameter><decl><type><name>char</name></type> <name>id</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>msgLength</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conn</name><operator>-&gt;</operator><name>errorMessage</name></name></expr></argument>,
					  <argument><expr><call><name>libpq_gettext</name><argument_list>(
									<argument><expr><literal type="string">"lost synchronization with server: got message type \"%c\", length %d\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
					  <argument><expr><name>id</name></expr></argument>, <argument><expr><name>msgLength</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* build an error result holding the error message */</comment>
	<expr_stmt><expr><call><name>pqSaveErrorResult</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>asyncStatus</name></name> <operator>=</operator> <name>PGASYNC_READY</name></expr>;</expr_stmt>	<comment type="block">/* drop out of GetResult wait loop */</comment>
	<comment type="block">/* flush input data since we're giving up on processing it */</comment>
	<expr_stmt><expr><call><name>pqDropConnection</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>status</name></name> <operator>=</operator> <name>CONNECTION_BAD</name></expr>;</expr_stmt>	<comment type="block">/* No more connection to backend */</comment>
</block_content>}</block></function>

<comment type="block">/*
 * parseInput subroutine to read a 'T' (row descriptions) message.
 * We'll build a new PGresult structure (unless called for a Describe
 * command for a prepared statement) containing the attribute data.
 * Returns: 0 if processed message successfully, EOF to suspend parsing
 * (the latter case is not actually used currently).
 * In the former case, conn-&gt;inStart has been advanced past the message.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>getRowDescriptions</name><parameter_list>(<parameter><decl><type><name>PGconn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>msgLength</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>nfields</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>errmsg</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * When doing Describe for a prepared statement, there'll already be a
	 * PGresult created by getParamDescriptions, and we should fill data into
	 * that.  Otherwise, create a new, empty PGresult.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>queryclass</name></name> <operator>==</operator> <name>PGQUERY_DESCRIBE</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>result</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <name><name>conn</name><operator>-&gt;</operator><name>result</name></name></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>PQmakeEmptyPGresult</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>PGRES_COMMAND_OK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>PQmakeEmptyPGresult</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>PGRES_TUPLES_OK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>result</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>errmsg</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>			<comment type="block">/* means "out of memory", see below */</comment>
		<goto>goto <name>advance_and_error</name>;</goto>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* parseInput already read the 'T' label and message length. */</comment>
	<comment type="block">/* the next two bytes are the number of fields */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>pqGetInt</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>result</name><operator>-&gt;</operator><name>numAttributes</name></name><operator>)</operator></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* We should not run out of data here, so complain */</comment>
		<expr_stmt><expr><name>errmsg</name> <operator>=</operator> <call><name>libpq_gettext</name><argument_list>(<argument><expr><literal type="string">"insufficient data in \"T\" message"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<goto>goto <name>advance_and_error</name>;</goto>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name>nfields</name> <operator>=</operator> <name><name>result</name><operator>-&gt;</operator><name>numAttributes</name></name></expr>;</expr_stmt>

	<comment type="block">/* allocate space for the attribute descriptors */</comment>
	<if_stmt><if>if <condition>(<expr><name>nfields</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>attDescs</name></name> <operator>=</operator> <operator>(</operator><name>PGresAttDesc</name> <operator>*</operator><operator>)</operator>
			<call><name>pqResultAlloc</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>nfields</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>PGresAttDesc</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>result</name><operator>-&gt;</operator><name>attDescs</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>errmsg</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>		<comment type="block">/* means "out of memory", see below */</comment>
			<goto>goto <name>advance_and_error</name>;</goto>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><name><name>result</name><operator>-&gt;</operator><name>attDescs</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>nfields</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>PGresAttDesc</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* result-&gt;binary is true only if ALL columns are binary */</comment>
	<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>binary</name></name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name>nfields</name> <operator>&gt;</operator> <literal type="number">0</literal><operator>)</operator></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr>;</expr_stmt>

	<comment type="block">/* get type info */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nfields</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>tableid</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>columnid</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>typid</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>typlen</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>atttypmod</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>format</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>pqGets</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conn</name><operator>-&gt;</operator><name>workBuffer</name></name></expr></argument>, <argument><expr><name>conn</name></expr></argument>)</argument_list></call> <operator>||</operator>
			<call><name>pqGetInt</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tableid</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>, <argument><expr><name>conn</name></expr></argument>)</argument_list></call> <operator>||</operator>
			<call><name>pqGetInt</name><argument_list>(<argument><expr><operator>&amp;</operator><name>columnid</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>conn</name></expr></argument>)</argument_list></call> <operator>||</operator>
			<call><name>pqGetInt</name><argument_list>(<argument><expr><operator>&amp;</operator><name>typid</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>, <argument><expr><name>conn</name></expr></argument>)</argument_list></call> <operator>||</operator>
			<call><name>pqGetInt</name><argument_list>(<argument><expr><operator>&amp;</operator><name>typlen</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>conn</name></expr></argument>)</argument_list></call> <operator>||</operator>
			<call><name>pqGetInt</name><argument_list>(<argument><expr><operator>&amp;</operator><name>atttypmod</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>, <argument><expr><name>conn</name></expr></argument>)</argument_list></call> <operator>||</operator>
			<call><name>pqGetInt</name><argument_list>(<argument><expr><operator>&amp;</operator><name>format</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* We should not run out of data here, so complain */</comment>
			<expr_stmt><expr><name>errmsg</name> <operator>=</operator> <call><name>libpq_gettext</name><argument_list>(<argument><expr><literal type="string">"insufficient data in \"T\" message"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<goto>goto <name>advance_and_error</name>;</goto>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * Since pqGetInt treats 2-byte integers as unsigned, we need to
		 * coerce these results to signed form.
		 */</comment>
		<expr_stmt><expr><name>columnid</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator> <operator>(</operator><operator>(</operator><name>int16</name><operator>)</operator> <name>columnid</name><operator>)</operator></expr>;</expr_stmt>
		<expr_stmt><expr><name>typlen</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator> <operator>(</operator><operator>(</operator><name>int16</name><operator>)</operator> <name>typlen</name><operator>)</operator></expr>;</expr_stmt>
		<expr_stmt><expr><name>format</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator> <operator>(</operator><operator>(</operator><name>int16</name><operator>)</operator> <name>format</name><operator>)</operator></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>attDescs</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>name</name> <operator>=</operator> <call><name>pqResultStrdup</name><argument_list>(<argument><expr><name>result</name></expr></argument>,
												  <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>workBuffer</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>result</name><operator>-&gt;</operator><name>attDescs</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>name</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>errmsg</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>		<comment type="block">/* means "out of memory", see below */</comment>
			<goto>goto <name>advance_and_error</name>;</goto>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>attDescs</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>tableid</name> <operator>=</operator> <name>tableid</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>attDescs</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>columnid</name> <operator>=</operator> <name>columnid</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>attDescs</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>format</name> <operator>=</operator> <name>format</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>attDescs</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>typid</name> <operator>=</operator> <name>typid</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>attDescs</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>typlen</name> <operator>=</operator> <name>typlen</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>attDescs</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>atttypmod</name> <operator>=</operator> <name>atttypmod</name></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>format</name> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>binary</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></for>

	<comment type="block">/* Sanity check that we absorbed all the data */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>inCursor</name></name> <operator>!=</operator> <name><name>conn</name><operator>-&gt;</operator><name>inStart</name></name> <operator>+</operator> <literal type="number">5</literal> <operator>+</operator> <name>msgLength</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>errmsg</name> <operator>=</operator> <call><name>libpq_gettext</name><argument_list>(<argument><expr><literal type="string">"extraneous data in \"T\" message"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<goto>goto <name>advance_and_error</name>;</goto>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Success! */</comment>
	<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>result</name></name> <operator>=</operator> <name>result</name></expr>;</expr_stmt>

	<comment type="block">/* Advance inStart to show that the "T" message has been processed. */</comment>
	<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>inStart</name></name> <operator>=</operator> <name><name>conn</name><operator>-&gt;</operator><name>inCursor</name></name></expr>;</expr_stmt>

	<comment type="block">/*
	 * If we're doing a Describe, we're done, and ready to pass the result
	 * back to the client.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>queryclass</name></name> <operator>==</operator> <name>PGQUERY_DESCRIBE</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>asyncStatus</name></name> <operator>=</operator> <name>PGASYNC_READY</name></expr>;</expr_stmt>
		<return>return <expr><literal type="number">0</literal></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * We could perform additional setup for the new result set here, but for
	 * now there's nothing else to do.
	 */</comment>

	<comment type="block">/* And we're done. */</comment>
	<return>return <expr><literal type="number">0</literal></expr>;</return>

<label><name>advance_and_error</name>:</label>
	<comment type="block">/* Discard unsaved result, if any */</comment>
	<if_stmt><if>if <condition>(<expr><name>result</name> <operator>&amp;&amp;</operator> <name>result</name> <operator>!=</operator> <name><name>conn</name><operator>-&gt;</operator><name>result</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Discard the failed message by pretending we read it */</comment>
	<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>inStart</name></name> <operator>+=</operator> <literal type="number">5</literal> <operator>+</operator> <name>msgLength</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Replace partially constructed result with an error result. First
	 * discard the old result to try to win back some memory.
	 */</comment>
	<expr_stmt><expr><call><name>pqClearAsyncResult</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If preceding code didn't provide an error message, assume "out of
	 * memory" was meant.  The advantage of having this special case is that
	 * freeing the old result first greatly improves the odds that gettext()
	 * will succeed in providing a translation.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>errmsg</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>errmsg</name> <operator>=</operator> <call><name>libpq_gettext</name><argument_list>(<argument><expr><literal type="string">"out of memory for query result"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conn</name><operator>-&gt;</operator><name>errorMessage</name></name></expr></argument>, <argument><expr><literal type="string">"%s\n"</literal></expr></argument>, <argument><expr><name>errmsg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pqSaveErrorResult</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Return zero to allow input parsing to continue.  Subsequent "D"
	 * messages will be ignored until we get to end of data, since an error
	 * result is already set up.
	 */</comment>
	<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * parseInput subroutine to read a 't' (ParameterDescription) message.
 * We'll build a new PGresult structure containing the parameter data.
 * Returns: 0 if completed message, EOF if not enough data yet.
 * In the former case, conn-&gt;inStart has been advanced past the message.
 *
 * Note that if we run out of data, we have to release the partially
 * constructed PGresult, and rebuild it again next time.  Fortunately,
 * that shouldn't happen often, since 't' messages usually fit in a packet.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>getParamDescriptions</name><parameter_list>(<parameter><decl><type><name>PGconn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>msgLength</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>errmsg</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>	<comment type="block">/* means "out of memory", see below */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>nparams</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>PQmakeEmptyPGresult</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>PGRES_COMMAND_OK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>result</name></expr>)</condition><block type="pseudo"><block_content>
		<goto>goto <name>advance_and_error</name>;</goto></block_content></block></if></if_stmt>

	<comment type="block">/* parseInput already read the 't' label and message length. */</comment>
	<comment type="block">/* the next two bytes are the number of parameters */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>pqGetInt</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>result</name><operator>-&gt;</operator><name>numParameters</name></name><operator>)</operator></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<goto>goto <name>not_enough_data</name>;</goto></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>nparams</name> <operator>=</operator> <name><name>result</name><operator>-&gt;</operator><name>numParameters</name></name></expr>;</expr_stmt>

	<comment type="block">/* allocate space for the parameter descriptors */</comment>
	<if_stmt><if>if <condition>(<expr><name>nparams</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>paramDescs</name></name> <operator>=</operator> <operator>(</operator><name>PGresParamDesc</name> <operator>*</operator><operator>)</operator>
			<call><name>pqResultAlloc</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>nparams</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>PGresParamDesc</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>result</name><operator>-&gt;</operator><name>paramDescs</name></name></expr>)</condition><block type="pseudo"><block_content>
			<goto>goto <name>advance_and_error</name>;</goto></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><name><name>result</name><operator>-&gt;</operator><name>paramDescs</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>nparams</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>PGresParamDesc</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* get parameter info */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nparams</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>typid</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>pqGetInt</name><argument_list>(<argument><expr><operator>&amp;</operator><name>typid</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>, <argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<goto>goto <name>not_enough_data</name>;</goto></block_content></block></if></if_stmt>
		<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>paramDescs</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>typid</name> <operator>=</operator> <name>typid</name></expr>;</expr_stmt>
	</block_content>}</block></for>

	<comment type="block">/* Sanity check that we absorbed all the data */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>inCursor</name></name> <operator>!=</operator> <name><name>conn</name><operator>-&gt;</operator><name>inStart</name></name> <operator>+</operator> <literal type="number">5</literal> <operator>+</operator> <name>msgLength</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>errmsg</name> <operator>=</operator> <call><name>libpq_gettext</name><argument_list>(<argument><expr><literal type="string">"extraneous data in \"t\" message"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<goto>goto <name>advance_and_error</name>;</goto>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Success! */</comment>
	<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>result</name></name> <operator>=</operator> <name>result</name></expr>;</expr_stmt>

	<comment type="block">/* Advance inStart to show that the "t" message has been processed. */</comment>
	<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>inStart</name></name> <operator>=</operator> <name><name>conn</name><operator>-&gt;</operator><name>inCursor</name></name></expr>;</expr_stmt>

	<return>return <expr><literal type="number">0</literal></expr>;</return>

<label><name>not_enough_data</name>:</label>
	<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>EOF</name></expr>;</return>

<label><name>advance_and_error</name>:</label>
	<comment type="block">/* Discard unsaved result, if any */</comment>
	<if_stmt><if>if <condition>(<expr><name>result</name> <operator>&amp;&amp;</operator> <name>result</name> <operator>!=</operator> <name><name>conn</name><operator>-&gt;</operator><name>result</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Discard the failed message by pretending we read it */</comment>
	<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>inStart</name></name> <operator>+=</operator> <literal type="number">5</literal> <operator>+</operator> <name>msgLength</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Replace partially constructed result with an error result. First
	 * discard the old result to try to win back some memory.
	 */</comment>
	<expr_stmt><expr><call><name>pqClearAsyncResult</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If preceding code didn't provide an error message, assume "out of
	 * memory" was meant.  The advantage of having this special case is that
	 * freeing the old result first greatly improves the odds that gettext()
	 * will succeed in providing a translation.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>errmsg</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>errmsg</name> <operator>=</operator> <call><name>libpq_gettext</name><argument_list>(<argument><expr><literal type="string">"out of memory"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conn</name><operator>-&gt;</operator><name>errorMessage</name></name></expr></argument>, <argument><expr><literal type="string">"%s\n"</literal></expr></argument>, <argument><expr><name>errmsg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pqSaveErrorResult</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Return zero to allow input parsing to continue.  Essentially, we've
	 * replaced the COMMAND_OK result with an error result, but since this
	 * doesn't affect the protocol state, it's fine.
	 */</comment>
	<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * parseInput subroutine to read a 'D' (row data) message.
 * We fill rowbuf with column pointers and then call the row processor.
 * Returns: 0 if processed message successfully, EOF to suspend parsing
 * (the latter case is not actually used currently).
 * In the former case, conn-&gt;inStart has been advanced past the message.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>getAnotherTuple</name><parameter_list>(<parameter><decl><type><name>PGconn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>msgLength</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier></type><name>result</name> <init>= <expr><name><name>conn</name><operator>-&gt;</operator><name>result</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>nfields</name> <init>= <expr><name><name>result</name><operator>-&gt;</operator><name>numAttributes</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>errmsg</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PGdataValue</name> <modifier>*</modifier></type><name>rowbuf</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>tupnfields</name></decl>;</decl_stmt>		<comment type="block">/* # fields from tuple */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>vlen</name></decl>;</decl_stmt>			<comment type="block">/* length of the current field value */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<comment type="block">/* Get the field count and make sure it's what we expect */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>pqGetInt</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tupnfields</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* We should not run out of data here, so complain */</comment>
		<expr_stmt><expr><name>errmsg</name> <operator>=</operator> <call><name>libpq_gettext</name><argument_list>(<argument><expr><literal type="string">"insufficient data in \"D\" message"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<goto>goto <name>advance_and_error</name>;</goto>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>tupnfields</name> <operator>!=</operator> <name>nfields</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>errmsg</name> <operator>=</operator> <call><name>libpq_gettext</name><argument_list>(<argument><expr><literal type="string">"unexpected field count in \"D\" message"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<goto>goto <name>advance_and_error</name>;</goto>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Resize row buffer if needed */</comment>
	<expr_stmt><expr><name>rowbuf</name> <operator>=</operator> <name><name>conn</name><operator>-&gt;</operator><name>rowBuf</name></name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>nfields</name> <operator>&gt;</operator> <name><name>conn</name><operator>-&gt;</operator><name>rowBufLen</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>rowbuf</name> <operator>=</operator> <operator>(</operator><name>PGdataValue</name> <operator>*</operator><operator>)</operator> <call><name>realloc</name><argument_list>(<argument><expr><name>rowbuf</name></expr></argument>,
										 <argument><expr><name>nfields</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>PGdataValue</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>rowbuf</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>errmsg</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>		<comment type="block">/* means "out of memory", see below */</comment>
			<goto>goto <name>advance_and_error</name>;</goto>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>rowBuf</name></name> <operator>=</operator> <name>rowbuf</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>rowBufLen</name></name> <operator>=</operator> <name>nfields</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Scan the fields */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nfields</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<comment type="block">/* get the value length */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>pqGetInt</name><argument_list>(<argument><expr><operator>&amp;</operator><name>vlen</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>, <argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* We should not run out of data here, so complain */</comment>
			<expr_stmt><expr><name>errmsg</name> <operator>=</operator> <call><name>libpq_gettext</name><argument_list>(<argument><expr><literal type="string">"insufficient data in \"D\" message"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<goto>goto <name>advance_and_error</name>;</goto>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><name><name>rowbuf</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>len</name> <operator>=</operator> <name>vlen</name></expr>;</expr_stmt>

		<comment type="block">/*
		 * rowbuf[i].value always points to the next address in the data
		 * buffer even if the value is NULL.  This allows row processors to
		 * estimate data sizes more easily.
		 */</comment>
		<expr_stmt><expr><name><name>rowbuf</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>value</name> <operator>=</operator> <name><name>conn</name><operator>-&gt;</operator><name>inBuffer</name></name> <operator>+</operator> <name><name>conn</name><operator>-&gt;</operator><name>inCursor</name></name></expr>;</expr_stmt>

		<comment type="block">/* Skip over the data value */</comment>
		<if_stmt><if>if <condition>(<expr><name>vlen</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><call><name>pqSkipnchar</name><argument_list>(<argument><expr><name>vlen</name></expr></argument>, <argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* We should not run out of data here, so complain */</comment>
				<expr_stmt><expr><name>errmsg</name> <operator>=</operator> <call><name>libpq_gettext</name><argument_list>(<argument><expr><literal type="string">"insufficient data in \"D\" message"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<goto>goto <name>advance_and_error</name>;</goto>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>

	<comment type="block">/* Sanity check that we absorbed all the data */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>inCursor</name></name> <operator>!=</operator> <name><name>conn</name><operator>-&gt;</operator><name>inStart</name></name> <operator>+</operator> <literal type="number">5</literal> <operator>+</operator> <name>msgLength</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>errmsg</name> <operator>=</operator> <call><name>libpq_gettext</name><argument_list>(<argument><expr><literal type="string">"extraneous data in \"D\" message"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<goto>goto <name>advance_and_error</name>;</goto>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Advance inStart to show that the "D" message has been processed. */</comment>
	<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>inStart</name></name> <operator>=</operator> <name><name>conn</name><operator>-&gt;</operator><name>inCursor</name></name></expr>;</expr_stmt>

	<comment type="block">/* Process the collected row */</comment>
	<expr_stmt><expr><name>errmsg</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>pqRowProcessor</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>errmsg</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>				<comment type="block">/* normal, successful exit */</comment>

	<goto>goto <name>set_error_result</name>;</goto>		<comment type="block">/* pqRowProcessor failed, report it */</comment>

<label><name>advance_and_error</name>:</label>
	<comment type="block">/* Discard the failed message by pretending we read it */</comment>
	<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>inStart</name></name> <operator>+=</operator> <literal type="number">5</literal> <operator>+</operator> <name>msgLength</name></expr>;</expr_stmt>

<label><name>set_error_result</name>:</label>

	<comment type="block">/*
	 * Replace partially constructed result with an error result. First
	 * discard the old result to try to win back some memory.
	 */</comment>
	<expr_stmt><expr><call><name>pqClearAsyncResult</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If preceding code didn't provide an error message, assume "out of
	 * memory" was meant.  The advantage of having this special case is that
	 * freeing the old result first greatly improves the odds that gettext()
	 * will succeed in providing a translation.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>errmsg</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>errmsg</name> <operator>=</operator> <call><name>libpq_gettext</name><argument_list>(<argument><expr><literal type="string">"out of memory for query result"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conn</name><operator>-&gt;</operator><name>errorMessage</name></name></expr></argument>, <argument><expr><literal type="string">"%s\n"</literal></expr></argument>, <argument><expr><name>errmsg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pqSaveErrorResult</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Return zero to allow input parsing to continue.  Subsequent "D"
	 * messages will be ignored until we get to end of data, since an error
	 * result is already set up.
	 */</comment>
	<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * Attempt to read an Error or Notice response message.
 * This is possible in several places, so we break it out as a subroutine.
 * Entry: 'E' or 'N' message type and length have already been consumed.
 * Exit: returns 0 if successfully consumed message.
 *		 returns EOF if not enough data.
 */</comment>
<function><type><name>int</name></type>
<name>pqGetErrorNotice3</name><parameter_list>(<parameter><decl><type><name>PGconn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>isError</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier></type><name>res</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>have_position</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PQExpBufferData</name></type> <name>workBuf</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name>id</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * If this is an error message, pre-emptively clear any incomplete query
	 * result we may have.  We'd just throw it away below anyway, and
	 * releasing it before collecting the error might avoid out-of-memory.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>isError</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>pqClearAsyncResult</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Since the fields might be pretty long, we create a temporary
	 * PQExpBuffer rather than using conn-&gt;workBuffer.  workBuffer is intended
	 * for stuff that is expected to be short.  We shouldn't use
	 * conn-&gt;errorMessage either, since this might be only a notice.
	 */</comment>
	<expr_stmt><expr><call><name>initPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>workBuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Make a PGresult to hold the accumulated fields.  We temporarily lie
	 * about the result status, so that PQmakeEmptyPGresult doesn't uselessly
	 * copy conn-&gt;errorMessage.
	 *
	 * NB: This allocation can fail, if you run out of memory. The rest of the
	 * function handles that gracefully, and we still try to set the error
	 * message as the connection's error message.
	 */</comment>
	<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>PQmakeEmptyPGresult</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>PGRES_EMPTY_QUERY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>res</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>res</name><operator>-&gt;</operator><name>resultStatus</name></name> <operator>=</operator> <ternary><condition><expr><name>isError</name></expr> ?</condition><then> <expr><name>PGRES_FATAL_ERROR</name></expr> </then><else>: <expr><name>PGRES_NONFATAL_ERROR</name></expr></else></ternary></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Read the fields and save into res.
	 *
	 * While at it, save the SQLSTATE in conn-&gt;last_sqlstate, and note whether
	 * we saw a PG_DIAG_STATEMENT_POSITION field.
	 */</comment>
	<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>pqGetc</name><argument_list>(<argument><expr><operator>&amp;</operator><name>id</name></expr></argument>, <argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<goto>goto <name>fail</name>;</goto></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name>id</name> <operator>==</operator> <literal type="char">'\0'</literal></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>				<comment type="block">/* terminator found */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>pqGets</name><argument_list>(<argument><expr><operator>&amp;</operator><name>workBuf</name></expr></argument>, <argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<goto>goto <name>fail</name>;</goto></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>pqSaveMessageField</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>id</name></expr></argument>, <argument><expr><name><name>workBuf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>id</name> <operator>==</operator> <name>PG_DIAG_SQLSTATE</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>strlcpy</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>last_sqlstate</name></name></expr></argument>, <argument><expr><name><name>workBuf</name><operator>.</operator><name>data</name></name></expr></argument>,
					<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>last_sqlstate</name></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><name>id</name> <operator>==</operator> <name>PG_DIAG_STATEMENT_POSITION</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>have_position</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></for>

	<comment type="block">/*
	 * Save the active query text, if any, into res as well; but only if we
	 * might need it for an error cursor display, which is only true if there
	 * is a PG_DIAG_STATEMENT_POSITION field.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>have_position</name> <operator>&amp;&amp;</operator> <name><name>conn</name><operator>-&gt;</operator><name>last_query</name></name> <operator>&amp;&amp;</operator> <name>res</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>res</name><operator>-&gt;</operator><name>errQuery</name></name> <operator>=</operator> <call><name>pqResultStrdup</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>last_query</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Now build the "overall" error message for PQresultErrorMessage.
	 */</comment>
	<expr_stmt><expr><call><name>resetPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>workBuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pqBuildErrorMessage3</name><argument_list>(<argument><expr><operator>&amp;</operator><name>workBuf</name></expr></argument>, <argument><expr><name>res</name></expr></argument>, <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>verbosity</name></name></expr></argument>, <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>show_context</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Either save error as current async result, or just emit the notice.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>isError</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>res</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>res</name><operator>-&gt;</operator><name>errMsg</name></name> <operator>=</operator> <call><name>pqResultStrdup</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name><name>workBuf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/* POLAR px: Transfer statistical messages on to the new result. */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>result</name></name> <operator>&amp;&amp;</operator>
		    <name><name>conn</name><operator>-&gt;</operator><name>result</name><operator>-&gt;</operator><name>pxstats</name></name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>pgPxStatCell</name>  <modifier>*</modifier></type><name>cell</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>pgPxStatCell</name>  <modifier>*</modifier></type><name>next</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>pgPxStatCell</name>  <modifier>*</modifier></type><name>prev</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

			<comment type="block">/* Copy messages (incidentally reversing the list). */</comment>
			<for>for <control>(<init><expr><name>cell</name> <operator>=</operator> <name><name>conn</name><operator>-&gt;</operator><name>result</name><operator>-&gt;</operator><name>pxstats</name></name></expr>;</init> <condition><expr><name>cell</name></expr>;</condition> <incr><expr><name>cell</name> <operator>=</operator> <name><name>cell</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>savePxStatMsg</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name><name>cell</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name><name>cell</name><operator>-&gt;</operator><name>len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>

			<comment type="block">/* Reverse the list again to restore newest-first ordering. */</comment>
			<for>for <control>(<init><expr><name>cell</name> <operator>=</operator> <name><name>res</name><operator>-&gt;</operator><name>pxstats</name></name></expr>;</init> <condition><expr><name>cell</name></expr>;</condition> <incr><expr><name>cell</name> <operator>=</operator> <name>next</name></expr></incr>)</control>
			<block>{<block_content>
				<expr_stmt><expr><name>next</name> <operator>=</operator> <name><name>cell</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>cell</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name>prev</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>prev</name> <operator>=</operator> <name>cell</name></expr>;</expr_stmt>
			</block_content>}</block></for>
			<expr_stmt><expr><name><name>res</name><operator>-&gt;</operator><name>pxstats</name></name> <operator>=</operator> <name>prev</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>pqClearAsyncResult</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>	<comment type="block">/* redundant, but be safe */</comment>
		<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>result</name></name> <operator>=</operator> <name>res</name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>PQExpBufferDataBroken</name><argument_list>(<argument><expr><name>workBuf</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conn</name><operator>-&gt;</operator><name>errorMessage</name></name></expr></argument>,
							  <argument><expr><call><name>libpq_gettext</name><argument_list>(<argument><expr><literal type="string">"out of memory"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conn</name><operator>-&gt;</operator><name>errorMessage</name></name></expr></argument>, <argument><expr><name><name>workBuf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* if we couldn't allocate the result set, just discard the NOTICE */</comment>
		<if_stmt><if>if <condition>(<expr><name>res</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* We can cheat a little here and not copy the message. */</comment>
			<expr_stmt><expr><name><name>res</name><operator>-&gt;</operator><name>errMsg</name></name> <operator>=</operator> <name><name>workBuf</name><operator>.</operator><name>data</name></name></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>res</name><operator>-&gt;</operator><name>noticeHooks</name><operator>.</operator><name>noticeRec</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name><name>res</name><operator>-&gt;</operator><name>noticeHooks</name><operator>.</operator><name>noticeRec</name></name><argument_list>(<argument><expr><name><name>res</name><operator>-&gt;</operator><name>noticeHooks</name><operator>.</operator><name>noticeRecArg</name></name></expr></argument>, <argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><call><name>termPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>workBuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><literal type="number">0</literal></expr>;</return>

<label><name>fail</name>:</label>
	<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>termPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>workBuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>EOF</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Construct an error message from the fields in the given PGresult,
 * appending it to the contents of "msg".
 */</comment>
<function><type><name>void</name></type>
<name>pqBuildErrorMessage3</name><parameter_list>(<parameter><decl><type><name>PQExpBuffer</name></type> <name>msg</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>PGresult</name> <modifier>*</modifier></type><name>res</name></decl></parameter>,
					 <parameter><decl><type><name>PGVerbosity</name></type> <name>verbosity</name></decl></parameter>, <parameter><decl><type><name>PGContextVisibility</name></type> <name>show_context</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>val</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>querytext</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>querypos</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<comment type="block">/* If we couldn't allocate a PGresult, just say "out of memory" */</comment>
	<if_stmt><if>if <condition>(<expr><name>res</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>msg</name></expr></argument>, <argument><expr><call><name>libpq_gettext</name><argument_list>(<argument><expr><literal type="string">"out of memory\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * If we don't have any broken-down fields, just return the base message.
	 * This mainly applies if we're given a libpq-generated error result.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>res</name><operator>-&gt;</operator><name>errFields</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>res</name><operator>-&gt;</operator><name>errMsg</name></name> <operator>&amp;&amp;</operator> <name><name>res</name><operator>-&gt;</operator><name>errMsg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>msg</name></expr></argument>, <argument><expr><name><name>res</name><operator>-&gt;</operator><name>errMsg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>msg</name></expr></argument>, <argument><expr><call><name>libpq_gettext</name><argument_list>(<argument><expr><literal type="string">"no error message available\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Else build error message from relevant fields */</comment>
	<expr_stmt><expr><name>val</name> <operator>=</operator> <call><name>PQresultErrorField</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>PG_DIAG_SEVERITY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>val</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>msg</name></expr></argument>, <argument><expr><literal type="string">"%s:  "</literal></expr></argument>, <argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>verbosity</name> <operator>==</operator> <name>PQERRORS_VERBOSE</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>val</name> <operator>=</operator> <call><name>PQresultErrorField</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>PG_DIAG_SQLSTATE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>val</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>msg</name></expr></argument>, <argument><expr><literal type="string">"%s: "</literal></expr></argument>, <argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name>val</name> <operator>=</operator> <call><name>PQresultErrorField</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>PG_DIAG_MESSAGE_PRIMARY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>val</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>msg</name></expr></argument>, <argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>val</name> <operator>=</operator> <call><name>PQresultErrorField</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>PG_DIAG_STATEMENT_POSITION</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>val</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>verbosity</name> <operator>!=</operator> <name>PQERRORS_TERSE</name> <operator>&amp;&amp;</operator> <name><name>res</name><operator>-&gt;</operator><name>errQuery</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* emit position as a syntax cursor display */</comment>
			<expr_stmt><expr><name>querytext</name> <operator>=</operator> <name><name>res</name><operator>-&gt;</operator><name>errQuery</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name>querypos</name> <operator>=</operator> <call><name>atoi</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/* emit position as text addition to primary message */</comment>
			<comment type="block">/* translator: %s represents a digit string */</comment>
			<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>msg</name></expr></argument>, <argument><expr><call><name>libpq_gettext</name><argument_list>(<argument><expr><literal type="string">" at character %s"</literal></expr></argument>)</argument_list></call></expr></argument>,
							  <argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name>val</name> <operator>=</operator> <call><name>PQresultErrorField</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>PG_DIAG_INTERNAL_POSITION</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>val</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>querytext</name> <operator>=</operator> <call><name>PQresultErrorField</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>PG_DIAG_INTERNAL_QUERY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>verbosity</name> <operator>!=</operator> <name>PQERRORS_TERSE</name> <operator>&amp;&amp;</operator> <name>querytext</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* emit position as a syntax cursor display */</comment>
				<expr_stmt><expr><name>querypos</name> <operator>=</operator> <call><name>atoi</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<comment type="block">/* emit position as text addition to primary message */</comment>
				<comment type="block">/* translator: %s represents a digit string */</comment>
				<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>msg</name></expr></argument>, <argument><expr><call><name>libpq_gettext</name><argument_list>(<argument><expr><literal type="string">" at character %s"</literal></expr></argument>)</argument_list></call></expr></argument>,
								  <argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></else></if_stmt>
	<expr_stmt><expr><call><name>appendPQExpBufferChar</name><argument_list>(<argument><expr><name>msg</name></expr></argument>, <argument><expr><literal type="char">'\n'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>verbosity</name> <operator>!=</operator> <name>PQERRORS_TERSE</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>querytext</name> <operator>&amp;&amp;</operator> <name>querypos</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>reportErrorPosition</name><argument_list>(<argument><expr><name>msg</name></expr></argument>, <argument><expr><name>querytext</name></expr></argument>, <argument><expr><name>querypos</name></expr></argument>,
								<argument><expr><name><name>res</name><operator>-&gt;</operator><name>client_encoding</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>val</name> <operator>=</operator> <call><name>PQresultErrorField</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>PG_DIAG_MESSAGE_DETAIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>val</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>msg</name></expr></argument>, <argument><expr><call><name>libpq_gettext</name><argument_list>(<argument><expr><literal type="string">"DETAIL:  %s\n"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>val</name> <operator>=</operator> <call><name>PQresultErrorField</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>PG_DIAG_MESSAGE_HINT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>val</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>msg</name></expr></argument>, <argument><expr><call><name>libpq_gettext</name><argument_list>(<argument><expr><literal type="string">"HINT:  %s\n"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>val</name> <operator>=</operator> <call><name>PQresultErrorField</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>PG_DIAG_INTERNAL_QUERY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>val</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>msg</name></expr></argument>, <argument><expr><call><name>libpq_gettext</name><argument_list>(<argument><expr><literal type="string">"QUERY:  %s\n"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name>show_context</name> <operator>==</operator> <name>PQSHOW_CONTEXT_ALWAYS</name> <operator>||</operator>
			<operator>(</operator><name>show_context</name> <operator>==</operator> <name>PQSHOW_CONTEXT_ERRORS</name> <operator>&amp;&amp;</operator>
			 <name><name>res</name><operator>-&gt;</operator><name>resultStatus</name></name> <operator>==</operator> <name>PGRES_FATAL_ERROR</name><operator>)</operator></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>val</name> <operator>=</operator> <call><name>PQresultErrorField</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>PG_DIAG_CONTEXT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>val</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>msg</name></expr></argument>, <argument><expr><call><name>libpq_gettext</name><argument_list>(<argument><expr><literal type="string">"CONTEXT:  %s\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
								  <argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>verbosity</name> <operator>==</operator> <name>PQERRORS_VERBOSE</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>val</name> <operator>=</operator> <call><name>PQresultErrorField</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>PG_DIAG_SCHEMA_NAME</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>val</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>msg</name></expr></argument>,
							  <argument><expr><call><name>libpq_gettext</name><argument_list>(<argument><expr><literal type="string">"SCHEMA NAME:  %s\n"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>val</name> <operator>=</operator> <call><name>PQresultErrorField</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>PG_DIAG_TABLE_NAME</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>val</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>msg</name></expr></argument>,
							  <argument><expr><call><name>libpq_gettext</name><argument_list>(<argument><expr><literal type="string">"TABLE NAME:  %s\n"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>val</name> <operator>=</operator> <call><name>PQresultErrorField</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>PG_DIAG_COLUMN_NAME</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>val</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>msg</name></expr></argument>,
							  <argument><expr><call><name>libpq_gettext</name><argument_list>(<argument><expr><literal type="string">"COLUMN NAME:  %s\n"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>val</name> <operator>=</operator> <call><name>PQresultErrorField</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>PG_DIAG_DATATYPE_NAME</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>val</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>msg</name></expr></argument>,
							  <argument><expr><call><name>libpq_gettext</name><argument_list>(<argument><expr><literal type="string">"DATATYPE NAME:  %s\n"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>val</name> <operator>=</operator> <call><name>PQresultErrorField</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>PG_DIAG_CONSTRAINT_NAME</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>val</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>msg</name></expr></argument>,
							  <argument><expr><call><name>libpq_gettext</name><argument_list>(<argument><expr><literal type="string">"CONSTRAINT NAME:  %s\n"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>verbosity</name> <operator>==</operator> <name>PQERRORS_VERBOSE</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>valf</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>vall</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>valf</name> <operator>=</operator> <call><name>PQresultErrorField</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>PG_DIAG_SOURCE_FILE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>vall</name> <operator>=</operator> <call><name>PQresultErrorField</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>PG_DIAG_SOURCE_LINE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>val</name> <operator>=</operator> <call><name>PQresultErrorField</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>PG_DIAG_SOURCE_FUNCTION</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>val</name> <operator>||</operator> <name>valf</name> <operator>||</operator> <name>vall</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>msg</name></expr></argument>, <argument><expr><call><name>libpq_gettext</name><argument_list>(<argument><expr><literal type="string">"LOCATION:  "</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>val</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>msg</name></expr></argument>, <argument><expr><call><name>libpq_gettext</name><argument_list>(<argument><expr><literal type="string">"%s, "</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><name>valf</name> <operator>&amp;&amp;</operator> <name>vall</name></expr>)</condition><block type="pseudo"><block_content>	<comment type="block">/* unlikely we'd have just one */</comment>
				<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>msg</name></expr></argument>, <argument><expr><call><name>libpq_gettext</name><argument_list>(<argument><expr><literal type="string">"%s:%s"</literal></expr></argument>)</argument_list></call></expr></argument>,
								  <argument><expr><name>valf</name></expr></argument>, <argument><expr><name>vall</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><call><name>appendPQExpBufferChar</name><argument_list>(<argument><expr><name>msg</name></expr></argument>, <argument><expr><literal type="char">'\n'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Add an error-location display to the error message under construction.
 *
 * The cursor location is measured in logical characters; the query string
 * is presumed to be in the specified encoding.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>reportErrorPosition</name><parameter_list>(<parameter><decl><type><name>PQExpBuffer</name></type> <name>msg</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>query</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>loc</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>encoding</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DISPLAY_SIZE</name></cpp:macro>	<cpp:value>60</cpp:value></cpp:define>		<comment type="block">/* screen width limit, in screen cols */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MIN_RIGHT_CUT</name></cpp:macro>	<cpp:value>10</cpp:value></cpp:define>		<comment type="block">/* try to keep this far away from EOL */</comment>

	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>wquery</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>slen</name></decl>,
				<decl><type ref="prev"/><name>cno</name></decl>,
				<decl><type ref="prev"/><name>i</name></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name>qidx</name></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name>scridx</name></decl>,
				<decl><type ref="prev"/><name>qoffset</name></decl>,
				<decl><type ref="prev"/><name>scroffset</name></decl>,
				<decl><type ref="prev"/><name>ibeg</name></decl>,
				<decl><type ref="prev"/><name>iend</name></decl>,
				<decl><type ref="prev"/><name>loc_line</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>mb_encoding</name></decl>,
				<decl><type ref="prev"/><name>beg_trunc</name></decl>,
				<decl><type ref="prev"/><name>end_trunc</name></decl>;</decl_stmt>

	<comment type="block">/* Convert loc from 1-based to 0-based; no-op if out of range */</comment>
	<expr_stmt><expr><name>loc</name><operator>--</operator></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>loc</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/* Need a writable copy of the query */</comment>
	<expr_stmt><expr><name>wquery</name> <operator>=</operator> <call><name>strdup</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>wquery</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>					<comment type="block">/* fail silently if out of memory */</comment>

	<comment type="block">/*
	 * Each character might occupy multiple physical bytes in the string, and
	 * in some Far Eastern character sets it might take more than one screen
	 * column as well.  We compute the starting byte offset and starting
	 * screen column of each logical character, and store these in qidx[] and
	 * scridx[] respectively.
	 */</comment>

	<comment type="block">/* we need a safe allocation size... */</comment>
	<expr_stmt><expr><name>slen</name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>wquery</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>

	<expr_stmt><expr><name>qidx</name> <operator>=</operator> <operator>(</operator><name>int</name> <operator>*</operator><operator>)</operator> <call><name>malloc</name><argument_list>(<argument><expr><name>slen</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>qidx</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>wquery</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name>scridx</name> <operator>=</operator> <operator>(</operator><name>int</name> <operator>*</operator><operator>)</operator> <call><name>malloc</name><argument_list>(<argument><expr><name>slen</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>scridx</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>qidx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>wquery</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* We can optimize a bit if it's a single-byte encoding */</comment>
	<expr_stmt><expr><name>mb_encoding</name> <operator>=</operator> <operator>(</operator><call><name>pg_encoding_max_length</name><argument_list>(<argument><expr><name>encoding</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>

	<comment type="block">/*
	 * Within the scanning loop, cno is the current character's logical
	 * number, qoffset is its offset in wquery, and scroffset is its starting
	 * logical screen column (all indexed from 0).  "loc" is the logical
	 * character number of the error location.  We scan to determine loc_line
	 * (the 1-based line number containing loc) and ibeg/iend (first character
	 * number and last+1 character number of the line containing loc). Note
	 * that qidx[] and scridx[] are filled only as far as iend.
	 */</comment>
	<expr_stmt><expr><name>qoffset</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>scroffset</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>loc_line</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>ibeg</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>iend</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>					<comment type="block">/* -1 means not set yet */</comment>

	<for>for <control>(<init><expr><name>cno</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name><name>wquery</name><index>[<expr><name>qoffset</name></expr>]</index></name> <operator>!=</operator> <literal type="char">'\0'</literal></expr>;</condition> <incr><expr><name>cno</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name></type>		<name>ch</name> <init>= <expr><name><name>wquery</name><index>[<expr><name>qoffset</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>qidx</name><index>[<expr><name>cno</name></expr>]</index></name> <operator>=</operator> <name>qoffset</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>scridx</name><index>[<expr><name>cno</name></expr>]</index></name> <operator>=</operator> <name>scroffset</name></expr>;</expr_stmt>

		<comment type="block">/*
		 * Replace tabs with spaces in the writable copy.  (Later we might
		 * want to think about coping with their variable screen width, but
		 * not today.)
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>ch</name> <operator>==</operator> <literal type="char">'\t'</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>wquery</name><index>[<expr><name>qoffset</name></expr>]</index></name> <operator>=</operator> <literal type="char">' '</literal></expr>;</expr_stmt></block_content></block></if>

		<comment type="block">/*
		 * If end-of-line, count lines and mark positions. Each \r or \n
		 * counts as a line except when \r \n appear together.
		 */</comment>
		<if type="elseif">else if <condition>(<expr><name>ch</name> <operator>==</operator> <literal type="char">'\r'</literal> <operator>||</operator> <name>ch</name> <operator>==</operator> <literal type="char">'\n'</literal></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>cno</name> <operator>&lt;</operator> <name>loc</name></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name>ch</name> <operator>==</operator> <literal type="char">'\r'</literal> <operator>||</operator>
					<name>cno</name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
					<name><name>wquery</name><index>[<expr><name><name>qidx</name><index>[<expr><name>cno</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>]</index></name> <operator>!=</operator> <literal type="char">'\r'</literal></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>loc_line</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<comment type="block">/* extract beginning = last line start before loc. */</comment>
				<expr_stmt><expr><name>ibeg</name> <operator>=</operator> <name>cno</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<comment type="block">/* set extract end. */</comment>
				<expr_stmt><expr><name>iend</name> <operator>=</operator> <name>cno</name></expr>;</expr_stmt>
				<comment type="block">/* done scanning. */</comment>
				<break>break;</break>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* Advance */</comment>
		<if_stmt><if>if <condition>(<expr><name>mb_encoding</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>int</name></type>			<name>w</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>w</name> <operator>=</operator> <call><name>pg_encoding_dsplen</name><argument_list>(<argument><expr><name>encoding</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>wquery</name><index>[<expr><name>qoffset</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* treat any non-tab control chars as width 1 */</comment>
			<if_stmt><if>if <condition>(<expr><name>w</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>w</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><name>scroffset</name> <operator>+=</operator> <name>w</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>qoffset</name> <operator>+=</operator> <call><name>pg_encoding_mblen</name><argument_list>(<argument><expr><name>encoding</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>wquery</name><index>[<expr><name>qoffset</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/* We assume wide chars only exist in multibyte encodings */</comment>
			<expr_stmt><expr><name>scroffset</name><operator>++</operator></expr>;</expr_stmt>
			<expr_stmt><expr><name>qoffset</name><operator>++</operator></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></for>
	<comment type="block">/* Fix up if we didn't find an end-of-line after loc */</comment>
	<if_stmt><if>if <condition>(<expr><name>iend</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>iend</name> <operator>=</operator> <name>cno</name></expr>;</expr_stmt>				<comment type="block">/* query length in chars, +1 */</comment>
		<expr_stmt><expr><name><name>qidx</name><index>[<expr><name>iend</name></expr>]</index></name> <operator>=</operator> <name>qoffset</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>scridx</name><index>[<expr><name>iend</name></expr>]</index></name> <operator>=</operator> <name>scroffset</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Print only if loc is within computed query length */</comment>
	<if_stmt><if>if <condition>(<expr><name>loc</name> <operator>&lt;=</operator> <name>cno</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* If the line extracted is too long, we truncate it. */</comment>
		<expr_stmt><expr><name>beg_trunc</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>end_trunc</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>scridx</name><index>[<expr><name>iend</name></expr>]</index></name> <operator>-</operator> <name><name>scridx</name><index>[<expr><name>ibeg</name></expr>]</index></name> <operator>&gt;</operator> <name>DISPLAY_SIZE</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * We first truncate right if it is enough.  This code might be
			 * off a space or so on enforcing MIN_RIGHT_CUT if there's a wide
			 * character right there, but that should be okay.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>scridx</name><index>[<expr><name>ibeg</name></expr>]</index></name> <operator>+</operator> <name>DISPLAY_SIZE</name> <operator>&gt;=</operator> <name><name>scridx</name><index>[<expr><name>loc</name></expr>]</index></name> <operator>+</operator> <name>MIN_RIGHT_CUT</name></expr>)</condition>
			<block>{<block_content>
				<while>while <condition>(<expr><name><name>scridx</name><index>[<expr><name>iend</name></expr>]</index></name> <operator>-</operator> <name><name>scridx</name><index>[<expr><name>ibeg</name></expr>]</index></name> <operator>&gt;</operator> <name>DISPLAY_SIZE</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>iend</name><operator>--</operator></expr>;</expr_stmt></block_content></block></while>
				<expr_stmt><expr><name>end_trunc</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<comment type="block">/* Truncate right if not too close to loc. */</comment>
				<while>while <condition>(<expr><name><name>scridx</name><index>[<expr><name>loc</name></expr>]</index></name> <operator>+</operator> <name>MIN_RIGHT_CUT</name> <operator>&lt;</operator> <name><name>scridx</name><index>[<expr><name>iend</name></expr>]</index></name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name>iend</name><operator>--</operator></expr>;</expr_stmt>
					<expr_stmt><expr><name>end_trunc</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				</block_content>}</block></while>

				<comment type="block">/* Truncate left if still too long. */</comment>
				<while>while <condition>(<expr><name><name>scridx</name><index>[<expr><name>iend</name></expr>]</index></name> <operator>-</operator> <name><name>scridx</name><index>[<expr><name>ibeg</name></expr>]</index></name> <operator>&gt;</operator> <name>DISPLAY_SIZE</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name>ibeg</name><operator>++</operator></expr>;</expr_stmt>
					<expr_stmt><expr><name>beg_trunc</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				</block_content>}</block></while>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* truncate working copy at desired endpoint */</comment>
		<expr_stmt><expr><name><name>wquery</name><index>[<expr><name><name>qidx</name><index>[<expr><name>iend</name></expr>]</index></name></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>

		<comment type="block">/* Begin building the finished message. */</comment>
		<expr_stmt><expr><name>i</name> <operator>=</operator> <name><name>msg</name><operator>-&gt;</operator><name>len</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>msg</name></expr></argument>, <argument><expr><call><name>libpq_gettext</name><argument_list>(<argument><expr><literal type="string">"LINE %d: "</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>loc_line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>beg_trunc</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>msg</name></expr></argument>, <argument><expr><literal type="string">"..."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * While we have the prefix in the msg buffer, compute its screen
		 * width.
		 */</comment>
		<expr_stmt><expr><name>scroffset</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<for>for <control>(<init>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>msg</name><operator>-&gt;</operator><name>len</name></name></expr>;</condition> <incr><expr><name>i</name> <operator>+=</operator> <call><name>pg_encoding_mblen</name><argument_list>(<argument><expr><name>encoding</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>msg</name><operator>-&gt;</operator><name>data</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>int</name></type>			<name>w</name> <init>= <expr><call><name>pg_encoding_dsplen</name><argument_list>(<argument><expr><name>encoding</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>msg</name><operator>-&gt;</operator><name>data</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name>w</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>w</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><name>scroffset</name> <operator>+=</operator> <name>w</name></expr>;</expr_stmt>
		</block_content>}</block></for>

		<comment type="block">/* Finish up the LINE message line. */</comment>
		<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>msg</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>wquery</name><index>[<expr><name><name>qidx</name><index>[<expr><name>ibeg</name></expr>]</index></name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>end_trunc</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>msg</name></expr></argument>, <argument><expr><literal type="string">"..."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>appendPQExpBufferChar</name><argument_list>(<argument><expr><name>msg</name></expr></argument>, <argument><expr><literal type="char">'\n'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Now emit the cursor marker line. */</comment>
		<expr_stmt><expr><name>scroffset</name> <operator>+=</operator> <name><name>scridx</name><index>[<expr><name>loc</name></expr>]</index></name> <operator>-</operator> <name><name>scridx</name><index>[<expr><name>ibeg</name></expr>]</index></name></expr>;</expr_stmt>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>scroffset</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendPQExpBufferChar</name><argument_list>(<argument><expr><name>msg</name></expr></argument>, <argument><expr><literal type="char">' '</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
		<expr_stmt><expr><call><name>appendPQExpBufferChar</name><argument_list>(<argument><expr><name>msg</name></expr></argument>, <argument><expr><literal type="char">'^'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>appendPQExpBufferChar</name><argument_list>(<argument><expr><name>msg</name></expr></argument>, <argument><expr><literal type="char">'\n'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Clean up. */</comment>
	<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>scridx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>qidx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>wquery</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * Attempt to read a ParameterStatus message.
 * This is possible in several places, so we break it out as a subroutine.
 * Entry: 'S' message type and length have already been consumed.
 * Exit: returns 0 if successfully consumed message.
 *		 returns EOF if not enough data.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>getParameterStatus</name><parameter_list>(<parameter><decl><type><name>PGconn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PQExpBufferData</name></type> <name>valueBuf</name></decl>;</decl_stmt>

	<comment type="block">/* Get the parameter name */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>pqGets</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conn</name><operator>-&gt;</operator><name>workBuffer</name></name></expr></argument>, <argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>EOF</name></expr>;</return></block_content></block></if></if_stmt>
	<comment type="block">/* Get the parameter value (could be large) */</comment>
	<expr_stmt><expr><call><name>initPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>valueBuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>pqGets</name><argument_list>(<argument><expr><operator>&amp;</operator><name>valueBuf</name></expr></argument>, <argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>termPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>valueBuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>EOF</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* And save it */</comment>
	<expr_stmt><expr><call><name>pqSaveParameterStatus</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>workBuffer</name><operator>.</operator><name>data</name></name></expr></argument>, <argument><expr><name><name>valueBuf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>termPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>valueBuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * Attempt to read a Notify response message.
 * This is possible in several places, so we break it out as a subroutine.
 * Entry: 'A' message type and length have already been consumed.
 * Exit: returns 0 if successfully consumed Notify message.
 *		 returns EOF if not enough data.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>getNotify</name><parameter_list>(<parameter><decl><type><name>PGconn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>be_pid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>svname</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>nmlen</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>extralen</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PGnotify</name>   <modifier>*</modifier></type><name>newNotify</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>pqGetInt</name><argument_list>(<argument><expr><operator>&amp;</operator><name>be_pid</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>, <argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>EOF</name></expr>;</return></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>pqGets</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conn</name><operator>-&gt;</operator><name>workBuffer</name></name></expr></argument>, <argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>EOF</name></expr>;</return></block_content></block></if></if_stmt>
	<comment type="block">/* must save name while getting extra string */</comment>
	<expr_stmt><expr><name>svname</name> <operator>=</operator> <call><name>strdup</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>workBuffer</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>svname</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>EOF</name></expr>;</return></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>pqGets</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conn</name><operator>-&gt;</operator><name>workBuffer</name></name></expr></argument>, <argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>svname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>EOF</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Store the strings right after the PQnotify structure so it can all be
	 * freed at once.  We don't use NAMEDATALEN because we don't want to tie
	 * this interface to a specific server name length.
	 */</comment>
	<expr_stmt><expr><name>nmlen</name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>svname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>extralen</name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>workBuffer</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>newNotify</name> <operator>=</operator> <operator>(</operator><name>PGnotify</name> <operator>*</operator><operator>)</operator> <call><name>malloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>PGnotify</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <name>nmlen</name> <operator>+</operator> <name>extralen</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>newNotify</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>newNotify</name><operator>-&gt;</operator><name>relname</name></name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>newNotify</name> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>PGnotify</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name><name>newNotify</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>, <argument><expr><name>svname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>newNotify</name><operator>-&gt;</operator><name>extra</name></name> <operator>=</operator> <name><name>newNotify</name><operator>-&gt;</operator><name>relname</name></name> <operator>+</operator> <name>nmlen</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name><name>newNotify</name><operator>-&gt;</operator><name>extra</name></name></expr></argument>, <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>workBuffer</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>newNotify</name><operator>-&gt;</operator><name>be_pid</name></name> <operator>=</operator> <name>be_pid</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>newNotify</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>notifyTail</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>notifyTail</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name>newNotify</name></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>notifyHead</name></name> <operator>=</operator> <name>newNotify</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
		<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>notifyTail</name></name> <operator>=</operator> <name>newNotify</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>svname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * getCopyStart - process CopyInResponse, CopyOutResponse or
 * CopyBothResponse message
 *
 * parseInput already read the message type and length.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>getCopyStart</name><parameter_list>(<parameter><decl><type><name>PGconn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>, <parameter><decl><type><name>ExecStatusType</name></type> <name>copytype</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>nfields</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>PQmakeEmptyPGresult</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>copytype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>result</name></expr>)</condition><block type="pseudo"><block_content>
		<goto>goto <name>failure</name>;</goto></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>pqGetc</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conn</name><operator>-&gt;</operator><name>copy_is_binary</name></name></expr></argument>, <argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<goto>goto <name>failure</name>;</goto></block_content></block></if></if_stmt>
	<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>binary</name></name> <operator>=</operator> <name><name>conn</name><operator>-&gt;</operator><name>copy_is_binary</name></name></expr>;</expr_stmt>
	<comment type="block">/* the next two bytes are the number of fields	*/</comment>
	<if_stmt><if>if <condition>(<expr><call><name>pqGetInt</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>result</name><operator>-&gt;</operator><name>numAttributes</name></name><operator>)</operator></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<goto>goto <name>failure</name>;</goto></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>nfields</name> <operator>=</operator> <name><name>result</name><operator>-&gt;</operator><name>numAttributes</name></name></expr>;</expr_stmt>

	<comment type="block">/* allocate space for the attribute descriptors */</comment>
	<if_stmt><if>if <condition>(<expr><name>nfields</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>attDescs</name></name> <operator>=</operator> <operator>(</operator><name>PGresAttDesc</name> <operator>*</operator><operator>)</operator>
			<call><name>pqResultAlloc</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>nfields</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>PGresAttDesc</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>result</name><operator>-&gt;</operator><name>attDescs</name></name></expr>)</condition><block type="pseudo"><block_content>
			<goto>goto <name>failure</name>;</goto></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><name><name>result</name><operator>-&gt;</operator><name>attDescs</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>nfields</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>PGresAttDesc</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nfields</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>format</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>pqGetInt</name><argument_list>(<argument><expr><operator>&amp;</operator><name>format</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<goto>goto <name>failure</name>;</goto></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * Since pqGetInt treats 2-byte integers as unsigned, we need to
		 * coerce these results to signed form.
		 */</comment>
		<expr_stmt><expr><name>format</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator> <operator>(</operator><operator>(</operator><name>int16</name><operator>)</operator> <name>format</name><operator>)</operator></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>attDescs</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>format</name> <operator>=</operator> <name>format</name></expr>;</expr_stmt>
	</block_content>}</block></for>

	<comment type="block">/* Success! */</comment>
	<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>result</name></name> <operator>=</operator> <name>result</name></expr>;</expr_stmt>
	<return>return <expr><literal type="number">0</literal></expr>;</return>

<label><name>failure</name>:</label>
	<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>EOF</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * getReadyForQuery - process ReadyForQuery message
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>getReadyForQuery</name><parameter_list>(<parameter><decl><type><name>PGconn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name></type>		<name>xact_status</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>pqGetc</name><argument_list>(<argument><expr><operator>&amp;</operator><name>xact_status</name></expr></argument>, <argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>EOF</name></expr>;</return></block_content></block></if></if_stmt>
	<switch>switch <condition>(<expr><name>xact_status</name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><literal type="char">'I'</literal></expr>:</case>
			<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>xactStatus</name></name> <operator>=</operator> <name>PQTRANS_IDLE</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><literal type="char">'T'</literal></expr>:</case>
			<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>xactStatus</name></name> <operator>=</operator> <name>PQTRANS_INTRANS</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><literal type="char">'E'</literal></expr>:</case>
			<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>xactStatus</name></name> <operator>=</operator> <name>PQTRANS_INERROR</name></expr>;</expr_stmt>
			<break>break;</break>
		<default>default:</default>
			<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>xactStatus</name></name> <operator>=</operator> <name>PQTRANS_UNKNOWN</name></expr>;</expr_stmt>
			<break>break;</break>
	</block_content>}</block></switch>

	<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * getCopyDataMessage - fetch next CopyData message, process async messages
 *
 * Returns length word of CopyData message (&gt; 0), or 0 if no complete
 * message available, -1 if end of copy, -2 if error.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>getCopyDataMessage</name><parameter_list>(<parameter><decl><type><name>PGconn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name></type>		<name>id</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>msgLength</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>avail</name></decl>;</decl_stmt>

	<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
	<block>{<block_content>
		<comment type="block">/*
		 * Do we have the next input message?  To make life simpler for async
		 * callers, we keep returning 0 until the next message is fully
		 * available, even if it is not Copy Data.
		 */</comment>
		<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>inCursor</name></name> <operator>=</operator> <name><name>conn</name><operator>-&gt;</operator><name>inStart</name></name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>pqGetc</name><argument_list>(<argument><expr><operator>&amp;</operator><name>id</name></expr></argument>, <argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>pqGetInt</name><argument_list>(<argument><expr><operator>&amp;</operator><name>msgLength</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>, <argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name>msgLength</name> <operator>&lt;</operator> <literal type="number">4</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>handleSyncLoss</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>id</name></expr></argument>, <argument><expr><name>msgLength</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><operator>-</operator><literal type="number">2</literal></expr>;</return>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><name>avail</name> <operator>=</operator> <name><name>conn</name><operator>-&gt;</operator><name>inEnd</name></name> <operator>-</operator> <name><name>conn</name><operator>-&gt;</operator><name>inCursor</name></name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>avail</name> <operator>&lt;</operator> <name>msgLength</name> <operator>-</operator> <literal type="number">4</literal></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * Before returning, enlarge the input buffer if needed to hold
			 * the whole message.  See notes in parseInput.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>pqCheckInBufferSpace</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>inCursor</name></name> <operator>+</operator> <operator>(</operator><name>size_t</name><operator>)</operator> <name>msgLength</name> <operator>-</operator> <literal type="number">4</literal></expr></argument>,
									 <argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/*
				 * XXX add some better recovery code... plan is to skip over
				 * the message using its length, then report an error. For the
				 * moment, just treat this like loss of sync (which indeed it
				 * might be!)
				 */</comment>
				<expr_stmt><expr><call><name>handleSyncLoss</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>id</name></expr></argument>, <argument><expr><name>msgLength</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr><operator>-</operator><literal type="number">2</literal></expr>;</return>
			</block_content>}</block></if></if_stmt>
			<return>return <expr><literal type="number">0</literal></expr>;</return>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * If it's a legitimate async message type, process it.  (NOTIFY
		 * messages are not currently possible here, but we handle them for
		 * completeness.)  Otherwise, if it's anything except Copy Data,
		 * report end-of-copy.
		 */</comment>
		<switch>switch <condition>(<expr><name>id</name></expr>)</condition>
		<block>{<block_content>
			<case>case <expr><literal type="char">'A'</literal></expr>:</case>			<comment type="block">/* NOTIFY */</comment>
				<if_stmt><if>if <condition>(<expr><call><name>getNotify</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
				<break>break;</break>
			<case>case <expr><literal type="char">'N'</literal></expr>:</case>			<comment type="block">/* NOTICE */</comment>
				<if_stmt><if>if <condition>(<expr><call><name>pqGetErrorNotice3</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
				<break>break;</break>
			<case>case <expr><literal type="char">'S'</literal></expr>:</case>			<comment type="block">/* ParameterStatus */</comment>
				<if_stmt><if>if <condition>(<expr><call><name>getParameterStatus</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
				<break>break;</break>
			<case>case <expr><literal type="char">'d'</literal></expr>:</case>			<comment type="block">/* Copy Data, pass it back to caller */</comment>
				<return>return <expr><name>msgLength</name></expr>;</return>
			<case>case <expr><literal type="char">'c'</literal></expr>:</case>

				<comment type="block">/*
				 * If this is a CopyDone message, exit COPY_OUT mode and let
				 * caller read status with PQgetResult().  If we're in
				 * COPY_BOTH mode, return to COPY_IN mode.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>asyncStatus</name></name> <operator>==</operator> <name>PGASYNC_COPY_BOTH</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>asyncStatus</name></name> <operator>=</operator> <name>PGASYNC_COPY_IN</name></expr>;</expr_stmt></block_content></block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>asyncStatus</name></name> <operator>=</operator> <name>PGASYNC_BUSY</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
				<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
			<default>default:</default>			<comment type="block">/* treat as end of copy */</comment>

				<comment type="block">/*
				 * Any other message terminates either COPY_IN or COPY_BOTH
				 * mode.
				 */</comment>
				<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>asyncStatus</name></name> <operator>=</operator> <name>PGASYNC_BUSY</name></expr>;</expr_stmt>
				<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
		</block_content>}</block></switch>

		<comment type="block">/* Drop the processed message and loop around for another */</comment>
		<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>inStart</name></name> <operator>=</operator> <name><name>conn</name><operator>-&gt;</operator><name>inCursor</name></name></expr>;</expr_stmt>
	</block_content>}</block></for>
</block_content>}</block></function>

<comment type="block">/*
 * PQgetCopyData - read a row of data from the backend during COPY OUT
 * or COPY BOTH
 *
 * If successful, sets *buffer to point to a malloc'd row of data, and
 * returns row length (always &gt; 0) as result.
 * Returns 0 if no row available yet (only possible if async is true),
 * -1 if end of copy (consult PQgetResult), or -2 if error (consult
 * PQerrorMessage).
 */</comment>
<function><type><name>int</name></type>
<name>pqGetCopyData3</name><parameter_list>(<parameter><decl><type><name>PGconn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>buffer</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>async</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>msgLength</name></decl>;</decl_stmt>

	<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
	<block>{<block_content>
		<comment type="block">/*
		 * Collect the next input message.  To make life simpler for async
		 * callers, we keep returning 0 until the next message is fully
		 * available, even if it is not Copy Data.
		 */</comment>
		<expr_stmt><expr><name>msgLength</name> <operator>=</operator> <call><name>getCopyDataMessage</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>msgLength</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>msgLength</name></expr>;</return></block_content></block></if></if_stmt>	<comment type="block">/* end-of-copy or error */</comment>
		<if_stmt><if>if <condition>(<expr><name>msgLength</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Don't block if async read requested */</comment>
			<if_stmt><if>if <condition>(<expr><name>async</name></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
			<comment type="block">/* Need to load more data */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>pqWait</name><argument_list>(<argument><expr><name>true</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>conn</name></expr></argument>)</argument_list></call> <operator>||</operator>
				<call><name>pqReadData</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><operator>-</operator><literal type="number">2</literal></expr>;</return></block_content></block></if></if_stmt>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * Drop zero-length messages (shouldn't happen anyway).  Otherwise
		 * pass the data back to the caller.
		 */</comment>
		<expr_stmt><expr><name>msgLength</name> <operator>-=</operator> <literal type="number">4</literal></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>msgLength</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><operator>*</operator><name>buffer</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>malloc</name><argument_list>(<argument><expr><name>msgLength</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><operator>*</operator><name>buffer</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conn</name><operator>-&gt;</operator><name>errorMessage</name></name></expr></argument>,
								  <argument><expr><call><name>libpq_gettext</name><argument_list>(<argument><expr><literal type="string">"out of memory\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr><operator>-</operator><literal type="number">2</literal></expr>;</return>
			</block_content>}</block></if></if_stmt>
			<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>*</operator><name>buffer</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>conn</name><operator>-&gt;</operator><name>inBuffer</name><index>[<expr><name><name>conn</name><operator>-&gt;</operator><name>inCursor</name></name></expr>]</index></name></expr></argument>, <argument><expr><name>msgLength</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><operator>(</operator><operator>*</operator><name>buffer</name><operator>)</operator><index>[<expr><name>msgLength</name></expr>]</index> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>	<comment type="block">/* Add terminating null */</comment>

			<comment type="block">/* Mark message consumed */</comment>
			<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>inStart</name></name> <operator>=</operator> <name><name>conn</name><operator>-&gt;</operator><name>inCursor</name></name> <operator>+</operator> <name>msgLength</name></expr>;</expr_stmt>

			<return>return <expr><name>msgLength</name></expr>;</return>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* Empty, so drop it and loop around for another */</comment>
		<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>inStart</name></name> <operator>=</operator> <name><name>conn</name><operator>-&gt;</operator><name>inCursor</name></name></expr>;</expr_stmt>
	</block_content>}</block></for>
</block_content>}</block></function>

<comment type="block">/*
 * PQgetline - gets a newline-terminated string from the backend.
 *
 * See fe-exec.c for documentation.
 */</comment>
<function><type><name>int</name></type>
<name>pqGetline3</name><parameter_list>(<parameter><decl><type><name>PGconn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>s</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>maxlen</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>status</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>sock</name></name> <operator>==</operator> <name>PGINVALID_SOCKET</name> <operator>||</operator>
		<operator>(</operator><name><name>conn</name><operator>-&gt;</operator><name>asyncStatus</name></name> <operator>!=</operator> <name>PGASYNC_COPY_OUT</name> <operator>&amp;&amp;</operator>
		 <name><name>conn</name><operator>-&gt;</operator><name>asyncStatus</name></name> <operator>!=</operator> <name>PGASYNC_COPY_BOTH</name><operator>)</operator> <operator>||</operator>
		<name><name>conn</name><operator>-&gt;</operator><name>copy_is_binary</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conn</name><operator>-&gt;</operator><name>errorMessage</name></name></expr></argument>,
						  <argument><expr><call><name>libpq_gettext</name><argument_list>(<argument><expr><literal type="string">"PQgetline: not doing text COPY OUT\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><operator>*</operator><name>s</name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
		<return>return <expr><name>EOF</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<while>while <condition>(<expr><operator>(</operator><name>status</name> <operator>=</operator> <call><name>PQgetlineAsync</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name>maxlen</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* need to load more data */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>pqWait</name><argument_list>(<argument><expr><name>true</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>conn</name></expr></argument>)</argument_list></call> <operator>||</operator>
			<call><name>pqReadData</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><operator>*</operator><name>s</name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
			<return>return <expr><name>EOF</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></while>

	<if_stmt><if>if <condition>(<expr><name>status</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* End of copy detected; gin up old-style terminator */</comment>
		<expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><literal type="string">"\\."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><literal type="number">0</literal></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Add null terminator, and strip trailing \n if present */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>s</name><index>[<expr><name>status</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'\n'</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>s</name><index>[<expr><name>status</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
		<return>return <expr><literal type="number">0</literal></expr>;</return>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name><name>s</name><index>[<expr><name>status</name></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
		<return>return <expr><literal type="number">1</literal></expr>;</return>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * PQgetlineAsync - gets a COPY data row without blocking.
 *
 * See fe-exec.c for documentation.
 */</comment>
<function><type><name>int</name></type>
<name>pqGetlineAsync3</name><parameter_list>(<parameter><decl><type><name>PGconn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>buffer</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>bufsize</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>msgLength</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>avail</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>asyncStatus</name></name> <operator>!=</operator> <name>PGASYNC_COPY_OUT</name>
		<operator>&amp;&amp;</operator> <name><name>conn</name><operator>-&gt;</operator><name>asyncStatus</name></name> <operator>!=</operator> <name>PGASYNC_COPY_BOTH</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>				<comment type="block">/* we are not doing a copy... */</comment>

	<comment type="block">/*
	 * Recognize the next input message.  To make life simpler for async
	 * callers, we keep returning 0 until the next message is fully available
	 * even if it is not Copy Data.  This should keep PQendcopy from blocking.
	 * (Note: unlike pqGetCopyData3, we do not change asyncStatus here.)
	 */</comment>
	<expr_stmt><expr><name>msgLength</name> <operator>=</operator> <call><name>getCopyDataMessage</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>msgLength</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>				<comment type="block">/* end-of-copy or error */</comment>
	<if_stmt><if>if <condition>(<expr><name>msgLength</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>				<comment type="block">/* no data yet */</comment>

	<comment type="block">/*
	 * Move data from libpq's buffer to the caller's.  In the case where a
	 * prior call found the caller's buffer too small, we use
	 * conn-&gt;copy_already_done to remember how much of the row was already
	 * returned to the caller.
	 */</comment>
	<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>inCursor</name></name> <operator>+=</operator> <name><name>conn</name><operator>-&gt;</operator><name>copy_already_done</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>avail</name> <operator>=</operator> <name>msgLength</name> <operator>-</operator> <literal type="number">4</literal> <operator>-</operator> <name><name>conn</name><operator>-&gt;</operator><name>copy_already_done</name></name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>avail</name> <operator>&lt;=</operator> <name>bufsize</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Able to consume the whole message */</comment>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>conn</name><operator>-&gt;</operator><name>inBuffer</name><index>[<expr><name><name>conn</name><operator>-&gt;</operator><name>inCursor</name></name></expr>]</index></name></expr></argument>, <argument><expr><name>avail</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* Mark message consumed */</comment>
		<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>inStart</name></name> <operator>=</operator> <name><name>conn</name><operator>-&gt;</operator><name>inCursor</name></name> <operator>+</operator> <name>avail</name></expr>;</expr_stmt>
		<comment type="block">/* Reset state for next time */</comment>
		<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>copy_already_done</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<return>return <expr><name>avail</name></expr>;</return>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* We must return a partial message */</comment>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>conn</name><operator>-&gt;</operator><name>inBuffer</name><index>[<expr><name><name>conn</name><operator>-&gt;</operator><name>inCursor</name></name></expr>]</index></name></expr></argument>, <argument><expr><name>bufsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* The message is NOT consumed from libpq's buffer */</comment>
		<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>copy_already_done</name></name> <operator>+=</operator> <name>bufsize</name></expr>;</expr_stmt>
		<return>return <expr><name>bufsize</name></expr>;</return>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * PQendcopy
 *
 * See fe-exec.c for documentation.
 */</comment>
<function><type><name>int</name></type>
<name>pqEndcopy3</name><parameter_list>(<parameter><decl><type><name>PGconn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>asyncStatus</name></name> <operator>!=</operator> <name>PGASYNC_COPY_IN</name> <operator>&amp;&amp;</operator>
		<name><name>conn</name><operator>-&gt;</operator><name>asyncStatus</name></name> <operator>!=</operator> <name>PGASYNC_COPY_OUT</name> <operator>&amp;&amp;</operator>
		<name><name>conn</name><operator>-&gt;</operator><name>asyncStatus</name></name> <operator>!=</operator> <name>PGASYNC_COPY_BOTH</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conn</name><operator>-&gt;</operator><name>errorMessage</name></name></expr></argument>,
						  <argument><expr><call><name>libpq_gettext</name><argument_list>(<argument><expr><literal type="string">"no COPY in progress\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><literal type="number">1</literal></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Send the CopyDone message if needed */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>asyncStatus</name></name> <operator>==</operator> <name>PGASYNC_COPY_IN</name> <operator>||</operator>
		<name><name>conn</name><operator>-&gt;</operator><name>asyncStatus</name></name> <operator>==</operator> <name>PGASYNC_COPY_BOTH</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>pqPutMsgStart</name><argument_list>(<argument><expr><literal type="char">'c'</literal></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>conn</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator>
			<call><name>pqPutMsgEnd</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * If we sent the COPY command in extended-query mode, we must issue a
		 * Sync as well.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>queryclass</name></name> <operator>!=</operator> <name>PGQUERY_SIMPLE</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><call><name>pqPutMsgStart</name><argument_list>(<argument><expr><literal type="char">'S'</literal></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>conn</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator>
				<call><name>pqPutMsgEnd</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * make sure no data is waiting to be sent, abort if we are non-blocking
	 * and the flush fails
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>pqFlush</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>pqIsnonblocking</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* Return to active duty */</comment>
	<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>asyncStatus</name></name> <operator>=</operator> <name>PGASYNC_BUSY</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>resetPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conn</name><operator>-&gt;</operator><name>errorMessage</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Non blocking connections may have to abort at this point.  If everyone
	 * played the game there should be no problem, but in error scenarios the
	 * expected messages may not have arrived yet.  (We are assuming that the
	 * backend's packetizing will ensure that CommandComplete arrives along
	 * with the CopyDone; are there corner cases where that doesn't happen?)
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>pqIsnonblocking</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>PQisBusy</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* Wait for the completion response */</comment>
	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>PQgetResult</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Expecting a successful result */</comment>
	<if_stmt><if>if <condition>(<expr><name>result</name> <operator>&amp;&amp;</operator> <name><name>result</name><operator>-&gt;</operator><name>resultStatus</name></name> <operator>==</operator> <name>PGRES_COMMAND_OK</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><literal type="number">0</literal></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Trouble. For backwards-compatibility reasons, we issue the error
	 * message as if it were a notice (would be nice to get rid of this
	 * silliness, but too many apps probably don't handle errors from
	 * PQendcopy reasonably).  Note that the app can still obtain the error
	 * status from the PGconn object.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>errorMessage</name><operator>.</operator><name>len</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* We have to strip the trailing newline ... pain in neck... */</comment>
		<decl_stmt><decl><type><name>char</name></type>		<name>svLast</name> <init>= <expr><name><name>conn</name><operator>-&gt;</operator><name>errorMessage</name><operator>.</operator><name>data</name><index>[<expr><name><name>conn</name><operator>-&gt;</operator><name>errorMessage</name><operator>.</operator><name>len</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>svLast</name> <operator>==</operator> <literal type="char">'\n'</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>errorMessage</name><operator>.</operator><name>data</name><index>[<expr><name><name>conn</name><operator>-&gt;</operator><name>errorMessage</name><operator>.</operator><name>len</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>pqInternalNotice</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conn</name><operator>-&gt;</operator><name>noticeHooks</name></name></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>errorMessage</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>errorMessage</name><operator>.</operator><name>data</name><index>[<expr><name><name>conn</name><operator>-&gt;</operator><name>errorMessage</name><operator>.</operator><name>len</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>svLast</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * PQfn - Send a function call to the POSTGRES backend.
 *
 * See fe-exec.c for documentation.
 */</comment>
<function><type><name>PGresult</name> <modifier>*</modifier></type>
<name>pqFunctionCall3</name><parameter_list>(<parameter><decl><type><name>PGconn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>fnid</name></decl></parameter>,
				<parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>result_buf</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>actual_result_len</name></decl></parameter>,
				<parameter><decl><type><name>int</name></type> <name>result_is_int</name></decl></parameter>,
				<parameter><decl><type><specifier>const</specifier> <name>PQArgBlock</name> <modifier>*</modifier></type><name>args</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nargs</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type>		<name>needInput</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ExecStatusType</name></type> <name>status</name> <init>= <expr><name>PGRES_FATAL_ERROR</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name>id</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>msgLength</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>avail</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<comment type="block">/* PQfn already validated connection state */</comment>

	<if_stmt><if>if <condition>(<expr><call><name>pqPutMsgStart</name><argument_list>(<argument><expr><literal type="char">'F'</literal></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>conn</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator>	<comment type="block">/* function call msg */</comment>
		<call><name>pqPutInt</name><argument_list>(<argument><expr><name>fnid</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>, <argument><expr><name>conn</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator>	<comment type="block">/* function id */</comment>
		<call><name>pqPutInt</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>conn</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator> <comment type="block">/* # of format codes */</comment>
		<call><name>pqPutInt</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>conn</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator> <comment type="block">/* format code: BINARY */</comment>
		<call><name>pqPutInt</name><argument_list>(<argument><expr><name>nargs</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>conn</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>	<comment type="block">/* # of args */</comment>
	<block>{<block_content>
		<expr_stmt><expr><call><name>pqHandleSendFailure</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nargs</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control>
	<block>{<block_content>							<comment type="block">/* len.int4 + contents	   */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>pqPutInt</name><argument_list>(<argument><expr><name><name>args</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>len</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>, <argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>pqHandleSendFailure</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>NULL</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>args</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>len</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>			<comment type="block">/* it's NULL */</comment>

		<if_stmt><if>if <condition>(<expr><name><name>args</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>isint</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><call><name>pqPutInt</name><argument_list>(<argument><expr><name><name>args</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>u</name><operator>.</operator><name>integer</name></name></expr></argument>, <argument><expr><name><name>args</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>len</name></expr></argument>, <argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>pqHandleSendFailure</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr><name>NULL</name></expr>;</return>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><call><name>pqPutnchar</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name><name>args</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>u</name><operator>.</operator><name>ptr</name></name></expr></argument>, <argument><expr><name><name>args</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>len</name></expr></argument>, <argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>pqHandleSendFailure</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr><name>NULL</name></expr>;</return>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></for>

	<if_stmt><if>if <condition>(<expr><call><name>pqPutInt</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>conn</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>	<comment type="block">/* result format code: BINARY */</comment>
	<block>{<block_content>
		<expr_stmt><expr><call><name>pqHandleSendFailure</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>pqPutMsgEnd</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator>
		<call><name>pqFlush</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>pqHandleSendFailure</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>needInput</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Wait for some data to arrive (or for the channel to close) */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>pqWait</name><argument_list>(<argument><expr><name>true</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>conn</name></expr></argument>)</argument_list></call> <operator>||</operator>
				<call><name>pqReadData</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<break>break;</break></block_content></block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * Scan the message. If we run out of data, loop around to try again.
		 */</comment>
		<expr_stmt><expr><name>needInput</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>inCursor</name></name> <operator>=</operator> <name><name>conn</name><operator>-&gt;</operator><name>inStart</name></name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>pqGetc</name><argument_list>(<argument><expr><operator>&amp;</operator><name>id</name></expr></argument>, <argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>pqGetInt</name><argument_list>(<argument><expr><operator>&amp;</operator><name>msgLength</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>, <argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * Try to validate message type/length here.  A length less than 4 is
		 * definitely broken.  Large lengths should only be believed for a few
		 * message types.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>msgLength</name> <operator>&lt;</operator> <literal type="number">4</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>handleSyncLoss</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>id</name></expr></argument>, <argument><expr><name>msgLength</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name>msgLength</name> <operator>&gt;</operator> <literal type="number">30000</literal> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>VALID_LONG_MESSAGE_TYPE</name><argument_list>(<argument><expr><name>id</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>handleSyncLoss</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>id</name></expr></argument>, <argument><expr><name>msgLength</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * Can't process if message body isn't all here yet.
		 */</comment>
		<expr_stmt><expr><name>msgLength</name> <operator>-=</operator> <literal type="number">4</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name>avail</name> <operator>=</operator> <name><name>conn</name><operator>-&gt;</operator><name>inEnd</name></name> <operator>-</operator> <name><name>conn</name><operator>-&gt;</operator><name>inCursor</name></name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>avail</name> <operator>&lt;</operator> <name>msgLength</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * Before looping, enlarge the input buffer if needed to hold the
			 * whole message.  See notes in parseInput.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>pqCheckInBufferSpace</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>inCursor</name></name> <operator>+</operator> <operator>(</operator><name>size_t</name><operator>)</operator> <name>msgLength</name></expr></argument>,
									 <argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/*
				 * XXX add some better recovery code... plan is to skip over
				 * the message using its length, then report an error. For the
				 * moment, just treat this like loss of sync (which indeed it
				 * might be!)
				 */</comment>
				<expr_stmt><expr><call><name>handleSyncLoss</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>id</name></expr></argument>, <argument><expr><name>msgLength</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block></if></if_stmt>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * We should see V or E response to the command, but might get N
		 * and/or A notices first. We also need to swallow the final Z before
		 * returning.
		 */</comment>
		<switch>switch <condition>(<expr><name>id</name></expr>)</condition>
		<block>{<block_content>
			<case>case <expr><literal type="char">'V'</literal></expr>:</case>			<comment type="block">/* function result */</comment>
				<if_stmt><if>if <condition>(<expr><call><name>pqGetInt</name><argument_list>(<argument><expr><name>actual_result_len</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>, <argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<continue>continue;</continue></block_content></block></if></if_stmt>
				<if_stmt><if>if <condition>(<expr><operator>*</operator><name>actual_result_len</name> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>
				<block>{<block_content>
					<if_stmt><if>if <condition>(<expr><name>result_is_int</name></expr>)</condition>
					<block>{<block_content>
						<if_stmt><if>if <condition>(<expr><call><name>pqGetInt</name><argument_list>(<argument><expr><name>result_buf</name></expr></argument>, <argument><expr><operator>*</operator><name>actual_result_len</name></expr></argument>, <argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
							<continue>continue;</continue></block_content></block></if></if_stmt>
					</block_content>}</block></if>
					<else>else
					<block>{<block_content>
						<if_stmt><if>if <condition>(<expr><call><name>pqGetnchar</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>result_buf</name></expr></argument>,
									   <argument><expr><operator>*</operator><name>actual_result_len</name></expr></argument>,
									   <argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
							<continue>continue;</continue></block_content></block></if></if_stmt>
					</block_content>}</block></else></if_stmt>
				</block_content>}</block></if></if_stmt>
				<comment type="block">/* correctly finished function result message */</comment>
				<expr_stmt><expr><name>status</name> <operator>=</operator> <name>PGRES_COMMAND_OK</name></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><literal type="char">'E'</literal></expr>:</case>			<comment type="block">/* error return */</comment>
				<if_stmt><if>if <condition>(<expr><call><name>pqGetErrorNotice3</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<continue>continue;</continue></block_content></block></if></if_stmt>
				<expr_stmt><expr><name>status</name> <operator>=</operator> <name>PGRES_FATAL_ERROR</name></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><literal type="char">'A'</literal></expr>:</case>			<comment type="block">/* notify message */</comment>
				<comment type="block">/* handle notify and go back to processing return values */</comment>
				<if_stmt><if>if <condition>(<expr><call><name>getNotify</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<continue>continue;</continue></block_content></block></if></if_stmt>
				<break>break;</break>
			<case>case <expr><literal type="char">'N'</literal></expr>:</case>			<comment type="block">/* notice */</comment>
				<comment type="block">/* handle notice and go back to processing return values */</comment>
				<if_stmt><if>if <condition>(<expr><call><name>pqGetErrorNotice3</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<continue>continue;</continue></block_content></block></if></if_stmt>
				<break>break;</break>
			<case>case <expr><literal type="char">'Z'</literal></expr>:</case>			<comment type="block">/* backend is ready for new query */</comment>
				<if_stmt><if>if <condition>(<expr><call><name>getReadyForQuery</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<continue>continue;</continue></block_content></block></if></if_stmt>
				<comment type="block">/* consume the message and exit */</comment>
				<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>inStart</name></name> <operator>+=</operator> <literal type="number">5</literal> <operator>+</operator> <name>msgLength</name></expr>;</expr_stmt>
				<comment type="block">/* if we saved a result object (probably an error), use it */</comment>
				<if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>result</name></name></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><call><name>pqPrepareAsyncResult</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
				<return>return <expr><call><name>PQmakeEmptyPGresult</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>status</name></expr></argument>)</argument_list></call></expr>;</return>
			<case>case <expr><literal type="char">'S'</literal></expr>:</case>			<comment type="block">/* parameter status */</comment>
				<if_stmt><if>if <condition>(<expr><call><name>getParameterStatus</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<continue>continue;</continue></block_content></block></if></if_stmt>
				<break>break;</break>
			<default>default:</default>
				<comment type="block">/* The backend violates the protocol. */</comment>
				<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conn</name><operator>-&gt;</operator><name>errorMessage</name></name></expr></argument>,
								  <argument><expr><call><name>libpq_gettext</name><argument_list>(<argument><expr><literal type="string">"protocol error: id=0x%x\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
								  <argument><expr><name>id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>pqSaveErrorResult</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<comment type="block">/* trust the specified message length as what to skip */</comment>
				<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>inStart</name></name> <operator>+=</operator> <literal type="number">5</literal> <operator>+</operator> <name>msgLength</name></expr>;</expr_stmt>
				<return>return <expr><call><name>pqPrepareAsyncResult</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>;</return>
		</block_content>}</block></switch>
		<comment type="block">/* Completed this message, keep going */</comment>
		<comment type="block">/* trust the specified message length as what to skip */</comment>
		<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>inStart</name></name> <operator>+=</operator> <literal type="number">5</literal> <operator>+</operator> <name>msgLength</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>needInput</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	</block_content>}</block></for>

	<comment type="block">/*
	 * We fall out of the loop only upon failing to read data.
	 * conn-&gt;errorMessage has been set by pqWait or pqReadData. We want to
	 * append it to any already-received error message.
	 */</comment>
	<expr_stmt><expr><call><name>pqSaveErrorResult</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><call><name>pqPrepareAsyncResult</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * Construct startup packet
 *
 * Returns a malloc'd packet buffer, or NULL if out of memory
 */</comment>
<function><type><name>char</name> <modifier>*</modifier></type>
<name>pqBuildStartupPacket3</name><parameter_list>(<parameter><decl><type><name>PGconn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>packetlen</name></decl></parameter>,
					  <parameter><decl><type><specifier>const</specifier> <name>PQEnvironmentOption</name> <modifier>*</modifier></type><name>options</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>startpacket</name></decl>;</decl_stmt>

	<expr_stmt><expr><operator>*</operator><name>packetlen</name> <operator>=</operator> <call><name>build_startup_packet</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>options</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>startpacket</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>malloc</name><argument_list>(<argument><expr><operator>*</operator><name>packetlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>startpacket</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
	<expr_stmt><expr><operator>*</operator><name>packetlen</name> <operator>=</operator> <call><name>build_startup_packet</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>startpacket</name></expr></argument>, <argument><expr><name>options</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>startpacket</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Build a startup packet given a filled-in PGconn structure.
 *
 * We need to figure out how much space is needed, then fill it in.
 * To avoid duplicate logic, this routine is called twice: the first time
 * (with packet == NULL) just counts the space needed, the second time
 * (with packet == allocated space) fills it in.  Return value is the number
 * of bytes used.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>build_startup_packet</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>PGconn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>packet</name></decl></parameter>,
					 <parameter><decl><type><specifier>const</specifier> <name>PQEnvironmentOption</name> <modifier>*</modifier></type><name>options</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>packet_len</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>PQEnvironmentOption</name> <modifier>*</modifier></type><name>next_eo</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>val</name></decl>;</decl_stmt>

	<comment type="block">/* Protocol version comes first. */</comment>
	<if_stmt><if>if <condition>(<expr><name>packet</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ProtocolVersion</name></type> <name>pv</name> <init>= <expr><call><name>pg_hton32</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>pversion</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>packet</name> <operator>+</operator> <name>packet_len</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pv</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ProtocolVersion</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name>packet_len</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ProtocolVersion</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>

	<comment type="block">/* Add user name, database name, options */</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ADD_STARTUP_OPTION</name><parameter_list>(<parameter><type><name>optname</name></type></parameter>, <parameter><type><name>optval</name></type></parameter>)</parameter_list></cpp:macro> \
	<cpp:value>do { \
		if (packet) \
			strcpy(packet + packet_len, optname); \
		packet_len += strlen(optname) + 1; \
		if (packet) \
			strcpy(packet + packet_len, optval); \
		packet_len += strlen(optval) + 1; \
	} while(0)</cpp:value></cpp:define>

	<if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>pguser</name></name> <operator>&amp;&amp;</operator> <name><name>conn</name><operator>-&gt;</operator><name>pguser</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ADD_STARTUP_OPTION</name><argument_list>(<argument><expr><literal type="string">"user"</literal></expr></argument>, <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>pguser</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>dbName</name></name> <operator>&amp;&amp;</operator> <name><name>conn</name><operator>-&gt;</operator><name>dbName</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ADD_STARTUP_OPTION</name><argument_list>(<argument><expr><literal type="string">"database"</literal></expr></argument>, <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>dbName</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>replication</name></name> <operator>&amp;&amp;</operator> <name><name>conn</name><operator>-&gt;</operator><name>replication</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ADD_STARTUP_OPTION</name><argument_list>(<argument><expr><literal type="string">"replication"</literal></expr></argument>, <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>replication</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<comment type="block">/* POLAR px */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>pxconntype</name></name> <operator>&amp;&amp;</operator> <name><name>conn</name><operator>-&gt;</operator><name>pxconntype</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ADD_STARTUP_OPTION</name><argument_list>(<argument><expr><name>PXCONN_TYPE</name></expr></argument>, <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>pxconntype</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>pgoptions</name></name> <operator>&amp;&amp;</operator> <name><name>conn</name><operator>-&gt;</operator><name>pgoptions</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ADD_STARTUP_OPTION</name><argument_list>(<argument><expr><literal type="string">"options"</literal></expr></argument>, <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>pgoptions</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>send_appname</name></name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Use appname if present, otherwise use fallback */</comment>
		<expr_stmt><expr><name>val</name> <operator>=</operator> <ternary><condition><expr><name><name>conn</name><operator>-&gt;</operator><name>appname</name></name></expr> ?</condition><then> <expr><name><name>conn</name><operator>-&gt;</operator><name>appname</name></name></expr> </then><else>: <expr><name><name>conn</name><operator>-&gt;</operator><name>fbappname</name></name></expr></else></ternary></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>val</name> <operator>&amp;&amp;</operator> <name><name>val</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ADD_STARTUP_OPTION</name><argument_list>(<argument><expr><literal type="string">"application_name"</literal></expr></argument>, <argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>client_encoding_initial</name></name> <operator>&amp;&amp;</operator> <name><name>conn</name><operator>-&gt;</operator><name>client_encoding_initial</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ADD_STARTUP_OPTION</name><argument_list>(<argument><expr><literal type="string">"client_encoding"</literal></expr></argument>, <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>client_encoding_initial</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* POLAR px: Add PX startup data */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>pxid</name></name> <operator>&amp;&amp;</operator> <name><name>conn</name><operator>-&gt;</operator><name>pxid</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ADD_STARTUP_OPTION</name><argument_list>(<argument><expr><literal type="string">"pxid"</literal></expr></argument>, <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>pxid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Add any environment-driven GUC settings needed */</comment>
	<for>for <control>(<init><expr><name>next_eo</name> <operator>=</operator> <name>options</name></expr>;</init> <condition><expr><name><name>next_eo</name><operator>-&gt;</operator><name>envName</name></name></expr>;</condition> <incr><expr><name>next_eo</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>(</operator><name>val</name> <operator>=</operator> <call><name>getenv</name><argument_list>(<argument><expr><name><name>next_eo</name><operator>-&gt;</operator><name>envName</name></name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><call><name>pg_strcasecmp</name><argument_list>(<argument><expr><name>val</name></expr></argument>, <argument><expr><literal type="string">"default"</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ADD_STARTUP_OPTION</name><argument_list>(<argument><expr><name><name>next_eo</name><operator>-&gt;</operator><name>pgName</name></name></expr></argument>, <argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>

	<comment type="block">/* Add trailing terminator */</comment>
	<if_stmt><if>if <condition>(<expr><name>packet</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>packet</name><index>[<expr><name>packet_len</name></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>packet_len</name><operator>++</operator></expr>;</expr_stmt>

	<return>return <expr><name>packet_len</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * POLAR px: savePxStatMsg - attach PX statistics message to PGresult
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>savePxStatMsg</name><parameter_list>(<parameter><decl><type><name>PGresult</name> <modifier>*</modifier></type><name>result</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>data</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>len</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>pgPxStatCell</name>  <modifier>*</modifier></type><name>cell</name></decl>;</decl_stmt>

    <comment type="block">/* Allocate list element. */</comment>
    <expr_stmt><expr><name>cell</name> <operator>=</operator> <call><name>pqResultAlloc</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>cell</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>cell</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return;</return></block_content></block></if></if_stmt>

    <comment type="block">/* Allocate an aligned buffer from the PGresult's memory pool. */</comment>
    <expr_stmt><expr><name><name>cell</name><operator>-&gt;</operator><name>data</name></name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><call><name>pqResultAlloc</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>cell</name><operator>-&gt;</operator><name>data</name></name></expr>)</condition><block type="pseudo"><block_content>
        <return>return;</return></block_content></block></if></if_stmt>

    <comment type="block">/* Copy the message data. */</comment>
    <expr_stmt><expr><name><name>cell</name><operator>-&gt;</operator><name>len</name></name> <operator>=</operator> <name>len</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>cell</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name>data</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Add to head of list. */</comment>
    <expr_stmt><expr><name><name>cell</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name><name>result</name><operator>-&gt;</operator><name>pxstats</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>pxstats</name></name> <operator>=</operator> <name>cell</name></expr>;</expr_stmt>
    <return>return;</return>
</block_content>}</block></function>                               <comment type="block">/* savePxStatMsg */</comment></unit>
