<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/PolarDB-for-PostgreSQL/src/interfaces/libpq/fe-protocol2.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * fe-protocol2.c
 *	  functions that are specific to frontend/backend protocol version 2
 *
 * Portions Copyright (c) 1996-2018, PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, Regents of the University of California
 *
 *
 * IDENTIFICATION
 *	  src/interfaces/libpq/fe-protocol2.c
 *
 *-------------------------------------------------------------------------
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres_fe.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;ctype.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;fcntl.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"libpq-fe.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"libpq-int.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"port/pg_bswap.h"</cpp:file></cpp:include>


<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WIN32</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"win32.h"</cpp:file></cpp:include>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;unistd.h&gt;</cpp:file></cpp:include>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_NETINET_TCP_H</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;netinet/tcp.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>


<function_decl><type><specifier>static</specifier> <name>int</name></type>	<name>getRowDescriptions</name><parameter_list>(<parameter><decl><type><name>PGconn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type>	<name>getAnotherTuple</name><parameter_list>(<parameter><decl><type><name>PGconn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>binary</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type>	<name>pqGetErrorNotice2</name><parameter_list>(<parameter><decl><type><name>PGconn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>isError</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>checkXactStatus</name><parameter_list>(<parameter><decl><type><name>PGconn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>cmdTag</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type>	<name>getNotify</name><parameter_list>(<parameter><decl><type><name>PGconn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>)</parameter_list>;</function_decl>


<comment type="block">/*
 *		pqSetenvPoll
 *
 * Polls the process of passing the values of a standard set of environment
 * variables to the backend.
 */</comment>
<function><type><name>PostgresPollingStatusType</name></type>
<name>pqSetenvPoll</name><parameter_list>(<parameter><decl><type><name>PGconn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>conn</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name><name>conn</name><operator>-&gt;</operator><name>status</name></name> <operator>==</operator> <name>CONNECTION_BAD</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>PGRES_POLLING_FAILED</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* Check whether there are any data for us */</comment>
	<switch>switch <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>setenv_state</name></name></expr>)</condition>
	<block>{<block_content>
			<comment type="block">/* These are reading states */</comment>
		<case>case <expr><name>SETENV_STATE_CLIENT_ENCODING_WAIT</name></expr>:</case>
		<case>case <expr><name>SETENV_STATE_OPTION_WAIT</name></expr>:</case>
		<case>case <expr><name>SETENV_STATE_QUERY1_WAIT</name></expr>:</case>
		<case>case <expr><name>SETENV_STATE_QUERY2_WAIT</name></expr>:</case>
			<block>{<block_content>
				<comment type="block">/* Load waiting data */</comment>
				<decl_stmt><decl><type><name>int</name></type>			<name>n</name> <init>= <expr><call><name>pqReadData</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><name>n</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
					<goto>goto <name>error_return</name>;</goto></block_content></block></if></if_stmt>
				<if_stmt><if>if <condition>(<expr><name>n</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>PGRES_POLLING_READING</name></expr>;</return></block_content></block></if></if_stmt>

				<break>break;</break>
			</block_content>}</block>

			<comment type="block">/* These are writing states, so we just proceed. */</comment>
		<case>case <expr><name>SETENV_STATE_CLIENT_ENCODING_SEND</name></expr>:</case>
		<case>case <expr><name>SETENV_STATE_OPTION_SEND</name></expr>:</case>
		<case>case <expr><name>SETENV_STATE_QUERY1_SEND</name></expr>:</case>
		<case>case <expr><name>SETENV_STATE_QUERY2_SEND</name></expr>:</case>
			<break>break;</break>

			<comment type="block">/* Should we raise an error if called when not active? */</comment>
		<case>case <expr><name>SETENV_STATE_IDLE</name></expr>:</case>
			<return>return <expr><name>PGRES_POLLING_OK</name></expr>;</return>

		<default>default:</default>
			<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conn</name><operator>-&gt;</operator><name>errorMessage</name></name></expr></argument>,
							  <argument><expr><call><name>libpq_gettext</name><argument_list>(
											<argument><expr><literal type="string">"invalid setenv state %c, "</literal>
											<literal type="string">"probably indicative of memory corruption\n"</literal></expr></argument>
											)</argument_list></call></expr></argument>,
							  <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>setenv_state</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<goto>goto <name>error_return</name>;</goto>
	</block_content>}</block></switch>

	<comment type="block">/* We will loop here until there is nothing left to do in this call. */</comment>
	<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
	<block>{<block_content>
		<switch>switch <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>setenv_state</name></name></expr>)</condition>
		<block>{<block_content>
				<comment type="block">/*
				 * The _CLIENT_ENCODING_SEND code is slightly different from
				 * _OPTION_SEND below (e.g., no getenv() call), which is why a
				 * different state is used.
				 */</comment>
			<case>case <expr><name>SETENV_STATE_CLIENT_ENCODING_SEND</name></expr>:</case>
				<block>{<block_content>
					<decl_stmt><decl><type><name>char</name></type>		<name><name>setQuery</name><index>[<expr><literal type="number">100</literal></expr>]</index></name></decl>;</decl_stmt>	<comment type="block">/* note length limit in
												 * sprintf below */</comment>
					<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>val</name> <init>= <expr><name><name>conn</name><operator>-&gt;</operator><name>client_encoding_initial</name></name></expr></init></decl>;</decl_stmt>

					<if_stmt><if>if <condition>(<expr><name>val</name></expr>)</condition>
					<block>{<block_content>
						<if_stmt><if>if <condition>(<expr><call><name>pg_strcasecmp</name><argument_list>(<argument><expr><name>val</name></expr></argument>, <argument><expr><literal type="string">"default"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
							<expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>setQuery</name></expr></argument>, <argument><expr><literal type="string">"SET client_encoding = DEFAULT"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
						<else>else<block type="pseudo"><block_content>
							<expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>setQuery</name></expr></argument>, <argument><expr><literal type="string">"SET client_encoding = '%.60s'"</literal></expr></argument>,
									<argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>CONNECTDEBUG</name></cpp:ifdef>
						<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>,
								<argument><expr><literal type="string">"Sending client_encoding with %s\n"</literal></expr></argument>,
								<argument><expr><name>setQuery</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
						<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>PQsendQuery</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>setQuery</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
							<goto>goto <name>error_return</name>;</goto></block_content></block></if></if_stmt>

						<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>setenv_state</name></name> <operator>=</operator> <name>SETENV_STATE_CLIENT_ENCODING_WAIT</name></expr>;</expr_stmt>
					</block_content>}</block></if>
					<else>else<block type="pseudo"><block_content>
						<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>setenv_state</name></name> <operator>=</operator> <name>SETENV_STATE_OPTION_SEND</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
					<break>break;</break>
				</block_content>}</block>

			<case>case <expr><name>SETENV_STATE_OPTION_SEND</name></expr>:</case>
				<block>{<block_content>
					<comment type="block">/*
					 * Send SET commands for stuff directed by Environment
					 * Options.  Note: we assume that SET commands won't start
					 * transaction blocks, even in a 7.3 server with
					 * autocommit off.
					 */</comment>
					<decl_stmt><decl><type><name>char</name></type>		<name><name>setQuery</name><index>[<expr><literal type="number">100</literal></expr>]</index></name></decl>;</decl_stmt>	<comment type="block">/* note length limit in
												 * sprintf below */</comment>

					<if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>next_eo</name><operator>-&gt;</operator><name>envName</name></name></expr>)</condition>
					<block>{<block_content>
						<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>val</name></decl>;</decl_stmt>

						<if_stmt><if>if <condition>(<expr><operator>(</operator><name>val</name> <operator>=</operator> <call><name>getenv</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>next_eo</name><operator>-&gt;</operator><name>envName</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition>
						<block>{<block_content>
							<if_stmt><if>if <condition>(<expr><call><name>pg_strcasecmp</name><argument_list>(<argument><expr><name>val</name></expr></argument>, <argument><expr><literal type="string">"default"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
								<expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>setQuery</name></expr></argument>, <argument><expr><literal type="string">"SET %s = DEFAULT"</literal></expr></argument>,
										<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>next_eo</name><operator>-&gt;</operator><name>pgName</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
							<else>else<block type="pseudo"><block_content>
								<expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>setQuery</name></expr></argument>, <argument><expr><literal type="string">"SET %s = '%.60s'"</literal></expr></argument>,
										<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>next_eo</name><operator>-&gt;</operator><name>pgName</name></name></expr></argument>, <argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>CONNECTDEBUG</name></cpp:ifdef>
							<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>,
									<argument><expr><literal type="string">"Use environment variable %s to send %s\n"</literal></expr></argument>,
									<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>next_eo</name><operator>-&gt;</operator><name>envName</name></name></expr></argument>, <argument><expr><name>setQuery</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
							<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>PQsendQuery</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>setQuery</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
								<goto>goto <name>error_return</name>;</goto></block_content></block></if></if_stmt>

							<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>setenv_state</name></name> <operator>=</operator> <name>SETENV_STATE_OPTION_WAIT</name></expr>;</expr_stmt>
						</block_content>}</block></if>
						<else>else<block type="pseudo"><block_content>
							<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>next_eo</name></name><operator>++</operator></expr>;</expr_stmt></block_content></block></else></if_stmt>
					</block_content>}</block></if>
					<else>else
					<block>{<block_content>
						<comment type="block">/* No more options to send, so move on to querying */</comment>
						<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>setenv_state</name></name> <operator>=</operator> <name>SETENV_STATE_QUERY1_SEND</name></expr>;</expr_stmt>
					</block_content>}</block></else></if_stmt>
					<break>break;</break>
				</block_content>}</block>

			<case>case <expr><name>SETENV_STATE_CLIENT_ENCODING_WAIT</name></expr>:</case>
				<block>{<block_content>
					<if_stmt><if>if <condition>(<expr><call><name>PQisBusy</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
						<return>return <expr><name>PGRES_POLLING_READING</name></expr>;</return></block_content></block></if></if_stmt>

					<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>PQgetResult</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<if_stmt><if>if <condition>(<expr><name>res</name></expr>)</condition>
					<block>{<block_content>
						<if_stmt><if>if <condition>(<expr><call><name>PQresultStatus</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>PGRES_COMMAND_OK</name></expr>)</condition>
						<block>{<block_content>
							<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							<goto>goto <name>error_return</name>;</goto>
						</block_content>}</block></if></if_stmt>
						<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<comment type="block">/* Keep reading until PQgetResult returns NULL */</comment>
					</block_content>}</block></if>
					<else>else
					<block>{<block_content>
						<comment type="block">/* Query finished, so send the next option */</comment>
						<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>setenv_state</name></name> <operator>=</operator> <name>SETENV_STATE_OPTION_SEND</name></expr>;</expr_stmt>
					</block_content>}</block></else></if_stmt>
					<break>break;</break>
				</block_content>}</block>

			<case>case <expr><name>SETENV_STATE_OPTION_WAIT</name></expr>:</case>
				<block>{<block_content>
					<if_stmt><if>if <condition>(<expr><call><name>PQisBusy</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
						<return>return <expr><name>PGRES_POLLING_READING</name></expr>;</return></block_content></block></if></if_stmt>

					<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>PQgetResult</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<if_stmt><if>if <condition>(<expr><name>res</name></expr>)</condition>
					<block>{<block_content>
						<if_stmt><if>if <condition>(<expr><call><name>PQresultStatus</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>PGRES_COMMAND_OK</name></expr>)</condition>
						<block>{<block_content>
							<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							<goto>goto <name>error_return</name>;</goto>
						</block_content>}</block></if></if_stmt>
						<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<comment type="block">/* Keep reading until PQgetResult returns NULL */</comment>
					</block_content>}</block></if>
					<else>else
					<block>{<block_content>
						<comment type="block">/* Query finished, so send the next option */</comment>
						<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>next_eo</name></name><operator>++</operator></expr>;</expr_stmt>
						<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>setenv_state</name></name> <operator>=</operator> <name>SETENV_STATE_OPTION_SEND</name></expr>;</expr_stmt>
					</block_content>}</block></else></if_stmt>
					<break>break;</break>
				</block_content>}</block>

			<case>case <expr><name>SETENV_STATE_QUERY1_SEND</name></expr>:</case>
				<block>{<block_content>
					<comment type="block">/*
					 * Issue query to get information we need.  Here we must
					 * use begin/commit in case autocommit is off by default
					 * in a 7.3 server.
					 *
					 * Note: version() exists in all protocol-2.0-supporting
					 * backends.  In 7.3 it would be safer to write
					 * pg_catalog.version(), but we can't do that without
					 * causing problems on older versions.
					 */</comment>
					<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>PQsendQuery</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><literal type="string">"begin; select version(); end"</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
						<goto>goto <name>error_return</name>;</goto></block_content></block></if></if_stmt>

					<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>setenv_state</name></name> <operator>=</operator> <name>SETENV_STATE_QUERY1_WAIT</name></expr>;</expr_stmt>
					<return>return <expr><name>PGRES_POLLING_READING</name></expr>;</return>
				</block_content>}</block>

			<case>case <expr><name>SETENV_STATE_QUERY1_WAIT</name></expr>:</case>
				<block>{<block_content>
					<if_stmt><if>if <condition>(<expr><call><name>PQisBusy</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
						<return>return <expr><name>PGRES_POLLING_READING</name></expr>;</return></block_content></block></if></if_stmt>

					<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>PQgetResult</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<if_stmt><if>if <condition>(<expr><name>res</name></expr>)</condition>
					<block>{<block_content>
						<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>val</name></decl>;</decl_stmt>

						<if_stmt><if>if <condition>(<expr><call><name>PQresultStatus</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>PGRES_COMMAND_OK</name></expr>)</condition>
						<block>{<block_content>
							<comment type="block">/* ignore begin/commit command results */</comment>
							<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							<continue>continue;</continue>
						</block_content>}</block></if></if_stmt>

						<if_stmt><if>if <condition>(<expr><call><name>PQresultStatus</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>PGRES_TUPLES_OK</name> <operator>||</operator>
							<call><name>PQntuples</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition>
						<block>{<block_content>
							<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							<goto>goto <name>error_return</name>;</goto>
						</block_content>}</block></if></if_stmt>

						<comment type="block">/*
						 * Extract server version and save as if
						 * ParameterStatus
						 */</comment>
						<expr_stmt><expr><name>val</name> <operator>=</operator> <call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<if_stmt><if>if <condition>(<expr><name>val</name> <operator>&amp;&amp;</operator> <call><name>strncmp</name><argument_list>(<argument><expr><name>val</name></expr></argument>, <argument><expr><literal type="string">"PostgreSQL "</literal></expr></argument>, <argument><expr><literal type="number">11</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
						<block>{<block_content>
							<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>ptr</name></decl>;</decl_stmt>

							<comment type="block">/* strip off PostgreSQL part */</comment>
							<expr_stmt><expr><name>val</name> <operator>+=</operator> <literal type="number">11</literal></expr>;</expr_stmt>

							<comment type="block">/*
							 * strip off platform part (scribbles on result,
							 * naughty naughty)
							 */</comment>
							<expr_stmt><expr><name>ptr</name> <operator>=</operator> <call><name>strchr</name><argument_list>(<argument><expr><name>val</name></expr></argument>, <argument><expr><literal type="char">' '</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							<if_stmt><if>if <condition>(<expr><name>ptr</name></expr>)</condition><block type="pseudo"><block_content>
								<expr_stmt><expr><operator>*</operator><name>ptr</name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

							<expr_stmt><expr><call><name>pqSaveParameterStatus</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><literal type="string">"server_version"</literal></expr></argument>,
												  <argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						</block_content>}</block></if></if_stmt>

						<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<comment type="block">/* Keep reading until PQgetResult returns NULL */</comment>
					</block_content>}</block></if>
					<else>else
					<block>{<block_content>
						<comment type="block">/* Query finished, move to next */</comment>
						<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>setenv_state</name></name> <operator>=</operator> <name>SETENV_STATE_QUERY2_SEND</name></expr>;</expr_stmt>
					</block_content>}</block></else></if_stmt>
					<break>break;</break>
				</block_content>}</block>

			<case>case <expr><name>SETENV_STATE_QUERY2_SEND</name></expr>:</case>
				<block>{<block_content>
					<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>query</name></decl>;</decl_stmt>

					<comment type="block">/*
					 * pg_client_encoding does not exist in pre-7.2 servers.
					 * So we need to be prepared for an error here.  Do *not*
					 * start a transaction block, except in 7.3 servers where
					 * we need to prevent autocommit-off from starting a
					 * transaction anyway.
					 */</comment>
					<if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>sversion</name></name> <operator>&gt;=</operator> <literal type="number">70300</literal> <operator>&amp;&amp;</operator>
						<name><name>conn</name><operator>-&gt;</operator><name>sversion</name></name> <operator>&lt;</operator> <literal type="number">70400</literal></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><name>query</name> <operator>=</operator> <literal type="string">"begin; select pg_catalog.pg_client_encoding(); end"</literal></expr>;</expr_stmt></block_content></block></if>
					<else>else<block type="pseudo"><block_content>
						<expr_stmt><expr><name>query</name> <operator>=</operator> <literal type="string">"select pg_client_encoding()"</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>
					<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>PQsendQuery</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
						<goto>goto <name>error_return</name>;</goto></block_content></block></if></if_stmt>

					<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>setenv_state</name></name> <operator>=</operator> <name>SETENV_STATE_QUERY2_WAIT</name></expr>;</expr_stmt>
					<return>return <expr><name>PGRES_POLLING_READING</name></expr>;</return>
				</block_content>}</block>

			<case>case <expr><name>SETENV_STATE_QUERY2_WAIT</name></expr>:</case>
				<block>{<block_content>
					<if_stmt><if>if <condition>(<expr><call><name>PQisBusy</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
						<return>return <expr><name>PGRES_POLLING_READING</name></expr>;</return></block_content></block></if></if_stmt>

					<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>PQgetResult</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<if_stmt><if>if <condition>(<expr><name>res</name></expr>)</condition>
					<block>{<block_content>
						<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>val</name></decl>;</decl_stmt>

						<if_stmt><if>if <condition>(<expr><call><name>PQresultStatus</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>PGRES_COMMAND_OK</name></expr>)</condition>
						<block>{<block_content>
							<comment type="block">/* ignore begin/commit command results */</comment>
							<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							<continue>continue;</continue>
						</block_content>}</block></if></if_stmt>

						<if_stmt><if>if <condition>(<expr><call><name>PQresultStatus</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>PGRES_TUPLES_OK</name> <operator>&amp;&amp;</operator>
							<call><name>PQntuples</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal></expr>)</condition>
						<block>{<block_content>
							<comment type="block">/* Extract client encoding and save it */</comment>
							<expr_stmt><expr><name>val</name> <operator>=</operator> <call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							<if_stmt><if>if <condition>(<expr><name>val</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>val</name></expr>)</condition><block type="pseudo"><block_content>	<comment type="block">/* null should not happen, but */</comment>
								<expr_stmt><expr><call><name>pqSaveParameterStatus</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><literal type="string">"client_encoding"</literal></expr></argument>,
													  <argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
						</block_content>}</block></if>
						<else>else
						<block>{<block_content>
							<comment type="block">/*
							 * Error: presumably function not available, so
							 * use PGCLIENTENCODING or SQL_ASCII as the
							 * fallback.
							 */</comment>
							<expr_stmt><expr><name>val</name> <operator>=</operator> <call><name>getenv</name><argument_list>(<argument><expr><literal type="string">"PGCLIENTENCODING"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							<if_stmt><if>if <condition>(<expr><name>val</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>val</name></expr>)</condition><block type="pseudo"><block_content>
								<expr_stmt><expr><call><name>pqSaveParameterStatus</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><literal type="string">"client_encoding"</literal></expr></argument>,
													  <argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
							<else>else<block type="pseudo"><block_content>
								<expr_stmt><expr><call><name>pqSaveParameterStatus</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><literal type="string">"client_encoding"</literal></expr></argument>,
													  <argument><expr><literal type="string">"SQL_ASCII"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
						</block_content>}</block></else></if_stmt>

						<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<comment type="block">/* Keep reading until PQgetResult returns NULL */</comment>
					</block_content>}</block></if>
					<else>else
					<block>{<block_content>
						<comment type="block">/* Query finished, so we're done */</comment>
						<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>setenv_state</name></name> <operator>=</operator> <name>SETENV_STATE_IDLE</name></expr>;</expr_stmt>
						<return>return <expr><name>PGRES_POLLING_OK</name></expr>;</return>
					</block_content>}</block></else></if_stmt>
					<break>break;</break>
				</block_content>}</block>

			<default>default:</default>
				<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conn</name><operator>-&gt;</operator><name>errorMessage</name></name></expr></argument>,
								  <argument><expr><call><name>libpq_gettext</name><argument_list>(<argument><expr><literal type="string">"invalid state %c, "</literal>
												<literal type="string">"probably indicative of memory corruption\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
								  <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>setenv_state</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<goto>goto <name>error_return</name>;</goto>
		</block_content>}</block></switch>
	</block_content>}</block></for>

	<comment type="block">/* Unreachable */</comment>

<label><name>error_return</name>:</label>
	<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>setenv_state</name></name> <operator>=</operator> <name>SETENV_STATE_IDLE</name></expr>;</expr_stmt>
	<return>return <expr><name>PGRES_POLLING_FAILED</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * parseInput: if appropriate, parse input data from backend
 * until input is exhausted or a stopping state is reached.
 * Note that this function will NOT attempt to read more data from the backend.
 */</comment>
<function><type><name>void</name></type>
<name>pqParseInput2</name><parameter_list>(<parameter><decl><type><name>PGconn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name></type>		<name>id</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Loop to parse successive complete messages available in the buffer.
	 */</comment>
	<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
	<block>{<block_content>
		<comment type="block">/*
		 * Quit if in COPY_OUT state: we expect raw data from the server until
		 * PQendcopy is called.  Don't try to parse it according to the normal
		 * protocol.  (This is bogus.  The data lines ought to be part of the
		 * protocol and have identifying leading characters.)
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>asyncStatus</name></name> <operator>==</operator> <name>PGASYNC_COPY_OUT</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return;</return></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * OK to try to read a message type code.
		 */</comment>
		<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>inCursor</name></name> <operator>=</operator> <name><name>conn</name><operator>-&gt;</operator><name>inStart</name></name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>pqGetc</name><argument_list>(<argument><expr><operator>&amp;</operator><name>id</name></expr></argument>, <argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<return>return;</return></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * NOTIFY and NOTICE messages can happen in any state besides COPY
		 * OUT; always process them right away.
		 *
		 * Most other messages should only be processed while in BUSY state.
		 * (In particular, in READY state we hold off further parsing until
		 * the application collects the current PGresult.)
		 *
		 * However, if the state is IDLE then we got trouble; we need to deal
		 * with the unexpected message somehow.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>id</name> <operator>==</operator> <literal type="char">'A'</literal></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><call><name>getNotify</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<return>return;</return></block_content></block></if></if_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name>id</name> <operator>==</operator> <literal type="char">'N'</literal></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><call><name>pqGetErrorNotice2</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<return>return;</return></block_content></block></if></if_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>asyncStatus</name></name> <operator>!=</operator> <name>PGASYNC_BUSY</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* If not IDLE state, just wait ... */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>asyncStatus</name></name> <operator>!=</operator> <name>PGASYNC_IDLE</name></expr>)</condition><block type="pseudo"><block_content>
				<return>return;</return></block_content></block></if></if_stmt>

			<comment type="block">/*
			 * Unexpected message in IDLE state; need to recover somehow.
			 * ERROR messages are displayed using the notice processor;
			 * anything else is just dropped on the floor after displaying a
			 * suitable warning notice.  (An ERROR is very possibly the
			 * backend telling us why it is about to close the connection, so
			 * we don't want to just discard it...)
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name>id</name> <operator>==</operator> <literal type="char">'E'</literal></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><call><name>pqGetErrorNotice2</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>false</name></expr></argument> <comment type="block">/* treat as notice */</comment> )</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<return>return;</return></block_content></block></if></if_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<expr_stmt><expr><call><name>pqInternalNotice</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conn</name><operator>-&gt;</operator><name>noticeHooks</name></name></expr></argument>,
								 <argument><expr><literal type="string">"message type 0x%02x arrived from server while idle"</literal></expr></argument>,
								 <argument><expr><name>id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<comment type="block">/* Discard the unexpected message; good idea?? */</comment>
				<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>inStart</name></name> <operator>=</operator> <name><name>conn</name><operator>-&gt;</operator><name>inEnd</name></name></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/*
			 * In BUSY state, we can process everything.
			 */</comment>
			<switch>switch <condition>(<expr><name>id</name></expr>)</condition>
			<block>{<block_content>
				<case>case <expr><literal type="char">'C'</literal></expr>:</case>		<comment type="block">/* command complete */</comment>
					<if_stmt><if>if <condition>(<expr><call><name>pqGets</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conn</name><operator>-&gt;</operator><name>workBuffer</name></name></expr></argument>, <argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
						<return>return;</return></block_content></block></if></if_stmt>
					<if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>result</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>result</name></name> <operator>=</operator> <call><name>PQmakeEmptyPGresult</name><argument_list>(<argument><expr><name>conn</name></expr></argument>,
														   <argument><expr><name>PGRES_COMMAND_OK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>conn</name><operator>-&gt;</operator><name>result</name></name></expr>)</condition>
						<block>{<block_content>
							<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conn</name><operator>-&gt;</operator><name>errorMessage</name></name></expr></argument>,
											  <argument><expr><call><name>libpq_gettext</name><argument_list>(<argument><expr><literal type="string">"out of memory"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							<expr_stmt><expr><call><name>pqSaveErrorResult</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						</block_content>}</block></if></if_stmt>
					</block_content>}</block></if></if_stmt>
					<if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>result</name></name></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><call><name>strlcpy</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>result</name><operator>-&gt;</operator><name>cmdStatus</name></name></expr></argument>, <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>workBuffer</name><operator>.</operator><name>data</name></name></expr></argument>,
								<argument><expr><name>CMDSTATUS_LEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block></if></if_stmt>
					<expr_stmt><expr><call><name>checkXactStatus</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>workBuffer</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>asyncStatus</name></name> <operator>=</operator> <name>PGASYNC_READY</name></expr>;</expr_stmt>
					<break>break;</break>
				<case>case <expr><literal type="char">'E'</literal></expr>:</case>		<comment type="block">/* error return */</comment>
					<if_stmt><if>if <condition>(<expr><call><name>pqGetErrorNotice2</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
						<return>return;</return></block_content></block></if></if_stmt>
					<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>asyncStatus</name></name> <operator>=</operator> <name>PGASYNC_READY</name></expr>;</expr_stmt>
					<break>break;</break>
				<case>case <expr><literal type="char">'Z'</literal></expr>:</case>		<comment type="block">/* backend is ready for new query */</comment>
					<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>asyncStatus</name></name> <operator>=</operator> <name>PGASYNC_IDLE</name></expr>;</expr_stmt>
					<break>break;</break>
				<case>case <expr><literal type="char">'I'</literal></expr>:</case>		<comment type="block">/* empty query */</comment>
					<comment type="block">/* read and throw away the closing '\0' */</comment>
					<if_stmt><if>if <condition>(<expr><call><name>pqGetc</name><argument_list>(<argument><expr><operator>&amp;</operator><name>id</name></expr></argument>, <argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
						<return>return;</return></block_content></block></if></if_stmt>
					<if_stmt><if>if <condition>(<expr><name>id</name> <operator>!=</operator> <literal type="char">'\0'</literal></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>pqInternalNotice</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conn</name><operator>-&gt;</operator><name>noticeHooks</name></name></expr></argument>,
										 <argument><expr><literal type="string">"unexpected character %c following empty query response (\"I\" message)"</literal></expr></argument>,
										 <argument><expr><name>id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
					<if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>result</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>result</name></name> <operator>=</operator> <call><name>PQmakeEmptyPGresult</name><argument_list>(<argument><expr><name>conn</name></expr></argument>,
														   <argument><expr><name>PGRES_EMPTY_QUERY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>conn</name><operator>-&gt;</operator><name>result</name></name></expr>)</condition>
						<block>{<block_content>
							<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conn</name><operator>-&gt;</operator><name>errorMessage</name></name></expr></argument>,
											  <argument><expr><call><name>libpq_gettext</name><argument_list>(<argument><expr><literal type="string">"out of memory"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							<expr_stmt><expr><call><name>pqSaveErrorResult</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						</block_content>}</block></if></if_stmt>
					</block_content>}</block></if></if_stmt>
					<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>asyncStatus</name></name> <operator>=</operator> <name>PGASYNC_READY</name></expr>;</expr_stmt>
					<break>break;</break>
				<case>case <expr><literal type="char">'K'</literal></expr>:</case>		<comment type="block">/* secret key data from the backend */</comment>

					<comment type="block">/*
					 * This is expected only during backend startup, but it's
					 * just as easy to handle it as part of the main loop.
					 * Save the data and continue processing.
					 */</comment>
					<if_stmt><if>if <condition>(<expr><call><name>pqGetInt</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>conn</name><operator>-&gt;</operator><name>be_pid</name></name><operator>)</operator></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>, <argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
						<return>return;</return></block_content></block></if></if_stmt>
					<if_stmt><if>if <condition>(<expr><call><name>pqGetInt</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>conn</name><operator>-&gt;</operator><name>be_key</name></name><operator>)</operator></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>, <argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
						<return>return;</return></block_content></block></if></if_stmt>
					<break>break;</break>
				<case>case <expr><literal type="char">'P'</literal></expr>:</case>		<comment type="block">/* synchronous (normal) portal */</comment>
					<if_stmt><if>if <condition>(<expr><call><name>pqGets</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conn</name><operator>-&gt;</operator><name>workBuffer</name></name></expr></argument>, <argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
						<return>return;</return></block_content></block></if></if_stmt>
					<comment type="block">/* We pretty much ignore this message type... */</comment>
					<break>break;</break>
				<case>case <expr><literal type="char">'T'</literal></expr>:</case>		<comment type="block">/* row descriptions (start of query results) */</comment>
					<if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>result</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
					<block>{<block_content>
						<comment type="block">/* First 'T' in a query sequence */</comment>
						<if_stmt><if>if <condition>(<expr><call><name>getRowDescriptions</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
							<return>return;</return></block_content></block></if></if_stmt>
						<comment type="block">/* getRowDescriptions() moves inStart itself */</comment>
						<continue>continue;</continue>
					</block_content>}</block></if>
					<else>else
					<block>{<block_content>
						<comment type="block">/*
						 * A new 'T' message is treated as the start of
						 * another PGresult.  (It is not clear that this is
						 * really possible with the current backend.) We stop
						 * parsing until the application accepts the current
						 * result.
						 */</comment>
						<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>asyncStatus</name></name> <operator>=</operator> <name>PGASYNC_READY</name></expr>;</expr_stmt>
						<return>return;</return>
					</block_content>}</block></else></if_stmt>
					<break>break;</break>
				<case>case <expr><literal type="char">'D'</literal></expr>:</case>		<comment type="block">/* ASCII data tuple */</comment>
					<if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>result</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
					<block>{<block_content>
						<comment type="block">/* Read another tuple of a normal query response */</comment>
						<if_stmt><if>if <condition>(<expr><call><name>getAnotherTuple</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
							<return>return;</return></block_content></block></if></if_stmt>
						<comment type="block">/* getAnotherTuple() moves inStart itself */</comment>
						<continue>continue;</continue>
					</block_content>}</block></if>
					<else>else
					<block>{<block_content>
						<expr_stmt><expr><call><name>pqInternalNotice</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conn</name><operator>-&gt;</operator><name>noticeHooks</name></name></expr></argument>,
										 <argument><expr><literal type="string">"server sent data (\"D\" message) without prior row description (\"T\" message)"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<comment type="block">/* Discard the unexpected message; good idea?? */</comment>
						<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>inStart</name></name> <operator>=</operator> <name><name>conn</name><operator>-&gt;</operator><name>inEnd</name></name></expr>;</expr_stmt>
						<return>return;</return>
					</block_content>}</block></else></if_stmt>
					<break>break;</break>
				<case>case <expr><literal type="char">'B'</literal></expr>:</case>		<comment type="block">/* Binary data tuple */</comment>
					<if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>result</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
					<block>{<block_content>
						<comment type="block">/* Read another tuple of a normal query response */</comment>
						<if_stmt><if>if <condition>(<expr><call><name>getAnotherTuple</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
							<return>return;</return></block_content></block></if></if_stmt>
						<comment type="block">/* getAnotherTuple() moves inStart itself */</comment>
						<continue>continue;</continue>
					</block_content>}</block></if>
					<else>else
					<block>{<block_content>
						<expr_stmt><expr><call><name>pqInternalNotice</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conn</name><operator>-&gt;</operator><name>noticeHooks</name></name></expr></argument>,
										 <argument><expr><literal type="string">"server sent binary data (\"B\" message) without prior row description (\"T\" message)"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<comment type="block">/* Discard the unexpected message; good idea?? */</comment>
						<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>inStart</name></name> <operator>=</operator> <name><name>conn</name><operator>-&gt;</operator><name>inEnd</name></name></expr>;</expr_stmt>
						<return>return;</return>
					</block_content>}</block></else></if_stmt>
					<break>break;</break>
				<case>case <expr><literal type="char">'G'</literal></expr>:</case>		<comment type="block">/* Start Copy In */</comment>
					<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>asyncStatus</name></name> <operator>=</operator> <name>PGASYNC_COPY_IN</name></expr>;</expr_stmt>
					<break>break;</break>
				<case>case <expr><literal type="char">'H'</literal></expr>:</case>		<comment type="block">/* Start Copy Out */</comment>
					<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>asyncStatus</name></name> <operator>=</operator> <name>PGASYNC_COPY_OUT</name></expr>;</expr_stmt>
					<break>break;</break>

					<comment type="block">/*
					 * Don't need to process CopyBothResponse here because it
					 * never arrives from the server during protocol 2.0.
					 */</comment>
				<default>default:</default>
					<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conn</name><operator>-&gt;</operator><name>errorMessage</name></name></expr></argument>,
									  <argument><expr><call><name>libpq_gettext</name><argument_list>(
													<argument><expr><literal type="string">"unexpected response from server; first received character was \"%c\"\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
									  <argument><expr><name>id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<comment type="block">/* build an error result holding the error message */</comment>
					<expr_stmt><expr><call><name>pqSaveErrorResult</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<comment type="block">/* Discard the unexpected message; good idea?? */</comment>
					<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>inStart</name></name> <operator>=</operator> <name><name>conn</name><operator>-&gt;</operator><name>inEnd</name></name></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>asyncStatus</name></name> <operator>=</operator> <name>PGASYNC_READY</name></expr>;</expr_stmt>
					<return>return;</return>
			</block_content>}</block></switch>					<comment type="block">/* switch on protocol character */</comment>
		</block_content>}</block></else></if_stmt>
		<comment type="block">/* Successfully consumed this message */</comment>
		<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>inStart</name></name> <operator>=</operator> <name><name>conn</name><operator>-&gt;</operator><name>inCursor</name></name></expr>;</expr_stmt>
	</block_content>}</block></for>
</block_content>}</block></function>

<comment type="block">/*
 * parseInput subroutine to read a 'T' (row descriptions) message.
 * We build a PGresult structure containing the attribute data.
 * Returns: 0 if completed message, EOF if error or not enough data
 * received yet.
 *
 * Note that if we run out of data, we have to suspend and reprocess
 * the message after more data is received.  Otherwise, conn-&gt;inStart
 * must get advanced past the processed data.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>getRowDescriptions</name><parameter_list>(<parameter><decl><type><name>PGconn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>nfields</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>errmsg</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>PQmakeEmptyPGresult</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>PGRES_TUPLES_OK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>result</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>errmsg</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>			<comment type="block">/* means "out of memory", see below */</comment>
		<goto>goto <name>advance_and_error</name>;</goto>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* parseInput already read the 'T' label. */</comment>
	<comment type="block">/* the next two bytes are the number of fields	*/</comment>
	<if_stmt><if>if <condition>(<expr><call><name>pqGetInt</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>result</name><operator>-&gt;</operator><name>numAttributes</name></name><operator>)</operator></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<goto>goto <name>EOFexit</name>;</goto></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>nfields</name> <operator>=</operator> <name><name>result</name><operator>-&gt;</operator><name>numAttributes</name></name></expr>;</expr_stmt>

	<comment type="block">/* allocate space for the attribute descriptors */</comment>
	<if_stmt><if>if <condition>(<expr><name>nfields</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>attDescs</name></name> <operator>=</operator> <operator>(</operator><name>PGresAttDesc</name> <operator>*</operator><operator>)</operator>
			<call><name>pqResultAlloc</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>nfields</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>PGresAttDesc</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>result</name><operator>-&gt;</operator><name>attDescs</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>errmsg</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>		<comment type="block">/* means "out of memory", see below */</comment>
			<goto>goto <name>advance_and_error</name>;</goto>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><name><name>result</name><operator>-&gt;</operator><name>attDescs</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>nfields</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>PGresAttDesc</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* get type info */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nfields</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>typid</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>typlen</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>atttypmod</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>pqGets</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conn</name><operator>-&gt;</operator><name>workBuffer</name></name></expr></argument>, <argument><expr><name>conn</name></expr></argument>)</argument_list></call> <operator>||</operator>
			<call><name>pqGetInt</name><argument_list>(<argument><expr><operator>&amp;</operator><name>typid</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>, <argument><expr><name>conn</name></expr></argument>)</argument_list></call> <operator>||</operator>
			<call><name>pqGetInt</name><argument_list>(<argument><expr><operator>&amp;</operator><name>typlen</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>conn</name></expr></argument>)</argument_list></call> <operator>||</operator>
			<call><name>pqGetInt</name><argument_list>(<argument><expr><operator>&amp;</operator><name>atttypmod</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>, <argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<goto>goto <name>EOFexit</name>;</goto></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * Since pqGetInt treats 2-byte integers as unsigned, we need to
		 * coerce the result to signed form.
		 */</comment>
		<expr_stmt><expr><name>typlen</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator> <operator>(</operator><operator>(</operator><name>int16</name><operator>)</operator> <name>typlen</name><operator>)</operator></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>attDescs</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>name</name> <operator>=</operator> <call><name>pqResultStrdup</name><argument_list>(<argument><expr><name>result</name></expr></argument>,
												  <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>workBuffer</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>result</name><operator>-&gt;</operator><name>attDescs</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>name</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>errmsg</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>		<comment type="block">/* means "out of memory", see below */</comment>
			<goto>goto <name>advance_and_error</name>;</goto>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>attDescs</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>tableid</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>attDescs</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>columnid</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>attDescs</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>format</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>attDescs</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>typid</name> <operator>=</operator> <name>typid</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>attDescs</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>typlen</name> <operator>=</operator> <name>typlen</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>attDescs</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>atttypmod</name> <operator>=</operator> <name>atttypmod</name></expr>;</expr_stmt>
	</block_content>}</block></for>

	<comment type="block">/* Success! */</comment>
	<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>result</name></name> <operator>=</operator> <name>result</name></expr>;</expr_stmt>

	<comment type="block">/* Advance inStart to show that the "T" message has been processed. */</comment>
	<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>inStart</name></name> <operator>=</operator> <name><name>conn</name><operator>-&gt;</operator><name>inCursor</name></name></expr>;</expr_stmt>

	<comment type="block">/*
	 * We could perform additional setup for the new result set here, but for
	 * now there's nothing else to do.
	 */</comment>

	<comment type="block">/* And we're done. */</comment>
	<return>return <expr><literal type="number">0</literal></expr>;</return>

<label><name>advance_and_error</name>:</label>

	<comment type="block">/*
	 * Discard the failed message.  Unfortunately we don't know for sure where
	 * the end is, so just throw away everything in the input buffer. This is
	 * not very desirable but it's the best we can do in protocol v2.
	 */</comment>
	<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>inStart</name></name> <operator>=</operator> <name><name>conn</name><operator>-&gt;</operator><name>inEnd</name></name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Replace partially constructed result with an error result. First
	 * discard the old result to try to win back some memory.
	 */</comment>
	<expr_stmt><expr><call><name>pqClearAsyncResult</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If preceding code didn't provide an error message, assume "out of
	 * memory" was meant.  The advantage of having this special case is that
	 * freeing the old result first greatly improves the odds that gettext()
	 * will succeed in providing a translation.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>errmsg</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>errmsg</name> <operator>=</operator> <call><name>libpq_gettext</name><argument_list>(<argument><expr><literal type="string">"out of memory for query result"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conn</name><operator>-&gt;</operator><name>errorMessage</name></name></expr></argument>, <argument><expr><literal type="string">"%s\n"</literal></expr></argument>, <argument><expr><name>errmsg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * XXX: if PQmakeEmptyPGresult() fails, there's probably not much we can
	 * do to recover...
	 */</comment>
	<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>result</name></name> <operator>=</operator> <call><name>PQmakeEmptyPGresult</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>PGRES_FATAL_ERROR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>asyncStatus</name></name> <operator>=</operator> <name>PGASYNC_READY</name></expr>;</expr_stmt>

<label><name>EOFexit</name>:</label>
	<if_stmt><if>if <condition>(<expr><name>result</name> <operator>&amp;&amp;</operator> <name>result</name> <operator>!=</operator> <name><name>conn</name><operator>-&gt;</operator><name>result</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<return>return <expr><name>EOF</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * parseInput subroutine to read a 'B' or 'D' (row data) message.
 * We fill rowbuf with column pointers and then call the row processor.
 * Returns: 0 if completed message, EOF if error or not enough data
 * received yet.
 *
 * Note that if we run out of data, we have to suspend and reprocess
 * the message after more data is received.  Otherwise, conn-&gt;inStart
 * must get advanced past the processed data.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>getAnotherTuple</name><parameter_list>(<parameter><decl><type><name>PGconn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>binary</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier></type><name>result</name> <init>= <expr><name><name>conn</name><operator>-&gt;</operator><name>result</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>nfields</name> <init>= <expr><name><name>result</name><operator>-&gt;</operator><name>numAttributes</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>errmsg</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PGdataValue</name> <modifier>*</modifier></type><name>rowbuf</name></decl>;</decl_stmt>

	<comment type="block">/* the backend sends us a bitmap of which attributes are null */</comment>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>std_bitmap</name><index>[<expr><literal type="number">64</literal></expr>]</index></name></decl>;</decl_stmt> <comment type="block">/* used unless it doesn't fit */</comment>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>bitmap</name> <init>= <expr><name>std_bitmap</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>size_t</name></type>		<name>nbytes</name></decl>;</decl_stmt>			<comment type="block">/* the number of bytes in bitmap  */</comment>
	<decl_stmt><decl><type><name>char</name></type>		<name>bmap</name></decl>;</decl_stmt>			<comment type="block">/* One byte of the bitmap */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>bitmap_index</name></decl>;</decl_stmt>	<comment type="block">/* Its index */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>bitcnt</name></decl>;</decl_stmt>			<comment type="block">/* number of bits examined in current byte */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>vlen</name></decl>;</decl_stmt>			<comment type="block">/* length of the current field value */</comment>

	<comment type="block">/* Resize row buffer if needed */</comment>
	<expr_stmt><expr><name>rowbuf</name> <operator>=</operator> <name><name>conn</name><operator>-&gt;</operator><name>rowBuf</name></name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>nfields</name> <operator>&gt;</operator> <name><name>conn</name><operator>-&gt;</operator><name>rowBufLen</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>rowbuf</name> <operator>=</operator> <operator>(</operator><name>PGdataValue</name> <operator>*</operator><operator>)</operator> <call><name>realloc</name><argument_list>(<argument><expr><name>rowbuf</name></expr></argument>,
										 <argument><expr><name>nfields</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>PGdataValue</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>rowbuf</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>errmsg</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>		<comment type="block">/* means "out of memory", see below */</comment>
			<goto>goto <name>advance_and_error</name>;</goto>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>rowBuf</name></name> <operator>=</operator> <name>rowbuf</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>rowBufLen</name></name> <operator>=</operator> <name>nfields</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Save format specifier */</comment>
	<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>binary</name></name> <operator>=</operator> <name>binary</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * If it's binary, fix the column format indicators.  We assume the
	 * backend will consistently send either B or D, not a mix.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>binary</name></expr>)</condition>
	<block>{<block_content>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nfields</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>attDescs</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>format</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></for>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Get the null-value bitmap */</comment>
	<expr_stmt><expr><name>nbytes</name> <operator>=</operator> <operator>(</operator><name>nfields</name> <operator>+</operator> <name>BITS_PER_BYTE</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator> <operator>/</operator> <name>BITS_PER_BYTE</name></expr>;</expr_stmt>
	<comment type="block">/* malloc() only for unusually large field counts... */</comment>
	<if_stmt><if>if <condition>(<expr><name>nbytes</name> <operator>&gt;</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>std_bitmap</name></expr></argument>)</argument_list></sizeof></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>bitmap</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>malloc</name><argument_list>(<argument><expr><name>nbytes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>bitmap</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>errmsg</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>		<comment type="block">/* means "out of memory", see below */</comment>
			<goto>goto <name>advance_and_error</name>;</goto>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>pqGetnchar</name><argument_list>(<argument><expr><name>bitmap</name></expr></argument>, <argument><expr><name>nbytes</name></expr></argument>, <argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<goto>goto <name>EOFexit</name>;</goto></block_content></block></if></if_stmt>

	<comment type="block">/* Scan the fields */</comment>
	<expr_stmt><expr><name>bitmap_index</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>bmap</name> <operator>=</operator> <name><name>bitmap</name><index>[<expr><name>bitmap_index</name></expr>]</index></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>bitcnt</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nfields</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<comment type="block">/* get the value length */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>bmap</name> <operator>&amp;</operator> <literal type="number">0200</literal><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>vlen</name> <operator>=</operator> <name>NULL_LEN</name></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><call><name>pqGetInt</name><argument_list>(<argument><expr><operator>&amp;</operator><name>vlen</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>, <argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<goto>goto <name>EOFexit</name>;</goto></block_content></block></if>
		<else>else
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>binary</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>vlen</name> <operator>=</operator> <name>vlen</name> <operator>-</operator> <literal type="number">4</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><name>vlen</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>vlen</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></else></if_stmt>
		<expr_stmt><expr><name><name>rowbuf</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>len</name> <operator>=</operator> <name>vlen</name></expr>;</expr_stmt>

		<comment type="block">/*
		 * rowbuf[i].value always points to the next address in the data
		 * buffer even if the value is NULL.  This allows row processors to
		 * estimate data sizes more easily.
		 */</comment>
		<expr_stmt><expr><name><name>rowbuf</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>value</name> <operator>=</operator> <name><name>conn</name><operator>-&gt;</operator><name>inBuffer</name></name> <operator>+</operator> <name><name>conn</name><operator>-&gt;</operator><name>inCursor</name></name></expr>;</expr_stmt>

		<comment type="block">/* Skip over the data value */</comment>
		<if_stmt><if>if <condition>(<expr><name>vlen</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><call><name>pqSkipnchar</name><argument_list>(<argument><expr><name>vlen</name></expr></argument>, <argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<goto>goto <name>EOFexit</name>;</goto></block_content></block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* advance the bitmap stuff */</comment>
		<expr_stmt><expr><name>bitcnt</name><operator>++</operator></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>bitcnt</name> <operator>==</operator> <name>BITS_PER_BYTE</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>bitmap_index</name><operator>++</operator></expr>;</expr_stmt>
			<expr_stmt><expr><name>bmap</name> <operator>=</operator> <name><name>bitmap</name><index>[<expr><name>bitmap_index</name></expr>]</index></name></expr>;</expr_stmt>
			<expr_stmt><expr><name>bitcnt</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>bmap</name> <operator>&lt;&lt;=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></for>

	<comment type="block">/* Release bitmap now if we allocated it */</comment>
	<if_stmt><if>if <condition>(<expr><name>bitmap</name> <operator>!=</operator> <name>std_bitmap</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>bitmap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>bitmap</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<comment type="block">/* Advance inStart to show that the "D" message has been processed. */</comment>
	<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>inStart</name></name> <operator>=</operator> <name><name>conn</name><operator>-&gt;</operator><name>inCursor</name></name></expr>;</expr_stmt>

	<comment type="block">/* Process the collected row */</comment>
	<expr_stmt><expr><name>errmsg</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>pqRowProcessor</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>errmsg</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>				<comment type="block">/* normal, successful exit */</comment>

	<goto>goto <name>set_error_result</name>;</goto>		<comment type="block">/* pqRowProcessor failed, report it */</comment>

<label><name>advance_and_error</name>:</label>

	<comment type="block">/*
	 * Discard the failed message.  Unfortunately we don't know for sure where
	 * the end is, so just throw away everything in the input buffer. This is
	 * not very desirable but it's the best we can do in protocol v2.
	 */</comment>
	<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>inStart</name></name> <operator>=</operator> <name><name>conn</name><operator>-&gt;</operator><name>inEnd</name></name></expr>;</expr_stmt>

<label><name>set_error_result</name>:</label>

	<comment type="block">/*
	 * Replace partially constructed result with an error result. First
	 * discard the old result to try to win back some memory.
	 */</comment>
	<expr_stmt><expr><call><name>pqClearAsyncResult</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If preceding code didn't provide an error message, assume "out of
	 * memory" was meant.  The advantage of having this special case is that
	 * freeing the old result first greatly improves the odds that gettext()
	 * will succeed in providing a translation.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>errmsg</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>errmsg</name> <operator>=</operator> <call><name>libpq_gettext</name><argument_list>(<argument><expr><literal type="string">"out of memory for query result"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conn</name><operator>-&gt;</operator><name>errorMessage</name></name></expr></argument>, <argument><expr><literal type="string">"%s\n"</literal></expr></argument>, <argument><expr><name>errmsg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * XXX: if PQmakeEmptyPGresult() fails, there's probably not much we can
	 * do to recover...
	 */</comment>
	<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>result</name></name> <operator>=</operator> <call><name>PQmakeEmptyPGresult</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>PGRES_FATAL_ERROR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>asyncStatus</name></name> <operator>=</operator> <name>PGASYNC_READY</name></expr>;</expr_stmt>

<label><name>EOFexit</name>:</label>
	<if_stmt><if>if <condition>(<expr><name>bitmap</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name>bitmap</name> <operator>!=</operator> <name>std_bitmap</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>bitmap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<return>return <expr><name>EOF</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * Attempt to read an Error or Notice response message.
 * This is possible in several places, so we break it out as a subroutine.
 * Entry: 'E' or 'N' message type has already been consumed.
 * Exit: returns 0 if successfully consumed message.
 *		 returns EOF if not enough data.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>pqGetErrorNotice2</name><parameter_list>(<parameter><decl><type><name>PGconn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>isError</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier></type><name>res</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PQExpBufferData</name></type> <name>workBuf</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>startp</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>splitp</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * If this is an error message, pre-emptively clear any incomplete query
	 * result we may have.  We'd just throw it away below anyway, and
	 * releasing it before collecting the error might avoid out-of-memory.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>isError</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>pqClearAsyncResult</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Since the message might be pretty long, we create a temporary
	 * PQExpBuffer rather than using conn-&gt;workBuffer.  workBuffer is intended
	 * for stuff that is expected to be short.
	 */</comment>
	<expr_stmt><expr><call><name>initPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>workBuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>pqGets</name><argument_list>(<argument><expr><operator>&amp;</operator><name>workBuf</name></expr></argument>, <argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<goto>goto <name>failure</name>;</goto></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Make a PGresult to hold the message.  We temporarily lie about the
	 * result status, so that PQmakeEmptyPGresult doesn't uselessly copy
	 * conn-&gt;errorMessage.
	 *
	 * NB: This allocation can fail, if you run out of memory. The rest of the
	 * function handles that gracefully, and we still try to set the error
	 * message as the connection's error message.
	 */</comment>
	<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>PQmakeEmptyPGresult</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>PGRES_EMPTY_QUERY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>res</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>res</name><operator>-&gt;</operator><name>resultStatus</name></name> <operator>=</operator> <ternary><condition><expr><name>isError</name></expr> ?</condition><then> <expr><name>PGRES_FATAL_ERROR</name></expr> </then><else>: <expr><name>PGRES_NONFATAL_ERROR</name></expr></else></ternary></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>res</name><operator>-&gt;</operator><name>errMsg</name></name> <operator>=</operator> <call><name>pqResultStrdup</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name><name>workBuf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Break the message into fields.  We can't do very much here, but we can
	 * split the severity code off, and remove trailing newlines. Also, we use
	 * the heuristic that the primary message extends only to the first
	 * newline --- anything after that is detail message.  (In some cases it'd
	 * be better classed as hint, but we can hardly be expected to guess that
	 * here.)
	 */</comment>
	<while>while <condition>(<expr><name><name>workBuf</name><operator>.</operator><name>len</name></name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>workBuf</name><operator>.</operator><name>data</name><index>[<expr><name><name>workBuf</name><operator>.</operator><name>len</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'\n'</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>workBuf</name><operator>.</operator><name>data</name><index>[<expr><operator>--</operator><name><name>workBuf</name><operator>.</operator><name>len</name></name></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt></block_content></block></while>
	<expr_stmt><expr><name>splitp</name> <operator>=</operator> <call><name>strstr</name><argument_list>(<argument><expr><name><name>workBuf</name><operator>.</operator><name>data</name></name></expr></argument>, <argument><expr><literal type="string">":  "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>splitp</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* what comes before the colon is severity */</comment>
		<expr_stmt><expr><operator>*</operator><name>splitp</name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pqSaveMessageField</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>PG_DIAG_SEVERITY</name></expr></argument>, <argument><expr><name><name>workBuf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>startp</name> <operator>=</operator> <name>splitp</name> <operator>+</operator> <literal type="number">3</literal></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* can't find a colon?  oh well... */</comment>
		<expr_stmt><expr><name>startp</name> <operator>=</operator> <name><name>workBuf</name><operator>.</operator><name>data</name></name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
	<expr_stmt><expr><name>splitp</name> <operator>=</operator> <call><name>strchr</name><argument_list>(<argument><expr><name>startp</name></expr></argument>, <argument><expr><literal type="char">'\n'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>splitp</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* what comes before the newline is primary message */</comment>
		<expr_stmt><expr><operator>*</operator><name>splitp</name><operator>++</operator> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pqSaveMessageField</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>PG_DIAG_MESSAGE_PRIMARY</name></expr></argument>, <argument><expr><name>startp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* the rest is detail; strip any leading whitespace */</comment>
		<while>while <condition>(<expr><operator>*</operator><name>splitp</name> <operator>&amp;&amp;</operator> <call><name>isspace</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator> <operator>*</operator><name>splitp</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>splitp</name><operator>++</operator></expr>;</expr_stmt></block_content></block></while>
		<expr_stmt><expr><call><name>pqSaveMessageField</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>PG_DIAG_MESSAGE_DETAIL</name></expr></argument>, <argument><expr><name>splitp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* single-line message, so all primary */</comment>
		<expr_stmt><expr><call><name>pqSaveMessageField</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>PG_DIAG_MESSAGE_PRIMARY</name></expr></argument>, <argument><expr><name>startp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/*
	 * Either save error as current async result, or just emit the notice.
	 * Also, if it's an error and we were in a transaction block, assume the
	 * server has now gone to error-in-transaction state.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>isError</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>pqClearAsyncResult</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>	<comment type="block">/* redundant, but be safe */</comment>
		<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>result</name></name> <operator>=</operator> <name>res</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>resetPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conn</name><operator>-&gt;</operator><name>errorMessage</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>res</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>PQExpBufferDataBroken</name><argument_list>(<argument><expr><name>workBuf</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name><name>res</name><operator>-&gt;</operator><name>errMsg</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conn</name><operator>-&gt;</operator><name>errorMessage</name></name></expr></argument>, <argument><expr><name><name>res</name><operator>-&gt;</operator><name>errMsg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conn</name><operator>-&gt;</operator><name>errorMessage</name></name></expr></argument>,
							  <argument><expr><call><name>libpq_gettext</name><argument_list>(<argument><expr><literal type="string">"out of memory"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>xactStatus</name></name> <operator>==</operator> <name>PQTRANS_INTRANS</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>xactStatus</name></name> <operator>=</operator> <name>PQTRANS_INERROR</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>res</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name><name>res</name><operator>-&gt;</operator><name>noticeHooks</name><operator>.</operator><name>noticeRec</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name><name>res</name><operator>-&gt;</operator><name>noticeHooks</name><operator>.</operator><name>noticeRec</name></name><argument_list>(<argument><expr><name><name>res</name><operator>-&gt;</operator><name>noticeHooks</name><operator>.</operator><name>noticeRecArg</name></name></expr></argument>, <argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><call><name>termPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>workBuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><literal type="number">0</literal></expr>;</return>

<label><name>failure</name>:</label>
	<if_stmt><if>if <condition>(<expr><name>res</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><call><name>termPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>workBuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>EOF</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * checkXactStatus - attempt to track transaction-block status of server
 *
 * This is called each time we receive a command-complete message.  By
 * watching for messages from BEGIN/COMMIT/ROLLBACK commands, we can do
 * a passable job of tracking the server's xact status.  BUT: this does
 * not work at all on 7.3 servers with AUTOCOMMIT OFF.  (Man, was that
 * feature ever a mistake.)  Caveat user.
 *
 * The tags known here are all those used as far back as 7.0; is it worth
 * adding those from even-older servers?
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>checkXactStatus</name><parameter_list>(<parameter><decl><type><name>PGconn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>cmdTag</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>cmdTag</name></expr></argument>, <argument><expr><literal type="string">"BEGIN"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>xactStatus</name></name> <operator>=</operator> <name>PQTRANS_INTRANS</name></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>cmdTag</name></expr></argument>, <argument><expr><literal type="string">"COMMIT"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>xactStatus</name></name> <operator>=</operator> <name>PQTRANS_IDLE</name></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>cmdTag</name></expr></argument>, <argument><expr><literal type="string">"ROLLBACK"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>xactStatus</name></name> <operator>=</operator> <name>PQTRANS_IDLE</name></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>cmdTag</name></expr></argument>, <argument><expr><literal type="string">"START TRANSACTION"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>	<comment type="block">/* 7.3 only */</comment>
		<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>xactStatus</name></name> <operator>=</operator> <name>PQTRANS_INTRANS</name></expr>;</expr_stmt></block_content></block></if>

	<comment type="block">/*
	 * Normally we get into INERROR state by detecting an Error message.
	 * However, if we see one of these tags then we know for sure the server
	 * is in abort state ...
	 */</comment>
	<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>cmdTag</name></expr></argument>, <argument><expr><literal type="string">"*ABORT STATE*"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>	<comment type="block">/* pre-7.3 only */</comment>
		<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>xactStatus</name></name> <operator>=</operator> <name>PQTRANS_INERROR</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Attempt to read a Notify response message.
 * This is possible in several places, so we break it out as a subroutine.
 * Entry: 'A' message type and length have already been consumed.
 * Exit: returns 0 if successfully consumed Notify message.
 *		 returns EOF if not enough data.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>getNotify</name><parameter_list>(<parameter><decl><type><name>PGconn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>be_pid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>nmlen</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PGnotify</name>   <modifier>*</modifier></type><name>newNotify</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>pqGetInt</name><argument_list>(<argument><expr><operator>&amp;</operator><name>be_pid</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>, <argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>EOF</name></expr>;</return></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>pqGets</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conn</name><operator>-&gt;</operator><name>workBuffer</name></name></expr></argument>, <argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>EOF</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Store the relation name right after the PQnotify structure so it can
	 * all be freed at once.  We don't use NAMEDATALEN because we don't want
	 * to tie this interface to a specific server name length.
	 */</comment>
	<expr_stmt><expr><name>nmlen</name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>workBuffer</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>newNotify</name> <operator>=</operator> <operator>(</operator><name>PGnotify</name> <operator>*</operator><operator>)</operator> <call><name>malloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>PGnotify</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <name>nmlen</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>newNotify</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>newNotify</name><operator>-&gt;</operator><name>relname</name></name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>newNotify</name> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>PGnotify</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name><name>newNotify</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>, <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>workBuffer</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* fake up an empty-string extra field */</comment>
		<expr_stmt><expr><name><name>newNotify</name><operator>-&gt;</operator><name>extra</name></name> <operator>=</operator> <name><name>newNotify</name><operator>-&gt;</operator><name>relname</name></name> <operator>+</operator> <name>nmlen</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>newNotify</name><operator>-&gt;</operator><name>be_pid</name></name> <operator>=</operator> <name>be_pid</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>newNotify</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>notifyTail</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>notifyTail</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name>newNotify</name></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>notifyHead</name></name> <operator>=</operator> <name>newNotify</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
		<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>notifyTail</name></name> <operator>=</operator> <name>newNotify</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * PQgetCopyData - read a row of data from the backend during COPY OUT
 *
 * If successful, sets *buffer to point to a malloc'd row of data, and
 * returns row length (always &gt; 0) as result.
 * Returns 0 if no row available yet (only possible if async is true),
 * -1 if end of copy (consult PQgetResult), or -2 if error (consult
 * PQerrorMessage).
 */</comment>
<function><type><name>int</name></type>
<name>pqGetCopyData2</name><parameter_list>(<parameter><decl><type><name>PGconn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>buffer</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>async</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type>		<name>found</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>msgLength</name></decl>;</decl_stmt>

	<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
	<block>{<block_content>
		<comment type="block">/*
		 * Do we have a complete line of data?
		 */</comment>
		<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>inCursor</name></name> <operator>=</operator> <name><name>conn</name><operator>-&gt;</operator><name>inStart</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>found</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<while>while <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>inCursor</name></name> <operator>&lt;</operator> <name><name>conn</name><operator>-&gt;</operator><name>inEnd</name></name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>char</name></type>		<name>c</name> <init>= <expr><name><name>conn</name><operator>-&gt;</operator><name>inBuffer</name><index>[<expr><name><name>conn</name><operator>-&gt;</operator><name>inCursor</name></name><operator>++</operator></expr>]</index></name></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name>c</name> <operator>==</operator> <literal type="char">'\n'</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>found</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></while>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>found</name></expr>)</condition><block type="pseudo"><block_content>
			<goto>goto <name>nodata</name>;</goto></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>msgLength</name> <operator>=</operator> <name><name>conn</name><operator>-&gt;</operator><name>inCursor</name></name> <operator>-</operator> <name><name>conn</name><operator>-&gt;</operator><name>inStart</name></name></expr>;</expr_stmt>

		<comment type="block">/*
		 * If it's the end-of-data marker, consume it, exit COPY_OUT mode, and
		 * let caller read status with PQgetResult().
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>msgLength</name> <operator>==</operator> <literal type="number">3</literal> <operator>&amp;&amp;</operator>
			<call><name>strncmp</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conn</name><operator>-&gt;</operator><name>inBuffer</name><index>[<expr><name><name>conn</name><operator>-&gt;</operator><name>inStart</name></name></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"\\.\n"</literal></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>inStart</name></name> <operator>=</operator> <name><name>conn</name><operator>-&gt;</operator><name>inCursor</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>asyncStatus</name></name> <operator>=</operator> <name>PGASYNC_BUSY</name></expr>;</expr_stmt>
			<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * Pass the line back to the caller.
		 */</comment>
		<expr_stmt><expr><operator>*</operator><name>buffer</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>malloc</name><argument_list>(<argument><expr><name>msgLength</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>*</operator><name>buffer</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conn</name><operator>-&gt;</operator><name>errorMessage</name></name></expr></argument>,
							  <argument><expr><call><name>libpq_gettext</name><argument_list>(<argument><expr><literal type="string">"out of memory\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><operator>-</operator><literal type="number">2</literal></expr>;</return>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>*</operator><name>buffer</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>conn</name><operator>-&gt;</operator><name>inBuffer</name><index>[<expr><name><name>conn</name><operator>-&gt;</operator><name>inStart</name></name></expr>]</index></name></expr></argument>, <argument><expr><name>msgLength</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><operator>(</operator><operator>*</operator><name>buffer</name><operator>)</operator><index>[<expr><name>msgLength</name></expr>]</index> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>	<comment type="block">/* Add terminating null */</comment>

		<comment type="block">/* Mark message consumed */</comment>
		<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>inStart</name></name> <operator>=</operator> <name><name>conn</name><operator>-&gt;</operator><name>inCursor</name></name></expr>;</expr_stmt>

		<return>return <expr><name>msgLength</name></expr>;</return>

<label><name>nodata</name>:</label>
		<comment type="block">/* Don't block if async read requested */</comment>
		<if_stmt><if>if <condition>(<expr><name>async</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
		<comment type="block">/* Need to load more data */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>pqWait</name><argument_list>(<argument><expr><name>true</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>conn</name></expr></argument>)</argument_list></call> <operator>||</operator>
			<call><name>pqReadData</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><operator>-</operator><literal type="number">2</literal></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></for>
</block_content>}</block></function>


<comment type="block">/*
 * PQgetline - gets a newline-terminated string from the backend.
 *
 * See fe-exec.c for documentation.
 */</comment>
<function><type><name>int</name></type>
<name>pqGetline2</name><parameter_list>(<parameter><decl><type><name>PGconn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>s</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>maxlen</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>result</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>		<comment type="block">/* return value if buffer overflows */</comment>

	<if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>sock</name></name> <operator>==</operator> <name>PGINVALID_SOCKET</name> <operator>||</operator>
		<name><name>conn</name><operator>-&gt;</operator><name>asyncStatus</name></name> <operator>!=</operator> <name>PGASYNC_COPY_OUT</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><operator>*</operator><name>s</name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
		<return>return <expr><name>EOF</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Since this is a purely synchronous routine, we don't bother to maintain
	 * conn-&gt;inCursor; there is no need to back up.
	 */</comment>
	<while>while <condition>(<expr><name>maxlen</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>inStart</name></name> <operator>&lt;</operator> <name><name>conn</name><operator>-&gt;</operator><name>inEnd</name></name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>char</name></type>		<name>c</name> <init>= <expr><name><name>conn</name><operator>-&gt;</operator><name>inBuffer</name><index>[<expr><name><name>conn</name><operator>-&gt;</operator><name>inStart</name></name><operator>++</operator></expr>]</index></name></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name>c</name> <operator>==</operator> <literal type="char">'\n'</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>result</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>		<comment type="block">/* success exit */</comment>
				<break>break;</break>
			</block_content>}</block></if></if_stmt>
			<expr_stmt><expr><operator>*</operator><name>s</name><operator>++</operator> <operator>=</operator> <name>c</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>maxlen</name><operator>--</operator></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/* need to load more data */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>pqWait</name><argument_list>(<argument><expr><name>true</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>conn</name></expr></argument>)</argument_list></call> <operator>||</operator>
				<call><name>pqReadData</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>result</name> <operator>=</operator> <name>EOF</name></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></while>
	<expr_stmt><expr><operator>*</operator><name>s</name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * PQgetlineAsync - gets a COPY data row without blocking.
 *
 * See fe-exec.c for documentation.
 */</comment>
<function><type><name>int</name></type>
<name>pqGetlineAsync2</name><parameter_list>(<parameter><decl><type><name>PGconn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>buffer</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>bufsize</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>avail</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>asyncStatus</name></name> <operator>!=</operator> <name>PGASYNC_COPY_OUT</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>				<comment type="block">/* we are not doing a copy... */</comment>

	<comment type="block">/*
	 * Move data from libpq's buffer to the caller's. We want to accept data
	 * only in units of whole lines, not partial lines.  This ensures that we
	 * can recognize the terminator line "\\.\n".  (Otherwise, if it happened
	 * to cross a packet/buffer boundary, we might hand the first one or two
	 * characters off to the caller, which we shouldn't.)
	 */</comment>

	<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>inCursor</name></name> <operator>=</operator> <name><name>conn</name><operator>-&gt;</operator><name>inStart</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><name>avail</name> <operator>=</operator> <name>bufsize</name></expr>;</expr_stmt>
	<while>while <condition>(<expr><name>avail</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>conn</name><operator>-&gt;</operator><name>inCursor</name></name> <operator>&lt;</operator> <name><name>conn</name><operator>-&gt;</operator><name>inEnd</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name></type>		<name>c</name> <init>= <expr><name><name>conn</name><operator>-&gt;</operator><name>inBuffer</name><index>[<expr><name><name>conn</name><operator>-&gt;</operator><name>inCursor</name></name><operator>++</operator></expr>]</index></name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><operator>*</operator><name>buffer</name><operator>++</operator> <operator>=</operator> <name>c</name></expr>;</expr_stmt>
		<expr_stmt><expr><operator>--</operator><name>avail</name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>c</name> <operator>==</operator> <literal type="char">'\n'</literal></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Got a complete line; mark the data removed from libpq */</comment>
			<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>inStart</name></name> <operator>=</operator> <name><name>conn</name><operator>-&gt;</operator><name>inCursor</name></name></expr>;</expr_stmt>
			<comment type="block">/* Is it the endmarker line? */</comment>
			<if_stmt><if>if <condition>(<expr><name>bufsize</name> <operator>-</operator> <name>avail</name> <operator>==</operator> <literal type="number">3</literal> <operator>&amp;&amp;</operator> <name><name>buffer</name><index>[<expr><operator>-</operator><literal type="number">3</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'\\'</literal> <operator>&amp;&amp;</operator> <name><name>buffer</name><index>[<expr><operator>-</operator><literal type="number">2</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'.'</literal></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
			<comment type="block">/* No, return the data line to the caller */</comment>
			<return>return <expr><name>bufsize</name> <operator>-</operator> <name>avail</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></while>

	<comment type="block">/*
	 * We don't have a complete line. We'd prefer to leave it in libpq's
	 * buffer until the rest arrives, but there is a special case: what if the
	 * line is longer than the buffer the caller is offering us?  In that case
	 * we'd better hand over a partial line, else we'd get into an infinite
	 * loop. Do this in a way that ensures we can't misrecognize a terminator
	 * line later: leave last 3 characters in libpq buffer.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>avail</name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>bufsize</name> <operator>&gt;</operator> <literal type="number">3</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>inStart</name></name> <operator>=</operator> <name><name>conn</name><operator>-&gt;</operator><name>inCursor</name></name> <operator>-</operator> <literal type="number">3</literal></expr>;</expr_stmt>
		<return>return <expr><name>bufsize</name> <operator>-</operator> <literal type="number">3</literal></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * PQendcopy
 *
 * See fe-exec.c for documentation.
 */</comment>
<function><type><name>int</name></type>
<name>pqEndcopy2</name><parameter_list>(<parameter><decl><type><name>PGconn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>asyncStatus</name></name> <operator>!=</operator> <name>PGASYNC_COPY_IN</name> <operator>&amp;&amp;</operator>
		<name><name>conn</name><operator>-&gt;</operator><name>asyncStatus</name></name> <operator>!=</operator> <name>PGASYNC_COPY_OUT</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conn</name><operator>-&gt;</operator><name>errorMessage</name></name></expr></argument>,
						  <argument><expr><call><name>libpq_gettext</name><argument_list>(<argument><expr><literal type="string">"no COPY in progress\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><literal type="number">1</literal></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * make sure no data is waiting to be sent, abort if we are non-blocking
	 * and the flush fails
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>pqFlush</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>pqIsnonblocking</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* non blocking connections may have to abort at this point. */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>pqIsnonblocking</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>PQisBusy</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* Return to active duty */</comment>
	<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>asyncStatus</name></name> <operator>=</operator> <name>PGASYNC_BUSY</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>resetPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conn</name><operator>-&gt;</operator><name>errorMessage</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Wait for the completion response */</comment>
	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>PQgetResult</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Expecting a successful result */</comment>
	<if_stmt><if>if <condition>(<expr><name>result</name> <operator>&amp;&amp;</operator> <name><name>result</name><operator>-&gt;</operator><name>resultStatus</name></name> <operator>==</operator> <name>PGRES_COMMAND_OK</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><literal type="number">0</literal></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Trouble. For backwards-compatibility reasons, we issue the error
	 * message as if it were a notice (would be nice to get rid of this
	 * silliness, but too many apps probably don't handle errors from
	 * PQendcopy reasonably).  Note that the app can still obtain the error
	 * status from the PGconn object.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>errorMessage</name><operator>.</operator><name>len</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* We have to strip the trailing newline ... pain in neck... */</comment>
		<decl_stmt><decl><type><name>char</name></type>		<name>svLast</name> <init>= <expr><name><name>conn</name><operator>-&gt;</operator><name>errorMessage</name><operator>.</operator><name>data</name><index>[<expr><name><name>conn</name><operator>-&gt;</operator><name>errorMessage</name><operator>.</operator><name>len</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>svLast</name> <operator>==</operator> <literal type="char">'\n'</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>errorMessage</name><operator>.</operator><name>data</name><index>[<expr><name><name>conn</name><operator>-&gt;</operator><name>errorMessage</name><operator>.</operator><name>len</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>pqInternalNotice</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conn</name><operator>-&gt;</operator><name>noticeHooks</name></name></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>errorMessage</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>errorMessage</name><operator>.</operator><name>data</name><index>[<expr><name><name>conn</name><operator>-&gt;</operator><name>errorMessage</name><operator>.</operator><name>len</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>svLast</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * The worst case is that we've lost sync with the backend entirely due to
	 * application screwup of the copy in/out protocol. To recover, reset the
	 * connection (talk about using a sledgehammer...)
	 */</comment>
	<expr_stmt><expr><call><name>pqInternalNotice</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conn</name><operator>-&gt;</operator><name>noticeHooks</name></name></expr></argument>,
					 <argument><expr><literal type="string">"lost synchronization with server, resetting connection"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Users doing non-blocking connections need to handle the reset
	 * themselves, they'll need to check the connection status if we return an
	 * error.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>pqIsnonblocking</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PQresetStart</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PQreset</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * PQfn - Send a function call to the POSTGRES backend.
 *
 * See fe-exec.c for documentation.
 */</comment>
<function><type><name>PGresult</name> <modifier>*</modifier></type>
<name>pqFunctionCall2</name><parameter_list>(<parameter><decl><type><name>PGconn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>fnid</name></decl></parameter>,
				<parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>result_buf</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>actual_result_len</name></decl></parameter>,
				<parameter><decl><type><name>int</name></type> <name>result_is_int</name></decl></parameter>,
				<parameter><decl><type><specifier>const</specifier> <name>PQArgBlock</name> <modifier>*</modifier></type><name>args</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nargs</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type>		<name>needInput</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ExecStatusType</name></type> <name>status</name> <init>= <expr><name>PGRES_FATAL_ERROR</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name>id</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<comment type="block">/* PQfn already validated connection state */</comment>

	<if_stmt><if>if <condition>(<expr><call><name>pqPutMsgStart</name><argument_list>(<argument><expr><literal type="char">'F'</literal></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>conn</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator>	<comment type="block">/* function call msg */</comment>
		<call><name>pqPuts</name><argument_list>(<argument><expr><literal type="string">" "</literal></expr></argument>, <argument><expr><name>conn</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator>	<comment type="block">/* dummy string */</comment>
		<call><name>pqPutInt</name><argument_list>(<argument><expr><name>fnid</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>, <argument><expr><name>conn</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal> <operator>||</operator> <comment type="block">/* function id */</comment>
		<call><name>pqPutInt</name><argument_list>(<argument><expr><name>nargs</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>, <argument><expr><name>conn</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>	<comment type="block">/* # of args */</comment>
	<block>{<block_content>
		<expr_stmt><expr><call><name>pqHandleSendFailure</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nargs</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control>
	<block>{<block_content>							<comment type="block">/* len.int4 + contents	   */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>pqPutInt</name><argument_list>(<argument><expr><name><name>args</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>len</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>, <argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>pqHandleSendFailure</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>NULL</name></expr>;</return>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>args</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>isint</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><call><name>pqPutInt</name><argument_list>(<argument><expr><name><name>args</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>u</name><operator>.</operator><name>integer</name></name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>, <argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>pqHandleSendFailure</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr><name>NULL</name></expr>;</return>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><call><name>pqPutnchar</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name><name>args</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>u</name><operator>.</operator><name>ptr</name></name></expr></argument>, <argument><expr><name><name>args</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>len</name></expr></argument>, <argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>pqHandleSendFailure</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr><name>NULL</name></expr>;</return>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></for>

	<if_stmt><if>if <condition>(<expr><call><name>pqPutMsgEnd</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator>
		<call><name>pqFlush</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>pqHandleSendFailure</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>needInput</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Wait for some data to arrive (or for the channel to close) */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>pqWait</name><argument_list>(<argument><expr><name>true</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>conn</name></expr></argument>)</argument_list></call> <operator>||</operator>
				<call><name>pqReadData</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<break>break;</break></block_content></block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * Scan the message. If we run out of data, loop around to try again.
		 */</comment>
		<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>inCursor</name></name> <operator>=</operator> <name><name>conn</name><operator>-&gt;</operator><name>inStart</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>needInput</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>pqGetc</name><argument_list>(<argument><expr><operator>&amp;</operator><name>id</name></expr></argument>, <argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * We should see V or E response to the command, but might get N
		 * and/or A notices first. We also need to swallow the final Z before
		 * returning.
		 */</comment>
		<switch>switch <condition>(<expr><name>id</name></expr>)</condition>
		<block>{<block_content>
			<case>case <expr><literal type="char">'V'</literal></expr>:</case>			<comment type="block">/* function result */</comment>
				<if_stmt><if>if <condition>(<expr><call><name>pqGetc</name><argument_list>(<argument><expr><operator>&amp;</operator><name>id</name></expr></argument>, <argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<continue>continue;</continue></block_content></block></if></if_stmt>
				<if_stmt><if>if <condition>(<expr><name>id</name> <operator>==</operator> <literal type="char">'G'</literal></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/* function returned nonempty value */</comment>
					<if_stmt><if>if <condition>(<expr><call><name>pqGetInt</name><argument_list>(<argument><expr><name>actual_result_len</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>, <argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
						<continue>continue;</continue></block_content></block></if></if_stmt>
					<if_stmt><if>if <condition>(<expr><name>result_is_int</name></expr>)</condition>
					<block>{<block_content>
						<if_stmt><if>if <condition>(<expr><call><name>pqGetInt</name><argument_list>(<argument><expr><name>result_buf</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>, <argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
							<continue>continue;</continue></block_content></block></if></if_stmt>
					</block_content>}</block></if>
					<else>else
					<block>{<block_content>
						<if_stmt><if>if <condition>(<expr><call><name>pqGetnchar</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>result_buf</name></expr></argument>,
									   <argument><expr><operator>*</operator><name>actual_result_len</name></expr></argument>,
									   <argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
							<continue>continue;</continue></block_content></block></if></if_stmt>
					</block_content>}</block></else></if_stmt>
					<if_stmt><if>if <condition>(<expr><call><name>pqGetc</name><argument_list>(<argument><expr><operator>&amp;</operator><name>id</name></expr></argument>, <argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>	<comment type="block">/* get the last '0' */</comment>
						<continue>continue;</continue></block_content></block></if></if_stmt>
				</block_content>}</block></if></if_stmt>
				<if_stmt><if>if <condition>(<expr><name>id</name> <operator>==</operator> <literal type="char">'0'</literal></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/* correctly finished function result message */</comment>
					<expr_stmt><expr><name>status</name> <operator>=</operator> <name>PGRES_COMMAND_OK</name></expr>;</expr_stmt>
				</block_content>}</block></if>
				<else>else
				<block>{<block_content>
					<comment type="block">/* The backend violates the protocol. */</comment>
					<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conn</name><operator>-&gt;</operator><name>errorMessage</name></name></expr></argument>,
									  <argument><expr><call><name>libpq_gettext</name><argument_list>(<argument><expr><literal type="string">"protocol error: id=0x%x\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
									  <argument><expr><name>id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>pqSaveErrorResult</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>inStart</name></name> <operator>=</operator> <name><name>conn</name><operator>-&gt;</operator><name>inCursor</name></name></expr>;</expr_stmt>
					<return>return <expr><call><name>pqPrepareAsyncResult</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>;</return>
				</block_content>}</block></else></if_stmt>
				<break>break;</break>
			<case>case <expr><literal type="char">'E'</literal></expr>:</case>			<comment type="block">/* error return */</comment>
				<if_stmt><if>if <condition>(<expr><call><name>pqGetErrorNotice2</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<continue>continue;</continue></block_content></block></if></if_stmt>
				<expr_stmt><expr><name>status</name> <operator>=</operator> <name>PGRES_FATAL_ERROR</name></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><literal type="char">'A'</literal></expr>:</case>			<comment type="block">/* notify message */</comment>
				<comment type="block">/* handle notify and go back to processing return values */</comment>
				<if_stmt><if>if <condition>(<expr><call><name>getNotify</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<continue>continue;</continue></block_content></block></if></if_stmt>
				<break>break;</break>
			<case>case <expr><literal type="char">'N'</literal></expr>:</case>			<comment type="block">/* notice */</comment>
				<comment type="block">/* handle notice and go back to processing return values */</comment>
				<if_stmt><if>if <condition>(<expr><call><name>pqGetErrorNotice2</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<continue>continue;</continue></block_content></block></if></if_stmt>
				<break>break;</break>
			<case>case <expr><literal type="char">'Z'</literal></expr>:</case>			<comment type="block">/* backend is ready for new query */</comment>
				<comment type="block">/* consume the message and exit */</comment>
				<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>inStart</name></name> <operator>=</operator> <name><name>conn</name><operator>-&gt;</operator><name>inCursor</name></name></expr>;</expr_stmt>
				<comment type="block">/* if we saved a result object (probably an error), use it */</comment>
				<if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>result</name></name></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><call><name>pqPrepareAsyncResult</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
				<return>return <expr><call><name>PQmakeEmptyPGresult</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>status</name></expr></argument>)</argument_list></call></expr>;</return>
			<default>default:</default>
				<comment type="block">/* The backend violates the protocol. */</comment>
				<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conn</name><operator>-&gt;</operator><name>errorMessage</name></name></expr></argument>,
								  <argument><expr><call><name>libpq_gettext</name><argument_list>(<argument><expr><literal type="string">"protocol error: id=0x%x\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
								  <argument><expr><name>id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>pqSaveErrorResult</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>inStart</name></name> <operator>=</operator> <name><name>conn</name><operator>-&gt;</operator><name>inCursor</name></name></expr>;</expr_stmt>
				<return>return <expr><call><name>pqPrepareAsyncResult</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>;</return>
		</block_content>}</block></switch>
		<comment type="block">/* Completed this message, keep going */</comment>
		<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>inStart</name></name> <operator>=</operator> <name><name>conn</name><operator>-&gt;</operator><name>inCursor</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>needInput</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	</block_content>}</block></for>

	<comment type="block">/*
	 * We fall out of the loop only upon failing to read data.
	 * conn-&gt;errorMessage has been set by pqWait or pqReadData. We want to
	 * append it to any already-received error message.
	 */</comment>
	<expr_stmt><expr><call><name>pqSaveErrorResult</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><call><name>pqPrepareAsyncResult</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * Construct startup packet
 *
 * Returns a malloc'd packet buffer, or NULL if out of memory
 */</comment>
<function><type><name>char</name> <modifier>*</modifier></type>
<name>pqBuildStartupPacket2</name><parameter_list>(<parameter><decl><type><name>PGconn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>packetlen</name></decl></parameter>,
					  <parameter><decl><type><specifier>const</specifier> <name>PQEnvironmentOption</name> <modifier>*</modifier></type><name>options</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>StartupPacket</name> <modifier>*</modifier></type><name>startpacket</name></decl>;</decl_stmt>

	<expr_stmt><expr><operator>*</operator><name>packetlen</name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>StartupPacket</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
	<expr_stmt><expr><name>startpacket</name> <operator>=</operator> <operator>(</operator><name>StartupPacket</name> <operator>*</operator><operator>)</operator> <call><name>malloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>StartupPacket</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>startpacket</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><name>startpacket</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>StartupPacket</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>startpacket</name><operator>-&gt;</operator><name>protoVersion</name></name> <operator>=</operator> <call><name>pg_hton32</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>pversion</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* strncpy is safe here: postmaster will handle full fields correctly */</comment>
	<expr_stmt><expr><call><name>strncpy</name><argument_list>(<argument><expr><name><name>startpacket</name><operator>-&gt;</operator><name>user</name></name></expr></argument>, <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>pguser</name></name></expr></argument>, <argument><expr><name>SM_USER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>strncpy</name><argument_list>(<argument><expr><name><name>startpacket</name><operator>-&gt;</operator><name>database</name></name></expr></argument>, <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>dbName</name></name></expr></argument>, <argument><expr><name>SM_DATABASE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>strncpy</name><argument_list>(<argument><expr><name><name>startpacket</name><operator>-&gt;</operator><name>tty</name></name></expr></argument>, <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>pgtty</name></name></expr></argument>, <argument><expr><name>SM_TTY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>pgoptions</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>strncpy</name><argument_list>(<argument><expr><name><name>startpacket</name><operator>-&gt;</operator><name>options</name></name></expr></argument>, <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>pgoptions</name></name></expr></argument>, <argument><expr><name>SM_OPTIONS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>startpacket</name></expr>;</return>
</block_content>}</block></function>
</unit>
