<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/PolarDB-for-PostgreSQL/src/interfaces/libpq/fe-misc.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 *	 FILE
 *		fe-misc.c
 *
 *	 DESCRIPTION
 *		 miscellaneous useful functions
 *
 * The communication routines here are analogous to the ones in
 * backend/libpq/pqcomm.c and backend/libpq/pqcomprim.c, but operate
 * in the considerably different environment of the frontend libpq.
 * In particular, we work with a bare nonblock-mode socket, rather than
 * a stdio stream, so that we can avoid unwanted blocking of the application.
 *
 * XXX: MOVE DEBUG PRINTOUT TO HIGHER LEVEL.  As is, block and restart
 * will cause repeat printouts.
 *
 * We must speak the same transmitted data representations as the backend
 * routines.
 *
 *
 * Portions Copyright (c) 1996-2018, PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, Regents of the University of California
 *
 * IDENTIFICATION
 *	  src/interfaces/libpq/fe-misc.c
 *
 *-------------------------------------------------------------------------
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres_fe.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;signal.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;time.h&gt;</cpp:file></cpp:include>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WIN32</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"win32.h"</cpp:file></cpp:include>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;unistd.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/time.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_POLL_H</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;poll.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_SYS_SELECT_H</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/select.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"libpq-fe.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"libpq-int.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"mb/pg_wchar.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"port/pg_bswap.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pg_config_paths.h"</cpp:file></cpp:include>


<function_decl><type><specifier>static</specifier> <name>int</name></type>	<name>pqPutMsgBytes</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>len</name></decl></parameter>, <parameter><decl><type><name>PGconn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type>	<name>pqSendSome</name><parameter_list>(<parameter><decl><type><name>PGconn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>len</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>pqSocketCheck</name><parameter_list>(<parameter><decl><type><name>PGconn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>forRead</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>forWrite</name></decl></parameter>,
			  <parameter><decl><type><name>time_t</name></type> <name>end_time</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type>	<name>pqSocketPoll</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>sock</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>forRead</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>forWrite</name></decl></parameter>, <parameter><decl><type><name>time_t</name></type> <name>end_time</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/* POLAR px */</comment>
<function_decl><type><name>int</name></type> <name>pqFlushNonBlocking</name><parameter_list>(<parameter><decl><type><name>PGconn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/*
 * PQlibVersion: return the libpq version number
 */</comment>
<function><type><name>int</name></type>
<name>PQlibVersion</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><name>PG_VERSION_NUM</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * fputnbytes: print exactly N bytes to a file
 *
 * We avoid using %.*s here because it can misbehave if the data
 * is not valid in what libc thinks is the prevailing encoding.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>fputnbytes</name><parameter_list>(<parameter><decl><type><name>FILE</name> <modifier>*</modifier></type><name>f</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>str</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>n</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<while>while <condition>(<expr><name>n</name><operator>--</operator> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>fputc</name><argument_list>(<argument><expr><operator>*</operator><name>str</name><operator>++</operator></expr></argument>, <argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></while>
</block_content>}</block></function>


<comment type="block">/*
 * pqGetc: get 1 character from the connection
 *
 *	All these routines return 0 on success, EOF on error.
 *	Note that for the Get routines, EOF only means there is not enough
 *	data in the buffer, not that there is necessarily a hard error.
 */</comment>
<function><type><name>int</name></type>
<name>pqGetc</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>result</name></decl></parameter>, <parameter><decl><type><name>PGconn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>inCursor</name></name> <operator>&gt;=</operator> <name><name>conn</name><operator>-&gt;</operator><name>inEnd</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>EOF</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><operator>*</operator><name>result</name> <operator>=</operator> <name><name>conn</name><operator>-&gt;</operator><name>inBuffer</name><index>[<expr><name><name>conn</name><operator>-&gt;</operator><name>inCursor</name></name><operator>++</operator></expr>]</index></name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>Pfdebug</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>Pfdebug</name></name></expr></argument>, <argument><expr><literal type="string">"From backend&gt; %c\n"</literal></expr></argument>, <argument><expr><operator>*</operator><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * pqPutc: write 1 char to the current message
 */</comment>
<function><type><name>int</name></type>
<name>pqPutc</name><parameter_list>(<parameter><decl><type><name>char</name></type> <name>c</name></decl></parameter>, <parameter><decl><type><name>PGconn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><call><name>pqPutMsgBytes</name><argument_list>(<argument><expr><operator>&amp;</operator><name>c</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>EOF</name></expr>;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>Pfdebug</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>Pfdebug</name></name></expr></argument>, <argument><expr><literal type="string">"To backend&gt; %c\n"</literal></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * pqGets[_append]:
 * get a null-terminated string from the connection,
 * and store it in an expansible PQExpBuffer.
 * If we run out of memory, all of the string is still read,
 * but the excess characters are silently discarded.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>pqGets_internal</name><parameter_list>(<parameter><decl><type><name>PQExpBuffer</name></type> <name>buf</name></decl></parameter>, <parameter><decl><type><name>PGconn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>resetbuffer</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* Copy conn data to locals for faster search loop */</comment>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>inBuffer</name> <init>= <expr><name><name>conn</name><operator>-&gt;</operator><name>inBuffer</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>inCursor</name> <init>= <expr><name><name>conn</name><operator>-&gt;</operator><name>inCursor</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>inEnd</name> <init>= <expr><name><name>conn</name><operator>-&gt;</operator><name>inEnd</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>slen</name></decl>;</decl_stmt>

	<while>while <condition>(<expr><name>inCursor</name> <operator>&lt;</operator> <name>inEnd</name> <operator>&amp;&amp;</operator> <name><name>inBuffer</name><index>[<expr><name>inCursor</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>inCursor</name><operator>++</operator></expr>;</expr_stmt></block_content></block></while>

	<if_stmt><if>if <condition>(<expr><name>inCursor</name> <operator>&gt;=</operator> <name>inEnd</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>EOF</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>slen</name> <operator>=</operator> <name>inCursor</name> <operator>-</operator> <name><name>conn</name><operator>-&gt;</operator><name>inCursor</name></name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>resetbuffer</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>resetPQExpBuffer</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>appendBinaryPQExpBuffer</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>inBuffer</name> <operator>+</operator> <name><name>conn</name><operator>-&gt;</operator><name>inCursor</name></name></expr></argument>, <argument><expr><name>slen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>inCursor</name></name> <operator>=</operator> <operator>++</operator><name>inCursor</name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>Pfdebug</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>Pfdebug</name></name></expr></argument>, <argument><expr><literal type="string">"From backend&gt; \"%s\"\n"</literal></expr></argument>,
				<argument><expr><name><name>buf</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type>
<name>pqGets</name><parameter_list>(<parameter><decl><type><name>PQExpBuffer</name></type> <name>buf</name></decl></parameter>, <parameter><decl><type><name>PGconn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>pqGets_internal</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>conn</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type>
<name>pqGets_append</name><parameter_list>(<parameter><decl><type><name>PQExpBuffer</name></type> <name>buf</name></decl></parameter>, <parameter><decl><type><name>PGconn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>pqGets_internal</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>conn</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * pqPuts: write a null-terminated string to the current message
 */</comment>
<function><type><name>int</name></type>
<name>pqPuts</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>s</name></decl></parameter>, <parameter><decl><type><name>PGconn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><call><name>pqPutMsgBytes</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>EOF</name></expr>;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>Pfdebug</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>Pfdebug</name></name></expr></argument>, <argument><expr><literal type="string">"To backend&gt; \"%s\"\n"</literal></expr></argument>, <argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * pqGetnchar:
 *	get a string of exactly len bytes in buffer s, no null termination
 */</comment>
<function><type><name>int</name></type>
<name>pqGetnchar</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>s</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>len</name></decl></parameter>, <parameter><decl><type><name>PGconn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>len</name> <operator>&gt;</operator> <operator>(</operator><name>size_t</name><operator>)</operator> <operator>(</operator><name><name>conn</name><operator>-&gt;</operator><name>inEnd</name></name> <operator>-</operator> <name><name>conn</name><operator>-&gt;</operator><name>inCursor</name></name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>EOF</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>inBuffer</name></name> <operator>+</operator> <name><name>conn</name><operator>-&gt;</operator><name>inCursor</name></name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* no terminating null */</comment>

	<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>inCursor</name></name> <operator>+=</operator> <name>len</name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>Pfdebug</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>Pfdebug</name></name></expr></argument>, <argument><expr><literal type="string">"From backend (%lu)&gt; "</literal></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name> <name>long</name><operator>)</operator> <name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>fputnbytes</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>Pfdebug</name></name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>Pfdebug</name></name></expr></argument>, <argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * pqSkipnchar:
 *	skip over len bytes in input buffer.
 *
 * Note: this is primarily useful for its debug output, which should
 * be exactly the same as for pqGetnchar.  We assume the data in question
 * will actually be used, but just isn't getting copied anywhere as yet.
 */</comment>
<function><type><name>int</name></type>
<name>pqSkipnchar</name><parameter_list>(<parameter><decl><type><name>size_t</name></type> <name>len</name></decl></parameter>, <parameter><decl><type><name>PGconn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>len</name> <operator>&gt;</operator> <operator>(</operator><name>size_t</name><operator>)</operator> <operator>(</operator><name><name>conn</name><operator>-&gt;</operator><name>inEnd</name></name> <operator>-</operator> <name><name>conn</name><operator>-&gt;</operator><name>inCursor</name></name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>EOF</name></expr>;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>Pfdebug</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>Pfdebug</name></name></expr></argument>, <argument><expr><literal type="string">"From backend (%lu)&gt; "</literal></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name> <name>long</name><operator>)</operator> <name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>fputnbytes</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>Pfdebug</name></name></expr></argument>, <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>inBuffer</name></name> <operator>+</operator> <name><name>conn</name><operator>-&gt;</operator><name>inCursor</name></name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>Pfdebug</name></name></expr></argument>, <argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>inCursor</name></name> <operator>+=</operator> <name>len</name></expr>;</expr_stmt>

	<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * pqPutnchar:
 *	write exactly len bytes to the current message
 */</comment>
<function><type><name>int</name></type>
<name>pqPutnchar</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>s</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>len</name></decl></parameter>, <parameter><decl><type><name>PGconn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><call><name>pqPutMsgBytes</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>EOF</name></expr>;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>Pfdebug</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>Pfdebug</name></name></expr></argument>, <argument><expr><literal type="string">"To backend&gt; "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>fputnbytes</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>Pfdebug</name></name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>Pfdebug</name></name></expr></argument>, <argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * pqGetInt
 *	read a 2 or 4 byte integer and convert from network byte order
 *	to local byte order
 */</comment>
<function><type><name>int</name></type>
<name>pqGetInt</name><parameter_list>(<parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>result</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>bytes</name></decl></parameter>, <parameter><decl><type><name>PGconn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>uint16</name></type>		<name>tmp2</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32</name></type>		<name>tmp4</name></decl>;</decl_stmt>

	<switch>switch <condition>(<expr><name>bytes</name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><literal type="number">2</literal></expr>:</case>
			<if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>inCursor</name></name> <operator>+</operator> <literal type="number">2</literal> <operator>&gt;</operator> <name><name>conn</name><operator>-&gt;</operator><name>inEnd</name></name></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>EOF</name></expr>;</return></block_content></block></if></if_stmt>
			<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tmp2</name></expr></argument>, <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>inBuffer</name></name> <operator>+</operator> <name><name>conn</name><operator>-&gt;</operator><name>inCursor</name></name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>inCursor</name></name> <operator>+=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
			<expr_stmt><expr><operator>*</operator><name>result</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator> <call><name>pg_ntoh16</name><argument_list>(<argument><expr><name>tmp2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><literal type="number">4</literal></expr>:</case>
			<if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>inCursor</name></name> <operator>+</operator> <literal type="number">4</literal> <operator>&gt;</operator> <name><name>conn</name><operator>-&gt;</operator><name>inEnd</name></name></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>EOF</name></expr>;</return></block_content></block></if></if_stmt>
			<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tmp4</name></expr></argument>, <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>inBuffer</name></name> <operator>+</operator> <name><name>conn</name><operator>-&gt;</operator><name>inCursor</name></name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>inCursor</name></name> <operator>+=</operator> <literal type="number">4</literal></expr>;</expr_stmt>
			<expr_stmt><expr><operator>*</operator><name>result</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator> <call><name>pg_ntoh32</name><argument_list>(<argument><expr><name>tmp4</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<default>default:</default>
			<expr_stmt><expr><call><name>pqInternalNotice</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conn</name><operator>-&gt;</operator><name>noticeHooks</name></name></expr></argument>,
							 <argument><expr><literal type="string">"integer of size %lu not supported by pqGetInt"</literal></expr></argument>,
							 <argument><expr><operator>(</operator><name>unsigned</name> <name>long</name><operator>)</operator> <name>bytes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>EOF</name></expr>;</return>
	</block_content>}</block></switch>

	<if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>Pfdebug</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>Pfdebug</name></name></expr></argument>, <argument><expr><literal type="string">"From backend (#%lu)&gt; %d\n"</literal></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name> <name>long</name><operator>)</operator> <name>bytes</name></expr></argument>, <argument><expr><operator>*</operator><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * pqPutInt
 * write an integer of 2 or 4 bytes, converting from host byte order
 * to network byte order.
 */</comment>
<function><type><name>int</name></type>
<name>pqPutInt</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>value</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>bytes</name></decl></parameter>, <parameter><decl><type><name>PGconn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>uint16</name></type>		<name>tmp2</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32</name></type>		<name>tmp4</name></decl>;</decl_stmt>

	<switch>switch <condition>(<expr><name>bytes</name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><literal type="number">2</literal></expr>:</case>
			<expr_stmt><expr><name>tmp2</name> <operator>=</operator> <call><name>pg_hton16</name><argument_list>(<argument><expr><operator>(</operator><name>uint16</name><operator>)</operator> <name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><call><name>pqPutMsgBytes</name><argument_list>(<argument><expr><operator>(</operator><specifier>const</specifier> <name>char</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>tmp2</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>EOF</name></expr>;</return></block_content></block></if></if_stmt>
			<break>break;</break>
		<case>case <expr><literal type="number">4</literal></expr>:</case>
			<expr_stmt><expr><name>tmp4</name> <operator>=</operator> <call><name>pg_hton32</name><argument_list>(<argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><call><name>pqPutMsgBytes</name><argument_list>(<argument><expr><operator>(</operator><specifier>const</specifier> <name>char</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>tmp4</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>, <argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>EOF</name></expr>;</return></block_content></block></if></if_stmt>
			<break>break;</break>
		<default>default:</default>
			<expr_stmt><expr><call><name>pqInternalNotice</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conn</name><operator>-&gt;</operator><name>noticeHooks</name></name></expr></argument>,
							 <argument><expr><literal type="string">"integer of size %lu not supported by pqPutInt"</literal></expr></argument>,
							 <argument><expr><operator>(</operator><name>unsigned</name> <name>long</name><operator>)</operator> <name>bytes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>EOF</name></expr>;</return>
	</block_content>}</block></switch>

	<if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>Pfdebug</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>Pfdebug</name></name></expr></argument>, <argument><expr><literal type="string">"To backend (%lu#)&gt; %d\n"</literal></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name> <name>long</name><operator>)</operator> <name>bytes</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Make sure conn's output buffer can hold bytes_needed bytes (caller must
 * include already-stored data into the value!)
 *
 * Returns 0 on success, EOF if failed to enlarge buffer
 */</comment>
<function><type><name>int</name></type>
<name>pqCheckOutBufferSpace</name><parameter_list>(<parameter><decl><type><name>size_t</name></type> <name>bytes_needed</name></decl></parameter>, <parameter><decl><type><name>PGconn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>newsize</name> <init>= <expr><name><name>conn</name><operator>-&gt;</operator><name>outBufSize</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>newbuf</name></decl>;</decl_stmt>

	<comment type="block">/* Quick exit if we have enough space */</comment>
	<if_stmt><if>if <condition>(<expr><name>bytes_needed</name> <operator>&lt;=</operator> <operator>(</operator><name>size_t</name><operator>)</operator> <name>newsize</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * If we need to enlarge the buffer, we first try to double it in size; if
	 * that doesn't work, enlarge in multiples of 8K.  This avoids thrashing
	 * the malloc pool by repeated small enlargements.
	 *
	 * Note: tests for newsize &gt; 0 are to catch integer overflow.
	 */</comment>
	<do>do
	<block>{<block_content>
		<expr_stmt><expr><name>newsize</name> <operator>*=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
	</block_content>}</block> while <condition>(<expr><name>newsize</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>bytes_needed</name> <operator>&gt;</operator> <operator>(</operator><name>size_t</name><operator>)</operator> <name>newsize</name></expr>)</condition>;</do>

	<if_stmt><if>if <condition>(<expr><name>newsize</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>bytes_needed</name> <operator>&lt;=</operator> <operator>(</operator><name>size_t</name><operator>)</operator> <name>newsize</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>newbuf</name> <operator>=</operator> <call><name>realloc</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>outBuffer</name></name></expr></argument>, <argument><expr><name>newsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>newbuf</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* realloc succeeded */</comment>
			<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>outBuffer</name></name> <operator>=</operator> <name>newbuf</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>outBufSize</name></name> <operator>=</operator> <name>newsize</name></expr>;</expr_stmt>
			<return>return <expr><literal type="number">0</literal></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>newsize</name> <operator>=</operator> <name><name>conn</name><operator>-&gt;</operator><name>outBufSize</name></name></expr>;</expr_stmt>
	<do>do
	<block>{<block_content>
		<expr_stmt><expr><name>newsize</name> <operator>+=</operator> <literal type="number">8192</literal></expr>;</expr_stmt>
	</block_content>}</block> while <condition>(<expr><name>newsize</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>bytes_needed</name> <operator>&gt;</operator> <operator>(</operator><name>size_t</name><operator>)</operator> <name>newsize</name></expr>)</condition>;</do>

	<if_stmt><if>if <condition>(<expr><name>newsize</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>bytes_needed</name> <operator>&lt;=</operator> <operator>(</operator><name>size_t</name><operator>)</operator> <name>newsize</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>newbuf</name> <operator>=</operator> <call><name>realloc</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>outBuffer</name></name></expr></argument>, <argument><expr><name>newsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>newbuf</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* realloc succeeded */</comment>
			<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>outBuffer</name></name> <operator>=</operator> <name>newbuf</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>outBufSize</name></name> <operator>=</operator> <name>newsize</name></expr>;</expr_stmt>
			<return>return <expr><literal type="number">0</literal></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* realloc failed. Probably out of memory */</comment>
	<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conn</name><operator>-&gt;</operator><name>errorMessage</name></name></expr></argument>,
					  <argument><expr><literal type="string">"cannot allocate memory for output buffer\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>EOF</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Make sure conn's input buffer can hold bytes_needed bytes (caller must
 * include already-stored data into the value!)
 *
 * Returns 0 on success, EOF if failed to enlarge buffer
 */</comment>
<function><type><name>int</name></type>
<name>pqCheckInBufferSpace</name><parameter_list>(<parameter><decl><type><name>size_t</name></type> <name>bytes_needed</name></decl></parameter>, <parameter><decl><type><name>PGconn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>newsize</name> <init>= <expr><name><name>conn</name><operator>-&gt;</operator><name>inBufSize</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>newbuf</name></decl>;</decl_stmt>

	<comment type="block">/* Quick exit if we have enough space */</comment>
	<if_stmt><if>if <condition>(<expr><name>bytes_needed</name> <operator>&lt;=</operator> <operator>(</operator><name>size_t</name><operator>)</operator> <name>newsize</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Before concluding that we need to enlarge the buffer, left-justify
	 * whatever is in it and recheck.  The caller's value of bytes_needed
	 * includes any data to the left of inStart, but we can delete that in
	 * preference to enlarging the buffer.  It's slightly ugly to have this
	 * function do this, but it's better than making callers worry about it.
	 */</comment>
	<expr_stmt><expr><name>bytes_needed</name> <operator>-=</operator> <name><name>conn</name><operator>-&gt;</operator><name>inStart</name></name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>inStart</name></name> <operator>&lt;</operator> <name><name>conn</name><operator>-&gt;</operator><name>inEnd</name></name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>inStart</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>memmove</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>inBuffer</name></name></expr></argument>, <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>inBuffer</name></name> <operator>+</operator> <name><name>conn</name><operator>-&gt;</operator><name>inStart</name></name></expr></argument>,
					<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>inEnd</name></name> <operator>-</operator> <name><name>conn</name><operator>-&gt;</operator><name>inStart</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>inEnd</name></name> <operator>-=</operator> <name><name>conn</name><operator>-&gt;</operator><name>inStart</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>inCursor</name></name> <operator>-=</operator> <name><name>conn</name><operator>-&gt;</operator><name>inStart</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>inStart</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* buffer is logically empty, reset it */</comment>
		<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>inStart</name></name> <operator>=</operator> <name><name>conn</name><operator>-&gt;</operator><name>inCursor</name></name> <operator>=</operator> <name><name>conn</name><operator>-&gt;</operator><name>inEnd</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/* Recheck whether we have enough space */</comment>
	<if_stmt><if>if <condition>(<expr><name>bytes_needed</name> <operator>&lt;=</operator> <operator>(</operator><name>size_t</name><operator>)</operator> <name>newsize</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * If we need to enlarge the buffer, we first try to double it in size; if
	 * that doesn't work, enlarge in multiples of 8K.  This avoids thrashing
	 * the malloc pool by repeated small enlargements.
	 *
	 * Note: tests for newsize &gt; 0 are to catch integer overflow.
	 */</comment>
	<do>do
	<block>{<block_content>
		<expr_stmt><expr><name>newsize</name> <operator>*=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
	</block_content>}</block> while <condition>(<expr><name>newsize</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>bytes_needed</name> <operator>&gt;</operator> <operator>(</operator><name>size_t</name><operator>)</operator> <name>newsize</name></expr>)</condition>;</do>

	<if_stmt><if>if <condition>(<expr><name>newsize</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>bytes_needed</name> <operator>&lt;=</operator> <operator>(</operator><name>size_t</name><operator>)</operator> <name>newsize</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>newbuf</name> <operator>=</operator> <call><name>realloc</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>inBuffer</name></name></expr></argument>, <argument><expr><name>newsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>newbuf</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* realloc succeeded */</comment>
			<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>inBuffer</name></name> <operator>=</operator> <name>newbuf</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>inBufSize</name></name> <operator>=</operator> <name>newsize</name></expr>;</expr_stmt>
			<return>return <expr><literal type="number">0</literal></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>newsize</name> <operator>=</operator> <name><name>conn</name><operator>-&gt;</operator><name>inBufSize</name></name></expr>;</expr_stmt>
	<do>do
	<block>{<block_content>
		<expr_stmt><expr><name>newsize</name> <operator>+=</operator> <literal type="number">8192</literal></expr>;</expr_stmt>
	</block_content>}</block> while <condition>(<expr><name>newsize</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>bytes_needed</name> <operator>&gt;</operator> <operator>(</operator><name>size_t</name><operator>)</operator> <name>newsize</name></expr>)</condition>;</do>

	<if_stmt><if>if <condition>(<expr><name>newsize</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>bytes_needed</name> <operator>&lt;=</operator> <operator>(</operator><name>size_t</name><operator>)</operator> <name>newsize</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>newbuf</name> <operator>=</operator> <call><name>realloc</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>inBuffer</name></name></expr></argument>, <argument><expr><name>newsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>newbuf</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* realloc succeeded */</comment>
			<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>inBuffer</name></name> <operator>=</operator> <name>newbuf</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>inBufSize</name></name> <operator>=</operator> <name>newsize</name></expr>;</expr_stmt>
			<return>return <expr><literal type="number">0</literal></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* realloc failed. Probably out of memory */</comment>
	<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conn</name><operator>-&gt;</operator><name>errorMessage</name></name></expr></argument>,
					  <argument><expr><literal type="string">"cannot allocate memory for input buffer\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>EOF</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * pqPutMsgStart: begin construction of a message to the server
 *
 * msg_type is the message type byte, or 0 for a message without type byte
 * (only startup messages have no type byte)
 *
 * force_len forces the message to have a length word; otherwise, we add
 * a length word if protocol 3.
 *
 * Returns 0 on success, EOF on error
 *
 * The idea here is that we construct the message in conn-&gt;outBuffer,
 * beginning just past any data already in outBuffer (ie, at
 * outBuffer+outCount).  We enlarge the buffer as needed to hold the message.
 * When the message is complete, we fill in the length word (if needed) and
 * then advance outCount past the message, making it eligible to send.
 *
 * The state variable conn-&gt;outMsgStart points to the incomplete message's
 * length word: it is either outCount or outCount+1 depending on whether
 * there is a type byte.  If we are sending a message without length word
 * (pre protocol 3.0 only), then outMsgStart is -1.  The state variable
 * conn-&gt;outMsgEnd is the end of the data collected so far.
 */</comment>
<function><type><name>int</name></type>
<name>pqPutMsgStart</name><parameter_list>(<parameter><decl><type><name>char</name></type> <name>msg_type</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>force_len</name></decl></parameter>, <parameter><decl><type><name>PGconn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>lenPos</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>endPos</name></decl>;</decl_stmt>

	<comment type="block">/* allow room for message type byte */</comment>
	<if_stmt><if>if <condition>(<expr><name>msg_type</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>endPos</name> <operator>=</operator> <name><name>conn</name><operator>-&gt;</operator><name>outCount</name></name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>endPos</name> <operator>=</operator> <name><name>conn</name><operator>-&gt;</operator><name>outCount</name></name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/* do we want a length word? */</comment>
	<if_stmt><if>if <condition>(<expr><name>force_len</name> <operator>||</operator> <call><name>PG_PROTOCOL_MAJOR</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>pversion</name></name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <literal type="number">3</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>lenPos</name> <operator>=</operator> <name>endPos</name></expr>;</expr_stmt>
		<comment type="block">/* allow room for message length */</comment>
		<expr_stmt><expr><name>endPos</name> <operator>+=</operator> <literal type="number">4</literal></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>lenPos</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/* make sure there is room for message header */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>pqCheckOutBufferSpace</name><argument_list>(<argument><expr><name>endPos</name></expr></argument>, <argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>EOF</name></expr>;</return></block_content></block></if></if_stmt>
	<comment type="block">/* okay, save the message type byte if any */</comment>
	<if_stmt><if>if <condition>(<expr><name>msg_type</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>outBuffer</name><index>[<expr><name><name>conn</name><operator>-&gt;</operator><name>outCount</name></name></expr>]</index></name> <operator>=</operator> <name>msg_type</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<comment type="block">/* set up the message pointers */</comment>
	<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>outMsgStart</name></name> <operator>=</operator> <name>lenPos</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>outMsgEnd</name></name> <operator>=</operator> <name>endPos</name></expr>;</expr_stmt>
	<comment type="block">/* length word, if needed, will be filled in by pqPutMsgEnd */</comment>

	<if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>Pfdebug</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>Pfdebug</name></name></expr></argument>, <argument><expr><literal type="string">"To backend&gt; Msg %c\n"</literal></expr></argument>,
				<argument><expr><ternary><condition><expr><name>msg_type</name></expr> ?</condition><then> <expr><name>msg_type</name></expr> </then><else>: <expr><literal type="char">' '</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * pqPutMsgBytes: add bytes to a partially-constructed message
 *
 * Returns 0 on success, EOF on error
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>pqPutMsgBytes</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>len</name></decl></parameter>, <parameter><decl><type><name>PGconn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* make sure there is room for it */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>pqCheckOutBufferSpace</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>outMsgEnd</name></name> <operator>+</operator> <name>len</name></expr></argument>, <argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>EOF</name></expr>;</return></block_content></block></if></if_stmt>
	<comment type="block">/* okay, save the data */</comment>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>outBuffer</name></name> <operator>+</operator> <name><name>conn</name><operator>-&gt;</operator><name>outMsgEnd</name></name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>outMsgEnd</name></name> <operator>+=</operator> <name>len</name></expr>;</expr_stmt>
	<comment type="block">/* no Pfdebug call here, caller should do it */</comment>
	<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * pqPutMsgEnd: finish constructing a message and possibly send it
 *
 * Returns 0 on success, EOF on error
 *
 * We don't actually send anything here unless we've accumulated at least
 * 8K worth of data (the typical size of a pipe buffer on Unix systems).
 * This avoids sending small partial packets.  The caller must use pqFlush
 * when it's important to flush all the data out to the server.
 */</comment>
<function><type><name>int</name></type>
<name>pqPutMsgEnd</name><parameter_list>(<parameter><decl><type><name>PGconn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>Pfdebug</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>Pfdebug</name></name></expr></argument>, <argument><expr><literal type="string">"To backend&gt; Msg complete, length %u\n"</literal></expr></argument>,
				<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>outMsgEnd</name></name> <operator>-</operator> <name><name>conn</name><operator>-&gt;</operator><name>outCount</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Fill in length word if needed */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>outMsgStart</name></name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>uint32</name></type>		<name>msgLen</name> <init>= <expr><name><name>conn</name><operator>-&gt;</operator><name>outMsgEnd</name></name> <operator>-</operator> <name><name>conn</name><operator>-&gt;</operator><name>outMsgStart</name></name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>msgLen</name> <operator>=</operator> <call><name>pg_hton32</name><argument_list>(<argument><expr><name>msgLen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>outBuffer</name></name> <operator>+</operator> <name><name>conn</name><operator>-&gt;</operator><name>outMsgStart</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>msgLen</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Make message eligible to send */</comment>
	<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>outCount</name></name> <operator>=</operator> <name><name>conn</name><operator>-&gt;</operator><name>outMsgEnd</name></name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>outCount</name></name> <operator>&gt;=</operator> <literal type="number">8192</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>toSend</name> <init>= <expr><name><name>conn</name><operator>-&gt;</operator><name>outCount</name></name> <operator>-</operator> <operator>(</operator><name><name>conn</name><operator>-&gt;</operator><name>outCount</name></name> <operator>%</operator> <literal type="number">8192</literal><operator>)</operator></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>pqSendSome</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>toSend</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>EOF</name></expr>;</return></block_content></block></if></if_stmt>
		<comment type="block">/* in nonblock mode, don't complain if unable to send it all */</comment>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* ----------
 * pqReadData: read more data, if any is available
 * Possible return values:
 *	 1: successfully loaded at least one more byte
 *	 0: no data is presently available, but no error detected
 *	-1: error detected (including EOF = connection closure);
 *		conn-&gt;errorMessage set
 * NOTE: callers must not assume that pointers or indexes into conn-&gt;inBuffer
 * remain valid across this call!
 * ----------
 */</comment>
<function><type><name>int</name></type>
<name>pqReadData</name><parameter_list>(<parameter><decl><type><name>PGconn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>someread</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>nread</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>sock</name></name> <operator>==</operator> <name>PGINVALID_SOCKET</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conn</name><operator>-&gt;</operator><name>errorMessage</name></name></expr></argument>,
						  <argument><expr><call><name>libpq_gettext</name><argument_list>(<argument><expr><literal type="string">"connection not open\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Left-justify any data in the buffer to make room */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>inStart</name></name> <operator>&lt;</operator> <name><name>conn</name><operator>-&gt;</operator><name>inEnd</name></name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>inStart</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>memmove</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>inBuffer</name></name></expr></argument>, <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>inBuffer</name></name> <operator>+</operator> <name><name>conn</name><operator>-&gt;</operator><name>inStart</name></name></expr></argument>,
					<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>inEnd</name></name> <operator>-</operator> <name><name>conn</name><operator>-&gt;</operator><name>inStart</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>inEnd</name></name> <operator>-=</operator> <name><name>conn</name><operator>-&gt;</operator><name>inStart</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>inCursor</name></name> <operator>-=</operator> <name><name>conn</name><operator>-&gt;</operator><name>inStart</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>inStart</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* buffer is logically empty, reset it */</comment>
		<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>inStart</name></name> <operator>=</operator> <name><name>conn</name><operator>-&gt;</operator><name>inCursor</name></name> <operator>=</operator> <name><name>conn</name><operator>-&gt;</operator><name>inEnd</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/*
	 * If the buffer is fairly full, enlarge it. We need to be able to enlarge
	 * the buffer in case a single message exceeds the initial buffer size. We
	 * enlarge before filling the buffer entirely so as to avoid asking the
	 * kernel for a partial packet. The magic constant here should be large
	 * enough for a TCP packet or Unix pipe bufferload.  8K is the usual pipe
	 * buffer size, so...
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>inBufSize</name></name> <operator>-</operator> <name><name>conn</name><operator>-&gt;</operator><name>inEnd</name></name> <operator>&lt;</operator> <literal type="number">8192</literal></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>pqCheckInBufferSpace</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>inEnd</name></name> <operator>+</operator> <operator>(</operator><name>size_t</name><operator>)</operator> <literal type="number">8192</literal></expr></argument>, <argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * We don't insist that the enlarge worked, but we need some room
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>inBufSize</name></name> <operator>-</operator> <name><name>conn</name><operator>-&gt;</operator><name>inEnd</name></name> <operator>&lt;</operator> <literal type="number">100</literal></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>		<comment type="block">/* errorMessage already set */</comment>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* OK, try to read some data */</comment>
<label><name>retry3</name>:</label>
	<expr_stmt><expr><name>nread</name> <operator>=</operator> <call><name>pqsecure_read</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>inBuffer</name></name> <operator>+</operator> <name><name>conn</name><operator>-&gt;</operator><name>inEnd</name></name></expr></argument>,
						  <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>inBufSize</name></name> <operator>-</operator> <name><name>conn</name><operator>-&gt;</operator><name>inEnd</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>nread</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>SOCK_ERRNO</name> <operator>==</operator> <name>EINTR</name></expr>)</condition><block type="pseudo"><block_content>
			<goto>goto <name>retry3</name>;</goto></block_content></block></if></if_stmt>
		<comment type="block">/* Some systems return EAGAIN/EWOULDBLOCK for no data */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>EAGAIN</name></cpp:ifdef>
		<if_stmt><if>if <condition>(<expr><name>SOCK_ERRNO</name> <operator>==</operator> <name>EAGAIN</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>someread</name></expr>;</return></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>EWOULDBLOCK</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>(</operator><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>EAGAIN</name></expr></argument>)</argument_list></call> <operator>||</operator> <operator>(</operator><name>EWOULDBLOCK</name> <operator>!=</operator> <name>EAGAIN</name><operator>)</operator><operator>)</operator></expr></cpp:if>
		<if_stmt><if>if <condition>(<expr><name>SOCK_ERRNO</name> <operator>==</operator> <name>EWOULDBLOCK</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>someread</name></expr>;</return></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
		<comment type="block">/* We might get ECONNRESET here if using TCP and backend died */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>ECONNRESET</name></cpp:ifdef>
		<if_stmt><if>if <condition>(<expr><name>SOCK_ERRNO</name> <operator>==</operator> <name>ECONNRESET</name></expr>)</condition><block type="pseudo"><block_content>
			<goto>goto <name>definitelyFailed</name>;</goto></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
		<comment type="block">/* pqsecure_read set the error message for us */</comment>
		<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>nread</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>inEnd</name></name> <operator>+=</operator> <name>nread</name></expr>;</expr_stmt>

		<comment type="block">/*
		 * Hack to deal with the fact that some kernels will only give us back
		 * 1 packet per recv() call, even if we asked for more and there is
		 * more available.  If it looks like we are reading a long message,
		 * loop back to recv() again immediately, until we run out of data or
		 * buffer space.  Without this, the block-and-restart behavior of
		 * libpq's higher levels leads to O(N^2) performance on long messages.
		 *
		 * Since we left-justified the data above, conn-&gt;inEnd gives the
		 * amount of data already read in the current message.  We consider
		 * the message "long" once we have acquired 32k ...
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>inEnd</name></name> <operator>&gt;</operator> <literal type="number">32768</literal> <operator>&amp;&amp;</operator>
			<operator>(</operator><name><name>conn</name><operator>-&gt;</operator><name>inBufSize</name></name> <operator>-</operator> <name><name>conn</name><operator>-&gt;</operator><name>inEnd</name></name><operator>)</operator> <operator>&gt;=</operator> <literal type="number">8192</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>someread</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
			<goto>goto <name>retry3</name>;</goto>
		</block_content>}</block></if></if_stmt>
		<return>return <expr><literal type="number">1</literal></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>someread</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>				<comment type="block">/* got a zero read after successful tries */</comment>

	<comment type="block">/*
	 * A return value of 0 could mean just that no data is now available, or
	 * it could mean EOF --- that is, the server has closed the connection.
	 * Since we have the socket in nonblock mode, the only way to tell the
	 * difference is to see if select() is saying that the file is ready.
	 * Grumble.  Fortunately, we don't expect this path to be taken much,
	 * since in normal practice we should not be trying to read data unless
	 * the file selected for reading already.
	 *
	 * In SSL mode it's even worse: SSL_read() could say WANT_READ and then
	 * data could arrive before we make the pqReadReady() test, but the second
	 * SSL_read() could still say WANT_READ because the data received was not
	 * a complete SSL record.  So we must play dumb and assume there is more
	 * data, relying on the SSL layer to detect true EOF.
	 */</comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_SSL</name></cpp:ifdef>
	<if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>ssl_in_use</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<switch>switch <condition>(<expr><call><name>pqReadReady</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><literal type="number">0</literal></expr>:</case>
			<comment type="block">/* definitely no data available */</comment>
			<return>return <expr><literal type="number">0</literal></expr>;</return>
		<case>case <expr><literal type="number">1</literal></expr>:</case>
			<comment type="block">/* ready for read */</comment>
			<break>break;</break>
		<default>default:</default>
			<comment type="block">/* we override pqReadReady's message with something more useful */</comment>
			<goto>goto <name>definitelyEOF</name>;</goto>
	</block_content>}</block></switch>

	<comment type="block">/*
	 * Still not sure that it's EOF, because some data could have just
	 * arrived.
	 */</comment>
<label><name>retry4</name>:</label>
	<expr_stmt><expr><name>nread</name> <operator>=</operator> <call><name>pqsecure_read</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>inBuffer</name></name> <operator>+</operator> <name><name>conn</name><operator>-&gt;</operator><name>inEnd</name></name></expr></argument>,
						  <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>inBufSize</name></name> <operator>-</operator> <name><name>conn</name><operator>-&gt;</operator><name>inEnd</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>nread</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>SOCK_ERRNO</name> <operator>==</operator> <name>EINTR</name></expr>)</condition><block type="pseudo"><block_content>
			<goto>goto <name>retry4</name>;</goto></block_content></block></if></if_stmt>
		<comment type="block">/* Some systems return EAGAIN/EWOULDBLOCK for no data */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>EAGAIN</name></cpp:ifdef>
		<if_stmt><if>if <condition>(<expr><name>SOCK_ERRNO</name> <operator>==</operator> <name>EAGAIN</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>EWOULDBLOCK</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>(</operator><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>EAGAIN</name></expr></argument>)</argument_list></call> <operator>||</operator> <operator>(</operator><name>EWOULDBLOCK</name> <operator>!=</operator> <name>EAGAIN</name><operator>)</operator><operator>)</operator></expr></cpp:if>
		<if_stmt><if>if <condition>(<expr><name>SOCK_ERRNO</name> <operator>==</operator> <name>EWOULDBLOCK</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
		<comment type="block">/* We might get ECONNRESET here if using TCP and backend died */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>ECONNRESET</name></cpp:ifdef>
		<if_stmt><if>if <condition>(<expr><name>SOCK_ERRNO</name> <operator>==</operator> <name>ECONNRESET</name></expr>)</condition><block type="pseudo"><block_content>
			<goto>goto <name>definitelyFailed</name>;</goto></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
		<comment type="block">/* pqsecure_read set the error message for us */</comment>
		<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>nread</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>inEnd</name></name> <operator>+=</operator> <name>nread</name></expr>;</expr_stmt>
		<return>return <expr><literal type="number">1</literal></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * OK, we are getting a zero read even though select() says ready. This
	 * means the connection has been closed.  Cope.
	 */</comment>
<label><name>definitelyEOF</name>:</label>
	<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conn</name><operator>-&gt;</operator><name>errorMessage</name></name></expr></argument>,
					  <argument><expr><call><name>libpq_gettext</name><argument_list>(
									<argument><expr><literal type="string">"server closed the connection unexpectedly\n"</literal>
									<literal type="string">"\tThis probably means the server terminated abnormally\n"</literal>
									<literal type="string">"\tbefore or while processing the request.\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Come here if lower-level code already set a suitable errorMessage */</comment>
<label><name>definitelyFailed</name>:</label>
	<comment type="block">/* Do *not* drop any already-read data; caller still wants it */</comment>
	<expr_stmt><expr><call><name>pqDropConnection</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>status</name></name> <operator>=</operator> <name>CONNECTION_BAD</name></expr>;</expr_stmt>	<comment type="block">/* No more connection to backend */</comment>
	<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * pqSendSome: send data waiting in the output buffer.
 *
 * len is how much to try to send (typically equal to outCount, but may
 * be less).
 *
 * Return 0 on success, -1 on failure and 1 when not all data could be sent
 * because the socket would block and the connection is non-blocking.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>pqSendSome</name><parameter_list>(<parameter><decl><type><name>PGconn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>len</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>ptr</name> <init>= <expr><name><name>conn</name><operator>-&gt;</operator><name>outBuffer</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>remaining</name> <init>= <expr><name><name>conn</name><operator>-&gt;</operator><name>outCount</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>result</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>sock</name></name> <operator>==</operator> <name>PGINVALID_SOCKET</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conn</name><operator>-&gt;</operator><name>errorMessage</name></name></expr></argument>,
						  <argument><expr><call><name>libpq_gettext</name><argument_list>(<argument><expr><literal type="string">"connection not open\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* Discard queued data; no chance it'll ever be sent */</comment>
		<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>outCount</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* while there's still data to send */</comment>
	<while>while <condition>(<expr><name>len</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>sent</name></decl>;</decl_stmt>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>WIN32</name></cpp:ifndef>
		<expr_stmt><expr><name>sent</name> <operator>=</operator> <call><name>pqsecure_write</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

		<comment type="block">/*
		 * Windows can fail on large sends, per KB article Q201213. The
		 * failure-point appears to be different in different versions of
		 * Windows, but 64k should always be safe.
		 */</comment>
		<expr_stmt><expr><name>sent</name> <operator>=</operator> <call><name>pqsecure_write</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><call><name>Min</name><argument_list>(<argument><expr><name>len</name></expr></argument>, <argument><expr><literal type="number">65536</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

		<if_stmt><if>if <condition>(<expr><name>sent</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Anything except EAGAIN/EWOULDBLOCK/EINTR is trouble */</comment>
			<switch>switch <condition>(<expr><name>SOCK_ERRNO</name></expr>)</condition>
			<block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>EAGAIN</name></cpp:ifdef>
				<case>case <expr><name>EAGAIN</name></expr>:</case>
					<break>break;</break>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>EWOULDBLOCK</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>(</operator><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>EAGAIN</name></expr></argument>)</argument_list></call> <operator>||</operator> <operator>(</operator><name>EWOULDBLOCK</name> <operator>!=</operator> <name>EAGAIN</name><operator>)</operator><operator>)</operator></expr></cpp:if>
				<case>case <expr><name>EWOULDBLOCK</name></expr>:</case>
					<break>break;</break>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
				<case>case <expr><name>EINTR</name></expr>:</case>
					<continue>continue;</continue>

				<default>default:</default>
					<comment type="block">/* pqsecure_write set the error message for us */</comment>

					<comment type="block">/*
					 * We used to close the socket here, but that's a bad idea
					 * since there might be unread data waiting (typically, a
					 * NOTICE message from the backend telling us it's
					 * committing hara-kiri...).  Leave the socket open until
					 * pqReadData finds no more data can be read.  But abandon
					 * attempt to send data.
					 */</comment>
					<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>outCount</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
					<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
			</block_content>}</block></switch>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><name>ptr</name> <operator>+=</operator> <name>sent</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>len</name> <operator>-=</operator> <name>sent</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>remaining</name> <operator>-=</operator> <name>sent</name></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>len</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * We didn't send it all, wait till we can send more.
			 *
			 * There are scenarios in which we can't send data because the
			 * communications channel is full, but we cannot expect the server
			 * to clear the channel eventually because it's blocked trying to
			 * send data to us.  (This can happen when we are sending a large
			 * amount of COPY data, and the server has generated lots of
			 * NOTICE responses.)  To avoid a deadlock situation, we must be
			 * prepared to accept and buffer incoming data before we try
			 * again.  Furthermore, it is possible that such incoming data
			 * might not arrive until after we've gone to sleep.  Therefore,
			 * we wait for either read ready or write ready.
			 *
			 * In non-blocking mode, we don't wait here directly, but return 1
			 * to indicate that data is still pending.  The caller should wait
			 * for both read and write ready conditions, and call
			 * PQconsumeInput() on read ready, but just in case it doesn't, we
			 * call pqReadData() ourselves before returning.  That's not
			 * enough if the data has not arrived yet, but it's the best we
			 * can do, and works pretty well in practice.  (The documentation
			 * used to say that you only need to wait for write-ready, so
			 * there are still plenty of applications like that out there.)
			 */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>pqReadData</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>	<comment type="block">/* error message already set up */</comment>
				<break>break;</break>
			</block_content>}</block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>pqIsnonblocking</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>result</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>pqWait</name><argument_list>(<argument><expr><name>true</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></while>

	<comment type="block">/* shift the remaining contents of the buffer */</comment>
	<if_stmt><if>if <condition>(<expr><name>remaining</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* POLAR px */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>outBuffer_shared</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>outBuffer</name></name> <operator>=</operator> <name>ptr</name></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>memmove</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>outBuffer</name></name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>remaining</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>outCount</name></name> <operator>=</operator> <name>remaining</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * POLAR px
	 * Once we finish with the external buffer, switch back to the original.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>remaining</name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>conn</name><operator>-&gt;</operator><name>outBuffer_shared</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>outBuffer_shared</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>outBuffer</name></name> <operator>=</operator> <name><name>conn</name><operator>-&gt;</operator><name>outBufferSaved</name></name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * pqFlush: send any data waiting in the output buffer
 *
 * Return 0 on success, -1 on failure and 1 when not all data could be sent
 * because the socket would block and the connection is non-blocking.
 */</comment>
<function><type><name>int</name></type>
<name>pqFlush</name><parameter_list>(<parameter><decl><type><name>PGconn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>Pfdebug</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>fflush</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>Pfdebug</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>outCount</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><call><name>pqSendSome</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>outCount</name></name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

	<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * pqWait: wait until we can read or write the connection socket
 *
 * JAB: If SSL enabled and used and forRead, buffered bytes short-circuit the
 * call to select().
 *
 * We also stop waiting and return if the kernel flags an exception condition
 * on the socket.  The actual error condition will be detected and reported
 * when the caller tries to read or write the socket.
 */</comment>
<function><type><name>int</name></type>
<name>pqWait</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>forRead</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>forWrite</name></decl></parameter>, <parameter><decl><type><name>PGconn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>pqWaitTimed</name><argument_list>(<argument><expr><name>forRead</name></expr></argument>, <argument><expr><name>forWrite</name></expr></argument>, <argument><expr><name>conn</name></expr></argument>, <argument><expr><operator>(</operator><name>time_t</name><operator>)</operator> <operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * pqWaitTimed: wait, but not past finish_time.
 *
 * finish_time = ((time_t) -1) disables the wait limit.
 *
 * Returns -1 on failure, 0 if the socket is readable/writable, 1 if it timed out.
 */</comment>
<function><type><name>int</name></type>
<name>pqWaitTimed</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>forRead</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>forWrite</name></decl></parameter>, <parameter><decl><type><name>PGconn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>, <parameter><decl><type><name>time_t</name></type> <name>finish_time</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>result</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>pqSocketCheck</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>forRead</name></expr></argument>, <argument><expr><name>forWrite</name></expr></argument>, <argument><expr><name>finish_time</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>result</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>				<comment type="block">/* errorMessage is already set */</comment>

	<if_stmt><if>if <condition>(<expr><name>result</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conn</name><operator>-&gt;</operator><name>errorMessage</name></name></expr></argument>,
						  <argument><expr><call><name>libpq_gettext</name><argument_list>(<argument><expr><literal type="string">"timeout expired\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><literal type="number">1</literal></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * pqReadReady: is select() saying the file is ready to read?
 * Returns -1 on failure, 0 if not ready, 1 if ready.
 */</comment>
<function><type><name>int</name></type>
<name>pqReadReady</name><parameter_list>(<parameter><decl><type><name>PGconn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>pqSocketCheck</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>(</operator><name>time_t</name><operator>)</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * pqWriteReady: is select() saying the file is ready to write?
 * Returns -1 on failure, 0 if not ready, 1 if ready.
 */</comment>
<function><type><name>int</name></type>
<name>pqWriteReady</name><parameter_list>(<parameter><decl><type><name>PGconn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>pqSocketCheck</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>(</operator><name>time_t</name><operator>)</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Checks a socket, using poll or select, for data to be read, written,
 * or both.  Returns &gt;0 if one or more conditions are met, 0 if it timed
 * out, -1 if an error occurred.
 *
 * If SSL is in use, the SSL buffer is checked prior to checking the socket
 * for read data directly.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>pqSocketCheck</name><parameter_list>(<parameter><decl><type><name>PGconn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>forRead</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>forWrite</name></decl></parameter>, <parameter><decl><type><name>time_t</name></type> <name>end_time</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>result</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>conn</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>sock</name></name> <operator>==</operator> <name>PGINVALID_SOCKET</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conn</name><operator>-&gt;</operator><name>errorMessage</name></name></expr></argument>,
						  <argument><expr><call><name>libpq_gettext</name><argument_list>(<argument><expr><literal type="string">"invalid socket\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
	</block_content>}</block></if></if_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_SSL</name></cpp:ifdef>
	<comment type="block">/* Check for SSL library buffering read bytes */</comment>
	<if_stmt><if>if <condition>(<expr><name>forRead</name> <operator>&amp;&amp;</operator> <name><name>conn</name><operator>-&gt;</operator><name>ssl_in_use</name></name> <operator>&amp;&amp;</operator> <call><name>pgtls_read_pending</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* short-circuit the select */</comment>
		<return>return <expr><literal type="number">1</literal></expr>;</return>
	</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<comment type="block">/* We will retry as long as we get EINTR */</comment>
	<do>do<block type="pseudo"><block_content>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>pqSocketPoll</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>sock</name></name></expr></argument>, <argument><expr><name>forRead</name></expr></argument>, <argument><expr><name>forWrite</name></expr></argument>, <argument><expr><name>end_time</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block>
	while <condition>(<expr><name>result</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>SOCK_ERRNO</name> <operator>==</operator> <name>EINTR</name></expr>)</condition>;</do>

	<if_stmt><if>if <condition>(<expr><name>result</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name></type>		<name><name>sebuf</name><index>[<expr><literal type="number">256</literal></expr>]</index></name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conn</name><operator>-&gt;</operator><name>errorMessage</name></name></expr></argument>,
						  <argument><expr><call><name>libpq_gettext</name><argument_list>(<argument><expr><literal type="string">"select() failed: %s\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
						  <argument><expr><call><name>SOCK_STRERROR</name><argument_list>(<argument><expr><name>SOCK_ERRNO</name></expr></argument>, <argument><expr><name>sebuf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>sebuf</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * Check a file descriptor for read and/or write data, possibly waiting.
 * If neither forRead nor forWrite are set, immediately return a timeout
 * condition (without waiting).  Return &gt;0 if condition is met, 0
 * if a timeout occurred, -1 if an error or interrupt occurred.
 *
 * Timeout is infinite if end_time is -1.  Timeout is immediate (no blocking)
 * if end_time is 0 (or indeed, any time before now).
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>pqSocketPoll</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>sock</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>forRead</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>forWrite</name></decl></parameter>, <parameter><decl><type><name>time_t</name></type> <name>end_time</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* We use poll(2) if available, otherwise select(2) */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_POLL</name></cpp:ifdef>
	<decl_stmt><decl><type><name><name>struct</name> <name>pollfd</name></name></type> <name>input_fd</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>timeout_ms</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>forRead</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>forWrite</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name><name>input_fd</name><operator>.</operator><name>fd</name></name> <operator>=</operator> <name>sock</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>input_fd</name><operator>.</operator><name>events</name></name> <operator>=</operator> <name>POLLERR</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>input_fd</name><operator>.</operator><name>revents</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>forRead</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>input_fd</name><operator>.</operator><name>events</name></name> <operator>|=</operator> <name>POLLIN</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>forWrite</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>input_fd</name><operator>.</operator><name>events</name></name> <operator>|=</operator> <name>POLLOUT</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Compute appropriate timeout interval */</comment>
	<if_stmt><if>if <condition>(<expr><name>end_time</name> <operator>==</operator> <operator>(</operator><operator>(</operator><name>time_t</name><operator>)</operator> <operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>timeout_ms</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if>
	<else>else
	<block>{<block_content>
		<decl_stmt><decl><type><name>time_t</name></type>		<name>now</name> <init>= <expr><call><name>time</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>end_time</name> <operator>&gt;</operator> <name>now</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>timeout_ms</name> <operator>=</operator> <operator>(</operator><name>end_time</name> <operator>-</operator> <name>now</name><operator>)</operator> <operator>*</operator> <literal type="number">1000</literal></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>timeout_ms</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></else></if_stmt>

	<return>return <expr><call><name>poll</name><argument_list>(<argument><expr><operator>&amp;</operator><name>input_fd</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>timeout_ms</name></expr></argument>)</argument_list></call></expr>;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>							<comment type="block">/* !HAVE_POLL */</comment>

	<decl_stmt><decl><type><name>fd_set</name></type>		<name>input_mask</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>fd_set</name></type>		<name>output_mask</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>fd_set</name></type>		<name>except_mask</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>timeval</name></name></type> <name>timeout</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>timeval</name></name> <modifier>*</modifier></type><name>ptr_timeout</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>forRead</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>forWrite</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>FD_ZERO</name><argument_list>(<argument><expr><operator>&amp;</operator><name>input_mask</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>FD_ZERO</name><argument_list>(<argument><expr><operator>&amp;</operator><name>output_mask</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>FD_ZERO</name><argument_list>(<argument><expr><operator>&amp;</operator><name>except_mask</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>forRead</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>FD_SET</name><argument_list>(<argument><expr><name>sock</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>input_mask</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>forWrite</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>FD_SET</name><argument_list>(<argument><expr><name>sock</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>output_mask</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><call><name>FD_SET</name><argument_list>(<argument><expr><name>sock</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>except_mask</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Compute appropriate timeout interval */</comment>
	<if_stmt><if>if <condition>(<expr><name>end_time</name> <operator>==</operator> <operator>(</operator><operator>(</operator><name>time_t</name><operator>)</operator> <operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>ptr_timeout</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></if>
	<else>else
	<block>{<block_content>
		<decl_stmt><decl><type><name>time_t</name></type>		<name>now</name> <init>= <expr><call><name>time</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>end_time</name> <operator>&gt;</operator> <name>now</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>timeout</name><operator>.</operator><name>tv_sec</name></name> <operator>=</operator> <name>end_time</name> <operator>-</operator> <name>now</name></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>timeout</name><operator>.</operator><name>tv_sec</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>
		<expr_stmt><expr><name><name>timeout</name><operator>.</operator><name>tv_usec</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name>ptr_timeout</name> <operator>=</operator> <operator>&amp;</operator><name>timeout</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<return>return <expr><call><name>select</name><argument_list>(<argument><expr><name>sock</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>input_mask</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>output_mask</name></expr></argument>,
				  <argument><expr><operator>&amp;</operator><name>except_mask</name></expr></argument>, <argument><expr><name>ptr_timeout</name></expr></argument>)</argument_list></call></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>							<comment type="block">/* HAVE_POLL */</comment>
</block_content>}</block></function>


<comment type="block">/*
 * A couple of "miscellaneous" multibyte related functions. They used
 * to be in fe-print.c but that file is doomed.
 */</comment>

<comment type="block">/*
 * returns the byte length of the character beginning at s, using the
 * specified encoding.
 */</comment>
<function><type><name>int</name></type>
<name>PQmblen</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>s</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>encoding</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>pg_encoding_mblen</name><argument_list>(<argument><expr><name>encoding</name></expr></argument>, <argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * returns the display length of the character beginning at s, using the
 * specified encoding.
 */</comment>
<function><type><name>int</name></type>
<name>PQdsplen</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>s</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>encoding</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>pg_encoding_dsplen</name><argument_list>(<argument><expr><name>encoding</name></expr></argument>, <argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Get encoding id from environment variable PGCLIENTENCODING.
 */</comment>
<function><type><name>int</name></type>
<name>PQenv2encoding</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>str</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>encoding</name> <init>= <expr><name>PG_SQL_ASCII</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>str</name> <operator>=</operator> <call><name>getenv</name><argument_list>(<argument><expr><literal type="string">"PGCLIENTENCODING"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>str</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>str</name> <operator>!=</operator> <literal type="char">'\0'</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>encoding</name> <operator>=</operator> <call><name>pg_char_to_encoding</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>encoding</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>encoding</name> <operator>=</operator> <name>PG_SQL_ASCII</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><name>encoding</name></expr>;</return>
</block_content>}</block></function>


<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>ENABLE_NLS</name></cpp:ifdef>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>libpq_binddomain</name><parameter_list>()</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type> <name>already_bound</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>already_bound</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* bindtextdomain() does not preserve errno */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WIN32</name></cpp:ifdef>
		<decl_stmt><decl><type><name>int</name></type>			<name>save_errno</name> <init>= <expr><call><name>GetLastError</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
		<decl_stmt><decl><type><name>int</name></type>			<name>save_errno</name> <init>= <expr><name>errno</name></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
		<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>ldir</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>already_bound</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<comment type="block">/* No relocatable lookup here because the binary could be anywhere */</comment>
		<expr_stmt><expr><name>ldir</name> <operator>=</operator> <call><name>getenv</name><argument_list>(<argument><expr><literal type="string">"PGLOCALEDIR"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>ldir</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>ldir</name> <operator>=</operator> <name>LOCALEDIR</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>bindtextdomain</name><argument_list>(<argument><expr><call><name>PG_TEXTDOMAIN</name><argument_list>(<argument><expr><literal type="string">"libpq"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>ldir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WIN32</name></cpp:ifdef>
		<expr_stmt><expr><call><name>SetLastError</name><argument_list>(<argument><expr><name>save_errno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
		<expr_stmt><expr><name>errno</name> <operator>=</operator> <name>save_errno</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><name>char</name> <modifier>*</modifier></type>
<name>libpq_gettext</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>msgid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>libpq_binddomain</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><call><name>dgettext</name><argument_list>(<argument><expr><call><name>PG_TEXTDOMAIN</name><argument_list>(<argument><expr><literal type="string">"libpq"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>msgid</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>char</name> <modifier>*</modifier></type>
<name>libpq_ngettext</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>msgid</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>msgid_plural</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>long</name></type> <name>n</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>libpq_binddomain</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><call><name>dngettext</name><argument_list>(<argument><expr><call><name>PG_TEXTDOMAIN</name><argument_list>(<argument><expr><literal type="string">"libpq"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>msgid</name></expr></argument>, <argument><expr><name>msgid_plural</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>							<comment type="block">/* ENABLE_NLS */</comment>

<comment type="block">/*
 * POLAR px
 * pqFlushNonBlocking:
 *
 * wrapper for pqFlush, used by the dispatcher.
 * conn will be temporarily set to non-blocking mode,
 * so that if not all data could be sent on 1st attempt,
 * pqFlushNonBlocking will return 1 instead of waiting/retrying.
 *
 * Return 0 on success, -1 on failure and 1 when not all data could be sent
 */</comment>
<function><type><name>int</name></type>
<name>pqFlushNonBlocking</name><parameter_list>(<parameter><decl><type><name>PGconn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>ret</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>old</name> <init>= <expr><name><name>conn</name><operator>-&gt;</operator><name>nonblocking</name></name></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>nonblocking</name></name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>pqFlush</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>nonblocking</name></name> <operator>=</operator> <name>old</name></expr>;</expr_stmt>
	<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>

</unit>
