<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/PolarDB-for-PostgreSQL/src/backend/regex/regcomp.c"><comment type="block">/*
 * re_*comp and friends - compile REs
 * This file #includes several others (see the bottom).
 *
 * Copyright (c) 1998, 1999 Henry Spencer.  All rights reserved.
 *
 * Development of this software was funded, in part, by Cray Research Inc.,
 * UUNET Communications Services Inc., Sun Microsystems Inc., and Scriptics
 * Corporation, none of whom are responsible for the results.  The author
 * thanks all of them.
 *
 * Redistribution and use in source and binary forms -- with or without
 * modification -- are permitted for any purpose, provided that
 * redistributions in source form retain this entire copyright notice and
 * indicate the origin and nature of any modifications.
 *
 * I'd appreciate being given credit for this package in the documentation
 * of software which uses it, but that is not a requirement.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES,
 * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
 * AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL
 * HENRY SPENCER BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
 * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
 * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
 * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * src/backend/regex/regcomp.c
 *
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"regex/regguts.h"</cpp:file></cpp:include>

<comment type="block">/*
 * forward declarations, up here so forward datatypes etc. are defined early
 */</comment>
<comment type="block">/* === regcomp.c === */</comment>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>moresubs</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>vars</name></name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>int</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type>	<name>freev</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>vars</name></name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>int</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>makesearch</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>vars</name></name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>nfa</name></name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name><name>struct</name> <name>subre</name></name> <modifier>*</modifier></type><name>parse</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>vars</name></name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>int</name></type></decl></parameter>, <parameter><decl><type><name>int</name></type></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>state</name></name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>state</name></name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name><name>struct</name> <name>subre</name></name> <modifier>*</modifier></type><name>parsebranch</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>vars</name></name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>int</name></type></decl></parameter>, <parameter><decl><type><name>int</name></type></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>state</name></name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>state</name></name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>int</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>parseqatom</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>vars</name></name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>int</name></type></decl></parameter>, <parameter><decl><type><name>int</name></type></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>state</name></name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>state</name></name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>subre</name></name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>nonword</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>vars</name></name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>int</name></type></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>state</name></name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>state</name></name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>word</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>vars</name></name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>int</name></type></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>state</name></name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>state</name></name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type>	<name>scannum</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>vars</name></name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>repeat</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>vars</name></name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>state</name></name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>state</name></name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>int</name></type></decl></parameter>, <parameter><decl><type><name>int</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>bracket</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>vars</name></name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>state</name></name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>state</name></name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>cbracket</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>vars</name></name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>state</name></name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>state</name></name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>brackpart</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>vars</name></name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>state</name></name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>state</name></name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <specifier>const</specifier> <name>chr</name> <modifier>*</modifier></type><name>scanplain</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>vars</name></name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>onechr</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>vars</name></name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>chr</name></type></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>state</name></name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>state</name></name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>wordchrs</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>vars</name></name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>processlacon</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>vars</name></name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>state</name></name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>state</name></name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>int</name></type></decl></parameter>,
			 <parameter><decl><type><name><name>struct</name> <name>state</name></name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>state</name></name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name><name>struct</name> <name>subre</name></name> <modifier>*</modifier></type><name>subre</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>vars</name></name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>int</name></type></decl></parameter>, <parameter><decl><type><name>int</name></type></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>state</name></name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>state</name></name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>freesubre</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>vars</name></name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>subre</name></name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>freesrnode</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>vars</name></name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>subre</name></name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>optst</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>vars</name></name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>subre</name></name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type>	<name>numst</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>subre</name></name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>int</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>markst</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>subre</name></name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>cleanst</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>vars</name></name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>long</name></type> <name>nfatree</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>vars</name></name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>subre</name></name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>FILE</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>long</name></type> <name>nfanode</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>vars</name></name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>subre</name></name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>int</name></type></decl></parameter>, <parameter><decl><type><name>FILE</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type>	<name>newlacon</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>vars</name></name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>state</name></name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>state</name></name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>int</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>freelacons</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>subre</name></name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>int</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>rfree</name><parameter_list>(<parameter><decl><type><name>regex_t</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type>	<name>rcancelrequested</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type>	<name>rstacktoodeep</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>REG_DEBUG</name></cpp:ifdef>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>dump</name><parameter_list>(<parameter><decl><type><name>regex_t</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>FILE</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>dumpst</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>subre</name></name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>FILE</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>int</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>stdump</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>subre</name></name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>FILE</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>int</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>stid</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>subre</name></name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>size_t</name></type></decl></parameter>)</parameter_list>;</function_decl>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<comment type="block">/* === regc_lex.c === */</comment>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>lexstart</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>vars</name></name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>prefixes</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>vars</name></name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>lexnest</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>vars</name></name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>chr</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>chr</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>lexword</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>vars</name></name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type>	<name>next</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>vars</name></name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type>	<name>lexescape</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>vars</name></name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>chr</name></type>	<name>lexdigits</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>vars</name></name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>int</name></type></decl></parameter>, <parameter><decl><type><name>int</name></type></decl></parameter>, <parameter><decl><type><name>int</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type>	<name>brenext</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>vars</name></name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>chr</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>skip</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>vars</name></name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>chr</name></type>	<name>newline</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>chr</name></type>	<name>chrnamed</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>vars</name></name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>chr</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>chr</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>chr</name></type></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/* === regc_color.c === */</comment>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>initcm</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>vars</name></name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>colormap</name></name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>freecm</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>colormap</name></name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>color</name></type> <name>maxcolor</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>colormap</name></name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>color</name></type> <name>newcolor</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>colormap</name></name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>freecolor</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>colormap</name></name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>color</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>color</name></type> <name>pseudocolor</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>colormap</name></name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>color</name></type> <name>subcolor</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>colormap</name></name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>chr</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>color</name></type> <name>subcolorhi</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>colormap</name></name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>color</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>color</name></type> <name>newsub</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>colormap</name></name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>color</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type>	<name>newhicolorrow</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>colormap</name></name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>int</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>newhicolorcols</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>colormap</name></name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>subcolorcvec</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>vars</name></name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>cvec</name></name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>state</name></name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>state</name></name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>subcoloronechr</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>vars</name></name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>chr</name></type></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>state</name></name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>state</name></name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>color</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>subcoloronerange</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>vars</name></name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>chr</name></type></decl></parameter>, <parameter><decl><type><name>chr</name></type></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>state</name></name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>state</name></name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>color</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>subcoloronerow</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>vars</name></name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>int</name></type></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>state</name></name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>state</name></name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>color</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>okcolors</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>nfa</name></name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>colormap</name></name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>colorchain</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>colormap</name></name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>arc</name></name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>uncolorchain</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>colormap</name></name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>arc</name></name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>rainbow</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>nfa</name></name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>colormap</name></name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>int</name></type></decl></parameter>, <parameter><decl><type><name>color</name></type></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>state</name></name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>state</name></name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>colorcomplement</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>nfa</name></name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>colormap</name></name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>int</name></type></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>state</name></name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>state</name></name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>state</name></name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>REG_DEBUG</name></cpp:ifdef>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>dumpcolors</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>colormap</name></name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>FILE</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>dumpchr</name><parameter_list>(<parameter><decl><type><name>chr</name></type></decl></parameter>, <parameter><decl><type><name>FILE</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<comment type="block">/* === regc_nfa.c === */</comment>
<function_decl><type><specifier>static</specifier> <name><name>struct</name> <name>nfa</name></name> <modifier>*</modifier></type><name>newnfa</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>vars</name></name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>colormap</name></name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>nfa</name></name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>freenfa</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>nfa</name></name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name><name>struct</name> <name>state</name></name> <modifier>*</modifier></type><name>newstate</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>nfa</name></name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name><name>struct</name> <name>state</name></name> <modifier>*</modifier></type><name>newfstate</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>nfa</name></name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>flag</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>dropstate</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>nfa</name></name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>state</name></name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>freestate</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>nfa</name></name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>state</name></name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>destroystate</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>nfa</name></name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>state</name></name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>newarc</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>nfa</name></name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>int</name></type></decl></parameter>, <parameter><decl><type><name>color</name></type></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>state</name></name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>state</name></name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>createarc</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>nfa</name></name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>int</name></type></decl></parameter>, <parameter><decl><type><name>color</name></type></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>state</name></name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>state</name></name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name><name>struct</name> <name>arc</name></name> <modifier>*</modifier></type><name>allocarc</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>nfa</name></name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>state</name></name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>freearc</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>nfa</name></name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>arc</name></name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>changearctarget</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>arc</name></name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>state</name></name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type>	<name>hasnonemptyout</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>state</name></name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name><name>struct</name> <name>arc</name></name> <modifier>*</modifier></type><name>findarc</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>state</name></name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>int</name></type></decl></parameter>, <parameter><decl><type><name>color</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>cparc</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>nfa</name></name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>arc</name></name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>state</name></name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>state</name></name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>sortins</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>nfa</name></name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>state</name></name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type>	<name>sortins_cmp</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>sortouts</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>nfa</name></name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>state</name></name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type>	<name>sortouts_cmp</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>moveins</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>nfa</name></name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>state</name></name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>state</name></name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>copyins</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>nfa</name></name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>state</name></name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>state</name></name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>mergeins</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>nfa</name></name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>state</name></name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>arc</name></name> <modifier>*</modifier><modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>int</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>moveouts</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>nfa</name></name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>state</name></name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>state</name></name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>copyouts</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>nfa</name></name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>state</name></name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>state</name></name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>cloneouts</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>nfa</name></name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>state</name></name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>state</name></name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>state</name></name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>int</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>delsub</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>nfa</name></name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>state</name></name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>state</name></name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>deltraverse</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>nfa</name></name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>state</name></name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>state</name></name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>dupnfa</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>nfa</name></name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>state</name></name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>state</name></name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>state</name></name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>state</name></name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>duptraverse</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>nfa</name></name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>state</name></name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>state</name></name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>cleartraverse</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>nfa</name></name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>state</name></name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name><name>struct</name> <name>state</name></name> <modifier>*</modifier></type><name>single_color_transition</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>state</name></name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>state</name></name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>specialcolors</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>nfa</name></name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>long</name></type> <name>optimize</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>nfa</name></name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>FILE</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>pullback</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>nfa</name></name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>FILE</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type>	<name>pull</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>nfa</name></name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>arc</name></name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>state</name></name> <modifier>*</modifier><modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>pushfwd</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>nfa</name></name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>FILE</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type>	<name>push</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>nfa</name></name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>arc</name></name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>state</name></name> <modifier>*</modifier><modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>INCOMPATIBLE</name></cpp:macro>	<cpp:value>1</cpp:value></cpp:define>		<comment type="block">/* destroys arc */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SATISFIED</name></cpp:macro>	<cpp:value>2</cpp:value></cpp:define>			<comment type="block">/* constraint satisfied */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>COMPATIBLE</name></cpp:macro>	<cpp:value>3</cpp:value></cpp:define>			<comment type="block">/* compatible but not satisfied yet */</comment>
<function_decl><type><specifier>static</specifier> <name>int</name></type>	<name>combine</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>arc</name></name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>arc</name></name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>fixempties</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>nfa</name></name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>FILE</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name><name>struct</name> <name>state</name></name> <modifier>*</modifier></type><name>emptyreachable</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>nfa</name></name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>state</name></name> <modifier>*</modifier></type></decl></parameter>,
			   <parameter><decl><type><name><name>struct</name> <name>state</name></name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>arc</name></name> <modifier>*</modifier><modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type>	<name>isconstraintarc</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>arc</name></name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type>	<name>hasconstraintout</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>state</name></name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>fixconstraintloops</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>nfa</name></name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>FILE</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type>	<name>findconstraintloop</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>nfa</name></name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>state</name></name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>breakconstraintloop</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>nfa</name></name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>state</name></name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>clonesuccessorstates</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>nfa</name></name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>state</name></name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>state</name></name> <modifier>*</modifier></type></decl></parameter>,
					 <parameter><decl><type><name><name>struct</name> <name>state</name></name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>arc</name></name> <modifier>*</modifier></type></decl></parameter>,
					 <parameter><decl><type><name>char</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>int</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>cleanup</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>nfa</name></name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>markreachable</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>nfa</name></name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>state</name></name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>state</name></name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>state</name></name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>markcanreach</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>nfa</name></name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>state</name></name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>state</name></name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>state</name></name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>long</name></type> <name>analyze</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>nfa</name></name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>compact</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>nfa</name></name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>cnfa</name></name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>carcsort</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>carc</name></name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>size_t</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type>	<name>carc_cmp</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>freecnfa</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>cnfa</name></name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>dumpnfa</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>nfa</name></name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>FILE</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>REG_DEBUG</name></cpp:ifdef>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>dumpstate</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>state</name></name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>FILE</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>dumparcs</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>state</name></name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>FILE</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>dumparc</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>arc</name></name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>state</name></name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>FILE</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>dumpcnfa</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>cnfa</name></name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>FILE</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>dumpcstate</name><parameter_list>(<parameter><decl><type><name>int</name></type></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>cnfa</name></name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>FILE</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<comment type="block">/* === regc_cvec.c === */</comment>
<function_decl><type><specifier>static</specifier> <name><name>struct</name> <name>cvec</name></name> <modifier>*</modifier></type><name>newcvec</name><parameter_list>(<parameter><decl><type><name>int</name></type></decl></parameter>, <parameter><decl><type><name>int</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name><name>struct</name> <name>cvec</name></name> <modifier>*</modifier></type><name>clearcvec</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>cvec</name></name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>addchr</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>cvec</name></name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>chr</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>addrange</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>cvec</name></name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>chr</name></type></decl></parameter>, <parameter><decl><type><name>chr</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name><name>struct</name> <name>cvec</name></name> <modifier>*</modifier></type><name>getcvec</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>vars</name></name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>int</name></type></decl></parameter>, <parameter><decl><type><name>int</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>freecvec</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>cvec</name></name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/* === regc_pg_locale.c === */</comment>
<function_decl><type><specifier>static</specifier> <name>int</name></type>	<name>pg_wc_isdigit</name><parameter_list>(<parameter><decl><type><name>pg_wchar</name></type> <name>c</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type>	<name>pg_wc_isalpha</name><parameter_list>(<parameter><decl><type><name>pg_wchar</name></type> <name>c</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type>	<name>pg_wc_isalnum</name><parameter_list>(<parameter><decl><type><name>pg_wchar</name></type> <name>c</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type>	<name>pg_wc_isupper</name><parameter_list>(<parameter><decl><type><name>pg_wchar</name></type> <name>c</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type>	<name>pg_wc_islower</name><parameter_list>(<parameter><decl><type><name>pg_wchar</name></type> <name>c</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type>	<name>pg_wc_isgraph</name><parameter_list>(<parameter><decl><type><name>pg_wchar</name></type> <name>c</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type>	<name>pg_wc_isprint</name><parameter_list>(<parameter><decl><type><name>pg_wchar</name></type> <name>c</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type>	<name>pg_wc_ispunct</name><parameter_list>(<parameter><decl><type><name>pg_wchar</name></type> <name>c</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type>	<name>pg_wc_isspace</name><parameter_list>(<parameter><decl><type><name>pg_wchar</name></type> <name>c</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>pg_wchar</name></type> <name>pg_wc_toupper</name><parameter_list>(<parameter><decl><type><name>pg_wchar</name></type> <name>c</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>pg_wchar</name></type> <name>pg_wc_tolower</name><parameter_list>(<parameter><decl><type><name>pg_wchar</name></type> <name>c</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/* === regc_locale.c === */</comment>
<function_decl><type><specifier>static</specifier> <name>chr</name></type>	<name>element</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>vars</name></name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>chr</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>chr</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name><name>struct</name> <name>cvec</name></name> <modifier>*</modifier></type><name>range</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>vars</name></name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>chr</name></type></decl></parameter>, <parameter><decl><type><name>chr</name></type></decl></parameter>, <parameter><decl><type><name>int</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type>	<name>before</name><parameter_list>(<parameter><decl><type><name>chr</name></type></decl></parameter>, <parameter><decl><type><name>chr</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name><name>struct</name> <name>cvec</name></name> <modifier>*</modifier></type><name>eclass</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>vars</name></name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>chr</name></type></decl></parameter>, <parameter><decl><type><name>int</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name><name>struct</name> <name>cvec</name></name> <modifier>*</modifier></type><name>cclass</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>vars</name></name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>chr</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>chr</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>int</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type>	<name>cclass_column_index</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>colormap</name></name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>chr</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name><name>struct</name> <name>cvec</name></name> <modifier>*</modifier></type><name>allcases</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>vars</name></name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>chr</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type>	<name>cmp</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>chr</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>chr</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>size_t</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type>	<name>casecmp</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>chr</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>chr</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>size_t</name></type></decl></parameter>)</parameter_list>;</function_decl>


<comment type="block">/* internal variables, bundled for easy passing around */</comment>
<struct>struct <name>vars</name>
<block>{
	<decl_stmt><decl><type><name>regex_t</name>    <modifier>*</modifier></type><name>re</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>chr</name>  <modifier>*</modifier></type><name>now</name></decl>;</decl_stmt>			<comment type="block">/* scan pointer into string */</comment>
	<decl_stmt><decl><type><specifier>const</specifier> <name>chr</name>  <modifier>*</modifier></type><name>stop</name></decl>;</decl_stmt>			<comment type="block">/* end of string */</comment>
	<decl_stmt><decl><type><specifier>const</specifier> <name>chr</name>  <modifier>*</modifier></type><name>savenow</name></decl>;</decl_stmt>		<comment type="block">/* saved now and stop for "subroutine call" */</comment>
	<decl_stmt><decl><type><specifier>const</specifier> <name>chr</name>  <modifier>*</modifier></type><name>savestop</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>err</name></decl>;</decl_stmt>			<comment type="block">/* error code (0 if none) */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>cflags</name></decl>;</decl_stmt>			<comment type="block">/* copy of compile flags */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>lasttype</name></decl>;</decl_stmt>		<comment type="block">/* type of previous token */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>nexttype</name></decl>;</decl_stmt>		<comment type="block">/* type of next token */</comment>
	<decl_stmt><decl><type><name>chr</name></type>			<name>nextvalue</name></decl>;</decl_stmt>		<comment type="block">/* value (if any) of next token */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>lexcon</name></decl>;</decl_stmt>			<comment type="block">/* lexical context type (see lex.c) */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>nsubexp</name></decl>;</decl_stmt>		<comment type="block">/* subexpression count */</comment>
	<decl_stmt><decl><type><name><name>struct</name> <name>subre</name></name> <modifier>*</modifier><modifier>*</modifier></type><name>subs</name></decl>;</decl_stmt>		<comment type="block">/* subRE pointer vector */</comment>
	<decl_stmt><decl><type><name>size_t</name></type>		<name>nsubs</name></decl>;</decl_stmt>			<comment type="block">/* length of vector */</comment>
	<decl_stmt><decl><type><name><name>struct</name> <name>subre</name></name> <modifier>*</modifier></type><name><name>sub10</name><index>[<expr><literal type="number">10</literal></expr>]</index></name></decl>;</decl_stmt>	<comment type="block">/* initial vector, enough for most */</comment>
	<decl_stmt><decl><type><name><name>struct</name> <name>nfa</name></name> <modifier>*</modifier></type><name>nfa</name></decl>;</decl_stmt>			<comment type="block">/* the NFA */</comment>
	<decl_stmt><decl><type><name><name>struct</name> <name>colormap</name></name> <modifier>*</modifier></type><name>cm</name></decl>;</decl_stmt>		<comment type="block">/* character color map */</comment>
	<decl_stmt><decl><type><name>color</name></type>		<name>nlcolor</name></decl>;</decl_stmt>		<comment type="block">/* color of newline */</comment>
	<decl_stmt><decl><type><name><name>struct</name> <name>state</name></name> <modifier>*</modifier></type><name>wordchrs</name></decl>;</decl_stmt>		<comment type="block">/* state in nfa holding word-char outarcs */</comment>
	<decl_stmt><decl><type><name><name>struct</name> <name>subre</name></name> <modifier>*</modifier></type><name>tree</name></decl>;</decl_stmt>			<comment type="block">/* subexpression tree */</comment>
	<decl_stmt><decl><type><name><name>struct</name> <name>subre</name></name> <modifier>*</modifier></type><name>treechain</name></decl>;</decl_stmt>	<comment type="block">/* all tree nodes allocated */</comment>
	<decl_stmt><decl><type><name><name>struct</name> <name>subre</name></name> <modifier>*</modifier></type><name>treefree</name></decl>;</decl_stmt>		<comment type="block">/* any free tree nodes */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>ntree</name></decl>;</decl_stmt>			<comment type="block">/* number of tree nodes, plus one */</comment>
	<decl_stmt><decl><type><name><name>struct</name> <name>cvec</name></name> <modifier>*</modifier></type><name>cv</name></decl>;</decl_stmt>			<comment type="block">/* interface cvec */</comment>
	<decl_stmt><decl><type><name><name>struct</name> <name>cvec</name></name> <modifier>*</modifier></type><name>cv2</name></decl>;</decl_stmt>			<comment type="block">/* utility cvec */</comment>
	<decl_stmt><decl><type><name><name>struct</name> <name>subre</name></name> <modifier>*</modifier></type><name>lacons</name></decl>;</decl_stmt>		<comment type="block">/* lookaround-constraint vector */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>nlacons</name></decl>;</decl_stmt>		<comment type="block">/* size of lacons[]; note that only slots
								 * numbered 1 .. nlacons-1 are used */</comment>
	<decl_stmt><decl><type><name>size_t</name></type>		<name>spaceused</name></decl>;</decl_stmt>		<comment type="block">/* approx. space used for compilation */</comment>
}</block>;</struct>

<comment type="block">/* parsing macros; most know that `v' is the struct vars pointer */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NEXT</name><parameter_list>()</parameter_list></cpp:macro>	<cpp:value>(next(v))</cpp:value></cpp:define>		<comment type="block">/* advance by one token */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SEE</name><parameter_list>(<parameter><type><name>t</name></type></parameter>)</parameter_list></cpp:macro>	<cpp:value>(v-&gt;nexttype == (t))</cpp:value></cpp:define>	<comment type="block">/* is next token this? */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>EAT</name><parameter_list>(<parameter><type><name>t</name></type></parameter>)</parameter_list></cpp:macro>	<cpp:value>(SEE(t) &amp;&amp; next(v))</cpp:value></cpp:define> <comment type="block">/* if next is this, swallow it */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>VISERR</name><parameter_list>(<parameter><type><name>vv</name></type></parameter>)</parameter_list></cpp:macro>	<cpp:value>((vv)-&gt;err != 0)</cpp:value></cpp:define>	<comment type="block">/* have we seen an error yet? */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ISERR</name><parameter_list>()</parameter_list></cpp:macro> <cpp:value>VISERR(v)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>VERR</name><parameter_list>(<parameter><type><name>vv</name></type></parameter>,<parameter><type><name>e</name></type></parameter>)</parameter_list></cpp:macro>	<cpp:value>((vv)-&gt;nexttype = EOS, \
					 (vv)-&gt;err = ((vv)-&gt;err ? (vv)-&gt;err : (e)))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ERR</name><parameter_list>(<parameter><type><name>e</name></type></parameter>)</parameter_list></cpp:macro>	<cpp:value>VERR(v, e)</cpp:value></cpp:define>		<comment type="block">/* record an error */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NOERR</name><parameter_list>()</parameter_list></cpp:macro> <cpp:value>{if (ISERR()) return;}</cpp:value></cpp:define>	<comment type="block">/* if error seen, return */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NOERRN</name><parameter_list>()</parameter_list></cpp:macro>	<cpp:value>{if (ISERR()) return NULL;}</cpp:value></cpp:define> <comment type="block">/* NOERR with retval */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NOERRZ</name><parameter_list>()</parameter_list></cpp:macro>	<cpp:value>{if (ISERR()) return 0;}</cpp:value></cpp:define>	<comment type="block">/* NOERR with retval */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>INSIST</name><parameter_list>(<parameter><type><name>c</name></type></parameter>, <parameter><type><name>e</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>do { if (!(c)) ERR(e); } while (0)</cpp:value></cpp:define> <comment type="block">/* error if c false */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NOTE</name><parameter_list>(<parameter><type><name>b</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(v-&gt;re-&gt;re_info |= (b))</cpp:value></cpp:define> <comment type="block">/* note visible condition */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>EMPTYARC</name><parameter_list>(<parameter><type><name>x</name></type></parameter>, <parameter><type><name>y</name></type></parameter>)</parameter_list></cpp:macro>	<cpp:value>newarc(v-&gt;nfa, EMPTY, 0, x, y)</cpp:value></cpp:define>

<comment type="block">/* token type codes, some also used as NFA arc types */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>EMPTY</name></cpp:macro>	<cpp:value>'n'</cpp:value></cpp:define>				<comment type="block">/* no token present */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>EOS</name></cpp:macro> <cpp:value>'e'</cpp:value></cpp:define>					<comment type="block">/* end of string */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PLAIN</name></cpp:macro>	<cpp:value>'p'</cpp:value></cpp:define>				<comment type="block">/* ordinary character */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DIGIT</name></cpp:macro>	<cpp:value>'d'</cpp:value></cpp:define>				<comment type="block">/* digit (in bound) */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BACKREF</name></cpp:macro> <cpp:value>'b'</cpp:value></cpp:define>				<comment type="block">/* back reference */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>COLLEL</name></cpp:macro>	<cpp:value>'I'</cpp:value></cpp:define>				<comment type="block">/* start of [. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ECLASS</name></cpp:macro>	<cpp:value>'E'</cpp:value></cpp:define>				<comment type="block">/* start of [= */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CCLASS</name></cpp:macro>	<cpp:value>'C'</cpp:value></cpp:define>				<comment type="block">/* start of [: */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>END</name></cpp:macro> <cpp:value>'X'</cpp:value></cpp:define>					<comment type="block">/* end of [. [= [: */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RANGE</name></cpp:macro>	<cpp:value>'R'</cpp:value></cpp:define>				<comment type="block">/* - within [] which might be range delim. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LACON</name></cpp:macro>	<cpp:value>'L'</cpp:value></cpp:define>				<comment type="block">/* lookaround constraint subRE */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>AHEAD</name></cpp:macro>	<cpp:value>'a'</cpp:value></cpp:define>				<comment type="block">/* color-lookahead arc */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BEHIND</name></cpp:macro>	<cpp:value>'r'</cpp:value></cpp:define>				<comment type="block">/* color-lookbehind arc */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>WBDRY</name></cpp:macro>	<cpp:value>'w'</cpp:value></cpp:define>				<comment type="block">/* word boundary constraint */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NWBDRY</name></cpp:macro>	<cpp:value>'W'</cpp:value></cpp:define>				<comment type="block">/* non-word-boundary constraint */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SBEGIN</name></cpp:macro>	<cpp:value>'A'</cpp:value></cpp:define>				<comment type="block">/* beginning of string (even if not BOL) */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SEND</name></cpp:macro>	<cpp:value>'Z'</cpp:value></cpp:define>				<comment type="block">/* end of string (even if not EOL) */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PREFER</name></cpp:macro>	<cpp:value>'P'</cpp:value></cpp:define>				<comment type="block">/* length preference */</comment>

<comment type="block">/* is an arc colored, and hence on a color chain? */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>COLORED</name><parameter_list>(<parameter><type><name>a</name></type></parameter>)</parameter_list></cpp:macro> \
	<cpp:value>((a)-&gt;type == PLAIN || (a)-&gt;type == AHEAD || (a)-&gt;type == BEHIND)</cpp:value></cpp:define>


<comment type="block">/* static function list */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name><name>struct</name> <name>fns</name></name></type> <name>functions</name> <init>= <expr><block>{
	<expr><name>rfree</name></expr>,						<comment type="block">/* regfree insides */</comment>
	<expr><name>rcancelrequested</name></expr>,			<comment type="block">/* check for cancel request */</comment>
	<expr><name>rstacktoodeep</name></expr>				<comment type="block">/* check for stack getting dangerously deep */</comment>
}</block></expr></init></decl>;</decl_stmt>



<comment type="block">/*
 * pg_regcomp - compile regular expression
 *
 * Note: on failure, no resources remain allocated, so pg_regfree()
 * need not be applied to re.
 */</comment>
<function><type><name>int</name></type>
<name>pg_regcomp</name><parameter_list>(<parameter><decl><type><name>regex_t</name> <modifier>*</modifier></type><name>re</name></decl></parameter>,
		   <parameter><decl><type><specifier>const</specifier> <name>chr</name> <modifier>*</modifier></type><name>string</name></decl></parameter>,
		   <parameter><decl><type><name>size_t</name></type> <name>len</name></decl></parameter>,
		   <parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>,
		   <parameter><decl><type><name>Oid</name></type> <name>collation</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name><name>struct</name> <name>vars</name></name></type> <name>var</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>vars</name></name> <modifier>*</modifier></type><name>v</name> <init>= <expr><operator>&amp;</operator><name>var</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>guts</name></name> <modifier>*</modifier></type><name>g</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>size_t</name></type>		<name>j</name></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>REG_DEBUG</name></cpp:ifdef>
	<decl_stmt><decl><type><name>FILE</name>	   <modifier>*</modifier></type><name>debug</name> <init>= <expr><ternary><condition><expr><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>REG_PROGRESS</name><operator>)</operator></expr> ?</condition><then> <expr><name>stdout</name></expr> </then><else>: <expr><operator>(</operator><name>FILE</name> <operator>*</operator><operator>)</operator> <name>NULL</name></expr></else></ternary></expr></init></decl>;</decl_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	<decl_stmt><decl><type><name>FILE</name>	   <modifier>*</modifier></type><name>debug</name> <init>= <expr><operator>(</operator><name>FILE</name> <operator>*</operator><operator>)</operator> <name>NULL</name></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:define>#<cpp:directive>define</cpp:directive>  <cpp:macro><name>CNOERR</name><parameter_list>()</parameter_list></cpp:macro>	 <cpp:value>{ if (ISERR()) return freev(v, v-&gt;err); }</cpp:value></cpp:define>

	<comment type="block">/* sanity checks */</comment>

	<if_stmt><if>if <condition>(<expr><name>re</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name>string</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>REG_INVARG</name></expr>;</return></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>REG_QUOTE</name><operator>)</operator> <operator>&amp;&amp;</operator>
		<operator>(</operator><name>flags</name> <operator>&amp;</operator> <operator>(</operator><name>REG_ADVANCED</name> <operator>|</operator> <name>REG_EXPANDED</name> <operator>|</operator> <name>REG_NEWLINE</name><operator>)</operator><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>REG_INVARG</name></expr>;</return></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>REG_EXTENDED</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>REG_ADVF</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>REG_INVARG</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* Initialize locale-dependent support */</comment>
	<expr_stmt><expr><call><name>pg_set_regex_collation</name><argument_list>(<argument><expr><name>collation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* initial setup (after which freev() is callable) */</comment>
	<expr_stmt><expr><name><name>v</name><operator>-&gt;</operator><name>re</name></name> <operator>=</operator> <name>re</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>v</name><operator>-&gt;</operator><name>now</name></name> <operator>=</operator> <name>string</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>v</name><operator>-&gt;</operator><name>stop</name></name> <operator>=</operator> <name><name>v</name><operator>-&gt;</operator><name>now</name></name> <operator>+</operator> <name>len</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>v</name><operator>-&gt;</operator><name>savenow</name></name> <operator>=</operator> <name><name>v</name><operator>-&gt;</operator><name>savestop</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>v</name><operator>-&gt;</operator><name>err</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>v</name><operator>-&gt;</operator><name>cflags</name></name> <operator>=</operator> <name>flags</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>v</name><operator>-&gt;</operator><name>nsubexp</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>v</name><operator>-&gt;</operator><name>subs</name></name> <operator>=</operator> <name><name>v</name><operator>-&gt;</operator><name>sub10</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>v</name><operator>-&gt;</operator><name>nsubs</name></name> <operator>=</operator> <literal type="number">10</literal></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name><name>v</name><operator>-&gt;</operator><name>nsubs</name></name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>v</name><operator>-&gt;</operator><name>subs</name><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></for>
	<expr_stmt><expr><name><name>v</name><operator>-&gt;</operator><name>nfa</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>v</name><operator>-&gt;</operator><name>cm</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>v</name><operator>-&gt;</operator><name>nlcolor</name></name> <operator>=</operator> <name>COLORLESS</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>v</name><operator>-&gt;</operator><name>wordchrs</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>v</name><operator>-&gt;</operator><name>tree</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>v</name><operator>-&gt;</operator><name>treechain</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>v</name><operator>-&gt;</operator><name>treefree</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>v</name><operator>-&gt;</operator><name>cv</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>v</name><operator>-&gt;</operator><name>cv2</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>v</name><operator>-&gt;</operator><name>lacons</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>v</name><operator>-&gt;</operator><name>nlacons</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>v</name><operator>-&gt;</operator><name>spaceused</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>re</name><operator>-&gt;</operator><name>re_magic</name></name> <operator>=</operator> <name>REMAGIC</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>re</name><operator>-&gt;</operator><name>re_info</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>			<comment type="block">/* bits get set during parse */</comment>
	<expr_stmt><expr><name><name>re</name><operator>-&gt;</operator><name>re_csize</name></name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>chr</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>re</name><operator>-&gt;</operator><name>re_collation</name></name> <operator>=</operator> <name>collation</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>re</name><operator>-&gt;</operator><name>re_guts</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>re</name><operator>-&gt;</operator><name>re_fns</name></name> <operator>=</operator> <call><name>VS</name><argument_list>(<argument><expr><operator>&amp;</operator><name>functions</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* more complex setup, malloced things */</comment>
	<expr_stmt><expr><name><name>re</name><operator>-&gt;</operator><name>re_guts</name></name> <operator>=</operator> <call><name>VS</name><argument_list>(<argument><expr><call><name>MALLOC</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr>struct <name>guts</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>re</name><operator>-&gt;</operator><name>re_guts</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><call><name>freev</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>REG_ESPACE</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>g</name> <operator>=</operator> <operator>(</operator>struct <name>guts</name> <operator>*</operator><operator>)</operator> <name><name>re</name><operator>-&gt;</operator><name>re_guts</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>tree</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>initcm</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>g</name><operator>-&gt;</operator><name>cmap</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>v</name><operator>-&gt;</operator><name>cm</name></name> <operator>=</operator> <operator>&amp;</operator><name><name>g</name><operator>-&gt;</operator><name>cmap</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>lacons</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>nlacons</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ZAPCNFA</name><argument_list>(<argument><expr><name><name>g</name><operator>-&gt;</operator><name>search</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>v</name><operator>-&gt;</operator><name>nfa</name></name> <operator>=</operator> <call><name>newnfa</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name><name>v</name><operator>-&gt;</operator><name>cm</name></name></expr></argument>, <argument><expr><operator>(</operator>struct <name>nfa</name> <operator>*</operator><operator>)</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>CNOERR</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* set up a reasonably-sized transient cvec for getcvec usage */</comment>
	<expr_stmt><expr><name><name>v</name><operator>-&gt;</operator><name>cv</name></name> <operator>=</operator> <call><name>newcvec</name><argument_list>(<argument><expr><literal type="number">100</literal></expr></argument>, <argument><expr><literal type="number">20</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>v</name><operator>-&gt;</operator><name>cv</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><call><name>freev</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>REG_ESPACE</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* parsing */</comment>
	<expr_stmt><expr><call><name>lexstart</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>				<comment type="block">/* also handles prefixes */</comment>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>v</name><operator>-&gt;</operator><name>cflags</name></name> <operator>&amp;</operator> <name>REG_NLSTOP</name><operator>)</operator> <operator>||</operator> <operator>(</operator><name><name>v</name><operator>-&gt;</operator><name>cflags</name></name> <operator>&amp;</operator> <name>REG_NLANCH</name><operator>)</operator></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* assign newline a unique color */</comment>
		<expr_stmt><expr><name><name>v</name><operator>-&gt;</operator><name>nlcolor</name></name> <operator>=</operator> <call><name>subcolor</name><argument_list>(<argument><expr><name><name>v</name><operator>-&gt;</operator><name>cm</name></name></expr></argument>, <argument><expr><call><name>newline</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>okcolors</name><argument_list>(<argument><expr><name><name>v</name><operator>-&gt;</operator><name>nfa</name></name></expr></argument>, <argument><expr><name><name>v</name><operator>-&gt;</operator><name>cm</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>CNOERR</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>v</name><operator>-&gt;</operator><name>tree</name></name> <operator>=</operator> <call><name>parse</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>EOS</name></expr></argument>, <argument><expr><name>PLAIN</name></expr></argument>, <argument><expr><name><name>v</name><operator>-&gt;</operator><name>nfa</name><operator>-&gt;</operator><name>init</name></name></expr></argument>, <argument><expr><name><name>v</name><operator>-&gt;</operator><name>nfa</name><operator>-&gt;</operator><name>final</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>SEE</name><argument_list>(<argument><expr><name>EOS</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>			<comment type="block">/* even if error; ISERR() =&gt; SEE(EOS) */</comment>
	<expr_stmt><expr><call><name>CNOERR</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>v</name><operator>-&gt;</operator><name>tree</name></name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* finish setup of nfa and its subre tree */</comment>
	<expr_stmt><expr><call><name>specialcolors</name><argument_list>(<argument><expr><name><name>v</name><operator>-&gt;</operator><name>nfa</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>CNOERR</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>REG_DEBUG</name></cpp:ifdef>
	<if_stmt><if>if <condition>(<expr><name>debug</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>debug</name></expr></argument>, <argument><expr><literal type="string">"\n\n\n========= RAW ==========\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>dumpnfa</name><argument_list>(<argument><expr><name><name>v</name><operator>-&gt;</operator><name>nfa</name></name></expr></argument>, <argument><expr><name>debug</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>dumpst</name><argument_list>(<argument><expr><name><name>v</name><operator>-&gt;</operator><name>tree</name></name></expr></argument>, <argument><expr><name>debug</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<expr_stmt><expr><call><name>optst</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name><name>v</name><operator>-&gt;</operator><name>tree</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>v</name><operator>-&gt;</operator><name>ntree</name></name> <operator>=</operator> <call><name>numst</name><argument_list>(<argument><expr><name><name>v</name><operator>-&gt;</operator><name>tree</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>markst</name><argument_list>(<argument><expr><name><name>v</name><operator>-&gt;</operator><name>tree</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>cleanst</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>REG_DEBUG</name></cpp:ifdef>
	<if_stmt><if>if <condition>(<expr><name>debug</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>debug</name></expr></argument>, <argument><expr><literal type="string">"\n\n\n========= TREE FIXED ==========\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>dumpst</name><argument_list>(<argument><expr><name><name>v</name><operator>-&gt;</operator><name>tree</name></name></expr></argument>, <argument><expr><name>debug</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<comment type="block">/* build compacted NFAs for tree and lacons */</comment>
	<expr_stmt><expr><name><name>re</name><operator>-&gt;</operator><name>re_info</name></name> <operator>|=</operator> <call><name>nfatree</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name><name>v</name><operator>-&gt;</operator><name>tree</name></name></expr></argument>, <argument><expr><name>debug</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>CNOERR</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>v</name><operator>-&gt;</operator><name>nlacons</name></name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <name><name>v</name><operator>-&gt;</operator><name>lacons</name></name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>v</name><operator>-&gt;</operator><name>nlacons</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name><name>struct</name> <name>subre</name></name> <modifier>*</modifier></type><name>lasub</name> <init>= <expr><operator>&amp;</operator><name><name>v</name><operator>-&gt;</operator><name>lacons</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>REG_DEBUG</name></cpp:ifdef>
		<if_stmt><if>if <condition>(<expr><name>debug</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>debug</name></expr></argument>, <argument><expr><literal type="string">"\n\n\n========= LA%d ==========\n"</literal></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

		<comment type="block">/* Prepend .* to pattern if it's a lookbehind LACON */</comment>
		<expr_stmt><expr><call><name>nfanode</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>lasub</name></expr></argument>, <argument><expr><operator>!</operator><call><name>LATYPE_IS_AHEAD</name><argument_list>(<argument><expr><name><name>lasub</name><operator>-&gt;</operator><name>subno</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>debug</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>
	<expr_stmt><expr><call><name>CNOERR</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>v</name><operator>-&gt;</operator><name>tree</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>SHORTER</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>NOTE</name><argument_list>(<argument><expr><name>REG_USHORTEST</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* build compacted NFAs for tree, lacons, fast search */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>REG_DEBUG</name></cpp:ifdef>
	<if_stmt><if>if <condition>(<expr><name>debug</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>debug</name></expr></argument>, <argument><expr><literal type="string">"\n\n\n========= SEARCH ==========\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<comment type="block">/* can sacrifice main NFA now, so use it as work area */</comment>
	<expr_stmt><expr><operator>(</operator><name>DISCARD</name><operator>)</operator> <call><name>optimize</name><argument_list>(<argument><expr><name><name>v</name><operator>-&gt;</operator><name>nfa</name></name></expr></argument>, <argument><expr><name>debug</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>CNOERR</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>makesearch</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name><name>v</name><operator>-&gt;</operator><name>nfa</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>CNOERR</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>compact</name><argument_list>(<argument><expr><name><name>v</name><operator>-&gt;</operator><name>nfa</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>g</name><operator>-&gt;</operator><name>search</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>CNOERR</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* looks okay, package it up */</comment>
	<expr_stmt><expr><name><name>re</name><operator>-&gt;</operator><name>re_nsub</name></name> <operator>=</operator> <name><name>v</name><operator>-&gt;</operator><name>nsubexp</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>v</name><operator>-&gt;</operator><name>re</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>				<comment type="block">/* freev no longer frees re */</comment>
	<expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>magic</name></name> <operator>=</operator> <name>GUTSMAGIC</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>cflags</name></name> <operator>=</operator> <name><name>v</name><operator>-&gt;</operator><name>cflags</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>info</name></name> <operator>=</operator> <name><name>re</name><operator>-&gt;</operator><name>re_info</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>nsub</name></name> <operator>=</operator> <name><name>re</name><operator>-&gt;</operator><name>re_nsub</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>tree</name></name> <operator>=</operator> <name><name>v</name><operator>-&gt;</operator><name>tree</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>v</name><operator>-&gt;</operator><name>tree</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>ntree</name></name> <operator>=</operator> <name><name>v</name><operator>-&gt;</operator><name>ntree</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>compare</name></name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name><name>v</name><operator>-&gt;</operator><name>cflags</name></name> <operator>&amp;</operator> <name>REG_ICASE</name><operator>)</operator></expr> ?</condition><then> <expr><name>casecmp</name></expr> </then><else>: <expr><name>cmp</name></expr></else></ternary></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>lacons</name></name> <operator>=</operator> <name><name>v</name><operator>-&gt;</operator><name>lacons</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>v</name><operator>-&gt;</operator><name>lacons</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>nlacons</name></name> <operator>=</operator> <name><name>v</name><operator>-&gt;</operator><name>nlacons</name></name></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>REG_DEBUG</name></cpp:ifdef>
	<if_stmt><if>if <condition>(<expr><name>flags</name> <operator>&amp;</operator> <name>REG_DUMP</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>dump</name><argument_list>(<argument><expr><name>re</name></expr></argument>, <argument><expr><name>stdout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>v</name><operator>-&gt;</operator><name>err</name></name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><call><name>freev</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * moresubs - enlarge subRE vector
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>moresubs</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>vars</name></name> <modifier>*</modifier></type><name>v</name></decl></parameter>,
		 <parameter><decl><type><name>int</name></type> <name>wanted</name></decl></parameter>)</parameter_list>			<comment type="block">/* want enough room for this one */</comment>
<block>{<block_content>
	<decl_stmt><decl><type><name><name>struct</name> <name>subre</name></name> <modifier>*</modifier><modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>size_t</name></type>		<name>n</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>wanted</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>(</operator><name>size_t</name><operator>)</operator> <name>wanted</name> <operator>&gt;=</operator> <name><name>v</name><operator>-&gt;</operator><name>nsubs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>n</name> <operator>=</operator> <operator>(</operator><name>size_t</name><operator>)</operator> <name>wanted</name> <operator>*</operator> <literal type="number">3</literal> <operator>/</operator> <literal type="number">2</literal> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>v</name><operator>-&gt;</operator><name>subs</name></name> <operator>==</operator> <name><name>v</name><operator>-&gt;</operator><name>sub10</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>p</name> <operator>=</operator> <operator>(</operator>struct <name>subre</name> <operator>*</operator><operator>*</operator><operator>)</operator> <call><name>MALLOC</name><argument_list>(<argument><expr><name>n</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr>struct <name>subre</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>p</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><call><name>VS</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>VS</name><argument_list>(<argument><expr><name><name>v</name><operator>-&gt;</operator><name>subs</name></name></expr></argument>)</argument_list></call></expr></argument>,
				   <argument><expr><name><name>v</name><operator>-&gt;</operator><name>nsubs</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr>struct <name>subre</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>p</name> <operator>=</operator> <operator>(</operator>struct <name>subre</name> <operator>*</operator><operator>*</operator><operator>)</operator> <call><name>REALLOC</name><argument_list>(<argument><expr><name><name>v</name><operator>-&gt;</operator><name>subs</name></name></expr></argument>, <argument><expr><name>n</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr>struct <name>subre</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>p</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ERR</name><argument_list>(<argument><expr><name>REG_ESPACE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name><name>v</name><operator>-&gt;</operator><name>subs</name></name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>p</name> <operator>=</operator> <operator>&amp;</operator><name><name>v</name><operator>-&gt;</operator><name>subs</name><index>[<expr><name><name>v</name><operator>-&gt;</operator><name>nsubs</name></name></expr>]</index></name></expr>;</init> <condition><expr><name><name>v</name><operator>-&gt;</operator><name>nsubs</name></name> <operator>&lt;</operator> <name>n</name></expr>;</condition> <incr><expr><name>p</name><operator>++</operator></expr><operator>,</operator> <expr><name><name>v</name><operator>-&gt;</operator><name>nsubs</name></name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
		<expr_stmt><expr><operator>*</operator><name>p</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></for>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>v</name><operator>-&gt;</operator><name>nsubs</name></name> <operator>==</operator> <name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>(</operator><name>size_t</name><operator>)</operator> <name>wanted</name> <operator>&lt;</operator> <name><name>v</name><operator>-&gt;</operator><name>nsubs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * freev - free vars struct's substructures where necessary
 *
 * Optionally does error-number setting, and always returns error code
 * (if any), to make error-handling code terser.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>freev</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>vars</name></name> <modifier>*</modifier></type><name>v</name></decl></parameter>,
	  <parameter><decl><type><name>int</name></type> <name>err</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name><name>v</name><operator>-&gt;</operator><name>re</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>rfree</name><argument_list>(<argument><expr><name><name>v</name><operator>-&gt;</operator><name>re</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>v</name><operator>-&gt;</operator><name>subs</name></name> <operator>!=</operator> <name><name>v</name><operator>-&gt;</operator><name>sub10</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>FREE</name><argument_list>(<argument><expr><name><name>v</name><operator>-&gt;</operator><name>subs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>v</name><operator>-&gt;</operator><name>nfa</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>freenfa</name><argument_list>(<argument><expr><name><name>v</name><operator>-&gt;</operator><name>nfa</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>v</name><operator>-&gt;</operator><name>tree</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>freesubre</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name><name>v</name><operator>-&gt;</operator><name>tree</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>v</name><operator>-&gt;</operator><name>treechain</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>cleanst</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>v</name><operator>-&gt;</operator><name>cv</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>freecvec</name><argument_list>(<argument><expr><name><name>v</name><operator>-&gt;</operator><name>cv</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>v</name><operator>-&gt;</operator><name>cv2</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>freecvec</name><argument_list>(<argument><expr><name><name>v</name><operator>-&gt;</operator><name>cv2</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>v</name><operator>-&gt;</operator><name>lacons</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>freelacons</name><argument_list>(<argument><expr><name><name>v</name><operator>-&gt;</operator><name>lacons</name></name></expr></argument>, <argument><expr><name><name>v</name><operator>-&gt;</operator><name>nlacons</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><call><name>ERR</name><argument_list>(<argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>					<comment type="block">/* nop if err==0 */</comment>

	<return>return <expr><name><name>v</name><operator>-&gt;</operator><name>err</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * makesearch - turn an NFA into a search NFA (implicit prepend of .*?)
 * NFA must have been optimize()d already.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>makesearch</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>vars</name></name> <modifier>*</modifier></type><name>v</name></decl></parameter>,
		   <parameter><decl><type><name><name>struct</name> <name>nfa</name></name> <modifier>*</modifier></type><name>nfa</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name><name>struct</name> <name>arc</name></name> <modifier>*</modifier></type><name>a</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>arc</name></name> <modifier>*</modifier></type><name>b</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>state</name></name> <modifier>*</modifier></type><name>pre</name> <init>= <expr><name><name>nfa</name><operator>-&gt;</operator><name>pre</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>state</name></name> <modifier>*</modifier></type><name>s</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>state</name></name> <modifier>*</modifier></type><name>s2</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>state</name></name> <modifier>*</modifier></type><name>slist</name></decl>;</decl_stmt>

	<comment type="block">/* no loops are needed if it's anchored */</comment>
	<for>for <control>(<init><expr><name>a</name> <operator>=</operator> <name><name>pre</name><operator>-&gt;</operator><name>outs</name></name></expr>;</init> <condition><expr><name>a</name> <operator>!=</operator> <name>NULL</name></expr>;</condition> <incr><expr><name>a</name> <operator>=</operator> <name><name>a</name><operator>-&gt;</operator><name>outchain</name></name></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>a</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>PLAIN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>a</name><operator>-&gt;</operator><name>co</name></name> <operator>!=</operator> <name><name>nfa</name><operator>-&gt;</operator><name>bos</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&amp;&amp;</operator> <name><name>a</name><operator>-&gt;</operator><name>co</name></name> <operator>!=</operator> <name><name>nfa</name><operator>-&gt;</operator><name>bos</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>
	</block_content>}</block></for>
	<if_stmt><if>if <condition>(<expr><name>a</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* add implicit .* in front */</comment>
		<expr_stmt><expr><call><name>rainbow</name><argument_list>(<argument><expr><name>nfa</name></expr></argument>, <argument><expr><name><name>v</name><operator>-&gt;</operator><name>cm</name></name></expr></argument>, <argument><expr><name>PLAIN</name></expr></argument>, <argument><expr><name>COLORLESS</name></expr></argument>, <argument><expr><name>pre</name></expr></argument>, <argument><expr><name>pre</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* and ^* and \A* too -- not always necessary, but harmless */</comment>
		<expr_stmt><expr><call><name>newarc</name><argument_list>(<argument><expr><name>nfa</name></expr></argument>, <argument><expr><name>PLAIN</name></expr></argument>, <argument><expr><name><name>nfa</name><operator>-&gt;</operator><name>bos</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name>pre</name></expr></argument>, <argument><expr><name>pre</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>newarc</name><argument_list>(<argument><expr><name>nfa</name></expr></argument>, <argument><expr><name>PLAIN</name></expr></argument>, <argument><expr><name><name>nfa</name><operator>-&gt;</operator><name>bos</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name>pre</name></expr></argument>, <argument><expr><name>pre</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Now here's the subtle part.  Because many REs have no lookback
	 * constraints, often knowing when you were in the pre state tells you
	 * little; it's the next state(s) that are informative.  But some of them
	 * may have other inarcs, i.e. it may be possible to make actual progress
	 * and then return to one of them.  We must de-optimize such cases,
	 * splitting each such state into progress and no-progress states.
	 */</comment>

	<comment type="block">/* first, make a list of the states reachable from pre and elsewhere */</comment>
	<expr_stmt><expr><name>slist</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>a</name> <operator>=</operator> <name><name>pre</name><operator>-&gt;</operator><name>outs</name></name></expr>;</init> <condition><expr><name>a</name> <operator>!=</operator> <name>NULL</name></expr>;</condition> <incr><expr><name>a</name> <operator>=</operator> <name><name>a</name><operator>-&gt;</operator><name>outchain</name></name></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><name>s</name> <operator>=</operator> <name><name>a</name><operator>-&gt;</operator><name>to</name></name></expr>;</expr_stmt>
		<for>for <control>(<init><expr><name>b</name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>ins</name></name></expr>;</init> <condition><expr><name>b</name> <operator>!=</operator> <name>NULL</name></expr>;</condition> <incr><expr><name>b</name> <operator>=</operator> <name><name>b</name><operator>-&gt;</operator><name>inchain</name></name></expr></incr>)</control>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name><name>b</name><operator>-&gt;</operator><name>from</name></name> <operator>!=</operator> <name>pre</name></expr>)</condition><block type="pseudo"><block_content>
				<break>break;</break></block_content></block></if></if_stmt>
		</block_content>}</block></for>

		<comment type="block">/*
		 * We want to mark states as being in the list already by having non
		 * NULL tmp fields, but we can't just store the old slist value in tmp
		 * because that doesn't work for the first such state.  Instead, the
		 * first list entry gets its own address in tmp.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>b</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name><name>s</name><operator>-&gt;</operator><name>tmp</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>tmp</name></name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name>slist</name> <operator>!=</operator> <name>NULL</name><operator>)</operator></expr> ?</condition><then> <expr><name>slist</name></expr> </then><else>: <expr><name>s</name></expr></else></ternary></expr>;</expr_stmt>
			<expr_stmt><expr><name>slist</name> <operator>=</operator> <name>s</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>

	<comment type="block">/* do the splits */</comment>
	<for>for <control>(<init><expr><name>s</name> <operator>=</operator> <name>slist</name></expr>;</init> <condition><expr><name>s</name> <operator>!=</operator> <name>NULL</name></expr>;</condition> <incr><expr><name>s</name> <operator>=</operator> <name>s2</name></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><name>s2</name> <operator>=</operator> <call><name>newstate</name><argument_list>(<argument><expr><name>nfa</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>NOERR</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>copyouts</name><argument_list>(<argument><expr><name>nfa</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name>s2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>NOERR</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<for>for <control>(<init><expr><name>a</name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>ins</name></name></expr>;</init> <condition><expr><name>a</name> <operator>!=</operator> <name>NULL</name></expr>;</condition> <incr><expr><name>a</name> <operator>=</operator> <name>b</name></expr></incr>)</control>
		<block>{<block_content>
			<expr_stmt><expr><name>b</name> <operator>=</operator> <name><name>a</name><operator>-&gt;</operator><name>inchain</name></name></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>a</name><operator>-&gt;</operator><name>from</name></name> <operator>!=</operator> <name>pre</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>cparc</name><argument_list>(<argument><expr><name>nfa</name></expr></argument>, <argument><expr><name>a</name></expr></argument>, <argument><expr><name><name>a</name><operator>-&gt;</operator><name>from</name></name></expr></argument>, <argument><expr><name>s2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>freearc</name><argument_list>(<argument><expr><name>nfa</name></expr></argument>, <argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></for>
		<expr_stmt><expr><name>s2</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name><name>s</name><operator>-&gt;</operator><name>tmp</name></name> <operator>!=</operator> <name>s</name><operator>)</operator></expr> ?</condition><then> <expr><name><name>s</name><operator>-&gt;</operator><name>tmp</name></name></expr> </then><else>: <expr><name>NULL</name></expr></else></ternary></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>tmp</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>			<comment type="block">/* clean up while we're at it */</comment>
	</block_content>}</block></for>
</block_content>}</block></function>

<comment type="block">/*
 * parse - parse an RE
 *
 * This is actually just the top level, which parses a bunch of branches
 * tied together with '|'.  They appear in the tree as the left children
 * of a chain of '|' subres.
 */</comment>
<function><type><specifier>static</specifier> <name><name>struct</name> <name>subre</name></name> <modifier>*</modifier></type>
<name>parse</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>vars</name></name> <modifier>*</modifier></type><name>v</name></decl></parameter>,
	  <parameter><decl><type><name>int</name></type> <name>stopper</name></decl></parameter>,				<comment type="block">/* EOS or ')' */</comment>
	  <parameter><decl><type><name>int</name></type> <name>type</name></decl></parameter>,					<comment type="block">/* LACON (lookaround subRE) or PLAIN */</comment>
	  <parameter><decl><type><name><name>struct</name> <name>state</name></name> <modifier>*</modifier></type><name>init</name></decl></parameter>,		<comment type="block">/* initial state */</comment>
	  <parameter><decl><type><name><name>struct</name> <name>state</name></name> <modifier>*</modifier></type><name>final</name></decl></parameter>)</parameter_list>		<comment type="block">/* final state */</comment>
<block>{<block_content>
	<decl_stmt><decl><type><name><name>struct</name> <name>state</name></name> <modifier>*</modifier></type><name>left</name></decl>;</decl_stmt>			<comment type="block">/* scaffolding for branch */</comment>
	<decl_stmt><decl><type><name><name>struct</name> <name>state</name></name> <modifier>*</modifier></type><name>right</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>subre</name></name> <modifier>*</modifier></type><name>branches</name></decl>;</decl_stmt>		<comment type="block">/* top level */</comment>
	<decl_stmt><decl><type><name><name>struct</name> <name>subre</name></name> <modifier>*</modifier></type><name>branch</name></decl>;</decl_stmt>		<comment type="block">/* current branch */</comment>
	<decl_stmt><decl><type><name><name>struct</name> <name>subre</name></name> <modifier>*</modifier></type><name>t</name></decl>;</decl_stmt>			<comment type="block">/* temporary */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>firstbranch</name></decl>;</decl_stmt>	<comment type="block">/* is this the first branch? */</comment>

	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>stopper</name> <operator>==</operator> <literal type="char">')'</literal> <operator>||</operator> <name>stopper</name> <operator>==</operator> <name>EOS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>branches</name> <operator>=</operator> <call><name>subre</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><literal type="char">'|'</literal></expr></argument>, <argument><expr><name>LONGER</name></expr></argument>, <argument><expr><name>init</name></expr></argument>, <argument><expr><name>final</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>NOERRN</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>branch</name> <operator>=</operator> <name>branches</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>firstbranch</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	<do>do
	<block>{<block_content>							<comment type="block">/* a branch */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>firstbranch</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* need a place to hang it */</comment>
			<expr_stmt><expr><name><name>branch</name><operator>-&gt;</operator><name>right</name></name> <operator>=</operator> <call><name>subre</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><literal type="char">'|'</literal></expr></argument>, <argument><expr><name>LONGER</name></expr></argument>, <argument><expr><name>init</name></expr></argument>, <argument><expr><name>final</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>NOERRN</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>branch</name> <operator>=</operator> <name><name>branch</name><operator>-&gt;</operator><name>right</name></name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><name>firstbranch</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name>left</name> <operator>=</operator> <call><name>newstate</name><argument_list>(<argument><expr><name><name>v</name><operator>-&gt;</operator><name>nfa</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>right</name> <operator>=</operator> <call><name>newstate</name><argument_list>(<argument><expr><name><name>v</name><operator>-&gt;</operator><name>nfa</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>NOERRN</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>EMPTYARC</name><argument_list>(<argument><expr><name>init</name></expr></argument>, <argument><expr><name>left</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>EMPTYARC</name><argument_list>(<argument><expr><name>right</name></expr></argument>, <argument><expr><name>final</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>NOERRN</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>branch</name><operator>-&gt;</operator><name>left</name></name> <operator>=</operator> <call><name>parsebranch</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>stopper</name></expr></argument>, <argument><expr><name>type</name></expr></argument>, <argument><expr><name>left</name></expr></argument>, <argument><expr><name>right</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>NOERRN</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>branch</name><operator>-&gt;</operator><name>flags</name></name> <operator>|=</operator> <call><name>UP</name><argument_list>(<argument><expr><name><name>branch</name><operator>-&gt;</operator><name>flags</name></name> <operator>|</operator> <name><name>branch</name><operator>-&gt;</operator><name>left</name><operator>-&gt;</operator><name>flags</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>branch</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <operator>~</operator><name><name>branches</name><operator>-&gt;</operator><name>flags</name></name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>	<comment type="block">/* new flags */</comment>
			<for>for <control>(<init><expr><name>t</name> <operator>=</operator> <name>branches</name></expr>;</init> <condition><expr><name>t</name> <operator>!=</operator> <name>branch</name></expr>;</condition> <incr><expr><name>t</name> <operator>=</operator> <name><name>t</name><operator>-&gt;</operator><name>right</name></name></expr></incr>)</control><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>t</name><operator>-&gt;</operator><name>flags</name></name> <operator>|=</operator> <name><name>branch</name><operator>-&gt;</operator><name>flags</name></name></expr>;</expr_stmt></block_content></block></for></block_content></block></if></if_stmt>
	</block_content>}</block> while <condition>(<expr><call><name>EAT</name><argument_list>(<argument><expr><literal type="char">'|'</literal></expr></argument>)</argument_list></call></expr>)</condition>;</do>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>SEE</name><argument_list>(<argument><expr><name>stopper</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>SEE</name><argument_list>(<argument><expr><name>EOS</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>SEE</name><argument_list>(<argument><expr><name>stopper</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>stopper</name> <operator>==</operator> <literal type="char">')'</literal> <operator>&amp;&amp;</operator> <call><name>SEE</name><argument_list>(<argument><expr><name>EOS</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ERR</name><argument_list>(<argument><expr><name>REG_EPAREN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* optimize out simple cases */</comment>
	<if_stmt><if>if <condition>(<expr><name>branch</name> <operator>==</operator> <name>branches</name></expr>)</condition>
	<block>{<block_content>							<comment type="block">/* only one branch */</comment>
		<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>branch</name><operator>-&gt;</operator><name>right</name></name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>t</name> <operator>=</operator> <name><name>branch</name><operator>-&gt;</operator><name>left</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>branch</name><operator>-&gt;</operator><name>left</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>freesubre</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>branches</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>branches</name> <operator>=</operator> <name>t</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>MESSY</name><argument_list>(<argument><expr><name><name>branches</name><operator>-&gt;</operator><name>flags</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>							<comment type="block">/* no interesting innards */</comment>
		<expr_stmt><expr><call><name>freesubre</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name><name>branches</name><operator>-&gt;</operator><name>left</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>branches</name><operator>-&gt;</operator><name>left</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>freesubre</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name><name>branches</name><operator>-&gt;</operator><name>right</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>branches</name><operator>-&gt;</operator><name>right</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>branches</name><operator>-&gt;</operator><name>op</name></name> <operator>=</operator> <literal type="char">'='</literal></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>branches</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * parsebranch - parse one branch of an RE
 *
 * This mostly manages concatenation, working closely with parseqatom().
 * Concatenated things are bundled up as much as possible, with separate
 * ',' nodes introduced only when necessary due to substructure.
 */</comment>
<function><type><specifier>static</specifier> <name><name>struct</name> <name>subre</name></name> <modifier>*</modifier></type>
<name>parsebranch</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>vars</name></name> <modifier>*</modifier></type><name>v</name></decl></parameter>,
			<parameter><decl><type><name>int</name></type> <name>stopper</name></decl></parameter>,		<comment type="block">/* EOS or ')' */</comment>
			<parameter><decl><type><name>int</name></type> <name>type</name></decl></parameter>,			<comment type="block">/* LACON (lookaround subRE) or PLAIN */</comment>
			<parameter><decl><type><name><name>struct</name> <name>state</name></name> <modifier>*</modifier></type><name>left</name></decl></parameter>, <comment type="block">/* leftmost state */</comment>
			<parameter><decl><type><name><name>struct</name> <name>state</name></name> <modifier>*</modifier></type><name>right</name></decl></parameter>,	<comment type="block">/* rightmost state */</comment>
			<parameter><decl><type><name>int</name></type> <name>partial</name></decl></parameter>)</parameter_list>		<comment type="block">/* is this only part of a branch? */</comment>
<block>{<block_content>
	<decl_stmt><decl><type><name><name>struct</name> <name>state</name></name> <modifier>*</modifier></type><name>lp</name></decl>;</decl_stmt>			<comment type="block">/* left end of current construct */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>seencontent</name></decl>;</decl_stmt>	<comment type="block">/* is there anything in this branch yet? */</comment>
	<decl_stmt><decl><type><name><name>struct</name> <name>subre</name></name> <modifier>*</modifier></type><name>t</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>lp</name> <operator>=</operator> <name>left</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>seencontent</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>t</name> <operator>=</operator> <call><name>subre</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><literal type="char">'='</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>left</name></expr></argument>, <argument><expr><name>right</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>	<comment type="block">/* op '=' is tentative */</comment>
	<expr_stmt><expr><call><name>NOERRN</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<while>while <condition>(<expr><operator>!</operator><call><name>SEE</name><argument_list>(<argument><expr><literal type="char">'|'</literal></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>SEE</name><argument_list>(<argument><expr><name>stopper</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>SEE</name><argument_list>(<argument><expr><name>EOS</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>seencontent</name></expr>)</condition>
		<block>{<block_content>						<comment type="block">/* implicit concat operator */</comment>
			<expr_stmt><expr><name>lp</name> <operator>=</operator> <call><name>newstate</name><argument_list>(<argument><expr><name><name>v</name><operator>-&gt;</operator><name>nfa</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>NOERRN</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>moveins</name><argument_list>(<argument><expr><name><name>v</name><operator>-&gt;</operator><name>nfa</name></name></expr></argument>, <argument><expr><name>right</name></expr></argument>, <argument><expr><name>lp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><name>seencontent</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

		<comment type="block">/* NB, recursion in parseqatom() may swallow rest of branch */</comment>
		<expr_stmt><expr><call><name>parseqatom</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>stopper</name></expr></argument>, <argument><expr><name>type</name></expr></argument>, <argument><expr><name>lp</name></expr></argument>, <argument><expr><name>right</name></expr></argument>, <argument><expr><name>t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>NOERRN</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></while>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>seencontent</name></expr>)</condition>
	<block>{<block_content>							<comment type="block">/* empty branch */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>partial</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>NOTE</name><argument_list>(<argument><expr><name>REG_UUNSPEC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>lp</name> <operator>==</operator> <name>left</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>EMPTYARC</name><argument_list>(<argument><expr><name>left</name></expr></argument>, <argument><expr><name>right</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>t</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * parseqatom - parse one quantified atom or constraint of an RE
 *
 * The bookkeeping near the end cooperates very closely with parsebranch();
 * in particular, it contains a recursion that can involve parsing the rest
 * of the branch, making this function's name somewhat inaccurate.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>parseqatom</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>vars</name></name> <modifier>*</modifier></type><name>v</name></decl></parameter>,
		   <parameter><decl><type><name>int</name></type> <name>stopper</name></decl></parameter>,			<comment type="block">/* EOS or ')' */</comment>
		   <parameter><decl><type><name>int</name></type> <name>type</name></decl></parameter>,			<comment type="block">/* LACON (lookaround subRE) or PLAIN */</comment>
		   <parameter><decl><type><name><name>struct</name> <name>state</name></name> <modifier>*</modifier></type><name>lp</name></decl></parameter>,	<comment type="block">/* left state to hang it on */</comment>
		   <parameter><decl><type><name><name>struct</name> <name>state</name></name> <modifier>*</modifier></type><name>rp</name></decl></parameter>,	<comment type="block">/* right state to hang it on */</comment>
		   <parameter><decl><type><name><name>struct</name> <name>subre</name></name> <modifier>*</modifier></type><name>top</name></decl></parameter>)</parameter_list>	<comment type="block">/* subtree top */</comment>
<block>{<block_content>
	<decl_stmt><decl><type><name><name>struct</name> <name>state</name></name> <modifier>*</modifier></type><name>s</name></decl>;</decl_stmt>			<comment type="block">/* temporaries for new states */</comment>
	<decl_stmt><decl><type><name><name>struct</name> <name>state</name></name> <modifier>*</modifier></type><name>s2</name></decl>;</decl_stmt>

<cpp:define>#<cpp:directive>define</cpp:directive>  <cpp:macro><name>ARCV</name><parameter_list>(<parameter><type><name>t</name></type></parameter>, <parameter><type><name>val</name></type></parameter>)</parameter_list></cpp:macro>	 <cpp:value>newarc(v-&gt;nfa, t, val, lp, rp)</cpp:value></cpp:define>
	<decl_stmt><decl><type><name>int</name></type>			<name>m</name></decl>,
				<decl><type ref="prev"/><name>n</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>subre</name></name> <modifier>*</modifier></type><name>atom</name></decl>;</decl_stmt>			<comment type="block">/* atom's subtree */</comment>
	<decl_stmt><decl><type><name><name>struct</name> <name>subre</name></name> <modifier>*</modifier></type><name>t</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>cap</name></decl>;</decl_stmt>			<comment type="block">/* capturing parens? */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>latype</name></decl>;</decl_stmt>			<comment type="block">/* lookaround constraint type */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>subno</name></decl>;</decl_stmt>			<comment type="block">/* capturing-parens or backref number */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>atomtype</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>qprefer</name></decl>;</decl_stmt>		<comment type="block">/* quantifier short/long preference */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>f</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>subre</name></name> <modifier>*</modifier><modifier>*</modifier></type><name>atomp</name></decl>;</decl_stmt>		<comment type="block">/* where the pointer to atom is */</comment>

	<comment type="block">/* initial bookkeeping */</comment>
	<expr_stmt><expr><name>atom</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>lp</name><operator>-&gt;</operator><name>nouts</name></name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>		<comment type="block">/* must string new code */</comment>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>rp</name><operator>-&gt;</operator><name>nins</name></name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>		<comment type="block">/* between lp and rp */</comment>
	<expr_stmt><expr><name>subno</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>					<comment type="block">/* just to shut lint up */</comment>

	<comment type="block">/* an atom or constraint... */</comment>
	<expr_stmt><expr><name>atomtype</name> <operator>=</operator> <name><name>v</name><operator>-&gt;</operator><name>nexttype</name></name></expr>;</expr_stmt>
	<switch>switch <condition>(<expr><name>atomtype</name></expr>)</condition>
	<block>{<block_content>
			<comment type="block">/* first, constraints, which end by returning */</comment>
		<case>case <expr><literal type="char">'^'</literal></expr>:</case>
			<expr_stmt><expr><call><name>ARCV</name><argument_list>(<argument><expr><literal type="char">'^'</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>v</name><operator>-&gt;</operator><name>cflags</name></name> <operator>&amp;</operator> <name>REG_NLANCH</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ARCV</name><argument_list>(<argument><expr><name>BEHIND</name></expr></argument>, <argument><expr><name><name>v</name><operator>-&gt;</operator><name>nlcolor</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><call><name>NEXT</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<return>return;</return>
			<break>break;</break>
		<case>case <expr><literal type="char">'$'</literal></expr>:</case>
			<expr_stmt><expr><call><name>ARCV</name><argument_list>(<argument><expr><literal type="char">'$'</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>v</name><operator>-&gt;</operator><name>cflags</name></name> <operator>&amp;</operator> <name>REG_NLANCH</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ARCV</name><argument_list>(<argument><expr><name>AHEAD</name></expr></argument>, <argument><expr><name><name>v</name><operator>-&gt;</operator><name>nlcolor</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><call><name>NEXT</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<return>return;</return>
			<break>break;</break>
		<case>case <expr><name>SBEGIN</name></expr>:</case>
			<expr_stmt><expr><call><name>ARCV</name><argument_list>(<argument><expr><literal type="char">'^'</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>		<comment type="block">/* BOL */</comment>
			<expr_stmt><expr><call><name>ARCV</name><argument_list>(<argument><expr><literal type="char">'^'</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>		<comment type="block">/* or BOS */</comment>
			<expr_stmt><expr><call><name>NEXT</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<return>return;</return>
			<break>break;</break>
		<case>case <expr><name>SEND</name></expr>:</case>
			<expr_stmt><expr><call><name>ARCV</name><argument_list>(<argument><expr><literal type="char">'$'</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>		<comment type="block">/* EOL */</comment>
			<expr_stmt><expr><call><name>ARCV</name><argument_list>(<argument><expr><literal type="char">'$'</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>		<comment type="block">/* or EOS */</comment>
			<expr_stmt><expr><call><name>NEXT</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<return>return;</return>
			<break>break;</break>
		<case>case <expr><literal type="char">'&lt;'</literal></expr>:</case>
			<expr_stmt><expr><call><name>wordchrs</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>		<comment type="block">/* does NEXT() */</comment>
			<expr_stmt><expr><name>s</name> <operator>=</operator> <call><name>newstate</name><argument_list>(<argument><expr><name><name>v</name><operator>-&gt;</operator><name>nfa</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>NOERR</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>nonword</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>BEHIND</name></expr></argument>, <argument><expr><name>lp</name></expr></argument>, <argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>word</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>AHEAD</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name>rp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return;</return>
			<break>break;</break>
		<case>case <expr><literal type="char">'&gt;'</literal></expr>:</case>
			<expr_stmt><expr><call><name>wordchrs</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>		<comment type="block">/* does NEXT() */</comment>
			<expr_stmt><expr><name>s</name> <operator>=</operator> <call><name>newstate</name><argument_list>(<argument><expr><name><name>v</name><operator>-&gt;</operator><name>nfa</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>NOERR</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>word</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>BEHIND</name></expr></argument>, <argument><expr><name>lp</name></expr></argument>, <argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>nonword</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>AHEAD</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name>rp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return;</return>
			<break>break;</break>
		<case>case <expr><name>WBDRY</name></expr>:</case>
			<expr_stmt><expr><call><name>wordchrs</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>		<comment type="block">/* does NEXT() */</comment>
			<expr_stmt><expr><name>s</name> <operator>=</operator> <call><name>newstate</name><argument_list>(<argument><expr><name><name>v</name><operator>-&gt;</operator><name>nfa</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>NOERR</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>nonword</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>BEHIND</name></expr></argument>, <argument><expr><name>lp</name></expr></argument>, <argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>word</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>AHEAD</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name>rp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>s</name> <operator>=</operator> <call><name>newstate</name><argument_list>(<argument><expr><name><name>v</name><operator>-&gt;</operator><name>nfa</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>NOERR</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>word</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>BEHIND</name></expr></argument>, <argument><expr><name>lp</name></expr></argument>, <argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>nonword</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>AHEAD</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name>rp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return;</return>
			<break>break;</break>
		<case>case <expr><name>NWBDRY</name></expr>:</case>
			<expr_stmt><expr><call><name>wordchrs</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>		<comment type="block">/* does NEXT() */</comment>
			<expr_stmt><expr><name>s</name> <operator>=</operator> <call><name>newstate</name><argument_list>(<argument><expr><name><name>v</name><operator>-&gt;</operator><name>nfa</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>NOERR</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>word</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>BEHIND</name></expr></argument>, <argument><expr><name>lp</name></expr></argument>, <argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>word</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>AHEAD</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name>rp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>s</name> <operator>=</operator> <call><name>newstate</name><argument_list>(<argument><expr><name><name>v</name><operator>-&gt;</operator><name>nfa</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>NOERR</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>nonword</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>BEHIND</name></expr></argument>, <argument><expr><name>lp</name></expr></argument>, <argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>nonword</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>AHEAD</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name>rp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return;</return>
			<break>break;</break>
		<case>case <expr><name>LACON</name></expr>:</case>				<comment type="block">/* lookaround constraint */</comment>
			<expr_stmt><expr><name>latype</name> <operator>=</operator> <name><name>v</name><operator>-&gt;</operator><name>nextvalue</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>NEXT</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>s</name> <operator>=</operator> <call><name>newstate</name><argument_list>(<argument><expr><name><name>v</name><operator>-&gt;</operator><name>nfa</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>s2</name> <operator>=</operator> <call><name>newstate</name><argument_list>(<argument><expr><name><name>v</name><operator>-&gt;</operator><name>nfa</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>NOERR</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>t</name> <operator>=</operator> <call><name>parse</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><literal type="char">')'</literal></expr></argument>, <argument><expr><name>LACON</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name>s2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>freesubre</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>	<comment type="block">/* internal structure irrelevant */</comment>
			<expr_stmt><expr><call><name>NOERR</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>SEE</name><argument_list>(<argument><expr><literal type="char">')'</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>NEXT</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>processlacon</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name>s2</name></expr></argument>, <argument><expr><name>latype</name></expr></argument>, <argument><expr><name>lp</name></expr></argument>, <argument><expr><name>rp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return;</return>
			<break>break;</break>
			<comment type="block">/* then errors, to get them out of the way */</comment>
		<case>case <expr><literal type="char">'*'</literal></expr>:</case>
		<case>case <expr><literal type="char">'+'</literal></expr>:</case>
		<case>case <expr><literal type="char">'?'</literal></expr>:</case>
		<case>case <expr><literal type="char">'{'</literal></expr>:</case>
			<expr_stmt><expr><call><name>ERR</name><argument_list>(<argument><expr><name>REG_BADRPT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return;</return>
			<break>break;</break>
		<default>default:</default>
			<expr_stmt><expr><call><name>ERR</name><argument_list>(<argument><expr><name>REG_ASSERT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return;</return>
			<break>break;</break>
			<comment type="block">/* then plain characters, and minor variants on that theme */</comment>
		<case>case <expr><literal type="char">')'</literal></expr>:</case>				<comment type="block">/* unbalanced paren */</comment>
			<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>v</name><operator>-&gt;</operator><name>cflags</name></name> <operator>&amp;</operator> <name>REG_ADVANCED</name><operator>)</operator> <operator>!=</operator> <name>REG_EXTENDED</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>ERR</name><argument_list>(<argument><expr><name>REG_EPAREN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return;</return>
			</block_content>}</block></if></if_stmt>
			<comment type="block">/* legal in EREs due to specification botch */</comment>
			<expr_stmt><expr><call><name>NOTE</name><argument_list>(<argument><expr><name>REG_UPBOTCH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* fall through into case PLAIN */</comment>
			<comment type="block">/* FALLTHROUGH */</comment>
		<case>case <expr><name>PLAIN</name></expr>:</case>
			<expr_stmt><expr><call><name>onechr</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name><name>v</name><operator>-&gt;</operator><name>nextvalue</name></name></expr></argument>, <argument><expr><name>lp</name></expr></argument>, <argument><expr><name>rp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>okcolors</name><argument_list>(<argument><expr><name><name>v</name><operator>-&gt;</operator><name>nfa</name></name></expr></argument>, <argument><expr><name><name>v</name><operator>-&gt;</operator><name>cm</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>NOERR</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>NEXT</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><literal type="char">'['</literal></expr>:</case>
			<if_stmt><if>if <condition>(<expr><name><name>v</name><operator>-&gt;</operator><name>nextvalue</name></name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>bracket</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>lp</name></expr></argument>, <argument><expr><name>rp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>cbracket</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>lp</name></expr></argument>, <argument><expr><name>rp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
			<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>SEE</name><argument_list>(<argument><expr><literal type="char">']'</literal></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>ISERR</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>NEXT</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><literal type="char">'.'</literal></expr>:</case>
			<expr_stmt><expr><call><name>rainbow</name><argument_list>(<argument><expr><name><name>v</name><operator>-&gt;</operator><name>nfa</name></name></expr></argument>, <argument><expr><name><name>v</name><operator>-&gt;</operator><name>cm</name></name></expr></argument>, <argument><expr><name>PLAIN</name></expr></argument>,
					<argument><expr><ternary><condition><expr><operator>(</operator><name><name>v</name><operator>-&gt;</operator><name>cflags</name></name> <operator>&amp;</operator> <name>REG_NLSTOP</name><operator>)</operator></expr> ?</condition><then> <expr><name><name>v</name><operator>-&gt;</operator><name>nlcolor</name></name></expr> </then><else>: <expr><name>COLORLESS</name></expr></else></ternary></expr></argument>,
					<argument><expr><name>lp</name></expr></argument>, <argument><expr><name>rp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>NEXT</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
			<comment type="block">/* and finally the ugly stuff */</comment>
		<case>case <expr><literal type="char">'('</literal></expr>:</case>				<comment type="block">/* value flags as capturing or non */</comment>
			<expr_stmt><expr><name>cap</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name>type</name> <operator>==</operator> <name>LACON</name><operator>)</operator></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><name><name>v</name><operator>-&gt;</operator><name>nextvalue</name></name></expr></else></ternary></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>cap</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name><name>v</name><operator>-&gt;</operator><name>nsubexp</name></name><operator>++</operator></expr>;</expr_stmt>
				<expr_stmt><expr><name>subno</name> <operator>=</operator> <name><name>v</name><operator>-&gt;</operator><name>nsubexp</name></name></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><operator>(</operator><name>size_t</name><operator>)</operator> <name>subno</name> <operator>&gt;=</operator> <name><name>v</name><operator>-&gt;</operator><name>nsubs</name></name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>moresubs</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>subno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>(</operator><name>size_t</name><operator>)</operator> <name>subno</name> <operator>&lt;</operator> <name><name>v</name><operator>-&gt;</operator><name>nsubs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name>atomtype</name> <operator>=</operator> <name>PLAIN</name></expr>;</expr_stmt></block_content></block></else></if_stmt>	<comment type="block">/* something that's not '(' */</comment>
			<expr_stmt><expr><call><name>NEXT</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* need new endpoints because tree will contain pointers */</comment>
			<expr_stmt><expr><name>s</name> <operator>=</operator> <call><name>newstate</name><argument_list>(<argument><expr><name><name>v</name><operator>-&gt;</operator><name>nfa</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>s2</name> <operator>=</operator> <call><name>newstate</name><argument_list>(<argument><expr><name><name>v</name><operator>-&gt;</operator><name>nfa</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>NOERR</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>EMPTYARC</name><argument_list>(<argument><expr><name>lp</name></expr></argument>, <argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>EMPTYARC</name><argument_list>(<argument><expr><name>s2</name></expr></argument>, <argument><expr><name>rp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>NOERR</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>atom</name> <operator>=</operator> <call><name>parse</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><literal type="char">')'</literal></expr></argument>, <argument><expr><name>type</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name>s2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>SEE</name><argument_list>(<argument><expr><literal type="char">')'</literal></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>ISERR</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>NEXT</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>NOERR</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>cap</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name><name>v</name><operator>-&gt;</operator><name>subs</name><index>[<expr><name>subno</name></expr>]</index></name> <operator>=</operator> <name>atom</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>t</name> <operator>=</operator> <call><name>subre</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><literal type="char">'('</literal></expr></argument>, <argument><expr><name><name>atom</name><operator>-&gt;</operator><name>flags</name></name> <operator>|</operator> <name>CAP</name></expr></argument>, <argument><expr><name>lp</name></expr></argument>, <argument><expr><name>rp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>NOERR</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>t</name><operator>-&gt;</operator><name>subno</name></name> <operator>=</operator> <name>subno</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>t</name><operator>-&gt;</operator><name>left</name></name> <operator>=</operator> <name>atom</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>atom</name> <operator>=</operator> <name>t</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			<comment type="block">/* postpone everything else pending possible {0} */</comment>
			<break>break;</break>
		<case>case <expr><name>BACKREF</name></expr>:</case>			<comment type="block">/* the Feature From The Black Lagoon */</comment>
			<expr_stmt><expr><call><name>INSIST</name><argument_list>(<argument><expr><name>type</name> <operator>!=</operator> <name>LACON</name></expr></argument>, <argument><expr><name>REG_ESUBREG</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>INSIST</name><argument_list>(<argument><expr><name><name>v</name><operator>-&gt;</operator><name>nextvalue</name></name> <operator>&lt;</operator> <name><name>v</name><operator>-&gt;</operator><name>nsubs</name></name></expr></argument>, <argument><expr><name>REG_ESUBREG</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>INSIST</name><argument_list>(<argument><expr><name><name>v</name><operator>-&gt;</operator><name>subs</name><index>[<expr><name><name>v</name><operator>-&gt;</operator><name>nextvalue</name></name></expr>]</index></name> <operator>!=</operator> <name>NULL</name></expr></argument>, <argument><expr><name>REG_ESUBREG</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>NOERR</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>v</name><operator>-&gt;</operator><name>nextvalue</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>atom</name> <operator>=</operator> <call><name>subre</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><literal type="char">'b'</literal></expr></argument>, <argument><expr><name>BACKR</name></expr></argument>, <argument><expr><name>lp</name></expr></argument>, <argument><expr><name>rp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>NOERR</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>subno</name> <operator>=</operator> <name><name>v</name><operator>-&gt;</operator><name>nextvalue</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>atom</name><operator>-&gt;</operator><name>subno</name></name> <operator>=</operator> <name>subno</name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>EMPTYARC</name><argument_list>(<argument><expr><name>lp</name></expr></argument>, <argument><expr><name>rp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>	<comment type="block">/* temporarily, so there's something */</comment>
			<expr_stmt><expr><call><name>NEXT</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
	</block_content>}</block></switch>

	<comment type="block">/* ...and an atom may be followed by a quantifier */</comment>
	<switch>switch <condition>(<expr><name><name>v</name><operator>-&gt;</operator><name>nexttype</name></name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><literal type="char">'*'</literal></expr>:</case>
			<expr_stmt><expr><name>m</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name>n</name> <operator>=</operator> <name>DUPINF</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>qprefer</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name><name>v</name><operator>-&gt;</operator><name>nextvalue</name></name><operator>)</operator></expr> ?</condition><then> <expr><name>LONGER</name></expr> </then><else>: <expr><name>SHORTER</name></expr></else></ternary></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>NEXT</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><literal type="char">'+'</literal></expr>:</case>
			<expr_stmt><expr><name>m</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name>n</name> <operator>=</operator> <name>DUPINF</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>qprefer</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name><name>v</name><operator>-&gt;</operator><name>nextvalue</name></name><operator>)</operator></expr> ?</condition><then> <expr><name>LONGER</name></expr> </then><else>: <expr><name>SHORTER</name></expr></else></ternary></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>NEXT</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><literal type="char">'?'</literal></expr>:</case>
			<expr_stmt><expr><name>m</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name>n</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name>qprefer</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name><name>v</name><operator>-&gt;</operator><name>nextvalue</name></name><operator>)</operator></expr> ?</condition><then> <expr><name>LONGER</name></expr> </then><else>: <expr><name>SHORTER</name></expr></else></ternary></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>NEXT</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><literal type="char">'{'</literal></expr>:</case>
			<expr_stmt><expr><call><name>NEXT</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>m</name> <operator>=</operator> <call><name>scannum</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><call><name>EAT</name><argument_list>(<argument><expr><literal type="char">','</literal></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><call><name>SEE</name><argument_list>(<argument><expr><name>DIGIT</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>scannum</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><name>n</name> <operator>=</operator> <name>DUPINF</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
				<if_stmt><if>if <condition>(<expr><name>m</name> <operator>&gt;</operator> <name>n</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>ERR</name><argument_list>(<argument><expr><name>REG_BADBR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<return>return;</return>
				</block_content>}</block></if></if_stmt>
				<comment type="block">/* {m,n} exercises preference, even if it's {m,m} */</comment>
				<expr_stmt><expr><name>qprefer</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name><name>v</name><operator>-&gt;</operator><name>nextvalue</name></name><operator>)</operator></expr> ?</condition><then> <expr><name>LONGER</name></expr> </then><else>: <expr><name>SHORTER</name></expr></else></ternary></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<expr_stmt><expr><name>n</name> <operator>=</operator> <name>m</name></expr>;</expr_stmt>
				<comment type="block">/* {m} passes operand's preference through */</comment>
				<expr_stmt><expr><name>qprefer</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>SEE</name><argument_list>(<argument><expr><literal type="char">'}'</literal></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>					<comment type="block">/* catches errors too */</comment>
				<expr_stmt><expr><call><name>ERR</name><argument_list>(<argument><expr><name>REG_BADBR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return;</return>
			</block_content>}</block></if></if_stmt>
			<expr_stmt><expr><call><name>NEXT</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<default>default:</default>				<comment type="block">/* no quantifier */</comment>
			<expr_stmt><expr><name>m</name> <operator>=</operator> <name>n</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name>qprefer</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			<break>break;</break>
	</block_content>}</block></switch>

	<comment type="block">/* annoying special case:  {0} or {0,0} cancels everything */</comment>
	<if_stmt><if>if <condition>(<expr><name>m</name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>n</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>atom</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>freesubre</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>atom</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name>atomtype</name> <operator>==</operator> <literal type="char">'('</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>v</name><operator>-&gt;</operator><name>subs</name><index>[<expr><name>subno</name></expr>]</index></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>delsub</name><argument_list>(<argument><expr><name><name>v</name><operator>-&gt;</operator><name>nfa</name></name></expr></argument>, <argument><expr><name>lp</name></expr></argument>, <argument><expr><name>rp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>EMPTYARC</name><argument_list>(<argument><expr><name>lp</name></expr></argument>, <argument><expr><name>rp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* if not a messy case, avoid hard part */</comment>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>MESSY</name><argument_list>(<argument><expr><name><name>top</name><operator>-&gt;</operator><name>flags</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>f</name> <operator>=</operator> <name><name>top</name><operator>-&gt;</operator><name>flags</name></name> <operator>|</operator> <name>qprefer</name> <operator>|</operator> <operator>(</operator><ternary><condition><expr><operator>(</operator><name>atom</name> <operator>!=</operator> <name>NULL</name><operator>)</operator></expr> ?</condition><then> <expr><name><name>atom</name><operator>-&gt;</operator><name>flags</name></name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>atomtype</name> <operator>!=</operator> <literal type="char">'('</literal> <operator>&amp;&amp;</operator> <name>atomtype</name> <operator>!=</operator> <name>BACKREF</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>MESSY</name><argument_list>(<argument><expr><call><name>UP</name><argument_list>(<argument><expr><name>f</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>m</name> <operator>==</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <name>n</name> <operator>==</operator> <literal type="number">1</literal><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>repeat</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>lp</name></expr></argument>, <argument><expr><name>rp</name></expr></argument>, <argument><expr><name>m</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name>atom</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>freesubre</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>atom</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name><name>top</name><operator>-&gt;</operator><name>flags</name></name> <operator>=</operator> <name>f</name></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * hard part:  something messy
	 *
	 * That is, capturing parens, back reference, short/long clash, or an atom
	 * with substructure containing one of those.
	 */</comment>

	<comment type="block">/* now we'll need a subre for the contents even if they're boring */</comment>
	<if_stmt><if>if <condition>(<expr><name>atom</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>atom</name> <operator>=</operator> <call><name>subre</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><literal type="char">'='</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>lp</name></expr></argument>, <argument><expr><name>rp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>NOERR</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*----------
	 * Prepare a general-purpose state skeleton.
	 *
	 * In the no-backrefs case, we want this:
	 *
	 * [lp] ---&gt; [s] ---prefix---&gt; [begin] ---atom---&gt; [end] ---rest---&gt; [rp]
	 *
	 * where prefix is some repetitions of atom.  In the general case we need
	 *
	 * [lp] ---&gt; [s] ---iterator---&gt; [s2] ---rest---&gt; [rp]
	 *
	 * where the iterator wraps around [begin] ---atom---&gt; [end]
	 *
	 * We make the s state here for both cases; s2 is made below if needed
	 *----------
	 */</comment>
	<expr_stmt><expr><name>s</name> <operator>=</operator> <call><name>newstate</name><argument_list>(<argument><expr><name><name>v</name><operator>-&gt;</operator><name>nfa</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>		<comment type="block">/* first, new endpoints for the atom */</comment>
	<expr_stmt><expr><name>s2</name> <operator>=</operator> <call><name>newstate</name><argument_list>(<argument><expr><name><name>v</name><operator>-&gt;</operator><name>nfa</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>NOERR</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>moveouts</name><argument_list>(<argument><expr><name><name>v</name><operator>-&gt;</operator><name>nfa</name></name></expr></argument>, <argument><expr><name>lp</name></expr></argument>, <argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>moveins</name><argument_list>(<argument><expr><name><name>v</name><operator>-&gt;</operator><name>nfa</name></name></expr></argument>, <argument><expr><name>rp</name></expr></argument>, <argument><expr><name>s2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>NOERR</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>atom</name><operator>-&gt;</operator><name>begin</name></name> <operator>=</operator> <name>s</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>atom</name><operator>-&gt;</operator><name>end</name></name> <operator>=</operator> <name>s2</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>s</name> <operator>=</operator> <call><name>newstate</name><argument_list>(<argument><expr><name><name>v</name><operator>-&gt;</operator><name>nfa</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>		<comment type="block">/* set up starting state */</comment>
	<expr_stmt><expr><call><name>NOERR</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>EMPTYARC</name><argument_list>(<argument><expr><name>lp</name></expr></argument>, <argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>NOERR</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* break remaining subRE into x{...} and what follows */</comment>
	<expr_stmt><expr><name>t</name> <operator>=</operator> <call><name>subre</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><literal type="char">'.'</literal></expr></argument>, <argument><expr><call><name>COMBINE</name><argument_list>(<argument><expr><name>qprefer</name></expr></argument>, <argument><expr><name><name>atom</name><operator>-&gt;</operator><name>flags</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>lp</name></expr></argument>, <argument><expr><name>rp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>NOERR</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>t</name><operator>-&gt;</operator><name>left</name></name> <operator>=</operator> <name>atom</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>atomp</name> <operator>=</operator> <operator>&amp;</operator><name><name>t</name><operator>-&gt;</operator><name>left</name></name></expr>;</expr_stmt>

	<comment type="block">/* here we should recurse... but we must postpone that to the end */</comment>

	<comment type="block">/* split top into prefix and remaining */</comment>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>top</name><operator>-&gt;</operator><name>op</name></name> <operator>==</operator> <literal type="char">'='</literal> <operator>&amp;&amp;</operator> <name><name>top</name><operator>-&gt;</operator><name>left</name></name> <operator>==</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name><name>top</name><operator>-&gt;</operator><name>right</name></name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>top</name><operator>-&gt;</operator><name>left</name></name> <operator>=</operator> <call><name>subre</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><literal type="char">'='</literal></expr></argument>, <argument><expr><name><name>top</name><operator>-&gt;</operator><name>flags</name></name></expr></argument>, <argument><expr><name><name>top</name><operator>-&gt;</operator><name>begin</name></name></expr></argument>, <argument><expr><name>lp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>NOERR</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>top</name><operator>-&gt;</operator><name>op</name></name> <operator>=</operator> <literal type="char">'.'</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>top</name><operator>-&gt;</operator><name>right</name></name> <operator>=</operator> <name>t</name></expr>;</expr_stmt>

	<comment type="block">/* if it's a backref, now is the time to replicate the subNFA */</comment>
	<if_stmt><if>if <condition>(<expr><name>atomtype</name> <operator>==</operator> <name>BACKREF</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>atom</name><operator>-&gt;</operator><name>begin</name><operator>-&gt;</operator><name>nouts</name></name> <operator>==</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>	<comment type="block">/* just the EMPTY */</comment>
		<expr_stmt><expr><call><name>delsub</name><argument_list>(<argument><expr><name><name>v</name><operator>-&gt;</operator><name>nfa</name></name></expr></argument>, <argument><expr><name><name>atom</name><operator>-&gt;</operator><name>begin</name></name></expr></argument>, <argument><expr><name><name>atom</name><operator>-&gt;</operator><name>end</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>v</name><operator>-&gt;</operator><name>subs</name><index>[<expr><name>subno</name></expr>]</index></name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * And here's why the recursion got postponed: it must wait until the
		 * skeleton is filled in, because it may hit a backref that wants to
		 * copy the filled-in skeleton.
		 */</comment>
		<expr_stmt><expr><call><name>dupnfa</name><argument_list>(<argument><expr><name><name>v</name><operator>-&gt;</operator><name>nfa</name></name></expr></argument>, <argument><expr><name><name>v</name><operator>-&gt;</operator><name>subs</name><index>[<expr><name>subno</name></expr>]</index></name><operator>-&gt;</operator><name>begin</name></expr></argument>, <argument><expr><name><name>v</name><operator>-&gt;</operator><name>subs</name><index>[<expr><name>subno</name></expr>]</index></name><operator>-&gt;</operator><name>end</name></expr></argument>,
			   <argument><expr><name><name>atom</name><operator>-&gt;</operator><name>begin</name></name></expr></argument>, <argument><expr><name><name>atom</name><operator>-&gt;</operator><name>end</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>NOERR</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * It's quantifier time.  If the atom is just a backref, we'll let it deal
	 * with quantifiers internally.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>atomtype</name> <operator>==</operator> <name>BACKREF</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* special case:  backrefs have internal quantifiers */</comment>
		<expr_stmt><expr><call><name>EMPTYARC</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name><name>atom</name><operator>-&gt;</operator><name>begin</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>	<comment type="block">/* empty prefix */</comment>
		<comment type="block">/* just stuff everything into atom */</comment>
		<expr_stmt><expr><call><name>repeat</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name><name>atom</name><operator>-&gt;</operator><name>begin</name></name></expr></argument>, <argument><expr><name><name>atom</name><operator>-&gt;</operator><name>end</name></name></expr></argument>, <argument><expr><name>m</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>atom</name><operator>-&gt;</operator><name>min</name></name> <operator>=</operator> <operator>(</operator><name>short</name><operator>)</operator> <name>m</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>atom</name><operator>-&gt;</operator><name>max</name></name> <operator>=</operator> <operator>(</operator><name>short</name><operator>)</operator> <name>n</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>atom</name><operator>-&gt;</operator><name>flags</name></name> <operator>|=</operator> <call><name>COMBINE</name><argument_list>(<argument><expr><name>qprefer</name></expr></argument>, <argument><expr><name><name>atom</name><operator>-&gt;</operator><name>flags</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* rest of branch can be strung starting from atom-&gt;end */</comment>
		<expr_stmt><expr><name>s2</name> <operator>=</operator> <name><name>atom</name><operator>-&gt;</operator><name>end</name></name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>m</name> <operator>==</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <name>n</name> <operator>==</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator>
			 <operator>(</operator><name>qprefer</name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
			  <operator>(</operator><name><name>atom</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <operator>(</operator><name>LONGER</name> <operator>|</operator> <name>SHORTER</name> <operator>|</operator> <name>MIXED</name><operator>)</operator><operator>)</operator> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
			  <name>qprefer</name> <operator>==</operator> <operator>(</operator><name><name>atom</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <operator>(</operator><name>LONGER</name> <operator>|</operator> <name>SHORTER</name> <operator>|</operator> <name>MIXED</name><operator>)</operator><operator>)</operator><operator>)</operator></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* no/vacuous quantifier:  done */</comment>
		<expr_stmt><expr><call><name>EMPTYARC</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name><name>atom</name><operator>-&gt;</operator><name>begin</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>	<comment type="block">/* empty prefix */</comment>
		<comment type="block">/* rest of branch can be strung starting from atom-&gt;end */</comment>
		<expr_stmt><expr><name>s2</name> <operator>=</operator> <name><name>atom</name><operator>-&gt;</operator><name>end</name></name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>m</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>!</operator><operator>(</operator><name><name>atom</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>BACKR</name><operator>)</operator></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * If there's no backrefs involved, we can turn x{m,n} into
		 * x{m-1,n-1}x, with capturing parens in only the second x.  This is
		 * valid because we only care about capturing matches from the final
		 * iteration of the quantifier.  It's a win because we can implement
		 * the backref-free left side as a plain DFA node, since we don't
		 * really care where its submatches are.
		 */</comment>
		<expr_stmt><expr><call><name>dupnfa</name><argument_list>(<argument><expr><name><name>v</name><operator>-&gt;</operator><name>nfa</name></name></expr></argument>, <argument><expr><name><name>atom</name><operator>-&gt;</operator><name>begin</name></name></expr></argument>, <argument><expr><name><name>atom</name><operator>-&gt;</operator><name>end</name></name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name><name>atom</name><operator>-&gt;</operator><name>begin</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>m</name> <operator>&gt;=</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <name>m</name> <operator>!=</operator> <name>DUPINF</name> <operator>&amp;&amp;</operator> <name>n</name> <operator>&gt;=</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>repeat</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name><name>atom</name><operator>-&gt;</operator><name>begin</name></name></expr></argument>, <argument><expr><name>m</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><ternary><condition><expr><operator>(</operator><name>n</name> <operator>==</operator> <name>DUPINF</name><operator>)</operator></expr> ?</condition><then> <expr><name>n</name></expr> </then><else>: <expr><name>n</name> <operator>-</operator> <literal type="number">1</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>f</name> <operator>=</operator> <call><name>COMBINE</name><argument_list>(<argument><expr><name>qprefer</name></expr></argument>, <argument><expr><name><name>atom</name><operator>-&gt;</operator><name>flags</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>t</name> <operator>=</operator> <call><name>subre</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><literal type="char">'.'</literal></expr></argument>, <argument><expr><name>f</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name><name>atom</name><operator>-&gt;</operator><name>end</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* prefix and atom */</comment>
		<expr_stmt><expr><call><name>NOERR</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>t</name><operator>-&gt;</operator><name>left</name></name> <operator>=</operator> <call><name>subre</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><literal type="char">'='</literal></expr></argument>, <argument><expr><call><name>PREF</name><argument_list>(<argument><expr><name>f</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name><name>atom</name><operator>-&gt;</operator><name>begin</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>NOERR</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>t</name><operator>-&gt;</operator><name>right</name></name> <operator>=</operator> <name>atom</name></expr>;</expr_stmt>
		<expr_stmt><expr><operator>*</operator><name>atomp</name> <operator>=</operator> <name>t</name></expr>;</expr_stmt>
		<comment type="block">/* rest of branch can be strung starting from atom-&gt;end */</comment>
		<expr_stmt><expr><name>s2</name> <operator>=</operator> <name><name>atom</name><operator>-&gt;</operator><name>end</name></name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* general case: need an iteration node */</comment>
		<expr_stmt><expr><name>s2</name> <operator>=</operator> <call><name>newstate</name><argument_list>(<argument><expr><name><name>v</name><operator>-&gt;</operator><name>nfa</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>NOERR</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>moveouts</name><argument_list>(<argument><expr><name><name>v</name><operator>-&gt;</operator><name>nfa</name></name></expr></argument>, <argument><expr><name><name>atom</name><operator>-&gt;</operator><name>end</name></name></expr></argument>, <argument><expr><name>s2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>NOERR</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>dupnfa</name><argument_list>(<argument><expr><name><name>v</name><operator>-&gt;</operator><name>nfa</name></name></expr></argument>, <argument><expr><name><name>atom</name><operator>-&gt;</operator><name>begin</name></name></expr></argument>, <argument><expr><name><name>atom</name><operator>-&gt;</operator><name>end</name></name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name>s2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>repeat</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name>s2</name></expr></argument>, <argument><expr><name>m</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>f</name> <operator>=</operator> <call><name>COMBINE</name><argument_list>(<argument><expr><name>qprefer</name></expr></argument>, <argument><expr><name><name>atom</name><operator>-&gt;</operator><name>flags</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>t</name> <operator>=</operator> <call><name>subre</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><literal type="char">'*'</literal></expr></argument>, <argument><expr><name>f</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name>s2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>NOERR</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>t</name><operator>-&gt;</operator><name>min</name></name> <operator>=</operator> <operator>(</operator><name>short</name><operator>)</operator> <name>m</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>t</name><operator>-&gt;</operator><name>max</name></name> <operator>=</operator> <operator>(</operator><name>short</name><operator>)</operator> <name>n</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>t</name><operator>-&gt;</operator><name>left</name></name> <operator>=</operator> <name>atom</name></expr>;</expr_stmt>
		<expr_stmt><expr><operator>*</operator><name>atomp</name> <operator>=</operator> <name>t</name></expr>;</expr_stmt>
		<comment type="block">/* rest of branch is to be strung from iteration's end state */</comment>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/* and finally, look after that postponed recursion */</comment>
	<expr_stmt><expr><name>t</name> <operator>=</operator> <name><name>top</name><operator>-&gt;</operator><name>right</name></name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><call><name>SEE</name><argument_list>(<argument><expr><literal type="char">'|'</literal></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>SEE</name><argument_list>(<argument><expr><name>stopper</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>SEE</name><argument_list>(<argument><expr><name>EOS</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>t</name><operator>-&gt;</operator><name>right</name></name> <operator>=</operator> <call><name>parsebranch</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>stopper</name></expr></argument>, <argument><expr><name>type</name></expr></argument>, <argument><expr><name>s2</name></expr></argument>, <argument><expr><name>rp</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>EMPTYARC</name><argument_list>(<argument><expr><name>s2</name></expr></argument>, <argument><expr><name>rp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>t</name><operator>-&gt;</operator><name>right</name></name> <operator>=</operator> <call><name>subre</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><literal type="char">'='</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>s2</name></expr></argument>, <argument><expr><name>rp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
	<expr_stmt><expr><call><name>NOERR</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>SEE</name><argument_list>(<argument><expr><literal type="char">'|'</literal></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>SEE</name><argument_list>(<argument><expr><name>stopper</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>SEE</name><argument_list>(<argument><expr><name>EOS</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>t</name><operator>-&gt;</operator><name>flags</name></name> <operator>|=</operator> <call><name>COMBINE</name><argument_list>(<argument><expr><name><name>t</name><operator>-&gt;</operator><name>flags</name></name></expr></argument>, <argument><expr><name><name>t</name><operator>-&gt;</operator><name>right</name><operator>-&gt;</operator><name>flags</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>top</name><operator>-&gt;</operator><name>flags</name></name> <operator>|=</operator> <call><name>COMBINE</name><argument_list>(<argument><expr><name><name>top</name><operator>-&gt;</operator><name>flags</name></name></expr></argument>, <argument><expr><name><name>t</name><operator>-&gt;</operator><name>flags</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * nonword - generate arcs for non-word-character ahead or behind
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>nonword</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>vars</name></name> <modifier>*</modifier></type><name>v</name></decl></parameter>,
		<parameter><decl><type><name>int</name></type> <name>dir</name></decl></parameter>,				<comment type="block">/* AHEAD or BEHIND */</comment>
		<parameter><decl><type><name><name>struct</name> <name>state</name></name> <modifier>*</modifier></type><name>lp</name></decl></parameter>,
		<parameter><decl><type><name><name>struct</name> <name>state</name></name> <modifier>*</modifier></type><name>rp</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>anchor</name> <init>= <expr><ternary><condition><expr><operator>(</operator><name>dir</name> <operator>==</operator> <name>AHEAD</name><operator>)</operator></expr> ?</condition><then> <expr><literal type="char">'$'</literal></expr> </then><else>: <expr><literal type="char">'^'</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>dir</name> <operator>==</operator> <name>AHEAD</name> <operator>||</operator> <name>dir</name> <operator>==</operator> <name>BEHIND</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>newarc</name><argument_list>(<argument><expr><name><name>v</name><operator>-&gt;</operator><name>nfa</name></name></expr></argument>, <argument><expr><name>anchor</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>lp</name></expr></argument>, <argument><expr><name>rp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>newarc</name><argument_list>(<argument><expr><name><name>v</name><operator>-&gt;</operator><name>nfa</name></name></expr></argument>, <argument><expr><name>anchor</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>lp</name></expr></argument>, <argument><expr><name>rp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>colorcomplement</name><argument_list>(<argument><expr><name><name>v</name><operator>-&gt;</operator><name>nfa</name></name></expr></argument>, <argument><expr><name><name>v</name><operator>-&gt;</operator><name>cm</name></name></expr></argument>, <argument><expr><name>dir</name></expr></argument>, <argument><expr><name><name>v</name><operator>-&gt;</operator><name>wordchrs</name></name></expr></argument>, <argument><expr><name>lp</name></expr></argument>, <argument><expr><name>rp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* (no need for special attention to \n) */</comment>
</block_content>}</block></function>

<comment type="block">/*
 * word - generate arcs for word character ahead or behind
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>word</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>vars</name></name> <modifier>*</modifier></type><name>v</name></decl></parameter>,
	 <parameter><decl><type><name>int</name></type> <name>dir</name></decl></parameter>,					<comment type="block">/* AHEAD or BEHIND */</comment>
	 <parameter><decl><type><name><name>struct</name> <name>state</name></name> <modifier>*</modifier></type><name>lp</name></decl></parameter>,
	 <parameter><decl><type><name><name>struct</name> <name>state</name></name> <modifier>*</modifier></type><name>rp</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>dir</name> <operator>==</operator> <name>AHEAD</name> <operator>||</operator> <name>dir</name> <operator>==</operator> <name>BEHIND</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>cloneouts</name><argument_list>(<argument><expr><name><name>v</name><operator>-&gt;</operator><name>nfa</name></name></expr></argument>, <argument><expr><name><name>v</name><operator>-&gt;</operator><name>wordchrs</name></name></expr></argument>, <argument><expr><name>lp</name></expr></argument>, <argument><expr><name>rp</name></expr></argument>, <argument><expr><name>dir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* (no need for special attention to \n) */</comment>
</block_content>}</block></function>

<comment type="block">/*
 * scannum - scan a number
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>						<comment type="block">/* value, &lt;= DUPMAX */</comment>
<name>scannum</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>vars</name></name> <modifier>*</modifier></type><name>v</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>n</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<while>while <condition>(<expr><call><name>SEE</name><argument_list>(<argument><expr><name>DIGIT</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>n</name> <operator>&lt;</operator> <name>DUPMAX</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>n</name> <operator>=</operator> <name>n</name> <operator>*</operator> <literal type="number">10</literal> <operator>+</operator> <name><name>v</name><operator>-&gt;</operator><name>nextvalue</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>NEXT</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></while>
	<if_stmt><if>if <condition>(<expr><call><name>SEE</name><argument_list>(<argument><expr><name>DIGIT</name></expr></argument>)</argument_list></call> <operator>||</operator> <name>n</name> <operator>&gt;</operator> <name>DUPMAX</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ERR</name><argument_list>(<argument><expr><name>REG_BADBR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><literal type="number">0</literal></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><name>n</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * repeat - replicate subNFA for quantifiers
 *
 * The sub-NFA strung from lp to rp is modified to represent m to n
 * repetitions of its initial contents.
 *
 * The duplication sequences used here are chosen carefully so that any
 * pointers starting out pointing into the subexpression end up pointing into
 * the last occurrence.  (Note that it may not be strung between the same
 * left and right end states, however!)  This used to be important for the
 * subRE tree, although the important bits are now handled by the in-line
 * code in parse(), and when this is called, it doesn't matter any more.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>repeat</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>vars</name></name> <modifier>*</modifier></type><name>v</name></decl></parameter>,
	   <parameter><decl><type><name><name>struct</name> <name>state</name></name> <modifier>*</modifier></type><name>lp</name></decl></parameter>,
	   <parameter><decl><type><name><name>struct</name> <name>state</name></name> <modifier>*</modifier></type><name>rp</name></decl></parameter>,
	   <parameter><decl><type><name>int</name></type> <name>m</name></decl></parameter>,
	   <parameter><decl><type><name>int</name></type> <name>n</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<cpp:define>#<cpp:directive>define</cpp:directive>  <cpp:macro><name>SOME</name></cpp:macro>	 <cpp:value>2</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive>  <cpp:macro><name>INF</name></cpp:macro>	 <cpp:value>3</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive>  <cpp:macro><name>PAIR</name><parameter_list>(<parameter><type><name>x</name></type></parameter>, <parameter><type><name>y</name></type></parameter>)</parameter_list></cpp:macro>  <cpp:value>((x)*4 + (y))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive>  <cpp:macro><name>REDUCE</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro>	 <cpp:value>( ((x) == DUPINF) ? INF : (((x) &gt; 1) ? SOME : (x)) )</cpp:value></cpp:define>
	<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type>	<name>rm</name> <init>= <expr><call><name>REDUCE</name><argument_list>(<argument><expr><name>m</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type>	<name>rn</name> <init>= <expr><call><name>REDUCE</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>state</name></name> <modifier>*</modifier></type><name>s</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>state</name></name> <modifier>*</modifier></type><name>s2</name></decl>;</decl_stmt>

	<switch>switch <condition>(<expr><call><name>PAIR</name><argument_list>(<argument><expr><name>rm</name></expr></argument>, <argument><expr><name>rn</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><call><name>PAIR</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>:</case>		<comment type="block">/* empty string */</comment>
			<expr_stmt><expr><call><name>delsub</name><argument_list>(<argument><expr><name><name>v</name><operator>-&gt;</operator><name>nfa</name></name></expr></argument>, <argument><expr><name>lp</name></expr></argument>, <argument><expr><name>rp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>EMPTYARC</name><argument_list>(<argument><expr><name>lp</name></expr></argument>, <argument><expr><name>rp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><call><name>PAIR</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>:</case>		<comment type="block">/* do as x| */</comment>
			<expr_stmt><expr><call><name>EMPTYARC</name><argument_list>(<argument><expr><name>lp</name></expr></argument>, <argument><expr><name>rp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><call><name>PAIR</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SOME</name></expr></argument>)</argument_list></call></expr>:</case>		<comment type="block">/* do as x{1,n}| */</comment>
			<expr_stmt><expr><call><name>repeat</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>lp</name></expr></argument>, <argument><expr><name>rp</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>NOERR</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>EMPTYARC</name><argument_list>(<argument><expr><name>lp</name></expr></argument>, <argument><expr><name>rp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><call><name>PAIR</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>INF</name></expr></argument>)</argument_list></call></expr>:</case>		<comment type="block">/* loop x around */</comment>
			<expr_stmt><expr><name>s</name> <operator>=</operator> <call><name>newstate</name><argument_list>(<argument><expr><name><name>v</name><operator>-&gt;</operator><name>nfa</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>NOERR</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>moveouts</name><argument_list>(<argument><expr><name><name>v</name><operator>-&gt;</operator><name>nfa</name></name></expr></argument>, <argument><expr><name>lp</name></expr></argument>, <argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>moveins</name><argument_list>(<argument><expr><name><name>v</name><operator>-&gt;</operator><name>nfa</name></name></expr></argument>, <argument><expr><name>rp</name></expr></argument>, <argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>EMPTYARC</name><argument_list>(<argument><expr><name>lp</name></expr></argument>, <argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>EMPTYARC</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>rp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><call><name>PAIR</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>:</case>		<comment type="block">/* no action required */</comment>
			<break>break;</break>
		<case>case <expr><call><name>PAIR</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>SOME</name></expr></argument>)</argument_list></call></expr>:</case>		<comment type="block">/* do as x{0,n-1}x = (x{1,n-1}|)x */</comment>
			<expr_stmt><expr><name>s</name> <operator>=</operator> <call><name>newstate</name><argument_list>(<argument><expr><name><name>v</name><operator>-&gt;</operator><name>nfa</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>NOERR</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>moveouts</name><argument_list>(<argument><expr><name><name>v</name><operator>-&gt;</operator><name>nfa</name></name></expr></argument>, <argument><expr><name>lp</name></expr></argument>, <argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>dupnfa</name><argument_list>(<argument><expr><name><name>v</name><operator>-&gt;</operator><name>nfa</name></name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name>rp</name></expr></argument>, <argument><expr><name>lp</name></expr></argument>, <argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>NOERR</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>repeat</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>lp</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>n</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>NOERR</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>EMPTYARC</name><argument_list>(<argument><expr><name>lp</name></expr></argument>, <argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><call><name>PAIR</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>INF</name></expr></argument>)</argument_list></call></expr>:</case>		<comment type="block">/* add loopback arc */</comment>
			<expr_stmt><expr><name>s</name> <operator>=</operator> <call><name>newstate</name><argument_list>(<argument><expr><name><name>v</name><operator>-&gt;</operator><name>nfa</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>s2</name> <operator>=</operator> <call><name>newstate</name><argument_list>(<argument><expr><name><name>v</name><operator>-&gt;</operator><name>nfa</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>NOERR</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>moveouts</name><argument_list>(<argument><expr><name><name>v</name><operator>-&gt;</operator><name>nfa</name></name></expr></argument>, <argument><expr><name>lp</name></expr></argument>, <argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>moveins</name><argument_list>(<argument><expr><name><name>v</name><operator>-&gt;</operator><name>nfa</name></name></expr></argument>, <argument><expr><name>rp</name></expr></argument>, <argument><expr><name>s2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>EMPTYARC</name><argument_list>(<argument><expr><name>lp</name></expr></argument>, <argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>EMPTYARC</name><argument_list>(<argument><expr><name>s2</name></expr></argument>, <argument><expr><name>rp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>EMPTYARC</name><argument_list>(<argument><expr><name>s2</name></expr></argument>, <argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><call><name>PAIR</name><argument_list>(<argument><expr><name>SOME</name></expr></argument>, <argument><expr><name>SOME</name></expr></argument>)</argument_list></call></expr>:</case>	<comment type="block">/* do as x{m-1,n-1}x */</comment>
			<expr_stmt><expr><name>s</name> <operator>=</operator> <call><name>newstate</name><argument_list>(<argument><expr><name><name>v</name><operator>-&gt;</operator><name>nfa</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>NOERR</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>moveouts</name><argument_list>(<argument><expr><name><name>v</name><operator>-&gt;</operator><name>nfa</name></name></expr></argument>, <argument><expr><name>lp</name></expr></argument>, <argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>dupnfa</name><argument_list>(<argument><expr><name><name>v</name><operator>-&gt;</operator><name>nfa</name></name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name>rp</name></expr></argument>, <argument><expr><name>lp</name></expr></argument>, <argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>NOERR</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>repeat</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>lp</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name>m</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>n</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><call><name>PAIR</name><argument_list>(<argument><expr><name>SOME</name></expr></argument>, <argument><expr><name>INF</name></expr></argument>)</argument_list></call></expr>:</case>	<comment type="block">/* do as x{m-1,}x */</comment>
			<expr_stmt><expr><name>s</name> <operator>=</operator> <call><name>newstate</name><argument_list>(<argument><expr><name><name>v</name><operator>-&gt;</operator><name>nfa</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>NOERR</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>moveouts</name><argument_list>(<argument><expr><name><name>v</name><operator>-&gt;</operator><name>nfa</name></name></expr></argument>, <argument><expr><name>lp</name></expr></argument>, <argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>dupnfa</name><argument_list>(<argument><expr><name><name>v</name><operator>-&gt;</operator><name>nfa</name></name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name>rp</name></expr></argument>, <argument><expr><name>lp</name></expr></argument>, <argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>NOERR</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>repeat</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>lp</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name>m</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<default>default:</default>
			<expr_stmt><expr><call><name>ERR</name><argument_list>(<argument><expr><name>REG_ASSERT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
	</block_content>}</block></switch>
</block_content>}</block></function>

<comment type="block">/*
 * bracket - handle non-complemented bracket expression
 * Also called from cbracket for complemented bracket expressions.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>bracket</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>vars</name></name> <modifier>*</modifier></type><name>v</name></decl></parameter>,
		<parameter><decl><type><name><name>struct</name> <name>state</name></name> <modifier>*</modifier></type><name>lp</name></decl></parameter>,
		<parameter><decl><type><name><name>struct</name> <name>state</name></name> <modifier>*</modifier></type><name>rp</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>SEE</name><argument_list>(<argument><expr><literal type="char">'['</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>NEXT</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<while>while <condition>(<expr><operator>!</operator><call><name>SEE</name><argument_list>(<argument><expr><literal type="char">']'</literal></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>SEE</name><argument_list>(<argument><expr><name>EOS</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>brackpart</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>lp</name></expr></argument>, <argument><expr><name>rp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></while>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>SEE</name><argument_list>(<argument><expr><literal type="char">']'</literal></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>ISERR</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>okcolors</name><argument_list>(<argument><expr><name><name>v</name><operator>-&gt;</operator><name>nfa</name></name></expr></argument>, <argument><expr><name><name>v</name><operator>-&gt;</operator><name>cm</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * cbracket - handle complemented bracket expression
 * We do it by calling bracket() with dummy endpoints, and then complementing
 * the result.  The alternative would be to invoke rainbow(), and then delete
 * arcs as the b.e. is seen... but that gets messy.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>cbracket</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>vars</name></name> <modifier>*</modifier></type><name>v</name></decl></parameter>,
		 <parameter><decl><type><name><name>struct</name> <name>state</name></name> <modifier>*</modifier></type><name>lp</name></decl></parameter>,
		 <parameter><decl><type><name><name>struct</name> <name>state</name></name> <modifier>*</modifier></type><name>rp</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name><name>struct</name> <name>state</name></name> <modifier>*</modifier></type><name>left</name> <init>= <expr><call><name>newstate</name><argument_list>(<argument><expr><name><name>v</name><operator>-&gt;</operator><name>nfa</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>state</name></name> <modifier>*</modifier></type><name>right</name> <init>= <expr><call><name>newstate</name><argument_list>(<argument><expr><name><name>v</name><operator>-&gt;</operator><name>nfa</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>NOERR</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>bracket</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>left</name></expr></argument>, <argument><expr><name>right</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>v</name><operator>-&gt;</operator><name>cflags</name></name> <operator>&amp;</operator> <name>REG_NLSTOP</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>newarc</name><argument_list>(<argument><expr><name><name>v</name><operator>-&gt;</operator><name>nfa</name></name></expr></argument>, <argument><expr><name>PLAIN</name></expr></argument>, <argument><expr><name><name>v</name><operator>-&gt;</operator><name>nlcolor</name></name></expr></argument>, <argument><expr><name>left</name></expr></argument>, <argument><expr><name>right</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><call><name>NOERR</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>lp</name><operator>-&gt;</operator><name>nouts</name></name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>		<comment type="block">/* all outarcs will be ours */</comment>

	<comment type="block">/*
	 * Easy part of complementing, and all there is to do since the MCCE code
	 * was removed.
	 */</comment>
	<expr_stmt><expr><call><name>colorcomplement</name><argument_list>(<argument><expr><name><name>v</name><operator>-&gt;</operator><name>nfa</name></name></expr></argument>, <argument><expr><name><name>v</name><operator>-&gt;</operator><name>cm</name></name></expr></argument>, <argument><expr><name>PLAIN</name></expr></argument>, <argument><expr><name>left</name></expr></argument>, <argument><expr><name>lp</name></expr></argument>, <argument><expr><name>rp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>NOERR</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>dropstate</name><argument_list>(<argument><expr><name><name>v</name><operator>-&gt;</operator><name>nfa</name></name></expr></argument>, <argument><expr><name>left</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>right</name><operator>-&gt;</operator><name>nins</name></name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>freestate</name><argument_list>(<argument><expr><name><name>v</name><operator>-&gt;</operator><name>nfa</name></name></expr></argument>, <argument><expr><name>right</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * brackpart - handle one item (or range) within a bracket expression
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>brackpart</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>vars</name></name> <modifier>*</modifier></type><name>v</name></decl></parameter>,
		  <parameter><decl><type><name><name>struct</name> <name>state</name></name> <modifier>*</modifier></type><name>lp</name></decl></parameter>,
		  <parameter><decl><type><name><name>struct</name> <name>state</name></name> <modifier>*</modifier></type><name>rp</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>chr</name></type>			<name>startc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>chr</name></type>			<name>endc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>cvec</name></name> <modifier>*</modifier></type><name>cv</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>chr</name>  <modifier>*</modifier></type><name>startp</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>chr</name>  <modifier>*</modifier></type><name>endp</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>chr</name></type>			<name><name>c</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>

	<comment type="block">/* parse something, get rid of special cases, take shortcuts */</comment>
	<switch>switch <condition>(<expr><name><name>v</name><operator>-&gt;</operator><name>nexttype</name></name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>RANGE</name></expr>:</case>				<comment type="block">/* a-b-c or other botch */</comment>
			<expr_stmt><expr><call><name>ERR</name><argument_list>(<argument><expr><name>REG_ERANGE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return;</return>
			<break>break;</break>
		<case>case <expr><name>PLAIN</name></expr>:</case>
			<expr_stmt><expr><name><name>c</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name><name>v</name><operator>-&gt;</operator><name>nextvalue</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>NEXT</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* shortcut for ordinary chr (not range) */</comment>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>SEE</name><argument_list>(<argument><expr><name>RANGE</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>onechr</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name><name>c</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name>lp</name></expr></argument>, <argument><expr><name>rp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return;</return>
			</block_content>}</block></if></if_stmt>
			<expr_stmt><expr><name>startc</name> <operator>=</operator> <call><name>element</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>c</name></expr></argument>, <argument><expr><name>c</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>NOERR</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>COLLEL</name></expr>:</case>
			<expr_stmt><expr><name>startp</name> <operator>=</operator> <name><name>v</name><operator>-&gt;</operator><name>now</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name>endp</name> <operator>=</operator> <call><name>scanplain</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>INSIST</name><argument_list>(<argument><expr><name>startp</name> <operator>&lt;</operator> <name>endp</name></expr></argument>, <argument><expr><name>REG_ECOLLATE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>NOERR</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>startc</name> <operator>=</operator> <call><name>element</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>startp</name></expr></argument>, <argument><expr><name>endp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>NOERR</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>ECLASS</name></expr>:</case>
			<expr_stmt><expr><name>startp</name> <operator>=</operator> <name><name>v</name><operator>-&gt;</operator><name>now</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name>endp</name> <operator>=</operator> <call><name>scanplain</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>INSIST</name><argument_list>(<argument><expr><name>startp</name> <operator>&lt;</operator> <name>endp</name></expr></argument>, <argument><expr><name>REG_ECOLLATE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>NOERR</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>startc</name> <operator>=</operator> <call><name>element</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>startp</name></expr></argument>, <argument><expr><name>endp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>NOERR</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>cv</name> <operator>=</operator> <call><name>eclass</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>startc</name></expr></argument>, <argument><expr><operator>(</operator><name><name>v</name><operator>-&gt;</operator><name>cflags</name></name> <operator>&amp;</operator> <name>REG_ICASE</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>NOERR</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>subcolorcvec</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>cv</name></expr></argument>, <argument><expr><name>lp</name></expr></argument>, <argument><expr><name>rp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return;</return>
			<break>break;</break>
		<case>case <expr><name>CCLASS</name></expr>:</case>
			<expr_stmt><expr><name>startp</name> <operator>=</operator> <name><name>v</name><operator>-&gt;</operator><name>now</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name>endp</name> <operator>=</operator> <call><name>scanplain</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>INSIST</name><argument_list>(<argument><expr><name>startp</name> <operator>&lt;</operator> <name>endp</name></expr></argument>, <argument><expr><name>REG_ECTYPE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>NOERR</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>cv</name> <operator>=</operator> <call><name>cclass</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>startp</name></expr></argument>, <argument><expr><name>endp</name></expr></argument>, <argument><expr><operator>(</operator><name><name>v</name><operator>-&gt;</operator><name>cflags</name></name> <operator>&amp;</operator> <name>REG_ICASE</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>NOERR</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>subcolorcvec</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>cv</name></expr></argument>, <argument><expr><name>lp</name></expr></argument>, <argument><expr><name>rp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return;</return>
			<break>break;</break>
		<default>default:</default>
			<expr_stmt><expr><call><name>ERR</name><argument_list>(<argument><expr><name>REG_ASSERT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return;</return>
			<break>break;</break>
	</block_content>}</block></switch>

	<if_stmt><if>if <condition>(<expr><call><name>SEE</name><argument_list>(<argument><expr><name>RANGE</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>NEXT</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<switch>switch <condition>(<expr><name><name>v</name><operator>-&gt;</operator><name>nexttype</name></name></expr>)</condition>
		<block>{<block_content>
			<case>case <expr><name>PLAIN</name></expr>:</case>
			<case>case <expr><name>RANGE</name></expr>:</case>
				<expr_stmt><expr><name><name>c</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name><name>v</name><operator>-&gt;</operator><name>nextvalue</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>NEXT</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>endc</name> <operator>=</operator> <call><name>element</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>c</name></expr></argument>, <argument><expr><name>c</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>NOERR</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>COLLEL</name></expr>:</case>
				<expr_stmt><expr><name>startp</name> <operator>=</operator> <name><name>v</name><operator>-&gt;</operator><name>now</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><name>endp</name> <operator>=</operator> <call><name>scanplain</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>INSIST</name><argument_list>(<argument><expr><name>startp</name> <operator>&lt;</operator> <name>endp</name></expr></argument>, <argument><expr><name>REG_ECOLLATE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>NOERR</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>endc</name> <operator>=</operator> <call><name>element</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>startp</name></expr></argument>, <argument><expr><name>endp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>NOERR</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<default>default:</default>
				<expr_stmt><expr><call><name>ERR</name><argument_list>(<argument><expr><name>REG_ERANGE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return;</return>
				<break>break;</break>
		</block_content>}</block></switch>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>endc</name> <operator>=</operator> <name>startc</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/*
	 * Ranges are unportable.  Actually, standard C does guarantee that digits
	 * are contiguous, but making that an exception is just too complicated.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>startc</name> <operator>!=</operator> <name>endc</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>NOTE</name><argument_list>(<argument><expr><name>REG_UUNPORT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>cv</name> <operator>=</operator> <call><name>range</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>startc</name></expr></argument>, <argument><expr><name>endc</name></expr></argument>, <argument><expr><operator>(</operator><name><name>v</name><operator>-&gt;</operator><name>cflags</name></name> <operator>&amp;</operator> <name>REG_ICASE</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>NOERR</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>subcolorcvec</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>cv</name></expr></argument>, <argument><expr><name>lp</name></expr></argument>, <argument><expr><name>rp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * scanplain - scan PLAIN contents of [. etc.
 *
 * Certain bits of trickery in lex.c know that this code does not try
 * to look past the final bracket of the [. etc.
 */</comment>
<function><type><specifier>static</specifier> <specifier>const</specifier> <name>chr</name> <modifier>*</modifier></type>				<comment type="block">/* just after end of sequence */</comment>
<name>scanplain</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>vars</name></name> <modifier>*</modifier></type><name>v</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>chr</name>  <modifier>*</modifier></type><name>endp</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>SEE</name><argument_list>(<argument><expr><name>COLLEL</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>SEE</name><argument_list>(<argument><expr><name>ECLASS</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>SEE</name><argument_list>(<argument><expr><name>CCLASS</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>NEXT</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>endp</name> <operator>=</operator> <name><name>v</name><operator>-&gt;</operator><name>now</name></name></expr>;</expr_stmt>
	<while>while <condition>(<expr><call><name>SEE</name><argument_list>(<argument><expr><name>PLAIN</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>endp</name> <operator>=</operator> <name><name>v</name><operator>-&gt;</operator><name>now</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>NEXT</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></while>

	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>SEE</name><argument_list>(<argument><expr><name>END</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>ISERR</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>NEXT</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>endp</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * onechr - fill in arcs for a plain character, and possible case complements
 * This is mostly a shortcut for efficient handling of the common case.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>onechr</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>vars</name></name> <modifier>*</modifier></type><name>v</name></decl></parameter>,
	   <parameter><decl><type><name>chr</name></type> <name>c</name></decl></parameter>,
	   <parameter><decl><type><name><name>struct</name> <name>state</name></name> <modifier>*</modifier></type><name>lp</name></decl></parameter>,
	   <parameter><decl><type><name><name>struct</name> <name>state</name></name> <modifier>*</modifier></type><name>rp</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name><name>v</name><operator>-&gt;</operator><name>cflags</name></name> <operator>&amp;</operator> <name>REG_ICASE</name><operator>)</operator></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>color</name></type>		<name>lastsubcolor</name> <init>= <expr><name>COLORLESS</name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>subcoloronechr</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>c</name></expr></argument>, <argument><expr><name>lp</name></expr></argument>, <argument><expr><name>rp</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>lastsubcolor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* rats, need general case anyway... */</comment>
	<expr_stmt><expr><call><name>subcolorcvec</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><call><name>allcases</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>lp</name></expr></argument>, <argument><expr><name>rp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * wordchrs - set up word-chr list for word-boundary stuff, if needed
 *
 * The list is kept as a bunch of arcs between two dummy states; it's
 * disposed of by the unreachable-states sweep in NFA optimization.
 * Does NEXT().  Must not be called from any unusual lexical context.
 * This should be reconciled with the \w etc. handling in lex.c, and
 * should be cleaned up to reduce dependencies on input scanning.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>wordchrs</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>vars</name></name> <modifier>*</modifier></type><name>v</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name><name>struct</name> <name>state</name></name> <modifier>*</modifier></type><name>left</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>state</name></name> <modifier>*</modifier></type><name>right</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>v</name><operator>-&gt;</operator><name>wordchrs</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>NEXT</name><argument_list>()</argument_list></call></expr>;</expr_stmt>					<comment type="block">/* for consistency */</comment>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>left</name> <operator>=</operator> <call><name>newstate</name><argument_list>(<argument><expr><name><name>v</name><operator>-&gt;</operator><name>nfa</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>right</name> <operator>=</operator> <call><name>newstate</name><argument_list>(<argument><expr><name><name>v</name><operator>-&gt;</operator><name>nfa</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>NOERR</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* fine point:	implemented with [::], and lexer will set REG_ULOCALE */</comment>
	<expr_stmt><expr><call><name>lexword</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>NEXT</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>v</name><operator>-&gt;</operator><name>savenow</name></name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <call><name>SEE</name><argument_list>(<argument><expr><literal type="char">'['</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>bracket</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>left</name></expr></argument>, <argument><expr><name>right</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>(</operator><name><name>v</name><operator>-&gt;</operator><name>savenow</name></name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <call><name>SEE</name><argument_list>(<argument><expr><literal type="char">']'</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>||</operator> <call><name>ISERR</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>NEXT</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>NOERR</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>v</name><operator>-&gt;</operator><name>wordchrs</name></name> <operator>=</operator> <name>left</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * processlacon - generate the NFA representation of a LACON
 *
 * In the general case this is just newlacon() + newarc(), but some cases
 * can be optimized.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>processlacon</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>vars</name></name> <modifier>*</modifier></type><name>v</name></decl></parameter>,
			 <parameter><decl><type><name><name>struct</name> <name>state</name></name> <modifier>*</modifier></type><name>begin</name></decl></parameter>,	<comment type="block">/* start of parsed LACON sub-re */</comment>
			 <parameter><decl><type><name><name>struct</name> <name>state</name></name> <modifier>*</modifier></type><name>end</name></decl></parameter>, <comment type="block">/* end of parsed LACON sub-re */</comment>
			 <parameter><decl><type><name>int</name></type> <name>latype</name></decl></parameter>,
			 <parameter><decl><type><name><name>struct</name> <name>state</name></name> <modifier>*</modifier></type><name>lp</name></decl></parameter>,	<comment type="block">/* left state to hang it on */</comment>
			 <parameter><decl><type><name><name>struct</name> <name>state</name></name> <modifier>*</modifier></type><name>rp</name></decl></parameter>)</parameter_list>	<comment type="block">/* right state to hang it on */</comment>
<block>{<block_content>
	<decl_stmt><decl><type><name><name>struct</name> <name>state</name></name> <modifier>*</modifier></type><name>s1</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>n</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Check for lookaround RE consisting of a single plain color arc (or set
	 * of arcs); this would typically be a simple chr or a bracket expression.
	 */</comment>
	<expr_stmt><expr><name>s1</name> <operator>=</operator> <call><name>single_color_transition</name><argument_list>(<argument><expr><name>begin</name></expr></argument>, <argument><expr><name>end</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<switch>switch <condition>(<expr><name>latype</name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>LATYPE_AHEAD_POS</name></expr>:</case>
			<comment type="block">/* If lookahead RE is just colorset C, convert to AHEAD(C) */</comment>
			<if_stmt><if>if <condition>(<expr><name>s1</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>cloneouts</name><argument_list>(<argument><expr><name><name>v</name><operator>-&gt;</operator><name>nfa</name></name></expr></argument>, <argument><expr><name>s1</name></expr></argument>, <argument><expr><name>lp</name></expr></argument>, <argument><expr><name>rp</name></expr></argument>, <argument><expr><name>AHEAD</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return;</return>
			</block_content>}</block></if></if_stmt>
			<break>break;</break>
		<case>case <expr><name>LATYPE_AHEAD_NEG</name></expr>:</case>
			<comment type="block">/* If lookahead RE is just colorset C, convert to AHEAD(^C)|$ */</comment>
			<if_stmt><if>if <condition>(<expr><name>s1</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>colorcomplement</name><argument_list>(<argument><expr><name><name>v</name><operator>-&gt;</operator><name>nfa</name></name></expr></argument>, <argument><expr><name><name>v</name><operator>-&gt;</operator><name>cm</name></name></expr></argument>, <argument><expr><name>AHEAD</name></expr></argument>, <argument><expr><name>s1</name></expr></argument>, <argument><expr><name>lp</name></expr></argument>, <argument><expr><name>rp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>newarc</name><argument_list>(<argument><expr><name><name>v</name><operator>-&gt;</operator><name>nfa</name></name></expr></argument>, <argument><expr><literal type="char">'$'</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>lp</name></expr></argument>, <argument><expr><name>rp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>newarc</name><argument_list>(<argument><expr><name><name>v</name><operator>-&gt;</operator><name>nfa</name></name></expr></argument>, <argument><expr><literal type="char">'$'</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>lp</name></expr></argument>, <argument><expr><name>rp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return;</return>
			</block_content>}</block></if></if_stmt>
			<break>break;</break>
		<case>case <expr><name>LATYPE_BEHIND_POS</name></expr>:</case>
			<comment type="block">/* If lookbehind RE is just colorset C, convert to BEHIND(C) */</comment>
			<if_stmt><if>if <condition>(<expr><name>s1</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>cloneouts</name><argument_list>(<argument><expr><name><name>v</name><operator>-&gt;</operator><name>nfa</name></name></expr></argument>, <argument><expr><name>s1</name></expr></argument>, <argument><expr><name>lp</name></expr></argument>, <argument><expr><name>rp</name></expr></argument>, <argument><expr><name>BEHIND</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return;</return>
			</block_content>}</block></if></if_stmt>
			<break>break;</break>
		<case>case <expr><name>LATYPE_BEHIND_NEG</name></expr>:</case>
			<comment type="block">/* If lookbehind RE is just colorset C, convert to BEHIND(^C)|^ */</comment>
			<if_stmt><if>if <condition>(<expr><name>s1</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>colorcomplement</name><argument_list>(<argument><expr><name><name>v</name><operator>-&gt;</operator><name>nfa</name></name></expr></argument>, <argument><expr><name><name>v</name><operator>-&gt;</operator><name>cm</name></name></expr></argument>, <argument><expr><name>BEHIND</name></expr></argument>, <argument><expr><name>s1</name></expr></argument>, <argument><expr><name>lp</name></expr></argument>, <argument><expr><name>rp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>newarc</name><argument_list>(<argument><expr><name><name>v</name><operator>-&gt;</operator><name>nfa</name></name></expr></argument>, <argument><expr><literal type="char">'^'</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>lp</name></expr></argument>, <argument><expr><name>rp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>newarc</name><argument_list>(<argument><expr><name><name>v</name><operator>-&gt;</operator><name>nfa</name></name></expr></argument>, <argument><expr><literal type="char">'^'</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>lp</name></expr></argument>, <argument><expr><name>rp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return;</return>
			</block_content>}</block></if></if_stmt>
			<break>break;</break>
		<default>default:</default>
			<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>NOTREACHED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></switch>

	<comment type="block">/* General case: we need a LACON subre and arc */</comment>
	<expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>newlacon</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>begin</name></expr></argument>, <argument><expr><name>end</name></expr></argument>, <argument><expr><name>latype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>newarc</name><argument_list>(<argument><expr><name><name>v</name><operator>-&gt;</operator><name>nfa</name></name></expr></argument>, <argument><expr><name>LACON</name></expr></argument>, <argument><expr><name>n</name></expr></argument>, <argument><expr><name>lp</name></expr></argument>, <argument><expr><name>rp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * subre - allocate a subre
 */</comment>
<function><type><specifier>static</specifier> <name><name>struct</name> <name>subre</name></name> <modifier>*</modifier></type>
<name>subre</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>vars</name></name> <modifier>*</modifier></type><name>v</name></decl></parameter>,
	  <parameter><decl><type><name>int</name></type> <name>op</name></decl></parameter>,
	  <parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>,
	  <parameter><decl><type><name><name>struct</name> <name>state</name></name> <modifier>*</modifier></type><name>begin</name></decl></parameter>,
	  <parameter><decl><type><name><name>struct</name> <name>state</name></name> <modifier>*</modifier></type><name>end</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name><name>struct</name> <name>subre</name></name> <modifier>*</modifier></type><name>ret</name> <init>= <expr><name><name>v</name><operator>-&gt;</operator><name>treefree</name></name></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * Checking for stack overflow here is sufficient to protect parse() and
	 * its recursive subroutines.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>STACK_TOO_DEEP</name><argument_list>(<argument><expr><name><name>v</name><operator>-&gt;</operator><name>re</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ERR</name><argument_list>(<argument><expr><name>REG_ETOOBIG</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>v</name><operator>-&gt;</operator><name>treefree</name></name> <operator>=</operator> <name><name>ret</name><operator>-&gt;</operator><name>left</name></name></expr>;</expr_stmt></block_content></block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name>ret</name> <operator>=</operator> <operator>(</operator>struct <name>subre</name> <operator>*</operator><operator>)</operator> <call><name>MALLOC</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr>struct <name>subre</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ERR</name><argument_list>(<argument><expr><name>REG_ESPACE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>NULL</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><name><name>ret</name><operator>-&gt;</operator><name>chain</name></name> <operator>=</operator> <name><name>v</name><operator>-&gt;</operator><name>treechain</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>v</name><operator>-&gt;</operator><name>treechain</name></name> <operator>=</operator> <name>ret</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>strchr</name><argument_list>(<argument><expr><literal type="string">"=b|.*("</literal></expr></argument>, <argument><expr><name>op</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>ret</name><operator>-&gt;</operator><name>op</name></name> <operator>=</operator> <name>op</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ret</name><operator>-&gt;</operator><name>flags</name></name> <operator>=</operator> <name>flags</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ret</name><operator>-&gt;</operator><name>id</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>				<comment type="block">/* will be assigned later */</comment>
	<expr_stmt><expr><name><name>ret</name><operator>-&gt;</operator><name>subno</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ret</name><operator>-&gt;</operator><name>min</name></name> <operator>=</operator> <name><name>ret</name><operator>-&gt;</operator><name>max</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ret</name><operator>-&gt;</operator><name>left</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ret</name><operator>-&gt;</operator><name>right</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ret</name><operator>-&gt;</operator><name>begin</name></name> <operator>=</operator> <name>begin</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ret</name><operator>-&gt;</operator><name>end</name></name> <operator>=</operator> <name>end</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ZAPCNFA</name><argument_list>(<argument><expr><name><name>ret</name><operator>-&gt;</operator><name>cnfa</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * freesubre - free a subRE subtree
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>freesubre</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>vars</name></name> <modifier>*</modifier></type><name>v</name></decl></parameter>,		<comment type="block">/* might be NULL */</comment>
		  <parameter><decl><type><name><name>struct</name> <name>subre</name></name> <modifier>*</modifier></type><name>sr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>sr</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>sr</name><operator>-&gt;</operator><name>left</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>freesubre</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name><name>sr</name><operator>-&gt;</operator><name>left</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>sr</name><operator>-&gt;</operator><name>right</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>freesubre</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name><name>sr</name><operator>-&gt;</operator><name>right</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>freesrnode</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>sr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * freesrnode - free one node in a subRE subtree
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>freesrnode</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>vars</name></name> <modifier>*</modifier></type><name>v</name></decl></parameter>,		<comment type="block">/* might be NULL */</comment>
		   <parameter><decl><type><name><name>struct</name> <name>subre</name></name> <modifier>*</modifier></type><name>sr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>sr</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>NULLCNFA</name><argument_list>(<argument><expr><name><name>sr</name><operator>-&gt;</operator><name>cnfa</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>freecnfa</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>sr</name><operator>-&gt;</operator><name>cnfa</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name><name>sr</name><operator>-&gt;</operator><name>flags</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>v</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name><name>v</name><operator>-&gt;</operator><name>treechain</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* we're still parsing, maybe we can reuse the subre */</comment>
		<expr_stmt><expr><name><name>sr</name><operator>-&gt;</operator><name>left</name></name> <operator>=</operator> <name><name>v</name><operator>-&gt;</operator><name>treefree</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>v</name><operator>-&gt;</operator><name>treefree</name></name> <operator>=</operator> <name>sr</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>FREE</name><argument_list>(<argument><expr><name>sr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * optst - optimize a subRE subtree
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>optst</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>vars</name></name> <modifier>*</modifier></type><name>v</name></decl></parameter>,
	  <parameter><decl><type><name><name>struct</name> <name>subre</name></name> <modifier>*</modifier></type><name>t</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * DGP (2007-11-13): I assume it was the programmer's intent to eventually
	 * come back and add code to optimize subRE trees, but the routine coded
	 * just spends effort traversing the tree and doing nothing. We can do
	 * nothing with less effort.
	 */</comment>
	<return>return;</return>
</block_content>}</block></function>

<comment type="block">/*
 * numst - number tree nodes (assigning "id" indexes)
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>						<comment type="block">/* next number */</comment>
<name>numst</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>subre</name></name> <modifier>*</modifier></type><name>t</name></decl></parameter>,
	  <parameter><decl><type><name>int</name></type> <name>start</name></decl></parameter>)</parameter_list>				<comment type="block">/* starting point for subtree numbers */</comment>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>t</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>i</name> <operator>=</operator> <name>start</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>t</name><operator>-&gt;</operator><name>id</name></name> <operator>=</operator> <operator>(</operator><name>short</name><operator>)</operator> <name>i</name><operator>++</operator></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>t</name><operator>-&gt;</operator><name>left</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>i</name> <operator>=</operator> <call><name>numst</name><argument_list>(<argument><expr><name><name>t</name><operator>-&gt;</operator><name>left</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>t</name><operator>-&gt;</operator><name>right</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>i</name> <operator>=</operator> <call><name>numst</name><argument_list>(<argument><expr><name><name>t</name><operator>-&gt;</operator><name>right</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<return>return <expr><name>i</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * markst - mark tree nodes as INUSE
 *
 * Note: this is a great deal more subtle than it looks.  During initial
 * parsing of a regex, all subres are linked into the treechain list;
 * discarded ones are also linked into the treefree list for possible reuse.
 * After we are done creating all subres required for a regex, we run markst()
 * then cleanst(), which results in discarding all subres not reachable from
 * v-&gt;tree.  We then clear v-&gt;treechain, indicating that subres must be found
 * by descending from v-&gt;tree.  This changes the behavior of freesubre(): it
 * will henceforth FREE() unwanted subres rather than sticking them into the
 * treefree list.  (Doing that any earlier would result in dangling links in
 * the treechain list.)  This all means that freev() will clean up correctly
 * if invoked before or after markst()+cleanst(); but it would not work if
 * called partway through this state conversion, so we mustn't error out
 * in or between these two functions.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>markst</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>subre</name></name> <modifier>*</modifier></type><name>t</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>t</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>t</name><operator>-&gt;</operator><name>flags</name></name> <operator>|=</operator> <name>INUSE</name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>t</name><operator>-&gt;</operator><name>left</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>markst</name><argument_list>(<argument><expr><name><name>t</name><operator>-&gt;</operator><name>left</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>t</name><operator>-&gt;</operator><name>right</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>markst</name><argument_list>(<argument><expr><name><name>t</name><operator>-&gt;</operator><name>right</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * cleanst - free any tree nodes not marked INUSE
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>cleanst</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>vars</name></name> <modifier>*</modifier></type><name>v</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name><name>struct</name> <name>subre</name></name> <modifier>*</modifier></type><name>t</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>subre</name></name> <modifier>*</modifier></type><name>next</name></decl>;</decl_stmt>

	<for>for <control>(<init><expr><name>t</name> <operator>=</operator> <name><name>v</name><operator>-&gt;</operator><name>treechain</name></name></expr>;</init> <condition><expr><name>t</name> <operator>!=</operator> <name>NULL</name></expr>;</condition> <incr><expr><name>t</name> <operator>=</operator> <name>next</name></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><name>next</name> <operator>=</operator> <name><name>t</name><operator>-&gt;</operator><name>chain</name></name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name><name>t</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>INUSE</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>FREE</name><argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></for>
	<expr_stmt><expr><name><name>v</name><operator>-&gt;</operator><name>treechain</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>v</name><operator>-&gt;</operator><name>treefree</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>			<comment type="block">/* just on general principles */</comment>
</block_content>}</block></function>

<comment type="block">/*
 * nfatree - turn a subRE subtree into a tree of compacted NFAs
 */</comment>
<function><type><specifier>static</specifier> <name>long</name></type>						<comment type="block">/* optimize results from top node */</comment>
<name>nfatree</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>vars</name></name> <modifier>*</modifier></type><name>v</name></decl></parameter>,
		<parameter><decl><type><name><name>struct</name> <name>subre</name></name> <modifier>*</modifier></type><name>t</name></decl></parameter>,
		<parameter><decl><type><name>FILE</name> <modifier>*</modifier></type><name>f</name></decl></parameter>)</parameter_list>				<comment type="block">/* for debug output */</comment>
<block>{<block_content>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>t</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name><name>t</name><operator>-&gt;</operator><name>begin</name></name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>t</name><operator>-&gt;</operator><name>left</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><operator>(</operator><name>DISCARD</name><operator>)</operator> <call><name>nfatree</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name><name>t</name><operator>-&gt;</operator><name>left</name></name></expr></argument>, <argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>t</name><operator>-&gt;</operator><name>right</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><operator>(</operator><name>DISCARD</name><operator>)</operator> <call><name>nfatree</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name><name>t</name><operator>-&gt;</operator><name>right</name></name></expr></argument>, <argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><call><name>nfanode</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>t</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * nfanode - do one NFA for nfatree or lacons
 *
 * If converttosearch is true, apply makesearch() to the NFA.
 */</comment>
<function><type><specifier>static</specifier> <name>long</name></type>						<comment type="block">/* optimize results */</comment>
<name>nfanode</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>vars</name></name> <modifier>*</modifier></type><name>v</name></decl></parameter>,
		<parameter><decl><type><name><name>struct</name> <name>subre</name></name> <modifier>*</modifier></type><name>t</name></decl></parameter>,
		<parameter><decl><type><name>int</name></type> <name>converttosearch</name></decl></parameter>,
		<parameter><decl><type><name>FILE</name> <modifier>*</modifier></type><name>f</name></decl></parameter>)</parameter_list>				<comment type="block">/* for debug output */</comment>
<block>{<block_content>
	<decl_stmt><decl><type><name><name>struct</name> <name>nfa</name></name> <modifier>*</modifier></type><name>nfa</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>long</name></type>		<name>ret</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>t</name><operator>-&gt;</operator><name>begin</name></name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>REG_DEBUG</name></cpp:ifdef>
	<if_stmt><if>if <condition>(<expr><name>f</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name></type>		<name><name>idbuf</name><index>[<expr><literal type="number">50</literal></expr>]</index></name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><literal type="string">"\n\n\n========= TREE NODE %s ==========\n"</literal></expr></argument>,
				<argument><expr><call><name>stid</name><argument_list>(<argument><expr><name>t</name></expr></argument>, <argument><expr><name>idbuf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>idbuf</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<expr_stmt><expr><name>nfa</name> <operator>=</operator> <call><name>newnfa</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name><name>v</name><operator>-&gt;</operator><name>cm</name></name></expr></argument>, <argument><expr><name><name>v</name><operator>-&gt;</operator><name>nfa</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>NOERRZ</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>dupnfa</name><argument_list>(<argument><expr><name>nfa</name></expr></argument>, <argument><expr><name><name>t</name><operator>-&gt;</operator><name>begin</name></name></expr></argument>, <argument><expr><name><name>t</name><operator>-&gt;</operator><name>end</name></name></expr></argument>, <argument><expr><name><name>nfa</name><operator>-&gt;</operator><name>init</name></name></expr></argument>, <argument><expr><name><name>nfa</name><operator>-&gt;</operator><name>final</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ISERR</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>specialcolors</name><argument_list>(<argument><expr><name>nfa</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ISERR</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>optimize</name><argument_list>(<argument><expr><name>nfa</name></expr></argument>, <argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>converttosearch</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>ISERR</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>makesearch</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>nfa</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ISERR</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>compact</name><argument_list>(<argument><expr><name>nfa</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>t</name><operator>-&gt;</operator><name>cnfa</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>freenfa</name><argument_list>(<argument><expr><name>nfa</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * newlacon - allocate a lookaround-constraint subRE
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>						<comment type="block">/* lacon number */</comment>
<name>newlacon</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>vars</name></name> <modifier>*</modifier></type><name>v</name></decl></parameter>,
		 <parameter><decl><type><name><name>struct</name> <name>state</name></name> <modifier>*</modifier></type><name>begin</name></decl></parameter>,
		 <parameter><decl><type><name><name>struct</name> <name>state</name></name> <modifier>*</modifier></type><name>end</name></decl></parameter>,
		 <parameter><decl><type><name>int</name></type> <name>latype</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>n</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>subre</name></name> <modifier>*</modifier></type><name>newlacons</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>subre</name></name> <modifier>*</modifier></type><name>sub</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>v</name><operator>-&gt;</operator><name>nlacons</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>n</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>					<comment type="block">/* skip 0th */</comment>
		<expr_stmt><expr><name>newlacons</name> <operator>=</operator> <operator>(</operator>struct <name>subre</name> <operator>*</operator><operator>)</operator> <call><name>MALLOC</name><argument_list>(<argument><expr><literal type="number">2</literal> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr>struct <name>subre</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name>n</name> <operator>=</operator> <name><name>v</name><operator>-&gt;</operator><name>nlacons</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>newlacons</name> <operator>=</operator> <operator>(</operator>struct <name>subre</name> <operator>*</operator><operator>)</operator> <call><name>REALLOC</name><argument_list>(<argument><expr><name><name>v</name><operator>-&gt;</operator><name>lacons</name></name></expr></argument>,
											 <argument><expr><operator>(</operator><name>n</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr>struct <name>subre</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>newlacons</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ERR</name><argument_list>(<argument><expr><name>REG_ESPACE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><literal type="number">0</literal></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name><name>v</name><operator>-&gt;</operator><name>lacons</name></name> <operator>=</operator> <name>newlacons</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>v</name><operator>-&gt;</operator><name>nlacons</name></name> <operator>=</operator> <name>n</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>sub</name> <operator>=</operator> <operator>&amp;</operator><name><name>v</name><operator>-&gt;</operator><name>lacons</name><index>[<expr><name>n</name></expr>]</index></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>sub</name><operator>-&gt;</operator><name>begin</name></name> <operator>=</operator> <name>begin</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>sub</name><operator>-&gt;</operator><name>end</name></name> <operator>=</operator> <name>end</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>sub</name><operator>-&gt;</operator><name>subno</name></name> <operator>=</operator> <name>latype</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ZAPCNFA</name><argument_list>(<argument><expr><name><name>sub</name><operator>-&gt;</operator><name>cnfa</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>n</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * freelacons - free lookaround-constraint subRE vector
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>freelacons</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>subre</name></name> <modifier>*</modifier></type><name>subs</name></decl></parameter>,
		   <parameter><decl><type><name>int</name></type> <name>n</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name><name>struct</name> <name>subre</name></name> <modifier>*</modifier></type><name>sub</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>n</name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>sub</name> <operator>=</operator> <name>subs</name> <operator>+</operator> <literal type="number">1</literal></expr><operator>,</operator> <expr><name>i</name> <operator>=</operator> <name>n</name> <operator>-</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><name>sub</name><operator>++</operator></expr><operator>,</operator> <expr><name>i</name><operator>--</operator></expr></incr>)</control><block type="pseudo"><block_content>	<comment type="block">/* no 0th */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>NULLCNFA</name><argument_list>(<argument><expr><name><name>sub</name><operator>-&gt;</operator><name>cnfa</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>freecnfa</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>sub</name><operator>-&gt;</operator><name>cnfa</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt></block_content></block></for>
	<expr_stmt><expr><call><name>FREE</name><argument_list>(<argument><expr><name>subs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * rfree - free a whole RE (insides of regfree)
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>rfree</name><parameter_list>(<parameter><decl><type><name>regex_t</name> <modifier>*</modifier></type><name>re</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name><name>struct</name> <name>guts</name></name> <modifier>*</modifier></type><name>g</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>re</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name><name>re</name><operator>-&gt;</operator><name>re_magic</name></name> <operator>!=</operator> <name>REMAGIC</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name><name>re</name><operator>-&gt;</operator><name>re_magic</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>			<comment type="block">/* invalidate RE */</comment>
	<expr_stmt><expr><name>g</name> <operator>=</operator> <operator>(</operator>struct <name>guts</name> <operator>*</operator><operator>)</operator> <name><name>re</name><operator>-&gt;</operator><name>re_guts</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>re</name><operator>-&gt;</operator><name>re_guts</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>re</name><operator>-&gt;</operator><name>re_fns</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>g</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>magic</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>freecm</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>g</name><operator>-&gt;</operator><name>cmap</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>g</name><operator>-&gt;</operator><name>tree</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>freesubre</name><argument_list>(<argument><expr><operator>(</operator>struct <name>vars</name> <operator>*</operator><operator>)</operator> <name>NULL</name></expr></argument>, <argument><expr><name><name>g</name><operator>-&gt;</operator><name>tree</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>g</name><operator>-&gt;</operator><name>lacons</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>freelacons</name><argument_list>(<argument><expr><name><name>g</name><operator>-&gt;</operator><name>lacons</name></name></expr></argument>, <argument><expr><name><name>g</name><operator>-&gt;</operator><name>nlacons</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>NULLCNFA</name><argument_list>(<argument><expr><name><name>g</name><operator>-&gt;</operator><name>search</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>freecnfa</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>g</name><operator>-&gt;</operator><name>search</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>FREE</name><argument_list>(<argument><expr><name>g</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * rcancelrequested - check for external request to cancel regex operation
 *
 * Return nonzero to fail the operation with error code REG_CANCEL,
 * zero to keep going
 *
 * The current implementation is Postgres-specific.  If we ever get around
 * to splitting the regex code out as a standalone library, there will need
 * to be some API to let applications define a callback function for this.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>rcancelrequested</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><name>InterruptPending</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>QueryCancelPending</name> <operator>||</operator> <name>ProcDiePending</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * rstacktoodeep - check for stack getting dangerously deep
 *
 * Return nonzero to fail the operation with error code REG_ETOOBIG,
 * zero to keep going
 *
 * The current implementation is Postgres-specific.  If we ever get around
 * to splitting the regex code out as a standalone library, there will need
 * to be some API to let applications define a callback function for this.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>rstacktoodeep</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>stack_is_too_deep</name><argument_list>()</argument_list></call></expr>;</return>
</block_content>}</block></function>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>REG_DEBUG</name></cpp:ifdef>

<comment type="block">/*
 * dump - dump an RE in human-readable form
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>dump</name><parameter_list>(<parameter><decl><type><name>regex_t</name> <modifier>*</modifier></type><name>re</name></decl></parameter>,
	 <parameter><decl><type><name>FILE</name> <modifier>*</modifier></type><name>f</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name><name>struct</name> <name>guts</name></name> <modifier>*</modifier></type><name>g</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>re</name><operator>-&gt;</operator><name>re_magic</name></name> <operator>!=</operator> <name>REMAGIC</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><literal type="string">"bad magic number (0x%x not 0x%x)\n"</literal></expr></argument>, <argument><expr><name><name>re</name><operator>-&gt;</operator><name>re_magic</name></name></expr></argument>,
				<argument><expr><name>REMAGIC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>re</name><operator>-&gt;</operator><name>re_guts</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><literal type="string">"NULL guts!!!\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name>g</name> <operator>=</operator> <operator>(</operator>struct <name>guts</name> <operator>*</operator><operator>)</operator> <name><name>re</name><operator>-&gt;</operator><name>re_guts</name></name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>g</name><operator>-&gt;</operator><name>magic</name></name> <operator>!=</operator> <name>GUTSMAGIC</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><literal type="string">"bad guts magic number (0x%x not 0x%x)\n"</literal></expr></argument>, <argument><expr><name><name>g</name><operator>-&gt;</operator><name>magic</name></name></expr></argument>,
				<argument><expr><name>GUTSMAGIC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><literal type="string">"\n\n\n========= DUMP ==========\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><literal type="string">"nsub %d, info 0%lo, csize %d, ntree %d\n"</literal></expr></argument>,
			<argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name><name>re</name><operator>-&gt;</operator><name>re_nsub</name></name></expr></argument>, <argument><expr><name><name>re</name><operator>-&gt;</operator><name>re_info</name></name></expr></argument>, <argument><expr><name><name>re</name><operator>-&gt;</operator><name>re_csize</name></name></expr></argument>, <argument><expr><name><name>g</name><operator>-&gt;</operator><name>ntree</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>dumpcolors</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>g</name><operator>-&gt;</operator><name>cmap</name></name></expr></argument>, <argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>NULLCNFA</name><argument_list>(<argument><expr><name><name>g</name><operator>-&gt;</operator><name>search</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><literal type="string">"\nsearch:\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>dumpcnfa</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>g</name><operator>-&gt;</operator><name>search</name></name></expr></argument>, <argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>g</name><operator>-&gt;</operator><name>nlacons</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name><name>struct</name> <name>subre</name></name> <modifier>*</modifier></type><name>lasub</name> <init>= <expr><operator>&amp;</operator><name><name>g</name><operator>-&gt;</operator><name>lacons</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>latype</name></decl>;</decl_stmt>

		<switch>switch <condition>(<expr><name><name>lasub</name><operator>-&gt;</operator><name>subno</name></name></expr>)</condition>
		<block>{<block_content>
			<case>case <expr><name>LATYPE_AHEAD_POS</name></expr>:</case>
				<expr_stmt><expr><name>latype</name> <operator>=</operator> <literal type="string">"positive lookahead"</literal></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>LATYPE_AHEAD_NEG</name></expr>:</case>
				<expr_stmt><expr><name>latype</name> <operator>=</operator> <literal type="string">"negative lookahead"</literal></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>LATYPE_BEHIND_POS</name></expr>:</case>
				<expr_stmt><expr><name>latype</name> <operator>=</operator> <literal type="string">"positive lookbehind"</literal></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>LATYPE_BEHIND_NEG</name></expr>:</case>
				<expr_stmt><expr><name>latype</name> <operator>=</operator> <literal type="string">"negative lookbehind"</literal></expr>;</expr_stmt>
				<break>break;</break>
			<default>default:</default>
				<expr_stmt><expr><name>latype</name> <operator>=</operator> <literal type="string">"???"</literal></expr>;</expr_stmt>
				<break>break;</break>
		</block_content>}</block></switch>
		<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><literal type="string">"\nla%d (%s):\n"</literal></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>latype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>dumpcnfa</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>lasub</name><operator>-&gt;</operator><name>cnfa</name></name></expr></argument>, <argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>
	<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>dumpst</name><argument_list>(<argument><expr><name><name>g</name><operator>-&gt;</operator><name>tree</name></name></expr></argument>, <argument><expr><name>f</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * dumpst - dump a subRE tree
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>dumpst</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>subre</name></name> <modifier>*</modifier></type><name>t</name></decl></parameter>,
	   <parameter><decl><type><name>FILE</name> <modifier>*</modifier></type><name>f</name></decl></parameter>,
	   <parameter><decl><type><name>int</name></type> <name>nfapresent</name></decl></parameter>)</parameter_list>			<comment type="block">/* is the original NFA still around? */</comment>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>t</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><literal type="string">"null tree\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>stdump</name><argument_list>(<argument><expr><name>t</name></expr></argument>, <argument><expr><name>f</name></expr></argument>, <argument><expr><name>nfapresent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	<expr_stmt><expr><call><name>fflush</name><argument_list>(<argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * stdump - recursive guts of dumpst
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>stdump</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>subre</name></name> <modifier>*</modifier></type><name>t</name></decl></parameter>,
	   <parameter><decl><type><name>FILE</name> <modifier>*</modifier></type><name>f</name></decl></parameter>,
	   <parameter><decl><type><name>int</name></type> <name>nfapresent</name></decl></parameter>)</parameter_list>			<comment type="block">/* is the original NFA still around? */</comment>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>idbuf</name><index>[<expr><literal type="number">50</literal></expr>]</index></name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><literal type="string">"%s. `%c'"</literal></expr></argument>, <argument><expr><call><name>stid</name><argument_list>(<argument><expr><name>t</name></expr></argument>, <argument><expr><name>idbuf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>idbuf</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>t</name><operator>-&gt;</operator><name>op</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>t</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>LONGER</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><literal type="string">" longest"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>t</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>SHORTER</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><literal type="string">" shortest"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>t</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>MIXED</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><literal type="string">" hasmixed"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>t</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>CAP</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><literal type="string">" hascapture"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>t</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>BACKR</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><literal type="string">" hasbackref"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name><name>t</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>INUSE</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><literal type="string">" UNUSED"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>t</name><operator>-&gt;</operator><name>subno</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><literal type="string">" (#%d)"</literal></expr></argument>, <argument><expr><name><name>t</name><operator>-&gt;</operator><name>subno</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>t</name><operator>-&gt;</operator><name>min</name></name> <operator>!=</operator> <literal type="number">1</literal> <operator>||</operator> <name><name>t</name><operator>-&gt;</operator><name>max</name></name> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><literal type="string">" {%d,"</literal></expr></argument>, <argument><expr><name><name>t</name><operator>-&gt;</operator><name>min</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>t</name><operator>-&gt;</operator><name>max</name></name> <operator>!=</operator> <name>DUPINF</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><literal type="string">"%d"</literal></expr></argument>, <argument><expr><name><name>t</name><operator>-&gt;</operator><name>max</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><literal type="string">"}"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>nfapresent</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><literal type="string">" %ld-%ld"</literal></expr></argument>, <argument><expr><operator>(</operator><name>long</name><operator>)</operator> <name><name>t</name><operator>-&gt;</operator><name>begin</name><operator>-&gt;</operator><name>no</name></name></expr></argument>, <argument><expr><operator>(</operator><name>long</name><operator>)</operator> <name><name>t</name><operator>-&gt;</operator><name>end</name><operator>-&gt;</operator><name>no</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>t</name><operator>-&gt;</operator><name>left</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><literal type="string">" L:%s"</literal></expr></argument>, <argument><expr><call><name>stid</name><argument_list>(<argument><expr><name><name>t</name><operator>-&gt;</operator><name>left</name></name></expr></argument>, <argument><expr><name>idbuf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>idbuf</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>t</name><operator>-&gt;</operator><name>right</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><literal type="string">" R:%s"</literal></expr></argument>, <argument><expr><call><name>stid</name><argument_list>(<argument><expr><name><name>t</name><operator>-&gt;</operator><name>right</name></name></expr></argument>, <argument><expr><name>idbuf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>idbuf</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>NULLCNFA</name><argument_list>(<argument><expr><name><name>t</name><operator>-&gt;</operator><name>cnfa</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>dumpcnfa</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>t</name><operator>-&gt;</operator><name>cnfa</name></name></expr></argument>, <argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>t</name><operator>-&gt;</operator><name>left</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>stdump</name><argument_list>(<argument><expr><name><name>t</name><operator>-&gt;</operator><name>left</name></name></expr></argument>, <argument><expr><name>f</name></expr></argument>, <argument><expr><name>nfapresent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>t</name><operator>-&gt;</operator><name>right</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>stdump</name><argument_list>(<argument><expr><name><name>t</name><operator>-&gt;</operator><name>right</name></name></expr></argument>, <argument><expr><name>f</name></expr></argument>, <argument><expr><name>nfapresent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * stid - identify a subtree node for dumping
 */</comment>
<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>				<comment type="block">/* points to buf or constant string */</comment>
<name>stid</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>subre</name></name> <modifier>*</modifier></type><name>t</name></decl></parameter>,
	 <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>,
	 <parameter><decl><type><name>size_t</name></type> <name>bufsize</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* big enough for hex int or decimal t-&gt;id? */</comment>
	<if_stmt><if>if <condition>(<expr><name>bufsize</name> <operator>&lt;</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>void</name> <operator>*</operator></expr></argument>)</argument_list></sizeof> <operator>*</operator> <literal type="number">2</literal> <operator>+</operator> <literal type="number">3</literal> <operator>||</operator> <name>bufsize</name> <operator>&lt;</operator> <sizeof>sizeof<argument_list>(<argument><expr><name><name>t</name><operator>-&gt;</operator><name>id</name></name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <literal type="number">3</literal> <operator>+</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><literal type="string">"unable"</literal></expr>;</return></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>t</name><operator>-&gt;</operator><name>id</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"%d"</literal></expr></argument>, <argument><expr><name><name>t</name><operator>-&gt;</operator><name>id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"%p"</literal></expr></argument>, <argument><expr><name>t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	<return>return <expr><name>buf</name></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>							<comment type="block">/* REG_DEBUG */</comment>


<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"regc_lex.c"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"regc_color.c"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"regc_nfa.c"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"regc_cvec.c"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"regc_pg_locale.c"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"regc_locale.c"</cpp:file></cpp:include>
</unit>
