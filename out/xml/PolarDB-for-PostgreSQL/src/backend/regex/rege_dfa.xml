<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/PolarDB-for-PostgreSQL/src/backend/regex/rege_dfa.c"><comment type="block">/*
 * DFA routines
 * This file is #included by regexec.c.
 *
 * Copyright (c) 1998, 1999 Henry Spencer.  All rights reserved.
 *
 * Development of this software was funded, in part, by Cray Research Inc.,
 * UUNET Communications Services Inc., Sun Microsystems Inc., and Scriptics
 * Corporation, none of whom are responsible for the results.  The author
 * thanks all of them.
 *
 * Redistribution and use in source and binary forms -- with or without
 * modification -- are permitted for any purpose, provided that
 * redistributions in source form retain this entire copyright notice and
 * indicate the origin and nature of any modifications.
 *
 * I'd appreciate being given credit for this package in the documentation
 * of software which uses it, but that is not a requirement.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES,
 * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
 * AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL
 * HENRY SPENCER BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
 * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
 * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
 * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * src/backend/regex/rege_dfa.c
 *
 */</comment>

<comment type="block">/*
 * longest - longest-preferred matching engine
 *
 * On success, returns match endpoint address.  Returns NULL on no match.
 * Internal errors also return NULL, with v-&gt;err set.
 */</comment>
<function><type><specifier>static</specifier> <name>chr</name> <modifier>*</modifier></type>
<name>longest</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>vars</name></name> <modifier>*</modifier></type><name>v</name></decl></parameter>,
		<parameter><decl><type><name><name>struct</name> <name>dfa</name></name> <modifier>*</modifier></type><name>d</name></decl></parameter>,
		<parameter><decl><type><name>chr</name> <modifier>*</modifier></type><name>start</name></decl></parameter>,				<comment type="block">/* where the match should start */</comment>
		<parameter><decl><type><name>chr</name> <modifier>*</modifier></type><name>stop</name></decl></parameter>,				<comment type="block">/* match must end at or before here */</comment>
		<parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>hitstopp</name></decl></parameter>)</parameter_list>			<comment type="block">/* record whether hit v-&gt;stop, if non-NULL */</comment>
<block>{<block_content>
	<decl_stmt><decl><type><name>chr</name>		   <modifier>*</modifier></type><name>cp</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>chr</name>		   <modifier>*</modifier></type><name>realstop</name> <init>= <expr><ternary><condition><expr><operator>(</operator><name>stop</name> <operator>==</operator> <name><name>v</name><operator>-&gt;</operator><name>stop</name></name><operator>)</operator></expr> ?</condition><then> <expr><name>stop</name></expr> </then><else>: <expr><name>stop</name> <operator>+</operator> <literal type="number">1</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>color</name></type>		<name>co</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>sset</name></name> <modifier>*</modifier></type><name>css</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>sset</name></name> <modifier>*</modifier></type><name>ss</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>chr</name>		   <modifier>*</modifier></type><name>post</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>colormap</name></name> <modifier>*</modifier></type><name>cm</name> <init>= <expr><name><name>d</name><operator>-&gt;</operator><name>cm</name></name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* prevent "uninitialized variable" warnings */</comment>
	<if_stmt><if>if <condition>(<expr><name>hitstopp</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><operator>*</operator><name>hitstopp</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* initialize */</comment>
	<expr_stmt><expr><name>css</name> <operator>=</operator> <call><name>initialize</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>d</name></expr></argument>, <argument><expr><name>start</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>css</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>cp</name> <operator>=</operator> <name>start</name></expr>;</expr_stmt>

	<comment type="block">/* startup */</comment>
	<expr_stmt><expr><call><name>FDEBUG</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"+++ startup +++\n"</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>cp</name> <operator>==</operator> <name><name>v</name><operator>-&gt;</operator><name>start</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>co</name> <operator>=</operator> <name><name>d</name><operator>-&gt;</operator><name>cnfa</name><operator>-&gt;</operator><name>bos</name><index>[<expr><ternary><condition><expr><operator>(</operator><name><name>v</name><operator>-&gt;</operator><name>eflags</name></name> <operator>&amp;</operator> <name>REG_NOTBOL</name><operator>)</operator></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><literal type="number">1</literal></expr></else></ternary></expr>]</index></name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>FDEBUG</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"color %ld\n"</literal><operator>,</operator> <operator>(</operator><name>long</name><operator>)</operator> <name>co</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name>co</name> <operator>=</operator> <call><name>GETCOLOR</name><argument_list>(<argument><expr><name>cm</name></expr></argument>, <argument><expr><operator>*</operator><operator>(</operator><name>cp</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>FDEBUG</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"char %c, color %ld\n"</literal><operator>,</operator> <operator>(</operator><name>char</name><operator>)</operator> <operator>*</operator><operator>(</operator><name>cp</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator><operator>,</operator> <operator>(</operator><name>long</name><operator>)</operator> <name>co</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
	<expr_stmt><expr><name>css</name> <operator>=</operator> <call><name>miss</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>d</name></expr></argument>, <argument><expr><name>css</name></expr></argument>, <argument><expr><name>co</name></expr></argument>, <argument><expr><name>cp</name></expr></argument>, <argument><expr><name>start</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>css</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
	<expr_stmt><expr><name><name>css</name><operator>-&gt;</operator><name>lastseen</name></name> <operator>=</operator> <name>cp</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * This is the main text-scanning loop.  It seems worth having two copies
	 * to avoid the overhead of REG_FTRACE tests here, even in REG_DEBUG
	 * builds, when you're not actively tracing.
	 */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>REG_DEBUG</name></cpp:ifdef>
	<if_stmt><if>if <condition>(<expr><name><name>v</name><operator>-&gt;</operator><name>eflags</name></name> <operator>&amp;</operator> <name>REG_FTRACE</name></expr>)</condition>
	<block>{<block_content>
		<while>while <condition>(<expr><name>cp</name> <operator>&lt;</operator> <name>realstop</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>FDEBUG</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"+++ at c%d +++\n"</literal><operator>,</operator> <operator>(</operator><name>int</name><operator>)</operator> <operator>(</operator><name>css</name> <operator>-</operator> <name><name>d</name><operator>-&gt;</operator><name>ssets</name></name><operator>)</operator><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>co</name> <operator>=</operator> <call><name>GETCOLOR</name><argument_list>(<argument><expr><name>cm</name></expr></argument>, <argument><expr><operator>*</operator><name>cp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>FDEBUG</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"char %c, color %ld\n"</literal><operator>,</operator> <operator>(</operator><name>char</name><operator>)</operator> <operator>*</operator><name>cp</name><operator>,</operator> <operator>(</operator><name>long</name><operator>)</operator> <name>co</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>ss</name> <operator>=</operator> <name><name>css</name><operator>-&gt;</operator><name>outs</name><index>[<expr><name>co</name></expr>]</index></name></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>ss</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>ss</name> <operator>=</operator> <call><name>miss</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>d</name></expr></argument>, <argument><expr><name>css</name></expr></argument>, <argument><expr><name>co</name></expr></argument>, <argument><expr><name>cp</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>start</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name>ss</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
					<break>break;</break></block_content></block></if></if_stmt>		<comment type="block">/* NOTE BREAK OUT */</comment>
			</block_content>}</block></if></if_stmt>
			<expr_stmt><expr><name>cp</name><operator>++</operator></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>ss</name><operator>-&gt;</operator><name>lastseen</name></name> <operator>=</operator> <name>cp</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>css</name> <operator>=</operator> <name>ss</name></expr>;</expr_stmt>
		</block_content>}</block></while>
	</block_content>}</block></if>
	<else>else
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<block>{<block_content>
		<while>while <condition>(<expr><name>cp</name> <operator>&lt;</operator> <name>realstop</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>co</name> <operator>=</operator> <call><name>GETCOLOR</name><argument_list>(<argument><expr><name>cm</name></expr></argument>, <argument><expr><operator>*</operator><name>cp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>ss</name> <operator>=</operator> <name><name>css</name><operator>-&gt;</operator><name>outs</name><index>[<expr><name>co</name></expr>]</index></name></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>ss</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>ss</name> <operator>=</operator> <call><name>miss</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>d</name></expr></argument>, <argument><expr><name>css</name></expr></argument>, <argument><expr><name>co</name></expr></argument>, <argument><expr><name>cp</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>start</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name>ss</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
					<break>break;</break></block_content></block></if></if_stmt>		<comment type="block">/* NOTE BREAK OUT */</comment>
			</block_content>}</block></if></if_stmt>
			<expr_stmt><expr><name>cp</name><operator>++</operator></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>ss</name><operator>-&gt;</operator><name>lastseen</name></name> <operator>=</operator> <name>cp</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>css</name> <operator>=</operator> <name>ss</name></expr>;</expr_stmt>
		</block_content>}</block></while>
	</block_content>}</block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>ISERR</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* shutdown */</comment>
	<expr_stmt><expr><call><name>FDEBUG</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"+++ shutdown at c%d +++\n"</literal><operator>,</operator> <operator>(</operator><name>int</name><operator>)</operator> <operator>(</operator><name>css</name> <operator>-</operator> <name><name>d</name><operator>-&gt;</operator><name>ssets</name></name><operator>)</operator><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>cp</name> <operator>==</operator> <name><name>v</name><operator>-&gt;</operator><name>stop</name></name> <operator>&amp;&amp;</operator> <name>stop</name> <operator>==</operator> <name><name>v</name><operator>-&gt;</operator><name>stop</name></name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>hitstopp</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><operator>*</operator><name>hitstopp</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>co</name> <operator>=</operator> <name><name>d</name><operator>-&gt;</operator><name>cnfa</name><operator>-&gt;</operator><name>eos</name><index>[<expr><ternary><condition><expr><operator>(</operator><name><name>v</name><operator>-&gt;</operator><name>eflags</name></name> <operator>&amp;</operator> <name>REG_NOTEOL</name><operator>)</operator></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><literal type="number">1</literal></expr></else></ternary></expr>]</index></name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>FDEBUG</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"color %ld\n"</literal><operator>,</operator> <operator>(</operator><name>long</name><operator>)</operator> <name>co</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>ss</name> <operator>=</operator> <call><name>miss</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>d</name></expr></argument>, <argument><expr><name>css</name></expr></argument>, <argument><expr><name>co</name></expr></argument>, <argument><expr><name>cp</name></expr></argument>, <argument><expr><name>start</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>ISERR</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
		<comment type="block">/* special case:  match ended at eol? */</comment>
		<if_stmt><if>if <condition>(<expr><name>ss</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>ss</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>POSTSTATE</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>cp</name></expr>;</return></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><name>ss</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>ss</name><operator>-&gt;</operator><name>lastseen</name></name> <operator>=</operator> <name>cp</name></expr>;</expr_stmt></block_content></block></if></if_stmt>	<comment type="block">/* to be tidy */</comment>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* find last match, if any */</comment>
	<expr_stmt><expr><name>post</name> <operator>=</operator> <name><name>d</name><operator>-&gt;</operator><name>lastpost</name></name></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>ss</name> <operator>=</operator> <name><name>d</name><operator>-&gt;</operator><name>ssets</name></name></expr><operator>,</operator> <expr><name>i</name> <operator>=</operator> <name><name>d</name><operator>-&gt;</operator><name>nssused</name></name></expr>;</init> <condition><expr><name>i</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><name>ss</name><operator>++</operator></expr><operator>,</operator> <expr><name>i</name><operator>--</operator></expr></incr>)</control><block type="pseudo"><block_content>
		<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>ss</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>POSTSTATE</name><operator>)</operator> <operator>&amp;&amp;</operator> <name>post</name> <operator>!=</operator> <name><name>ss</name><operator>-&gt;</operator><name>lastseen</name></name> <operator>&amp;&amp;</operator>
			<operator>(</operator><name>post</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name>post</name> <operator>&lt;</operator> <name><name>ss</name><operator>-&gt;</operator><name>lastseen</name></name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>post</name> <operator>=</operator> <name><name>ss</name><operator>-&gt;</operator><name>lastseen</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt></block_content></block></for>
	<if_stmt><if>if <condition>(<expr><name>post</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>			<comment type="block">/* found one */</comment>
		<return>return <expr><name>post</name> <operator>-</operator> <literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

	<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * shortest - shortest-preferred matching engine
 *
 * On success, returns match endpoint address.  Returns NULL on no match.
 * Internal errors also return NULL, with v-&gt;err set.
 */</comment>
<function><type><specifier>static</specifier> <name>chr</name> <modifier>*</modifier></type>
<name>shortest</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>vars</name></name> <modifier>*</modifier></type><name>v</name></decl></parameter>,
		 <parameter><decl><type><name><name>struct</name> <name>dfa</name></name> <modifier>*</modifier></type><name>d</name></decl></parameter>,
		 <parameter><decl><type><name>chr</name> <modifier>*</modifier></type><name>start</name></decl></parameter>,			<comment type="block">/* where the match should start */</comment>
		 <parameter><decl><type><name>chr</name> <modifier>*</modifier></type><name>min</name></decl></parameter>,				<comment type="block">/* match must end at or after here */</comment>
		 <parameter><decl><type><name>chr</name> <modifier>*</modifier></type><name>max</name></decl></parameter>,				<comment type="block">/* match must end at or before here */</comment>
		 <parameter><decl><type><name>chr</name> <modifier>*</modifier><modifier>*</modifier></type><name>coldp</name></decl></parameter>,			<comment type="block">/* store coldstart pointer here, if non-NULL */</comment>
		 <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>hitstopp</name></decl></parameter>)</parameter_list>			<comment type="block">/* record whether hit v-&gt;stop, if non-NULL */</comment>
<block>{<block_content>
	<decl_stmt><decl><type><name>chr</name>		   <modifier>*</modifier></type><name>cp</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>chr</name>		   <modifier>*</modifier></type><name>realmin</name> <init>= <expr><ternary><condition><expr><operator>(</operator><name>min</name> <operator>==</operator> <name><name>v</name><operator>-&gt;</operator><name>stop</name></name><operator>)</operator></expr> ?</condition><then> <expr><name>min</name></expr> </then><else>: <expr><name>min</name> <operator>+</operator> <literal type="number">1</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>chr</name>		   <modifier>*</modifier></type><name>realmax</name> <init>= <expr><ternary><condition><expr><operator>(</operator><name>max</name> <operator>==</operator> <name><name>v</name><operator>-&gt;</operator><name>stop</name></name><operator>)</operator></expr> ?</condition><then> <expr><name>max</name></expr> </then><else>: <expr><name>max</name> <operator>+</operator> <literal type="number">1</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>color</name></type>		<name>co</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>sset</name></name> <modifier>*</modifier></type><name>css</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>sset</name></name> <modifier>*</modifier></type><name>ss</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>colormap</name></name> <modifier>*</modifier></type><name>cm</name> <init>= <expr><name><name>d</name><operator>-&gt;</operator><name>cm</name></name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* prevent "uninitialized variable" warnings */</comment>
	<if_stmt><if>if <condition>(<expr><name>coldp</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><operator>*</operator><name>coldp</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>hitstopp</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><operator>*</operator><name>hitstopp</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* initialize */</comment>
	<expr_stmt><expr><name>css</name> <operator>=</operator> <call><name>initialize</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>d</name></expr></argument>, <argument><expr><name>start</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>css</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>cp</name> <operator>=</operator> <name>start</name></expr>;</expr_stmt>

	<comment type="block">/* startup */</comment>
	<expr_stmt><expr><call><name>FDEBUG</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"--- startup ---\n"</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>cp</name> <operator>==</operator> <name><name>v</name><operator>-&gt;</operator><name>start</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>co</name> <operator>=</operator> <name><name>d</name><operator>-&gt;</operator><name>cnfa</name><operator>-&gt;</operator><name>bos</name><index>[<expr><ternary><condition><expr><operator>(</operator><name><name>v</name><operator>-&gt;</operator><name>eflags</name></name> <operator>&amp;</operator> <name>REG_NOTBOL</name><operator>)</operator></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><literal type="number">1</literal></expr></else></ternary></expr>]</index></name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>FDEBUG</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"color %ld\n"</literal><operator>,</operator> <operator>(</operator><name>long</name><operator>)</operator> <name>co</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name>co</name> <operator>=</operator> <call><name>GETCOLOR</name><argument_list>(<argument><expr><name>cm</name></expr></argument>, <argument><expr><operator>*</operator><operator>(</operator><name>cp</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>FDEBUG</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"char %c, color %ld\n"</literal><operator>,</operator> <operator>(</operator><name>char</name><operator>)</operator> <operator>*</operator><operator>(</operator><name>cp</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator><operator>,</operator> <operator>(</operator><name>long</name><operator>)</operator> <name>co</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
	<expr_stmt><expr><name>css</name> <operator>=</operator> <call><name>miss</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>d</name></expr></argument>, <argument><expr><name>css</name></expr></argument>, <argument><expr><name>co</name></expr></argument>, <argument><expr><name>cp</name></expr></argument>, <argument><expr><name>start</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>css</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
	<expr_stmt><expr><name><name>css</name><operator>-&gt;</operator><name>lastseen</name></name> <operator>=</operator> <name>cp</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>ss</name> <operator>=</operator> <name>css</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * This is the main text-scanning loop.  It seems worth having two copies
	 * to avoid the overhead of REG_FTRACE tests here, even in REG_DEBUG
	 * builds, when you're not actively tracing.
	 */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>REG_DEBUG</name></cpp:ifdef>
	<if_stmt><if>if <condition>(<expr><name><name>v</name><operator>-&gt;</operator><name>eflags</name></name> <operator>&amp;</operator> <name>REG_FTRACE</name></expr>)</condition>
	<block>{<block_content>
		<while>while <condition>(<expr><name>cp</name> <operator>&lt;</operator> <name>realmax</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>FDEBUG</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"--- at c%d ---\n"</literal><operator>,</operator> <operator>(</operator><name>int</name><operator>)</operator> <operator>(</operator><name>css</name> <operator>-</operator> <name><name>d</name><operator>-&gt;</operator><name>ssets</name></name><operator>)</operator><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>co</name> <operator>=</operator> <call><name>GETCOLOR</name><argument_list>(<argument><expr><name>cm</name></expr></argument>, <argument><expr><operator>*</operator><name>cp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>FDEBUG</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"char %c, color %ld\n"</literal><operator>,</operator> <operator>(</operator><name>char</name><operator>)</operator> <operator>*</operator><name>cp</name><operator>,</operator> <operator>(</operator><name>long</name><operator>)</operator> <name>co</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>ss</name> <operator>=</operator> <name><name>css</name><operator>-&gt;</operator><name>outs</name><index>[<expr><name>co</name></expr>]</index></name></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>ss</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>ss</name> <operator>=</operator> <call><name>miss</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>d</name></expr></argument>, <argument><expr><name>css</name></expr></argument>, <argument><expr><name>co</name></expr></argument>, <argument><expr><name>cp</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>start</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name>ss</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
					<break>break;</break></block_content></block></if></if_stmt>		<comment type="block">/* NOTE BREAK OUT */</comment>
			</block_content>}</block></if></if_stmt>
			<expr_stmt><expr><name>cp</name><operator>++</operator></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>ss</name><operator>-&gt;</operator><name>lastseen</name></name> <operator>=</operator> <name>cp</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>css</name> <operator>=</operator> <name>ss</name></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>ss</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>POSTSTATE</name><operator>)</operator> <operator>&amp;&amp;</operator> <name>cp</name> <operator>&gt;=</operator> <name>realmin</name></expr>)</condition><block type="pseudo"><block_content>
				<break>break;</break></block_content></block></if></if_stmt>			<comment type="block">/* NOTE BREAK OUT */</comment>
		</block_content>}</block></while>
	</block_content>}</block></if>
	<else>else
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<block>{<block_content>
		<while>while <condition>(<expr><name>cp</name> <operator>&lt;</operator> <name>realmax</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>co</name> <operator>=</operator> <call><name>GETCOLOR</name><argument_list>(<argument><expr><name>cm</name></expr></argument>, <argument><expr><operator>*</operator><name>cp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>ss</name> <operator>=</operator> <name><name>css</name><operator>-&gt;</operator><name>outs</name><index>[<expr><name>co</name></expr>]</index></name></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>ss</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>ss</name> <operator>=</operator> <call><name>miss</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>d</name></expr></argument>, <argument><expr><name>css</name></expr></argument>, <argument><expr><name>co</name></expr></argument>, <argument><expr><name>cp</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>start</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name>ss</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
					<break>break;</break></block_content></block></if></if_stmt>		<comment type="block">/* NOTE BREAK OUT */</comment>
			</block_content>}</block></if></if_stmt>
			<expr_stmt><expr><name>cp</name><operator>++</operator></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>ss</name><operator>-&gt;</operator><name>lastseen</name></name> <operator>=</operator> <name>cp</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>css</name> <operator>=</operator> <name>ss</name></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>ss</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>POSTSTATE</name><operator>)</operator> <operator>&amp;&amp;</operator> <name>cp</name> <operator>&gt;=</operator> <name>realmin</name></expr>)</condition><block type="pseudo"><block_content>
				<break>break;</break></block_content></block></if></if_stmt>			<comment type="block">/* NOTE BREAK OUT */</comment>
		</block_content>}</block></while>
	</block_content>}</block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>ss</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>coldp</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>			<comment type="block">/* report last no-progress state set, if any */</comment>
		<expr_stmt><expr><operator>*</operator><name>coldp</name> <operator>=</operator> <call><name>lastcold</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>d</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>ss</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>POSTSTATE</name><operator>)</operator> <operator>&amp;&amp;</operator> <name>cp</name> <operator>&gt;</operator> <name>min</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>cp</name> <operator>&gt;=</operator> <name>realmin</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>cp</name><operator>--</operator></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>cp</name> <operator>==</operator> <name><name>v</name><operator>-&gt;</operator><name>stop</name></name> <operator>&amp;&amp;</operator> <name>max</name> <operator>==</operator> <name><name>v</name><operator>-&gt;</operator><name>stop</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>co</name> <operator>=</operator> <name><name>d</name><operator>-&gt;</operator><name>cnfa</name><operator>-&gt;</operator><name>eos</name><index>[<expr><ternary><condition><expr><operator>(</operator><name><name>v</name><operator>-&gt;</operator><name>eflags</name></name> <operator>&amp;</operator> <name>REG_NOTEOL</name><operator>)</operator></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><literal type="number">1</literal></expr></else></ternary></expr>]</index></name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>FDEBUG</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"color %ld\n"</literal><operator>,</operator> <operator>(</operator><name>long</name><operator>)</operator> <name>co</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>ss</name> <operator>=</operator> <call><name>miss</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>d</name></expr></argument>, <argument><expr><name>css</name></expr></argument>, <argument><expr><name>co</name></expr></argument>, <argument><expr><name>cp</name></expr></argument>, <argument><expr><name>start</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* match might have ended at eol */</comment>
		<if_stmt><if>if <condition>(<expr><operator>(</operator><name>ss</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <operator>!</operator><operator>(</operator><name><name>ss</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>POSTSTATE</name><operator>)</operator><operator>)</operator> <operator>&amp;&amp;</operator> <name>hitstopp</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><operator>*</operator><name>hitstopp</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>ss</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <operator>!</operator><operator>(</operator><name><name>ss</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>POSTSTATE</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

	<return>return <expr><name>cp</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * matchuntil - incremental matching engine
 *
 * This is meant for use with a search-style NFA (that is, the pattern is
 * known to act as though it had a leading .*).  We determine whether a
 * match exists starting at v-&gt;start and ending at probe.  Multiple calls
 * require only O(N) time not O(N^2) so long as the probe values are
 * nondecreasing.  *lastcss and *lastcp must be initialized to NULL before
 * starting a series of calls.
 *
 * Returns 1 if a match exists, 0 if not.
 * Internal errors also return 0, with v-&gt;err set.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>matchuntil</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>vars</name></name> <modifier>*</modifier></type><name>v</name></decl></parameter>,
		   <parameter><decl><type><name><name>struct</name> <name>dfa</name></name> <modifier>*</modifier></type><name>d</name></decl></parameter>,
		   <parameter><decl><type><name>chr</name> <modifier>*</modifier></type><name>probe</name></decl></parameter>,			<comment type="block">/* we want to know if a match ends here */</comment>
		   <parameter><decl><type><name><name>struct</name> <name>sset</name></name> <modifier>*</modifier><modifier>*</modifier></type><name>lastcss</name></decl></parameter>,	<comment type="block">/* state storage across calls */</comment>
		   <parameter><decl><type><name>chr</name> <modifier>*</modifier><modifier>*</modifier></type><name>lastcp</name></decl></parameter>)</parameter_list>		<comment type="block">/* state storage across calls */</comment>
<block>{<block_content>
	<decl_stmt><decl><type><name>chr</name>		   <modifier>*</modifier></type><name>cp</name> <init>= <expr><operator>*</operator><name>lastcp</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>color</name></type>		<name>co</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>sset</name></name> <modifier>*</modifier></type><name>css</name> <init>= <expr><operator>*</operator><name>lastcss</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>sset</name></name> <modifier>*</modifier></type><name>ss</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>colormap</name></name> <modifier>*</modifier></type><name>cm</name> <init>= <expr><name><name>d</name><operator>-&gt;</operator><name>cm</name></name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* initialize and startup, or restart, if necessary */</comment>
	<if_stmt><if>if <condition>(<expr><name>cp</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name>cp</name> <operator>&gt;</operator> <name>probe</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>cp</name> <operator>=</operator> <name><name>v</name><operator>-&gt;</operator><name>start</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>css</name> <operator>=</operator> <call><name>initialize</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>d</name></expr></argument>, <argument><expr><name>cp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>css</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>FDEBUG</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"&gt;&gt;&gt; startup &gt;&gt;&gt;\n"</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>co</name> <operator>=</operator> <name><name>d</name><operator>-&gt;</operator><name>cnfa</name><operator>-&gt;</operator><name>bos</name><index>[<expr><ternary><condition><expr><operator>(</operator><name><name>v</name><operator>-&gt;</operator><name>eflags</name></name> <operator>&amp;</operator> <name>REG_NOTBOL</name><operator>)</operator></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><literal type="number">1</literal></expr></else></ternary></expr>]</index></name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>FDEBUG</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"color %ld\n"</literal><operator>,</operator> <operator>(</operator><name>long</name><operator>)</operator> <name>co</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>css</name> <operator>=</operator> <call><name>miss</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>d</name></expr></argument>, <argument><expr><name>css</name></expr></argument>, <argument><expr><name>co</name></expr></argument>, <argument><expr><name>cp</name></expr></argument>, <argument><expr><name><name>v</name><operator>-&gt;</operator><name>start</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>css</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
		<expr_stmt><expr><name><name>css</name><operator>-&gt;</operator><name>lastseen</name></name> <operator>=</operator> <name>cp</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>css</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* we previously found that no match is possible beyond *lastcp */</comment>
		<return>return <expr><literal type="number">0</literal></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name>ss</name> <operator>=</operator> <name>css</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * This is the main text-scanning loop.  It seems worth having two copies
	 * to avoid the overhead of REG_FTRACE tests here, even in REG_DEBUG
	 * builds, when you're not actively tracing.
	 */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>REG_DEBUG</name></cpp:ifdef>
	<if_stmt><if>if <condition>(<expr><name><name>v</name><operator>-&gt;</operator><name>eflags</name></name> <operator>&amp;</operator> <name>REG_FTRACE</name></expr>)</condition>
	<block>{<block_content>
		<while>while <condition>(<expr><name>cp</name> <operator>&lt;</operator> <name>probe</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>FDEBUG</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"&gt;&gt;&gt; at c%d &gt;&gt;&gt;\n"</literal><operator>,</operator> <operator>(</operator><name>int</name><operator>)</operator> <operator>(</operator><name>css</name> <operator>-</operator> <name><name>d</name><operator>-&gt;</operator><name>ssets</name></name><operator>)</operator><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>co</name> <operator>=</operator> <call><name>GETCOLOR</name><argument_list>(<argument><expr><name>cm</name></expr></argument>, <argument><expr><operator>*</operator><name>cp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>FDEBUG</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"char %c, color %ld\n"</literal><operator>,</operator> <operator>(</operator><name>char</name><operator>)</operator> <operator>*</operator><name>cp</name><operator>,</operator> <operator>(</operator><name>long</name><operator>)</operator> <name>co</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>ss</name> <operator>=</operator> <name><name>css</name><operator>-&gt;</operator><name>outs</name><index>[<expr><name>co</name></expr>]</index></name></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>ss</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>ss</name> <operator>=</operator> <call><name>miss</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>d</name></expr></argument>, <argument><expr><name>css</name></expr></argument>, <argument><expr><name>co</name></expr></argument>, <argument><expr><name>cp</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name><name>v</name><operator>-&gt;</operator><name>start</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name>ss</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
					<break>break;</break></block_content></block></if></if_stmt>		<comment type="block">/* NOTE BREAK OUT */</comment>
			</block_content>}</block></if></if_stmt>
			<expr_stmt><expr><name>cp</name><operator>++</operator></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>ss</name><operator>-&gt;</operator><name>lastseen</name></name> <operator>=</operator> <name>cp</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>css</name> <operator>=</operator> <name>ss</name></expr>;</expr_stmt>
		</block_content>}</block></while>
	</block_content>}</block></if>
	<else>else
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<block>{<block_content>
		<while>while <condition>(<expr><name>cp</name> <operator>&lt;</operator> <name>probe</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>co</name> <operator>=</operator> <call><name>GETCOLOR</name><argument_list>(<argument><expr><name>cm</name></expr></argument>, <argument><expr><operator>*</operator><name>cp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>ss</name> <operator>=</operator> <name><name>css</name><operator>-&gt;</operator><name>outs</name><index>[<expr><name>co</name></expr>]</index></name></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>ss</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>ss</name> <operator>=</operator> <call><name>miss</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>d</name></expr></argument>, <argument><expr><name>css</name></expr></argument>, <argument><expr><name>co</name></expr></argument>, <argument><expr><name>cp</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name><name>v</name><operator>-&gt;</operator><name>start</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name>ss</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
					<break>break;</break></block_content></block></if></if_stmt>		<comment type="block">/* NOTE BREAK OUT */</comment>
			</block_content>}</block></if></if_stmt>
			<expr_stmt><expr><name>cp</name><operator>++</operator></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>ss</name><operator>-&gt;</operator><name>lastseen</name></name> <operator>=</operator> <name>cp</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>css</name> <operator>=</operator> <name>ss</name></expr>;</expr_stmt>
		</block_content>}</block></while>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><operator>*</operator><name>lastcss</name> <operator>=</operator> <name>ss</name></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>lastcp</name> <operator>=</operator> <name>cp</name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>ss</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>				<comment type="block">/* impossible match, or internal error */</comment>

	<comment type="block">/* We need to process one more chr, or the EOS symbol, to check match */</comment>
	<if_stmt><if>if <condition>(<expr><name>cp</name> <operator>&lt;</operator> <name><name>v</name><operator>-&gt;</operator><name>stop</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>FDEBUG</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"&gt;&gt;&gt; at c%d &gt;&gt;&gt;\n"</literal><operator>,</operator> <operator>(</operator><name>int</name><operator>)</operator> <operator>(</operator><name>css</name> <operator>-</operator> <name><name>d</name><operator>-&gt;</operator><name>ssets</name></name><operator>)</operator><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>co</name> <operator>=</operator> <call><name>GETCOLOR</name><argument_list>(<argument><expr><name>cm</name></expr></argument>, <argument><expr><operator>*</operator><name>cp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>FDEBUG</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"char %c, color %ld\n"</literal><operator>,</operator> <operator>(</operator><name>char</name><operator>)</operator> <operator>*</operator><name>cp</name><operator>,</operator> <operator>(</operator><name>long</name><operator>)</operator> <name>co</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>ss</name> <operator>=</operator> <name><name>css</name><operator>-&gt;</operator><name>outs</name><index>[<expr><name>co</name></expr>]</index></name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>ss</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>ss</name> <operator>=</operator> <call><name>miss</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>d</name></expr></argument>, <argument><expr><name>css</name></expr></argument>, <argument><expr><name>co</name></expr></argument>, <argument><expr><name>cp</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name><name>v</name><operator>-&gt;</operator><name>start</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>cp</name> <operator>==</operator> <name><name>v</name><operator>-&gt;</operator><name>stop</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>co</name> <operator>=</operator> <name><name>d</name><operator>-&gt;</operator><name>cnfa</name><operator>-&gt;</operator><name>eos</name><index>[<expr><ternary><condition><expr><operator>(</operator><name><name>v</name><operator>-&gt;</operator><name>eflags</name></name> <operator>&amp;</operator> <name>REG_NOTEOL</name><operator>)</operator></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><literal type="number">1</literal></expr></else></ternary></expr>]</index></name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>FDEBUG</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"color %ld\n"</literal><operator>,</operator> <operator>(</operator><name>long</name><operator>)</operator> <name>co</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>ss</name> <operator>=</operator> <call><name>miss</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>d</name></expr></argument>, <argument><expr><name>css</name></expr></argument>, <argument><expr><name>co</name></expr></argument>, <argument><expr><name>cp</name></expr></argument>, <argument><expr><name><name>v</name><operator>-&gt;</operator><name>start</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>ss</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <operator>!</operator><operator>(</operator><name><name>ss</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>POSTSTATE</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

	<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * lastcold - determine last point at which no progress had been made
 */</comment>
<function><type><specifier>static</specifier> <name>chr</name> <modifier>*</modifier></type>					<comment type="block">/* endpoint, or NULL */</comment>
<name>lastcold</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>vars</name></name> <modifier>*</modifier></type><name>v</name></decl></parameter>,
		 <parameter><decl><type><name><name>struct</name> <name>dfa</name></name> <modifier>*</modifier></type><name>d</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name><name>struct</name> <name>sset</name></name> <modifier>*</modifier></type><name>ss</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>chr</name>		   <modifier>*</modifier></type><name>nopr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>nopr</name> <operator>=</operator> <name><name>d</name><operator>-&gt;</operator><name>lastnopr</name></name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>nopr</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>nopr</name> <operator>=</operator> <name><name>v</name><operator>-&gt;</operator><name>start</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<for>for <control>(<init><expr><name>ss</name> <operator>=</operator> <name><name>d</name><operator>-&gt;</operator><name>ssets</name></name></expr><operator>,</operator> <expr><name>i</name> <operator>=</operator> <name><name>d</name><operator>-&gt;</operator><name>nssused</name></name></expr>;</init> <condition><expr><name>i</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><name>ss</name><operator>++</operator></expr><operator>,</operator> <expr><name>i</name><operator>--</operator></expr></incr>)</control><block type="pseudo"><block_content>
		<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>ss</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>NOPROGRESS</name><operator>)</operator> <operator>&amp;&amp;</operator> <name>nopr</name> <operator>&lt;</operator> <name><name>ss</name><operator>-&gt;</operator><name>lastseen</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>nopr</name> <operator>=</operator> <name><name>ss</name><operator>-&gt;</operator><name>lastseen</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt></block_content></block></for>
	<return>return <expr><name>nopr</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * newdfa - set up a fresh DFA
 */</comment>
<function><type><specifier>static</specifier> <name><name>struct</name> <name>dfa</name></name> <modifier>*</modifier></type>
<name>newdfa</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>vars</name></name> <modifier>*</modifier></type><name>v</name></decl></parameter>,
	   <parameter><decl><type><name><name>struct</name> <name>cnfa</name></name> <modifier>*</modifier></type><name>cnfa</name></decl></parameter>,
	   <parameter><decl><type><name><name>struct</name> <name>colormap</name></name> <modifier>*</modifier></type><name>cm</name></decl></parameter>,
	   <parameter><decl><type><name><name>struct</name> <name>smalldfa</name></name> <modifier>*</modifier></type><name>sml</name></decl></parameter>)</parameter_list>	<comment type="block">/* preallocated space, may be NULL */</comment>
<block>{<block_content>
	<decl_stmt><decl><type><name><name>struct</name> <name>dfa</name></name> <modifier>*</modifier></type><name>d</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>size_t</name></type>		<name>nss</name> <init>= <expr><name><name>cnfa</name><operator>-&gt;</operator><name>nstates</name></name> <operator>*</operator> <literal type="number">2</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>wordsper</name> <init>= <expr><operator>(</operator><name><name>cnfa</name><operator>-&gt;</operator><name>nstates</name></name> <operator>+</operator> <name>UBITS</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator> <operator>/</operator> <name>UBITS</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>smalldfa</name></name> <modifier>*</modifier></type><name>smallwas</name> <init>= <expr><name>sml</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>cnfa</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name><name>cnfa</name><operator>-&gt;</operator><name>nstates</name></name> <operator>!=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>nss</name> <operator>&lt;=</operator> <name>FEWSTATES</name> <operator>&amp;&amp;</operator> <name><name>cnfa</name><operator>-&gt;</operator><name>ncolors</name></name> <operator>&lt;=</operator> <name>FEWCOLORS</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>wordsper</name> <operator>==</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>sml</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>sml</name> <operator>=</operator> <operator>(</operator>struct <name>smalldfa</name> <operator>*</operator><operator>)</operator> <call><name>MALLOC</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr>struct <name>smalldfa</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>sml</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>ERR</name><argument_list>(<argument><expr><name>REG_ESPACE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr><name>NULL</name></expr>;</return>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><name>d</name> <operator>=</operator> <operator>&amp;</operator><name><name>sml</name><operator>-&gt;</operator><name>dfa</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>d</name><operator>-&gt;</operator><name>ssets</name></name> <operator>=</operator> <name><name>sml</name><operator>-&gt;</operator><name>ssets</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>d</name><operator>-&gt;</operator><name>statesarea</name></name> <operator>=</operator> <name><name>sml</name><operator>-&gt;</operator><name>statesarea</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>d</name><operator>-&gt;</operator><name>work</name></name> <operator>=</operator> <operator>&amp;</operator><name><name>d</name><operator>-&gt;</operator><name>statesarea</name><index>[<expr><name>nss</name></expr>]</index></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>d</name><operator>-&gt;</operator><name>outsarea</name></name> <operator>=</operator> <name><name>sml</name><operator>-&gt;</operator><name>outsarea</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>d</name><operator>-&gt;</operator><name>incarea</name></name> <operator>=</operator> <name><name>sml</name><operator>-&gt;</operator><name>incarea</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>d</name><operator>-&gt;</operator><name>cptsmalloced</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>d</name><operator>-&gt;</operator><name>mallocarea</name></name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name>smallwas</name> <operator>==</operator> <name>NULL</name><operator>)</operator></expr> ?</condition><then> <expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>sml</name></expr> </then><else>: <expr><name>NULL</name></expr></else></ternary></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name>d</name> <operator>=</operator> <operator>(</operator>struct <name>dfa</name> <operator>*</operator><operator>)</operator> <call><name>MALLOC</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr>struct <name>dfa</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>d</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ERR</name><argument_list>(<argument><expr><name>REG_ESPACE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>NULL</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><name><name>d</name><operator>-&gt;</operator><name>ssets</name></name> <operator>=</operator> <operator>(</operator>struct <name>sset</name> <operator>*</operator><operator>)</operator> <call><name>MALLOC</name><argument_list>(<argument><expr><name>nss</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr>struct <name>sset</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>d</name><operator>-&gt;</operator><name>statesarea</name></name> <operator>=</operator> <operator>(</operator><name>unsigned</name> <operator>*</operator><operator>)</operator> <call><name>MALLOC</name><argument_list>(<argument><expr><operator>(</operator><name>nss</name> <operator>+</operator> <name>WORK</name><operator>)</operator> <operator>*</operator> <name>wordsper</name> <operator>*</operator>
											<sizeof>sizeof<argument_list>(<argument><expr><name>unsigned</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>d</name><operator>-&gt;</operator><name>work</name></name> <operator>=</operator> <operator>&amp;</operator><name><name>d</name><operator>-&gt;</operator><name>statesarea</name><index>[<expr><name>nss</name> <operator>*</operator> <name>wordsper</name></expr>]</index></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>d</name><operator>-&gt;</operator><name>outsarea</name></name> <operator>=</operator> <operator>(</operator>struct <name>sset</name> <operator>*</operator><operator>*</operator><operator>)</operator> <call><name>MALLOC</name><argument_list>(<argument><expr><name>nss</name> <operator>*</operator> <name><name>cnfa</name><operator>-&gt;</operator><name>ncolors</name></name> <operator>*</operator>
											  <sizeof>sizeof<argument_list>(<argument><expr>struct <name>sset</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>d</name><operator>-&gt;</operator><name>incarea</name></name> <operator>=</operator> <operator>(</operator>struct <name>arcp</name> <operator>*</operator><operator>)</operator> <call><name>MALLOC</name><argument_list>(<argument><expr><name>nss</name> <operator>*</operator> <name><name>cnfa</name><operator>-&gt;</operator><name>ncolors</name></name> <operator>*</operator>
											<sizeof>sizeof<argument_list>(<argument><expr>struct <name>arcp</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>d</name><operator>-&gt;</operator><name>cptsmalloced</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>d</name><operator>-&gt;</operator><name>mallocarea</name></name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>d</name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>d</name><operator>-&gt;</operator><name>ssets</name></name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name><name>d</name><operator>-&gt;</operator><name>statesarea</name></name> <operator>==</operator> <name>NULL</name> <operator>||</operator>
			<name><name>d</name><operator>-&gt;</operator><name>outsarea</name></name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name><name>d</name><operator>-&gt;</operator><name>incarea</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>freedfa</name><argument_list>(<argument><expr><name>d</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>ERR</name><argument_list>(<argument><expr><name>REG_ESPACE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>NULL</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><name><name>d</name><operator>-&gt;</operator><name>nssets</name></name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name><name>v</name><operator>-&gt;</operator><name>eflags</name></name> <operator>&amp;</operator> <name>REG_SMALL</name><operator>)</operator></expr> ?</condition><then> <expr><literal type="number">7</literal></expr> </then><else>: <expr><name>nss</name></expr></else></ternary></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>d</name><operator>-&gt;</operator><name>nssused</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>d</name><operator>-&gt;</operator><name>nstates</name></name> <operator>=</operator> <name><name>cnfa</name><operator>-&gt;</operator><name>nstates</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>d</name><operator>-&gt;</operator><name>ncolors</name></name> <operator>=</operator> <name><name>cnfa</name><operator>-&gt;</operator><name>ncolors</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>d</name><operator>-&gt;</operator><name>wordsper</name></name> <operator>=</operator> <name>wordsper</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>d</name><operator>-&gt;</operator><name>cnfa</name></name> <operator>=</operator> <name>cnfa</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>d</name><operator>-&gt;</operator><name>cm</name></name> <operator>=</operator> <name>cm</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>d</name><operator>-&gt;</operator><name>lastpost</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>d</name><operator>-&gt;</operator><name>lastnopr</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>d</name><operator>-&gt;</operator><name>search</name></name> <operator>=</operator> <name><name>d</name><operator>-&gt;</operator><name>ssets</name></name></expr>;</expr_stmt>

	<comment type="block">/* initialization of sset fields is done as needed */</comment>

	<return>return <expr><name>d</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * freedfa - free a DFA
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>freedfa</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>dfa</name></name> <modifier>*</modifier></type><name>d</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name><name>d</name><operator>-&gt;</operator><name>cptsmalloced</name></name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>d</name><operator>-&gt;</operator><name>ssets</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>FREE</name><argument_list>(<argument><expr><name><name>d</name><operator>-&gt;</operator><name>ssets</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>d</name><operator>-&gt;</operator><name>statesarea</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>FREE</name><argument_list>(<argument><expr><name><name>d</name><operator>-&gt;</operator><name>statesarea</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>d</name><operator>-&gt;</operator><name>outsarea</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>FREE</name><argument_list>(<argument><expr><name><name>d</name><operator>-&gt;</operator><name>outsarea</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>d</name><operator>-&gt;</operator><name>incarea</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>FREE</name><argument_list>(<argument><expr><name><name>d</name><operator>-&gt;</operator><name>incarea</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>d</name><operator>-&gt;</operator><name>mallocarea</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>FREE</name><argument_list>(<argument><expr><name><name>d</name><operator>-&gt;</operator><name>mallocarea</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * hash - construct a hash code for a bitvector
 *
 * There are probably better ways, but they're more expensive.
 */</comment>
<function><type><specifier>static</specifier> <name>unsigned</name></type>
<name>hash</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <modifier>*</modifier></type><name>uv</name></decl></parameter>,
	 <parameter><decl><type><name>int</name></type> <name>n</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>unsigned</name></type>	<name>h</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>h</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>n</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
		<expr_stmt><expr><name>h</name> <operator>^=</operator> <name><name>uv</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></for>
	<return>return <expr><name>h</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * initialize - hand-craft a cache entry for startup, otherwise get ready
 */</comment>
<function><type><specifier>static</specifier> <name><name>struct</name> <name>sset</name></name> <modifier>*</modifier></type>
<name>initialize</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>vars</name></name> <modifier>*</modifier></type><name>v</name></decl></parameter>,
		   <parameter><decl><type><name><name>struct</name> <name>dfa</name></name> <modifier>*</modifier></type><name>d</name></decl></parameter>,
		   <parameter><decl><type><name>chr</name> <modifier>*</modifier></type><name>start</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name><name>struct</name> <name>sset</name></name> <modifier>*</modifier></type><name>ss</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<comment type="block">/* is previous one still there? */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>d</name><operator>-&gt;</operator><name>nssused</name></name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>d</name><operator>-&gt;</operator><name>ssets</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>flags</name> <operator>&amp;</operator> <name>STARTER</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>ss</name> <operator>=</operator> <operator>&amp;</operator><name><name>d</name><operator>-&gt;</operator><name>ssets</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt></block_content></block></if>
	<else>else
	<block>{<block_content>							<comment type="block">/* no, must (re)build it */</comment>
		<expr_stmt><expr><name>ss</name> <operator>=</operator> <call><name>getvacant</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>d</name></expr></argument>, <argument><expr><name>start</name></expr></argument>, <argument><expr><name>start</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>ss</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>d</name><operator>-&gt;</operator><name>wordsper</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>ss</name><operator>-&gt;</operator><name>states</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></for>
		<expr_stmt><expr><call><name>BSET</name><argument_list>(<argument><expr><name><name>ss</name><operator>-&gt;</operator><name>states</name></name></expr></argument>, <argument><expr><name><name>d</name><operator>-&gt;</operator><name>cnfa</name><operator>-&gt;</operator><name>pre</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>ss</name><operator>-&gt;</operator><name>hash</name></name> <operator>=</operator> <call><name>HASH</name><argument_list>(<argument><expr><name><name>ss</name><operator>-&gt;</operator><name>states</name></name></expr></argument>, <argument><expr><name><name>d</name><operator>-&gt;</operator><name>wordsper</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>d</name><operator>-&gt;</operator><name>cnfa</name><operator>-&gt;</operator><name>pre</name></name> <operator>!=</operator> <name><name>d</name><operator>-&gt;</operator><name>cnfa</name><operator>-&gt;</operator><name>post</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>ss</name><operator>-&gt;</operator><name>flags</name></name> <operator>=</operator> <name>STARTER</name> <operator>|</operator> <name>LOCKED</name> <operator>|</operator> <name>NOPROGRESS</name></expr>;</expr_stmt>
		<comment type="block">/* lastseen dealt with below */</comment>
	</block_content>}</block></else></if_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>d</name><operator>-&gt;</operator><name>nssused</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>d</name><operator>-&gt;</operator><name>ssets</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>lastseen</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></for>
	<expr_stmt><expr><name><name>ss</name><operator>-&gt;</operator><name>lastseen</name></name> <operator>=</operator> <name>start</name></expr>;</expr_stmt>		<comment type="block">/* maybe untrue, but harmless */</comment>
	<expr_stmt><expr><name><name>d</name><operator>-&gt;</operator><name>lastpost</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>d</name><operator>-&gt;</operator><name>lastnopr</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<return>return <expr><name>ss</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * miss - handle a stateset cache miss
 *
 * css is the current stateset, co is the color of the current input character,
 * cp points to the character after that (which is where we may need to test
 * LACONs).  start does not affect matching behavior but is needed for pickss'
 * heuristics about which stateset cache entry to replace.
 *
 * Ordinarily, returns the address of the next stateset (the one that is
 * valid after consuming the input character).  Returns NULL if no valid
 * NFA states remain, ie we have a certain match failure.
 * Internal errors also return NULL, with v-&gt;err set.
 */</comment>
<function><type><specifier>static</specifier> <name><name>struct</name> <name>sset</name></name> <modifier>*</modifier></type>
<name>miss</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>vars</name></name> <modifier>*</modifier></type><name>v</name></decl></parameter>,
	 <parameter><decl><type><name><name>struct</name> <name>dfa</name></name> <modifier>*</modifier></type><name>d</name></decl></parameter>,
	 <parameter><decl><type><name><name>struct</name> <name>sset</name></name> <modifier>*</modifier></type><name>css</name></decl></parameter>,
	 <parameter><decl><type><name>color</name></type> <name>co</name></decl></parameter>,
	 <parameter><decl><type><name>chr</name> <modifier>*</modifier></type><name>cp</name></decl></parameter>,					<comment type="block">/* next chr */</comment>
	 <parameter><decl><type><name>chr</name> <modifier>*</modifier></type><name>start</name></decl></parameter>)</parameter_list>				<comment type="block">/* where the attempt got started */</comment>
<block>{<block_content>
	<decl_stmt><decl><type><name><name>struct</name> <name>cnfa</name></name> <modifier>*</modifier></type><name>cnfa</name> <init>= <expr><name><name>d</name><operator>-&gt;</operator><name>cnfa</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>unsigned</name></type>	<name>h</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>carc</name></name> <modifier>*</modifier></type><name>ca</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>sset</name></name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>ispost</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>noprogress</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>gotstate</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>dolacons</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>sawlacons</name></decl>;</decl_stmt>

	<comment type="block">/* for convenience, we can be called even if it might not be a miss */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>css</name><operator>-&gt;</operator><name>outs</name><index>[<expr><name>co</name></expr>]</index></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>FDEBUG</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"hit\n"</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name><name>css</name><operator>-&gt;</operator><name>outs</name><index>[<expr><name>co</name></expr>]</index></name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>FDEBUG</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"miss\n"</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Checking for operation cancel in the inner text search loop seems
	 * unduly expensive.  As a compromise, check during cache misses.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>CANCEL_REQUESTED</name><argument_list>(<argument><expr><name><name>v</name><operator>-&gt;</operator><name>re</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ERR</name><argument_list>(<argument><expr><name>REG_CANCEL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * What set of states would we end up in after consuming the co character?
	 * We first consider PLAIN arcs that consume the character, and then look
	 * to see what LACON arcs could be traversed after consuming it.
	 */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>d</name><operator>-&gt;</operator><name>wordsper</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>d</name><operator>-&gt;</operator><name>work</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></for>			<comment type="block">/* build new stateset bitmap in d-&gt;work */</comment>
	<expr_stmt><expr><name>ispost</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>noprogress</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>gotstate</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>d</name><operator>-&gt;</operator><name>nstates</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
		<if_stmt><if>if <condition>(<expr><call><name>ISBSET</name><argument_list>(<argument><expr><name><name>css</name><operator>-&gt;</operator><name>states</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<for>for <control>(<init><expr><name>ca</name> <operator>=</operator> <name><name>cnfa</name><operator>-&gt;</operator><name>states</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</init> <condition><expr><name><name>ca</name><operator>-&gt;</operator><name>co</name></name> <operator>!=</operator> <name>COLORLESS</name></expr>;</condition> <incr><expr><name>ca</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
				<if_stmt><if>if <condition>(<expr><name><name>ca</name><operator>-&gt;</operator><name>co</name></name> <operator>==</operator> <name>co</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>BSET</name><argument_list>(<argument><expr><name><name>d</name><operator>-&gt;</operator><name>work</name></name></expr></argument>, <argument><expr><name><name>ca</name><operator>-&gt;</operator><name>to</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>gotstate</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
					<if_stmt><if>if <condition>(<expr><name><name>ca</name><operator>-&gt;</operator><name>to</name></name> <operator>==</operator> <name><name>cnfa</name><operator>-&gt;</operator><name>post</name></name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><name>ispost</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
					<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name><name>cnfa</name><operator>-&gt;</operator><name>stflags</name><index>[<expr><name><name>ca</name><operator>-&gt;</operator><name>to</name></name></expr>]</index></name> <operator>&amp;</operator> <name>CNFA_NOPROGRESS</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><name>noprogress</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
					<expr_stmt><expr><call><name>FDEBUG</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"%d -&gt; %d\n"</literal><operator>,</operator> <name>i</name><operator>,</operator> <name><name>ca</name><operator>-&gt;</operator><name>to</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt></block_content></block></for></block_content></block></if></if_stmt></block_content></block></for>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>gotstate</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>			<comment type="block">/* character cannot reach any new state */</comment>
	<expr_stmt><expr><name>dolacons</name> <operator>=</operator> <operator>(</operator><name><name>cnfa</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>HASLACONS</name><operator>)</operator></expr>;</expr_stmt>
	<expr_stmt><expr><name>sawlacons</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<comment type="block">/* outer loop handles transitive closure of reachable-by-LACON states */</comment>
	<while>while <condition>(<expr><name>dolacons</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>dolacons</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>d</name><operator>-&gt;</operator><name>nstates</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
			<if_stmt><if>if <condition>(<expr><call><name>ISBSET</name><argument_list>(<argument><expr><name><name>d</name><operator>-&gt;</operator><name>work</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<for>for <control>(<init><expr><name>ca</name> <operator>=</operator> <name><name>cnfa</name><operator>-&gt;</operator><name>states</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</init> <condition><expr><name><name>ca</name><operator>-&gt;</operator><name>co</name></name> <operator>!=</operator> <name>COLORLESS</name></expr>;</condition> <incr><expr><name>ca</name><operator>++</operator></expr></incr>)</control>
				<block>{<block_content>
					<if_stmt><if>if <condition>(<expr><name><name>ca</name><operator>-&gt;</operator><name>co</name></name> <operator>&lt;</operator> <name><name>cnfa</name><operator>-&gt;</operator><name>ncolors</name></name></expr>)</condition><block type="pseudo"><block_content>
						<continue>continue;</continue></block_content></block></if></if_stmt>	<comment type="block">/* not a LACON arc */</comment>
					<if_stmt><if>if <condition>(<expr><call><name>ISBSET</name><argument_list>(<argument><expr><name><name>d</name><operator>-&gt;</operator><name>work</name></name></expr></argument>, <argument><expr><name><name>ca</name><operator>-&gt;</operator><name>to</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
						<continue>continue;</continue></block_content></block></if></if_stmt>	<comment type="block">/* arc would be a no-op anyway */</comment>
					<expr_stmt><expr><name>sawlacons</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>	<comment type="block">/* this LACON affects our result */</comment>
					<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>lacon</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>cnfa</name></expr></argument>, <argument><expr><name>cp</name></expr></argument>, <argument><expr><name><name>ca</name><operator>-&gt;</operator><name>co</name></name></expr></argument>)</argument_list></call></expr>)</condition>
					<block>{<block_content>
						<if_stmt><if>if <condition>(<expr><call><name>ISERR</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
							<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
						<continue>continue;</continue>	<comment type="block">/* LACON arc cannot be traversed */</comment>
					</block_content>}</block></if></if_stmt>
					<if_stmt><if>if <condition>(<expr><call><name>ISERR</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
						<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
					<expr_stmt><expr><call><name>BSET</name><argument_list>(<argument><expr><name><name>d</name><operator>-&gt;</operator><name>work</name></name></expr></argument>, <argument><expr><name><name>ca</name><operator>-&gt;</operator><name>to</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>dolacons</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
					<if_stmt><if>if <condition>(<expr><name><name>ca</name><operator>-&gt;</operator><name>to</name></name> <operator>==</operator> <name><name>cnfa</name><operator>-&gt;</operator><name>post</name></name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><name>ispost</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
					<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name><name>cnfa</name><operator>-&gt;</operator><name>stflags</name><index>[<expr><name><name>ca</name><operator>-&gt;</operator><name>to</name></name></expr>]</index></name> <operator>&amp;</operator> <name>CNFA_NOPROGRESS</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><name>noprogress</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
					<expr_stmt><expr><call><name>FDEBUG</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"%d :&gt; %d\n"</literal><operator>,</operator> <name>i</name><operator>,</operator> <name><name>ca</name><operator>-&gt;</operator><name>to</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></for></block_content></block></if></if_stmt></block_content></block></for>
	</block_content>}</block></while>
	<expr_stmt><expr><name>h</name> <operator>=</operator> <call><name>HASH</name><argument_list>(<argument><expr><name><name>d</name><operator>-&gt;</operator><name>work</name></name></expr></argument>, <argument><expr><name><name>d</name><operator>-&gt;</operator><name>wordsper</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Is this stateset already in the cache? */</comment>
	<for>for <control>(<init><expr><name>p</name> <operator>=</operator> <name><name>d</name><operator>-&gt;</operator><name>ssets</name></name></expr><operator>,</operator> <expr><name>i</name> <operator>=</operator> <name><name>d</name><operator>-&gt;</operator><name>nssused</name></name></expr>;</init> <condition><expr><name>i</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><name>p</name><operator>++</operator></expr><operator>,</operator> <expr><name>i</name><operator>--</operator></expr></incr>)</control><block type="pseudo"><block_content>
		<if_stmt><if>if <condition>(<expr><call><name>HIT</name><argument_list>(<argument><expr><name>h</name></expr></argument>, <argument><expr><name><name>d</name><operator>-&gt;</operator><name>work</name></name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name><name>d</name><operator>-&gt;</operator><name>wordsper</name></name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>FDEBUG</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"cached c%d\n"</literal><operator>,</operator> <operator>(</operator><name>int</name><operator>)</operator> <operator>(</operator><name>p</name> <operator>-</operator> <name><name>d</name><operator>-&gt;</operator><name>ssets</name></name><operator>)</operator><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>				<comment type="block">/* NOTE BREAK OUT */</comment>
		</block_content>}</block></if></if_stmt></block_content></block></for>
	<if_stmt><if>if <condition>(<expr><name>i</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>							<comment type="block">/* nope, need a new cache entry */</comment>
		<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>getvacant</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>d</name></expr></argument>, <argument><expr><name>cp</name></expr></argument>, <argument><expr><name>start</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>p</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>p</name> <operator>!=</operator> <name>css</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>d</name><operator>-&gt;</operator><name>wordsper</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>states</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>d</name><operator>-&gt;</operator><name>work</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></for>
		<expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>hash</name></name> <operator>=</operator> <name>h</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>flags</name></name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name>ispost</name><operator>)</operator></expr> ?</condition><then> <expr><name>POSTSTATE</name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>noprogress</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>flags</name></name> <operator>|=</operator> <name>NOPROGRESS</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<comment type="block">/* lastseen to be dealt with by caller */</comment>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Link new stateset to old, unless a LACON affected the result, in which
	 * case we don't create the link.  That forces future transitions across
	 * this same arc (same prior stateset and character color) to come through
	 * miss() again, so that we can recheck the LACON(s), which might or might
	 * not pass since context will be different.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>sawlacons</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>FDEBUG</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"c%d[%d]-&gt;c%d\n"</literal><operator>,</operator>
				<operator>(</operator><name>int</name><operator>)</operator> <operator>(</operator><name>css</name> <operator>-</operator> <name><name>d</name><operator>-&gt;</operator><name>ssets</name></name><operator>)</operator><operator>,</operator> <name>co</name><operator>,</operator> <operator>(</operator><name>int</name><operator>)</operator> <operator>(</operator><name>p</name> <operator>-</operator> <name><name>d</name><operator>-&gt;</operator><name>ssets</name></name><operator>)</operator><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>css</name><operator>-&gt;</operator><name>outs</name><index>[<expr><name>co</name></expr>]</index></name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>css</name><operator>-&gt;</operator><name>inchain</name><index>[<expr><name>co</name></expr>]</index></name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>ins</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>ins</name><operator>.</operator><name>ss</name></name> <operator>=</operator> <name>css</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>ins</name><operator>.</operator><name>co</name></name> <operator>=</operator> <name>co</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><name>p</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * lacon - lookaround-constraint checker for miss()
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>						<comment type="block">/* predicate:  constraint satisfied? */</comment>
<name>lacon</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>vars</name></name> <modifier>*</modifier></type><name>v</name></decl></parameter>,
	  <parameter><decl><type><name><name>struct</name> <name>cnfa</name></name> <modifier>*</modifier></type><name>pcnfa</name></decl></parameter>,		<comment type="block">/* parent cnfa */</comment>
	  <parameter><decl><type><name>chr</name> <modifier>*</modifier></type><name>cp</name></decl></parameter>,
	  <parameter><decl><type><name>color</name></type> <name>co</name></decl></parameter>)</parameter_list>					<comment type="block">/* "color" of the lookaround constraint */</comment>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>n</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>subre</name></name> <modifier>*</modifier></type><name>sub</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>dfa</name></name> <modifier>*</modifier></type><name>d</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>chr</name>		   <modifier>*</modifier></type><name>end</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>satisfied</name></decl>;</decl_stmt>

	<comment type="block">/* Since this is recursive, it could be driven to stack overflow */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>STACK_TOO_DEEP</name><argument_list>(<argument><expr><name><name>v</name><operator>-&gt;</operator><name>re</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ERR</name><argument_list>(<argument><expr><name>REG_ETOOBIG</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><literal type="number">0</literal></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>n</name> <operator>=</operator> <name>co</name> <operator>-</operator> <name><name>pcnfa</name><operator>-&gt;</operator><name>ncolors</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>n</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>n</name> <operator>&lt;</operator> <name><name>v</name><operator>-&gt;</operator><name>g</name><operator>-&gt;</operator><name>nlacons</name></name> <operator>&amp;&amp;</operator> <name><name>v</name><operator>-&gt;</operator><name>g</name><operator>-&gt;</operator><name>lacons</name></name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>FDEBUG</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"=== testing lacon %d\n"</literal><operator>,</operator> <name>n</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>sub</name> <operator>=</operator> <operator>&amp;</operator><name><name>v</name><operator>-&gt;</operator><name>g</name><operator>-&gt;</operator><name>lacons</name><index>[<expr><name>n</name></expr>]</index></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>d</name> <operator>=</operator> <call><name>getladfa</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>d</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>LATYPE_IS_AHEAD</name><argument_list>(<argument><expr><name><name>sub</name><operator>-&gt;</operator><name>subno</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* used to use longest() here, but shortest() could be much cheaper */</comment>
		<expr_stmt><expr><name>end</name> <operator>=</operator> <call><name>shortest</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>d</name></expr></argument>, <argument><expr><name>cp</name></expr></argument>, <argument><expr><name>cp</name></expr></argument>, <argument><expr><name><name>v</name><operator>-&gt;</operator><name>stop</name></name></expr></argument>,
					   <argument><expr><operator>(</operator><name>chr</name> <operator>*</operator><operator>*</operator><operator>)</operator> <name>NULL</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name> <operator>*</operator><operator>)</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>satisfied</name> <operator>=</operator> <ternary><condition><expr><call><name>LATYPE_IS_POS</name><argument_list>(<argument><expr><name><name>sub</name><operator>-&gt;</operator><name>subno</name></name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><operator>(</operator><name>end</name> <operator>!=</operator> <name>NULL</name><operator>)</operator></expr> </then><else>: <expr><operator>(</operator><name>end</name> <operator>==</operator> <name>NULL</name><operator>)</operator></expr></else></ternary></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/*
		 * To avoid doing O(N^2) work when repeatedly testing a lookbehind
		 * constraint in an N-character string, we use matchuntil() which can
		 * cache the DFA state across calls.  We only need to restart if the
		 * probe point decreases, which is not common.  The NFA we're using is
		 * a search NFA, so it doesn't mind scanning over stuff before the
		 * nominal match.
		 */</comment>
		<expr_stmt><expr><name>satisfied</name> <operator>=</operator> <call><name>matchuntil</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>d</name></expr></argument>, <argument><expr><name>cp</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>v</name><operator>-&gt;</operator><name>lblastcss</name><index>[<expr><name>n</name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>v</name><operator>-&gt;</operator><name>lblastcp</name><index>[<expr><name>n</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>LATYPE_IS_POS</name><argument_list>(<argument><expr><name><name>sub</name><operator>-&gt;</operator><name>subno</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>satisfied</name> <operator>=</operator> <operator>!</operator><name>satisfied</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></else></if_stmt>
	<expr_stmt><expr><call><name>FDEBUG</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"=== lacon %d satisfied %d\n"</literal><operator>,</operator> <name>n</name><operator>,</operator> <name>satisfied</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>satisfied</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * getvacant - get a vacant state set
 *
 * This routine clears out the inarcs and outarcs, but does not otherwise
 * clear the innards of the state set -- that's up to the caller.
 */</comment>
<function><type><specifier>static</specifier> <name><name>struct</name> <name>sset</name></name> <modifier>*</modifier></type>
<name>getvacant</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>vars</name></name> <modifier>*</modifier></type><name>v</name></decl></parameter>,
		  <parameter><decl><type><name><name>struct</name> <name>dfa</name></name> <modifier>*</modifier></type><name>d</name></decl></parameter>,
		  <parameter><decl><type><name>chr</name> <modifier>*</modifier></type><name>cp</name></decl></parameter>,
		  <parameter><decl><type><name>chr</name> <modifier>*</modifier></type><name>start</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>sset</name></name> <modifier>*</modifier></type><name>ss</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>sset</name></name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>arcp</name></name></type> <name>ap</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>color</name></type>		<name>co</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>ss</name> <operator>=</operator> <call><name>pickss</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>d</name></expr></argument>, <argument><expr><name>cp</name></expr></argument>, <argument><expr><name>start</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>ss</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>!</operator><operator>(</operator><name><name>ss</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>LOCKED</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* clear out its inarcs, including self-referential ones */</comment>
	<expr_stmt><expr><name>ap</name> <operator>=</operator> <name><name>ss</name><operator>-&gt;</operator><name>ins</name></name></expr>;</expr_stmt>
	<while>while <condition>(<expr><operator>(</operator><name>p</name> <operator>=</operator> <name><name>ap</name><operator>.</operator><name>ss</name></name><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>co</name> <operator>=</operator> <name><name>ap</name><operator>.</operator><name>co</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>FDEBUG</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"zapping c%d's %ld outarc\n"</literal><operator>,</operator> <operator>(</operator><name>int</name><operator>)</operator> <operator>(</operator><name>p</name> <operator>-</operator> <name><name>d</name><operator>-&gt;</operator><name>ssets</name></name><operator>)</operator><operator>,</operator> <operator>(</operator><name>long</name><operator>)</operator> <name>co</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>outs</name><index>[<expr><name>co</name></expr>]</index></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>ap</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>inchain</name><index>[<expr><name>co</name></expr>]</index></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>inchain</name><index>[<expr><name>co</name></expr>]</index></name><operator>.</operator><name>ss</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>	<comment type="block">/* paranoia */</comment>
	</block_content>}</block></while>
	<expr_stmt><expr><name><name>ss</name><operator>-&gt;</operator><name>ins</name><operator>.</operator><name>ss</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<comment type="block">/* take it off the inarc chains of the ssets reached by its outarcs */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>d</name><operator>-&gt;</operator><name>ncolors</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><name>p</name> <operator>=</operator> <name><name>ss</name><operator>-&gt;</operator><name>outs</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>p</name> <operator>!=</operator> <name>ss</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>		<comment type="block">/* not self-referential */</comment>
		<if_stmt><if>if <condition>(<expr><name>p</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>			<comment type="block">/* NOTE CONTINUE */</comment>
		<expr_stmt><expr><call><name>FDEBUG</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"del outarc %d from c%d's in chn\n"</literal><operator>,</operator> <name>i</name><operator>,</operator> <operator>(</operator><name>int</name><operator>)</operator> <operator>(</operator><name>p</name> <operator>-</operator> <name><name>d</name><operator>-&gt;</operator><name>ssets</name></name><operator>)</operator><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>p</name><operator>-&gt;</operator><name>ins</name><operator>.</operator><name>ss</name></name> <operator>==</operator> <name>ss</name> <operator>&amp;&amp;</operator> <name><name>p</name><operator>-&gt;</operator><name>ins</name><operator>.</operator><name>co</name></name> <operator>==</operator> <name>i</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>ins</name></name> <operator>=</operator> <name><name>ss</name><operator>-&gt;</operator><name>inchain</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></if>
		<else>else
		<block>{<block_content>
			<decl_stmt><decl><type><name><name>struct</name> <name>arcp</name></name></type> <name>lastap</name> <init>= <expr><block>{<expr><name>NULL</name></expr>, <expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>ins</name><operator>.</operator><name>ss</name></name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<for>for <control>(<init><expr><name>ap</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>ins</name></name></expr>;</init> <condition><expr><name><name>ap</name><operator>.</operator><name>ss</name></name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator>
				 <operator>!</operator><operator>(</operator><name><name>ap</name><operator>.</operator><name>ss</name></name> <operator>==</operator> <name>ss</name> <operator>&amp;&amp;</operator> <name><name>ap</name><operator>.</operator><name>co</name></name> <operator>==</operator> <name>i</name><operator>)</operator></expr>;</condition>
				 <incr><expr><name>ap</name> <operator>=</operator> <name><name>ap</name><operator>.</operator><name>ss</name><operator>-&gt;</operator><name>inchain</name><index>[<expr><name><name>ap</name><operator>.</operator><name>co</name></name></expr>]</index></name></expr></incr>)</control><block type="pseudo"><block_content>
				<expr_stmt><expr><name>lastap</name> <operator>=</operator> <name>ap</name></expr>;</expr_stmt></block_content></block></for>
			<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>ap</name><operator>.</operator><name>ss</name></name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>lastap</name><operator>.</operator><name>ss</name><operator>-&gt;</operator><name>inchain</name><index>[<expr><name><name>lastap</name><operator>.</operator><name>co</name></name></expr>]</index></name> <operator>=</operator> <name><name>ss</name><operator>-&gt;</operator><name>inchain</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
		<expr_stmt><expr><name><name>ss</name><operator>-&gt;</operator><name>outs</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>ss</name><operator>-&gt;</operator><name>inchain</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>ss</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	</block_content>}</block></for>

	<comment type="block">/* if ss was a success state, may need to remember location */</comment>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>ss</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>POSTSTATE</name><operator>)</operator> <operator>&amp;&amp;</operator> <name><name>ss</name><operator>-&gt;</operator><name>lastseen</name></name> <operator>!=</operator> <name><name>d</name><operator>-&gt;</operator><name>lastpost</name></name> <operator>&amp;&amp;</operator>
		<operator>(</operator><name><name>d</name><operator>-&gt;</operator><name>lastpost</name></name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name><name>d</name><operator>-&gt;</operator><name>lastpost</name></name> <operator>&lt;</operator> <name><name>ss</name><operator>-&gt;</operator><name>lastseen</name></name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>d</name><operator>-&gt;</operator><name>lastpost</name></name> <operator>=</operator> <name><name>ss</name><operator>-&gt;</operator><name>lastseen</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* likewise for a no-progress state */</comment>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>ss</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>NOPROGRESS</name><operator>)</operator> <operator>&amp;&amp;</operator> <name><name>ss</name><operator>-&gt;</operator><name>lastseen</name></name> <operator>!=</operator> <name><name>d</name><operator>-&gt;</operator><name>lastnopr</name></name> <operator>&amp;&amp;</operator>
		<operator>(</operator><name><name>d</name><operator>-&gt;</operator><name>lastnopr</name></name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name><name>d</name><operator>-&gt;</operator><name>lastnopr</name></name> <operator>&lt;</operator> <name><name>ss</name><operator>-&gt;</operator><name>lastseen</name></name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>d</name><operator>-&gt;</operator><name>lastnopr</name></name> <operator>=</operator> <name><name>ss</name><operator>-&gt;</operator><name>lastseen</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>ss</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * pickss - pick the next stateset to be used
 */</comment>
<function><type><specifier>static</specifier> <name><name>struct</name> <name>sset</name></name> <modifier>*</modifier></type>
<name>pickss</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>vars</name></name> <modifier>*</modifier></type><name>v</name></decl></parameter>,
	   <parameter><decl><type><name><name>struct</name> <name>dfa</name></name> <modifier>*</modifier></type><name>d</name></decl></parameter>,
	   <parameter><decl><type><name>chr</name> <modifier>*</modifier></type><name>cp</name></decl></parameter>,
	   <parameter><decl><type><name>chr</name> <modifier>*</modifier></type><name>start</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>sset</name></name> <modifier>*</modifier></type><name>ss</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>sset</name></name> <modifier>*</modifier></type><name>end</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>chr</name>		   <modifier>*</modifier></type><name>ancient</name></decl>;</decl_stmt>

	<comment type="block">/* shortcut for cases where cache isn't full */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>d</name><operator>-&gt;</operator><name>nssused</name></name> <operator>&lt;</operator> <name><name>d</name><operator>-&gt;</operator><name>nssets</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>i</name> <operator>=</operator> <name><name>d</name><operator>-&gt;</operator><name>nssused</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>d</name><operator>-&gt;</operator><name>nssused</name></name><operator>++</operator></expr>;</expr_stmt>
		<expr_stmt><expr><name>ss</name> <operator>=</operator> <operator>&amp;</operator><name><name>d</name><operator>-&gt;</operator><name>ssets</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>FDEBUG</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"new c%d\n"</literal><operator>,</operator> <name>i</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* set up innards */</comment>
		<expr_stmt><expr><name><name>ss</name><operator>-&gt;</operator><name>states</name></name> <operator>=</operator> <operator>&amp;</operator><name><name>d</name><operator>-&gt;</operator><name>statesarea</name><index>[<expr><name>i</name> <operator>*</operator> <name><name>d</name><operator>-&gt;</operator><name>wordsper</name></name></expr>]</index></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>ss</name><operator>-&gt;</operator><name>flags</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>ss</name><operator>-&gt;</operator><name>ins</name><operator>.</operator><name>ss</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>ss</name><operator>-&gt;</operator><name>ins</name><operator>.</operator><name>co</name></name> <operator>=</operator> <name>WHITE</name></expr>;</expr_stmt>		<comment type="block">/* give it some value */</comment>
		<expr_stmt><expr><name><name>ss</name><operator>-&gt;</operator><name>outs</name></name> <operator>=</operator> <operator>&amp;</operator><name><name>d</name><operator>-&gt;</operator><name>outsarea</name><index>[<expr><name>i</name> <operator>*</operator> <name><name>d</name><operator>-&gt;</operator><name>ncolors</name></name></expr>]</index></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>ss</name><operator>-&gt;</operator><name>inchain</name></name> <operator>=</operator> <operator>&amp;</operator><name><name>d</name><operator>-&gt;</operator><name>incarea</name><index>[<expr><name>i</name> <operator>*</operator> <name><name>d</name><operator>-&gt;</operator><name>ncolors</name></name></expr>]</index></name></expr>;</expr_stmt>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>d</name><operator>-&gt;</operator><name>ncolors</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<expr_stmt><expr><name><name>ss</name><operator>-&gt;</operator><name>outs</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>ss</name><operator>-&gt;</operator><name>inchain</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>ss</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		</block_content>}</block></for>
		<return>return <expr><name>ss</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* look for oldest, or old enough anyway */</comment>
	<if_stmt><if>if <condition>(<expr><name>cp</name> <operator>-</operator> <name>start</name> <operator>&gt;</operator> <name><name>d</name><operator>-&gt;</operator><name>nssets</name></name> <operator>*</operator> <literal type="number">2</literal> <operator>/</operator> <literal type="number">3</literal></expr>)</condition><block type="pseudo"><block_content> <comment type="block">/* oldest 33% are expendable */</comment>
		<expr_stmt><expr><name>ancient</name> <operator>=</operator> <name>cp</name> <operator>-</operator> <name><name>d</name><operator>-&gt;</operator><name>nssets</name></name> <operator>*</operator> <literal type="number">2</literal> <operator>/</operator> <literal type="number">3</literal></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>ancient</name> <operator>=</operator> <name>start</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
	<for>for <control>(<init><expr><name>ss</name> <operator>=</operator> <name><name>d</name><operator>-&gt;</operator><name>search</name></name></expr><operator>,</operator> <expr><name>end</name> <operator>=</operator> <operator>&amp;</operator><name><name>d</name><operator>-&gt;</operator><name>ssets</name><index>[<expr><name><name>d</name><operator>-&gt;</operator><name>nssets</name></name></expr>]</index></name></expr>;</init> <condition><expr><name>ss</name> <operator>&lt;</operator> <name>end</name></expr>;</condition> <incr><expr><name>ss</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
		<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>ss</name><operator>-&gt;</operator><name>lastseen</name></name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name><name>ss</name><operator>-&gt;</operator><name>lastseen</name></name> <operator>&lt;</operator> <name>ancient</name><operator>)</operator> <operator>&amp;&amp;</operator>
			<operator>!</operator><operator>(</operator><name><name>ss</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>LOCKED</name><operator>)</operator></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>d</name><operator>-&gt;</operator><name>search</name></name> <operator>=</operator> <name>ss</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>FDEBUG</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"replacing c%d\n"</literal><operator>,</operator> <operator>(</operator><name>int</name><operator>)</operator> <operator>(</operator><name>ss</name> <operator>-</operator> <name><name>d</name><operator>-&gt;</operator><name>ssets</name></name><operator>)</operator><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>ss</name></expr>;</return>
		</block_content>}</block></if></if_stmt></block_content></block></for>
	<for>for <control>(<init><expr><name>ss</name> <operator>=</operator> <name><name>d</name><operator>-&gt;</operator><name>ssets</name></name></expr><operator>,</operator> <expr><name>end</name> <operator>=</operator> <name><name>d</name><operator>-&gt;</operator><name>search</name></name></expr>;</init> <condition><expr><name>ss</name> <operator>&lt;</operator> <name>end</name></expr>;</condition> <incr><expr><name>ss</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
		<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>ss</name><operator>-&gt;</operator><name>lastseen</name></name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name><name>ss</name><operator>-&gt;</operator><name>lastseen</name></name> <operator>&lt;</operator> <name>ancient</name><operator>)</operator> <operator>&amp;&amp;</operator>
			<operator>!</operator><operator>(</operator><name><name>ss</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>LOCKED</name><operator>)</operator></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>d</name><operator>-&gt;</operator><name>search</name></name> <operator>=</operator> <name>ss</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>FDEBUG</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"replacing c%d\n"</literal><operator>,</operator> <operator>(</operator><name>int</name><operator>)</operator> <operator>(</operator><name>ss</name> <operator>-</operator> <name><name>d</name><operator>-&gt;</operator><name>ssets</name></name><operator>)</operator><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>ss</name></expr>;</return>
		</block_content>}</block></if></if_stmt></block_content></block></for>

	<comment type="block">/* nobody's old enough?!? -- something's really wrong */</comment>
	<expr_stmt><expr><call><name>FDEBUG</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"cannot find victim to replace!\n"</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ERR</name><argument_list>(<argument><expr><name>REG_ASSERT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>
</unit>
