<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/PolarDB-for-PostgreSQL/src/backend/rewrite/rewriteManip.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * rewriteManip.c
 *
 * Portions Copyright (c) 1996-2018, PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, Regents of the University of California
 *
 *
 * IDENTIFICATION
 *	  src/backend/rewrite/rewriteManip.c
 *
 *-------------------------------------------------------------------------
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_type.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/makefuncs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/nodeFuncs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/plannodes.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/clauses.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parse_coerce.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parse_relation.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parsetree.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"rewrite/rewriteManip.h"</cpp:file></cpp:include>


<typedef>typedef <type><struct>struct
<block>{
	<decl_stmt><decl><type><name>int</name></type>			<name>sublevels_up</name></decl>;</decl_stmt>
}</block></struct></type> <name>contain_aggs_of_level_context</name>;</typedef>

<typedef>typedef <type><struct>struct
<block>{
	<decl_stmt><decl><type><name>int</name></type>			<name>agg_location</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>sublevels_up</name></decl>;</decl_stmt>
}</block></struct></type> <name>locate_agg_of_level_context</name>;</typedef>

<typedef>typedef <type><struct>struct
<block>{
	<decl_stmt><decl><type><name>int</name></type>			<name>win_location</name></decl>;</decl_stmt>
}</block></struct></type> <name>locate_windowfunc_context</name>;</typedef>

<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>contain_aggs_of_level_walker</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>,
							 <parameter><decl><type><name>contain_aggs_of_level_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>locate_agg_of_level_walker</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>,
						   <parameter><decl><type><name>locate_agg_of_level_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>contain_windowfuncs_walker</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>locate_windowfunc_walker</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>,
						 <parameter><decl><type><name>locate_windowfunc_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>checkExprHasSubLink_walker</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Relids</name></type> <name>offset_relid_set</name><parameter_list>(<parameter><decl><type><name>Relids</name></type> <name>relids</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>offset</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Relids</name></type> <name>adjust_relid_set</name><parameter_list>(<parameter><decl><type><name>Relids</name></type> <name>relids</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>oldrelid</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>newrelid</name></decl></parameter>)</parameter_list>;</function_decl>


<comment type="block">/*
 * contain_aggs_of_level -
 *	Check if an expression contains an aggregate function call of a
 *	specified query level.
 *
 * The objective of this routine is to detect whether there are aggregates
 * belonging to the given query level.  Aggregates belonging to subqueries
 * or outer queries do NOT cause a true result.  We must recurse into
 * subqueries to detect outer-reference aggregates that logically belong to
 * the specified query level.
 */</comment>
<function><type><name>bool</name></type>
<name>contain_aggs_of_level</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>levelsup</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>contain_aggs_of_level_context</name></type> <name>context</name></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>context</name><operator>.</operator><name>sublevels_up</name></name> <operator>=</operator> <name>levelsup</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Must be prepared to start with a Query or a bare expression tree; if
	 * it's a Query, we don't want to increment sublevels_up.
	 */</comment>
	<return>return <expr><call><name>query_or_expression_tree_walker</name><argument_list>(<argument><expr><name>node</name></expr></argument>,
										   <argument><expr><name>contain_aggs_of_level_walker</name></expr></argument>,
										   <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>context</name></expr></argument>,
										   <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>contain_aggs_of_level_walker</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>,
							 <parameter><decl><type><name>contain_aggs_of_level_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>node</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>Aggref</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>(</operator><operator>(</operator><name>Aggref</name> <operator>*</operator><operator>)</operator> <name>node</name><operator>)</operator><operator>-&gt;</operator><name>agglevelsup</name> <operator>==</operator> <name><name>context</name><operator>-&gt;</operator><name>sublevels_up</name></name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>		<comment type="block">/* abort the tree traversal and return true */</comment>
		<comment type="block">/* else fall through to examine argument */</comment>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>GroupingFunc</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>(</operator><operator>(</operator><name>GroupingFunc</name> <operator>*</operator><operator>)</operator> <name>node</name><operator>)</operator><operator>-&gt;</operator><name>agglevelsup</name> <operator>==</operator> <name><name>context</name><operator>-&gt;</operator><name>sublevels_up</name></name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
		<comment type="block">/* else fall through to examine argument */</comment>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>Query</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Recurse into subselects */</comment>
		<decl_stmt><decl><type><name>bool</name></type>		<name>result</name></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>sublevels_up</name></name><operator>++</operator></expr>;</expr_stmt>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>query_tree_walker</name><argument_list>(<argument><expr><operator>(</operator><name>Query</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>,
								   <argument><expr><name>contain_aggs_of_level_walker</name></expr></argument>,
								   <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>context</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>sublevels_up</name></name><operator>--</operator></expr>;</expr_stmt>
		<return>return <expr><name>result</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><call><name>expression_tree_walker</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>contain_aggs_of_level_walker</name></expr></argument>,
								  <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>context</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * locate_agg_of_level -
 *	  Find the parse location of any aggregate of the specified query level.
 *
 * Returns -1 if no such agg is in the querytree, or if they all have
 * unknown parse location.  (The former case is probably caller error,
 * but we don't bother to distinguish it from the latter case.)
 *
 * Note: it might seem appropriate to merge this functionality into
 * contain_aggs_of_level, but that would complicate that function's API.
 * Currently, the only uses of this function are for error reporting,
 * and so shaving cycles probably isn't very important.
 */</comment>
<function><type><name>int</name></type>
<name>locate_agg_of_level</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>levelsup</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>locate_agg_of_level_context</name></type> <name>context</name></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>context</name><operator>.</operator><name>agg_location</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>	<comment type="block">/* in case we find nothing */</comment>
	<expr_stmt><expr><name><name>context</name><operator>.</operator><name>sublevels_up</name></name> <operator>=</operator> <name>levelsup</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Must be prepared to start with a Query or a bare expression tree; if
	 * it's a Query, we don't want to increment sublevels_up.
	 */</comment>
	<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>query_or_expression_tree_walker</name><argument_list>(<argument><expr><name>node</name></expr></argument>,
										   <argument><expr><name>locate_agg_of_level_walker</name></expr></argument>,
										   <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>context</name></expr></argument>,
										   <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name><name>context</name><operator>.</operator><name>agg_location</name></name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>locate_agg_of_level_walker</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>,
						   <parameter><decl><type><name>locate_agg_of_level_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>node</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>Aggref</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>(</operator><operator>(</operator><name>Aggref</name> <operator>*</operator><operator>)</operator> <name>node</name><operator>)</operator><operator>-&gt;</operator><name>agglevelsup</name> <operator>==</operator> <name><name>context</name><operator>-&gt;</operator><name>sublevels_up</name></name> <operator>&amp;&amp;</operator>
			<operator>(</operator><operator>(</operator><name>Aggref</name> <operator>*</operator><operator>)</operator> <name>node</name><operator>)</operator><operator>-&gt;</operator><name>location</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>agg_location</name></name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>Aggref</name> <operator>*</operator><operator>)</operator> <name>node</name><operator>)</operator><operator>-&gt;</operator><name>location</name></expr>;</expr_stmt>
			<return>return <expr><name>true</name></expr>;</return>		<comment type="block">/* abort the tree traversal and return true */</comment>
		</block_content>}</block></if></if_stmt>
		<comment type="block">/* else fall through to examine argument */</comment>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>GroupingFunc</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>(</operator><operator>(</operator><name>GroupingFunc</name> <operator>*</operator><operator>)</operator> <name>node</name><operator>)</operator><operator>-&gt;</operator><name>agglevelsup</name> <operator>==</operator> <name><name>context</name><operator>-&gt;</operator><name>sublevels_up</name></name> <operator>&amp;&amp;</operator>
			<operator>(</operator><operator>(</operator><name>GroupingFunc</name> <operator>*</operator><operator>)</operator> <name>node</name><operator>)</operator><operator>-&gt;</operator><name>location</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>agg_location</name></name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>GroupingFunc</name> <operator>*</operator><operator>)</operator> <name>node</name><operator>)</operator><operator>-&gt;</operator><name>location</name></expr>;</expr_stmt>
			<return>return <expr><name>true</name></expr>;</return>		<comment type="block">/* abort the tree traversal and return true */</comment>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>Query</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Recurse into subselects */</comment>
		<decl_stmt><decl><type><name>bool</name></type>		<name>result</name></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>sublevels_up</name></name><operator>++</operator></expr>;</expr_stmt>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>query_tree_walker</name><argument_list>(<argument><expr><operator>(</operator><name>Query</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>,
								   <argument><expr><name>locate_agg_of_level_walker</name></expr></argument>,
								   <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>context</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>sublevels_up</name></name><operator>--</operator></expr>;</expr_stmt>
		<return>return <expr><name>result</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><call><name>expression_tree_walker</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>locate_agg_of_level_walker</name></expr></argument>,
								  <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>context</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * contain_windowfuncs -
 *	Check if an expression contains a window function call of the
 *	current query level.
 */</comment>
<function><type><name>bool</name></type>
<name>contain_windowfuncs</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * Must be prepared to start with a Query or a bare expression tree; if
	 * it's a Query, we don't want to increment sublevels_up.
	 */</comment>
	<return>return <expr><call><name>query_or_expression_tree_walker</name><argument_list>(<argument><expr><name>node</name></expr></argument>,
										   <argument><expr><name>contain_windowfuncs_walker</name></expr></argument>,
										   <argument><expr><name>NULL</name></expr></argument>,
										   <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>contain_windowfuncs_walker</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>node</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>WindowFunc</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>			<comment type="block">/* abort the tree traversal and return true */</comment>
	<comment type="block">/* Mustn't recurse into subselects */</comment>
	<return>return <expr><call><name>expression_tree_walker</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>contain_windowfuncs_walker</name></expr></argument>,
								  <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>context</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * locate_windowfunc -
 *	  Find the parse location of any windowfunc of the current query level.
 *
 * Returns -1 if no such windowfunc is in the querytree, or if they all have
 * unknown parse location.  (The former case is probably caller error,
 * but we don't bother to distinguish it from the latter case.)
 *
 * Note: it might seem appropriate to merge this functionality into
 * contain_windowfuncs, but that would complicate that function's API.
 * Currently, the only uses of this function are for error reporting,
 * and so shaving cycles probably isn't very important.
 */</comment>
<function><type><name>int</name></type>
<name>locate_windowfunc</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>locate_windowfunc_context</name></type> <name>context</name></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>context</name><operator>.</operator><name>win_location</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>	<comment type="block">/* in case we find nothing */</comment>

	<comment type="block">/*
	 * Must be prepared to start with a Query or a bare expression tree; if
	 * it's a Query, we don't want to increment sublevels_up.
	 */</comment>
	<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>query_or_expression_tree_walker</name><argument_list>(<argument><expr><name>node</name></expr></argument>,
										   <argument><expr><name>locate_windowfunc_walker</name></expr></argument>,
										   <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>context</name></expr></argument>,
										   <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name><name>context</name><operator>.</operator><name>win_location</name></name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>locate_windowfunc_walker</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>locate_windowfunc_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>node</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>WindowFunc</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>(</operator><operator>(</operator><name>WindowFunc</name> <operator>*</operator><operator>)</operator> <name>node</name><operator>)</operator><operator>-&gt;</operator><name>location</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>win_location</name></name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>WindowFunc</name> <operator>*</operator><operator>)</operator> <name>node</name><operator>)</operator><operator>-&gt;</operator><name>location</name></expr>;</expr_stmt>
			<return>return <expr><name>true</name></expr>;</return>		<comment type="block">/* abort the tree traversal and return true */</comment>
		</block_content>}</block></if></if_stmt>
		<comment type="block">/* else fall through to examine argument */</comment>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* Mustn't recurse into subselects */</comment>
	<return>return <expr><call><name>expression_tree_walker</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>locate_windowfunc_walker</name></expr></argument>,
								  <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>context</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * checkExprHasSubLink -
 *	Check if an expression contains a SubLink.
 */</comment>
<function><type><name>bool</name></type>
<name>checkExprHasSubLink</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * If a Query is passed, examine it --- but we should not recurse into
	 * sub-Queries that are in its rangetable or CTE list.
	 */</comment>
	<return>return <expr><call><name>query_or_expression_tree_walker</name><argument_list>(<argument><expr><name>node</name></expr></argument>,
										   <argument><expr><name>checkExprHasSubLink_walker</name></expr></argument>,
										   <argument><expr><name>NULL</name></expr></argument>,
										   <argument><expr><name>QTW_IGNORE_RC_SUBQUERIES</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>checkExprHasSubLink_walker</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>node</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>SubLink</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>			<comment type="block">/* abort the tree traversal and return true */</comment>
	<return>return <expr><call><name>expression_tree_walker</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>checkExprHasSubLink_walker</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Check for MULTIEXPR Param within expression tree
 *
 * We intentionally don't descend into SubLinks: only Params at the current
 * query level are of interest.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>contains_multiexpr_param</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>node</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>Param</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>(</operator><operator>(</operator><name>Param</name> <operator>*</operator><operator>)</operator> <name>node</name><operator>)</operator><operator>-&gt;</operator><name>paramkind</name> <operator>==</operator> <name>PARAM_MULTIEXPR</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>		<comment type="block">/* abort the tree traversal and return true */</comment>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><call><name>expression_tree_walker</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>contains_multiexpr_param</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * OffsetVarNodes - adjust Vars when appending one query's RT to another
 *
 * Find all Var nodes in the given tree with varlevelsup == sublevels_up,
 * and increment their varno fields (rangetable indexes) by 'offset'.
 * The varnoold fields are adjusted similarly.  Also, adjust other nodes
 * that contain rangetable indexes, such as RangeTblRef and JoinExpr.
 *
 * NOTE: although this has the form of a walker, we cheat and modify the
 * nodes in-place.  The given expression tree should have been copied
 * earlier to ensure that no unwanted side-effects occur!
 */</comment>

<typedef>typedef <type><struct>struct
<block>{
	<decl_stmt><decl><type><name>int</name></type>			<name>offset</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>sublevels_up</name></decl>;</decl_stmt>
}</block></struct></type> <name>OffsetVarNodes_context</name>;</typedef>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>OffsetVarNodes_walker</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>OffsetVarNodes_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>node</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>Var</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Var</name>		   <modifier>*</modifier></type><name>var</name> <init>= <expr><operator>(</operator><name>Var</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>var</name><operator>-&gt;</operator><name>varlevelsup</name></name> <operator>==</operator> <name><name>context</name><operator>-&gt;</operator><name>sublevels_up</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>var</name><operator>-&gt;</operator><name>varno</name></name> <operator>+=</operator> <name><name>context</name><operator>-&gt;</operator><name>offset</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>var</name><operator>-&gt;</operator><name>varnoold</name></name> <operator>+=</operator> <name><name>context</name><operator>-&gt;</operator><name>offset</name></name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>CurrentOfExpr</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>CurrentOfExpr</name> <modifier>*</modifier></type><name>cexpr</name> <init>= <expr><operator>(</operator><name>CurrentOfExpr</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>context</name><operator>-&gt;</operator><name>sublevels_up</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>cexpr</name><operator>-&gt;</operator><name>cvarno</name></name> <operator>+=</operator> <name><name>context</name><operator>-&gt;</operator><name>offset</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>RangeTblRef</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>RangeTblRef</name> <modifier>*</modifier></type><name>rtr</name> <init>= <expr><operator>(</operator><name>RangeTblRef</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>context</name><operator>-&gt;</operator><name>sublevels_up</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>rtr</name><operator>-&gt;</operator><name>rtindex</name></name> <operator>+=</operator> <name><name>context</name><operator>-&gt;</operator><name>offset</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<comment type="block">/* the subquery itself is visited separately */</comment>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>JoinExpr</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>JoinExpr</name>   <modifier>*</modifier></type><name>j</name> <init>= <expr><operator>(</operator><name>JoinExpr</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>j</name><operator>-&gt;</operator><name>rtindex</name></name> <operator>&amp;&amp;</operator> <name><name>context</name><operator>-&gt;</operator><name>sublevels_up</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>j</name><operator>-&gt;</operator><name>rtindex</name></name> <operator>+=</operator> <name><name>context</name><operator>-&gt;</operator><name>offset</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<comment type="block">/* fall through to examine children */</comment>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>PlaceHolderVar</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>PlaceHolderVar</name> <modifier>*</modifier></type><name>phv</name> <init>= <expr><operator>(</operator><name>PlaceHolderVar</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>phv</name><operator>-&gt;</operator><name>phlevelsup</name></name> <operator>==</operator> <name><name>context</name><operator>-&gt;</operator><name>sublevels_up</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>phv</name><operator>-&gt;</operator><name>phrels</name></name> <operator>=</operator> <call><name>offset_relid_set</name><argument_list>(<argument><expr><name><name>phv</name><operator>-&gt;</operator><name>phrels</name></name></expr></argument>,
										   <argument><expr><name><name>context</name><operator>-&gt;</operator><name>offset</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<comment type="block">/* fall through to examine children */</comment>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>AppendRelInfo</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>AppendRelInfo</name> <modifier>*</modifier></type><name>appinfo</name> <init>= <expr><operator>(</operator><name>AppendRelInfo</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>context</name><operator>-&gt;</operator><name>sublevels_up</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>appinfo</name><operator>-&gt;</operator><name>parent_relid</name></name> <operator>+=</operator> <name><name>context</name><operator>-&gt;</operator><name>offset</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>appinfo</name><operator>-&gt;</operator><name>child_relid</name></name> <operator>+=</operator> <name><name>context</name><operator>-&gt;</operator><name>offset</name></name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<comment type="block">/* fall through to examine children */</comment>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* Shouldn't need to handle other planner auxiliary nodes here */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>PlanRowMark</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>SpecialJoinInfo</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>PlaceHolderInfo</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>MinMaxAggInfo</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>Query</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Recurse into subselects */</comment>
		<decl_stmt><decl><type><name>bool</name></type>		<name>result</name></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>sublevels_up</name></name><operator>++</operator></expr>;</expr_stmt>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>query_tree_walker</name><argument_list>(<argument><expr><operator>(</operator><name>Query</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>, <argument><expr><name>OffsetVarNodes_walker</name></expr></argument>,
								   <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>context</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>sublevels_up</name></name><operator>--</operator></expr>;</expr_stmt>
		<return>return <expr><name>result</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><call><name>expression_tree_walker</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>OffsetVarNodes_walker</name></expr></argument>,
								  <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>context</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>OffsetVarNodes</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>offset</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>sublevels_up</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>OffsetVarNodes_context</name></type> <name>context</name></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>context</name><operator>.</operator><name>offset</name></name> <operator>=</operator> <name>offset</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>context</name><operator>.</operator><name>sublevels_up</name></name> <operator>=</operator> <name>sublevels_up</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Must be prepared to start with a Query or a bare expression tree; if
	 * it's a Query, go straight to query_tree_walker to make sure that
	 * sublevels_up doesn't get incremented prematurely.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>node</name> <operator>&amp;&amp;</operator> <call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>Query</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Query</name>	   <modifier>*</modifier></type><name>qry</name> <init>= <expr><operator>(</operator><name>Query</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

		<comment type="block">/*
		 * If we are starting at a Query, and sublevels_up is zero, then we
		 * must also fix rangetable indexes in the Query itself --- namely
		 * resultRelation, exclRelIndex and rowMarks entries.  sublevels_up
		 * cannot be zero when recursing into a subquery, so there's no need
		 * to have the same logic inside OffsetVarNodes_walker.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>sublevels_up</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>qry</name><operator>-&gt;</operator><name>resultRelation</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>qry</name><operator>-&gt;</operator><name>resultRelation</name></name> <operator>+=</operator> <name>offset</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>qry</name><operator>-&gt;</operator><name>onConflict</name></name> <operator>&amp;&amp;</operator> <name><name>qry</name><operator>-&gt;</operator><name>onConflict</name><operator>-&gt;</operator><name>exclRelIndex</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>qry</name><operator>-&gt;</operator><name>onConflict</name><operator>-&gt;</operator><name>exclRelIndex</name></name> <operator>+=</operator> <name>offset</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>qry-&gt;rowMarks</argument>)</argument_list></macro>
			<block>{<block_content>
				<decl_stmt><decl><type><name>RowMarkClause</name> <modifier>*</modifier></type><name>rc</name> <init>= <expr><operator>(</operator><name>RowMarkClause</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><name><name>rc</name><operator>-&gt;</operator><name>rti</name></name> <operator>+=</operator> <name>offset</name></expr>;</expr_stmt>
			</block_content>}</block>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><call><name>query_tree_walker</name><argument_list>(<argument><expr><name>qry</name></expr></argument>, <argument><expr><name>OffsetVarNodes_walker</name></expr></argument>,
						  <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>context</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>OffsetVarNodes_walker</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>Relids</name></type>
<name>offset_relid_set</name><parameter_list>(<parameter><decl><type><name>Relids</name></type> <name>relids</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>offset</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Relids</name></type>		<name>result</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>rtindex</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>rtindex</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
	<while>while <condition>(<expr><operator>(</operator><name>rtindex</name> <operator>=</operator> <call><name>bms_next_member</name><argument_list>(<argument><expr><name>relids</name></expr></argument>, <argument><expr><name>rtindex</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>bms_add_member</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>rtindex</name> <operator>+</operator> <name>offset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></while>
	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * ChangeVarNodes - adjust Var nodes for a specific change of RT index
 *
 * Find all Var nodes in the given tree belonging to a specific relation
 * (identified by sublevels_up and rt_index), and change their varno fields
 * to 'new_index'.  The varnoold fields are changed too.  Also, adjust other
 * nodes that contain rangetable indexes, such as RangeTblRef and JoinExpr.
 *
 * NOTE: although this has the form of a walker, we cheat and modify the
 * nodes in-place.  The given expression tree should have been copied
 * earlier to ensure that no unwanted side-effects occur!
 */</comment>

<typedef>typedef <type><struct>struct
<block>{
	<decl_stmt><decl><type><name>int</name></type>			<name>rt_index</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>new_index</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>sublevels_up</name></decl>;</decl_stmt>
}</block></struct></type> <name>ChangeVarNodes_context</name>;</typedef>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>ChangeVarNodes_walker</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>ChangeVarNodes_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>node</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>Var</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Var</name>		   <modifier>*</modifier></type><name>var</name> <init>= <expr><operator>(</operator><name>Var</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>var</name><operator>-&gt;</operator><name>varlevelsup</name></name> <operator>==</operator> <name><name>context</name><operator>-&gt;</operator><name>sublevels_up</name></name> <operator>&amp;&amp;</operator>
			<name><name>var</name><operator>-&gt;</operator><name>varno</name></name> <operator>==</operator> <name><name>context</name><operator>-&gt;</operator><name>rt_index</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>var</name><operator>-&gt;</operator><name>varno</name></name> <operator>=</operator> <name><name>context</name><operator>-&gt;</operator><name>new_index</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>var</name><operator>-&gt;</operator><name>varnoold</name></name> <operator>=</operator> <name><name>context</name><operator>-&gt;</operator><name>new_index</name></name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>CurrentOfExpr</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>CurrentOfExpr</name> <modifier>*</modifier></type><name>cexpr</name> <init>= <expr><operator>(</operator><name>CurrentOfExpr</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>context</name><operator>-&gt;</operator><name>sublevels_up</name></name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
			<name><name>cexpr</name><operator>-&gt;</operator><name>cvarno</name></name> <operator>==</operator> <name><name>context</name><operator>-&gt;</operator><name>rt_index</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>cexpr</name><operator>-&gt;</operator><name>cvarno</name></name> <operator>=</operator> <name><name>context</name><operator>-&gt;</operator><name>new_index</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>RangeTblRef</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>RangeTblRef</name> <modifier>*</modifier></type><name>rtr</name> <init>= <expr><operator>(</operator><name>RangeTblRef</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>context</name><operator>-&gt;</operator><name>sublevels_up</name></name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
			<name><name>rtr</name><operator>-&gt;</operator><name>rtindex</name></name> <operator>==</operator> <name><name>context</name><operator>-&gt;</operator><name>rt_index</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>rtr</name><operator>-&gt;</operator><name>rtindex</name></name> <operator>=</operator> <name><name>context</name><operator>-&gt;</operator><name>new_index</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<comment type="block">/* the subquery itself is visited separately */</comment>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>JoinExpr</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>JoinExpr</name>   <modifier>*</modifier></type><name>j</name> <init>= <expr><operator>(</operator><name>JoinExpr</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>context</name><operator>-&gt;</operator><name>sublevels_up</name></name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
			<name><name>j</name><operator>-&gt;</operator><name>rtindex</name></name> <operator>==</operator> <name><name>context</name><operator>-&gt;</operator><name>rt_index</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>j</name><operator>-&gt;</operator><name>rtindex</name></name> <operator>=</operator> <name><name>context</name><operator>-&gt;</operator><name>new_index</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<comment type="block">/* fall through to examine children */</comment>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>PlaceHolderVar</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>PlaceHolderVar</name> <modifier>*</modifier></type><name>phv</name> <init>= <expr><operator>(</operator><name>PlaceHolderVar</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>phv</name><operator>-&gt;</operator><name>phlevelsup</name></name> <operator>==</operator> <name><name>context</name><operator>-&gt;</operator><name>sublevels_up</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>phv</name><operator>-&gt;</operator><name>phrels</name></name> <operator>=</operator> <call><name>adjust_relid_set</name><argument_list>(<argument><expr><name><name>phv</name><operator>-&gt;</operator><name>phrels</name></name></expr></argument>,
										   <argument><expr><name><name>context</name><operator>-&gt;</operator><name>rt_index</name></name></expr></argument>,
										   <argument><expr><name><name>context</name><operator>-&gt;</operator><name>new_index</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<comment type="block">/* fall through to examine children */</comment>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>PlanRowMark</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>PlanRowMark</name> <modifier>*</modifier></type><name>rowmark</name> <init>= <expr><operator>(</operator><name>PlanRowMark</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>context</name><operator>-&gt;</operator><name>sublevels_up</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name><name>rowmark</name><operator>-&gt;</operator><name>rti</name></name> <operator>==</operator> <name><name>context</name><operator>-&gt;</operator><name>rt_index</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>rowmark</name><operator>-&gt;</operator><name>rti</name></name> <operator>=</operator> <name><name>context</name><operator>-&gt;</operator><name>new_index</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>rowmark</name><operator>-&gt;</operator><name>prti</name></name> <operator>==</operator> <name><name>context</name><operator>-&gt;</operator><name>rt_index</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>rowmark</name><operator>-&gt;</operator><name>prti</name></name> <operator>=</operator> <name><name>context</name><operator>-&gt;</operator><name>new_index</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>AppendRelInfo</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>AppendRelInfo</name> <modifier>*</modifier></type><name>appinfo</name> <init>= <expr><operator>(</operator><name>AppendRelInfo</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>context</name><operator>-&gt;</operator><name>sublevels_up</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name><name>appinfo</name><operator>-&gt;</operator><name>parent_relid</name></name> <operator>==</operator> <name><name>context</name><operator>-&gt;</operator><name>rt_index</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>appinfo</name><operator>-&gt;</operator><name>parent_relid</name></name> <operator>=</operator> <name><name>context</name><operator>-&gt;</operator><name>new_index</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>appinfo</name><operator>-&gt;</operator><name>child_relid</name></name> <operator>==</operator> <name><name>context</name><operator>-&gt;</operator><name>rt_index</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>appinfo</name><operator>-&gt;</operator><name>child_relid</name></name> <operator>=</operator> <name><name>context</name><operator>-&gt;</operator><name>new_index</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
		<comment type="block">/* fall through to examine children */</comment>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* Shouldn't need to handle other planner auxiliary nodes here */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>SpecialJoinInfo</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>PlaceHolderInfo</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>MinMaxAggInfo</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>Query</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Recurse into subselects */</comment>
		<decl_stmt><decl><type><name>bool</name></type>		<name>result</name></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>sublevels_up</name></name><operator>++</operator></expr>;</expr_stmt>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>query_tree_walker</name><argument_list>(<argument><expr><operator>(</operator><name>Query</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>, <argument><expr><name>ChangeVarNodes_walker</name></expr></argument>,
								   <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>context</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>sublevels_up</name></name><operator>--</operator></expr>;</expr_stmt>
		<return>return <expr><name>result</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><call><name>expression_tree_walker</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>ChangeVarNodes_walker</name></expr></argument>,
								  <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>context</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>ChangeVarNodes</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>rt_index</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>new_index</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>sublevels_up</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ChangeVarNodes_context</name></type> <name>context</name></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>context</name><operator>.</operator><name>rt_index</name></name> <operator>=</operator> <name>rt_index</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>context</name><operator>.</operator><name>new_index</name></name> <operator>=</operator> <name>new_index</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>context</name><operator>.</operator><name>sublevels_up</name></name> <operator>=</operator> <name>sublevels_up</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Must be prepared to start with a Query or a bare expression tree; if
	 * it's a Query, go straight to query_tree_walker to make sure that
	 * sublevels_up doesn't get incremented prematurely.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>node</name> <operator>&amp;&amp;</operator> <call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>Query</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Query</name>	   <modifier>*</modifier></type><name>qry</name> <init>= <expr><operator>(</operator><name>Query</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

		<comment type="block">/*
		 * If we are starting at a Query, and sublevels_up is zero, then we
		 * must also fix rangetable indexes in the Query itself --- namely
		 * resultRelation and rowMarks entries.  sublevels_up cannot be zero
		 * when recursing into a subquery, so there's no need to have the same
		 * logic inside ChangeVarNodes_walker.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>sublevels_up</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>qry</name><operator>-&gt;</operator><name>resultRelation</name></name> <operator>==</operator> <name>rt_index</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>qry</name><operator>-&gt;</operator><name>resultRelation</name></name> <operator>=</operator> <name>new_index</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<comment type="block">/* this is unlikely to ever be used, but ... */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>qry</name><operator>-&gt;</operator><name>onConflict</name></name> <operator>&amp;&amp;</operator> <name><name>qry</name><operator>-&gt;</operator><name>onConflict</name><operator>-&gt;</operator><name>exclRelIndex</name></name> <operator>==</operator> <name>rt_index</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>qry</name><operator>-&gt;</operator><name>onConflict</name><operator>-&gt;</operator><name>exclRelIndex</name></name> <operator>=</operator> <name>new_index</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>qry-&gt;rowMarks</argument>)</argument_list></macro>
			<block>{<block_content>
				<decl_stmt><decl><type><name>RowMarkClause</name> <modifier>*</modifier></type><name>rc</name> <init>= <expr><operator>(</operator><name>RowMarkClause</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><name><name>rc</name><operator>-&gt;</operator><name>rti</name></name> <operator>==</operator> <name>rt_index</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name><name>rc</name><operator>-&gt;</operator><name>rti</name></name> <operator>=</operator> <name>new_index</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><call><name>query_tree_walker</name><argument_list>(<argument><expr><name>qry</name></expr></argument>, <argument><expr><name>ChangeVarNodes_walker</name></expr></argument>,
						  <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>context</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ChangeVarNodes_walker</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Substitute newrelid for oldrelid in a Relid set
 */</comment>
<function><type><specifier>static</specifier> <name>Relids</name></type>
<name>adjust_relid_set</name><parameter_list>(<parameter><decl><type><name>Relids</name></type> <name>relids</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>oldrelid</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>newrelid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><call><name>bms_is_member</name><argument_list>(<argument><expr><name>oldrelid</name></expr></argument>, <argument><expr><name>relids</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Ensure we have a modifiable copy */</comment>
		<expr_stmt><expr><name>relids</name> <operator>=</operator> <call><name>bms_copy</name><argument_list>(<argument><expr><name>relids</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* Remove old, add new */</comment>
		<expr_stmt><expr><name>relids</name> <operator>=</operator> <call><name>bms_del_member</name><argument_list>(<argument><expr><name>relids</name></expr></argument>, <argument><expr><name>oldrelid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>relids</name> <operator>=</operator> <call><name>bms_add_member</name><argument_list>(<argument><expr><name>relids</name></expr></argument>, <argument><expr><name>newrelid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><name>relids</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * IncrementVarSublevelsUp - adjust Var nodes when pushing them down in tree
 *
 * Find all Var nodes in the given tree having varlevelsup &gt;= min_sublevels_up,
 * and add delta_sublevels_up to their varlevelsup value.  This is needed when
 * an expression that's correct for some nesting level is inserted into a
 * subquery.  Ordinarily the initial call has min_sublevels_up == 0 so that
 * all Vars are affected.  The point of min_sublevels_up is that we can
 * increment it when we recurse into a sublink, so that local variables in
 * that sublink are not affected, only outer references to vars that belong
 * to the expression's original query level or parents thereof.
 *
 * Likewise for other nodes containing levelsup fields, such as Aggref.
 *
 * NOTE: although this has the form of a walker, we cheat and modify the
 * Var nodes in-place.  The given expression tree should have been copied
 * earlier to ensure that no unwanted side-effects occur!
 */</comment>

<typedef>typedef <type><struct>struct
<block>{
	<decl_stmt><decl><type><name>int</name></type>			<name>delta_sublevels_up</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>min_sublevels_up</name></decl>;</decl_stmt>
	
	<comment type="block">/* POLAR px
	 * MPP-19436: when a query mixes window function with group by or aggregates,
	 * then a transformation will turn the original structure Q into an outer
	 * query Q' and an inner query Q''
	 * Q -&gt;  Q'
	 *       |
	 *       |-&gt;Q''
	 * All the structures will be copied from Q to Q'' except ctelists.
	 * This causes Q'', and its inner structures, to have dangling cte references, since
	 * ctelists are kept in Q'. In such a case, we need to ignore min_sublevels_up and
	 * increment by delta_sublevels_up.
	 *
	 */</comment>
	<decl_stmt><decl><type><name>bool</name></type>		        <name>ignore_min_sublevels_up</name></decl>;</decl_stmt>
}</block></struct></type> <name>IncrementVarSublevelsUp_context</name>;</typedef>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>IncrementVarSublevelsUp_walker</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>,
							   <parameter><decl><type><name>IncrementVarSublevelsUp_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>node</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>Var</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Var</name>		   <modifier>*</modifier></type><name>var</name> <init>= <expr><operator>(</operator><name>Var</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>var</name><operator>-&gt;</operator><name>varlevelsup</name></name> <operator>&gt;=</operator> <name><name>context</name><operator>-&gt;</operator><name>min_sublevels_up</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>var</name><operator>-&gt;</operator><name>varlevelsup</name></name> <operator>+=</operator> <name><name>context</name><operator>-&gt;</operator><name>delta_sublevels_up</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<return>return <expr><name>false</name></expr>;</return>			<comment type="block">/* done here */</comment>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>CurrentOfExpr</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* this should not happen */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>context</name><operator>-&gt;</operator><name>min_sublevels_up</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cannot push down CurrentOfExpr"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>Aggref</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Aggref</name>	   <modifier>*</modifier></type><name>agg</name> <init>= <expr><operator>(</operator><name>Aggref</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>agg</name><operator>-&gt;</operator><name>agglevelsup</name></name> <operator>&gt;=</operator> <name><name>context</name><operator>-&gt;</operator><name>min_sublevels_up</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>agg</name><operator>-&gt;</operator><name>agglevelsup</name></name> <operator>+=</operator> <name><name>context</name><operator>-&gt;</operator><name>delta_sublevels_up</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<comment type="block">/* fall through to recurse into argument */</comment>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>GroupingFunc</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>GroupingFunc</name> <modifier>*</modifier></type><name>grp</name> <init>= <expr><operator>(</operator><name>GroupingFunc</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>grp</name><operator>-&gt;</operator><name>agglevelsup</name></name> <operator>&gt;=</operator> <name><name>context</name><operator>-&gt;</operator><name>min_sublevels_up</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>grp</name><operator>-&gt;</operator><name>agglevelsup</name></name> <operator>+=</operator> <name><name>context</name><operator>-&gt;</operator><name>delta_sublevels_up</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<comment type="block">/* fall through to recurse into argument */</comment>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>PlaceHolderVar</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>PlaceHolderVar</name> <modifier>*</modifier></type><name>phv</name> <init>= <expr><operator>(</operator><name>PlaceHolderVar</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>phv</name><operator>-&gt;</operator><name>phlevelsup</name></name> <operator>&gt;=</operator> <name><name>context</name><operator>-&gt;</operator><name>min_sublevels_up</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>phv</name><operator>-&gt;</operator><name>phlevelsup</name></name> <operator>+=</operator> <name><name>context</name><operator>-&gt;</operator><name>delta_sublevels_up</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<comment type="block">/* fall through to recurse into argument */</comment>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>RangeTblEntry</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name> <init>= <expr><operator>(</operator><name>RangeTblEntry</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>rte</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>==</operator> <name>RTE_CTE</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name><name>rte</name><operator>-&gt;</operator><name>ctelevelsup</name></name> <operator>&gt;=</operator> <name><name>context</name><operator>-&gt;</operator><name>min_sublevels_up</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>rte</name><operator>-&gt;</operator><name>ctelevelsup</name></name> <operator>+=</operator> <name><name>context</name><operator>-&gt;</operator><name>delta_sublevels_up</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<comment type="block">/*
			* Fix for MPP-19436: in transformGroupedWindows, min_sublevels_up
			* is ignored. For RTE refer to the original query ctelist should
			* all be incremented.
			*/</comment>
			<if_stmt><if>if<condition>(<expr><name><name>context</name><operator>-&gt;</operator><name>ignore_min_sublevels_up</name></name> <operator>&amp;&amp;</operator> <name><name>rte</name><operator>-&gt;</operator><name>ctelevelsup</name></name> <operator>==</operator> <name><name>context</name><operator>-&gt;</operator><name>min_sublevels_up</name></name> <operator>-</operator> <literal type="number">1</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name><name>rte</name><operator>-&gt;</operator><name>ctelevelsup</name></name> <operator>+=</operator> <name><name>context</name><operator>-&gt;</operator><name>delta_sublevels_up</name></name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
		<return>return <expr><name>false</name></expr>;</return>			<comment type="block">/* allow range_table_walker to continue */</comment>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>Query</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Recurse into subselects */</comment>
		<decl_stmt><decl><type><name>bool</name></type>		<name>result</name></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>min_sublevels_up</name></name><operator>++</operator></expr>;</expr_stmt>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>query_tree_walker</name><argument_list>(<argument><expr><operator>(</operator><name>Query</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>,
								   <argument><expr><name>IncrementVarSublevelsUp_walker</name></expr></argument>,
								   <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>context</name></expr></argument>,
								   <argument><expr><name>QTW_EXAMINE_RTES_BEFORE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>min_sublevels_up</name></name><operator>--</operator></expr>;</expr_stmt>
		<return>return <expr><name>result</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><call><name>expression_tree_walker</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>IncrementVarSublevelsUp_walker</name></expr></argument>,
								  <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>context</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>IncrementVarSublevelsUp</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>delta_sublevels_up</name></decl></parameter>,
						<parameter><decl><type><name>int</name></type> <name>min_sublevels_up</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>IncrementVarSublevelsUp_context</name></type> <name>context</name></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>context</name><operator>.</operator><name>delta_sublevels_up</name></name> <operator>=</operator> <name>delta_sublevels_up</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>context</name><operator>.</operator><name>min_sublevels_up</name></name> <operator>=</operator> <name>min_sublevels_up</name></expr>;</expr_stmt>

	<comment type="block">/* POLAR px */</comment>
	<expr_stmt><expr><name><name>context</name><operator>.</operator><name>ignore_min_sublevels_up</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Must be prepared to start with a Query or a bare expression tree; if
	 * it's a Query, we don't want to increment sublevels_up.
	 */</comment>
	<expr_stmt><expr><call><name>query_or_expression_tree_walker</name><argument_list>(<argument><expr><name>node</name></expr></argument>,
									<argument><expr><name>IncrementVarSublevelsUp_walker</name></expr></argument>,
									<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>context</name></expr></argument>,
									<argument><expr><name>QTW_EXAMINE_RTES_BEFORE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/* POLAR px */</comment>
<function><type><name>void</name></type>
<name>polar_IncrementVarSublevelsUpInTransformGroupedWindows</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>,
		<parameter><decl><type><name>int</name></type> <name>delta_sublevels_up</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>min_sublevels_up</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>IncrementVarSublevelsUp_context</name></type> <name>context</name></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>context</name><operator>.</operator><name>delta_sublevels_up</name></name> <operator>=</operator> <name>delta_sublevels_up</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>context</name><operator>.</operator><name>min_sublevels_up</name></name> <operator>=</operator> <name>min_sublevels_up</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>context</name><operator>.</operator><name>ignore_min_sublevels_up</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Must be prepared to start with a Query or a bare expression tree; if
	 * it's a Query, we don't want to increment sublevels_up.
	 */</comment>
	<expr_stmt><expr><call><name>query_or_expression_tree_walker</name><argument_list>(<argument><expr><name>node</name></expr></argument>,
									<argument><expr><name>IncrementVarSublevelsUp_walker</name></expr></argument>,
									<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>context</name></expr></argument>,
									<argument><expr><name>QTW_EXAMINE_RTES_BEFORE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * IncrementVarSublevelsUp_rtable -
 *	Same as IncrementVarSublevelsUp, but to be invoked on a range table.
 */</comment>
<function><type><name>void</name></type>
<name>IncrementVarSublevelsUp_rtable</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>rtable</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>delta_sublevels_up</name></decl></parameter>,
							   <parameter><decl><type><name>int</name></type> <name>min_sublevels_up</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>IncrementVarSublevelsUp_context</name></type> <name>context</name></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>context</name><operator>.</operator><name>delta_sublevels_up</name></name> <operator>=</operator> <name>delta_sublevels_up</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>context</name><operator>.</operator><name>min_sublevels_up</name></name> <operator>=</operator> <name>min_sublevels_up</name></expr>;</expr_stmt>

	<comment type="block">/* POLAR px */</comment>
	<expr_stmt><expr><name><name>context</name><operator>.</operator><name>ignore_min_sublevels_up</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>range_table_walker</name><argument_list>(<argument><expr><name>rtable</name></expr></argument>,
					   <argument><expr><name>IncrementVarSublevelsUp_walker</name></expr></argument>,
					   <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>context</name></expr></argument>,
					   <argument><expr><name>QTW_EXAMINE_RTES_BEFORE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * rangeTableEntry_used - detect whether an RTE is referenced somewhere
 *	in var nodes or join or setOp trees of a query or expression.
 */</comment>

<typedef>typedef <type><struct>struct
<block>{
	<decl_stmt><decl><type><name>int</name></type>			<name>rt_index</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>sublevels_up</name></decl>;</decl_stmt>
}</block></struct></type> <name>rangeTableEntry_used_context</name>;</typedef>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>rangeTableEntry_used_walker</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>,
							<parameter><decl><type><name>rangeTableEntry_used_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>node</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>Var</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Var</name>		   <modifier>*</modifier></type><name>var</name> <init>= <expr><operator>(</operator><name>Var</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>var</name><operator>-&gt;</operator><name>varlevelsup</name></name> <operator>==</operator> <name><name>context</name><operator>-&gt;</operator><name>sublevels_up</name></name> <operator>&amp;&amp;</operator>
			<name><name>var</name><operator>-&gt;</operator><name>varno</name></name> <operator>==</operator> <name><name>context</name><operator>-&gt;</operator><name>rt_index</name></name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>CurrentOfExpr</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>CurrentOfExpr</name> <modifier>*</modifier></type><name>cexpr</name> <init>= <expr><operator>(</operator><name>CurrentOfExpr</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>context</name><operator>-&gt;</operator><name>sublevels_up</name></name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
			<name><name>cexpr</name><operator>-&gt;</operator><name>cvarno</name></name> <operator>==</operator> <name><name>context</name><operator>-&gt;</operator><name>rt_index</name></name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>RangeTblRef</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>RangeTblRef</name> <modifier>*</modifier></type><name>rtr</name> <init>= <expr><operator>(</operator><name>RangeTblRef</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>rtr</name><operator>-&gt;</operator><name>rtindex</name></name> <operator>==</operator> <name><name>context</name><operator>-&gt;</operator><name>rt_index</name></name> <operator>&amp;&amp;</operator>
			<name><name>context</name><operator>-&gt;</operator><name>sublevels_up</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
		<comment type="block">/* the subquery itself is visited separately */</comment>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>JoinExpr</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>JoinExpr</name>   <modifier>*</modifier></type><name>j</name> <init>= <expr><operator>(</operator><name>JoinExpr</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>j</name><operator>-&gt;</operator><name>rtindex</name></name> <operator>==</operator> <name><name>context</name><operator>-&gt;</operator><name>rt_index</name></name> <operator>&amp;&amp;</operator>
			<name><name>context</name><operator>-&gt;</operator><name>sublevels_up</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
		<comment type="block">/* fall through to examine children */</comment>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* Shouldn't need to handle planner auxiliary nodes here */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>PlaceHolderVar</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>PlanRowMark</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>SpecialJoinInfo</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>AppendRelInfo</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>PlaceHolderInfo</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>MinMaxAggInfo</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>Query</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Recurse into subselects */</comment>
		<decl_stmt><decl><type><name>bool</name></type>		<name>result</name></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>sublevels_up</name></name><operator>++</operator></expr>;</expr_stmt>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>query_tree_walker</name><argument_list>(<argument><expr><operator>(</operator><name>Query</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>, <argument><expr><name>rangeTableEntry_used_walker</name></expr></argument>,
								   <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>context</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>sublevels_up</name></name><operator>--</operator></expr>;</expr_stmt>
		<return>return <expr><name>result</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><call><name>expression_tree_walker</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>rangeTableEntry_used_walker</name></expr></argument>,
								  <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>context</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>bool</name></type>
<name>rangeTableEntry_used</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>rt_index</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>sublevels_up</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>rangeTableEntry_used_context</name></type> <name>context</name></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>context</name><operator>.</operator><name>rt_index</name></name> <operator>=</operator> <name>rt_index</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>context</name><operator>.</operator><name>sublevels_up</name></name> <operator>=</operator> <name>sublevels_up</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Must be prepared to start with a Query or a bare expression tree; if
	 * it's a Query, we don't want to increment sublevels_up.
	 */</comment>
	<return>return <expr><call><name>query_or_expression_tree_walker</name><argument_list>(<argument><expr><name>node</name></expr></argument>,
										   <argument><expr><name>rangeTableEntry_used_walker</name></expr></argument>,
										   <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>context</name></expr></argument>,
										   <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * If the given Query is an INSERT ... SELECT construct, extract and
 * return the sub-Query node that represents the SELECT part.  Otherwise
 * return the given Query.
 *
 * If subquery_ptr is not NULL, then *subquery_ptr is set to the location
 * of the link to the SELECT subquery inside parsetree, or NULL if not an
 * INSERT ... SELECT.
 *
 * This is a hack needed because transformations on INSERT ... SELECTs that
 * appear in rule actions should be applied to the source SELECT, not to the
 * INSERT part.  Perhaps this can be cleaned up with redesigned querytrees.
 */</comment>
<function><type><name>Query</name> <modifier>*</modifier></type>
<name>getInsertSelectQuery</name><parameter_list>(<parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>parsetree</name></decl></parameter>, <parameter><decl><type><name>Query</name> <modifier>*</modifier><modifier>*</modifier><modifier>*</modifier></type><name>subquery_ptr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Query</name>	   <modifier>*</modifier></type><name>selectquery</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>selectrte</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RangeTblRef</name> <modifier>*</modifier></type><name>rtr</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>subquery_ptr</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><operator>*</operator><name>subquery_ptr</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>parsetree</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>parsetree</name></expr>;</return></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>parsetree</name><operator>-&gt;</operator><name>commandType</name></name> <operator>!=</operator> <name>CMD_INSERT</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>parsetree</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Currently, this is ONLY applied to rule-action queries, and so we
	 * expect to find the OLD and NEW placeholder entries in the given query.
	 * If they're not there, it must be an INSERT/SELECT in which they've been
	 * pushed down to the SELECT.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>parsetree</name><operator>-&gt;</operator><name>rtable</name></name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <literal type="number">2</literal> <operator>&amp;&amp;</operator>
		<call><name>strcmp</name><argument_list>(<argument><expr><call><name>rt_fetch</name><argument_list>(<argument><expr><name>PRS2_OLD_VARNO</name></expr></argument>, <argument><expr><name><name>parsetree</name><operator>-&gt;</operator><name>rtable</name></name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>eref</name><operator>-&gt;</operator><name>aliasname</name></name></expr></argument>,
			   <argument><expr><literal type="string">"old"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
		<call><name>strcmp</name><argument_list>(<argument><expr><call><name>rt_fetch</name><argument_list>(<argument><expr><name>PRS2_NEW_VARNO</name></expr></argument>, <argument><expr><name><name>parsetree</name><operator>-&gt;</operator><name>rtable</name></name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>eref</name><operator>-&gt;</operator><name>aliasname</name></name></expr></argument>,
			   <argument><expr><literal type="string">"new"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>parsetree</name></expr>;</return></block_content></block></if></if_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>parsetree</name><operator>-&gt;</operator><name>jointree</name></name> <operator>&amp;&amp;</operator> <call><name>IsA</name><argument_list>(<argument><expr><name><name>parsetree</name><operator>-&gt;</operator><name>jointree</name></name></expr></argument>, <argument><expr><name>FromExpr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>parsetree</name><operator>-&gt;</operator><name>jointree</name><operator>-&gt;</operator><name>fromlist</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"expected to find SELECT subquery"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>rtr</name> <operator>=</operator> <operator>(</operator><name>RangeTblRef</name> <operator>*</operator><operator>)</operator> <call><name>linitial</name><argument_list>(<argument><expr><name><name>parsetree</name><operator>-&gt;</operator><name>jointree</name><operator>-&gt;</operator><name>fromlist</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>IsA</name><argument_list>(<argument><expr><name>rtr</name></expr></argument>, <argument><expr><name>RangeTblRef</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>selectrte</name> <operator>=</operator> <call><name>rt_fetch</name><argument_list>(<argument><expr><name><name>rtr</name><operator>-&gt;</operator><name>rtindex</name></name></expr></argument>, <argument><expr><name><name>parsetree</name><operator>-&gt;</operator><name>rtable</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>selectquery</name> <operator>=</operator> <name><name>selectrte</name><operator>-&gt;</operator><name>subquery</name></name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>selectquery</name> <operator>&amp;&amp;</operator> <call><name>IsA</name><argument_list>(<argument><expr><name>selectquery</name></expr></argument>, <argument><expr><name>Query</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
		  <name><name>selectquery</name><operator>-&gt;</operator><name>commandType</name></name> <operator>==</operator> <name>CMD_SELECT</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"expected to find SELECT subquery"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>selectquery</name><operator>-&gt;</operator><name>rtable</name></name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <literal type="number">2</literal> <operator>&amp;&amp;</operator>
		<call><name>strcmp</name><argument_list>(<argument><expr><call><name>rt_fetch</name><argument_list>(<argument><expr><name>PRS2_OLD_VARNO</name></expr></argument>, <argument><expr><name><name>selectquery</name><operator>-&gt;</operator><name>rtable</name></name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>eref</name><operator>-&gt;</operator><name>aliasname</name></name></expr></argument>,
			   <argument><expr><literal type="string">"old"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
		<call><name>strcmp</name><argument_list>(<argument><expr><call><name>rt_fetch</name><argument_list>(<argument><expr><name>PRS2_NEW_VARNO</name></expr></argument>, <argument><expr><name><name>selectquery</name><operator>-&gt;</operator><name>rtable</name></name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>eref</name><operator>-&gt;</operator><name>aliasname</name></name></expr></argument>,
			   <argument><expr><literal type="string">"new"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>subquery_ptr</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><operator>*</operator><name>subquery_ptr</name> <operator>=</operator> <operator>&amp;</operator><operator>(</operator><name><name>selectrte</name><operator>-&gt;</operator><name>subquery</name></name><operator>)</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<return>return <expr><name>selectquery</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"could not find rule placeholders"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>NULL</name></expr>;</return>				<comment type="block">/* not reached */</comment>
</block_content>}</block></function>


<comment type="block">/*
 * Add the given qualifier condition to the query's WHERE clause
 */</comment>
<function><type><name>void</name></type>
<name>AddQual</name><parameter_list>(<parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>parsetree</name></decl></parameter>, <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>qual</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>copy</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>qual</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>parsetree</name><operator>-&gt;</operator><name>commandType</name></name> <operator>==</operator> <name>CMD_UTILITY</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * There's noplace to put the qual on a utility statement.
		 *
		 * If it's a NOTIFY, silently ignore the qual; this means that the
		 * NOTIFY will execute, whether or not there are any qualifying rows.
		 * While clearly wrong, this is much more useful than refusing to
		 * execute the rule at all, and extra NOTIFY events are harmless for
		 * typical uses of NOTIFY.
		 *
		 * If it isn't a NOTIFY, error out, since unconditional execution of
		 * other utility stmts is unlikely to be wanted.  (This case is not
		 * currently allowed anyway, but keep the test for safety.)
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>parsetree</name><operator>-&gt;</operator><name>utilityStmt</name></name> <operator>&amp;&amp;</operator> <call><name>IsA</name><argument_list>(<argument><expr><name><name>parsetree</name><operator>-&gt;</operator><name>utilityStmt</name></name></expr></argument>, <argument><expr><name>NotifyStmt</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<return>return;</return></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"conditional utility statements are not implemented"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>parsetree</name><operator>-&gt;</operator><name>setOperations</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * There's noplace to put the qual on a setop statement, either. (This
		 * could be fixed, but right now the planner simply ignores any qual
		 * condition on a setop query.)
		 */</comment>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"conditional UNION/INTERSECT/EXCEPT statements are not implemented"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* INTERSECT want's the original, but we need to copy - Jan */</comment>
	<expr_stmt><expr><name>copy</name> <operator>=</operator> <call><name>copyObject</name><argument_list>(<argument><expr><name>qual</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>parsetree</name><operator>-&gt;</operator><name>jointree</name><operator>-&gt;</operator><name>quals</name></name> <operator>=</operator> <call><name>make_and_qual</name><argument_list>(<argument><expr><name><name>parsetree</name><operator>-&gt;</operator><name>jointree</name><operator>-&gt;</operator><name>quals</name></name></expr></argument>,
											   <argument><expr><name>copy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * We had better not have stuck an aggregate into the WHERE clause.
	 */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>contain_aggs_of_level</name><argument_list>(<argument><expr><name>copy</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Make sure query is marked correctly if added qual has sublinks. Need
	 * not search qual when query is already marked.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>parsetree</name><operator>-&gt;</operator><name>hasSubLinks</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>parsetree</name><operator>-&gt;</operator><name>hasSubLinks</name></name> <operator>=</operator> <call><name>checkExprHasSubLink</name><argument_list>(<argument><expr><name>copy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * Invert the given clause and add it to the WHERE qualifications of the
 * given querytree.  Inversion means "x IS NOT TRUE", not just "NOT x",
 * else we will do the wrong thing when x evaluates to NULL.
 */</comment>
<function><type><name>void</name></type>
<name>AddInvertedQual</name><parameter_list>(<parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>parsetree</name></decl></parameter>, <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>qual</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>BooleanTest</name> <modifier>*</modifier></type><name>invqual</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>qual</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/* Need not copy input qual, because AddQual will... */</comment>
	<expr_stmt><expr><name>invqual</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>BooleanTest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>invqual</name><operator>-&gt;</operator><name>arg</name></name> <operator>=</operator> <operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>qual</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>invqual</name><operator>-&gt;</operator><name>booltesttype</name></name> <operator>=</operator> <name>IS_NOT_TRUE</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>invqual</name><operator>-&gt;</operator><name>location</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>AddQual</name><argument_list>(<argument><expr><name>parsetree</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>invqual</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * replace_rte_variables() finds all Vars in an expression tree
 * that reference a particular RTE, and replaces them with substitute
 * expressions obtained from a caller-supplied callback function.
 *
 * When invoking replace_rte_variables on a portion of a Query, pass the
 * address of the containing Query's hasSubLinks field as outer_hasSubLinks.
 * Otherwise, pass NULL, but inserting a SubLink into a non-Query expression
 * will then cause an error.
 *
 * Note: the business with inserted_sublink is needed to update hasSubLinks
 * in subqueries when the replacement adds a subquery inside a subquery.
 * Messy, isn't it?  We do not need to do similar pushups for hasAggs,
 * because it isn't possible for this transformation to insert a level-zero
 * aggregate reference into a subquery --- it could only insert outer aggs.
 * Likewise for hasWindowFuncs.
 *
 * Note: usually, we'd not expose the mutator function or context struct
 * for a function like this.  We do so because callbacks often find it
 * convenient to recurse directly to the mutator on sub-expressions of
 * what they will return.
 */</comment>
<function><type><name>Node</name> <modifier>*</modifier></type>
<name>replace_rte_variables</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>target_varno</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>sublevels_up</name></decl></parameter>,
					  <parameter><decl><type><name>replace_rte_variables_callback</name></type> <name>callback</name></decl></parameter>,
					  <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>callback_arg</name></decl></parameter>,
					  <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>outer_hasSubLinks</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>replace_rte_variables_context</name></type> <name>context</name></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>context</name><operator>.</operator><name>callback</name></name> <operator>=</operator> <name>callback</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>context</name><operator>.</operator><name>callback_arg</name></name> <operator>=</operator> <name>callback_arg</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>context</name><operator>.</operator><name>target_varno</name></name> <operator>=</operator> <name>target_varno</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>context</name><operator>.</operator><name>sublevels_up</name></name> <operator>=</operator> <name>sublevels_up</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * We try to initialize inserted_sublink to true if there is no need to
	 * detect new sublinks because the query already has some.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>node</name> <operator>&amp;&amp;</operator> <call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>Query</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>context</name><operator>.</operator><name>inserted_sublink</name></name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>Query</name> <operator>*</operator><operator>)</operator> <name>node</name><operator>)</operator><operator>-&gt;</operator><name>hasSubLinks</name></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><name>outer_hasSubLinks</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>context</name><operator>.</operator><name>inserted_sublink</name></name> <operator>=</operator> <operator>*</operator><name>outer_hasSubLinks</name></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>context</name><operator>.</operator><name>inserted_sublink</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/*
	 * Must be prepared to start with a Query or a bare expression tree; if
	 * it's a Query, we don't want to increment sublevels_up.
	 */</comment>
	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>query_or_expression_tree_mutator</name><argument_list>(<argument><expr><name>node</name></expr></argument>,
											  <argument><expr><name>replace_rte_variables_mutator</name></expr></argument>,
											  <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>context</name></expr></argument>,
											  <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>context</name><operator>.</operator><name>inserted_sublink</name></name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>result</name> <operator>&amp;&amp;</operator> <call><name>IsA</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>Query</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><operator>(</operator><operator>(</operator><name>Query</name> <operator>*</operator><operator>)</operator> <name>result</name><operator>)</operator><operator>-&gt;</operator><name>hasSubLinks</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><name>outer_hasSubLinks</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><operator>*</operator><name>outer_hasSubLinks</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"replace_rte_variables inserted a SubLink, but has noplace to record it"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>Node</name> <modifier>*</modifier></type>
<name>replace_rte_variables_mutator</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>,
							  <parameter><decl><type><name>replace_rte_variables_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>node</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>Var</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Var</name>		   <modifier>*</modifier></type><name>var</name> <init>= <expr><operator>(</operator><name>Var</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>var</name><operator>-&gt;</operator><name>varno</name></name> <operator>==</operator> <name><name>context</name><operator>-&gt;</operator><name>target_varno</name></name> <operator>&amp;&amp;</operator>
			<name><name>var</name><operator>-&gt;</operator><name>varlevelsup</name></name> <operator>==</operator> <name><name>context</name><operator>-&gt;</operator><name>sublevels_up</name></name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Found a matching variable, make the substitution */</comment>
			<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>newnode</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>newnode</name> <operator>=</operator> <call><name><name>context</name><operator>-&gt;</operator><name>callback</name></name><argument_list>(<argument><expr><name>var</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* Detect if we are adding a sublink to query */</comment>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>context</name><operator>-&gt;</operator><name>inserted_sublink</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>inserted_sublink</name></name> <operator>=</operator> <call><name>checkExprHasSubLink</name><argument_list>(<argument><expr><name>newnode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<return>return <expr><name>newnode</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
		<comment type="block">/* otherwise fall through to copy the var normally */</comment>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>CurrentOfExpr</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>CurrentOfExpr</name> <modifier>*</modifier></type><name>cexpr</name> <init>= <expr><operator>(</operator><name>CurrentOfExpr</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>cexpr</name><operator>-&gt;</operator><name>cvarno</name></name> <operator>==</operator> <name><name>context</name><operator>-&gt;</operator><name>target_varno</name></name> <operator>&amp;&amp;</operator>
			<name><name>context</name><operator>-&gt;</operator><name>sublevels_up</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * We get here if a WHERE CURRENT OF expression turns out to apply
			 * to a view.  Someday we might be able to translate the
			 * expression to apply to an underlying table of the view, but
			 * right now it's not implemented.
			 */</comment>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"WHERE CURRENT OF on a view is not implemented"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<comment type="block">/* otherwise fall through to copy the expr normally */</comment>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>Query</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Recurse into RTE subquery or not-yet-planned sublink subquery */</comment>
		<decl_stmt><decl><type><name>Query</name>	   <modifier>*</modifier></type><name>newnode</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>save_inserted_sublink</name></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>sublevels_up</name></name><operator>++</operator></expr>;</expr_stmt>
		<expr_stmt><expr><name>save_inserted_sublink</name> <operator>=</operator> <name><name>context</name><operator>-&gt;</operator><name>inserted_sublink</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>inserted_sublink</name></name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>Query</name> <operator>*</operator><operator>)</operator> <name>node</name><operator>)</operator><operator>-&gt;</operator><name>hasSubLinks</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>newnode</name> <operator>=</operator> <call><name>query_tree_mutator</name><argument_list>(<argument><expr><operator>(</operator><name>Query</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>,
									 <argument><expr><name>replace_rte_variables_mutator</name></expr></argument>,
									 <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>context</name></expr></argument>,
									 <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>newnode</name><operator>-&gt;</operator><name>hasSubLinks</name></name> <operator>|=</operator> <name><name>context</name><operator>-&gt;</operator><name>inserted_sublink</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>inserted_sublink</name></name> <operator>=</operator> <name>save_inserted_sublink</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>sublevels_up</name></name><operator>--</operator></expr>;</expr_stmt>
		<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>newnode</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><call><name>expression_tree_mutator</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>replace_rte_variables_mutator</name></expr></argument>,
								   <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>context</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * map_variable_attnos() finds all user-column Vars in an expression tree
 * that reference a particular RTE, and adjusts their varattnos according
 * to the given mapping array (varattno n is replaced by attno_map[n-1]).
 * Vars for system columns are not modified.
 *
 * A zero in the mapping array represents a dropped column, which should not
 * appear in the expression.
 *
 * If the expression tree contains a whole-row Var for the target RTE,
 * *found_whole_row is set to true.  In addition, if to_rowtype is
 * not InvalidOid, we replace the Var with a Var of that vartype, inserting
 * a ConvertRowtypeExpr to map back to the rowtype expected by the expression.
 * (Therefore, to_rowtype had better be a child rowtype of the rowtype of the
 * RTE we're changing references to.)  Callers that don't provide to_rowtype
 * should report an error if *found_row_type is true; we don't do that here
 * because we don't know exactly what wording for the error message would
 * be most appropriate.  The caller will be aware of the context.
 *
 * This could be built using replace_rte_variables and a callback function,
 * but since we don't ever need to insert sublinks, replace_rte_variables is
 * overly complicated.
 */</comment>

<typedef>typedef <type><struct>struct
<block>{
	<decl_stmt><decl><type><name>int</name></type>			<name>target_varno</name></decl>;</decl_stmt>	<comment type="block">/* RTE index to search for */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>sublevels_up</name></decl>;</decl_stmt>	<comment type="block">/* (current) nesting depth */</comment>
	<decl_stmt><decl><type><specifier>const</specifier> <name>AttrNumber</name> <modifier>*</modifier></type><name>attno_map</name></decl>;</decl_stmt>	<comment type="block">/* map array for user attnos */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>map_length</name></decl>;</decl_stmt>		<comment type="block">/* number of entries in attno_map[] */</comment>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>to_rowtype</name></decl>;</decl_stmt>		<comment type="block">/* change whole-row Vars to this type */</comment>
	<decl_stmt><decl><type><name>bool</name>	   <modifier>*</modifier></type><name>found_whole_row</name></decl>;</decl_stmt>	<comment type="block">/* output flag */</comment>
}</block></struct></type> <name>map_variable_attnos_context</name>;</typedef>

<function><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type>
<name>map_variable_attnos_mutator</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>,
							<parameter><decl><type><name>map_variable_attnos_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>node</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>Var</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Var</name>		   <modifier>*</modifier></type><name>var</name> <init>= <expr><operator>(</operator><name>Var</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>var</name><operator>-&gt;</operator><name>varno</name></name> <operator>==</operator> <name><name>context</name><operator>-&gt;</operator><name>target_varno</name></name> <operator>&amp;&amp;</operator>
			<name><name>var</name><operator>-&gt;</operator><name>varlevelsup</name></name> <operator>==</operator> <name><name>context</name><operator>-&gt;</operator><name>sublevels_up</name></name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Found a matching variable, make the substitution */</comment>
			<decl_stmt><decl><type><name>Var</name>		   <modifier>*</modifier></type><name>newvar</name> <init>= <expr><operator>(</operator><name>Var</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Var</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int</name></type>			<name>attno</name> <init>= <expr><name><name>var</name><operator>-&gt;</operator><name>varattno</name></name></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><operator>*</operator><name>newvar</name> <operator>=</operator> <operator>*</operator><name>var</name></expr>;</expr_stmt>		<comment type="block">/* initially copy all fields of the Var */</comment>

			<if_stmt><if>if <condition>(<expr><name>attno</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* user-defined column, replace attno */</comment>
				<if_stmt><if>if <condition>(<expr><name>attno</name> <operator>&gt;</operator> <name><name>context</name><operator>-&gt;</operator><name>map_length</name></name> <operator>||</operator>
					<name><name>context</name><operator>-&gt;</operator><name>attno_map</name><index>[<expr><name>attno</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unexpected varattno %d in expression to be mapped"</literal></expr></argument>,
						 <argument><expr><name>attno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<expr_stmt><expr><name><name>newvar</name><operator>-&gt;</operator><name>varattno</name></name> <operator>=</operator> <name><name>newvar</name><operator>-&gt;</operator><name>varoattno</name></name> <operator>=</operator> <name><name>context</name><operator>-&gt;</operator><name>attno_map</name><index>[<expr><name>attno</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
			</block_content>}</block></if>
			<if type="elseif">else if <condition>(<expr><name>attno</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* whole-row variable, warn caller */</comment>
				<expr_stmt><expr><operator>*</operator><operator>(</operator><name><name>context</name><operator>-&gt;</operator><name>found_whole_row</name></name><operator>)</operator> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

				<comment type="block">/* If the caller expects us to convert the Var, do so. */</comment>
				<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>context</name><operator>-&gt;</operator><name>to_rowtype</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
					<name><name>context</name><operator>-&gt;</operator><name>to_rowtype</name></name> <operator>!=</operator> <name><name>var</name><operator>-&gt;</operator><name>vartype</name></name></expr>)</condition>
				<block>{<block_content>
					<decl_stmt><decl><type><name>ConvertRowtypeExpr</name> <modifier>*</modifier></type><name>r</name></decl>;</decl_stmt>

					<comment type="block">/* This certainly won't work for a RECORD variable. */</comment>
					<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>var</name><operator>-&gt;</operator><name>vartype</name></name> <operator>!=</operator> <name>RECORDOID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<comment type="block">/* Var itself is changed to the requested type. */</comment>
					<expr_stmt><expr><name><name>newvar</name><operator>-&gt;</operator><name>vartype</name></name> <operator>=</operator> <name><name>context</name><operator>-&gt;</operator><name>to_rowtype</name></name></expr>;</expr_stmt>

					<comment type="block">/*
					 * Add a conversion node on top to convert back to the
					 * original type expected by the expression.
					 */</comment>
					<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>ConvertRowtypeExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>r</name><operator>-&gt;</operator><name>arg</name></name> <operator>=</operator> <operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>newvar</name></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>r</name><operator>-&gt;</operator><name>resulttype</name></name> <operator>=</operator> <name><name>var</name><operator>-&gt;</operator><name>vartype</name></name></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>r</name><operator>-&gt;</operator><name>convertformat</name></name> <operator>=</operator> <name>COERCE_IMPLICIT_CAST</name></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>r</name><operator>-&gt;</operator><name>location</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>

					<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>r</name></expr>;</return>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></if></if_stmt>
			<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>newvar</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
		<comment type="block">/* otherwise fall through to copy the var normally */</comment>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>ConvertRowtypeExpr</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ConvertRowtypeExpr</name> <modifier>*</modifier></type><name>r</name> <init>= <expr><operator>(</operator><name>ConvertRowtypeExpr</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Var</name>		   <modifier>*</modifier></type><name>var</name> <init>= <expr><operator>(</operator><name>Var</name> <operator>*</operator><operator>)</operator> <name><name>r</name><operator>-&gt;</operator><name>arg</name></name></expr></init></decl>;</decl_stmt>

		<comment type="block">/*
		 * If this is coercing a whole-row Var that we need to convert, then
		 * just convert the Var without adding an extra ConvertRowtypeExpr.
		 * Effectively we're simplifying var::parenttype::grandparenttype into
		 * just var::grandparenttype.  This avoids building stacks of CREs if
		 * this function is applied repeatedly.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>var</name></expr></argument>, <argument><expr><name>Var</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
			<name><name>var</name><operator>-&gt;</operator><name>varno</name></name> <operator>==</operator> <name><name>context</name><operator>-&gt;</operator><name>target_varno</name></name> <operator>&amp;&amp;</operator>
			<name><name>var</name><operator>-&gt;</operator><name>varlevelsup</name></name> <operator>==</operator> <name><name>context</name><operator>-&gt;</operator><name>sublevels_up</name></name> <operator>&amp;&amp;</operator>
			<name><name>var</name><operator>-&gt;</operator><name>varattno</name></name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
			<call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>context</name><operator>-&gt;</operator><name>to_rowtype</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
			<name><name>context</name><operator>-&gt;</operator><name>to_rowtype</name></name> <operator>!=</operator> <name><name>var</name><operator>-&gt;</operator><name>vartype</name></name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>ConvertRowtypeExpr</name> <modifier>*</modifier></type><name>newnode</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Var</name>		   <modifier>*</modifier></type><name>newvar</name> <init>= <expr><operator>(</operator><name>Var</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Var</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<comment type="block">/* whole-row variable, warn caller */</comment>
			<expr_stmt><expr><operator>*</operator><operator>(</operator><name><name>context</name><operator>-&gt;</operator><name>found_whole_row</name></name><operator>)</operator> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

			<expr_stmt><expr><operator>*</operator><name>newvar</name> <operator>=</operator> <operator>*</operator><name>var</name></expr>;</expr_stmt>		<comment type="block">/* initially copy all fields of the Var */</comment>

			<comment type="block">/* This certainly won't work for a RECORD variable. */</comment>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>var</name><operator>-&gt;</operator><name>vartype</name></name> <operator>!=</operator> <name>RECORDOID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* Var itself is changed to the requested type. */</comment>
			<expr_stmt><expr><name><name>newvar</name><operator>-&gt;</operator><name>vartype</name></name> <operator>=</operator> <name><name>context</name><operator>-&gt;</operator><name>to_rowtype</name></name></expr>;</expr_stmt>

			<expr_stmt><expr><name>newnode</name> <operator>=</operator> <operator>(</operator><name>ConvertRowtypeExpr</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ConvertRowtypeExpr</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><operator>*</operator><name>newnode</name> <operator>=</operator> <operator>*</operator><name>r</name></expr>;</expr_stmt>		<comment type="block">/* initially copy all fields of the CRE */</comment>
			<expr_stmt><expr><name><name>newnode</name><operator>-&gt;</operator><name>arg</name></name> <operator>=</operator> <operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>newvar</name></expr>;</expr_stmt>

			<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>newnode</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
		<comment type="block">/* otherwise fall through to process the expression normally */</comment>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>Query</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Recurse into RTE subquery or not-yet-planned sublink subquery */</comment>
		<decl_stmt><decl><type><name>Query</name>	   <modifier>*</modifier></type><name>newnode</name></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>sublevels_up</name></name><operator>++</operator></expr>;</expr_stmt>
		<expr_stmt><expr><name>newnode</name> <operator>=</operator> <call><name>query_tree_mutator</name><argument_list>(<argument><expr><operator>(</operator><name>Query</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>,
									 <argument><expr><name>map_variable_attnos_mutator</name></expr></argument>,
									 <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>context</name></expr></argument>,
									 <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>sublevels_up</name></name><operator>--</operator></expr>;</expr_stmt>
		<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>newnode</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><call><name>expression_tree_mutator</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>map_variable_attnos_mutator</name></expr></argument>,
								   <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>context</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>Node</name> <modifier>*</modifier></type>
<name>map_variable_attnos</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>,
					<parameter><decl><type><name>int</name></type> <name>target_varno</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>sublevels_up</name></decl></parameter>,
					<parameter><decl><type><specifier>const</specifier> <name>AttrNumber</name> <modifier>*</modifier></type><name>attno_map</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>map_length</name></decl></parameter>,
					<parameter><decl><type><name>Oid</name></type> <name>to_rowtype</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>found_whole_row</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>map_variable_attnos_context</name></type> <name>context</name></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>context</name><operator>.</operator><name>target_varno</name></name> <operator>=</operator> <name>target_varno</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>context</name><operator>.</operator><name>sublevels_up</name></name> <operator>=</operator> <name>sublevels_up</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>context</name><operator>.</operator><name>attno_map</name></name> <operator>=</operator> <name>attno_map</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>context</name><operator>.</operator><name>map_length</name></name> <operator>=</operator> <name>map_length</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>context</name><operator>.</operator><name>to_rowtype</name></name> <operator>=</operator> <name>to_rowtype</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>context</name><operator>.</operator><name>found_whole_row</name></name> <operator>=</operator> <name>found_whole_row</name></expr>;</expr_stmt>

	<expr_stmt><expr><operator>*</operator><name>found_whole_row</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Must be prepared to start with a Query or a bare expression tree; if
	 * it's a Query, we don't want to increment sublevels_up.
	 */</comment>
	<return>return <expr><call><name>query_or_expression_tree_mutator</name><argument_list>(<argument><expr><name>node</name></expr></argument>,
											<argument><expr><name>map_variable_attnos_mutator</name></expr></argument>,
											<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>context</name></expr></argument>,
											<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * ReplaceVarsFromTargetList - replace Vars with items from a targetlist
 *
 * Vars matching target_varno and sublevels_up are replaced by the
 * entry with matching resno from targetlist, if there is one.
 *
 * If there is no matching resno for such a Var, the action depends on the
 * nomatch_option:
 *	REPLACEVARS_REPORT_ERROR: throw an error
 *	REPLACEVARS_CHANGE_VARNO: change Var's varno to nomatch_varno
 *	REPLACEVARS_SUBSTITUTE_NULL: replace Var with a NULL Const of same type
 *
 * The caller must also provide target_rte, the RTE describing the target
 * relation.  This is needed to handle whole-row Vars referencing the target.
 * We expand such Vars into RowExpr constructs.
 *
 * outer_hasSubLinks works the same as for replace_rte_variables().
 */</comment>

<typedef>typedef <type><struct>struct
<block>{
	<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>target_rte</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>targetlist</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ReplaceVarsNoMatchOption</name></type> <name>nomatch_option</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>nomatch_varno</name></decl>;</decl_stmt>
}</block></struct></type> <name>ReplaceVarsFromTargetList_context</name>;</typedef>

<function><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type>
<name>ReplaceVarsFromTargetList_callback</name><parameter_list>(<parameter><decl><type><name>Var</name> <modifier>*</modifier></type><name>var</name></decl></parameter>,
								   <parameter><decl><type><name>replace_rte_variables_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ReplaceVarsFromTargetList_context</name> <modifier>*</modifier></type><name>rcon</name> <init>= <expr><operator>(</operator><name>ReplaceVarsFromTargetList_context</name> <operator>*</operator><operator>)</operator> <name><name>context</name><operator>-&gt;</operator><name>callback_arg</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>tle</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>var</name><operator>-&gt;</operator><name>varattno</name></name> <operator>==</operator> <name>InvalidAttrNumber</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Must expand whole-tuple reference into RowExpr */</comment>
		<decl_stmt><decl><type><name>RowExpr</name>    <modifier>*</modifier></type><name>rowexpr</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>colnames</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>fields</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * If generating an expansion for a var of a named rowtype (ie, this
		 * is a plain relation RTE), then we must include dummy items for
		 * dropped columns.  If the var is RECORD (ie, this is a JOIN), then
		 * omit dropped columns.  Either way, attach column names to the
		 * RowExpr for use of ruleutils.c.
		 */</comment>
		<expr_stmt><expr><call><name>expandRTE</name><argument_list>(<argument><expr><name><name>rcon</name><operator>-&gt;</operator><name>target_rte</name></name></expr></argument>,
				  <argument><expr><name><name>var</name><operator>-&gt;</operator><name>varno</name></name></expr></argument>, <argument><expr><name><name>var</name><operator>-&gt;</operator><name>varlevelsup</name></name></expr></argument>, <argument><expr><name><name>var</name><operator>-&gt;</operator><name>location</name></name></expr></argument>,
				  <argument><expr><operator>(</operator><name><name>var</name><operator>-&gt;</operator><name>vartype</name></name> <operator>!=</operator> <name>RECORDOID</name><operator>)</operator></expr></argument>,
				  <argument><expr><operator>&amp;</operator><name>colnames</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>fields</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* Adjust the generated per-field Vars... */</comment>
		<expr_stmt><expr><name>fields</name> <operator>=</operator> <operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator> <call><name>replace_rte_variables_mutator</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>fields</name></expr></argument>,
														<argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>rowexpr</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>RowExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>rowexpr</name><operator>-&gt;</operator><name>args</name></name> <operator>=</operator> <name>fields</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>rowexpr</name><operator>-&gt;</operator><name>row_typeid</name></name> <operator>=</operator> <name><name>var</name><operator>-&gt;</operator><name>vartype</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>rowexpr</name><operator>-&gt;</operator><name>row_format</name></name> <operator>=</operator> <name>COERCE_IMPLICIT_CAST</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>rowexpr</name><operator>-&gt;</operator><name>colnames</name></name> <operator>=</operator> <name>colnames</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>rowexpr</name><operator>-&gt;</operator><name>location</name></name> <operator>=</operator> <name><name>var</name><operator>-&gt;</operator><name>location</name></name></expr>;</expr_stmt>

		<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>rowexpr</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Normal case referencing one targetlist element */</comment>
	<expr_stmt><expr><name>tle</name> <operator>=</operator> <call><name>get_tle_by_resno</name><argument_list>(<argument><expr><name><name>rcon</name><operator>-&gt;</operator><name>targetlist</name></name></expr></argument>, <argument><expr><name><name>var</name><operator>-&gt;</operator><name>varattno</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>tle</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name><name>tle</name><operator>-&gt;</operator><name>resjunk</name></name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Failed to find column in targetlist */</comment>
		<switch>switch <condition>(<expr><name><name>rcon</name><operator>-&gt;</operator><name>nomatch_option</name></name></expr>)</condition>
		<block>{<block_content>
			<case>case <expr><name>REPLACEVARS_REPORT_ERROR</name></expr>:</case>
				<comment type="block">/* fall through, throw error below */</comment>
				<break>break;</break>

			<case>case <expr><name>REPLACEVARS_CHANGE_VARNO</name></expr>:</case>
				<expr_stmt><expr><name>var</name> <operator>=</operator> <operator>(</operator><name>Var</name> <operator>*</operator><operator>)</operator> <call><name>copyObject</name><argument_list>(<argument><expr><name>var</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>var</name><operator>-&gt;</operator><name>varno</name></name> <operator>=</operator> <name><name>rcon</name><operator>-&gt;</operator><name>nomatch_varno</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>var</name><operator>-&gt;</operator><name>varnoold</name></name> <operator>=</operator> <name><name>rcon</name><operator>-&gt;</operator><name>nomatch_varno</name></name></expr>;</expr_stmt>
				<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>var</name></expr>;</return>

			<case>case <expr><name>REPLACEVARS_SUBSTITUTE_NULL</name></expr>:</case>

				<comment type="block">/*
				 * If Var is of domain type, we should add a CoerceToDomain
				 * node, in case there is a NOT NULL domain constraint.
				 */</comment>
				<return>return <expr><call><name>coerce_to_domain</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>makeNullConst</name><argument_list>(<argument><expr><name><name>var</name><operator>-&gt;</operator><name>vartype</name></name></expr></argument>,
															   <argument><expr><name><name>var</name><operator>-&gt;</operator><name>vartypmod</name></name></expr></argument>,
															   <argument><expr><name><name>var</name><operator>-&gt;</operator><name>varcollid</name></name></expr></argument>)</argument_list></call></expr></argument>,
										<argument><expr><name>InvalidOid</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>,
										<argument><expr><name><name>var</name><operator>-&gt;</operator><name>vartype</name></name></expr></argument>,
										<argument><expr><name>COERCION_IMPLICIT</name></expr></argument>,
										<argument><expr><name>COERCE_IMPLICIT_CAST</name></expr></argument>,
										<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>,
										<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</return>
		</block_content>}</block></switch>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"could not find replacement targetlist entry for attno %d"</literal></expr></argument>,
			 <argument><expr><name><name>var</name><operator>-&gt;</operator><name>varattno</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>			<comment type="block">/* keep compiler quiet */</comment>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* Make a copy of the tlist item to return */</comment>
		<decl_stmt><decl><type><name>Expr</name>	   <modifier>*</modifier></type><name>newnode</name> <init>= <expr><call><name>copyObject</name><argument_list>(<argument><expr><name><name>tle</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/* Must adjust varlevelsup if tlist item is from higher query */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>var</name><operator>-&gt;</operator><name>varlevelsup</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>IncrementVarSublevelsUp</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>newnode</name></expr></argument>, <argument><expr><name><name>var</name><operator>-&gt;</operator><name>varlevelsup</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * Check to see if the tlist item contains a PARAM_MULTIEXPR Param,
		 * and throw error if so.  This case could only happen when expanding
		 * an ON UPDATE rule's NEW variable and the referenced tlist item in
		 * the original UPDATE command is part of a multiple assignment. There
		 * seems no practical way to handle such cases without multiple
		 * evaluation of the multiple assignment's sub-select, which would
		 * create semantic oddities that users of rules would probably prefer
		 * not to cope with.  So treat it as an unimplemented feature.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>contains_multiexpr_param</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>newnode</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"NEW variables in ON UPDATE rules cannot reference columns that are part of a multiple assignment in the subject UPDATE command"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>newnode</name></expr>;</return>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<function><type><name>Node</name> <modifier>*</modifier></type>
<name>ReplaceVarsFromTargetList</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>,
						  <parameter><decl><type><name>int</name></type> <name>target_varno</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>sublevels_up</name></decl></parameter>,
						  <parameter><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>target_rte</name></decl></parameter>,
						  <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>targetlist</name></decl></parameter>,
						  <parameter><decl><type><name>ReplaceVarsNoMatchOption</name></type> <name>nomatch_option</name></decl></parameter>,
						  <parameter><decl><type><name>int</name></type> <name>nomatch_varno</name></decl></parameter>,
						  <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>outer_hasSubLinks</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ReplaceVarsFromTargetList_context</name></type> <name>context</name></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>context</name><operator>.</operator><name>target_rte</name></name> <operator>=</operator> <name>target_rte</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>context</name><operator>.</operator><name>targetlist</name></name> <operator>=</operator> <name>targetlist</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>context</name><operator>.</operator><name>nomatch_option</name></name> <operator>=</operator> <name>nomatch_option</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>context</name><operator>.</operator><name>nomatch_varno</name></name> <operator>=</operator> <name>nomatch_varno</name></expr>;</expr_stmt>

	<return>return <expr><call><name>replace_rte_variables</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>target_varno</name></expr></argument>, <argument><expr><name>sublevels_up</name></expr></argument>,
								 <argument><expr><name>ReplaceVarsFromTargetList_callback</name></expr></argument>,
								 <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>context</name></expr></argument>,
								 <argument><expr><name>outer_hasSubLinks</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
</unit>
