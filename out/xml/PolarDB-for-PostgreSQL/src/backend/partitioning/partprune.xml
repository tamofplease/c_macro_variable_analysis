<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/PolarDB-for-PostgreSQL/src/backend/partitioning/partprune.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * partprune.c
 *		Support for partition pruning during query planning and execution
 *
 * This module implements partition pruning using the information contained in
 * a table's partition descriptor, query clauses, and run-time parameters.
 *
 * During planning, clauses that can be matched to the table's partition key
 * are turned into a set of "pruning steps", which are then executed to
 * identify a set of partitions (as indexes in the RelOptInfo-&gt;part_rels
 * array) that satisfy the constraints in the step.  Partitions not in the set
 * are said to have been pruned.
 *
 * A base pruning step may involve expressions whose values are only known
 * during execution, such as Params, in which case pruning cannot occur
 * entirely during planning.  In that case, such steps are included alongside
 * the plan, so that they can be used by the executor for further pruning.
 *
 * There are two kinds of pruning steps.  A "base" pruning step represents
 * tests on partition key column(s), typically comparisons to expressions.
 * A "combine" pruning step represents a Boolean connector (AND/OR), and
 * combines the outputs of some previous steps using the appropriate
 * combination method.
 *
 * See gen_partprune_steps_internal() for more details on step generation.
 *
 * Portions Copyright (c) 1996-2018, PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, Regents of the University of California
 *
 * IDENTIFICATION
 *		  src/backend/partitioning/partprune.c
 *
 *-------------------------------------------------------------------------
*/</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/hash.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/nbtree.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_operator.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_opfamily.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_proc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_type.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/executor.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/makefuncs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/nodeFuncs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/clauses.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/pathnode.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/planner.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/predtest.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/prep.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/var.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"partitioning/partprune.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"partitioning/partbounds.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"rewrite/rewriteManip.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/lsyscache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parsetree.h"</cpp:file></cpp:include>


<comment type="block">/*
 * Information about a clause matched with a partition key.
 */</comment>
<typedef>typedef <type><struct>struct <name>PartClauseInfo</name>
<block>{
	<decl_stmt><decl><type><name>int</name></type>			<name>keyno</name></decl>;</decl_stmt>			<comment type="block">/* Partition key number (0 to partnatts - 1) */</comment>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>opno</name></decl>;</decl_stmt>			<comment type="block">/* operator used to compare partkey to expr */</comment>
	<decl_stmt><decl><type><name>bool</name></type>		<name>op_is_ne</name></decl>;</decl_stmt>		<comment type="block">/* is clause's original operator &lt;&gt; ? */</comment>
	<decl_stmt><decl><type><name>Expr</name>	   <modifier>*</modifier></type><name>expr</name></decl>;</decl_stmt>			<comment type="block">/* expr the partition key is compared to */</comment>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>cmpfn</name></decl>;</decl_stmt>			<comment type="block">/* Oid of function to compare 'expr' to the
								 * partition key */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>op_strategy</name></decl>;</decl_stmt>	<comment type="block">/* btree strategy identifying the operator */</comment>
}</block></struct></type> <name>PartClauseInfo</name>;</typedef>

<comment type="block">/*
 * PartClauseMatchStatus
 *		Describes the result of match_clause_to_partition_key()
 */</comment>
<typedef>typedef <type><enum>enum <name>PartClauseMatchStatus</name>
<block>{
	<decl><name>PARTCLAUSE_NOMATCH</name></decl>,
	<decl><name>PARTCLAUSE_MATCH_CLAUSE</name></decl>,
	<decl><name>PARTCLAUSE_MATCH_NULLNESS</name></decl>,
	<decl><name>PARTCLAUSE_MATCH_STEPS</name></decl>,
	<decl><name>PARTCLAUSE_MATCH_CONTRADICT</name></decl>,
	<decl><name>PARTCLAUSE_UNSUPPORTED</name></decl>
}</block></enum></type> <name>PartClauseMatchStatus</name>;</typedef>

<comment type="block">/*
 * PartClauseTarget
 *		Identifies which qual clauses we can use for generating pruning steps
 */</comment>
<typedef>typedef <type><enum>enum <name>PartClauseTarget</name>
<block>{
	<decl><name>PARTTARGET_PLANNER</name></decl>,			<comment type="block">/* want to prune during planning */</comment>
	<decl><name>PARTTARGET_INITIAL</name></decl>,			<comment type="block">/* want to prune during executor startup */</comment>
	<decl><name>PARTTARGET_EXEC</name></decl>				<comment type="block">/* want to prune during each plan node scan */</comment>
}</block></enum></type> <name>PartClauseTarget</name>;</typedef>

<comment type="block">/*
 * GeneratePruningStepsContext
 *		Information about the current state of generation of "pruning steps"
 *		for a given set of clauses
 *
 * gen_partprune_steps() initializes and returns an instance of this struct.
 *
 * Note that has_mutable_op, has_mutable_arg, and has_exec_param are set if
 * we found any potentially-useful-for-pruning clause having those properties,
 * whether or not we actually used the clause in the steps list.  This
 * definition allows us to skip the PARTTARGET_EXEC pass in some cases.
 */</comment>
<typedef>typedef <type><struct>struct <name>GeneratePruningStepsContext</name>
<block>{
	<comment type="block">/* Copies of input arguments for gen_partprune_steps: */</comment>
	<decl_stmt><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>rel</name></decl>;</decl_stmt>			<comment type="block">/* the partitioned relation */</comment>
	<decl_stmt><decl><type><name>PartClauseTarget</name></type> <name>target</name></decl>;</decl_stmt>	<comment type="block">/* use-case we're generating steps for */</comment>
	<comment type="block">/* Result data: */</comment>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>steps</name></decl>;</decl_stmt>			<comment type="block">/* list of PartitionPruneSteps */</comment>
	<decl_stmt><decl><type><name>bool</name></type>		<name>has_mutable_op</name></decl>;</decl_stmt> <comment type="block">/* clauses include any stable operators */</comment>
	<decl_stmt><decl><type><name>bool</name></type>		<name>has_mutable_arg</name></decl>;</decl_stmt>	<comment type="block">/* clauses include any mutable comparison
									 * values, *other than* exec params */</comment>
	<decl_stmt><decl><type><name>bool</name></type>		<name>has_exec_param</name></decl>;</decl_stmt> <comment type="block">/* clauses include any PARAM_EXEC params */</comment>
	<decl_stmt><decl><type><name>bool</name></type>		<name>contradictory</name></decl>;</decl_stmt>	<comment type="block">/* clauses were proven self-contradictory */</comment>
	<comment type="block">/* Working state: */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>next_step_id</name></decl>;</decl_stmt>
}</block></struct></type> <name>GeneratePruningStepsContext</name>;</typedef>

<comment type="block">/* The result of performing one PartitionPruneStep */</comment>
<typedef>typedef <type><struct>struct <name>PruneStepResult</name>
<block>{
	<comment type="block">/*
	 * The offsets of bounds (in a table's boundinfo) whose partition is
	 * selected by the pruning step.
	 */</comment>
	<decl_stmt><decl><type><name>Bitmapset</name>  <modifier>*</modifier></type><name>bound_offsets</name></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>bool</name></type>		<name>scan_default</name></decl>;</decl_stmt>	<comment type="block">/* Scan the default partition? */</comment>
	<decl_stmt><decl><type><name>bool</name></type>		<name>scan_null</name></decl>;</decl_stmt>		<comment type="block">/* Scan the partition for NULL values? */</comment>
}</block></struct></type> <name>PruneStepResult</name>;</typedef>


<function_decl><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type><name>make_partitionedrel_pruneinfo</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
							  <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>parentrel</name></decl></parameter>,
							  <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>relid_subplan_map</name></decl></parameter>,
							  <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>partitioned_rels</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>prunequal</name></decl></parameter>,
							  <parameter><decl><type><name>Bitmapset</name> <modifier>*</modifier><modifier>*</modifier></type><name>matchedsubplans</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>gen_partprune_steps</name><parameter_list>(<parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>rel</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>clauses</name></decl></parameter>,
					<parameter><decl><type><name>PartClauseTarget</name></type> <name>target</name></decl></parameter>,
					<parameter><decl><type><name>GeneratePruningStepsContext</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type><name>gen_partprune_steps_internal</name><parameter_list>(<parameter><decl><type><name>GeneratePruningStepsContext</name> <modifier>*</modifier></type><name>context</name></decl></parameter>,
							 <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>clauses</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>PartitionPruneStep</name> <modifier>*</modifier></type><name>gen_prune_step_op</name><parameter_list>(<parameter><decl><type><name>GeneratePruningStepsContext</name> <modifier>*</modifier></type><name>context</name></decl></parameter>,
				  <parameter><decl><type><name>StrategyNumber</name></type> <name>opstrategy</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>op_is_ne</name></decl></parameter>,
				  <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>exprs</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>cmpfns</name></decl></parameter>, <parameter><decl><type><name>Bitmapset</name> <modifier>*</modifier></type><name>nullkeys</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>PartitionPruneStep</name> <modifier>*</modifier></type><name>gen_prune_step_combine</name><parameter_list>(<parameter><decl><type><name>GeneratePruningStepsContext</name> <modifier>*</modifier></type><name>context</name></decl></parameter>,
					   <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>source_stepids</name></decl></parameter>,
					   <parameter><decl><type><name>PartitionPruneCombineOp</name></type> <name>combineOp</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>PartitionPruneStep</name> <modifier>*</modifier></type><name>gen_prune_steps_from_opexps</name><parameter_list>(<parameter><decl><type><name>GeneratePruningStepsContext</name> <modifier>*</modifier></type><name>context</name></decl></parameter>,
							<parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>keyclauses</name></decl></parameter>, <parameter><decl><type><name>Bitmapset</name> <modifier>*</modifier></type><name>nullkeys</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>PartClauseMatchStatus</name></type> <name>match_clause_to_partition_key</name><parameter_list>(<parameter><decl><type><name>GeneratePruningStepsContext</name> <modifier>*</modifier></type><name>context</name></decl></parameter>,
							  <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>clause</name></decl></parameter>, <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>partkey</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>partkeyidx</name></decl></parameter>,
							  <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>clause_is_not_null</name></decl></parameter>,
							  <parameter><decl><type><name>PartClauseInfo</name> <modifier>*</modifier><modifier>*</modifier></type><name>pc</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>clause_steps</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type><name>get_steps_using_prefix</name><parameter_list>(<parameter><decl><type><name>GeneratePruningStepsContext</name> <modifier>*</modifier></type><name>context</name></decl></parameter>,
					   <parameter><decl><type><name>StrategyNumber</name></type> <name>step_opstrategy</name></decl></parameter>,
					   <parameter><decl><type><name>bool</name></type> <name>step_op_is_ne</name></decl></parameter>,
					   <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>step_lastexpr</name></decl></parameter>,
					   <parameter><decl><type><name>Oid</name></type> <name>step_lastcmpfn</name></decl></parameter>,
					   <parameter><decl><type><name>int</name></type> <name>step_lastkeyno</name></decl></parameter>,
					   <parameter><decl><type><name>Bitmapset</name> <modifier>*</modifier></type><name>step_nullkeys</name></decl></parameter>,
					   <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>prefix</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type><name>get_steps_using_prefix_recurse</name><parameter_list>(<parameter><decl><type><name>GeneratePruningStepsContext</name> <modifier>*</modifier></type><name>context</name></decl></parameter>,
							   <parameter><decl><type><name>StrategyNumber</name></type> <name>step_opstrategy</name></decl></parameter>,
							   <parameter><decl><type><name>bool</name></type> <name>step_op_is_ne</name></decl></parameter>,
							   <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>step_lastexpr</name></decl></parameter>,
							   <parameter><decl><type><name>Oid</name></type> <name>step_lastcmpfn</name></decl></parameter>,
							   <parameter><decl><type><name>int</name></type> <name>step_lastkeyno</name></decl></parameter>,
							   <parameter><decl><type><name>Bitmapset</name> <modifier>*</modifier></type><name>step_nullkeys</name></decl></parameter>,
							   <parameter><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>start</name></decl></parameter>,
							   <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>step_exprs</name></decl></parameter>,
							   <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>step_cmpfns</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>PruneStepResult</name> <modifier>*</modifier></type><name>get_matching_hash_bounds</name><parameter_list>(<parameter><decl><type><name>PartitionPruneContext</name> <modifier>*</modifier></type><name>context</name></decl></parameter>,
						 <parameter><decl><type><name>StrategyNumber</name></type> <name>opstrategy</name></decl></parameter>, <parameter><decl><type><name>Datum</name> <modifier>*</modifier></type><name>values</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nvalues</name></decl></parameter>,
						 <parameter><decl><type><name>FmgrInfo</name> <modifier>*</modifier></type><name>partsupfunc</name></decl></parameter>, <parameter><decl><type><name>Bitmapset</name> <modifier>*</modifier></type><name>nullkeys</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>PruneStepResult</name> <modifier>*</modifier></type><name>get_matching_list_bounds</name><parameter_list>(<parameter><decl><type><name>PartitionPruneContext</name> <modifier>*</modifier></type><name>context</name></decl></parameter>,
						 <parameter><decl><type><name>StrategyNumber</name></type> <name>opstrategy</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>value</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nvalues</name></decl></parameter>,
						 <parameter><decl><type><name>FmgrInfo</name> <modifier>*</modifier></type><name>partsupfunc</name></decl></parameter>, <parameter><decl><type><name>Bitmapset</name> <modifier>*</modifier></type><name>nullkeys</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>PruneStepResult</name> <modifier>*</modifier></type><name>get_matching_range_bounds</name><parameter_list>(<parameter><decl><type><name>PartitionPruneContext</name> <modifier>*</modifier></type><name>context</name></decl></parameter>,
						  <parameter><decl><type><name>StrategyNumber</name></type> <name>opstrategy</name></decl></parameter>, <parameter><decl><type><name>Datum</name> <modifier>*</modifier></type><name>values</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nvalues</name></decl></parameter>,
						  <parameter><decl><type><name>FmgrInfo</name> <modifier>*</modifier></type><name>partsupfunc</name></decl></parameter>, <parameter><decl><type><name>Bitmapset</name> <modifier>*</modifier></type><name>nullkeys</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Bitmapset</name> <modifier>*</modifier></type><name>pull_exec_paramids</name><parameter_list>(<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>expr</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>pull_exec_paramids_walker</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>Bitmapset</name> <modifier>*</modifier><modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Bitmapset</name> <modifier>*</modifier></type><name>get_partkey_exec_paramids</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>steps</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>PruneStepResult</name> <modifier>*</modifier></type><name>perform_pruning_base_step</name><parameter_list>(<parameter><decl><type><name>PartitionPruneContext</name> <modifier>*</modifier></type><name>context</name></decl></parameter>,
						  <parameter><decl><type><name>PartitionPruneStepOp</name> <modifier>*</modifier></type><name>opstep</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>PruneStepResult</name> <modifier>*</modifier></type><name>perform_pruning_combine_step</name><parameter_list>(<parameter><decl><type><name>PartitionPruneContext</name> <modifier>*</modifier></type><name>context</name></decl></parameter>,
							 <parameter><decl><type><name>PartitionPruneStepCombine</name> <modifier>*</modifier></type><name>cstep</name></decl></parameter>,
							 <parameter><decl><type><name>PruneStepResult</name> <modifier>*</modifier><modifier>*</modifier></type><name>step_results</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>PartClauseMatchStatus</name></type> <name>match_boolean_partition_clause</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>partopfamily</name></decl></parameter>,
							   <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>clause</name></decl></parameter>,
							   <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>partkey</name></decl></parameter>,
							   <parameter><decl><type><name>Expr</name> <modifier>*</modifier><modifier>*</modifier></type><name>outconst</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>partkey_datum_from_expr</name><parameter_list>(<parameter><decl><type><name>PartitionPruneContext</name> <modifier>*</modifier></type><name>context</name></decl></parameter>,
						<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>expr</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>stateidx</name></decl></parameter>,
						<parameter><decl><type><name>Datum</name> <modifier>*</modifier></type><name>value</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>isnull</name></decl></parameter>)</parameter_list>;</function_decl>


<comment type="block">/*
 * make_partition_pruneinfo
 *		Builds a PartitionPruneInfo which can be used in the executor to allow
 *		additional partition pruning to take place.  Returns NULL when
 *		partition pruning would be useless.
 *
 * 'parentrel' is the RelOptInfo for an appendrel, and 'subpaths' is the list
 * of scan paths for its child rels.
 *
 * 'partitioned_rels' is a List containing Lists of relids of partitioned
 * tables (a/k/a non-leaf partitions) that are parents of some of the child
 * rels.  Here we attempt to populate the PartitionPruneInfo by adding a
 * 'prune_infos' item for each sublist in the 'partitioned_rels' list.
 * However, some of the sets of partitioned relations may not require any
 * run-time pruning.  In these cases we'll simply not include a 'prune_infos'
 * item for that set and instead we'll add all the subplans which belong to
 * that set into the PartitionPruneInfo's 'other_subplans' field.  Callers
 * will likely never want to prune subplans which are mentioned in this field.
 *
 * 'prunequal' is a list of potential pruning quals.
 */</comment>
<function><type><name>PartitionPruneInfo</name> <modifier>*</modifier></type>
<name>make_partition_pruneinfo</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>parentrel</name></decl></parameter>,
						 <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>subpaths</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>partitioned_rels</name></decl></parameter>,
						 <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>prunequal</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PartitionPruneInfo</name> <modifier>*</modifier></type><name>pruneinfo</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Bitmapset</name>  <modifier>*</modifier></type><name>allmatchedsubplans</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name>		   <modifier>*</modifier></type><name>relid_subplan_map</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>prunerelinfos</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Construct a temporary array to map from planner relids to subplan
	 * indexes.  For convenience, we use 1-based indexes here, so that zero
	 * can represent an un-filled array entry.
	 */</comment>
	<expr_stmt><expr><name>relid_subplan_map</name> <operator>=</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>root</name><operator>-&gt;</operator><name>simple_rel_array_size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * relid_subplan_map maps relid of a leaf partition to the index in
	 * 'subpaths' of the scan plan for that partition.
	 */</comment>
	<expr_stmt><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>subpaths</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Path</name>	   <modifier>*</modifier></type><name>path</name> <init>= <expr><operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>pathrel</name> <init>= <expr><name><name>path</name><operator>-&gt;</operator><name>parent</name></name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>IS_SIMPLE_REL</name><argument_list>(<argument><expr><name>pathrel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>pathrel</name><operator>-&gt;</operator><name>relid</name></name> <operator>&lt;</operator> <name><name>root</name><operator>-&gt;</operator><name>simple_rel_array_size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* No duplicates please */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>relid_subplan_map</name><index>[<expr><name><name>pathrel</name><operator>-&gt;</operator><name>relid</name></name></expr>]</index></name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>relid_subplan_map</name><index>[<expr><name><name>pathrel</name><operator>-&gt;</operator><name>relid</name></name></expr>]</index></name> <operator>=</operator> <name>i</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block>

	<comment type="block">/* We now build a PartitionedRelPruneInfo for each partitioned rel. */</comment>
	<expr_stmt><expr><name>prunerelinfos</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>partitioned_rels</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>rels</name> <init>= <expr><operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>pinfolist</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Bitmapset</name>  <modifier>*</modifier></type><name>matchedsubplans</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>pinfolist</name> <operator>=</operator> <call><name>make_partitionedrel_pruneinfo</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>parentrel</name></expr></argument>,
												  <argument><expr><name>relid_subplan_map</name></expr></argument>,
												  <argument><expr><name>rels</name></expr></argument>, <argument><expr><name>prunequal</name></expr></argument>,
												  <argument><expr><operator>&amp;</operator><name>matchedsubplans</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* When pruning is possible, record the matched subplans */</comment>
		<if_stmt><if>if <condition>(<expr><name>pinfolist</name> <operator>!=</operator> <name>NIL</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>prunerelinfos</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>prunerelinfos</name></expr></argument>, <argument><expr><name>pinfolist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>allmatchedsubplans</name> <operator>=</operator> <call><name>bms_join</name><argument_list>(<argument><expr><name>matchedsubplans</name></expr></argument>,
										  <argument><expr><name>allmatchedsubplans</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>

	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>relid_subplan_map</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If none of the partition hierarchies had any useful run-time pruning
	 * quals, then we can just not bother with run-time pruning.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>prunerelinfos</name> <operator>==</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* Else build the result data structure */</comment>
	<expr_stmt><expr><name>pruneinfo</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>PartitionPruneInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pruneinfo</name><operator>-&gt;</operator><name>prune_infos</name></name> <operator>=</operator> <name>prunerelinfos</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Some subplans may not belong to any of the listed partitioned rels.
	 * This can happen for UNION ALL queries which include a non-partitioned
	 * table, or when some of the hierarchies aren't run-time prunable.  Build
	 * a bitmapset of the indexes of all such subplans, so that the executor
	 * can identify which subplans should never be pruned.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>bms_num_members</name><argument_list>(<argument><expr><name>allmatchedsubplans</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <call><name>list_length</name><argument_list>(<argument><expr><name>subpaths</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Bitmapset</name>  <modifier>*</modifier></type><name>other_subplans</name></decl>;</decl_stmt>

		<comment type="block">/* Create the complement of allmatchedsubplans */</comment>
		<expr_stmt><expr><name>other_subplans</name> <operator>=</operator> <call><name>bms_add_range</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name>subpaths</name></expr></argument>)</argument_list></call> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>other_subplans</name> <operator>=</operator> <call><name>bms_del_members</name><argument_list>(<argument><expr><name>other_subplans</name></expr></argument>, <argument><expr><name>allmatchedsubplans</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>pruneinfo</name><operator>-&gt;</operator><name>other_subplans</name></name> <operator>=</operator> <name>other_subplans</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>pruneinfo</name><operator>-&gt;</operator><name>other_subplans</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<return>return <expr><name>pruneinfo</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * make_partitionedrel_pruneinfo
 *		Build a List of PartitionedRelPruneInfos, one for each partitioned
 *		rel.  These can be used in the executor to allow additional partition
 *		pruning to take place.
 *
 * Here we generate partition pruning steps for 'prunequal' and also build a
 * data structure which allows mapping of partition indexes into 'subpaths'
 * indexes.
 *
 * If no non-Const expressions are being compared to the partition key in any
 * of the 'partitioned_rels', then we return NIL to indicate no run-time
 * pruning should be performed.  Run-time pruning would be useless since the
 * pruning done during planning will have pruned everything that can be.
 *
 * On non-NIL return, 'matchedsubplans' is set to the subplan indexes which
 * were matched to this partition hierarchy.
 */</comment>
<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>make_partitionedrel_pruneinfo</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>parentrel</name></decl></parameter>,
							  <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>relid_subplan_map</name></decl></parameter>,
							  <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>partitioned_rels</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>prunequal</name></decl></parameter>,
							  <parameter><decl><type><name>Bitmapset</name> <modifier>*</modifier><modifier>*</modifier></type><name>matchedsubplans</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>targetpart</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>pinfolist</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>doruntimeprune</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name>		   <modifier>*</modifier></type><name>relid_subpart_map</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Bitmapset</name>  <modifier>*</modifier></type><name>subplansfound</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Construct a temporary array to map from planner relids to index of the
	 * partitioned_rel.  For convenience, we use 1-based indexes here, so that
	 * zero can represent an un-filled array entry.
	 */</comment>
	<expr_stmt><expr><name>relid_subpart_map</name> <operator>=</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>root</name><operator>-&gt;</operator><name>simple_rel_array_size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * relid_subpart_map maps relid of a non-leaf partition to the index in
	 * 'partitioned_rels' of that rel (which will also be the index in the
	 * returned PartitionedRelPruneInfo list of the info for that partition).
	 */</comment>
	<expr_stmt><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>partitioned_rels</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Index</name></type>		<name>rti</name> <init>= <expr><call><name>lfirst_int</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>rti</name> <operator>&lt;</operator> <name><name>root</name><operator>-&gt;</operator><name>simple_rel_array_size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* No duplicates please */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>relid_subpart_map</name><index>[<expr><name>rti</name></expr>]</index></name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>relid_subpart_map</name><index>[<expr><name>rti</name></expr>]</index></name> <operator>=</operator> <name>i</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block>

	<comment type="block">/* We now build a PartitionedRelPruneInfo for each partitioned rel */</comment>
	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>partitioned_rels</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Index</name></type>		<name>rti</name> <init>= <expr><call><name>lfirst_int</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>subpart</name> <init>= <expr><call><name>find_base_rel</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>rti</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>PartitionedRelPruneInfo</name> <modifier>*</modifier></type><name>pinfo</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Bitmapset</name>  <modifier>*</modifier></type><name>present_parts</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>nparts</name> <init>= <expr><name><name>subpart</name><operator>-&gt;</operator><name>nparts</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name>		   <modifier>*</modifier></type><name>subplan_map</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name>		   <modifier>*</modifier></type><name>subpart_map</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>partprunequal</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>initial_pruning_steps</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>exec_pruning_steps</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Bitmapset</name>  <modifier>*</modifier></type><name>execparamids</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>GeneratePruningStepsContext</name></type> <name>context</name></decl>;</decl_stmt>

		<comment type="block">/* POLAR px */</comment>
		<decl_stmt><decl><type><name>Oid</name>		   <modifier>*</modifier></type><name>relid_map</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * The first item in the list is the target partitioned relation.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>targetpart</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>targetpart</name> <operator>=</operator> <name>subpart</name></expr>;</expr_stmt>

			<comment type="block">/*
			 * The prunequal is presented to us as a qual for 'parentrel'.
			 * Frequently this rel is the same as targetpart, so we can skip
			 * an adjust_appendrel_attrs step.  But it might not be, and then
			 * we have to translate.  We update the prunequal parameter here,
			 * because in later iterations of the loop for child partitions,
			 * we want to translate from parent to child variables.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>bms_equal</name><argument_list>(<argument><expr><name><name>parentrel</name><operator>-&gt;</operator><name>relids</name></name></expr></argument>, <argument><expr><name><name>subpart</name><operator>-&gt;</operator><name>relids</name></name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>int</name></type>			<name>nappinfos</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>AppendRelInfo</name> <modifier>*</modifier><modifier>*</modifier></type><name>appinfos</name> <init>= <expr><call><name>find_appinfos_by_relids</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
																   <argument><expr><name><name>subpart</name><operator>-&gt;</operator><name>relids</name></name></expr></argument>,
																   <argument><expr><operator>&amp;</operator><name>nappinfos</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><name>prunequal</name> <operator>=</operator> <operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator> <call><name>adjust_appendrel_attrs</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator>
															<name>prunequal</name></expr></argument>,
															<argument><expr><name>nappinfos</name></expr></argument>,
															<argument><expr><name>appinfos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>appinfos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<expr_stmt><expr><name>partprunequal</name> <operator>=</operator> <name>prunequal</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/*
			 * For sub-partitioned tables the columns may not be in the same
			 * order as the parent, so we must translate the prunequal to make
			 * it compatible with this relation.
			 */</comment>
			<expr_stmt><expr><name>partprunequal</name> <operator>=</operator> <operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator>
				<call><name>adjust_appendrel_attrs_multilevel</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
												  <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>prunequal</name></expr></argument>,
												  <argument><expr><name><name>subpart</name><operator>-&gt;</operator><name>relids</name></name></expr></argument>,
												  <argument><expr><name><name>targetpart</name><operator>-&gt;</operator><name>relids</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<comment type="block">/*
		 * Convert pruning qual to pruning steps.  We may need to do this
		 * twice, once to obtain executor startup pruning steps, and once for
		 * executor per-scan pruning steps.  This first pass creates startup
		 * pruning steps and detects whether there's any possibly-useful quals
		 * that would require per-scan pruning.
		 */</comment>
		<expr_stmt><expr><call><name>gen_partprune_steps</name><argument_list>(<argument><expr><name>subpart</name></expr></argument>, <argument><expr><name>partprunequal</name></expr></argument>, <argument><expr><name>PARTTARGET_INITIAL</name></expr></argument>,
							<argument><expr><operator>&amp;</operator><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>context</name><operator>.</operator><name>contradictory</name></name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * This shouldn't happen as the planner should have detected this
			 * earlier. However, we do use additional quals from parameterized
			 * paths here. These do only compare Params to the partition key,
			 * so this shouldn't cause the discovery of any new qual
			 * contradictions that were not previously discovered as the Param
			 * values are unknown during planning.  Anyway, we'd better do
			 * something sane here, so let's just disable run-time pruning.
			 */</comment>
			<return>return <expr><name>NIL</name></expr>;</return>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * If no mutable operators or expressions appear in usable pruning
		 * clauses, then there's no point in running startup pruning, because
		 * plan-time pruning should have pruned everything prunable.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>context</name><operator>.</operator><name>has_mutable_op</name></name> <operator>||</operator> <name><name>context</name><operator>.</operator><name>has_mutable_arg</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>initial_pruning_steps</name> <operator>=</operator> <name><name>context</name><operator>.</operator><name>steps</name></name></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>initial_pruning_steps</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<comment type="block">/*
		 * If no exec Params appear in potentially-usable pruning clauses,
		 * then there's no point in even thinking about per-scan pruning.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>context</name><operator>.</operator><name>has_exec_param</name></name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* ... OK, we'd better think about it */</comment>
			<expr_stmt><expr><call><name>gen_partprune_steps</name><argument_list>(<argument><expr><name>subpart</name></expr></argument>, <argument><expr><name>partprunequal</name></expr></argument>, <argument><expr><name>PARTTARGET_EXEC</name></expr></argument>,
								<argument><expr><operator>&amp;</operator><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>context</name><operator>.</operator><name>contradictory</name></name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* As above, skip run-time pruning if anything fishy happens */</comment>
				<return>return <expr><name>NIL</name></expr>;</return>
			</block_content>}</block></if></if_stmt>

			<expr_stmt><expr><name>exec_pruning_steps</name> <operator>=</operator> <name><name>context</name><operator>.</operator><name>steps</name></name></expr>;</expr_stmt>

			<comment type="block">/*
			 * Detect which exec Params actually got used; the fact that some
			 * were in available clauses doesn't mean we actually used them.
			 * Skip per-scan pruning if there are none.
			 */</comment>
			<expr_stmt><expr><name>execparamids</name> <operator>=</operator> <call><name>get_partkey_exec_paramids</name><argument_list>(<argument><expr><name>exec_pruning_steps</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>bms_is_empty</name><argument_list>(<argument><expr><name>execparamids</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>exec_pruning_steps</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/* No exec Params anywhere, so forget about scan-time pruning */</comment>
			<expr_stmt><expr><name>exec_pruning_steps</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>execparamids</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>initial_pruning_steps</name> <operator>||</operator> <name>exec_pruning_steps</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>doruntimeprune</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * Construct the subplan and subpart maps for this partitioning level.
		 * Here we convert to zero-based indexes, with -1 for empty entries.
		 * Also construct a Bitmapset of all partitions that are present (that
		 * is, not pruned already).
		 */</comment>
		<expr_stmt><expr><name>subplan_map</name> <operator>=</operator> <operator>(</operator><name>int</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>nparts</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>subpart_map</name> <operator>=</operator> <operator>(</operator><name>int</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>nparts</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>present_parts</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

		<comment type="block">/* POLAR px */</comment>
		<expr_stmt><expr><name>relid_map</name> <operator>=</operator> <operator>(</operator><name>Oid</name> <operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><name>nparts</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nparts</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>partrel</name> <init>= <expr><name><name>subpart</name><operator>-&gt;</operator><name>part_rels</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int</name></type>			<name>subplanidx</name> <init>= <expr><name><name>relid_subplan_map</name><index>[<expr><name><name>partrel</name><operator>-&gt;</operator><name>relid</name></name></expr>]</index></name> <operator>-</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int</name></type>			<name>subpartidx</name> <init>= <expr><name><name>relid_subpart_map</name><index>[<expr><name><name>partrel</name><operator>-&gt;</operator><name>relid</name></name></expr>]</index></name> <operator>-</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><name><name>subplan_map</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>subplanidx</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>subpart_map</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>subpartidx</name></expr>;</expr_stmt>

			<comment type="block">/* POLAR px */</comment>
			<expr_stmt><expr><name><name>relid_map</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>planner_rt_fetch</name><argument_list>(<argument><expr><name><name>partrel</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>, <argument><expr><name>root</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>relid</name></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name>subplanidx</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>present_parts</name> <operator>=</operator> <call><name>bms_add_member</name><argument_list>(<argument><expr><name>present_parts</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/* Record finding this subplan  */</comment>
				<expr_stmt><expr><name>subplansfound</name> <operator>=</operator> <call><name>bms_add_member</name><argument_list>(<argument><expr><name>subplansfound</name></expr></argument>, <argument><expr><name>subplanidx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if>
			<if type="elseif">else if <condition>(<expr><name>subpartidx</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>present_parts</name> <operator>=</operator> <call><name>bms_add_member</name><argument_list>(<argument><expr><name>present_parts</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></for>

		<expr_stmt><expr><name>rte</name> <operator>=</operator> <name><name>root</name><operator>-&gt;</operator><name>simple_rte_array</name><index>[<expr><name><name>subpart</name><operator>-&gt;</operator><name>relid</name></name></expr>]</index></name></expr>;</expr_stmt>

		<expr_stmt><expr><name>pinfo</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>PartitionedRelPruneInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>pinfo</name><operator>-&gt;</operator><name>reloid</name></name> <operator>=</operator> <name><name>rte</name><operator>-&gt;</operator><name>relid</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>pinfo</name><operator>-&gt;</operator><name>pruning_steps</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt> <comment type="block">/* not used */</comment>
		<expr_stmt><expr><name><name>pinfo</name><operator>-&gt;</operator><name>present_parts</name></name> <operator>=</operator> <name>present_parts</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>pinfo</name><operator>-&gt;</operator><name>nparts</name></name> <operator>=</operator> <name>nparts</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>pinfo</name><operator>-&gt;</operator><name>nexprs</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>		<comment type="block">/* not used */</comment>
		<expr_stmt><expr><name><name>pinfo</name><operator>-&gt;</operator><name>subplan_map</name></name> <operator>=</operator> <name>subplan_map</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>pinfo</name><operator>-&gt;</operator><name>subpart_map</name></name> <operator>=</operator> <name>subpart_map</name></expr>;</expr_stmt>
		<comment type="block">/* POLAR px */</comment>
		<expr_stmt><expr><name><name>pinfo</name><operator>-&gt;</operator><name>relid_map</name></name> <operator>=</operator> <name>relid_map</name></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>pinfo</name><operator>-&gt;</operator><name>hasexecparam</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt> <comment type="block">/* not used */</comment>
		<expr_stmt><expr><name><name>pinfo</name><operator>-&gt;</operator><name>do_initial_prune</name></name> <operator>=</operator> <operator>(</operator><name>initial_pruning_steps</name> <operator>!=</operator> <name>NIL</name><operator>)</operator></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>pinfo</name><operator>-&gt;</operator><name>do_exec_prune</name></name> <operator>=</operator> <operator>(</operator><name>exec_pruning_steps</name> <operator>!=</operator> <name>NIL</name><operator>)</operator></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>pinfo</name><operator>-&gt;</operator><name>execparamids</name></name> <operator>=</operator> <name>execparamids</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>pinfo</name><operator>-&gt;</operator><name>initial_pruning_steps</name></name> <operator>=</operator> <name>initial_pruning_steps</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>pinfo</name><operator>-&gt;</operator><name>exec_pruning_steps</name></name> <operator>=</operator> <name>exec_pruning_steps</name></expr>;</expr_stmt>

		<expr_stmt><expr><name>pinfolist</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>pinfolist</name></expr></argument>, <argument><expr><name>pinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>relid_subpart_map</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>doruntimeprune</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* No run-time pruning required. */</comment>
		<return>return <expr><name>NIL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><operator>*</operator><name>matchedsubplans</name> <operator>=</operator> <name>subplansfound</name></expr>;</expr_stmt>

	<return>return <expr><name>pinfolist</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * gen_partprune_steps
 *		Process 'clauses' (typically a rel's baserestrictinfo list of clauses)
 *		and create a list of "partition pruning steps".
 *
 * 'target' tells whether to generate pruning steps for planning (use
 * immutable clauses only), or for executor startup (use any allowable
 * clause except ones containing PARAM_EXEC Params), or for executor
 * per-scan pruning (use any allowable clause).
 *
 * 'context' is an output argument that receives the steps list as well as
 * some subsidiary flags; see the GeneratePruningStepsContext typedef.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>gen_partprune_steps</name><parameter_list>(<parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>rel</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>clauses</name></decl></parameter>, <parameter><decl><type><name>PartClauseTarget</name></type> <name>target</name></decl></parameter>,
					<parameter><decl><type><name>GeneratePruningStepsContext</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* Initialize all output values to zero/false/NULL */</comment>
	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>GeneratePruningStepsContext</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>rel</name></name> <operator>=</operator> <name>rel</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>target</name></name> <operator>=</operator> <name>target</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * For sub-partitioned tables there's a corner case where if the
	 * sub-partitioned table shares any partition keys with its parent, then
	 * it's possible that the partitioning hierarchy allows the parent
	 * partition to only contain a narrower range of values than the
	 * sub-partitioned table does.  In this case it is possible that we'd
	 * include partitions that could not possibly have any tuples matching
	 * 'clauses'.  The possibility of such a partition arrangement is perhaps
	 * unlikely for non-default partitions, but it may be more likely in the
	 * case of default partitions, so we'll add the parent partition table's
	 * partition qual to the clause list in this case only.  This may result
	 * in the default partition being eliminated.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>partition_bound_has_default</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>boundinfo</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
		<name><name>rel</name><operator>-&gt;</operator><name>partition_qual</name></name> <operator>!=</operator> <name>NIL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>partqual</name> <init>= <expr><name><name>rel</name><operator>-&gt;</operator><name>partition_qual</name></name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>partqual</name> <operator>=</operator> <operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator> <call><name>expression_planner</name><argument_list>(<argument><expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>partqual</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Fix Vars to have the desired varno */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>rel</name><operator>-&gt;</operator><name>relid</name></name> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ChangeVarNodes</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>partqual</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name><name>rel</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/* Use list_copy to avoid modifying the passed-in List */</comment>
		<expr_stmt><expr><name>clauses</name> <operator>=</operator> <call><name>list_concat</name><argument_list>(<argument><expr><call><name>list_copy</name><argument_list>(<argument><expr><name>clauses</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>partqual</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Down into the rabbit-hole. */</comment>
	<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>gen_partprune_steps_internal</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><name>clauses</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * prune_append_rel_partitions
 *		Process rel's baserestrictinfo and make use of quals which can be
 *		evaluated during query planning in order to determine the minimum set
 *		of partitions which must be scanned to satisfy these quals.  Returns
 *		the matching partitions in the form of a Relids set containing the
 *		partitions' RT indexes.
 *
 * Callers must ensure that 'rel' is a partitioned table.
 */</comment>
<function><type><name>Relids</name></type>
<name>prune_append_rel_partitions</name><parameter_list>(<parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>rel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Relids</name></type>		<name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>clauses</name> <init>= <expr><name><name>rel</name><operator>-&gt;</operator><name>baserestrictinfo</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>pruning_steps</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>GeneratePruningStepsContext</name></type> <name>gcontext</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PartitionPruneContext</name></type> <name>context</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Bitmapset</name>  <modifier>*</modifier></type><name>partindexes</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>clauses</name> <operator>!=</operator> <name>NIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>part_scheme</name></name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* If there are no partitions, return the empty set */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>rel</name><operator>-&gt;</operator><name>nparts</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Process clauses to extract pruning steps that are usable at plan time.
	 * If the clauses are found to be contradictory, we can return the empty
	 * set.
	 */</comment>
	<expr_stmt><expr><call><name>gen_partprune_steps</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>clauses</name></expr></argument>, <argument><expr><name>PARTTARGET_PLANNER</name></expr></argument>,
						<argument><expr><operator>&amp;</operator><name>gcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>gcontext</name><operator>.</operator><name>contradictory</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>pruning_steps</name> <operator>=</operator> <name><name>gcontext</name><operator>.</operator><name>steps</name></name></expr>;</expr_stmt>

	<comment type="block">/* Set up PartitionPruneContext */</comment>
	<expr_stmt><expr><name><name>context</name><operator>.</operator><name>strategy</name></name> <operator>=</operator> <name><name>rel</name><operator>-&gt;</operator><name>part_scheme</name><operator>-&gt;</operator><name>strategy</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>context</name><operator>.</operator><name>partnatts</name></name> <operator>=</operator> <name><name>rel</name><operator>-&gt;</operator><name>part_scheme</name><operator>-&gt;</operator><name>partnatts</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>context</name><operator>.</operator><name>nparts</name></name> <operator>=</operator> <name><name>rel</name><operator>-&gt;</operator><name>nparts</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>context</name><operator>.</operator><name>boundinfo</name></name> <operator>=</operator> <name><name>rel</name><operator>-&gt;</operator><name>boundinfo</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>context</name><operator>.</operator><name>partcollation</name></name> <operator>=</operator> <name><name>rel</name><operator>-&gt;</operator><name>part_scheme</name><operator>-&gt;</operator><name>partcollation</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>context</name><operator>.</operator><name>partsupfunc</name></name> <operator>=</operator> <name><name>rel</name><operator>-&gt;</operator><name>part_scheme</name><operator>-&gt;</operator><name>partsupfunc</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>context</name><operator>.</operator><name>stepcmpfuncs</name></name> <operator>=</operator> <operator>(</operator><name>FmgrInfo</name> <operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>FmgrInfo</name></expr></argument>)</argument_list></sizeof> <operator>*</operator>
												<name><name>context</name><operator>.</operator><name>partnatts</name></name> <operator>*</operator>
												<call><name>list_length</name><argument_list>(<argument><expr><name>pruning_steps</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>context</name><operator>.</operator><name>ppccontext</name></name> <operator>=</operator> <name>CurrentMemoryContext</name></expr>;</expr_stmt>

	<comment type="block">/* These are not valid when being called from the planner */</comment>
	<expr_stmt><expr><name><name>context</name><operator>.</operator><name>partrel</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>context</name><operator>.</operator><name>planstate</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>context</name><operator>.</operator><name>exprstates</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<comment type="block">/* Actual pruning happens here. */</comment>
	<expr_stmt><expr><name>partindexes</name> <operator>=</operator> <call><name>get_matching_partitions</name><argument_list>(<argument><expr><operator>&amp;</operator><name>context</name></expr></argument>, <argument><expr><name>pruning_steps</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Add selected partitions' RT indexes to result. */</comment>
	<expr_stmt><expr><name>i</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>result</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<while>while <condition>(<expr><operator>(</operator><name>i</name> <operator>=</operator> <call><name>bms_next_member</name><argument_list>(<argument><expr><name>partindexes</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>bms_add_member</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name><name>rel</name><operator>-&gt;</operator><name>part_rels</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>relid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></while>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * get_matching_partitions
 *		Determine partitions that survive partition pruning
 *
 * Note: context-&gt;planstate must be set to a valid PlanState when the
 * pruning_steps were generated with a target other than PARTTARGET_PLANNER.
 *
 * Returns a Bitmapset of the RelOptInfo-&gt;part_rels indexes of the surviving
 * partitions.
 */</comment>
<function><type><name>Bitmapset</name> <modifier>*</modifier></type>
<name>get_matching_partitions</name><parameter_list>(<parameter><decl><type><name>PartitionPruneContext</name> <modifier>*</modifier></type><name>context</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>pruning_steps</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Bitmapset</name>  <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>num_steps</name> <init>= <expr><call><name>list_length</name><argument_list>(<argument><expr><name>pruning_steps</name></expr></argument>)</argument_list></call></expr></init></decl>,
				<decl><type ref="prev"/><name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PruneStepResult</name> <modifier>*</modifier><modifier>*</modifier></type><name>results</name></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name>final_result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>scan_default</name></decl>;</decl_stmt>

	<comment type="block">/* If there are no pruning steps then all partitions match. */</comment>
	<if_stmt><if>if <condition>(<expr><name>num_steps</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>context</name><operator>-&gt;</operator><name>nparts</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><call><name>bms_add_range</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>context</name><operator>-&gt;</operator><name>nparts</name></name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Allocate space for individual pruning steps to store its result.  Each
	 * slot will hold a PruneStepResult after performing a given pruning step.
	 * Later steps may use the result of one or more earlier steps.  The
	 * result of applying all pruning steps is the value contained in the slot
	 * of the last pruning step.
	 */</comment>
	<expr_stmt><expr><name>results</name> <operator>=</operator> <operator>(</operator><name>PruneStepResult</name> <operator>*</operator><operator>*</operator><operator>)</operator>
		<call><name>palloc0</name><argument_list>(<argument><expr><name>num_steps</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>PruneStepResult</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>pruning_steps</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>PartitionPruneStep</name> <modifier>*</modifier></type><name>step</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<switch>switch <condition>(<expr><call><name>nodeTag</name><argument_list>(<argument><expr><name>step</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<case>case <expr><name>T_PartitionPruneStepOp</name></expr>:</case>
				<expr_stmt><expr><name><name>results</name><index>[<expr><name><name>step</name><operator>-&gt;</operator><name>step_id</name></name></expr>]</index></name> <operator>=</operator>
					<call><name>perform_pruning_base_step</name><argument_list>(<argument><expr><name>context</name></expr></argument>,
											  <argument><expr><operator>(</operator><name>PartitionPruneStepOp</name> <operator>*</operator><operator>)</operator> <name>step</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><name>T_PartitionPruneStepCombine</name></expr>:</case>
				<expr_stmt><expr><name><name>results</name><index>[<expr><name><name>step</name><operator>-&gt;</operator><name>step_id</name></name></expr>]</index></name> <operator>=</operator>
					<call><name>perform_pruning_combine_step</name><argument_list>(<argument><expr><name>context</name></expr></argument>,
												 <argument><expr><operator>(</operator><name>PartitionPruneStepCombine</name> <operator>*</operator><operator>)</operator> <name>step</name></expr></argument>,
												 <argument><expr><name>results</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>

			<default>default:</default>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"invalid pruning step type: %d"</literal></expr></argument>,
					 <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <call><name>nodeTag</name><argument_list>(<argument><expr><name>step</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></switch>
	</block_content>}</block>

	<comment type="block">/*
	 * At this point we know the offsets of all the datums whose corresponding
	 * partitions need to be in the result, including special null-accepting
	 * and default partitions.  Collect the actual partition indexes now.
	 */</comment>
	<expr_stmt><expr><name>final_result</name> <operator>=</operator> <name><name>results</name><index>[<expr><name>num_steps</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>final_result</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>result</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>scan_default</name> <operator>=</operator> <name><name>final_result</name><operator>-&gt;</operator><name>scan_default</name></name></expr>;</expr_stmt>
	<while>while <condition>(<expr><operator>(</operator><name>i</name> <operator>=</operator> <call><name>bms_next_member</name><argument_list>(<argument><expr><name><name>final_result</name><operator>-&gt;</operator><name>bound_offsets</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>partindex</name> <init>= <expr><name><name>context</name><operator>-&gt;</operator><name>boundinfo</name><operator>-&gt;</operator><name>indexes</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>partindex</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * In range partitioning cases, if a partition index is -1 it
			 * means that the bound at the offset is the upper bound for a
			 * range not covered by any partition (other than a possible
			 * default partition).  In hash partitioning, the same means no
			 * partition has been defined for the corresponding remainder
			 * value.
			 *
			 * In either case, the value is still part of the queried range of
			 * values, so mark to scan the default partition if one exists.
			 */</comment>
			<expr_stmt><expr><name>scan_default</name> <operator>|=</operator> <call><name>partition_bound_has_default</name><argument_list>(<argument><expr><name><name>context</name><operator>-&gt;</operator><name>boundinfo</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>bms_add_member</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>partindex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></while>

	<comment type="block">/* Add the null and/or default partition if needed and present. */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>final_result</name><operator>-&gt;</operator><name>scan_null</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>context</name><operator>-&gt;</operator><name>strategy</name></name> <operator>==</operator> <name>PARTITION_STRATEGY_LIST</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>partition_bound_accepts_nulls</name><argument_list>(<argument><expr><name><name>context</name><operator>-&gt;</operator><name>boundinfo</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>bms_add_member</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name><name>context</name><operator>-&gt;</operator><name>boundinfo</name><operator>-&gt;</operator><name>null_index</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>scan_default</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>context</name><operator>-&gt;</operator><name>strategy</name></name> <operator>==</operator> <name>PARTITION_STRATEGY_LIST</name> <operator>||</operator>
			   <name><name>context</name><operator>-&gt;</operator><name>strategy</name></name> <operator>==</operator> <name>PARTITION_STRATEGY_RANGE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>partition_bound_has_default</name><argument_list>(<argument><expr><name><name>context</name><operator>-&gt;</operator><name>boundinfo</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>bms_add_member</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name><name>context</name><operator>-&gt;</operator><name>boundinfo</name><operator>-&gt;</operator><name>default_index</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * gen_partprune_steps_internal
 *		Processes 'clauses' to generate partition pruning steps.
 *
 * From OpExpr clauses that are mutually AND'd, we find combinations of those
 * that match to the partition key columns and for every such combination,
 * we emit a PartitionPruneStepOp containing a vector of expressions whose
 * values are used as a look up key to search partitions by comparing the
 * values with partition bounds.  Relevant details of the operator and a
 * vector of (possibly cross-type) comparison functions is also included with
 * each step.
 *
 * For BoolExpr clauses, we recursively generate steps for each argument, and
 * return a PartitionPruneStepCombine of their results.
 *
 * The return value is a list of the steps generated, which are also added to
 * the context's steps list.  Each step is assigned a step identifier, unique
 * even across recursive calls.
 *
 * If we find clauses that are mutually contradictory, or a pseudoconstant
 * clause that contains false, we set context-&gt;contradictory to true and
 * return NIL (that is, no pruning steps).  Caller should consider all
 * partitions as pruned in that case.
 */</comment>
<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>gen_partprune_steps_internal</name><parameter_list>(<parameter><decl><type><name>GeneratePruningStepsContext</name> <modifier>*</modifier></type><name>context</name></decl></parameter>,
							 <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>clauses</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PartitionScheme</name></type> <name>part_scheme</name> <init>= <expr><name><name>context</name><operator>-&gt;</operator><name>rel</name><operator>-&gt;</operator><name>part_scheme</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name><name>keyclauses</name><index>[<expr><name>PARTITION_MAX_KEYS</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Bitmapset</name>  <modifier>*</modifier></type><name>nullkeys</name> <init>= <expr><name>NULL</name></expr></init></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name>notnullkeys</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>generate_opsteps</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>result</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>keyclauses</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>keyclauses</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>clauses</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Expr</name>	   <modifier>*</modifier></type><name>clause</name> <init>= <expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

		<comment type="block">/* Look through RestrictInfo, if any */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>clause</name></expr></argument>, <argument><expr><name>RestrictInfo</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>clause</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>RestrictInfo</name> <operator>*</operator><operator>)</operator> <name>clause</name><operator>)</operator><operator>-&gt;</operator><name>clause</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/* Constant-false-or-null is contradictory */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>clause</name></expr></argument>, <argument><expr><name>Const</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
			<operator>(</operator><operator>(</operator><operator>(</operator><name>Const</name> <operator>*</operator><operator>)</operator> <name>clause</name><operator>)</operator><operator>-&gt;</operator><name>constisnull</name> <operator>||</operator>
			 <operator>!</operator><call><name>DatumGetBool</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>Const</name> <operator>*</operator><operator>)</operator> <name>clause</name><operator>)</operator><operator>-&gt;</operator><name>constvalue</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>contradictory</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<return>return <expr><name>NIL</name></expr>;</return>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* Get the BoolExpr's out of the way. */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>clause</name></expr></argument>, <argument><expr><name>BoolExpr</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * Generate steps for arguments.
			 *
			 * While steps generated for the arguments themselves will be
			 * added to context-&gt;steps during recursion and will be evaluated
			 * independently, collect their step IDs to be stored in the
			 * combine step we'll be creating.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>or_clause</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>clause</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>arg_stepids</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>bool</name></type>		<name>all_args_contradictory</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc1</name></decl>;</decl_stmt>

				<comment type="block">/*
				 * We can share the outer context area with the recursive
				 * call, but contradictory had better not be true yet.
				 */</comment>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name><name>context</name><operator>-&gt;</operator><name>contradictory</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/*
				 * Get pruning step for each arg.  If we get contradictory for
				 * all args, it means the OR expression is false as a whole.
				 */</comment>
				<macro><name>foreach</name><argument_list>(<argument>lc1</argument>, <argument>((BoolExpr *) clause)-&gt;args</argument>)</argument_list></macro>
				<block>{<block_content>
					<decl_stmt><decl><type><name>Expr</name>	   <modifier>*</modifier></type><name>arg</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc1</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>bool</name></type>		<name>arg_contradictory</name></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>argsteps</name></decl>;</decl_stmt>

					<expr_stmt><expr><name>argsteps</name> <operator>=</operator> <call><name>gen_partprune_steps_internal</name><argument_list>(<argument><expr><name>context</name></expr></argument>,
															<argument><expr><call><name>list_make1</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>arg_contradictory</name> <operator>=</operator> <name><name>context</name><operator>-&gt;</operator><name>contradictory</name></name></expr>;</expr_stmt>
					<comment type="block">/* Keep context-&gt;contradictory clear till we're done */</comment>
					<expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>contradictory</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

					<if_stmt><if>if <condition>(<expr><name>arg_contradictory</name></expr>)</condition>
					<block>{<block_content>
						<comment type="block">/* Just ignore self-contradictory arguments. */</comment>
						<continue>continue;</continue>
					</block_content>}</block></if>
					<else>else<block type="pseudo"><block_content>
						<expr_stmt><expr><name>all_args_contradictory</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

					<if_stmt><if>if <condition>(<expr><name>argsteps</name> <operator>!=</operator> <name>NIL</name></expr>)</condition>
					<block>{<block_content>
						<decl_stmt><decl><type><name>PartitionPruneStep</name> <modifier>*</modifier></type><name>step</name></decl>;</decl_stmt>

						<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name>argsteps</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><name>step</name> <operator>=</operator> <operator>(</operator><name>PartitionPruneStep</name> <operator>*</operator><operator>)</operator> <call><name>linitial</name><argument_list>(<argument><expr><name>argsteps</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><name>arg_stepids</name> <operator>=</operator> <call><name>lappend_int</name><argument_list>(<argument><expr><name>arg_stepids</name></expr></argument>, <argument><expr><name><name>step</name><operator>-&gt;</operator><name>step_id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block></if>
					<else>else
					<block>{<block_content>
						<comment type="block">/*
						 * The arg didn't contain a clause matching this
						 * partition key.  We cannot prune using such an arg.
						 * To indicate that to the pruning code, we must
						 * construct a dummy PartitionPruneStepCombine whose
						 * source_stepids is set to an empty List.
						 *
						 * However, if we can prove using constraint exclusion
						 * that the clause refutes the table's partition
						 * constraint (if it's sub-partitioned), we need not
						 * bother with that.  That is, we effectively ignore
						 * this OR arm.
						 */</comment>
						<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>partconstr</name> <init>= <expr><name><name>context</name><operator>-&gt;</operator><name>rel</name><operator>-&gt;</operator><name>partition_qual</name></name></expr></init></decl>;</decl_stmt>
						<decl_stmt><decl><type><name>PartitionPruneStep</name> <modifier>*</modifier></type><name>orstep</name></decl>;</decl_stmt>

						<if_stmt><if>if <condition>(<expr><name>partconstr</name></expr>)</condition>
						<block>{<block_content>
							<expr_stmt><expr><name>partconstr</name> <operator>=</operator> <operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator>
								<call><name>expression_planner</name><argument_list>(<argument><expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>partconstr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							<if_stmt><if>if <condition>(<expr><name><name>context</name><operator>-&gt;</operator><name>rel</name><operator>-&gt;</operator><name>relid</name></name> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
								<expr_stmt><expr><call><name>ChangeVarNodes</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>partconstr</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>,
											   <argument><expr><name><name>context</name><operator>-&gt;</operator><name>rel</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
							<if_stmt><if>if <condition>(<expr><call><name>predicate_refuted_by</name><argument_list>(<argument><expr><name>partconstr</name></expr></argument>,
													 <argument><expr><call><name>list_make1</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr></argument>,
													 <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
								<continue>continue;</continue></block_content></block></if></if_stmt>
						</block_content>}</block></if></if_stmt>

						<expr_stmt><expr><name>orstep</name> <operator>=</operator> <call><name>gen_prune_step_combine</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><name>NIL</name></expr></argument>,
														<argument><expr><name>PARTPRUNE_COMBINE_UNION</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><name>arg_stepids</name> <operator>=</operator> <call><name>lappend_int</name><argument_list>(<argument><expr><name>arg_stepids</name></expr></argument>, <argument><expr><name><name>orstep</name><operator>-&gt;</operator><name>step_id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block></else></if_stmt>
				</block_content>}</block>

				<comment type="block">/* If all the OR arms are contradictory, we can stop */</comment>
				<if_stmt><if>if <condition>(<expr><name>all_args_contradictory</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>contradictory</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
					<return>return <expr><name>NIL</name></expr>;</return>
				</block_content>}</block></if></if_stmt>

				<if_stmt><if>if <condition>(<expr><name>arg_stepids</name> <operator>!=</operator> <name>NIL</name></expr>)</condition>
				<block>{<block_content>
					<decl_stmt><decl><type><name>PartitionPruneStep</name> <modifier>*</modifier></type><name>step</name></decl>;</decl_stmt>

					<expr_stmt><expr><name>step</name> <operator>=</operator> <call><name>gen_prune_step_combine</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><name>arg_stepids</name></expr></argument>,
												  <argument><expr><name>PARTPRUNE_COMBINE_UNION</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>step</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
				<continue>continue;</continue>
			</block_content>}</block></if>
			<if type="elseif">else if <condition>(<expr><call><name>and_clause</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>clause</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>args</name> <init>= <expr><operator>(</operator><operator>(</operator><name>BoolExpr</name> <operator>*</operator><operator>)</operator> <name>clause</name><operator>)</operator><operator>-&gt;</operator><name>args</name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>argsteps</name></decl>,
						   <decl><type ref="prev"><modifier>*</modifier></type><name>arg_stepids</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc1</name></decl>;</decl_stmt>

				<comment type="block">/*
				 * args may itself contain clauses of arbitrary type, so just
				 * recurse and later combine the component partitions sets
				 * using a combine step.
				 */</comment>
				<expr_stmt><expr><name>argsteps</name> <operator>=</operator> <call><name>gen_partprune_steps_internal</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/* If any AND arm is contradictory, we can stop immediately */</comment>
				<if_stmt><if>if <condition>(<expr><name><name>context</name><operator>-&gt;</operator><name>contradictory</name></name></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>NIL</name></expr>;</return></block_content></block></if></if_stmt>

				<macro><name>foreach</name><argument_list>(<argument>lc1</argument>, <argument>argsteps</argument>)</argument_list></macro>
				<block>{<block_content>
					<decl_stmt><decl><type><name>PartitionPruneStep</name> <modifier>*</modifier></type><name>step</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc1</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

					<expr_stmt><expr><name>arg_stepids</name> <operator>=</operator> <call><name>lappend_int</name><argument_list>(<argument><expr><name>arg_stepids</name></expr></argument>, <argument><expr><name><name>step</name><operator>-&gt;</operator><name>step_id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block>

				<if_stmt><if>if <condition>(<expr><name>arg_stepids</name> <operator>!=</operator> <name>NIL</name></expr>)</condition>
				<block>{<block_content>
					<decl_stmt><decl><type><name>PartitionPruneStep</name> <modifier>*</modifier></type><name>step</name></decl>;</decl_stmt>

					<expr_stmt><expr><name>step</name> <operator>=</operator> <call><name>gen_prune_step_combine</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><name>arg_stepids</name></expr></argument>,
												  <argument><expr><name>PARTPRUNE_COMBINE_INTERSECT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>step</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
				<continue>continue;</continue>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/*
			 * Fall-through for a NOT clause, which if it's a Boolean clause,
			 * will be handled in match_clause_to_partition_key(). We
			 * currently don't perform any pruning for more complex NOT
			 * clauses.
			 */</comment>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * See if we can match this clause to any of the partition keys.
		 */</comment>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>part_scheme</name><operator>-&gt;</operator><name>partnatts</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Expr</name>	   <modifier>*</modifier></type><name>partkey</name> <init>= <expr><call><name>linitial</name><argument_list>(<argument><expr><name><name>context</name><operator>-&gt;</operator><name>rel</name><operator>-&gt;</operator><name>partexprs</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>bool</name></type>		<name>clause_is_not_null</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>PartClauseInfo</name> <modifier>*</modifier></type><name>pc</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>clause_steps</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>

			<switch>switch <condition>(<expr><call><name>match_clause_to_partition_key</name><argument_list>(<argument><expr><name>context</name></expr></argument>,
												  <argument><expr><name>clause</name></expr></argument>, <argument><expr><name>partkey</name></expr></argument>, <argument><expr><name>i</name></expr></argument>,
												  <argument><expr><operator>&amp;</operator><name>clause_is_not_null</name></expr></argument>,
												  <argument><expr><operator>&amp;</operator><name>pc</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>clause_steps</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<case>case <expr><name>PARTCLAUSE_MATCH_CLAUSE</name></expr>:</case>
					<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>pc</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<comment type="block">/*
					 * Since we only allow strict operators, check for any
					 * contradicting IS NULL.
					 */</comment>
					<if_stmt><if>if <condition>(<expr><call><name>bms_is_member</name><argument_list>(<argument><expr><name>i</name></expr></argument>, <argument><expr><name>nullkeys</name></expr></argument>)</argument_list></call></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>contradictory</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
						<return>return <expr><name>NIL</name></expr>;</return>
					</block_content>}</block></if></if_stmt>
					<expr_stmt><expr><name>generate_opsteps</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>keyclauses</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>keyclauses</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>pc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<break>break;</break>

				<case>case <expr><name>PARTCLAUSE_MATCH_NULLNESS</name></expr>:</case>
					<if_stmt><if>if <condition>(<expr><operator>!</operator><name>clause_is_not_null</name></expr>)</condition>
					<block>{<block_content>
						<comment type="block">/*
						 * check for conflicting IS NOT NULL as well as
						 * contradicting strict clauses
						 */</comment>
						<if_stmt><if>if <condition>(<expr><call><name>bms_is_member</name><argument_list>(<argument><expr><name>i</name></expr></argument>, <argument><expr><name>notnullkeys</name></expr></argument>)</argument_list></call> <operator>||</operator>
							<name><name>keyclauses</name><index>[<expr><name>i</name></expr>]</index></name> <operator>!=</operator> <name>NIL</name></expr>)</condition>
						<block>{<block_content>
							<expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>contradictory</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
							<return>return <expr><name>NIL</name></expr>;</return>
						</block_content>}</block></if></if_stmt>
						<expr_stmt><expr><name>nullkeys</name> <operator>=</operator> <call><name>bms_add_member</name><argument_list>(<argument><expr><name>nullkeys</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block></if>
					<else>else
					<block>{<block_content>
						<comment type="block">/* check for conflicting IS NULL */</comment>
						<if_stmt><if>if <condition>(<expr><call><name>bms_is_member</name><argument_list>(<argument><expr><name>i</name></expr></argument>, <argument><expr><name>nullkeys</name></expr></argument>)</argument_list></call></expr>)</condition>
						<block>{<block_content>
							<expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>contradictory</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
							<return>return <expr><name>NIL</name></expr>;</return>
						</block_content>}</block></if></if_stmt>
						<expr_stmt><expr><name>notnullkeys</name> <operator>=</operator> <call><name>bms_add_member</name><argument_list>(<argument><expr><name>notnullkeys</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block></else></if_stmt>
					<break>break;</break>

				<case>case <expr><name>PARTCLAUSE_MATCH_STEPS</name></expr>:</case>
					<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>clause_steps</name> <operator>!=</operator> <name>NIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>list_concat</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>clause_steps</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<break>break;</break>

				<case>case <expr><name>PARTCLAUSE_MATCH_CONTRADICT</name></expr>:</case>
					<comment type="block">/* We've nothing more to do if a contradiction was found. */</comment>
					<expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>contradictory</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
					<return>return <expr><name>NIL</name></expr>;</return>

				<case>case <expr><name>PARTCLAUSE_NOMATCH</name></expr>:</case>

					<comment type="block">/*
					 * Clause didn't match this key, but it might match the
					 * next one.
					 */</comment>
					<continue>continue;</continue>

				<case>case <expr><name>PARTCLAUSE_UNSUPPORTED</name></expr>:</case>
					<comment type="block">/* This clause cannot be used for pruning. */</comment>
					<break>break;</break>
			</block_content>}</block></switch>

			<comment type="block">/* done; go check the next clause. */</comment>
			<break>break;</break>
		</block_content>}</block></for>
	</block_content>}</block>

	<comment type="block">/*-----------
	 * Now generate some (more) pruning steps.  We have three strategies:
	 *
	 * 1) Generate pruning steps based on IS NULL clauses:
	 *   a) For list partitioning, null partition keys can only be found in
	 *      the designated null-accepting partition, so if there are IS NULL
	 *      clauses containing partition keys we should generate a pruning
	 *      step that gets rid of all partitions but that one.  We can
	 *      disregard any OpExpr we may have found.
	 *   b) For range partitioning, only the default partition can contain
	 *      NULL values, so the same rationale applies.
	 *   c) For hash partitioning, we only apply this strategy if we have
	 *      IS NULL clauses for all the keys.  Strategy 2 below will take
	 *      care of the case where some keys have OpExprs and others have
	 *      IS NULL clauses.
	 *
	 * 2) If not, generate steps based on OpExprs we have (if any).
	 *
	 * 3) If this doesn't work either, we may be able to generate steps to
	 *    prune just the null-accepting partition (if one exists), if we have
	 *    IS NOT NULL clauses for all partition keys.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>bms_is_empty</name><argument_list>(<argument><expr><name>nullkeys</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
		<operator>(</operator><name><name>part_scheme</name><operator>-&gt;</operator><name>strategy</name></name> <operator>==</operator> <name>PARTITION_STRATEGY_LIST</name> <operator>||</operator>
		 <name><name>part_scheme</name><operator>-&gt;</operator><name>strategy</name></name> <operator>==</operator> <name>PARTITION_STRATEGY_RANGE</name> <operator>||</operator>
		 <operator>(</operator><name><name>part_scheme</name><operator>-&gt;</operator><name>strategy</name></name> <operator>==</operator> <name>PARTITION_STRATEGY_HASH</name> <operator>&amp;&amp;</operator>
		  <call><name>bms_num_members</name><argument_list>(<argument><expr><name>nullkeys</name></expr></argument>)</argument_list></call> <operator>==</operator> <name><name>part_scheme</name><operator>-&gt;</operator><name>partnatts</name></name><operator>)</operator><operator>)</operator></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>PartitionPruneStep</name> <modifier>*</modifier></type><name>step</name></decl>;</decl_stmt>

		<comment type="block">/* Strategy 1 */</comment>
		<expr_stmt><expr><name>step</name> <operator>=</operator> <call><name>gen_prune_step_op</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><name>InvalidStrategy</name></expr></argument>,
								 <argument><expr><name>false</name></expr></argument>, <argument><expr><name>NIL</name></expr></argument>, <argument><expr><name>NIL</name></expr></argument>, <argument><expr><name>nullkeys</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>step</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>generate_opsteps</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>PartitionPruneStep</name> <modifier>*</modifier></type><name>step</name></decl>;</decl_stmt>

		<comment type="block">/* Strategy 2 */</comment>
		<expr_stmt><expr><name>step</name> <operator>=</operator> <call><name>gen_prune_steps_from_opexps</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><name>keyclauses</name></expr></argument>, <argument><expr><name>nullkeys</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>step</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>step</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>bms_num_members</name><argument_list>(<argument><expr><name>notnullkeys</name></expr></argument>)</argument_list></call> <operator>==</operator> <name><name>part_scheme</name><operator>-&gt;</operator><name>partnatts</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>PartitionPruneStep</name> <modifier>*</modifier></type><name>step</name></decl>;</decl_stmt>

		<comment type="block">/* Strategy 3 */</comment>
		<expr_stmt><expr><name>step</name> <operator>=</operator> <call><name>gen_prune_step_op</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><name>InvalidStrategy</name></expr></argument>,
								 <argument><expr><name>false</name></expr></argument>, <argument><expr><name>NIL</name></expr></argument>, <argument><expr><name>NIL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>step</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Finally, results from all entries appearing in result should be
	 * combined using an INTERSECT combine step, if more than one.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>step_ids</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>

		<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>result</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>PartitionPruneStep</name> <modifier>*</modifier></type><name>step</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><name>step_ids</name> <operator>=</operator> <call><name>lappend_int</name><argument_list>(<argument><expr><name>step_ids</name></expr></argument>, <argument><expr><name><name>step</name><operator>-&gt;</operator><name>step_id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>

		<if_stmt><if>if <condition>(<expr><name>step_ids</name> <operator>!=</operator> <name>NIL</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>PartitionPruneStep</name> <modifier>*</modifier></type><name>step</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>step</name> <operator>=</operator> <call><name>gen_prune_step_combine</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><name>step_ids</name></expr></argument>,
										  <argument><expr><name>PARTPRUNE_COMBINE_INTERSECT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>step</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * gen_prune_step_op
 *		Generate a pruning step for a specific operator
 *
 * The step is assigned a unique step identifier and added to context's 'steps'
 * list.
 */</comment>
<function><type><specifier>static</specifier> <name>PartitionPruneStep</name> <modifier>*</modifier></type>
<name>gen_prune_step_op</name><parameter_list>(<parameter><decl><type><name>GeneratePruningStepsContext</name> <modifier>*</modifier></type><name>context</name></decl></parameter>,
				  <parameter><decl><type><name>StrategyNumber</name></type> <name>opstrategy</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>op_is_ne</name></decl></parameter>,
				  <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>exprs</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>cmpfns</name></decl></parameter>,
				  <parameter><decl><type><name>Bitmapset</name> <modifier>*</modifier></type><name>nullkeys</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PartitionPruneStepOp</name> <modifier>*</modifier></type><name>opstep</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>PartitionPruneStepOp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>opstep</name><operator>-&gt;</operator><name>step</name><operator>.</operator><name>step_id</name></name> <operator>=</operator> <name><name>context</name><operator>-&gt;</operator><name>next_step_id</name></name><operator>++</operator></expr>;</expr_stmt>

	<comment type="block">/*
	 * For clauses that contain an &lt;&gt; operator, set opstrategy to
	 * InvalidStrategy to signal get_matching_list_bounds to do the right
	 * thing.
	 */</comment>
	<expr_stmt><expr><name><name>opstep</name><operator>-&gt;</operator><name>opstrategy</name></name> <operator>=</operator> <ternary><condition><expr><name>op_is_ne</name></expr> ?</condition><then> <expr><name>InvalidStrategy</name></expr> </then><else>: <expr><name>opstrategy</name></expr></else></ternary></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name>exprs</name></expr></argument>)</argument_list></call> <operator>==</operator> <call><name>list_length</name><argument_list>(<argument><expr><name>cmpfns</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>opstep</name><operator>-&gt;</operator><name>exprs</name></name> <operator>=</operator> <name>exprs</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>opstep</name><operator>-&gt;</operator><name>cmpfns</name></name> <operator>=</operator> <name>cmpfns</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>opstep</name><operator>-&gt;</operator><name>nullkeys</name></name> <operator>=</operator> <name>nullkeys</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>steps</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>context</name><operator>-&gt;</operator><name>steps</name></name></expr></argument>, <argument><expr><name>opstep</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><operator>(</operator><name>PartitionPruneStep</name> <operator>*</operator><operator>)</operator> <name>opstep</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * gen_prune_step_combine
 *		Generate a pruning step for a combination of several other steps
 *
 * The step is assigned a unique step identifier and added to context's
 * 'steps' list.
 */</comment>
<function><type><specifier>static</specifier> <name>PartitionPruneStep</name> <modifier>*</modifier></type>
<name>gen_prune_step_combine</name><parameter_list>(<parameter><decl><type><name>GeneratePruningStepsContext</name> <modifier>*</modifier></type><name>context</name></decl></parameter>,
					   <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>source_stepids</name></decl></parameter>,
					   <parameter><decl><type><name>PartitionPruneCombineOp</name></type> <name>combineOp</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PartitionPruneStepCombine</name> <modifier>*</modifier></type><name>cstep</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>PartitionPruneStepCombine</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>cstep</name><operator>-&gt;</operator><name>step</name><operator>.</operator><name>step_id</name></name> <operator>=</operator> <name><name>context</name><operator>-&gt;</operator><name>next_step_id</name></name><operator>++</operator></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>cstep</name><operator>-&gt;</operator><name>combineOp</name></name> <operator>=</operator> <name>combineOp</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>cstep</name><operator>-&gt;</operator><name>source_stepids</name></name> <operator>=</operator> <name>source_stepids</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>steps</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>context</name><operator>-&gt;</operator><name>steps</name></name></expr></argument>, <argument><expr><name>cstep</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><operator>(</operator><name>PartitionPruneStep</name> <operator>*</operator><operator>)</operator> <name>cstep</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * gen_prune_steps_from_opexps
 *		Generate pruning steps based on clauses for partition keys
 *
 * 'keyclauses' contains one list of clauses per partition key.  We check here
 * if we have found clauses for a valid subset of the partition key. In some
 * cases, (depending on the type of partitioning being used) if we didn't
 * find clauses for a given key, we discard clauses that may have been
 * found for any subsequent keys; see specific notes below.
 */</comment>
<function><type><specifier>static</specifier> <name>PartitionPruneStep</name> <modifier>*</modifier></type>
<name>gen_prune_steps_from_opexps</name><parameter_list>(<parameter><decl><type><name>GeneratePruningStepsContext</name> <modifier>*</modifier></type><name>context</name></decl></parameter>,
							<parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>keyclauses</name></decl></parameter>, <parameter><decl><type><name>Bitmapset</name> <modifier>*</modifier></type><name>nullkeys</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PartitionScheme</name></type> <name>part_scheme</name> <init>= <expr><name><name>context</name><operator>-&gt;</operator><name>rel</name><operator>-&gt;</operator><name>part_scheme</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>opsteps</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name><name>btree_clauses</name><index>[<expr><name>BTMaxStrategyNumber</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name><name>hash_clauses</name><index>[<expr><name>HTMaxStrategyNumber</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>btree_clauses</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>btree_clauses</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>hash_clauses</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>hash_clauses</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>part_scheme</name><operator>-&gt;</operator><name>partnatts</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>clauselist</name> <init>= <expr><name><name>keyclauses</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>consider_next_key</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>

		<comment type="block">/*
		 * For range partitioning, if we have no clauses for the current key,
		 * we can't consider any later keys either, so we can stop here.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>part_scheme</name><operator>-&gt;</operator><name>strategy</name></name> <operator>==</operator> <name>PARTITION_STRATEGY_RANGE</name> <operator>&amp;&amp;</operator>
			<name>clauselist</name> <operator>==</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * For hash partitioning, if a column doesn't have the necessary
		 * equality clause, there should be an IS NULL clause, otherwise
		 * pruning is not possible.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>part_scheme</name><operator>-&gt;</operator><name>strategy</name></name> <operator>==</operator> <name>PARTITION_STRATEGY_HASH</name> <operator>&amp;&amp;</operator>
			<name>clauselist</name> <operator>==</operator> <name>NIL</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>bms_is_member</name><argument_list>(<argument><expr><name>i</name></expr></argument>, <argument><expr><name>nullkeys</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

		<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>clauselist</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>PartClauseInfo</name> <modifier>*</modifier></type><name>pc</name> <init>= <expr><operator>(</operator><name>PartClauseInfo</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Oid</name></type>			<name>lefttype</name></decl>,
						<decl><type ref="prev"/><name>righttype</name></decl>;</decl_stmt>

			<comment type="block">/* Look up the operator's btree/hash strategy number. */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>pc</name><operator>-&gt;</operator><name>op_strategy</name></name> <operator>==</operator> <name>InvalidStrategy</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>get_op_opfamily_properties</name><argument_list>(<argument><expr><name><name>pc</name><operator>-&gt;</operator><name>opno</name></name></expr></argument>,
										   <argument><expr><name><name>part_scheme</name><operator>-&gt;</operator><name>partopfamily</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,
										   <argument><expr><name>false</name></expr></argument>,
										   <argument><expr><operator>&amp;</operator><name><name>pc</name><operator>-&gt;</operator><name>op_strategy</name></name></expr></argument>,
										   <argument><expr><operator>&amp;</operator><name>lefttype</name></expr></argument>,
										   <argument><expr><operator>&amp;</operator><name>righttype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<switch>switch <condition>(<expr><name><name>part_scheme</name><operator>-&gt;</operator><name>strategy</name></name></expr>)</condition>
			<block>{<block_content>
				<case>case <expr><name>PARTITION_STRATEGY_LIST</name></expr>:</case>
				<case>case <expr><name>PARTITION_STRATEGY_RANGE</name></expr>:</case>
					<expr_stmt><expr><name><name>btree_clauses</name><index>[<expr><name><name>pc</name><operator>-&gt;</operator><name>op_strategy</name></name></expr>]</index></name> <operator>=</operator>
						<call><name>lappend</name><argument_list>(<argument><expr><name><name>btree_clauses</name><index>[<expr><name><name>pc</name><operator>-&gt;</operator><name>op_strategy</name></name></expr>]</index></name></expr></argument>, <argument><expr><name>pc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<comment type="block">/*
					 * We can't consider subsequent partition keys if the
					 * clause for the current key contains a non-inclusive
					 * operator.
					 */</comment>
					<if_stmt><if>if <condition>(<expr><name><name>pc</name><operator>-&gt;</operator><name>op_strategy</name></name> <operator>==</operator> <name>BTLessStrategyNumber</name> <operator>||</operator>
						<name><name>pc</name><operator>-&gt;</operator><name>op_strategy</name></name> <operator>==</operator> <name>BTGreaterStrategyNumber</name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><name>consider_next_key</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
					<break>break;</break>

				<case>case <expr><name>PARTITION_STRATEGY_HASH</name></expr>:</case>
					<if_stmt><if>if <condition>(<expr><name><name>pc</name><operator>-&gt;</operator><name>op_strategy</name></name> <operator>!=</operator> <name>HTEqualStrategyNumber</name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"invalid clause for hash partitioning"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
					<expr_stmt><expr><name><name>hash_clauses</name><index>[<expr><name><name>pc</name><operator>-&gt;</operator><name>op_strategy</name></name></expr>]</index></name> <operator>=</operator>
						<call><name>lappend</name><argument_list>(<argument><expr><name><name>hash_clauses</name><index>[<expr><name><name>pc</name><operator>-&gt;</operator><name>op_strategy</name></name></expr>]</index></name></expr></argument>, <argument><expr><name>pc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<break>break;</break>

				<default>default:</default>
					<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"invalid partition strategy: %c"</literal></expr></argument>,
						 <argument><expr><name><name>part_scheme</name><operator>-&gt;</operator><name>strategy</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<break>break;</break>
			</block_content>}</block></switch>
		</block_content>}</block>

		<comment type="block">/*
		 * If we've decided that clauses for subsequent partition keys
		 * wouldn't be useful for pruning, don't search any further.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>consider_next_key</name></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>
	</block_content>}</block></for>

	<comment type="block">/*
	 * Now, we have divided clauses according to their operator strategies.
	 * Check for each strategy if we can generate pruning step(s) by
	 * collecting a list of expressions whose values will constitute a vector
	 * that can be used as a lookup key by a partition bound searching
	 * function.
	 */</comment>
	<switch>switch <condition>(<expr><name><name>part_scheme</name><operator>-&gt;</operator><name>strategy</name></name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>PARTITION_STRATEGY_LIST</name></expr>:</case>
		<case>case <expr><name>PARTITION_STRATEGY_RANGE</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>eq_clauses</name> <init>= <expr><name><name>btree_clauses</name><index>[<expr><name>BTEqualStrategyNumber</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>le_clauses</name> <init>= <expr><name><name>btree_clauses</name><index>[<expr><name>BTLessEqualStrategyNumber</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>ge_clauses</name> <init>= <expr><name><name>btree_clauses</name><index>[<expr><name>BTGreaterEqualStrategyNumber</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>int</name></type>			<name>strat</name></decl>;</decl_stmt>

				<comment type="block">/*
				 * For each clause under consideration for a given strategy,
				 * we collect expressions from clauses for earlier keys, whose
				 * operator strategy is inclusive, into a list called
				 * 'prefix'. By appending the clause's own expression to the
				 * 'prefix', we'll generate one step using the so generated
				 * vector and assign the current strategy to it.  Actually,
				 * 'prefix' might contain multiple clauses for the same key,
				 * in which case, we must generate steps for various
				 * combinations of expressions of different keys, which
				 * get_steps_using_prefix takes care of for us.
				 */</comment>
				<for>for <control>(<init><expr><name>strat</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>strat</name> <operator>&lt;=</operator> <name>BTMaxStrategyNumber</name></expr>;</condition> <incr><expr><name>strat</name><operator>++</operator></expr></incr>)</control>
				<block>{<block_content>
					<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>btree_clauses[strat]</argument>)</argument_list></macro>
					<block>{<block_content>
						<decl_stmt><decl><type><name>PartClauseInfo</name> <modifier>*</modifier></type><name>pc</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
						<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>eq_start</name></decl>;</decl_stmt>
						<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>le_start</name></decl>;</decl_stmt>
						<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>ge_start</name></decl>;</decl_stmt>
						<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc1</name></decl>;</decl_stmt>
						<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>prefix</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
						<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>pc_steps</name></decl>;</decl_stmt>
						<decl_stmt><decl><type><name>bool</name></type>		<name>prefix_valid</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
						<decl_stmt><decl><type><name>bool</name></type>		<name>pk_has_clauses</name></decl>;</decl_stmt>
						<decl_stmt><decl><type><name>int</name></type>			<name>keyno</name></decl>;</decl_stmt>

						<comment type="block">/*
						 * If this is a clause for the first partition key,
						 * there are no preceding expressions; generate a
						 * pruning step without a prefix.
						 *
						 * Note that we pass NULL for step_nullkeys, because
						 * we don't search list/range partition bounds where
						 * some keys are NULL.
						 */</comment>
						<if_stmt><if>if <condition>(<expr><name><name>pc</name><operator>-&gt;</operator><name>keyno</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
						<block>{<block_content>
							<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>pc</name><operator>-&gt;</operator><name>op_strategy</name></name> <operator>==</operator> <name>strat</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							<expr_stmt><expr><name>pc_steps</name> <operator>=</operator> <call><name>get_steps_using_prefix</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><name>strat</name></expr></argument>,
															  <argument><expr><name><name>pc</name><operator>-&gt;</operator><name>op_is_ne</name></name></expr></argument>,
															  <argument><expr><name><name>pc</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>,
															  <argument><expr><name><name>pc</name><operator>-&gt;</operator><name>cmpfn</name></name></expr></argument>,
															  <argument><expr><literal type="number">0</literal></expr></argument>,
															  <argument><expr><name>NULL</name></expr></argument>,
															  <argument><expr><name>NIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							<expr_stmt><expr><name>opsteps</name> <operator>=</operator> <call><name>list_concat</name><argument_list>(<argument><expr><name>opsteps</name></expr></argument>, <argument><expr><name>pc_steps</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							<continue>continue;</continue>
						</block_content>}</block></if></if_stmt>

						<expr_stmt><expr><name>eq_start</name> <operator>=</operator> <call><name>list_head</name><argument_list>(<argument><expr><name>eq_clauses</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><name>le_start</name> <operator>=</operator> <call><name>list_head</name><argument_list>(<argument><expr><name>le_clauses</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><name>ge_start</name> <operator>=</operator> <call><name>list_head</name><argument_list>(<argument><expr><name>ge_clauses</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

						<comment type="block">/*
						 * We arrange clauses into prefix in ascending order
						 * of their partition key numbers.
						 */</comment>
						<for>for <control>(<init><expr><name>keyno</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>keyno</name> <operator>&lt;</operator> <name><name>pc</name><operator>-&gt;</operator><name>keyno</name></name></expr>;</condition> <incr><expr><name>keyno</name><operator>++</operator></expr></incr>)</control>
						<block>{<block_content>
							<expr_stmt><expr><name>pk_has_clauses</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

							<comment type="block">/*
							 * Expressions from = clauses can always be in the
							 * prefix, provided they're from an earlier key.
							 */</comment>
							<macro><name>for_each_cell</name><argument_list>(<argument>lc1</argument>, <argument>eq_start</argument>)</argument_list></macro>
							<block>{<block_content>
								<decl_stmt><decl><type><name>PartClauseInfo</name> <modifier>*</modifier></type><name>eqpc</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc1</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

								<if_stmt><if>if <condition>(<expr><name><name>eqpc</name><operator>-&gt;</operator><name>keyno</name></name> <operator>==</operator> <name>keyno</name></expr>)</condition>
								<block>{<block_content>
									<expr_stmt><expr><name>prefix</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>prefix</name></expr></argument>, <argument><expr><name>eqpc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
									<expr_stmt><expr><name>pk_has_clauses</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
								</block_content>}</block></if>
								<else>else
								<block>{<block_content>
									<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>eqpc</name><operator>-&gt;</operator><name>keyno</name></name> <operator>&gt;</operator> <name>keyno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
									<break>break;</break>
								</block_content>}</block></else></if_stmt>
							</block_content>}</block>
							<expr_stmt><expr><name>eq_start</name> <operator>=</operator> <name>lc1</name></expr>;</expr_stmt>

							<comment type="block">/*
							 * If we're generating steps for &lt;/&lt;= strategy, we
							 * can add other &lt;= clauses to the prefix,
							 * provided they're from an earlier key.
							 */</comment>
							<if_stmt><if>if <condition>(<expr><name>strat</name> <operator>==</operator> <name>BTLessStrategyNumber</name> <operator>||</operator>
								<name>strat</name> <operator>==</operator> <name>BTLessEqualStrategyNumber</name></expr>)</condition>
							<block>{<block_content>
								<macro><name>for_each_cell</name><argument_list>(<argument>lc1</argument>, <argument>le_start</argument>)</argument_list></macro>
								<block>{<block_content>
									<decl_stmt><decl><type><name>PartClauseInfo</name> <modifier>*</modifier></type><name>lepc</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc1</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

									<if_stmt><if>if <condition>(<expr><name><name>lepc</name><operator>-&gt;</operator><name>keyno</name></name> <operator>==</operator> <name>keyno</name></expr>)</condition>
									<block>{<block_content>
										<expr_stmt><expr><name>prefix</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>prefix</name></expr></argument>, <argument><expr><name>lepc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
										<expr_stmt><expr><name>pk_has_clauses</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
									</block_content>}</block></if>
									<else>else
									<block>{<block_content>
										<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>lepc</name><operator>-&gt;</operator><name>keyno</name></name> <operator>&gt;</operator> <name>keyno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
										<break>break;</break>
									</block_content>}</block></else></if_stmt>
								</block_content>}</block>
								<expr_stmt><expr><name>le_start</name> <operator>=</operator> <name>lc1</name></expr>;</expr_stmt>
							</block_content>}</block></if></if_stmt>

							<comment type="block">/*
							 * If we're generating steps for &gt;/&gt;= strategy, we
							 * can add other &gt;= clauses to the prefix,
							 * provided they're from an earlier key.
							 */</comment>
							<if_stmt><if>if <condition>(<expr><name>strat</name> <operator>==</operator> <name>BTGreaterStrategyNumber</name> <operator>||</operator>
								<name>strat</name> <operator>==</operator> <name>BTGreaterEqualStrategyNumber</name></expr>)</condition>
							<block>{<block_content>
								<macro><name>for_each_cell</name><argument_list>(<argument>lc1</argument>, <argument>ge_start</argument>)</argument_list></macro>
								<block>{<block_content>
									<decl_stmt><decl><type><name>PartClauseInfo</name> <modifier>*</modifier></type><name>gepc</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc1</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

									<if_stmt><if>if <condition>(<expr><name><name>gepc</name><operator>-&gt;</operator><name>keyno</name></name> <operator>==</operator> <name>keyno</name></expr>)</condition>
									<block>{<block_content>
										<expr_stmt><expr><name>prefix</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>prefix</name></expr></argument>, <argument><expr><name>gepc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
										<expr_stmt><expr><name>pk_has_clauses</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
									</block_content>}</block></if>
									<else>else
									<block>{<block_content>
										<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>gepc</name><operator>-&gt;</operator><name>keyno</name></name> <operator>&gt;</operator> <name>keyno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
										<break>break;</break>
									</block_content>}</block></else></if_stmt>
								</block_content>}</block>
								<expr_stmt><expr><name>ge_start</name> <operator>=</operator> <name>lc1</name></expr>;</expr_stmt>
							</block_content>}</block></if></if_stmt>

							<comment type="block">/*
							 * If this key has no clauses, prefix is not valid
							 * anymore.
							 */</comment>
							<if_stmt><if>if <condition>(<expr><operator>!</operator><name>pk_has_clauses</name></expr>)</condition>
							<block>{<block_content>
								<expr_stmt><expr><name>prefix_valid</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
								<break>break;</break>
							</block_content>}</block></if></if_stmt>
						</block_content>}</block></for>

						<comment type="block">/*
						 * If prefix_valid, generate PartitionPruneStepOps.
						 * Otherwise, we would not find clauses for a valid
						 * subset of the partition keys anymore for the
						 * strategy; give up on generating partition pruning
						 * steps further for the strategy.
						 *
						 * As mentioned above, if 'prefix' contains multiple
						 * expressions for the same key, the following will
						 * generate multiple steps, one for each combination
						 * of the expressions for different keys.
						 *
						 * Note that we pass NULL for step_nullkeys, because
						 * we don't search list/range partition bounds where
						 * some keys are NULL.
						 */</comment>
						<if_stmt><if>if <condition>(<expr><name>prefix_valid</name></expr>)</condition>
						<block>{<block_content>
							<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>pc</name><operator>-&gt;</operator><name>op_strategy</name></name> <operator>==</operator> <name>strat</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							<expr_stmt><expr><name>pc_steps</name> <operator>=</operator> <call><name>get_steps_using_prefix</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><name>strat</name></expr></argument>,
															  <argument><expr><name><name>pc</name><operator>-&gt;</operator><name>op_is_ne</name></name></expr></argument>,
															  <argument><expr><name><name>pc</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>,
															  <argument><expr><name><name>pc</name><operator>-&gt;</operator><name>cmpfn</name></name></expr></argument>,
															  <argument><expr><name><name>pc</name><operator>-&gt;</operator><name>keyno</name></name></expr></argument>,
															  <argument><expr><name>NULL</name></expr></argument>,
															  <argument><expr><name>prefix</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							<expr_stmt><expr><name>opsteps</name> <operator>=</operator> <call><name>list_concat</name><argument_list>(<argument><expr><name>opsteps</name></expr></argument>, <argument><expr><name>pc_steps</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						</block_content>}</block></if>
						<else>else<block type="pseudo"><block_content>
							<break>break;</break></block_content></block></else></if_stmt>
					</block_content>}</block>
				</block_content>}</block></for>
				<break>break;</break>
			</block_content>}</block>

		<case>case <expr><name>PARTITION_STRATEGY_HASH</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>eq_clauses</name> <init>= <expr><name><name>hash_clauses</name><index>[<expr><name>HTEqualStrategyNumber</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

				<comment type="block">/* For hash partitioning, we have just the = strategy. */</comment>
				<if_stmt><if>if <condition>(<expr><name>eq_clauses</name> <operator>!=</operator> <name>NIL</name></expr>)</condition>
				<block>{<block_content>
					<decl_stmt><decl><type><name>PartClauseInfo</name> <modifier>*</modifier></type><name>pc</name></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>pc_steps</name></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>prefix</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>int</name></type>			<name>last_keyno</name></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc1</name></decl>;</decl_stmt>

					<comment type="block">/*
					 * Locate the clause for the greatest column.  This may
					 * not belong to the last partition key, but it is the
					 * clause belonging to the last partition key we found a
					 * clause for above.
					 */</comment>
					<expr_stmt><expr><name>pc</name> <operator>=</operator> <call><name>llast</name><argument_list>(<argument><expr><name>eq_clauses</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<comment type="block">/*
					 * There might be multiple clauses which matched to that
					 * partition key; find the first such clause.  While at
					 * it, add all the clauses before that one to 'prefix'.
					 */</comment>
					<expr_stmt><expr><name>last_keyno</name> <operator>=</operator> <name><name>pc</name><operator>-&gt;</operator><name>keyno</name></name></expr>;</expr_stmt>
					<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>eq_clauses</argument>)</argument_list></macro>
					<block>{<block_content>
						<expr_stmt><expr><name>pc</name> <operator>=</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<if_stmt><if>if <condition>(<expr><name><name>pc</name><operator>-&gt;</operator><name>keyno</name></name> <operator>==</operator> <name>last_keyno</name></expr>)</condition><block type="pseudo"><block_content>
							<break>break;</break></block_content></block></if></if_stmt>
						<expr_stmt><expr><name>prefix</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>prefix</name></expr></argument>, <argument><expr><name>pc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block>

					<comment type="block">/*
					 * For each clause for the "last" column, after appending
					 * the clause's own expression to the 'prefix', we'll
					 * generate one step using the so generated vector and
					 * assign = as its strategy.  Actually, 'prefix' might
					 * contain multiple clauses for the same key, in which
					 * case, we must generate steps for various combinations
					 * of expressions of different keys, which
					 * get_steps_using_prefix will take care of for us.
					 */</comment>
					<macro><name>for_each_cell</name><argument_list>(<argument>lc1</argument>, <argument>lc</argument>)</argument_list></macro>
					<block>{<block_content>
						<expr_stmt><expr><name>pc</name> <operator>=</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

						<comment type="block">/*
						 * Note that we pass nullkeys for step_nullkeys,
						 * because we need to tell hash partition bound search
						 * function which of the keys we found IS NULL clauses
						 * for.
						 */</comment>
						<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>pc</name><operator>-&gt;</operator><name>op_strategy</name></name> <operator>==</operator> <name>HTEqualStrategyNumber</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><name>pc_steps</name> <operator>=</operator>
							<call><name>get_steps_using_prefix</name><argument_list>(<argument><expr><name>context</name></expr></argument>,
												   <argument><expr><name>HTEqualStrategyNumber</name></expr></argument>,
												   <argument><expr><name>false</name></expr></argument>,
												   <argument><expr><name><name>pc</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>,
												   <argument><expr><name><name>pc</name><operator>-&gt;</operator><name>cmpfn</name></name></expr></argument>,
												   <argument><expr><name><name>pc</name><operator>-&gt;</operator><name>keyno</name></name></expr></argument>,
												   <argument><expr><name>nullkeys</name></expr></argument>,
												   <argument><expr><name>prefix</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><name>opsteps</name> <operator>=</operator> <call><name>list_concat</name><argument_list>(<argument><expr><name>opsteps</name></expr></argument>, <argument><expr><call><name>list_copy</name><argument_list>(<argument><expr><name>pc_steps</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block>
				</block_content>}</block></if></if_stmt>
				<break>break;</break>
			</block_content>}</block>

		<default>default:</default>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"invalid partition strategy: %c"</literal></expr></argument>,
				 <argument><expr><name><name>part_scheme</name><operator>-&gt;</operator><name>strategy</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
	</block_content>}</block></switch>

	<comment type="block">/* Lastly, add a combine step to mutually AND these op steps, if needed */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name>opsteps</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>opstep_ids</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>

		<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>opsteps</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>PartitionPruneStep</name> <modifier>*</modifier></type><name>step</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><name>opstep_ids</name> <operator>=</operator> <call><name>lappend_int</name><argument_list>(<argument><expr><name>opstep_ids</name></expr></argument>, <argument><expr><name><name>step</name><operator>-&gt;</operator><name>step_id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>

		<if_stmt><if>if <condition>(<expr><name>opstep_ids</name> <operator>!=</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><call><name>gen_prune_step_combine</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><name>opstep_ids</name></expr></argument>,
										  <argument><expr><name>PARTPRUNE_COMBINE_INTERSECT</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>opsteps</name> <operator>!=</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><call><name>linitial</name><argument_list>(<argument><expr><name>opsteps</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

	<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * If the partition key has a collation, then the clause must have the same
 * input collation.  If the partition key is non-collatable, we assume the
 * collation doesn't matter, because while collation wasn't considered when
 * performing partitioning, the clause still may have a collation assigned
 * due to the other input being of a collatable type.
 *
 * See also IndexCollMatchesExprColl.
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PartCollMatchesExprColl</name><parameter_list>(<parameter><type><name>partcoll</name></type></parameter>, <parameter><type><name>exprcoll</name></type></parameter>)</parameter_list></cpp:macro> \
	<cpp:value>((partcoll) == InvalidOid || (partcoll) == (exprcoll))</cpp:value></cpp:define>

<comment type="block">/*
 * match_clause_to_partition_key
 *		Attempt to match the given 'clause' with the specified partition key.
 *
 * Return value is:
 * * PARTCLAUSE_NOMATCH if the clause doesn't match this partition key (but
 *   caller should keep trying, because it might match a subsequent key).
 *   Output arguments: none set.
 *
 * * PARTCLAUSE_MATCH_CLAUSE if there is a match.
 *   Output arguments: *pc is set to a PartClauseInfo constructed for the
 *   matched clause.
 *
 * * PARTCLAUSE_MATCH_NULLNESS if there is a match, and the matched clause was
 *   either a "a IS NULL" or "a IS NOT NULL" clause.
 *   Output arguments: *clause_is_not_null is set to false in the former case
 *   true otherwise.
 *
 * * PARTCLAUSE_MATCH_STEPS if there is a match.
 *   Output arguments: *clause_steps is set to a list of PartitionPruneStep
 *   generated for the clause.
 *
 * * PARTCLAUSE_MATCH_CONTRADICT if the clause is self-contradictory, ie
 *   it provably returns FALSE or NULL.
 *   Output arguments: none set.
 *
 * * PARTCLAUSE_UNSUPPORTED if the clause doesn't match this partition key
 *   and couldn't possibly match any other one either, due to its form or
 *   properties (such as containing a volatile function).
 *   Output arguments: none set.
 */</comment>
<function><type><specifier>static</specifier> <name>PartClauseMatchStatus</name></type>
<name>match_clause_to_partition_key</name><parameter_list>(<parameter><decl><type><name>GeneratePruningStepsContext</name> <modifier>*</modifier></type><name>context</name></decl></parameter>,
							  <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>clause</name></decl></parameter>, <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>partkey</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>partkeyidx</name></decl></parameter>,
							  <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>clause_is_not_null</name></decl></parameter>, <parameter><decl><type><name>PartClauseInfo</name> <modifier>*</modifier><modifier>*</modifier></type><name>pc</name></decl></parameter>,
							  <parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>clause_steps</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PartClauseMatchStatus</name></type> <name>boolmatchstatus</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PartitionScheme</name></type> <name>part_scheme</name> <init>= <expr><name><name>context</name><operator>-&gt;</operator><name>rel</name><operator>-&gt;</operator><name>part_scheme</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>partopfamily</name> <init>= <expr><name><name>part_scheme</name><operator>-&gt;</operator><name>partopfamily</name><index>[<expr><name>partkeyidx</name></expr>]</index></name></expr></init></decl>,
				<decl><type ref="prev"/><name>partcoll</name> <init>= <expr><name><name>part_scheme</name><operator>-&gt;</operator><name>partcollation</name><index>[<expr><name>partkeyidx</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Expr</name>	   <modifier>*</modifier></type><name>expr</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Recognize specially shaped clauses that match a Boolean partition key.
	 */</comment>
	<expr_stmt><expr><name>boolmatchstatus</name> <operator>=</operator> <call><name>match_boolean_partition_clause</name><argument_list>(<argument><expr><name>partopfamily</name></expr></argument>, <argument><expr><name>clause</name></expr></argument>,
													 <argument><expr><name>partkey</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>expr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>boolmatchstatus</name> <operator>==</operator> <name>PARTCLAUSE_MATCH_CLAUSE</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>PartClauseInfo</name> <modifier>*</modifier></type><name>partclause</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>partclause</name> <operator>=</operator> <operator>(</operator><name>PartClauseInfo</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>PartClauseInfo</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>partclause</name><operator>-&gt;</operator><name>keyno</name></name> <operator>=</operator> <name>partkeyidx</name></expr>;</expr_stmt>
		<comment type="block">/* Do pruning with the Boolean equality operator. */</comment>
		<expr_stmt><expr><name><name>partclause</name><operator>-&gt;</operator><name>opno</name></name> <operator>=</operator> <name>BooleanEqualOperator</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>partclause</name><operator>-&gt;</operator><name>op_is_ne</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>partclause</name><operator>-&gt;</operator><name>expr</name></name> <operator>=</operator> <name>expr</name></expr>;</expr_stmt>
		<comment type="block">/* We know that expr is of Boolean type. */</comment>
		<expr_stmt><expr><name><name>partclause</name><operator>-&gt;</operator><name>cmpfn</name></name> <operator>=</operator> <name><name>part_scheme</name><operator>-&gt;</operator><name>partsupfunc</name><index>[<expr><name>partkeyidx</name></expr>]</index></name><operator>.</operator><name>fn_oid</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>partclause</name><operator>-&gt;</operator><name>op_strategy</name></name> <operator>=</operator> <name>InvalidStrategy</name></expr>;</expr_stmt>

		<expr_stmt><expr><operator>*</operator><name>pc</name> <operator>=</operator> <name>partclause</name></expr>;</expr_stmt>

		<return>return <expr><name>PARTCLAUSE_MATCH_CLAUSE</name></expr>;</return>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>clause</name></expr></argument>, <argument><expr><name>OpExpr</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
			 <call><name>list_length</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>OpExpr</name> <operator>*</operator><operator>)</operator> <name>clause</name><operator>)</operator><operator>-&gt;</operator><name>args</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">2</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>OpExpr</name>	   <modifier>*</modifier></type><name>opclause</name> <init>= <expr><operator>(</operator><name>OpExpr</name> <operator>*</operator><operator>)</operator> <name>clause</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Expr</name>	   <modifier>*</modifier></type><name>leftop</name></decl>,
				   <decl><type ref="prev"><modifier>*</modifier></type><name>rightop</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>opno</name></decl>,
					<decl><type ref="prev"/><name>op_lefttype</name></decl>,
					<decl><type ref="prev"/><name>op_righttype</name></decl>,
					<decl><type ref="prev"/><name>negator</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>cmpfn</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>op_strategy</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>is_opne_listp</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>PartClauseInfo</name> <modifier>*</modifier></type><name>partclause</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>leftop</name> <operator>=</operator> <operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <call><name>get_leftop</name><argument_list>(<argument><expr><name>clause</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>leftop</name></expr></argument>, <argument><expr><name>RelabelType</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>leftop</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>RelabelType</name> <operator>*</operator><operator>)</operator> <name>leftop</name><operator>)</operator><operator>-&gt;</operator><name>arg</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>rightop</name> <operator>=</operator> <operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <call><name>get_rightop</name><argument_list>(<argument><expr><name>clause</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>rightop</name></expr></argument>, <argument><expr><name>RelabelType</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>rightop</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>RelabelType</name> <operator>*</operator><operator>)</operator> <name>rightop</name><operator>)</operator><operator>-&gt;</operator><name>arg</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>opno</name> <operator>=</operator> <name><name>opclause</name><operator>-&gt;</operator><name>opno</name></name></expr>;</expr_stmt>

		<comment type="block">/* check if the clause matches this partition key */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>equal</name><argument_list>(<argument><expr><name>leftop</name></expr></argument>, <argument><expr><name>partkey</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>expr</name> <operator>=</operator> <name>rightop</name></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><call><name>equal</name><argument_list>(<argument><expr><name>rightop</name></expr></argument>, <argument><expr><name>partkey</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * It's only useful if we can commute the operator to put the
			 * partkey on the left.  If we can't, the clause can be deemed
			 * UNSUPPORTED.  Even if its leftop matches some later partkey, we
			 * now know it has Vars on the right, so it's no use.
			 */</comment>
			<expr_stmt><expr><name>opno</name> <operator>=</operator> <call><name>get_commutator</name><argument_list>(<argument><expr><name>opno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>opno</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>PARTCLAUSE_UNSUPPORTED</name></expr>;</return></block_content></block></if></if_stmt>
			<expr_stmt><expr><name>expr</name> <operator>=</operator> <name>leftop</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else<block type="pseudo"><block_content>
			<comment type="block">/* clause does not match this partition key, but perhaps next. */</comment>
			<return>return <expr><name>PARTCLAUSE_NOMATCH</name></expr>;</return></block_content></block></else></if_stmt>

		<comment type="block">/*
		 * Partition key match also requires collation match.  There may be
		 * multiple partkeys with the same expression but different
		 * collations, so failure is NOMATCH.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>PartCollMatchesExprColl</name><argument_list>(<argument><expr><name>partcoll</name></expr></argument>, <argument><expr><name><name>opclause</name><operator>-&gt;</operator><name>inputcollid</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>PARTCLAUSE_NOMATCH</name></expr>;</return></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * See if the operator is relevant to the partitioning opfamily.
		 *
		 * Normally we only care about operators that are listed as being part
		 * of the partitioning operator family.  But there is one exception:
		 * the not-equals operators are not listed in any operator family
		 * whatsoever, but their negators (equality) are.  We can use one of
		 * those if we find it, but only for list partitioning.
		 *
		 * Note: we report NOMATCH on failure, in case a later partkey has the
		 * same expression but different opfamily.  That's unlikely, but not
		 * much more so than duplicate expressions with different collations.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>op_in_opfamily</name><argument_list>(<argument><expr><name>opno</name></expr></argument>, <argument><expr><name>partopfamily</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>get_op_opfamily_properties</name><argument_list>(<argument><expr><name>opno</name></expr></argument>, <argument><expr><name>partopfamily</name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
									   <argument><expr><operator>&amp;</operator><name>op_strategy</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>op_lefttype</name></expr></argument>,
									   <argument><expr><operator>&amp;</operator><name>op_righttype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name><name>part_scheme</name><operator>-&gt;</operator><name>strategy</name></name> <operator>!=</operator> <name>PARTITION_STRATEGY_LIST</name></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>PARTCLAUSE_NOMATCH</name></expr>;</return></block_content></block></if></if_stmt>

			<comment type="block">/* See if the negator is equality */</comment>
			<expr_stmt><expr><name>negator</name> <operator>=</operator> <call><name>get_negator</name><argument_list>(<argument><expr><name>opno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>negator</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>op_in_opfamily</name><argument_list>(<argument><expr><name>negator</name></expr></argument>, <argument><expr><name>partopfamily</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>get_op_opfamily_properties</name><argument_list>(<argument><expr><name>negator</name></expr></argument>, <argument><expr><name>partopfamily</name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
										   <argument><expr><operator>&amp;</operator><name>op_strategy</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>op_lefttype</name></expr></argument>,
										   <argument><expr><operator>&amp;</operator><name>op_righttype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name>op_strategy</name> <operator>==</operator> <name>BTEqualStrategyNumber</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>is_opne_listp</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>	<comment type="block">/* bingo */</comment>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/* Nope, it's not &lt;&gt; either. */</comment>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>is_opne_listp</name></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>PARTCLAUSE_NOMATCH</name></expr>;</return></block_content></block></if></if_stmt>
		</block_content>}</block></else></if_stmt>

		<comment type="block">/*
		 * Only allow strict operators.  This will guarantee nulls are
		 * filtered.  (This test is likely useless, since btree and hash
		 * comparison operators are generally strict.)
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>op_strict</name><argument_list>(<argument><expr><name>opno</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>PARTCLAUSE_UNSUPPORTED</name></expr>;</return></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * OK, we have a match to the partition key and a suitable operator.
		 * Examine the other argument to see if it's usable for pruning.
		 *
		 * In most of these cases, we can return UNSUPPORTED because the same
		 * failure would occur no matter which partkey it's matched to.  (In
		 * particular, now that we've successfully matched one side of the
		 * opclause to a partkey, there is no chance that matching the other
		 * side to another partkey will produce a usable result, since that'd
		 * mean there are Vars on both sides.)
		 *
		 * Also, if we reject an argument for a target-dependent reason, set
		 * appropriate fields of *context to report that.  We postpone these
		 * tests until after matching the partkey and the operator, so as to
		 * reduce the odds of setting the context fields for clauses that do
		 * not end up contributing to pruning steps.
		 *
		 * First, check for non-Const argument.  (We assume that any immutable
		 * subexpression will have been folded to a Const already.)
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name>expr</name></expr></argument>, <argument><expr><name>Const</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Bitmapset</name>  <modifier>*</modifier></type><name>paramids</name></decl>;</decl_stmt>

			<comment type="block">/*
			 * When pruning in the planner, we only support pruning using
			 * comparisons to constants.  We cannot prune on the basis of
			 * anything that's not immutable.  (Note that has_mutable_arg and
			 * has_exec_param do not get set for this target value.)
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>context</name><operator>-&gt;</operator><name>target</name></name> <operator>==</operator> <name>PARTTARGET_PLANNER</name></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>PARTCLAUSE_UNSUPPORTED</name></expr>;</return></block_content></block></if></if_stmt>

			<comment type="block">/*
			 * We can never prune using an expression that contains Vars.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>contain_var_clause</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>expr</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>PARTCLAUSE_UNSUPPORTED</name></expr>;</return></block_content></block></if></if_stmt>

			<comment type="block">/*
			 * And we must reject anything containing a volatile function.
			 * Stable functions are OK though.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>contain_volatile_functions</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>expr</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>PARTCLAUSE_UNSUPPORTED</name></expr>;</return></block_content></block></if></if_stmt>

			<comment type="block">/*
			 * See if there are any exec Params.  If so, we can only use this
			 * expression during per-scan pruning.
			 */</comment>
			<expr_stmt><expr><name>paramids</name> <operator>=</operator> <call><name>pull_exec_paramids</name><argument_list>(<argument><expr><name>expr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>bms_is_empty</name><argument_list>(<argument><expr><name>paramids</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>has_exec_param</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name><name>context</name><operator>-&gt;</operator><name>target</name></name> <operator>!=</operator> <name>PARTTARGET_EXEC</name></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>PARTCLAUSE_UNSUPPORTED</name></expr>;</return></block_content></block></if></if_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<comment type="block">/* It's potentially usable, but mutable */</comment>
				<expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>has_mutable_arg</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * Check whether the comparison operator itself is immutable.  (We
		 * assume anything that's in a btree or hash opclass is at least
		 * stable, but we need to check for immutability.)
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>op_volatile</name><argument_list>(<argument><expr><name>opno</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>PROVOLATILE_IMMUTABLE</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>has_mutable_op</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

			<comment type="block">/*
			 * When pruning in the planner, we cannot prune with mutable
			 * operators.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>context</name><operator>-&gt;</operator><name>target</name></name> <operator>==</operator> <name>PARTTARGET_PLANNER</name></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>PARTCLAUSE_UNSUPPORTED</name></expr>;</return></block_content></block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * Now find the procedure to use, based on the types.  If the clause's
		 * other argument is of the same type as the partitioning opclass's
		 * declared input type, we can use the procedure cached in
		 * PartitionKey.  If not, search for a cross-type one in the same
		 * opfamily; if one doesn't exist, report no match.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>op_righttype</name> <operator>==</operator> <name><name>part_scheme</name><operator>-&gt;</operator><name>partopcintype</name><index>[<expr><name>partkeyidx</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>cmpfn</name> <operator>=</operator> <name><name>part_scheme</name><operator>-&gt;</operator><name>partsupfunc</name><index>[<expr><name>partkeyidx</name></expr>]</index></name><operator>.</operator><name>fn_oid</name></expr>;</expr_stmt></block_content></block></if>
		<else>else
		<block>{<block_content>
			<switch>switch <condition>(<expr><name><name>part_scheme</name><operator>-&gt;</operator><name>strategy</name></name></expr>)</condition>
			<block>{<block_content>
					<comment type="block">/*
					 * For range and list partitioning, we need the ordering
					 * procedure with lefttype being the partition key's type,
					 * and righttype the clause's operator's right type.
					 */</comment>
				<case>case <expr><name>PARTITION_STRATEGY_LIST</name></expr>:</case>
				<case>case <expr><name>PARTITION_STRATEGY_RANGE</name></expr>:</case>
					<expr_stmt><expr><name>cmpfn</name> <operator>=</operator>
						<call><name>get_opfamily_proc</name><argument_list>(<argument><expr><name><name>part_scheme</name><operator>-&gt;</operator><name>partopfamily</name><index>[<expr><name>partkeyidx</name></expr>]</index></name></expr></argument>,
										  <argument><expr><name><name>part_scheme</name><operator>-&gt;</operator><name>partopcintype</name><index>[<expr><name>partkeyidx</name></expr>]</index></name></expr></argument>,
										  <argument><expr><name>op_righttype</name></expr></argument>, <argument><expr><name>BTORDER_PROC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<break>break;</break>

					<comment type="block">/*
					 * For hash partitioning, we need the hashing procedure
					 * for the clause's type.
					 */</comment>
				<case>case <expr><name>PARTITION_STRATEGY_HASH</name></expr>:</case>
					<expr_stmt><expr><name>cmpfn</name> <operator>=</operator>
						<call><name>get_opfamily_proc</name><argument_list>(<argument><expr><name><name>part_scheme</name><operator>-&gt;</operator><name>partopfamily</name><index>[<expr><name>partkeyidx</name></expr>]</index></name></expr></argument>,
										  <argument><expr><name>op_righttype</name></expr></argument>, <argument><expr><name>op_righttype</name></expr></argument>,
										  <argument><expr><name>HASHEXTENDED_PROC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<break>break;</break>

				<default>default:</default>
					<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"invalid partition strategy: %c"</literal></expr></argument>,
						 <argument><expr><name><name>part_scheme</name><operator>-&gt;</operator><name>strategy</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>cmpfn</name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt> <comment type="block">/* keep compiler quiet */</comment>
					<break>break;</break>
			</block_content>}</block></switch>

			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>cmpfn</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>PARTCLAUSE_NOMATCH</name></expr>;</return></block_content></block></if></if_stmt>
		</block_content>}</block></else></if_stmt>

		<comment type="block">/*
		 * Build the clause, passing the negator if applicable.
		 */</comment>
		<expr_stmt><expr><name>partclause</name> <operator>=</operator> <operator>(</operator><name>PartClauseInfo</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>PartClauseInfo</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>partclause</name><operator>-&gt;</operator><name>keyno</name></name> <operator>=</operator> <name>partkeyidx</name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>is_opne_listp</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>negator</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>partclause</name><operator>-&gt;</operator><name>opno</name></name> <operator>=</operator> <name>negator</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>partclause</name><operator>-&gt;</operator><name>op_is_ne</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>partclause</name><operator>-&gt;</operator><name>op_strategy</name></name> <operator>=</operator> <name>InvalidStrategy</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><name><name>partclause</name><operator>-&gt;</operator><name>opno</name></name> <operator>=</operator> <name>opno</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>partclause</name><operator>-&gt;</operator><name>op_is_ne</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>partclause</name><operator>-&gt;</operator><name>op_strategy</name></name> <operator>=</operator> <name>op_strategy</name></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
		<expr_stmt><expr><name><name>partclause</name><operator>-&gt;</operator><name>expr</name></name> <operator>=</operator> <name>expr</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>partclause</name><operator>-&gt;</operator><name>cmpfn</name></name> <operator>=</operator> <name>cmpfn</name></expr>;</expr_stmt>

		<expr_stmt><expr><operator>*</operator><name>pc</name> <operator>=</operator> <name>partclause</name></expr>;</expr_stmt>

		<return>return <expr><name>PARTCLAUSE_MATCH_CLAUSE</name></expr>;</return>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>clause</name></expr></argument>, <argument><expr><name>ScalarArrayOpExpr</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ScalarArrayOpExpr</name> <modifier>*</modifier></type><name>saop</name> <init>= <expr><operator>(</operator><name>ScalarArrayOpExpr</name> <operator>*</operator><operator>)</operator> <name>clause</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>saop_op</name> <init>= <expr><name><name>saop</name><operator>-&gt;</operator><name>opno</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>saop_coll</name> <init>= <expr><name><name>saop</name><operator>-&gt;</operator><name>inputcollid</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Expr</name>	   <modifier>*</modifier></type><name>leftop</name> <init>= <expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <call><name>linitial</name><argument_list>(<argument><expr><name><name>saop</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr></init></decl>,
				   <decl><type ref="prev"><modifier>*</modifier></type><name>rightop</name> <init>= <expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <call><name>lsecond</name><argument_list>(<argument><expr><name><name>saop</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>elem_exprs</name></decl>,
				   <decl><type ref="prev"><modifier>*</modifier></type><name>elem_clauses</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc1</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>leftop</name></expr></argument>, <argument><expr><name>RelabelType</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>leftop</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>RelabelType</name> <operator>*</operator><operator>)</operator> <name>leftop</name><operator>)</operator><operator>-&gt;</operator><name>arg</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/* check if the LHS matches this partition key */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>equal</name><argument_list>(<argument><expr><name>leftop</name></expr></argument>, <argument><expr><name>partkey</name></expr></argument>)</argument_list></call> <operator>||</operator>
			<operator>!</operator><call><name>PartCollMatchesExprColl</name><argument_list>(<argument><expr><name>partcoll</name></expr></argument>, <argument><expr><name><name>saop</name><operator>-&gt;</operator><name>inputcollid</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>PARTCLAUSE_NOMATCH</name></expr>;</return></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * See if the operator is relevant to the partitioning opfamily.
		 *
		 * In case of NOT IN (..), we get a '&lt;&gt;', which we handle if list
		 * partitioning is in use and we're able to confirm that it's negator
		 * is a btree equality operator belonging to the partitioning operator
		 * family.  As above, report NOMATCH for non-matching operator.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>op_in_opfamily</name><argument_list>(<argument><expr><name>saop_op</name></expr></argument>, <argument><expr><name>partopfamily</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Oid</name></type>			<name>negator</name></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>part_scheme</name><operator>-&gt;</operator><name>strategy</name></name> <operator>!=</operator> <name>PARTITION_STRATEGY_LIST</name></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>PARTCLAUSE_NOMATCH</name></expr>;</return></block_content></block></if></if_stmt>

			<expr_stmt><expr><name>negator</name> <operator>=</operator> <call><name>get_negator</name><argument_list>(<argument><expr><name>saop_op</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>negator</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>op_in_opfamily</name><argument_list>(<argument><expr><name>negator</name></expr></argument>, <argument><expr><name>partopfamily</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>int</name></type>			<name>strategy</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>Oid</name></type>			<name>lefttype</name></decl>,
							<decl><type ref="prev"/><name>righttype</name></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>get_op_opfamily_properties</name><argument_list>(<argument><expr><name>negator</name></expr></argument>, <argument><expr><name>partopfamily</name></expr></argument>,
										   <argument><expr><name>false</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>strategy</name></expr></argument>,
										   <argument><expr><operator>&amp;</operator><name>lefttype</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>righttype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name>strategy</name> <operator>!=</operator> <name>BTEqualStrategyNumber</name></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>PARTCLAUSE_NOMATCH</name></expr>;</return></block_content></block></if></if_stmt>
			</block_content>}</block></if>
			<else>else<block type="pseudo"><block_content>
				<return>return <expr><name>PARTCLAUSE_NOMATCH</name></expr>;</return></block_content></block></else></if_stmt>	<comment type="block">/* no useful negator */</comment>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * Only allow strict operators.  This will guarantee nulls are
		 * filtered.  (This test is likely useless, since btree and hash
		 * comparison operators are generally strict.)
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>op_strict</name><argument_list>(<argument><expr><name>saop_op</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>PARTCLAUSE_UNSUPPORTED</name></expr>;</return></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * OK, we have a match to the partition key and a suitable operator.
		 * Examine the array argument to see if it's usable for pruning.  This
		 * is identical to the logic for a plain OpExpr.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name>rightop</name></expr></argument>, <argument><expr><name>Const</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Bitmapset</name>  <modifier>*</modifier></type><name>paramids</name></decl>;</decl_stmt>

			<comment type="block">/*
			 * When pruning in the planner, we only support pruning using
			 * comparisons to constants.  We cannot prune on the basis of
			 * anything that's not immutable.  (Note that has_mutable_arg and
			 * has_exec_param do not get set for this target value.)
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>context</name><operator>-&gt;</operator><name>target</name></name> <operator>==</operator> <name>PARTTARGET_PLANNER</name></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>PARTCLAUSE_UNSUPPORTED</name></expr>;</return></block_content></block></if></if_stmt>

			<comment type="block">/*
			 * We can never prune using an expression that contains Vars.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>contain_var_clause</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>rightop</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>PARTCLAUSE_UNSUPPORTED</name></expr>;</return></block_content></block></if></if_stmt>

			<comment type="block">/*
			 * And we must reject anything containing a volatile function.
			 * Stable functions are OK though.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>contain_volatile_functions</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>rightop</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>PARTCLAUSE_UNSUPPORTED</name></expr>;</return></block_content></block></if></if_stmt>

			<comment type="block">/*
			 * See if there are any exec Params.  If so, we can only use this
			 * expression during per-scan pruning.
			 */</comment>
			<expr_stmt><expr><name>paramids</name> <operator>=</operator> <call><name>pull_exec_paramids</name><argument_list>(<argument><expr><name>rightop</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>bms_is_empty</name><argument_list>(<argument><expr><name>paramids</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>has_exec_param</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name><name>context</name><operator>-&gt;</operator><name>target</name></name> <operator>!=</operator> <name>PARTTARGET_EXEC</name></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>PARTCLAUSE_UNSUPPORTED</name></expr>;</return></block_content></block></if></if_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<comment type="block">/* It's potentially usable, but mutable */</comment>
				<expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>has_mutable_arg</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * Check whether the comparison operator itself is immutable.  (We
		 * assume anything that's in a btree or hash opclass is at least
		 * stable, but we need to check for immutability.)
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>op_volatile</name><argument_list>(<argument><expr><name>saop_op</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>PROVOLATILE_IMMUTABLE</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>has_mutable_op</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

			<comment type="block">/*
			 * When pruning in the planner, we cannot prune with mutable
			 * operators.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>context</name><operator>-&gt;</operator><name>target</name></name> <operator>==</operator> <name>PARTTARGET_PLANNER</name></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>PARTCLAUSE_UNSUPPORTED</name></expr>;</return></block_content></block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * Examine the contents of the array argument.
		 */</comment>
		<expr_stmt><expr><name>elem_exprs</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>rightop</name></expr></argument>, <argument><expr><name>Const</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * For a constant array, convert the elements to a list of Const
			 * nodes, one for each array element (excepting nulls).
			 */</comment>
			<decl_stmt><decl><type><name>Const</name>	   <modifier>*</modifier></type><name>arr</name> <init>= <expr><operator>(</operator><name>Const</name> <operator>*</operator><operator>)</operator> <name>rightop</name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>ArrayType</name>  <modifier>*</modifier></type><name>arrval</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int16</name></type>		<name>elemlen</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>bool</name></type>		<name>elembyval</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>char</name></type>		<name>elemalign</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Datum</name>	   <modifier>*</modifier></type><name>elem_values</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>bool</name>	   <modifier>*</modifier></type><name>elem_nulls</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int</name></type>			<name>num_elems</name></decl>,
						<decl><type ref="prev"/><name>i</name></decl>;</decl_stmt>

			<comment type="block">/* If the array itself is null, the saop returns null */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>arr</name><operator>-&gt;</operator><name>constisnull</name></name></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>PARTCLAUSE_MATCH_CONTRADICT</name></expr>;</return></block_content></block></if></if_stmt>

			<expr_stmt><expr><name>arrval</name> <operator>=</operator> <call><name>DatumGetArrayTypeP</name><argument_list>(<argument><expr><name><name>arr</name><operator>-&gt;</operator><name>constvalue</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>get_typlenbyvalalign</name><argument_list>(<argument><expr><call><name>ARR_ELEMTYPE</name><argument_list>(<argument><expr><name>arrval</name></expr></argument>)</argument_list></call></expr></argument>,
								 <argument><expr><operator>&amp;</operator><name>elemlen</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>elembyval</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>elemalign</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>deconstruct_array</name><argument_list>(<argument><expr><name>arrval</name></expr></argument>,
							  <argument><expr><call><name>ARR_ELEMTYPE</name><argument_list>(<argument><expr><name>arrval</name></expr></argument>)</argument_list></call></expr></argument>,
							  <argument><expr><name>elemlen</name></expr></argument>, <argument><expr><name>elembyval</name></expr></argument>, <argument><expr><name>elemalign</name></expr></argument>,
							  <argument><expr><operator>&amp;</operator><name>elem_values</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>elem_nulls</name></expr></argument>,
							  <argument><expr><operator>&amp;</operator><name>num_elems</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>num_elems</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
			<block>{<block_content>
				<decl_stmt><decl><type><name>Const</name>	   <modifier>*</modifier></type><name>elem_expr</name></decl>;</decl_stmt>

				<comment type="block">/*
				 * A null array element must lead to a null comparison result,
				 * since saop_op is known strict.  We can ignore it in the
				 * useOr case, but otherwise it implies self-contradiction.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><name><name>elem_nulls</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition>
				<block>{<block_content>
					<if_stmt><if>if <condition>(<expr><name><name>saop</name><operator>-&gt;</operator><name>useOr</name></name></expr>)</condition><block type="pseudo"><block_content>
						<continue>continue;</continue></block_content></block></if></if_stmt>
					<return>return <expr><name>PARTCLAUSE_MATCH_CONTRADICT</name></expr>;</return>
				</block_content>}</block></if></if_stmt>

				<expr_stmt><expr><name>elem_expr</name> <operator>=</operator> <call><name>makeConst</name><argument_list>(<argument><expr><call><name>ARR_ELEMTYPE</name><argument_list>(<argument><expr><name>arrval</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>,
									  <argument><expr><name><name>arr</name><operator>-&gt;</operator><name>constcollid</name></name></expr></argument>, <argument><expr><name>elemlen</name></expr></argument>,
									  <argument><expr><name><name>elem_values</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>elembyval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>elem_exprs</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>elem_exprs</name></expr></argument>, <argument><expr><name>elem_expr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></for>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>rightop</name></expr></argument>, <argument><expr><name>ArrayExpr</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>ArrayExpr</name>  <modifier>*</modifier></type><name>arrexpr</name> <init>= <expr><call><name>castNode</name><argument_list>(<argument><expr><name>ArrayExpr</name></expr></argument>, <argument><expr><name>rightop</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<comment type="block">/*
			 * For a nested ArrayExpr, we don't know how to get the actual
			 * scalar values out into a flat list, so we give up doing
			 * anything with this ScalarArrayOpExpr.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>arrexpr</name><operator>-&gt;</operator><name>multidims</name></name></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>PARTCLAUSE_UNSUPPORTED</name></expr>;</return></block_content></block></if></if_stmt>

			<comment type="block">/*
			 * Otherwise, we can just use the list of element values.
			 */</comment>
			<expr_stmt><expr><name>elem_exprs</name> <operator>=</operator> <name><name>arrexpr</name><operator>-&gt;</operator><name>elements</name></name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/* Give up on any other clause types. */</comment>
			<return>return <expr><name>PARTCLAUSE_UNSUPPORTED</name></expr>;</return>
		</block_content>}</block></else></if_stmt>

		<comment type="block">/*
		 * Now generate a list of clauses, one for each array element, of the
		 * form saop_leftop saop_op elem_expr
		 */</comment>
		<expr_stmt><expr><name>elem_clauses</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
		<macro><name>foreach</name><argument_list>(<argument>lc1</argument>, <argument>elem_exprs</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Expr</name>	   <modifier>*</modifier></type><name>rightop</name> <init>= <expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc1</name></expr></argument>)</argument_list></call></expr></init></decl>,
					   <decl><type ref="prev"><modifier>*</modifier></type><name>elem_clause</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>elem_clause</name> <operator>=</operator> <call><name>make_opclause</name><argument_list>(<argument><expr><name>saop_op</name></expr></argument>, <argument><expr><name>BOOLOID</name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
										<argument><expr><name>leftop</name></expr></argument>, <argument><expr><name>rightop</name></expr></argument>,
										<argument><expr><name>InvalidOid</name></expr></argument>, <argument><expr><name>saop_coll</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>elem_clauses</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>elem_clauses</name></expr></argument>, <argument><expr><name>elem_clause</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>

		<comment type="block">/*
		 * If we have an ANY clause and multiple elements, now turn the list
		 * of clauses into an OR expression.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>saop</name><operator>-&gt;</operator><name>useOr</name></name> <operator>&amp;&amp;</operator> <call><name>list_length</name><argument_list>(<argument><expr><name>elem_clauses</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>elem_clauses</name> <operator>=</operator> <call><name>list_make1</name><argument_list>(<argument><expr><call><name>makeBoolExpr</name><argument_list>(<argument><expr><name>OR_EXPR</name></expr></argument>, <argument><expr><name>elem_clauses</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/* Finally, generate steps */</comment>
		<expr_stmt><expr><operator>*</operator><name>clause_steps</name> <operator>=</operator> <call><name>gen_partprune_steps_internal</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><name>elem_clauses</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>context</name><operator>-&gt;</operator><name>contradictory</name></name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>PARTCLAUSE_MATCH_CONTRADICT</name></expr>;</return></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><operator>*</operator><name>clause_steps</name> <operator>==</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>PARTCLAUSE_UNSUPPORTED</name></expr>;</return></block_content></block></if></if_stmt>	<comment type="block">/* step generation failed */</comment>
		<return>return <expr><name>PARTCLAUSE_MATCH_STEPS</name></expr>;</return>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>clause</name></expr></argument>, <argument><expr><name>NullTest</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>NullTest</name>   <modifier>*</modifier></type><name>nulltest</name> <init>= <expr><operator>(</operator><name>NullTest</name> <operator>*</operator><operator>)</operator> <name>clause</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Expr</name>	   <modifier>*</modifier></type><name>arg</name> <init>= <expr><name><name>nulltest</name><operator>-&gt;</operator><name>arg</name></name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><name>RelabelType</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>arg</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>RelabelType</name> <operator>*</operator><operator>)</operator> <name>arg</name><operator>)</operator><operator>-&gt;</operator><name>arg</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/* Does arg match with this partition key column? */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>equal</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><name>partkey</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>PARTCLAUSE_NOMATCH</name></expr>;</return></block_content></block></if></if_stmt>

		<expr_stmt><expr><operator>*</operator><name>clause_is_not_null</name> <operator>=</operator> <operator>(</operator><name><name>nulltest</name><operator>-&gt;</operator><name>nulltesttype</name></name> <operator>==</operator> <name>IS_NOT_NULL</name><operator>)</operator></expr>;</expr_stmt>

		<return>return <expr><name>PARTCLAUSE_MATCH_NULLNESS</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * If we get here then the return value depends on the result of the
	 * match_boolean_partition_clause call above.  If the call returned
	 * PARTCLAUSE_UNSUPPORTED then we're either not dealing with a bool qual
	 * or the bool qual is not suitable for pruning.  Since the qual didn't
	 * match up to any of the other qual types supported here, then trying to
	 * match it against any other partition key is a waste of time, so just
	 * return PARTCLAUSE_UNSUPPORTED.  If the qual just couldn't be matched to
	 * this partition key, then it may match another, so return
	 * PARTCLAUSE_NOMATCH.  The only other value that
	 * match_boolean_partition_clause can return is PARTCLAUSE_MATCH_CLAUSE,
	 * and since that value was already dealt with above, then we can just
	 * return boolmatchstatus.
	 */</comment>
	<return>return <expr><name>boolmatchstatus</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * get_steps_using_prefix
 *		Generate list of PartitionPruneStepOp steps each consisting of given
 *		opstrategy
 *
 * To generate steps, step_lastexpr and step_lastcmpfn are appended to
 * expressions and cmpfns, respectively, extracted from the clauses in
 * 'prefix'.  Actually, since 'prefix' may contain multiple clauses for the
 * same partition key column, we must generate steps for various combinations
 * of the clauses of different keys.
 *
 * For list/range partitioning, callers must ensure that step_nullkeys is
 * NULL, and that prefix contains at least one clause for each of the
 * partition keys earlier than one specified in step_lastkeyno if it's
 * greater than zero.  For hash partitioning, step_nullkeys is allowed to be
 * non-NULL, but they must ensure that prefix contains at least one clause
 * for each of the partition keys other than those specified in step_nullkeys
 * and step_lastkeyno.
 *
 * For both cases, callers must also ensure that clauses in prefix are sorted
 * in ascending order of their partition key numbers.
 */</comment>
<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>get_steps_using_prefix</name><parameter_list>(<parameter><decl><type><name>GeneratePruningStepsContext</name> <modifier>*</modifier></type><name>context</name></decl></parameter>,
					   <parameter><decl><type><name>StrategyNumber</name></type> <name>step_opstrategy</name></decl></parameter>,
					   <parameter><decl><type><name>bool</name></type> <name>step_op_is_ne</name></decl></parameter>,
					   <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>step_lastexpr</name></decl></parameter>,
					   <parameter><decl><type><name>Oid</name></type> <name>step_lastcmpfn</name></decl></parameter>,
					   <parameter><decl><type><name>int</name></type> <name>step_lastkeyno</name></decl></parameter>,
					   <parameter><decl><type><name>Bitmapset</name> <modifier>*</modifier></type><name>step_nullkeys</name></decl></parameter>,
					   <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>prefix</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>step_nullkeys</name> <operator>==</operator> <name>NULL</name> <operator>||</operator>
		   <name><name>context</name><operator>-&gt;</operator><name>rel</name><operator>-&gt;</operator><name>part_scheme</name><operator>-&gt;</operator><name>strategy</name></name> <operator>==</operator> <name>PARTITION_STRATEGY_HASH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Quick exit if there are no values to prefix with. */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name>prefix</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>PartitionPruneStep</name> <modifier>*</modifier></type><name>step</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>step</name> <operator>=</operator> <call><name>gen_prune_step_op</name><argument_list>(<argument><expr><name>context</name></expr></argument>,
								 <argument><expr><name>step_opstrategy</name></expr></argument>,
								 <argument><expr><name>step_op_is_ne</name></expr></argument>,
								 <argument><expr><call><name>list_make1</name><argument_list>(<argument><expr><name>step_lastexpr</name></expr></argument>)</argument_list></call></expr></argument>,
								 <argument><expr><call><name>list_make1_oid</name><argument_list>(<argument><expr><name>step_lastcmpfn</name></expr></argument>)</argument_list></call></expr></argument>,
								 <argument><expr><name>step_nullkeys</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><call><name>list_make1</name><argument_list>(<argument><expr><name>step</name></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Recurse to generate steps for various combinations. */</comment>
	<return>return <expr><call><name>get_steps_using_prefix_recurse</name><argument_list>(<argument><expr><name>context</name></expr></argument>,
										  <argument><expr><name>step_opstrategy</name></expr></argument>,
										  <argument><expr><name>step_op_is_ne</name></expr></argument>,
										  <argument><expr><name>step_lastexpr</name></expr></argument>,
										  <argument><expr><name>step_lastcmpfn</name></expr></argument>,
										  <argument><expr><name>step_lastkeyno</name></expr></argument>,
										  <argument><expr><name>step_nullkeys</name></expr></argument>,
										  <argument><expr><call><name>list_head</name><argument_list>(<argument><expr><name>prefix</name></expr></argument>)</argument_list></call></expr></argument>,
										  <argument><expr><name>NIL</name></expr></argument>, <argument><expr><name>NIL</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * get_steps_using_prefix_recurse
 *		Recursively generate combinations of clauses for different partition
 *		keys and start generating steps upon reaching clauses for the greatest
 *		column that is less than the one for which we're currently generating
 *		steps (that is, step_lastkeyno)
 *
 * 'start' is where we should start iterating for the current invocation.
 * 'step_exprs' and 'step_cmpfns' each contains the expressions and cmpfns
 * we've generated so far from the clauses for the previous part keys.
 */</comment>
<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>get_steps_using_prefix_recurse</name><parameter_list>(<parameter><decl><type><name>GeneratePruningStepsContext</name> <modifier>*</modifier></type><name>context</name></decl></parameter>,
							   <parameter><decl><type><name>StrategyNumber</name></type> <name>step_opstrategy</name></decl></parameter>,
							   <parameter><decl><type><name>bool</name></type> <name>step_op_is_ne</name></decl></parameter>,
							   <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>step_lastexpr</name></decl></parameter>,
							   <parameter><decl><type><name>Oid</name></type> <name>step_lastcmpfn</name></decl></parameter>,
							   <parameter><decl><type><name>int</name></type> <name>step_lastkeyno</name></decl></parameter>,
							   <parameter><decl><type><name>Bitmapset</name> <modifier>*</modifier></type><name>step_nullkeys</name></decl></parameter>,
							   <parameter><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>start</name></decl></parameter>,
							   <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>step_exprs</name></decl></parameter>,
							   <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>step_cmpfns</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>result</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>cur_keyno</name></decl>;</decl_stmt>

	<comment type="block">/* Actually, recursion would be limited by PARTITION_MAX_KEYS. */</comment>
	<expr_stmt><expr><call><name>check_stack_depth</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Check if we need to recurse. */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>start</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>cur_keyno</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>PartClauseInfo</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>start</name></expr></argument>)</argument_list></call><operator>)</operator><operator>-&gt;</operator><name>keyno</name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>cur_keyno</name> <operator>&lt;</operator> <name>step_lastkeyno</name> <operator>-</operator> <literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>PartClauseInfo</name> <modifier>*</modifier></type><name>pc</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>next_start</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * For each clause with cur_keyno, add its expr and cmpfn to
		 * step_exprs and step_cmpfns, respectively, and recurse after setting
		 * next_start to the ListCell of the first clause for the next
		 * partition key.
		 */</comment>
		<macro><name>for_each_cell</name><argument_list>(<argument>lc</argument>, <argument>start</argument>)</argument_list></macro>
		<block>{<block_content>
			<expr_stmt><expr><name>pc</name> <operator>=</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>pc</name><operator>-&gt;</operator><name>keyno</name></name> <operator>&gt;</operator> <name>cur_keyno</name></expr>)</condition><block type="pseudo"><block_content>
				<break>break;</break></block_content></block></if></if_stmt>
		</block_content>}</block>
		<expr_stmt><expr><name>next_start</name> <operator>=</operator> <name>lc</name></expr>;</expr_stmt>

		<macro><name>for_each_cell</name><argument_list>(<argument>lc</argument>, <argument>start</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>moresteps</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>step_exprs1</name></decl>,
					   <decl><type ref="prev"><modifier>*</modifier></type><name>step_cmpfns1</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>pc</name> <operator>=</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>pc</name><operator>-&gt;</operator><name>keyno</name></name> <operator>==</operator> <name>cur_keyno</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* Leave the original step_exprs unmodified. */</comment>
				<expr_stmt><expr><name>step_exprs1</name> <operator>=</operator> <call><name>list_copy</name><argument_list>(<argument><expr><name>step_exprs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>step_exprs1</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>step_exprs1</name></expr></argument>, <argument><expr><name><name>pc</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/* Leave the original step_cmpfns unmodified. */</comment>
				<expr_stmt><expr><name>step_cmpfns1</name> <operator>=</operator> <call><name>list_copy</name><argument_list>(<argument><expr><name>step_cmpfns</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>step_cmpfns1</name> <operator>=</operator> <call><name>lappend_oid</name><argument_list>(<argument><expr><name>step_cmpfns1</name></expr></argument>, <argument><expr><name><name>pc</name><operator>-&gt;</operator><name>cmpfn</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>pc</name><operator>-&gt;</operator><name>keyno</name></name> <operator>&gt;</operator> <name>cur_keyno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block></else></if_stmt>

			<expr_stmt><expr><name>moresteps</name> <operator>=</operator> <call><name>get_steps_using_prefix_recurse</name><argument_list>(<argument><expr><name>context</name></expr></argument>,
													   <argument><expr><name>step_opstrategy</name></expr></argument>,
													   <argument><expr><name>step_op_is_ne</name></expr></argument>,
													   <argument><expr><name>step_lastexpr</name></expr></argument>,
													   <argument><expr><name>step_lastcmpfn</name></expr></argument>,
													   <argument><expr><name>step_lastkeyno</name></expr></argument>,
													   <argument><expr><name>step_nullkeys</name></expr></argument>,
													   <argument><expr><name>next_start</name></expr></argument>,
													   <argument><expr><name>step_exprs1</name></expr></argument>,
													   <argument><expr><name>step_cmpfns1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>list_concat</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>moresteps</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>list_free</name><argument_list>(<argument><expr><name>step_exprs1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>list_free</name><argument_list>(<argument><expr><name>step_cmpfns1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/*
		 * End the current recursion cycle and start generating steps, one for
		 * each clause with cur_keyno, which is all clauses from here onward
		 * till the end of the list.  Note that for hash partitioning,
		 * step_nullkeys is allowed to be non-empty, in which case step_exprs
		 * would only contain expressions for the earlier partition keys that
		 * are not specified in step_nullkeys.
		 */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name>step_exprs</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>cur_keyno</name> <operator>||</operator>
			   <operator>!</operator><call><name>bms_is_empty</name><argument_list>(<argument><expr><name>step_nullkeys</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/*
		 * Note also that for hash partitioning, each partition key should
		 * have either equality clauses or an IS NULL clause, so if a
		 * partition key doesn't have an expression, it would be specified
		 * in step_nullkeys.
 		 */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>context</name><operator>-&gt;</operator><name>rel</name><operator>-&gt;</operator><name>part_scheme</name><operator>-&gt;</operator><name>strategy</name></name>
			   <operator>!=</operator> <name>PARTITION_STRATEGY_HASH</name> <operator>||</operator>
			   <call><name>list_length</name><argument_list>(<argument><expr><name>step_exprs</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">2</literal> <operator>+</operator> <call><name>bms_num_members</name><argument_list>(<argument><expr><name>step_nullkeys</name></expr></argument>)</argument_list></call> <operator>==</operator>
			   <name><name>context</name><operator>-&gt;</operator><name>rel</name><operator>-&gt;</operator><name>part_scheme</name><operator>-&gt;</operator><name>partnatts</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<macro><name>for_each_cell</name><argument_list>(<argument>lc</argument>, <argument>start</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>PartClauseInfo</name> <modifier>*</modifier></type><name>pc</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>PartitionPruneStep</name> <modifier>*</modifier></type><name>step</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>step_exprs1</name></decl>,
					   <decl><type ref="prev"><modifier>*</modifier></type><name>step_cmpfns1</name></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>pc</name><operator>-&gt;</operator><name>keyno</name></name> <operator>==</operator> <name>cur_keyno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* Leave the original step_exprs unmodified. */</comment>
			<expr_stmt><expr><name>step_exprs1</name> <operator>=</operator> <call><name>list_copy</name><argument_list>(<argument><expr><name>step_exprs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>step_exprs1</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>step_exprs1</name></expr></argument>, <argument><expr><name><name>pc</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>step_exprs1</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>step_exprs1</name></expr></argument>, <argument><expr><name>step_lastexpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* Leave the original step_cmpfns unmodified. */</comment>
			<expr_stmt><expr><name>step_cmpfns1</name> <operator>=</operator> <call><name>list_copy</name><argument_list>(<argument><expr><name>step_cmpfns</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>step_cmpfns1</name> <operator>=</operator> <call><name>lappend_oid</name><argument_list>(<argument><expr><name>step_cmpfns1</name></expr></argument>, <argument><expr><name><name>pc</name><operator>-&gt;</operator><name>cmpfn</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>step_cmpfns1</name> <operator>=</operator> <call><name>lappend_oid</name><argument_list>(<argument><expr><name>step_cmpfns1</name></expr></argument>, <argument><expr><name>step_lastcmpfn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name>step</name> <operator>=</operator> <call><name>gen_prune_step_op</name><argument_list>(<argument><expr><name>context</name></expr></argument>,
									 <argument><expr><name>step_opstrategy</name></expr></argument>, <argument><expr><name>step_op_is_ne</name></expr></argument>,
									 <argument><expr><name>step_exprs1</name></expr></argument>, <argument><expr><name>step_cmpfns1</name></expr></argument>,
									 <argument><expr><name>step_nullkeys</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>step</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>
	</block_content>}</block></else></if_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * get_matching_hash_bounds
 *		Determine offset of the hash bound matching the specified values,
 *		considering that all the non-null values come from clauses containing
 *		a compatible hash equality operator and any keys that are null come
 *		from an IS NULL clause.
 *
 * Generally this function will return a single matching bound offset,
 * although if a partition has not been setup for a given modulus then we may
 * return no matches.  If the number of clauses found don't cover the entire
 * partition key, then we'll need to return all offsets.
 *
 * 'opstrategy' if non-zero must be HTEqualStrategyNumber.
 *
 * 'values' contains Datums indexed by the partition key to use for pruning.
 *
 * 'nvalues', the number of Datums in the 'values' array.
 *
 * 'partsupfunc' contains partition hashing functions that can produce correct
 * hash for the type of the values contained in 'values'.
 *
 * 'nullkeys' is the set of partition keys that are null.
 */</comment>
<function><type><specifier>static</specifier> <name>PruneStepResult</name> <modifier>*</modifier></type>
<name>get_matching_hash_bounds</name><parameter_list>(<parameter><decl><type><name>PartitionPruneContext</name> <modifier>*</modifier></type><name>context</name></decl></parameter>,
						 <parameter><decl><type><name>StrategyNumber</name></type> <name>opstrategy</name></decl></parameter>, <parameter><decl><type><name>Datum</name> <modifier>*</modifier></type><name>values</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nvalues</name></decl></parameter>,
						 <parameter><decl><type><name>FmgrInfo</name> <modifier>*</modifier></type><name>partsupfunc</name></decl></parameter>, <parameter><decl><type><name>Bitmapset</name> <modifier>*</modifier></type><name>nullkeys</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PruneStepResult</name> <modifier>*</modifier></type><name>result</name> <init>= <expr><operator>(</operator><name>PruneStepResult</name> <operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>PruneStepResult</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PartitionBoundInfo</name></type> <name>boundinfo</name> <init>= <expr><name><name>context</name><operator>-&gt;</operator><name>boundinfo</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name>		   <modifier>*</modifier></type><name>partindices</name> <init>= <expr><name><name>boundinfo</name><operator>-&gt;</operator><name>indexes</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>partnatts</name> <init>= <expr><name><name>context</name><operator>-&gt;</operator><name>partnatts</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name><name>isnull</name><index>[<expr><name>PARTITION_MAX_KEYS</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint64</name></type>		<name>rowHash</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>greatest_modulus</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>context</name><operator>-&gt;</operator><name>strategy</name></name> <operator>==</operator> <name>PARTITION_STRATEGY_HASH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * For hash partitioning we can only perform pruning based on equality
	 * clauses to the partition key or IS NULL clauses.  We also can only
	 * prune if we got values for all keys.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>nvalues</name> <operator>+</operator> <call><name>bms_num_members</name><argument_list>(<argument><expr><name>nullkeys</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>partnatts</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * If there are any values, they must have come from clauses
		 * containing an equality operator compatible with hash partitioning.
		 */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>opstrategy</name> <operator>==</operator> <name>HTEqualStrategyNumber</name> <operator>||</operator> <name>nvalues</name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>partnatts</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>isnull</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>bms_is_member</name><argument_list>(<argument><expr><name>i</name></expr></argument>, <argument><expr><name>nullkeys</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>

		<expr_stmt><expr><name>greatest_modulus</name> <operator>=</operator> <call><name>get_hash_partition_greatest_modulus</name><argument_list>(<argument><expr><name>boundinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>rowHash</name> <operator>=</operator> <call><name>compute_partition_hash_value</name><argument_list>(<argument><expr><name>partnatts</name></expr></argument>, <argument><expr><name>partsupfunc</name></expr></argument>,
											   <argument><expr><name>values</name></expr></argument>, <argument><expr><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>partindices</name><index>[<expr><name>rowHash</name> <operator>%</operator> <name>greatest_modulus</name></expr>]</index></name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>bound_offsets</name></name> <operator>=</operator>
				<call><name>bms_make_singleton</name><argument_list>(<argument><expr><name>rowHash</name> <operator>%</operator> <name>greatest_modulus</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* Getting here means at least one hash partition exists. */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>boundinfo</name><operator>-&gt;</operator><name>ndatums</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>bound_offsets</name></name> <operator>=</operator> <call><name>bms_add_range</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
											  <argument><expr><name><name>boundinfo</name><operator>-&gt;</operator><name>ndatums</name></name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/*
	 * There is neither a special hash null partition or the default hash
	 * partition.
	 */</comment>
	<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>scan_null</name></name> <operator>=</operator> <name><name>result</name><operator>-&gt;</operator><name>scan_default</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * get_matching_list_bounds
 *		Determine the offsets of list bounds matching the specified value,
 *		according to the semantics of the given operator strategy
 *
 * scan_default will be set in the returned struct, if the default partition
 * needs to be scanned, provided one exists at all.  scan_null will be set if
 * the special null-accepting partition needs to be scanned.
 *
 * 'opstrategy' if non-zero must be a btree strategy number.
 *
 * 'value' contains the value to use for pruning.
 *
 * 'nvalues', if non-zero, should be exactly 1, because of list partitioning.
 *
 * 'partsupfunc' contains the list partitioning comparison function to be used
 * to perform partition_list_bsearch
 *
 * 'nullkeys' is the set of partition keys that are null.
 */</comment>
<function><type><specifier>static</specifier> <name>PruneStepResult</name> <modifier>*</modifier></type>
<name>get_matching_list_bounds</name><parameter_list>(<parameter><decl><type><name>PartitionPruneContext</name> <modifier>*</modifier></type><name>context</name></decl></parameter>,
						 <parameter><decl><type><name>StrategyNumber</name></type> <name>opstrategy</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>value</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nvalues</name></decl></parameter>,
						 <parameter><decl><type><name>FmgrInfo</name> <modifier>*</modifier></type><name>partsupfunc</name></decl></parameter>, <parameter><decl><type><name>Bitmapset</name> <modifier>*</modifier></type><name>nullkeys</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PruneStepResult</name> <modifier>*</modifier></type><name>result</name> <init>= <expr><operator>(</operator><name>PruneStepResult</name> <operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>PruneStepResult</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PartitionBoundInfo</name></type> <name>boundinfo</name> <init>= <expr><name><name>context</name><operator>-&gt;</operator><name>boundinfo</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>off</name></decl>,
				<decl><type ref="prev"/><name>minoff</name></decl>,
				<decl><type ref="prev"/><name>maxoff</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>is_equal</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>inclusive</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name>		   <modifier>*</modifier></type><name>partcollation</name> <init>= <expr><name><name>context</name><operator>-&gt;</operator><name>partcollation</name></name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>context</name><operator>-&gt;</operator><name>strategy</name></name> <operator>==</operator> <name>PARTITION_STRATEGY_LIST</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>context</name><operator>-&gt;</operator><name>partnatts</name></name> <operator>==</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>scan_null</name></name> <operator>=</operator> <name><name>result</name><operator>-&gt;</operator><name>scan_default</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>bms_is_empty</name><argument_list>(<argument><expr><name>nullkeys</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Nulls may exist in only one partition - the partition whose
		 * accepted set of values includes null or the default partition if
		 * the former doesn't exist.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>partition_bound_accepts_nulls</name><argument_list>(<argument><expr><name>boundinfo</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>scan_null</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>scan_default</name></name> <operator>=</operator> <call><name>partition_bound_has_default</name><argument_list>(<argument><expr><name>boundinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
		<return>return <expr><name>result</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * If there are no datums to compare keys with, but there are partitions,
	 * just return the default partition if one exists.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>boundinfo</name><operator>-&gt;</operator><name>ndatums</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>scan_default</name></name> <operator>=</operator> <call><name>partition_bound_has_default</name><argument_list>(<argument><expr><name>boundinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>result</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>minoff</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>maxoff</name> <operator>=</operator> <name><name>boundinfo</name><operator>-&gt;</operator><name>ndatums</name></name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>

	<comment type="block">/*
	 * If there are no values to compare with the datums in boundinfo, it
	 * means the caller asked for partitions for all non-null datums.  Add
	 * indexes of *all* partitions, including the default if any.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>nvalues</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>boundinfo</name><operator>-&gt;</operator><name>ndatums</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>bound_offsets</name></name> <operator>=</operator> <call><name>bms_add_range</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
											  <argument><expr><name><name>boundinfo</name><operator>-&gt;</operator><name>ndatums</name></name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>scan_default</name></name> <operator>=</operator> <call><name>partition_bound_has_default</name><argument_list>(<argument><expr><name>boundinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>result</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Special case handling of values coming from a &lt;&gt; operator clause. */</comment>
	<if_stmt><if>if <condition>(<expr><name>opstrategy</name> <operator>==</operator> <name>InvalidStrategy</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * First match to all bounds.  We'll remove any matching datums below.
		 */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>boundinfo</name><operator>-&gt;</operator><name>ndatums</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>bound_offsets</name></name> <operator>=</operator> <call><name>bms_add_range</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
											  <argument><expr><name><name>boundinfo</name><operator>-&gt;</operator><name>ndatums</name></name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>off</name> <operator>=</operator> <call><name>partition_list_bsearch</name><argument_list>(<argument><expr><name>partsupfunc</name></expr></argument>, <argument><expr><name>partcollation</name></expr></argument>, <argument><expr><name>boundinfo</name></expr></argument>,
									 <argument><expr><name>value</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>is_equal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>off</name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>is_equal</name></expr>)</condition>
		<block>{<block_content>

			<comment type="block">/* We have a match. Remove from the result. */</comment>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>boundinfo</name><operator>-&gt;</operator><name>indexes</name><index>[<expr><name>off</name></expr>]</index></name> <operator>&gt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>bound_offsets</name></name> <operator>=</operator> <call><name>bms_del_member</name><argument_list>(<argument><expr><name><name>result</name><operator>-&gt;</operator><name>bound_offsets</name></name></expr></argument>,
												   <argument><expr><name>off</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* Always include the default partition if any. */</comment>
		<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>scan_default</name></name> <operator>=</operator> <call><name>partition_bound_has_default</name><argument_list>(<argument><expr><name>boundinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<return>return <expr><name>result</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * With range queries, always include the default list partition, because
	 * list partitions divide the key space in a discontinuous manner, not all
	 * values in the given range will have a partition assigned.  This may not
	 * technically be true for some data types (e.g. integer types), however,
	 * we currently lack any sort of infrastructure to provide us with proofs
	 * that would allow us to do anything smarter here.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>opstrategy</name> <operator>!=</operator> <name>BTEqualStrategyNumber</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>scan_default</name></name> <operator>=</operator> <call><name>partition_bound_has_default</name><argument_list>(<argument><expr><name>boundinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<switch>switch <condition>(<expr><name>opstrategy</name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>BTEqualStrategyNumber</name></expr>:</case>
			<expr_stmt><expr><name>off</name> <operator>=</operator> <call><name>partition_list_bsearch</name><argument_list>(<argument><expr><name>partsupfunc</name></expr></argument>,
										 <argument><expr><name>partcollation</name></expr></argument>,
										 <argument><expr><name>boundinfo</name></expr></argument>, <argument><expr><name>value</name></expr></argument>,
										 <argument><expr><operator>&amp;</operator><name>is_equal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>off</name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>is_equal</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>boundinfo</name><operator>-&gt;</operator><name>indexes</name><index>[<expr><name>off</name></expr>]</index></name> <operator>&gt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>bound_offsets</name></name> <operator>=</operator> <call><name>bms_make_singleton</name><argument_list>(<argument><expr><name>off</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>scan_default</name></name> <operator>=</operator> <call><name>partition_bound_has_default</name><argument_list>(<argument><expr><name>boundinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
			<return>return <expr><name>result</name></expr>;</return>

		<case>case <expr><name>BTGreaterEqualStrategyNumber</name></expr>:</case>
			<expr_stmt><expr><name>inclusive</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<comment type="block">/* fall through */</comment>
		<case>case <expr><name>BTGreaterStrategyNumber</name></expr>:</case>
			<expr_stmt><expr><name>off</name> <operator>=</operator> <call><name>partition_list_bsearch</name><argument_list>(<argument><expr><name>partsupfunc</name></expr></argument>,
										 <argument><expr><name>partcollation</name></expr></argument>,
										 <argument><expr><name>boundinfo</name></expr></argument>, <argument><expr><name>value</name></expr></argument>,
										 <argument><expr><operator>&amp;</operator><name>is_equal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>off</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* We don't want the matched datum to be in the result. */</comment>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><name>is_equal</name> <operator>||</operator> <operator>!</operator><name>inclusive</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>off</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<comment type="block">/*
				 * This case means all partition bounds are greater, which in
				 * turn means that all partitions satisfy this key.
				 */</comment>
				<expr_stmt><expr><name>off</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>

			<comment type="block">/*
			 * off is greater than the numbers of datums we have partitions
			 * for.  The only possible partition that could contain a match is
			 * the default partition, but we must've set context-&gt;scan_default
			 * above anyway if one exists.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name>off</name> <operator>&gt;</operator> <name><name>boundinfo</name><operator>-&gt;</operator><name>ndatums</name></name> <operator>-</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>result</name></expr>;</return></block_content></block></if></if_stmt>

			<expr_stmt><expr><name>minoff</name> <operator>=</operator> <name>off</name></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>BTLessEqualStrategyNumber</name></expr>:</case>
			<expr_stmt><expr><name>inclusive</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<comment type="block">/* fall through */</comment>
		<case>case <expr><name>BTLessStrategyNumber</name></expr>:</case>
			<expr_stmt><expr><name>off</name> <operator>=</operator> <call><name>partition_list_bsearch</name><argument_list>(<argument><expr><name>partsupfunc</name></expr></argument>,
										 <argument><expr><name>partcollation</name></expr></argument>,
										 <argument><expr><name>boundinfo</name></expr></argument>, <argument><expr><name>value</name></expr></argument>,
										 <argument><expr><operator>&amp;</operator><name>is_equal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>off</name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>is_equal</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>inclusive</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>off</name><operator>--</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<comment type="block">/*
			 * off is smaller than the datums of all non-default partitions.
			 * The only possible partition that could contain a match is the
			 * default partition, but we must've set context-&gt;scan_default
			 * above anyway if one exists.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name>off</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>result</name></expr>;</return></block_content></block></if></if_stmt>

			<expr_stmt><expr><name>maxoff</name> <operator>=</operator> <name>off</name></expr>;</expr_stmt>
			<break>break;</break>

		<default>default:</default>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"invalid strategy number %d"</literal></expr></argument>, <argument><expr><name>opstrategy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
	</block_content>}</block></switch>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>minoff</name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>maxoff</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>bound_offsets</name></name> <operator>=</operator> <call><name>bms_add_range</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>minoff</name></expr></argument>, <argument><expr><name>maxoff</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * get_matching_range_datums
 *		Determine the offsets of range bounds matching the specified values,
 *		according to the semantics of the given operator strategy
 *
 * Each datum whose offset is in result is to be treated as the upper bound of
 * the partition that will contain the desired values.
 *
 * scan_default is set in the returned struct if a default partition exists
 * and we're absolutely certain that it needs to be scanned.  We do *not* set
 * it just because values match portions of the key space uncovered by
 * partitions other than default (space which we normally assume to belong to
 * the default partition): the final set of bounds obtained after combining
 * multiple pruning steps might exclude it, so we infer its inclusion
 * elsewhere.
 *
 * 'opstrategy' if non-zero must be a btree strategy number.
 *
 * 'values' contains Datums indexed by the partition key to use for pruning.
 *
 * 'nvalues', number of Datums in 'values' array. Must be &lt;= context-&gt;partnatts.
 *
 * 'partsupfunc' contains the range partitioning comparison functions to be
 * used to perform partition_range_datum_bsearch or partition_rbound_datum_cmp
 * using.
 *
 * 'nullkeys' is the set of partition keys that are null.
 */</comment>
<function><type><specifier>static</specifier> <name>PruneStepResult</name> <modifier>*</modifier></type>
<name>get_matching_range_bounds</name><parameter_list>(<parameter><decl><type><name>PartitionPruneContext</name> <modifier>*</modifier></type><name>context</name></decl></parameter>,
						  <parameter><decl><type><name>StrategyNumber</name></type> <name>opstrategy</name></decl></parameter>, <parameter><decl><type><name>Datum</name> <modifier>*</modifier></type><name>values</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nvalues</name></decl></parameter>,
						  <parameter><decl><type><name>FmgrInfo</name> <modifier>*</modifier></type><name>partsupfunc</name></decl></parameter>, <parameter><decl><type><name>Bitmapset</name> <modifier>*</modifier></type><name>nullkeys</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PruneStepResult</name> <modifier>*</modifier></type><name>result</name> <init>= <expr><operator>(</operator><name>PruneStepResult</name> <operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>PruneStepResult</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PartitionBoundInfo</name></type> <name>boundinfo</name> <init>= <expr><name><name>context</name><operator>-&gt;</operator><name>boundinfo</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name>		   <modifier>*</modifier></type><name>partcollation</name> <init>= <expr><name><name>context</name><operator>-&gt;</operator><name>partcollation</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>partnatts</name> <init>= <expr><name><name>context</name><operator>-&gt;</operator><name>partnatts</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name>		   <modifier>*</modifier></type><name>partindices</name> <init>= <expr><name><name>boundinfo</name><operator>-&gt;</operator><name>indexes</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>off</name></decl>,
				<decl><type ref="prev"/><name>minoff</name></decl>,
				<decl><type ref="prev"/><name>maxoff</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>is_equal</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>inclusive</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>context</name><operator>-&gt;</operator><name>strategy</name></name> <operator>==</operator> <name>PARTITION_STRATEGY_RANGE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>nvalues</name> <operator>&lt;=</operator> <name>partnatts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>scan_null</name></name> <operator>=</operator> <name><name>result</name><operator>-&gt;</operator><name>scan_default</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * If there are no datums to compare keys with, or if we got an IS NULL
	 * clause just return the default partition, if it exists.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>boundinfo</name><operator>-&gt;</operator><name>ndatums</name></name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <operator>!</operator><call><name>bms_is_empty</name><argument_list>(<argument><expr><name>nullkeys</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>scan_default</name></name> <operator>=</operator> <call><name>partition_bound_has_default</name><argument_list>(<argument><expr><name>boundinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>result</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>minoff</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>maxoff</name> <operator>=</operator> <name><name>boundinfo</name><operator>-&gt;</operator><name>ndatums</name></name></expr>;</expr_stmt>

	<comment type="block">/*
	 * If there are no values to compare with the datums in boundinfo, it
	 * means the caller asked for partitions for all non-null datums.  Add
	 * indexes of *all* partitions, including the default partition if one
	 * exists.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>nvalues</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* ignore key space not covered by any partitions */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>partindices</name><index>[<expr><name>minoff</name></expr>]</index></name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>minoff</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>partindices</name><index>[<expr><name>maxoff</name></expr>]</index></name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>maxoff</name><operator>--</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>scan_default</name></name> <operator>=</operator> <call><name>partition_bound_has_default</name><argument_list>(<argument><expr><name>boundinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>partindices</name><index>[<expr><name>minoff</name></expr>]</index></name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
			   <name><name>partindices</name><index>[<expr><name>maxoff</name></expr>]</index></name> <operator>&gt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>bound_offsets</name></name> <operator>=</operator> <call><name>bms_add_range</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>minoff</name></expr></argument>, <argument><expr><name>maxoff</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<return>return <expr><name>result</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * If the query does not constrain all key columns, we'll need to scan the
	 * the default partition, if any.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>nvalues</name> <operator>&lt;</operator> <name>partnatts</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>scan_default</name></name> <operator>=</operator> <call><name>partition_bound_has_default</name><argument_list>(<argument><expr><name>boundinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<switch>switch <condition>(<expr><name>opstrategy</name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>BTEqualStrategyNumber</name></expr>:</case>
			<comment type="block">/* Look for the smallest bound that is = lookup value. */</comment>
			<expr_stmt><expr><name>off</name> <operator>=</operator> <call><name>partition_range_datum_bsearch</name><argument_list>(<argument><expr><name>partsupfunc</name></expr></argument>,
												<argument><expr><name>partcollation</name></expr></argument>,
												<argument><expr><name>boundinfo</name></expr></argument>,
												<argument><expr><name>nvalues</name></expr></argument>, <argument><expr><name>values</name></expr></argument>,
												<argument><expr><operator>&amp;</operator><name>is_equal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name>off</name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>is_equal</name></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name>nvalues</name> <operator>==</operator> <name>partnatts</name></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/* There can only be zero or one matching partition. */</comment>
					<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>bound_offsets</name></name> <operator>=</operator> <call><name>bms_make_singleton</name><argument_list>(<argument><expr><name>off</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<return>return <expr><name>result</name></expr>;</return>
				</block_content>}</block></if>
				<else>else
				<block>{<block_content>
					<decl_stmt><decl><type><name>int</name></type>			<name>saved_off</name> <init>= <expr><name>off</name></expr></init></decl>;</decl_stmt>

					<comment type="block">/*
					 * Since the lookup value contains only a prefix of keys,
					 * we must find other bounds that may also match the
					 * prefix.  partition_range_datum_bsearch() returns the
					 * offset of one of them, find others by checking adjacent
					 * bounds.
					 */</comment>

					<comment type="block">/*
					 * First find greatest bound that's smaller than the
					 * lookup value.
					 */</comment>
					<while>while <condition>(<expr><name>off</name> <operator>&gt;=</operator> <literal type="number">1</literal></expr>)</condition>
					<block>{<block_content>
						<decl_stmt><decl><type><name>int32</name></type>		<name>cmpval</name></decl>;</decl_stmt>

						<expr_stmt><expr><name>cmpval</name> <operator>=</operator>
							<call><name>partition_rbound_datum_cmp</name><argument_list>(<argument><expr><name>partsupfunc</name></expr></argument>,
													   <argument><expr><name>partcollation</name></expr></argument>,
													   <argument><expr><name><name>boundinfo</name><operator>-&gt;</operator><name>datums</name><index>[<expr><name>off</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>,
													   <argument><expr><name><name>boundinfo</name><operator>-&gt;</operator><name>kind</name><index>[<expr><name>off</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>,
													   <argument><expr><name>values</name></expr></argument>, <argument><expr><name>nvalues</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<if_stmt><if>if <condition>(<expr><name>cmpval</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
							<break>break;</break></block_content></block></if></if_stmt>
						<expr_stmt><expr><name>off</name><operator>--</operator></expr>;</expr_stmt>
					</block_content>}</block></while>

					<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><literal type="number">0</literal> <operator>==</operator>
						   <call><name>partition_rbound_datum_cmp</name><argument_list>(<argument><expr><name>partsupfunc</name></expr></argument>,
													  <argument><expr><name>partcollation</name></expr></argument>,
													  <argument><expr><name><name>boundinfo</name><operator>-&gt;</operator><name>datums</name><index>[<expr><name>off</name></expr>]</index></name></expr></argument>,
													  <argument><expr><name><name>boundinfo</name><operator>-&gt;</operator><name>kind</name><index>[<expr><name>off</name></expr>]</index></name></expr></argument>,
													  <argument><expr><name>values</name></expr></argument>, <argument><expr><name>nvalues</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<comment type="block">/*
					 * We can treat 'off' as the offset of the smallest bound
					 * to be included in the result, if we know it is the
					 * upper bound of the partition in which the lookup value
					 * could possibly exist.  One case it couldn't is if the
					 * bound, or precisely the matched portion of its prefix,
					 * is not inclusive.
					 */</comment>
					<if_stmt><if>if <condition>(<expr><name><name>boundinfo</name><operator>-&gt;</operator><name>kind</name><index>[<expr><name>off</name></expr>]</index><index>[<expr><name>nvalues</name></expr>]</index></name> <operator>==</operator>
						<name>PARTITION_RANGE_DATUM_MINVALUE</name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><name>off</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>

					<expr_stmt><expr><name>minoff</name> <operator>=</operator> <name>off</name></expr>;</expr_stmt>

					<comment type="block">/*
					 * Now find smallest bound that's greater than the lookup
					 * value.
					 */</comment>
					<expr_stmt><expr><name>off</name> <operator>=</operator> <name>saved_off</name></expr>;</expr_stmt>
					<while>while <condition>(<expr><name>off</name> <operator>&lt;</operator> <name><name>boundinfo</name><operator>-&gt;</operator><name>ndatums</name></name> <operator>-</operator> <literal type="number">1</literal></expr>)</condition>
					<block>{<block_content>
						<decl_stmt><decl><type><name>int32</name></type>		<name>cmpval</name></decl>;</decl_stmt>

						<expr_stmt><expr><name>cmpval</name> <operator>=</operator> <call><name>partition_rbound_datum_cmp</name><argument_list>(<argument><expr><name>partsupfunc</name></expr></argument>,
															<argument><expr><name>partcollation</name></expr></argument>,
															<argument><expr><name><name>boundinfo</name><operator>-&gt;</operator><name>datums</name><index>[<expr><name>off</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>,
															<argument><expr><name><name>boundinfo</name><operator>-&gt;</operator><name>kind</name><index>[<expr><name>off</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>,
															<argument><expr><name>values</name></expr></argument>, <argument><expr><name>nvalues</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<if_stmt><if>if <condition>(<expr><name>cmpval</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
							<break>break;</break></block_content></block></if></if_stmt>
						<expr_stmt><expr><name>off</name><operator>++</operator></expr>;</expr_stmt>
					</block_content>}</block></while>

					<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><literal type="number">0</literal> <operator>==</operator>
						   <call><name>partition_rbound_datum_cmp</name><argument_list>(<argument><expr><name>partsupfunc</name></expr></argument>,
													  <argument><expr><name>partcollation</name></expr></argument>,
													  <argument><expr><name><name>boundinfo</name><operator>-&gt;</operator><name>datums</name><index>[<expr><name>off</name></expr>]</index></name></expr></argument>,
													  <argument><expr><name><name>boundinfo</name><operator>-&gt;</operator><name>kind</name><index>[<expr><name>off</name></expr>]</index></name></expr></argument>,
													  <argument><expr><name>values</name></expr></argument>, <argument><expr><name>nvalues</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<comment type="block">/*
					 * off + 1, then would be the offset of the greatest bound
					 * to be included in the result.
					 */</comment>
					<expr_stmt><expr><name>maxoff</name> <operator>=</operator> <name>off</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
				</block_content>}</block></else></if_stmt>

				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>minoff</name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>maxoff</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>bound_offsets</name></name> <operator>=</operator> <call><name>bms_add_range</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>minoff</name></expr></argument>, <argument><expr><name>maxoff</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<comment type="block">/*
				 * The lookup value falls in the range between some bounds in
				 * boundinfo.  'off' would be the offset of the greatest bound
				 * that is &lt;= lookup value, so add off + 1 to the result
				 * instead as the offset of the upper bound of the only
				 * partition that may contain the lookup value.  If 'off' is
				 * -1 indicating that all bounds are greater, then we simply
				 * end up adding the first bound's offset, that is, 0.
				 */</comment>
				<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>bound_offsets</name></name> <operator>=</operator> <call><name>bms_make_singleton</name><argument_list>(<argument><expr><name>off</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>

			<return>return <expr><name>result</name></expr>;</return>

		<case>case <expr><name>BTGreaterEqualStrategyNumber</name></expr>:</case>
			<expr_stmt><expr><name>inclusive</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<comment type="block">/* fall through */</comment>
		<case>case <expr><name>BTGreaterStrategyNumber</name></expr>:</case>

			<comment type="block">/*
			 * Look for the smallest bound that is &gt; or &gt;= lookup value and
			 * set minoff to its offset.
			 */</comment>
			<expr_stmt><expr><name>off</name> <operator>=</operator> <call><name>partition_range_datum_bsearch</name><argument_list>(<argument><expr><name>partsupfunc</name></expr></argument>,
												<argument><expr><name>partcollation</name></expr></argument>,
												<argument><expr><name>boundinfo</name></expr></argument>,
												<argument><expr><name>nvalues</name></expr></argument>, <argument><expr><name>values</name></expr></argument>,
												<argument><expr><operator>&amp;</operator><name>is_equal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>off</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/*
				 * All bounds are greater than the lookup value, so include
				 * all of them in the result.
				 */</comment>
				<expr_stmt><expr><name>minoff</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name>is_equal</name> <operator>&amp;&amp;</operator> <name>nvalues</name> <operator>&lt;</operator> <name>partnatts</name></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/*
					 * Since the lookup value contains only a prefix of keys,
					 * we must find other bounds that may also match the
					 * prefix.  partition_range_datum_bsearch() returns the
					 * offset of one of them, find others by checking adjacent
					 * bounds.
					 *
					 * Based on whether the lookup values are inclusive or
					 * not, we must either include the indexes of all such
					 * bounds in the result (that is, set minoff to the index
					 * of smallest such bound) or find the smallest one that's
					 * greater than the lookup values and set minoff to that.
					 */</comment>
					<while>while <condition>(<expr><name>off</name> <operator>&gt;=</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <name>off</name> <operator>&lt;</operator> <name><name>boundinfo</name><operator>-&gt;</operator><name>ndatums</name></name> <operator>-</operator> <literal type="number">1</literal></expr>)</condition>
					<block>{<block_content>
						<decl_stmt><decl><type><name>int32</name></type>		<name>cmpval</name></decl>;</decl_stmt>
						<decl_stmt><decl><type><name>int</name></type>			<name>nextoff</name></decl>;</decl_stmt>

						<expr_stmt><expr><name>nextoff</name> <operator>=</operator> <ternary><condition><expr><name>inclusive</name></expr> ?</condition><then> <expr><name>off</name> <operator>-</operator> <literal type="number">1</literal></expr> </then><else>: <expr><name>off</name> <operator>+</operator> <literal type="number">1</literal></expr></else></ternary></expr>;</expr_stmt>
						<expr_stmt><expr><name>cmpval</name> <operator>=</operator>
							<call><name>partition_rbound_datum_cmp</name><argument_list>(<argument><expr><name>partsupfunc</name></expr></argument>,
													   <argument><expr><name>partcollation</name></expr></argument>,
													   <argument><expr><name><name>boundinfo</name><operator>-&gt;</operator><name>datums</name><index>[<expr><name>nextoff</name></expr>]</index></name></expr></argument>,
													   <argument><expr><name><name>boundinfo</name><operator>-&gt;</operator><name>kind</name><index>[<expr><name>nextoff</name></expr>]</index></name></expr></argument>,
													   <argument><expr><name>values</name></expr></argument>, <argument><expr><name>nvalues</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<if_stmt><if>if <condition>(<expr><name>cmpval</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
							<break>break;</break></block_content></block></if></if_stmt>

						<expr_stmt><expr><name>off</name> <operator>=</operator> <name>nextoff</name></expr>;</expr_stmt>
					</block_content>}</block></while>

					<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><literal type="number">0</literal> <operator>==</operator>
						   <call><name>partition_rbound_datum_cmp</name><argument_list>(<argument><expr><name>partsupfunc</name></expr></argument>,
													  <argument><expr><name>partcollation</name></expr></argument>,
													  <argument><expr><name><name>boundinfo</name><operator>-&gt;</operator><name>datums</name><index>[<expr><name>off</name></expr>]</index></name></expr></argument>,
													  <argument><expr><name><name>boundinfo</name><operator>-&gt;</operator><name>kind</name><index>[<expr><name>off</name></expr>]</index></name></expr></argument>,
													  <argument><expr><name>values</name></expr></argument>, <argument><expr><name>nvalues</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<expr_stmt><expr><name>minoff</name> <operator>=</operator> <ternary><condition><expr><name>inclusive</name></expr> ?</condition><then> <expr><name>off</name></expr> </then><else>: <expr><name>off</name> <operator>+</operator> <literal type="number">1</literal></expr></else></ternary></expr>;</expr_stmt>
				</block_content>}</block></if>
				<else>else
				<block>{<block_content>

					<comment type="block">/*
					 * lookup value falls in the range between some bounds in
					 * boundinfo.  off would be the offset of the greatest
					 * bound that is &lt;= lookup value, so add off + 1 to the
					 * result instead as the offset of the upper bound of the
					 * smallest partition that may contain the lookup value.
					 */</comment>
					<expr_stmt><expr><name>minoff</name> <operator>=</operator> <name>off</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
				</block_content>}</block></else></if_stmt>
			</block_content>}</block></else></if_stmt>
			<break>break;</break>

		<case>case <expr><name>BTLessEqualStrategyNumber</name></expr>:</case>
			<expr_stmt><expr><name>inclusive</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<comment type="block">/* fall through */</comment>
		<case>case <expr><name>BTLessStrategyNumber</name></expr>:</case>

			<comment type="block">/*
			 * Look for the greatest bound that is &lt; or &lt;= lookup value and
			 * set maxoff to its offset.
			 */</comment>
			<expr_stmt><expr><name>off</name> <operator>=</operator> <call><name>partition_range_datum_bsearch</name><argument_list>(<argument><expr><name>partsupfunc</name></expr></argument>,
												<argument><expr><name>partcollation</name></expr></argument>,
												<argument><expr><name>boundinfo</name></expr></argument>,
												<argument><expr><name>nvalues</name></expr></argument>, <argument><expr><name>values</name></expr></argument>,
												<argument><expr><operator>&amp;</operator><name>is_equal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>off</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/*
				 * See the comment above.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><name>is_equal</name> <operator>&amp;&amp;</operator> <name>nvalues</name> <operator>&lt;</operator> <name>partnatts</name></expr>)</condition>
				<block>{<block_content>
					<while>while <condition>(<expr><name>off</name> <operator>&gt;=</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <name>off</name> <operator>&lt;</operator> <name><name>boundinfo</name><operator>-&gt;</operator><name>ndatums</name></name> <operator>-</operator> <literal type="number">1</literal></expr>)</condition>
					<block>{<block_content>
						<decl_stmt><decl><type><name>int32</name></type>		<name>cmpval</name></decl>;</decl_stmt>
						<decl_stmt><decl><type><name>int</name></type>			<name>nextoff</name></decl>;</decl_stmt>

						<expr_stmt><expr><name>nextoff</name> <operator>=</operator> <ternary><condition><expr><name>inclusive</name></expr> ?</condition><then> <expr><name>off</name> <operator>+</operator> <literal type="number">1</literal></expr> </then><else>: <expr><name>off</name> <operator>-</operator> <literal type="number">1</literal></expr></else></ternary></expr>;</expr_stmt>
						<expr_stmt><expr><name>cmpval</name> <operator>=</operator> <call><name>partition_rbound_datum_cmp</name><argument_list>(<argument><expr><name>partsupfunc</name></expr></argument>,
															<argument><expr><name>partcollation</name></expr></argument>,
															<argument><expr><name><name>boundinfo</name><operator>-&gt;</operator><name>datums</name><index>[<expr><name>nextoff</name></expr>]</index></name></expr></argument>,
															<argument><expr><name><name>boundinfo</name><operator>-&gt;</operator><name>kind</name><index>[<expr><name>nextoff</name></expr>]</index></name></expr></argument>,
															<argument><expr><name>values</name></expr></argument>, <argument><expr><name>nvalues</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<if_stmt><if>if <condition>(<expr><name>cmpval</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
							<break>break;</break></block_content></block></if></if_stmt>

						<expr_stmt><expr><name>off</name> <operator>=</operator> <name>nextoff</name></expr>;</expr_stmt>
					</block_content>}</block></while>

					<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><literal type="number">0</literal> <operator>==</operator>
						   <call><name>partition_rbound_datum_cmp</name><argument_list>(<argument><expr><name>partsupfunc</name></expr></argument>,
													  <argument><expr><name>partcollation</name></expr></argument>,
													  <argument><expr><name><name>boundinfo</name><operator>-&gt;</operator><name>datums</name><index>[<expr><name>off</name></expr>]</index></name></expr></argument>,
													  <argument><expr><name><name>boundinfo</name><operator>-&gt;</operator><name>kind</name><index>[<expr><name>off</name></expr>]</index></name></expr></argument>,
													  <argument><expr><name>values</name></expr></argument>, <argument><expr><name>nvalues</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<expr_stmt><expr><name>maxoff</name> <operator>=</operator> <ternary><condition><expr><name>inclusive</name></expr> ?</condition><then> <expr><name>off</name> <operator>+</operator> <literal type="number">1</literal></expr> </then><else>: <expr><name>off</name></expr></else></ternary></expr>;</expr_stmt>
				</block_content>}</block></if>

				<comment type="block">/*
				 * The lookup value falls in the range between some bounds in
				 * boundinfo.  'off' would be the offset of the greatest bound
				 * that is &lt;= lookup value, so add off + 1 to the result
				 * instead as the offset of the upper bound of the greatest
				 * partition that may contain lookup value.  If the lookup
				 * value had exactly matched the bound, but it isn't
				 * inclusive, no need add the adjacent partition.
				 */</comment>
				<if type="elseif">else if <condition>(<expr><operator>!</operator><name>is_equal</name> <operator>||</operator> <name>inclusive</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>maxoff</name> <operator>=</operator> <name>off</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><name>maxoff</name> <operator>=</operator> <name>off</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<comment type="block">/*
				 * 'off' is -1 indicating that all bounds are greater, so just
				 * set the first bound's offset as maxoff.
				 */</comment>
				<expr_stmt><expr><name>maxoff</name> <operator>=</operator> <name>off</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
			<break>break;</break>

		<default>default:</default>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"invalid strategy number %d"</literal></expr></argument>, <argument><expr><name>opstrategy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
	</block_content>}</block></switch>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>minoff</name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>minoff</name> <operator>&lt;=</operator> <name><name>boundinfo</name><operator>-&gt;</operator><name>ndatums</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>maxoff</name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>maxoff</name> <operator>&lt;=</operator> <name><name>boundinfo</name><operator>-&gt;</operator><name>ndatums</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If the smallest partition to return has MINVALUE (negative infinity) as
	 * its lower bound, increment it to point to the next finite bound
	 * (supposedly its upper bound), so that we don't advertently end up
	 * scanning the default partition.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>minoff</name> <operator>&lt;</operator> <name><name>boundinfo</name><operator>-&gt;</operator><name>ndatums</name></name> <operator>&amp;&amp;</operator> <name><name>partindices</name><index>[<expr><name>minoff</name></expr>]</index></name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>lastkey</name> <init>= <expr><name>nvalues</name> <operator>-</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>boundinfo</name><operator>-&gt;</operator><name>kind</name><index>[<expr><name>minoff</name></expr>]</index><index>[<expr><name>lastkey</name></expr>]</index></name> <operator>==</operator>
			<name>PARTITION_RANGE_DATUM_MINVALUE</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>minoff</name><operator>++</operator></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>boundinfo</name><operator>-&gt;</operator><name>indexes</name><index>[<expr><name>minoff</name></expr>]</index></name> <operator>&gt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * If the previous greatest partition has MAXVALUE (positive infinity) as
	 * its upper bound (something only possible to do with multi-column range
	 * partitioning), we scan switch to it as the greatest partition to
	 * return.  Again, so that we don't advertently end up scanning the
	 * default partition.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>maxoff</name> <operator>&gt;=</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <name><name>partindices</name><index>[<expr><name>maxoff</name></expr>]</index></name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>lastkey</name> <init>= <expr><name>nvalues</name> <operator>-</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>boundinfo</name><operator>-&gt;</operator><name>kind</name><index>[<expr><name>maxoff</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index><index>[<expr><name>lastkey</name></expr>]</index></name> <operator>==</operator>
			<name>PARTITION_RANGE_DATUM_MAXVALUE</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>maxoff</name><operator>--</operator></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>boundinfo</name><operator>-&gt;</operator><name>indexes</name><index>[<expr><name>maxoff</name></expr>]</index></name> <operator>&gt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>minoff</name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>maxoff</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>minoff</name> <operator>&lt;=</operator> <name>maxoff</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>bound_offsets</name></name> <operator>=</operator> <call><name>bms_add_range</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>minoff</name></expr></argument>, <argument><expr><name>maxoff</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * pull_exec_paramids
 *		Returns a Bitmapset containing the paramids of all Params with
 *		paramkind = PARAM_EXEC in 'expr'.
 */</comment>
<function><type><specifier>static</specifier> <name>Bitmapset</name> <modifier>*</modifier></type>
<name>pull_exec_paramids</name><parameter_list>(<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>expr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Bitmapset</name>  <modifier>*</modifier></type><name>result</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>pull_exec_paramids_walker</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>expr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>pull_exec_paramids_walker</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>Bitmapset</name> <modifier>*</modifier><modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>node</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>Param</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Param</name>	   <modifier>*</modifier></type><name>param</name> <init>= <expr><operator>(</operator><name>Param</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>param</name><operator>-&gt;</operator><name>paramkind</name></name> <operator>==</operator> <name>PARAM_EXEC</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><operator>*</operator><name>context</name> <operator>=</operator> <call><name>bms_add_member</name><argument_list>(<argument><expr><operator>*</operator><name>context</name></expr></argument>, <argument><expr><name><name>param</name><operator>-&gt;</operator><name>paramid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><call><name>expression_tree_walker</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>pull_exec_paramids_walker</name></expr></argument>,
								  <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>context</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * get_partkey_exec_paramids
 *		Loop through given pruning steps and find out which exec Params
 *		are used.
 *
 * Returns a Bitmapset of Param IDs.
 */</comment>
<function><type><specifier>static</specifier> <name>Bitmapset</name> <modifier>*</modifier></type>
<name>get_partkey_exec_paramids</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>steps</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Bitmapset</name>  <modifier>*</modifier></type><name>execparamids</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>steps</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>PartitionPruneStepOp</name> <modifier>*</modifier></type><name>step</name> <init>= <expr><operator>(</operator><name>PartitionPruneStepOp</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc2</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name>step</name></expr></argument>, <argument><expr><name>PartitionPruneStepOp</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<macro><name>foreach</name><argument_list>(<argument>lc2</argument>, <argument>step-&gt;exprs</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Expr</name>	   <modifier>*</modifier></type><name>expr</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc2</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<comment type="block">/* We can be quick for plain Consts */</comment>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name>expr</name></expr></argument>, <argument><expr><name>Const</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>execparamids</name> <operator>=</operator> <call><name>bms_join</name><argument_list>(<argument><expr><name>execparamids</name></expr></argument>,
										<argument><expr><call><name>pull_exec_paramids</name><argument_list>(<argument><expr><name>expr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block>
	</block_content>}</block>

	<return>return <expr><name>execparamids</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * perform_pruning_base_step
 *		Determines the indexes of datums that satisfy conditions specified in
 *		'opstep'.
 *
 * Result also contains whether special null-accepting and/or default
 * partition need to be scanned.
 */</comment>
<function><type><specifier>static</specifier> <name>PruneStepResult</name> <modifier>*</modifier></type>
<name>perform_pruning_base_step</name><parameter_list>(<parameter><decl><type><name>PartitionPruneContext</name> <modifier>*</modifier></type><name>context</name></decl></parameter>,
						  <parameter><decl><type><name>PartitionPruneStepOp</name> <modifier>*</modifier></type><name>opstep</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc1</name></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name>lc2</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>keyno</name></decl>,
				<decl><type ref="prev"/><name>nvalues</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type>		<name><name>values</name><index>[<expr><name>PARTITION_MAX_KEYS</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>FmgrInfo</name>   <modifier>*</modifier></type><name>partsupfunc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>stateidx</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * There better be the same number of expressions and compare functions.
	 */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>opstep</name><operator>-&gt;</operator><name>exprs</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>opstep</name><operator>-&gt;</operator><name>cmpfns</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>nvalues</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>lc1</name> <operator>=</operator> <call><name>list_head</name><argument_list>(<argument><expr><name><name>opstep</name><operator>-&gt;</operator><name>exprs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>lc2</name> <operator>=</operator> <call><name>list_head</name><argument_list>(<argument><expr><name><name>opstep</name><operator>-&gt;</operator><name>cmpfns</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Generate the partition lookup key that will be used by one of the
	 * get_matching_*_bounds functions called below.
	 */</comment>
	<for>for <control>(<init><expr><name>keyno</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>keyno</name> <operator>&lt;</operator> <name><name>context</name><operator>-&gt;</operator><name>partnatts</name></name></expr>;</condition> <incr><expr><name>keyno</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<comment type="block">/*
		 * For hash partitioning, it is possible that values of some keys are
		 * not provided in operator clauses, but instead the planner found
		 * that they appeared in a IS NULL clause.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>bms_is_member</name><argument_list>(<argument><expr><name>keyno</name></expr></argument>, <argument><expr><name><name>opstep</name><operator>-&gt;</operator><name>nullkeys</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * For range partitioning, we must only perform pruning with values
		 * for either all partition keys or a prefix thereof.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>keyno</name> <operator>&gt;</operator> <name>nvalues</name> <operator>&amp;&amp;</operator> <name><name>context</name><operator>-&gt;</operator><name>strategy</name></name> <operator>==</operator> <name>PARTITION_STRATEGY_RANGE</name></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>lc1</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Expr</name>	   <modifier>*</modifier></type><name>expr</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Datum</name></type>		<name>datum</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>bool</name></type>		<name>isnull</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Oid</name></type>			<name>cmpfn</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>expr</name> <operator>=</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>stateidx</name> <operator>=</operator> <call><name>PruneCxtStateIdx</name><argument_list>(<argument><expr><name><name>context</name><operator>-&gt;</operator><name>partnatts</name></name></expr></argument>,
										<argument><expr><name><name>opstep</name><operator>-&gt;</operator><name>step</name><operator>.</operator><name>step_id</name></name></expr></argument>, <argument><expr><name>keyno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>partkey_datum_from_expr</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>, <argument><expr><name>stateidx</name></expr></argument>,
									<argument><expr><operator>&amp;</operator><name>datum</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * Since we only allow strict operators in pruning steps, any
			 * null-valued comparison value must cause the comparison to fail,
			 * so that no partitions could match.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name>isnull</name></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>PruneStepResult</name> <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>

				<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>PruneStepResult</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>PruneStepResult</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>bound_offsets</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>scan_default</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>scan_null</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

				<return>return <expr><name>result</name></expr>;</return>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/* Set up the stepcmpfuncs entry, unless we already did */</comment>
			<expr_stmt><expr><name>cmpfn</name> <operator>=</operator> <call><name>lfirst_oid</name><argument_list>(<argument><expr><name>lc2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>cmpfn</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>cmpfn</name> <operator>!=</operator> <name><name>context</name><operator>-&gt;</operator><name>stepcmpfuncs</name><index>[<expr><name>stateidx</name></expr>]</index></name><operator>.</operator><name>fn_oid</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/*
				 * If the needed support function is the same one cached in
				 * the relation's partition key, copy the cached FmgrInfo.
				 * Otherwise (i.e., when we have a cross-type comparison), an
				 * actual lookup is required.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><name>cmpfn</name> <operator>==</operator> <name><name>context</name><operator>-&gt;</operator><name>partsupfunc</name><index>[<expr><name>keyno</name></expr>]</index></name><operator>.</operator><name>fn_oid</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>fmgr_info_copy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>context</name><operator>-&gt;</operator><name>stepcmpfuncs</name><index>[<expr><name>stateidx</name></expr>]</index></name></expr></argument>,
								   <argument><expr><operator>&amp;</operator><name><name>context</name><operator>-&gt;</operator><name>partsupfunc</name><index>[<expr><name>keyno</name></expr>]</index></name></expr></argument>,
								   <argument><expr><name><name>context</name><operator>-&gt;</operator><name>ppccontext</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>fmgr_info_cxt</name><argument_list>(<argument><expr><name>cmpfn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>context</name><operator>-&gt;</operator><name>stepcmpfuncs</name><index>[<expr><name>stateidx</name></expr>]</index></name></expr></argument>,
								  <argument><expr><name><name>context</name><operator>-&gt;</operator><name>ppccontext</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
			</block_content>}</block></if></if_stmt>

			<expr_stmt><expr><name><name>values</name><index>[<expr><name>keyno</name></expr>]</index></name> <operator>=</operator> <name>datum</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>nvalues</name><operator>++</operator></expr>;</expr_stmt>

			<expr_stmt><expr><name>lc1</name> <operator>=</operator> <call><name>lnext</name><argument_list>(<argument><expr><name>lc1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>lc2</name> <operator>=</operator> <call><name>lnext</name><argument_list>(<argument><expr><name>lc2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>

	<comment type="block">/*
	 * Point partsupfunc to the entry for the 0th key of this step; the
	 * additional support functions, if any, follow consecutively.
	 */</comment>
	<expr_stmt><expr><name>stateidx</name> <operator>=</operator> <call><name>PruneCxtStateIdx</name><argument_list>(<argument><expr><name><name>context</name><operator>-&gt;</operator><name>partnatts</name></name></expr></argument>, <argument><expr><name><name>opstep</name><operator>-&gt;</operator><name>step</name><operator>.</operator><name>step_id</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>partsupfunc</name> <operator>=</operator> <operator>&amp;</operator><name><name>context</name><operator>-&gt;</operator><name>stepcmpfuncs</name><index>[<expr><name>stateidx</name></expr>]</index></name></expr>;</expr_stmt>

	<switch>switch <condition>(<expr><name><name>context</name><operator>-&gt;</operator><name>strategy</name></name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>PARTITION_STRATEGY_HASH</name></expr>:</case>
			<return>return <expr><call><name>get_matching_hash_bounds</name><argument_list>(<argument><expr><name>context</name></expr></argument>,
											<argument><expr><name><name>opstep</name><operator>-&gt;</operator><name>opstrategy</name></name></expr></argument>,
											<argument><expr><name>values</name></expr></argument>, <argument><expr><name>nvalues</name></expr></argument>,
											<argument><expr><name>partsupfunc</name></expr></argument>,
											<argument><expr><name><name>opstep</name><operator>-&gt;</operator><name>nullkeys</name></name></expr></argument>)</argument_list></call></expr>;</return>

		<case>case <expr><name>PARTITION_STRATEGY_LIST</name></expr>:</case>
			<return>return <expr><call><name>get_matching_list_bounds</name><argument_list>(<argument><expr><name>context</name></expr></argument>,
											<argument><expr><name><name>opstep</name><operator>-&gt;</operator><name>opstrategy</name></name></expr></argument>,
											<argument><expr><name><name>values</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name>nvalues</name></expr></argument>,
											<argument><expr><operator>&amp;</operator><name><name>partsupfunc</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,
											<argument><expr><name><name>opstep</name><operator>-&gt;</operator><name>nullkeys</name></name></expr></argument>)</argument_list></call></expr>;</return>

		<case>case <expr><name>PARTITION_STRATEGY_RANGE</name></expr>:</case>
			<return>return <expr><call><name>get_matching_range_bounds</name><argument_list>(<argument><expr><name>context</name></expr></argument>,
											 <argument><expr><name><name>opstep</name><operator>-&gt;</operator><name>opstrategy</name></name></expr></argument>,
											 <argument><expr><name>values</name></expr></argument>, <argument><expr><name>nvalues</name></expr></argument>,
											 <argument><expr><name>partsupfunc</name></expr></argument>,
											 <argument><expr><name><name>opstep</name><operator>-&gt;</operator><name>nullkeys</name></name></expr></argument>)</argument_list></call></expr>;</return>

		<default>default:</default>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unexpected partition strategy: %d"</literal></expr></argument>,
				 <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name><name>context</name><operator>-&gt;</operator><name>strategy</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
	</block_content>}</block></switch>

	<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * perform_pruning_combine_step
 *		Determines the indexes of datums obtained by combining those given
 *		by the steps identified by cstep-&gt;source_stepids using the specified
 *		combination method
 *
 * Since cstep may refer to the result of earlier steps, we also receive
 * step_results here.
 */</comment>
<function><type><specifier>static</specifier> <name>PruneStepResult</name> <modifier>*</modifier></type>
<name>perform_pruning_combine_step</name><parameter_list>(<parameter><decl><type><name>PartitionPruneContext</name> <modifier>*</modifier></type><name>context</name></decl></parameter>,
							 <parameter><decl><type><name>PartitionPruneStepCombine</name> <modifier>*</modifier></type><name>cstep</name></decl></parameter>,
							 <parameter><decl><type><name>PruneStepResult</name> <modifier>*</modifier><modifier>*</modifier></type><name>step_results</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc1</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PruneStepResult</name> <modifier>*</modifier></type><name>result</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>firststep</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * A combine step without any source steps is an indication to not perform
	 * any partition pruning.  Return all datum indexes in that case.
	 */</comment>
	<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>PruneStepResult</name> <operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>PruneStepResult</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>cstep</name><operator>-&gt;</operator><name>source_stepids</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>PartitionBoundInfo</name></type> <name>boundinfo</name> <init>= <expr><name><name>context</name><operator>-&gt;</operator><name>boundinfo</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>rangemax</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * Add all valid offsets into the boundinfo-&gt;indexes array.  For range
		 * partitioning, boundinfo-&gt;indexes contains (boundinfo-&gt;ndatums + 1)
		 * valid entries; otherwise there are boundinfo-&gt;ndatums.
		 */</comment>
		<expr_stmt><expr><name>rangemax</name> <operator>=</operator> <ternary><condition><expr><name><name>context</name><operator>-&gt;</operator><name>strategy</name></name> <operator>==</operator> <name>PARTITION_STRATEGY_RANGE</name></expr> ?</condition><then>
			<expr><name><name>boundinfo</name><operator>-&gt;</operator><name>ndatums</name></name></expr> </then><else>: <expr><name><name>boundinfo</name><operator>-&gt;</operator><name>ndatums</name></name> <operator>-</operator> <literal type="number">1</literal></expr></else></ternary></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>bound_offsets</name></name> <operator>=</operator>
			<call><name>bms_add_range</name><argument_list>(<argument><expr><name><name>result</name><operator>-&gt;</operator><name>bound_offsets</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>rangemax</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>scan_default</name></name> <operator>=</operator> <call><name>partition_bound_has_default</name><argument_list>(<argument><expr><name>boundinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>scan_null</name></name> <operator>=</operator> <call><name>partition_bound_accepts_nulls</name><argument_list>(<argument><expr><name>boundinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>result</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<switch>switch <condition>(<expr><name><name>cstep</name><operator>-&gt;</operator><name>combineOp</name></name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>PARTPRUNE_COMBINE_UNION</name></expr>:</case>
			<macro><name>foreach</name><argument_list>(<argument>lc1</argument>, <argument>cstep-&gt;source_stepids</argument>)</argument_list></macro>
			<block>{<block_content>
				<decl_stmt><decl><type><name>int</name></type>			<name>step_id</name> <init>= <expr><call><name>lfirst_int</name><argument_list>(<argument><expr><name>lc1</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>PruneStepResult</name> <modifier>*</modifier></type><name>step_result</name></decl>;</decl_stmt>

				<comment type="block">/*
				 * step_results[step_id] must contain a valid result, which is
				 * confirmed by the fact that cstep's step_id is greater than
				 * step_id and the fact that results of the individual steps
				 * are evaluated in sequence of their step_ids.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><name>step_id</name> <operator>&gt;=</operator> <name><name>cstep</name><operator>-&gt;</operator><name>step</name><operator>.</operator><name>step_id</name></name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"invalid pruning combine step argument"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<expr_stmt><expr><name>step_result</name> <operator>=</operator> <name><name>step_results</name><index>[<expr><name>step_id</name></expr>]</index></name></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>step_result</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/* Record any additional datum indexes from this step */</comment>
				<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>bound_offsets</name></name> <operator>=</operator> <call><name>bms_add_members</name><argument_list>(<argument><expr><name><name>result</name><operator>-&gt;</operator><name>bound_offsets</name></name></expr></argument>,
														<argument><expr><name><name>step_result</name><operator>-&gt;</operator><name>bound_offsets</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/* Update whether to scan null and default partitions. */</comment>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>result</name><operator>-&gt;</operator><name>scan_null</name></name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>scan_null</name></name> <operator>=</operator> <name><name>step_result</name><operator>-&gt;</operator><name>scan_null</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>result</name><operator>-&gt;</operator><name>scan_default</name></name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>scan_default</name></name> <operator>=</operator> <name><name>step_result</name><operator>-&gt;</operator><name>scan_default</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block>
			<break>break;</break>

		<case>case <expr><name>PARTPRUNE_COMBINE_INTERSECT</name></expr>:</case>
			<expr_stmt><expr><name>firststep</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<macro><name>foreach</name><argument_list>(<argument>lc1</argument>, <argument>cstep-&gt;source_stepids</argument>)</argument_list></macro>
			<block>{<block_content>
				<decl_stmt><decl><type><name>int</name></type>			<name>step_id</name> <init>= <expr><call><name>lfirst_int</name><argument_list>(<argument><expr><name>lc1</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>PruneStepResult</name> <modifier>*</modifier></type><name>step_result</name></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><name>step_id</name> <operator>&gt;=</operator> <name><name>cstep</name><operator>-&gt;</operator><name>step</name><operator>.</operator><name>step_id</name></name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"invalid pruning combine step argument"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<expr_stmt><expr><name>step_result</name> <operator>=</operator> <name><name>step_results</name><index>[<expr><name>step_id</name></expr>]</index></name></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>step_result</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<if_stmt><if>if <condition>(<expr><name>firststep</name></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/* Copy step's result the first time. */</comment>
					<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>bound_offsets</name></name> <operator>=</operator>
						<call><name>bms_copy</name><argument_list>(<argument><expr><name><name>step_result</name><operator>-&gt;</operator><name>bound_offsets</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>scan_null</name></name> <operator>=</operator> <name><name>step_result</name><operator>-&gt;</operator><name>scan_null</name></name></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>scan_default</name></name> <operator>=</operator> <name><name>step_result</name><operator>-&gt;</operator><name>scan_default</name></name></expr>;</expr_stmt>
					<expr_stmt><expr><name>firststep</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
				</block_content>}</block></if>
				<else>else
				<block>{<block_content>
					<comment type="block">/* Record datum indexes common to both steps */</comment>
					<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>bound_offsets</name></name> <operator>=</operator>
						<call><name>bms_int_members</name><argument_list>(<argument><expr><name><name>result</name><operator>-&gt;</operator><name>bound_offsets</name></name></expr></argument>,
										<argument><expr><name><name>step_result</name><operator>-&gt;</operator><name>bound_offsets</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<comment type="block">/* Update whether to scan null and default partitions. */</comment>
					<if_stmt><if>if <condition>(<expr><name><name>result</name><operator>-&gt;</operator><name>scan_null</name></name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>scan_null</name></name> <operator>=</operator> <name><name>step_result</name><operator>-&gt;</operator><name>scan_null</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
					<if_stmt><if>if <condition>(<expr><name><name>result</name><operator>-&gt;</operator><name>scan_default</name></name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>scan_default</name></name> <operator>=</operator> <name><name>step_result</name><operator>-&gt;</operator><name>scan_default</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
				</block_content>}</block></else></if_stmt>
			</block_content>}</block>
			<break>break;</break>
	</block_content>}</block></switch>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * match_boolean_partition_clause
 *
 * If we're able to match the clause to the partition key as specially-shaped
 * boolean clause, set *outconst to a Const containing a true or false value
 * and return PARTCLAUSE_MATCH_CLAUSE.  Returns PARTCLAUSE_UNSUPPORTED if the
 * clause is not a boolean clause or if the boolean clause is unsuitable for
 * partition pruning.  Returns PARTCLAUSE_NOMATCH if it's a bool quals but
 * just does not match this partition key.  *outconst is set to NULL in the
 * latter two cases.
 */</comment>
<function><type><specifier>static</specifier> <name>PartClauseMatchStatus</name></type>
<name>match_boolean_partition_clause</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>partopfamily</name></decl></parameter>, <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>clause</name></decl></parameter>, <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>partkey</name></decl></parameter>,
							   <parameter><decl><type><name>Expr</name> <modifier>*</modifier><modifier>*</modifier></type><name>outconst</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Expr</name>	   <modifier>*</modifier></type><name>leftop</name></decl>;</decl_stmt>

	<expr_stmt><expr><operator>*</operator><name>outconst</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsBooleanOpfamily</name><argument_list>(<argument><expr><name>partopfamily</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>PARTCLAUSE_UNSUPPORTED</name></expr>;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>clause</name></expr></argument>, <argument><expr><name>BooleanTest</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>BooleanTest</name> <modifier>*</modifier></type><name>btest</name> <init>= <expr><operator>(</operator><name>BooleanTest</name> <operator>*</operator><operator>)</operator> <name>clause</name></expr></init></decl>;</decl_stmt>

		<comment type="block">/* Only IS [NOT] TRUE/FALSE are any good to us */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>btest</name><operator>-&gt;</operator><name>booltesttype</name></name> <operator>==</operator> <name>IS_UNKNOWN</name> <operator>||</operator>
			<name><name>btest</name><operator>-&gt;</operator><name>booltesttype</name></name> <operator>==</operator> <name>IS_NOT_UNKNOWN</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>PARTCLAUSE_UNSUPPORTED</name></expr>;</return></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>leftop</name> <operator>=</operator> <name><name>btest</name><operator>-&gt;</operator><name>arg</name></name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>leftop</name></expr></argument>, <argument><expr><name>RelabelType</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>leftop</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>RelabelType</name> <operator>*</operator><operator>)</operator> <name>leftop</name><operator>)</operator><operator>-&gt;</operator><name>arg</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>equal</name><argument_list>(<argument><expr><name>leftop</name></expr></argument>, <argument><expr><name>partkey</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><operator>*</operator><name>outconst</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name><name>btest</name><operator>-&gt;</operator><name>booltesttype</name></name> <operator>==</operator> <name>IS_TRUE</name> <operator>||</operator>
						 <name><name>btest</name><operator>-&gt;</operator><name>booltesttype</name></name> <operator>==</operator> <name>IS_NOT_FALSE</name><operator>)</operator></expr>
				?</condition><then> <expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <call><name>makeBoolConst</name><argument_list>(<argument><expr><name>true</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>
				</then><else>: <expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <call><name>makeBoolConst</name><argument_list>(<argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></else></ternary></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><operator>*</operator><name>outconst</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>PARTCLAUSE_MATCH_CLAUSE</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<decl_stmt><decl><type><name>bool</name></type>		<name>is_not_clause</name> <init>= <expr><call><name>not_clause</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>clause</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>leftop</name> <operator>=</operator> <ternary><condition><expr><name>is_not_clause</name></expr> ?</condition><then> <expr><call><name>get_notclausearg</name><argument_list>(<argument><expr><name>clause</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><name>clause</name></expr></else></ternary></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>leftop</name></expr></argument>, <argument><expr><name>RelabelType</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>leftop</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>RelabelType</name> <operator>*</operator><operator>)</operator> <name>leftop</name><operator>)</operator><operator>-&gt;</operator><name>arg</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/* Compare to the partition key, and make up a clause ... */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>equal</name><argument_list>(<argument><expr><name>leftop</name></expr></argument>, <argument><expr><name>partkey</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><operator>*</operator><name>outconst</name> <operator>=</operator> <ternary><condition><expr><name>is_not_clause</name></expr> ?</condition><then>
				<expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <call><name>makeBoolConst</name><argument_list>(<argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr> </then><else>:
				<expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <call><name>makeBoolConst</name><argument_list>(<argument><expr><name>true</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></else></ternary></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><call><name>equal</name><argument_list>(<argument><expr><call><name>negate_clause</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>leftop</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>partkey</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><operator>*</operator><name>outconst</name> <operator>=</operator> <operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <call><name>makeBoolConst</name><argument_list>(<argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><operator>*</operator><name>outconst</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>PARTCLAUSE_MATCH_CLAUSE</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></else></if_stmt>

	<return>return <expr><name>PARTCLAUSE_NOMATCH</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * partkey_datum_from_expr
 *		Evaluate expression for potential partition pruning
 *
 * Evaluate 'expr'; set *value and *isnull to the resulting Datum and nullflag.
 *
 * If expr isn't a Const, its ExprState is in stateidx of the context
 * exprstate array.
 *
 * Note that the evaluated result may be in the per-tuple memory context of
 * context-&gt;planstate-&gt;ps_ExprContext, and we may have leaked other memory
 * there too.  This memory must be recovered by resetting that ExprContext
 * after we're done with the pruning operation (see execPartition.c).
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>partkey_datum_from_expr</name><parameter_list>(<parameter><decl><type><name>PartitionPruneContext</name> <modifier>*</modifier></type><name>context</name></decl></parameter>,
						<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>expr</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>stateidx</name></decl></parameter>,
						<parameter><decl><type><name>Datum</name> <modifier>*</modifier></type><name>value</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>isnull</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>expr</name></expr></argument>, <argument><expr><name>Const</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* We can always determine the value of a constant */</comment>
		<decl_stmt><decl><type><name>Const</name>	   <modifier>*</modifier></type><name>con</name> <init>= <expr><operator>(</operator><name>Const</name> <operator>*</operator><operator>)</operator> <name>expr</name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><operator>*</operator><name>value</name> <operator>=</operator> <name><name>con</name><operator>-&gt;</operator><name>constvalue</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><operator>*</operator><name>isnull</name> <operator>=</operator> <name><name>con</name><operator>-&gt;</operator><name>constisnull</name></name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<decl_stmt><decl><type><name>ExprState</name>  <modifier>*</modifier></type><name>exprstate</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ExprContext</name> <modifier>*</modifier></type><name>ectx</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * We should never see a non-Const in a step unless we're running in
		 * the executor.
		 */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>context</name><operator>-&gt;</operator><name>planstate</name></name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>exprstate</name> <operator>=</operator> <name><name>context</name><operator>-&gt;</operator><name>exprstates</name><index>[<expr><name>stateidx</name></expr>]</index></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>ectx</name> <operator>=</operator> <name><name>context</name><operator>-&gt;</operator><name>planstate</name><operator>-&gt;</operator><name>ps_ExprContext</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><operator>*</operator><name>value</name> <operator>=</operator> <call><name>ExecEvalExprSwitchContext</name><argument_list>(<argument><expr><name>exprstate</name></expr></argument>, <argument><expr><name>ectx</name></expr></argument>, <argument><expr><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>
</unit>
