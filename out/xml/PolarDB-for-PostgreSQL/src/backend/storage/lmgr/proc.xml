<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/PolarDB-for-PostgreSQL/src/backend/storage/lmgr/proc.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * proc.c
 *	  routines to manage per-process shared memory data structure
 *
 * Portions Copyright (c) 1996-2018, PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, Regents of the University of California
 *
 *
 * IDENTIFICATION
 *	  src/backend/storage/lmgr/proc.c
 *
 *-------------------------------------------------------------------------
 */</comment>
<comment type="block">/*
 * Interface (a):
 *		ProcSleep(), ProcWakeup(),
 *		ProcQueueAlloc() -- create a shm queue for sleeping processes
 *		ProcQueueInit() -- create a queue without allocing memory
 *
 * Waiting for a lock causes the backend to be put to sleep.  Whoever releases
 * the lock wakes the process up again (and gives it an error code so it knows
 * whether it was awoken on an error condition).
 *
 * Interface (b):
 *
 * ProcReleaseLocks -- frees the locks associated with current transaction
 *
 * ProcKill -- destroys the shared memory state (and locks)
 * associated with the process.
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;signal.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;unistd.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/time.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/transam.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/twophase.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/xact.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pgstat.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postmaster/autovacuum.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"replication/slot.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"replication/syncrep.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/condition_variable.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/standby.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/ipc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/lmgr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/pmsignal.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/proc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/procarray.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/procsignal.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/spin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/timeout.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/timestamp.h"</cpp:file></cpp:include>
<comment type="block">/* POLAR */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"replication/walsender.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"polar_dma/polar_dma.h"</cpp:file></cpp:include>

<comment type="block">/* POLAR px */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"px/px_timeout.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"px/px_vars.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/hash.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postmaster/postmaster.h"</cpp:file></cpp:include>

<comment type="block">/* GUC variables */</comment>
<decl_stmt><decl><type><name>int</name></type>			<name>DeadlockTimeout</name> <init>= <expr><literal type="number">1000</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type>			<name>StatementTimeout</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type>			<name>LockTimeout</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type>			<name>IdleInTransactionSessionTimeout</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type>		<name>log_lock_waits</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

<comment type="block">/* Pointer to this process's PGPROC and PGXACT structs, if any */</comment>
<decl_stmt><decl><type><name>PGPROC</name>	   <modifier>*</modifier></type><name>MyProc</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PGXACT</name>	   <modifier>*</modifier></type><name>MyPgXact</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<comment type="block">/*
 * This spinlock protects the freelist of recycled PGPROC structures.
 * We cannot use an LWLock because the LWLock manager depends on already
 * having a PGPROC and a wait semaphore!  But these structures are touched
 * relatively infrequently (only at backend startup or shutdown) and not for
 * very long, so a spinlock is okay.
 */</comment>
<decl_stmt><decl><type><name>NON_EXEC_STATIC</name> <name>slock_t</name> <modifier>*</modifier></type><name>ProcStructLock</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<comment type="block">/* Pointers to shared-memory structures */</comment>
<decl_stmt><decl><type><name>PROC_HDR</name>   <modifier>*</modifier></type><name>ProcGlobal</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>NON_EXEC_STATIC</name> <name>PGPROC</name> <modifier>*</modifier></type><name>AuxiliaryProcs</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PGPROC</name>	   <modifier>*</modifier></type><name>PreparedXactProcs</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<comment type="block">/* If we are waiting for a lock, this points to the associated LOCALLOCK */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>LOCALLOCK</name> <modifier>*</modifier></type><name>lockAwaited</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>DeadLockState</name></type> <name>deadlock_state</name> <init>= <expr><name>DS_NOT_YET_CHECKED</name></expr></init></decl>;</decl_stmt>

<comment type="block">/* Is a deadlock check pending? */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>volatile</specifier> <name>sig_atomic_t</name></type> <name>got_deadlock_timeout</name></decl>;</decl_stmt>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>RemoveProcFromArray</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>code</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>arg</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ProcKill</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>code</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>arg</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>AuxiliaryProcKill</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>code</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>arg</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>CheckDeadLock</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/* POLAR px */</comment>
<function_decl><type><specifier>static</specifier> <name>void</name></type>	<name>InitTraceId</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>uint32</name></type> <name>ip_hash</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>uint16</name></type> <name>port</name></decl></parameter>)</parameter_list>;</function_decl>


<comment type="block">/*
 * Report shared-memory space needed by InitProcGlobal.
 */</comment>
<function><type><name>Size</name></type>
<name>ProcGlobalShmemSize</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Size</name></type>		<name>size</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<comment type="block">/* ProcGlobal */</comment>
	<expr_stmt><expr><name>size</name> <operator>=</operator> <call><name>add_size</name><argument_list>(<argument><expr><name>size</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>PROC_HDR</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* MyProcs, including autovacuum workers and launcher */</comment>
	<expr_stmt><expr><name>size</name> <operator>=</operator> <call><name>add_size</name><argument_list>(<argument><expr><name>size</name></expr></argument>, <argument><expr><call><name>mul_size</name><argument_list>(<argument><expr><name>MaxBackends</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>PGPROC</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* AuxiliaryProcs */</comment>
	<expr_stmt><expr><name>size</name> <operator>=</operator> <call><name>add_size</name><argument_list>(<argument><expr><name>size</name></expr></argument>, <argument><expr><call><name>mul_size</name><argument_list>(<argument><expr><name>NUM_AUXILIARY_PROCS</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>PGPROC</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* Prepared xacts */</comment>
	<expr_stmt><expr><name>size</name> <operator>=</operator> <call><name>add_size</name><argument_list>(<argument><expr><name>size</name></expr></argument>, <argument><expr><call><name>mul_size</name><argument_list>(<argument><expr><name>max_prepared_xacts</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>PGPROC</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* ProcStructLock */</comment>
	<expr_stmt><expr><name>size</name> <operator>=</operator> <call><name>add_size</name><argument_list>(<argument><expr><name>size</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>slock_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>size</name> <operator>=</operator> <call><name>add_size</name><argument_list>(<argument><expr><name>size</name></expr></argument>, <argument><expr><call><name>mul_size</name><argument_list>(<argument><expr><name>MaxBackends</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>PGXACT</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>size</name> <operator>=</operator> <call><name>add_size</name><argument_list>(<argument><expr><name>size</name></expr></argument>, <argument><expr><call><name>mul_size</name><argument_list>(<argument><expr><name>NUM_AUXILIARY_PROCS</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>PGXACT</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>size</name> <operator>=</operator> <call><name>add_size</name><argument_list>(<argument><expr><name>size</name></expr></argument>, <argument><expr><call><name>mul_size</name><argument_list>(<argument><expr><name>max_prepared_xacts</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>PGXACT</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>size</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Report number of semaphores needed by InitProcGlobal.
 */</comment>
<function><type><name>int</name></type>
<name>ProcGlobalSemas</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * We need a sema per backend (including autovacuum), plus one for each
	 * auxiliary process.
	 */</comment>
	<return>return <expr><name>MaxBackends</name> <operator>+</operator> <name>NUM_AUXILIARY_PROCS</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * InitProcGlobal -
 *	  Initialize the global process table during postmaster or standalone
 *	  backend startup.
 *
 *	  We also create all the per-process semaphores we will need to support
 *	  the requested number of backends.  We used to allocate semaphores
 *	  only when backends were actually started up, but that is bad because
 *	  it lets Postgres fail under load --- a lot of Unix systems are
 *	  (mis)configured with small limits on the number of semaphores, and
 *	  running out when trying to start another backend is a common failure.
 *	  So, now we grab enough semaphores to support the desired max number
 *	  of backends immediately at initialization --- if the sysadmin has set
 *	  MaxConnections, max_worker_processes, or autovacuum_max_workers higher
 *	  than his kernel will support, he'll find out sooner rather than later.
 *
 *	  Another reason for creating semaphores here is that the semaphore
 *	  implementation typically requires us to create semaphores in the
 *	  postmaster, not in backends.
 *
 * Note: this is NOT called by individual backends under a postmaster,
 * not even in the EXEC_BACKEND case.  The ProcGlobal and AuxiliaryProcs
 * pointers must be propagated specially for EXEC_BACKEND operation.
 */</comment>
<function><type><name>void</name></type>
<name>InitProcGlobal</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PGPROC</name>	   <modifier>*</modifier></type><name>procs</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PGXACT</name>	   <modifier>*</modifier></type><name>pgxacts</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>,
				<decl><type ref="prev"/><name>j</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>found</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32</name></type>		<name>TotalProcs</name> <init>= <expr><name>MaxBackends</name> <operator>+</operator> <name>NUM_AUXILIARY_PROCS</name> <operator>+</operator> <name>max_prepared_xacts</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* Create the ProcGlobal shared structure */</comment>
	<expr_stmt><expr><name>ProcGlobal</name> <operator>=</operator> <operator>(</operator><name>PROC_HDR</name> <operator>*</operator><operator>)</operator>
		<call><name>ShmemInitStruct</name><argument_list>(<argument><expr><literal type="string">"Proc Header"</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>PROC_HDR</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><operator>&amp;</operator><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Initialize the data structures.
	 */</comment>
	<expr_stmt><expr><name><name>ProcGlobal</name><operator>-&gt;</operator><name>spins_per_delay</name></name> <operator>=</operator> <name>DEFAULT_SPINS_PER_DELAY</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ProcGlobal</name><operator>-&gt;</operator><name>freeProcs</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ProcGlobal</name><operator>-&gt;</operator><name>autovacFreeProcs</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ProcGlobal</name><operator>-&gt;</operator><name>bgworkerFreeProcs</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ProcGlobal</name><operator>-&gt;</operator><name>startupProc</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ProcGlobal</name><operator>-&gt;</operator><name>startupProcPid</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ProcGlobal</name><operator>-&gt;</operator><name>startupBufferPinWaitBufId</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ProcGlobal</name><operator>-&gt;</operator><name>walwriterLatch</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ProcGlobal</name><operator>-&gt;</operator><name>checkpointerLatch</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pg_atomic_init_u32</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ProcGlobal</name><operator>-&gt;</operator><name>procArrayGroupFirst</name></name></expr></argument>, <argument><expr><name>INVALID_PGPROCNO</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pg_atomic_init_u32</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ProcGlobal</name><operator>-&gt;</operator><name>clogGroupFirst</name></name></expr></argument>, <argument><expr><name>INVALID_PGPROCNO</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* POLAR px */</comment>
	<expr_stmt><expr><call><name>pg_atomic_init_u32</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ProcGlobal</name><operator>-&gt;</operator><name>pxSessionCounter</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pg_atomic_init_u32</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ProcGlobal</name><operator>-&gt;</operator><name>pxWorkerCounter</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pg_atomic_init_u32</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ProcGlobal</name><operator>-&gt;</operator><name>sqlRequestCounter</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* POLAR wal pipeline */</comment>
	<expr_stmt><expr><name><name>ProcGlobal</name><operator>-&gt;</operator><name>polar_wal_pipeliner_latch</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Create and initialize all the PGPROC structures we'll need.  There are
	 * five separate consumers: (1) normal backends, (2) autovacuum workers
	 * and the autovacuum launcher, (3) background workers, (4) auxiliary
	 * processes, and (5) prepared transactions.  Each PGPROC structure is
	 * dedicated to exactly one of these purposes, and they do not move
	 * between groups.
	 */</comment>
	<expr_stmt><expr><name>procs</name> <operator>=</operator> <operator>(</operator><name>PGPROC</name> <operator>*</operator><operator>)</operator> <call><name>ShmemAlloc</name><argument_list>(<argument><expr><name>TotalProcs</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>PGPROC</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><name>procs</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TotalProcs</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>PGPROC</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ProcGlobal</name><operator>-&gt;</operator><name>allProcs</name></name> <operator>=</operator> <name>procs</name></expr>;</expr_stmt>
	<comment type="block">/* XXX allProcCount isn't really all of them; it excludes prepared xacts */</comment>
	<expr_stmt><expr><name><name>ProcGlobal</name><operator>-&gt;</operator><name>allProcCount</name></name> <operator>=</operator> <name>MaxBackends</name> <operator>+</operator> <name>NUM_AUXILIARY_PROCS</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Also allocate a separate array of PGXACT structures.  This is separate
	 * from the main PGPROC array so that the most heavily accessed data is
	 * stored contiguously in memory in as few cache lines as possible. This
	 * provides significant performance benefits, especially on a
	 * multiprocessor system.  There is one PGXACT structure for every PGPROC
	 * structure.
	 */</comment>
	<expr_stmt><expr><name>pgxacts</name> <operator>=</operator> <operator>(</operator><name>PGXACT</name> <operator>*</operator><operator>)</operator> <call><name>ShmemAlloc</name><argument_list>(<argument><expr><name>TotalProcs</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>PGXACT</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><name>pgxacts</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TotalProcs</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>PGXACT</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ProcGlobal</name><operator>-&gt;</operator><name>allPgXact</name></name> <operator>=</operator> <name>pgxacts</name></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>TotalProcs</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<comment type="block">/* Common initialization for all PGPROCs, regardless of type. */</comment>

		<comment type="block">/*
		 * Set up per-PGPROC semaphore, latch, and backendLock. Prepared xact
		 * dummy PGPROCs don't need these though - they're never associated
		 * with a real process
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>i</name> <operator>&lt;</operator> <name>MaxBackends</name> <operator>+</operator> <name>NUM_AUXILIARY_PROCS</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>procs</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>sem</name> <operator>=</operator> <call><name>PGSemaphoreCreate</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>InitSharedLatch</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>procs</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>procLatch</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>LWLockInitialize</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>procs</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>backendLock</name><operator>)</operator></expr></argument>, <argument><expr><name>LWTRANCHE_PROC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><name><name>procs</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>pgprocno</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>

		<comment type="block">/*
		 * Newly created PGPROCs for normal backends, autovacuum and bgworkers
		 * must be queued up on the appropriate free list.  Because there can
		 * only ever be a small, fixed number of auxiliary processes, no free
		 * list is used in that case; InitAuxiliaryProcess() instead uses a
		 * linear search.   PGPROCs for prepared transactions are added to a
		 * free list by TwoPhaseShmemInit().
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>i</name> <operator>&lt;</operator> <name>MaxConnections</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* PGPROC for normal backend, add to freeProcs list */</comment>
			<expr_stmt><expr><name><name>procs</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>links</name><operator>.</operator><name>next</name></name> <operator>=</operator> <operator>(</operator><name>SHM_QUEUE</name> <operator>*</operator><operator>)</operator> <name><name>ProcGlobal</name><operator>-&gt;</operator><name>freeProcs</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>ProcGlobal</name><operator>-&gt;</operator><name>freeProcs</name></name> <operator>=</operator> <operator>&amp;</operator><name><name>procs</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>procs</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>procgloballist</name> <operator>=</operator> <operator>&amp;</operator><name><name>ProcGlobal</name><operator>-&gt;</operator><name>freeProcs</name></name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name>i</name> <operator>&lt;</operator> <name>MaxConnections</name> <operator>+</operator> <name>autovacuum_max_workers</name> <operator>+</operator> <literal type="number">1</literal></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* PGPROC for AV launcher/worker, add to autovacFreeProcs list */</comment>
			<expr_stmt><expr><name><name>procs</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>links</name><operator>.</operator><name>next</name></name> <operator>=</operator> <operator>(</operator><name>SHM_QUEUE</name> <operator>*</operator><operator>)</operator> <name><name>ProcGlobal</name><operator>-&gt;</operator><name>autovacFreeProcs</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>ProcGlobal</name><operator>-&gt;</operator><name>autovacFreeProcs</name></name> <operator>=</operator> <operator>&amp;</operator><name><name>procs</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>procs</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>procgloballist</name> <operator>=</operator> <operator>&amp;</operator><name><name>ProcGlobal</name><operator>-&gt;</operator><name>autovacFreeProcs</name></name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name>i</name> <operator>&lt;</operator> <name>MaxBackends</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* PGPROC for bgworker, add to bgworkerFreeProcs list */</comment>
			<expr_stmt><expr><name><name>procs</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>links</name><operator>.</operator><name>next</name></name> <operator>=</operator> <operator>(</operator><name>SHM_QUEUE</name> <operator>*</operator><operator>)</operator> <name><name>ProcGlobal</name><operator>-&gt;</operator><name>bgworkerFreeProcs</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>ProcGlobal</name><operator>-&gt;</operator><name>bgworkerFreeProcs</name></name> <operator>=</operator> <operator>&amp;</operator><name><name>procs</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>procs</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>procgloballist</name> <operator>=</operator> <operator>&amp;</operator><name><name>ProcGlobal</name><operator>-&gt;</operator><name>bgworkerFreeProcs</name></name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* Initialize myProcLocks[] shared memory queues. */</comment>
		<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>NUM_LOCK_PARTITIONS</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>SHMQueueInit</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>procs</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>myProcLocks</name><index>[<expr><name>j</name></expr>]</index></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>

		<comment type="block">/* Initialize lockGroupMembers list. */</comment>
		<expr_stmt><expr><call><name>dlist_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>procs</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>lockGroupMembers</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Initialize the atomic variables, otherwise, it won't be safe to
		 * access them for backends that aren't currently in use.
		 */</comment>
		<expr_stmt><expr><call><name>pg_atomic_init_u32</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>procs</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>procArrayGroupNext</name><operator>)</operator></expr></argument>, <argument><expr><name>INVALID_PGPROCNO</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pg_atomic_init_u32</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>procs</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>clogGroupNext</name><operator>)</operator></expr></argument>, <argument><expr><name>INVALID_PGPROCNO</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<comment type="block">/*
	 * Save pointers to the blocks of PGPROC structures reserved for auxiliary
	 * processes and prepared transactions.
	 */</comment>
	<expr_stmt><expr><name>AuxiliaryProcs</name> <operator>=</operator> <operator>&amp;</operator><name><name>procs</name><index>[<expr><name>MaxBackends</name></expr>]</index></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>PreparedXactProcs</name> <operator>=</operator> <operator>&amp;</operator><name><name>procs</name><index>[<expr><name>MaxBackends</name> <operator>+</operator> <name>NUM_AUXILIARY_PROCS</name></expr>]</index></name></expr>;</expr_stmt>

	<comment type="block">/* Create ProcStructLock spinlock, too */</comment>
	<expr_stmt><expr><name>ProcStructLock</name> <operator>=</operator> <operator>(</operator><name>slock_t</name> <operator>*</operator><operator>)</operator> <call><name>ShmemAlloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>slock_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SpinLockInit</name><argument_list>(<argument><expr><name>ProcStructLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* POLAR px */</comment>
<function><type><specifier>static</specifier>
<name>void</name></type> <name>InitTraceId</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>uint32</name></type> <name>ip_hash</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>uint16</name></type> <name>port</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><name><name>sql_trace_id</name><operator>.</operator><name>ip_hash</name></name> <operator>=</operator> <name>ip_hash</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>sql_trace_id</name><operator>.</operator><name>port</name></name> <operator>=</operator> <name>port</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>sql_trace_id</name><operator>.</operator><name>seq</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * InitProcess -- initialize a per-process data structure for this backend
 */</comment>
<function><type><name>void</name></type>
<name>InitProcess</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PGPROC</name>	   <modifier>*</modifier><specifier>volatile</specifier> <modifier>*</modifier></type><name>procgloballist</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> 		<name>pxLocalSessionId</name></decl>;</decl_stmt>  	<comment type="block">/* this backend's PGPROC serial num */</comment>
	<decl_stmt><decl><type><name>uint32</name></type> 		<name>ip_hash</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * ProcGlobal should be set up already (if we are a backend, we inherit
	 * this by fork() or EXEC_BACKEND mechanism from the postmaster).
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>ProcGlobal</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>PANIC</name></expr></argument>, <argument><expr><literal type="string">"proc header uninitialized"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>MyProc</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"you already exist"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Decide which list should supply our PGPROC. */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>IsAnyAutoVacuumProcess</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>procgloballist</name> <operator>=</operator> <operator>&amp;</operator><name><name>ProcGlobal</name><operator>-&gt;</operator><name>autovacFreeProcs</name></name></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><name>IsBackgroundWorker</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>procgloballist</name> <operator>=</operator> <operator>&amp;</operator><name><name>ProcGlobal</name><operator>-&gt;</operator><name>bgworkerFreeProcs</name></name></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>procgloballist</name> <operator>=</operator> <operator>&amp;</operator><name><name>ProcGlobal</name><operator>-&gt;</operator><name>freeProcs</name></name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/*
	 * Try to get a proc struct from the appropriate free list.  If this
	 * fails, we must be out of PGPROC structures (not to mention semaphores).
	 *
	 * While we are holding the ProcStructLock, also copy the current shared
	 * estimate of spins_per_delay to local storage.
	 */</comment>
	<expr_stmt><expr><call><name>SpinLockAcquire</name><argument_list>(<argument><expr><name>ProcStructLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>set_spins_per_delay</name><argument_list>(<argument><expr><name><name>ProcGlobal</name><operator>-&gt;</operator><name>spins_per_delay</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>MyProc</name> <operator>=</operator> <operator>*</operator><name>procgloballist</name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>MyProc</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><operator>*</operator><name>procgloballist</name> <operator>=</operator> <operator>(</operator><name>PGPROC</name> <operator>*</operator><operator>)</operator> <name><name>MyProc</name><operator>-&gt;</operator><name>links</name><operator>.</operator><name>next</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>SpinLockRelease</name><argument_list>(<argument><expr><name>ProcStructLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/*
		 * If we reach here, all the PGPROCs are in use.  This is one of the
		 * possible places to detect "too many backends", so give the standard
		 * error message.  XXX do we need to give a different failure message
		 * in the autovacuum case?
		 */</comment>
		<expr_stmt><expr><call><name>SpinLockRelease</name><argument_list>(<argument><expr><name>ProcStructLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_TOO_MANY_CONNECTIONS</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"sorry, too many clients already"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>LOCK_DEBUG</name></cpp:ifdef>
	<comment type="block">/* POLAR: PGPROC is part of PROCLOCK, we print MyProc previous pid to validate it's cleared */</comment>
	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"Alloc PRPROC %p for pid %d, and it's used by previous pid %d"</literal></expr></argument>, <argument><expr><name>MyProc</name></expr></argument>, <argument><expr><name>MyProcPid</name></expr></argument>, <argument><expr><name><name>MyProc</name><operator>-&gt;</operator><name>pid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<expr_stmt><expr><name>MyPgXact</name> <operator>=</operator> <operator>&amp;</operator><name><name>ProcGlobal</name><operator>-&gt;</operator><name>allPgXact</name><index>[<expr><name><name>MyProc</name><operator>-&gt;</operator><name>pgprocno</name></name></expr>]</index></name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Cross-check that the PGPROC is of the type we expect; if this were not
	 * the case, it would get returned to the wrong list.
	 */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>MyProc</name><operator>-&gt;</operator><name>procgloballist</name></name> <operator>==</operator> <name>procgloballist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Now that we have a PGPROC, mark ourselves as an active postmaster
	 * child; this is so that the postmaster can detect it if we exit without
	 * cleaning up.  (XXX autovac launcher currently doesn't participate in
	 * this; it probably should.)
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>IsUnderPostmaster</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>IsAutoVacuumLauncherProcess</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>MarkPostmasterChildActive</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Initialize all fields of MyProc, except for those previously
	 * initialized by InitProcGlobal.
	 */</comment>
	<expr_stmt><expr><call><name>SHMQueueElemInit</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>MyProc</name><operator>-&gt;</operator><name>links</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>MyProc</name><operator>-&gt;</operator><name>waitStatus</name></name> <operator>=</operator> <name>STATUS_OK</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>MyProc</name><operator>-&gt;</operator><name>lxid</name></name> <operator>=</operator> <name>InvalidLocalTransactionId</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>MyProc</name><operator>-&gt;</operator><name>fpVXIDLock</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>MyProc</name><operator>-&gt;</operator><name>fpLocalTransactionId</name></name> <operator>=</operator> <name>InvalidLocalTransactionId</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>MyPgXact</name><operator>-&gt;</operator><name>xid</name></name> <operator>=</operator> <name>InvalidTransactionId</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>MyPgXact</name><operator>-&gt;</operator><name>xmin</name></name> <operator>=</operator> <name>InvalidTransactionId</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>MyPgXact</name><operator>-&gt;</operator><name>polar_csn</name></name> <operator>=</operator> <name>InvalidCommitSeqNo</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>MyProc</name><operator>-&gt;</operator><name>pid</name></name> <operator>=</operator> <name>MyProcPid</name></expr>;</expr_stmt>
	<comment type="block">/* backendId, databaseId and roleId will be filled in later */</comment>
	<expr_stmt><expr><name><name>MyProc</name><operator>-&gt;</operator><name>backendId</name></name> <operator>=</operator> <name>InvalidBackendId</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>MyProc</name><operator>-&gt;</operator><name>databaseId</name></name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>MyProc</name><operator>-&gt;</operator><name>roleId</name></name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>MyProc</name><operator>-&gt;</operator><name>tempNamespaceId</name></name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>MyProc</name><operator>-&gt;</operator><name>isBackgroundWorker</name></name> <operator>=</operator> <name>IsBackgroundWorker</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>MyPgXact</name><operator>-&gt;</operator><name>delayChkpt</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>MyPgXact</name><operator>-&gt;</operator><name>vacuumFlags</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<comment type="block">/* NB -- autovac launcher intentionally does not set IS_AUTOVACUUM */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>IsAutoVacuumWorkerProcess</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>MyPgXact</name><operator>-&gt;</operator><name>vacuumFlags</name></name> <operator>|=</operator> <name>PROC_IS_AUTOVACUUM</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name><name>MyProc</name><operator>-&gt;</operator><name>lwWaiting</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>MyProc</name><operator>-&gt;</operator><name>lwWaitMode</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>MyProc</name><operator>-&gt;</operator><name>waitLock</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>MyProc</name><operator>-&gt;</operator><name>waitProcLock</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * POLAR px: initialize the PX execution status.
	 *           It is set to false by default.
	 */</comment>
	<expr_stmt><expr><call><name>pg_atomic_init_flag</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>MyProc</name><operator>-&gt;</operator><name>polar_px_is_executing</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>px_role</name> <operator>==</operator> <name>PX_ROLE_PX</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>pg_atomic_test_set_flag</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>MyProc</name><operator>-&gt;</operator><name>polar_px_is_executing</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt> <comment type="block">/* set to true */</comment>
	<comment type="block">/* POLAR end */</comment>

	<comment type="block">/* POLAR px */</comment>
	<expr_stmt><expr><name>ip_hash</name> <operator>=</operator> <call><name>DatumGetUInt32</name><argument_list>(<argument><expr><call><name>hash_any</name><argument_list>(
		<argument><expr><operator>(</operator><specifier>const</specifier> <name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator><name>ListenAddresses</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>ListenAddresses</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>InitTraceId</name><argument_list>(<argument><expr><name>ip_hash</name></expr></argument>, <argument><expr><operator>(</operator><name>uint16</name><operator>)</operator><name>PostPortNumber</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>pxLocalSessionId</name> <operator>=</operator> <call><name>pg_atomic_add_fetch_u32</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ProcGlobal</name><operator>-&gt;</operator><name>pxSessionCounter</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
	 * POLAR px
	 * A nonzero px_session_id uniquely identifies an PX client session
	 * over the lifetime of the entry postmaster process. A qDisp passes
	 * its px_session_id down to all of its qExecs. If this is a qExec,
	 * we have already received the px_session_id from the qDisp.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>px_role</name> <operator>==</operator> <name>PX_ROLE_QC</name> <operator>&amp;&amp;</operator> <name>px_session_id</name> <operator>==</operator> <name>InvalidPxSessionId</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>px_session_id</name> <operator>=</operator> <name>pxLocalSessionId</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>,<argument><expr><literal type="string">"InitProcess(): px_session_id %d, px_role %d"</literal></expr></argument>,<argument><expr><name>px_session_id</name></expr></argument>, <argument><expr><name>px_role</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* POLAR end */</comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_ASSERT_CHECKING</name></cpp:ifdef>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

		<comment type="block">/* Last process should have released all locks. */</comment>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>NUM_LOCK_PARTITIONS</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>SHMQueueEmpty</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>MyProc</name><operator>-&gt;</operator><name>myProcLocks</name><index>[<expr><name>i</name></expr>]</index></name><operator>)</operator></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
	</block_content>}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<expr_stmt><expr><name><name>MyProc</name><operator>-&gt;</operator><name>recoveryConflictPending</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<comment type="block">/* Initialize fields for sync rep */</comment>
	<expr_stmt><expr><name><name>MyProc</name><operator>-&gt;</operator><name>waitLSN</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>MyProc</name><operator>-&gt;</operator><name>syncRepState</name></name> <operator>=</operator> <name>SYNC_REP_NOT_WAITING</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SHMQueueElemInit</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>MyProc</name><operator>-&gt;</operator><name>syncRepLinks</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* POLAR: Initialize fields for read view min lsn*/</comment>
	<expr_stmt><expr><call><name>pg_atomic_init_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>MyProc</name><operator>-&gt;</operator><name>polar_read_min_lsn</name></name></expr></argument>, <argument><expr><name>InvalidXLogRecPtr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Initialize fields for consensus rep */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>POLAR_ENABLE_DMA</name><argument_list>()</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ConsensusProcInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>MyProc</name><operator>-&gt;</operator><name>consensusInfo</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Initialize fields for group XID clearing. */</comment>
	<expr_stmt><expr><name><name>MyProc</name><operator>-&gt;</operator><name>procArrayGroupMember</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>MyProc</name><operator>-&gt;</operator><name>procArrayGroupMemberXid</name></name> <operator>=</operator> <name>InvalidTransactionId</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>pg_atomic_read_u32</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>MyProc</name><operator>-&gt;</operator><name>procArrayGroupNext</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <name>INVALID_PGPROCNO</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Check that group locking fields are in a proper initial state. */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>MyProc</name><operator>-&gt;</operator><name>lockGroupLeader</name></name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>dlist_is_empty</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>MyProc</name><operator>-&gt;</operator><name>lockGroupMembers</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Initialize wait event information. */</comment>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type> 	<name>i</name></decl>;</decl_stmt>
		<expr_stmt><expr><name><name>MyProc</name><operator>-&gt;</operator><name>wait_event_info</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>PGPROC_WAIT_STACK_LEN</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<expr_stmt><expr><name><name>MyProc</name><operator>-&gt;</operator><name>wait_object</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>PGPROC_INVAILD_WAIT_OBJ</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>MyProc</name><operator>-&gt;</operator><name>wait_type</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>PGPROC_INVAILD_WAIT_OBJ</name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>INSTR_TIME_SET_ZERO</name><argument_list>(<argument><expr><name><name>MyProc</name><operator>-&gt;</operator><name>wait_time</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></for>
		<expr_stmt><expr><name><name>MyProc</name><operator>-&gt;</operator><name>cur_wait_stack_index</name></name> <operator>=</operator> <name>PGPROC_INVAILD_WAIT_OBJ</name></expr>;</expr_stmt>
	</block_content>}</block>

	<comment type="block">/* Initialize fields for group transaction status update. */</comment>
	<expr_stmt><expr><name><name>MyProc</name><operator>-&gt;</operator><name>clogGroupMember</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>MyProc</name><operator>-&gt;</operator><name>clogGroupMemberXid</name></name> <operator>=</operator> <name>InvalidTransactionId</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>MyProc</name><operator>-&gt;</operator><name>clogGroupMemberXidStatus</name></name> <operator>=</operator> <name>TRANSACTION_STATUS_IN_PROGRESS</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>MyProc</name><operator>-&gt;</operator><name>clogGroupMemberPage</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>MyProc</name><operator>-&gt;</operator><name>clogGroupMemberLsn</name></name> <operator>=</operator> <name>InvalidXLogRecPtr</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>pg_atomic_read_u32</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>MyProc</name><operator>-&gt;</operator><name>clogGroupNext</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <name>INVALID_PGPROCNO</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Acquire ownership of the PGPROC's latch, so that we can use WaitLatch
	 * on it.  That allows us to repoint the process latch, which so far
	 * points to process local one, to the shared one.
	 */</comment>
	<expr_stmt><expr><call><name>OwnLatch</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>MyProc</name><operator>-&gt;</operator><name>procLatch</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SwitchToSharedLatch</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * We might be reusing a semaphore that belonged to a failed process. So
	 * be careful and reinitialize its value here.  (This is not strictly
	 * necessary anymore, but seems like a good idea for cleanliness.)
	 */</comment>
	<expr_stmt><expr><call><name>PGSemaphoreReset</name><argument_list>(<argument><expr><name><name>MyProc</name><operator>-&gt;</operator><name>sem</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Arrange to clean up at backend exit.
	 */</comment>
	<expr_stmt><expr><call><name>on_shmem_exit</name><argument_list>(<argument><expr><name>ProcKill</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Now that we have a PGPROC, we could try to acquire locks, so initialize
	 * local state needed for LWLocks, and the deadlock checker.
	 */</comment>
	<expr_stmt><expr><call><name>InitLWLockAccess</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>InitDeadLockChecking</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* POLAR: init lock state */</comment>
	<expr_stmt><expr><call><name>polar_init_lock_access</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * InitProcessPhase2 -- make MyProc visible in the shared ProcArray.
 *
 * This is separate from InitProcess because we can't acquire LWLocks until
 * we've created a PGPROC, but in the EXEC_BACKEND case ProcArrayAdd won't
 * work until after we've done CreateSharedMemoryAndSemaphores.
 */</comment>
<function><type><name>void</name></type>
<name>InitProcessPhase2</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>MyProc</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Add our PGPROC to the PGPROC array in shared memory.
	 */</comment>
	<expr_stmt><expr><call><name>ProcArrayAdd</name><argument_list>(<argument><expr><name>MyProc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Arrange to clean that up at backend exit.
	 */</comment>
	<expr_stmt><expr><call><name>on_shmem_exit</name><argument_list>(<argument><expr><name>RemoveProcFromArray</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * InitAuxiliaryProcess -- create a per-auxiliary-process data structure
 *
 * This is called by bgwriter and similar processes so that they will have a
 * MyProc value that's real enough to let them wait for LWLocks.  The PGPROC
 * and sema that are assigned are one of the extra ones created during
 * InitProcGlobal.
 *
 * Auxiliary processes are presently not expected to wait for real (lockmgr)
 * locks, so we need not set up the deadlock checker.  They are never added
 * to the ProcArray or the sinval messaging mechanism, either.  They also
 * don't get a VXID assigned, since this is only useful when we actually
 * hold lockmgr locks.
 *
 * Startup process however uses locks but never waits for them in the
 * normal backend sense. Startup process also takes part in sinval messaging
 * as a sendOnly process, so never reads messages from sinval queue. So
 * Startup process does have a VXID and does show up in pg_locks.
 */</comment>
<function><type><name>void</name></type>
<name>InitAuxiliaryProcess</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PGPROC</name>	   <modifier>*</modifier></type><name>auxproc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>proctype</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * ProcGlobal should be set up already (if we are a backend, we inherit
	 * this by fork() or EXEC_BACKEND mechanism from the postmaster).
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>ProcGlobal</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name>AuxiliaryProcs</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>PANIC</name></expr></argument>, <argument><expr><literal type="string">"proc header uninitialized"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>MyProc</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"you already exist"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * We use the ProcStructLock to protect assignment and releasing of
	 * AuxiliaryProcs entries.
	 *
	 * While we are holding the ProcStructLock, also copy the current shared
	 * estimate of spins_per_delay to local storage.
	 */</comment>
	<expr_stmt><expr><call><name>SpinLockAcquire</name><argument_list>(<argument><expr><name>ProcStructLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>set_spins_per_delay</name><argument_list>(<argument><expr><name><name>ProcGlobal</name><operator>-&gt;</operator><name>spins_per_delay</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Find a free auxproc ... *big* trouble if there isn't one ...
	 */</comment>
	<for>for <control>(<init><expr><name>proctype</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>proctype</name> <operator>&lt;</operator> <name>NUM_AUXILIARY_PROCS</name></expr>;</condition> <incr><expr><name>proctype</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><name>auxproc</name> <operator>=</operator> <operator>&amp;</operator><name><name>AuxiliaryProcs</name><index>[<expr><name>proctype</name></expr>]</index></name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>auxproc</name><operator>-&gt;</operator><name>pid</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>
	</block_content>}</block></for>
	<if_stmt><if>if <condition>(<expr><name>proctype</name> <operator>&gt;=</operator> <name>NUM_AUXILIARY_PROCS</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>SpinLockRelease</name><argument_list>(<argument><expr><name>ProcStructLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>, <argument><expr><literal type="string">"all AuxiliaryProcs are in use"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Mark auxiliary proc as in use by me */</comment>
	<comment type="block">/* use volatile pointer to prevent code rearrangement */</comment>
	<expr_stmt><expr><operator>(</operator><operator>(</operator><specifier>volatile</specifier> <name>PGPROC</name> <operator>*</operator><operator>)</operator> <name>auxproc</name><operator>)</operator><operator>-&gt;</operator><name>pid</name> <operator>=</operator> <name>MyProcPid</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>MyProc</name> <operator>=</operator> <name>auxproc</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>MyPgXact</name> <operator>=</operator> <operator>&amp;</operator><name><name>ProcGlobal</name><operator>-&gt;</operator><name>allPgXact</name><index>[<expr><name><name>auxproc</name><operator>-&gt;</operator><name>pgprocno</name></name></expr>]</index></name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>SpinLockRelease</name><argument_list>(<argument><expr><name>ProcStructLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Initialize all fields of MyProc, except for those previously
	 * initialized by InitProcGlobal.
	 */</comment>
	<expr_stmt><expr><call><name>SHMQueueElemInit</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>MyProc</name><operator>-&gt;</operator><name>links</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>MyProc</name><operator>-&gt;</operator><name>waitStatus</name></name> <operator>=</operator> <name>STATUS_OK</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>MyProc</name><operator>-&gt;</operator><name>lxid</name></name> <operator>=</operator> <name>InvalidLocalTransactionId</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>MyProc</name><operator>-&gt;</operator><name>fpVXIDLock</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>MyProc</name><operator>-&gt;</operator><name>fpLocalTransactionId</name></name> <operator>=</operator> <name>InvalidLocalTransactionId</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>MyPgXact</name><operator>-&gt;</operator><name>xid</name></name> <operator>=</operator> <name>InvalidTransactionId</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>MyPgXact</name><operator>-&gt;</operator><name>xmin</name></name> <operator>=</operator> <name>InvalidTransactionId</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>MyPgXact</name><operator>-&gt;</operator><name>polar_csn</name></name> <operator>=</operator> <name>InvalidCommitSeqNo</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>MyProc</name><operator>-&gt;</operator><name>backendId</name></name> <operator>=</operator> <name>InvalidBackendId</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>MyProc</name><operator>-&gt;</operator><name>databaseId</name></name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>MyProc</name><operator>-&gt;</operator><name>roleId</name></name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>MyProc</name><operator>-&gt;</operator><name>tempNamespaceId</name></name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>MyProc</name><operator>-&gt;</operator><name>isBackgroundWorker</name></name> <operator>=</operator> <name>IsBackgroundWorker</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>MyPgXact</name><operator>-&gt;</operator><name>delayChkpt</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>MyPgXact</name><operator>-&gt;</operator><name>vacuumFlags</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>MyProc</name><operator>-&gt;</operator><name>lwWaiting</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>MyProc</name><operator>-&gt;</operator><name>lwWaitMode</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>MyProc</name><operator>-&gt;</operator><name>waitLock</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>MyProc</name><operator>-&gt;</operator><name>waitProcLock</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<comment type="block">/* Initialize wait event information. */</comment>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type> 	<name>i</name></decl>;</decl_stmt>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>PGPROC_WAIT_STACK_LEN</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<expr_stmt><expr><name><name>MyProc</name><operator>-&gt;</operator><name>wait_object</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>PGPROC_INVAILD_WAIT_OBJ</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>MyProc</name><operator>-&gt;</operator><name>wait_type</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>PGPROC_INVAILD_WAIT_OBJ</name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>INSTR_TIME_SET_ZERO</name><argument_list>(<argument><expr><name><name>MyProc</name><operator>-&gt;</operator><name>wait_time</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></for>
		<expr_stmt><expr><name><name>MyProc</name><operator>-&gt;</operator><name>cur_wait_stack_index</name></name> <operator>=</operator> <name>PGPROC_INVAILD_WAIT_OBJ</name></expr>;</expr_stmt>
	</block_content>}</block>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_ASSERT_CHECKING</name></cpp:ifdef>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

		<comment type="block">/* Last process should have released all locks. */</comment>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>NUM_LOCK_PARTITIONS</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>SHMQueueEmpty</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>MyProc</name><operator>-&gt;</operator><name>myProcLocks</name><index>[<expr><name>i</name></expr>]</index></name><operator>)</operator></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
	</block_content>}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<comment type="block">/* Initialize fields for consensus rep */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>POLAR_ENABLE_DMA</name><argument_list>()</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ConsensusProcInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>MyProc</name><operator>-&gt;</operator><name>consensusInfo</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Acquire ownership of the PGPROC's latch, so that we can use WaitLatch
	 * on it.  That allows us to repoint the process latch, which so far
	 * points to process local one, to the shared one.
	 */</comment>
	<expr_stmt><expr><call><name>OwnLatch</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>MyProc</name><operator>-&gt;</operator><name>procLatch</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SwitchToSharedLatch</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Check that group locking fields are in a proper initial state. */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>MyProc</name><operator>-&gt;</operator><name>lockGroupLeader</name></name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>dlist_is_empty</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>MyProc</name><operator>-&gt;</operator><name>lockGroupMembers</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * We might be reusing a semaphore that belonged to a failed process. So
	 * be careful and reinitialize its value here.  (This is not strictly
	 * necessary anymore, but seems like a good idea for cleanliness.)
	 */</comment>
	<expr_stmt><expr><call><name>PGSemaphoreReset</name><argument_list>(<argument><expr><name><name>MyProc</name><operator>-&gt;</operator><name>sem</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Arrange to clean up at process exit.
	 */</comment>
	<expr_stmt><expr><call><name>on_shmem_exit</name><argument_list>(<argument><expr><name>AuxiliaryProcKill</name></expr></argument>, <argument><expr><call><name>Int32GetDatum</name><argument_list>(<argument><expr><name>proctype</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Record the PID and PGPROC structures for the Startup process, for use in
 * ProcSendSignal().  See comments there for further explanation.
 */</comment>
<function><type><name>void</name></type>
<name>PublishStartupProcessInformation</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>SpinLockAcquire</name><argument_list>(<argument><expr><name>ProcStructLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>ProcGlobal</name><operator>-&gt;</operator><name>startupProc</name></name> <operator>=</operator> <name>MyProc</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ProcGlobal</name><operator>-&gt;</operator><name>startupProcPid</name></name> <operator>=</operator> <name>MyProcPid</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>SpinLockRelease</name><argument_list>(<argument><expr><name>ProcStructLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Used from bufgr to share the value of the buffer that Startup waits on,
 * or to reset the value to "not waiting" (-1). This allows processing
 * of recovery conflicts for buffer pins. Set is made before backends look
 * at this value, so locking not required, especially since the set is
 * an atomic integer set operation.
 */</comment>
<function><type><name>void</name></type>
<name>SetStartupBufferPinWaitBufId</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>bufid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* use volatile pointer to prevent code rearrangement */</comment>
	<decl_stmt><decl><type><specifier>volatile</specifier> <name>PROC_HDR</name> <modifier>*</modifier></type><name>procglobal</name> <init>= <expr><name>ProcGlobal</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>procglobal</name><operator>-&gt;</operator><name>startupBufferPinWaitBufId</name></name> <operator>=</operator> <name>bufid</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Used by backends when they receive a request to check for buffer pin waits.
 */</comment>
<function><type><name>int</name></type>
<name>GetStartupBufferPinWaitBufId</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* use volatile pointer to prevent code rearrangement */</comment>
	<decl_stmt><decl><type><specifier>volatile</specifier> <name>PROC_HDR</name> <modifier>*</modifier></type><name>procglobal</name> <init>= <expr><name>ProcGlobal</name></expr></init></decl>;</decl_stmt>

	<return>return <expr><name><name>procglobal</name><operator>-&gt;</operator><name>startupBufferPinWaitBufId</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Check whether there are at least N free PGPROC objects.
 *
 * Note: this is designed on the assumption that N will generally be small.
 */</comment>
<function><type><name>bool</name></type>
<name>HaveNFreeProcs</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>n</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PGPROC</name>	   <modifier>*</modifier></type><name>proc</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>SpinLockAcquire</name><argument_list>(<argument><expr><name>ProcStructLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>proc</name> <operator>=</operator> <name><name>ProcGlobal</name><operator>-&gt;</operator><name>freeProcs</name></name></expr>;</expr_stmt>

	<while>while <condition>(<expr><name>n</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>proc</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>proc</name> <operator>=</operator> <operator>(</operator><name>PGPROC</name> <operator>*</operator><operator>)</operator> <name><name>proc</name><operator>-&gt;</operator><name>links</name><operator>.</operator><name>next</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>n</name><operator>--</operator></expr>;</expr_stmt>
	</block_content>}</block></while>

	<expr_stmt><expr><call><name>SpinLockRelease</name><argument_list>(<argument><expr><name>ProcStructLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><operator>(</operator><name>n</name> <operator>&lt;=</operator> <literal type="number">0</literal><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Check if the current process is awaiting a lock.
 */</comment>
<function><type><name>bool</name></type>
<name>IsWaitingForLock</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>lockAwaited</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Cancel any pending wait for lock, when aborting a transaction, and revert
 * any strong lock count acquisition for a lock being acquired.
 *
 * (Normally, this would only happen if we accept a cancel/die
 * interrupt while waiting; but an ereport(ERROR) before or during the lock
 * wait is within the realm of possibility, too.)
 */</comment>
<function><type><name>void</name></type>
<name>LockErrorCleanup</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>LWLock</name>	   <modifier>*</modifier></type><name>partitionLock</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>DisableTimeoutParams</name></type> <name><name>timeouts</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>HOLD_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>AbortStrongLockAcquire</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Nothing to do if we weren't waiting for a lock */</comment>
	<if_stmt><if>if <condition>(<expr><name>lockAwaited</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>RESUME_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Turn off the deadlock and lock timeout timers, if they are still
	 * running (see ProcSleep).  Note we must preserve the LOCK_TIMEOUT
	 * indicator flag, since this function is executed before
	 * ProcessInterrupts when responding to SIGINT; else we'd lose the
	 * knowledge that the SIGINT came from a lock timeout and not an external
	 * source.
	 */</comment>
	<expr_stmt><expr><name><name>timeouts</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>id</name> <operator>=</operator> <name>DEADLOCK_TIMEOUT</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>timeouts</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>keep_indicator</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>timeouts</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>id</name> <operator>=</operator> <name>LOCK_TIMEOUT</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>timeouts</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>keep_indicator</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>disable_timeouts</name><argument_list>(<argument><expr><name>timeouts</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Unlink myself from the wait queue, if on it (might not be anymore!) */</comment>
	<expr_stmt><expr><name>partitionLock</name> <operator>=</operator> <call><name>LockHashPartitionLock</name><argument_list>(<argument><expr><name><name>lockAwaited</name><operator>-&gt;</operator><name>hashcode</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>partitionLock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>MyProc</name><operator>-&gt;</operator><name>links</name><operator>.</operator><name>next</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* We could not have been granted the lock yet */</comment>
		<expr_stmt><expr><call><name>RemoveFromWaitQueue</name><argument_list>(<argument><expr><name>MyProc</name></expr></argument>, <argument><expr><name><name>lockAwaited</name><operator>-&gt;</operator><name>hashcode</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/*
		 * Somebody kicked us off the lock queue already.  Perhaps they
		 * granted us the lock, or perhaps they detected a deadlock. If they
		 * did grant us the lock, we'd better remember it in our local lock
		 * table.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>MyProc</name><operator>-&gt;</operator><name>waitStatus</name></name> <operator>==</operator> <name>STATUS_OK</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>GrantAwaitedLock</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><name>lockAwaited</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>partitionLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>RESUME_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * ProcReleaseLocks() -- release locks associated with current transaction
 *			at main transaction commit or abort
 *
 * At main transaction commit, we release standard locks except session locks.
 * At main transaction abort, we release all locks including session locks.
 *
 * Advisory locks are released only if they are transaction-level;
 * session-level holds remain, whether this is a commit or not.
 *
 * At subtransaction commit, we don't release any locks (so this func is not
 * needed at all); we will defer the releasing to the parent transaction.
 * At subtransaction abort, we release all locks held by the subtransaction;
 * this is implemented by retail releasing of the locks under control of
 * the ResourceOwner mechanism.
 */</comment>
<function><type><name>void</name></type>
<name>ProcReleaseLocks</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>isCommit</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>MyProc</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>
	<comment type="block">/* If waiting, get off wait queue (should only be needed after error) */</comment>
	<expr_stmt><expr><call><name>LockErrorCleanup</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* Release standard locks, including session-level if aborting */</comment>
	<expr_stmt><expr><call><name>LockReleaseAll</name><argument_list>(<argument><expr><name>DEFAULT_LOCKMETHOD</name></expr></argument>, <argument><expr><operator>!</operator><name>isCommit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* Release transaction-level advisory locks */</comment>
	<expr_stmt><expr><call><name>LockReleaseAll</name><argument_list>(<argument><expr><name>USER_LOCKMETHOD</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * RemoveProcFromArray() -- Remove this process from the shared ProcArray.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>RemoveProcFromArray</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>code</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>MyProc</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ProcArrayRemove</name><argument_list>(<argument><expr><name>MyProc</name></expr></argument>, <argument><expr><name>InvalidTransactionId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * ProcKill() -- Destroy the per-proc data structure for
 *		this process. Release any of its held LW locks.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ProcKill</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>code</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PGPROC</name>	   <modifier>*</modifier></type><name>proc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PGPROC</name>	   <modifier>*</modifier><specifier>volatile</specifier> <modifier>*</modifier></type><name>procgloballist</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>MyProc</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Make sure we're out of the sync rep lists */</comment>
	<expr_stmt><expr><call><name>SyncRepCleanupAtProcExit</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_ASSERT_CHECKING</name></cpp:ifdef>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

		<comment type="block">/* Last process should have released all locks. */</comment>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>NUM_LOCK_PARTITIONS</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>SHMQueueEmpty</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>MyProc</name><operator>-&gt;</operator><name>myProcLocks</name><index>[<expr><name>i</name></expr>]</index></name><operator>)</operator></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
	</block_content>}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<comment type="block">/*
	 * Release any LW locks I am holding.  There really shouldn't be any, but
	 * it's cheap to check again before we cut the knees off the LWLock
	 * facility by releasing our PGPROC ...
	 */</comment>
	<expr_stmt><expr><call><name>LWLockReleaseAll</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Cancel any pending condition variable sleep, too */</comment>
	<expr_stmt><expr><call><name>ConditionVariableCancelSleep</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Make sure active replication slots are released */</comment>
	<if_stmt><if>if <condition>(<expr><name>MyReplicationSlot</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ReplicationSlotRelease</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Also cleanup all the temporary slots. */</comment>
	<expr_stmt><expr><call><name>ReplicationSlotCleanup</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Detach from any lock group of which we are a member.  If the leader
	 * exist before all other group members, it's PGPROC will remain allocated
	 * until the last group process exits; that process must return the
	 * leader's PGPROC to the appropriate list.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>MyProc</name><operator>-&gt;</operator><name>lockGroupLeader</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>PGPROC</name>	   <modifier>*</modifier></type><name>leader</name> <init>= <expr><name><name>MyProc</name><operator>-&gt;</operator><name>lockGroupLeader</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>LWLock</name>	   <modifier>*</modifier></type><name>leader_lwlock</name> <init>= <expr><call><name>LockHashPartitionLockByProc</name><argument_list>(<argument><expr><name>leader</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>leader_lwlock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>dlist_is_empty</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>leader</name><operator>-&gt;</operator><name>lockGroupMembers</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>dlist_delete</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>MyProc</name><operator>-&gt;</operator><name>lockGroupLink</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>dlist_is_empty</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>leader</name><operator>-&gt;</operator><name>lockGroupMembers</name></name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>leader</name><operator>-&gt;</operator><name>lockGroupLeader</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>leader</name> <operator>!=</operator> <name>MyProc</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>procgloballist</name> <operator>=</operator> <name><name>leader</name><operator>-&gt;</operator><name>procgloballist</name></name></expr>;</expr_stmt>

				<comment type="block">/* Leader exited first; return its PGPROC. */</comment>
				<expr_stmt><expr><call><name>SpinLockAcquire</name><argument_list>(<argument><expr><name>ProcStructLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>leader</name><operator>-&gt;</operator><name>links</name><operator>.</operator><name>next</name></name> <operator>=</operator> <operator>(</operator><name>SHM_QUEUE</name> <operator>*</operator><operator>)</operator> <operator>*</operator><name>procgloballist</name></expr>;</expr_stmt>
				<expr_stmt><expr><operator>*</operator><name>procgloballist</name> <operator>=</operator> <name>leader</name></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>SpinLockRelease</name><argument_list>(<argument><expr><name>ProcStructLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name>leader</name> <operator>!=</operator> <name>MyProc</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>MyProc</name><operator>-&gt;</operator><name>lockGroupLeader</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>leader_lwlock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Reset MyLatch to the process local one.  This is so that signal
	 * handlers et al can continue using the latch after the shared latch
	 * isn't ours anymore. After that clear MyProc and disown the shared
	 * latch.
	 */</comment>
	<expr_stmt><expr><call><name>SwitchBackToLocalLatch</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>proc</name> <operator>=</operator> <name>MyProc</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>MyProc</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>DisownLatch</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>proc</name><operator>-&gt;</operator><name>procLatch</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>procgloballist</name> <operator>=</operator> <name><name>proc</name><operator>-&gt;</operator><name>procgloballist</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SpinLockAcquire</name><argument_list>(<argument><expr><name>ProcStructLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If we're still a member of a locking group, that means we're a leader
	 * which has somehow exited before its children.  The last remaining child
	 * will release our PGPROC.  Otherwise, release it now.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>proc</name><operator>-&gt;</operator><name>lockGroupLeader</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Since lockGroupLeader is NULL, lockGroupMembers should be empty. */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>dlist_is_empty</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>proc</name><operator>-&gt;</operator><name>lockGroupMembers</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Return PGPROC structure (and semaphore) to appropriate freelist */</comment>
		<expr_stmt><expr><name><name>proc</name><operator>-&gt;</operator><name>links</name><operator>.</operator><name>next</name></name> <operator>=</operator> <operator>(</operator><name>SHM_QUEUE</name> <operator>*</operator><operator>)</operator> <operator>*</operator><name>procgloballist</name></expr>;</expr_stmt>
		<expr_stmt><expr><operator>*</operator><name>procgloballist</name> <operator>=</operator> <name>proc</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Update shared estimate of spins_per_delay */</comment>
	<expr_stmt><expr><name><name>ProcGlobal</name><operator>-&gt;</operator><name>spins_per_delay</name></name> <operator>=</operator> <call><name>update_spins_per_delay</name><argument_list>(<argument><expr><name><name>ProcGlobal</name><operator>-&gt;</operator><name>spins_per_delay</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>SpinLockRelease</name><argument_list>(<argument><expr><name>ProcStructLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * This process is no longer present in shared memory in any meaningful
	 * way, so tell the postmaster we've cleaned up acceptably well. (XXX
	 * autovac launcher should be included here someday)
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>IsUnderPostmaster</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>IsAutoVacuumLauncherProcess</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>MarkPostmasterChildInactive</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* wake autovac launcher if needed -- see comments in FreeWorkerInfo */</comment>
	<if_stmt><if>if <condition>(<expr><name>AutovacuumLauncherPid</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>kill</name><argument_list>(<argument><expr><name>AutovacuumLauncherPid</name></expr></argument>, <argument><expr><name>SIGUSR2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * AuxiliaryProcKill() -- Cut-down version of ProcKill for auxiliary
 *		processes (bgwriter, etc).  The PGPROC and sema are not released, only
 *		marked as not-in-use.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>AuxiliaryProcKill</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>code</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>proctype</name> <init>= <expr><call><name>DatumGetInt32</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PGPROC</name>	   <modifier>*</modifier><name>auxproc</name></type> <name>PG_USED_FOR_ASSERTS_ONLY</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PGPROC</name>	   <modifier>*</modifier></type><name>proc</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>proctype</name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>proctype</name> <operator>&lt;</operator> <name>NUM_AUXILIARY_PROCS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>auxproc</name> <operator>=</operator> <operator>&amp;</operator><name><name>AuxiliaryProcs</name><index>[<expr><name>proctype</name></expr>]</index></name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>MyProc</name> <operator>==</operator> <name>auxproc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Release any LW locks I am holding (see notes above) */</comment>
	<expr_stmt><expr><call><name>LWLockReleaseAll</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Cancel any pending condition variable sleep, too */</comment>
	<expr_stmt><expr><call><name>ConditionVariableCancelSleep</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Reset MyLatch to the process local one.  This is so that signal
	 * handlers et al can continue using the latch after the shared latch
	 * isn't ours anymore. After that clear MyProc and disown the shared
	 * latch.
	 */</comment>
	<expr_stmt><expr><call><name>SwitchBackToLocalLatch</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>proc</name> <operator>=</operator> <name>MyProc</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>MyProc</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>DisownLatch</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>proc</name><operator>-&gt;</operator><name>procLatch</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>SpinLockAcquire</name><argument_list>(<argument><expr><name>ProcStructLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Mark auxiliary proc no longer in use */</comment>
	<expr_stmt><expr><name><name>proc</name><operator>-&gt;</operator><name>pid</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<comment type="block">/* Update shared estimate of spins_per_delay */</comment>
	<expr_stmt><expr><name><name>ProcGlobal</name><operator>-&gt;</operator><name>spins_per_delay</name></name> <operator>=</operator> <call><name>update_spins_per_delay</name><argument_list>(<argument><expr><name><name>ProcGlobal</name><operator>-&gt;</operator><name>spins_per_delay</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>SpinLockRelease</name><argument_list>(<argument><expr><name>ProcStructLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * AuxiliaryPidGetProc -- get PGPROC for an auxiliary process
 * given its PID
 *
 * Returns NULL if not found.
 */</comment>
<function><type><name>PGPROC</name> <modifier>*</modifier></type>
<name>AuxiliaryPidGetProc</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>pid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PGPROC</name>	   <modifier>*</modifier></type><name>result</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>index</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>pid</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>				<comment type="block">/* never match dummy PGPROCs */</comment>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

	<for>for <control>(<init><expr><name>index</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>index</name> <operator>&lt;</operator> <name>NUM_AUXILIARY_PROCS</name></expr>;</condition> <incr><expr><name>index</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>PGPROC</name>	   <modifier>*</modifier></type><name>proc</name> <init>= <expr><operator>&amp;</operator><name><name>AuxiliaryProcs</name><index>[<expr><name>index</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>proc</name><operator>-&gt;</operator><name>pid</name></name> <operator>==</operator> <name>pid</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <name>proc</name></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>
	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * ProcQueue package: routines for putting processes to sleep
 *		and  waking them up
 */</comment>

<comment type="block">/*
 * ProcQueueAlloc -- alloc/attach to a shared memory process queue
 *
 * Returns: a pointer to the queue
 * Side Effects: Initializes the queue if it wasn't there before
 */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>NOT_USED</name></cpp:ifdef>
<function><type><name>PROC_QUEUE</name> <modifier>*</modifier></type>
<name>ProcQueueAlloc</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PROC_QUEUE</name> <modifier>*</modifier></type><name>queue</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>found</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>queue</name> <operator>=</operator> <operator>(</operator><name>PROC_QUEUE</name> <operator>*</operator><operator>)</operator>
		<call><name>ShmemInitStruct</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>PROC_QUEUE</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><operator>&amp;</operator><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>found</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ProcQueueInit</name><argument_list>(<argument><expr><name>queue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>queue</name></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
 * ProcQueueInit -- initialize a shared memory process queue
 */</comment>
<function><type><name>void</name></type>
<name>ProcQueueInit</name><parameter_list>(<parameter><decl><type><name>PROC_QUEUE</name> <modifier>*</modifier></type><name>queue</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>SHMQueueInit</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>queue</name><operator>-&gt;</operator><name>links</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>queue</name><operator>-&gt;</operator><name>size</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * ProcSleep -- put a process to sleep on the specified lock
 *
 * Caller must have set MyProc-&gt;heldLocks to reflect locks already held
 * on the lockable object by this process (under all XIDs).
 *
 * The lock table's partition lock must be held at entry, and will be held
 * at exit.
 *
 * Result: STATUS_OK if we acquired the lock, STATUS_ERROR if not (deadlock).
 *
 * ASSUME: that no one will fiddle with the queue until after
 *		we release the partition lock.
 *
 * NOTES: The process queue is now a priority queue for locking.
 */</comment>
<function><type><name>int</name></type>
<name>ProcSleep</name><parameter_list>(<parameter><decl><type><name>LOCALLOCK</name> <modifier>*</modifier></type><name>locallock</name></decl></parameter>, <parameter><decl><type><name>LockMethod</name></type> <name>lockMethodTable</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>LOCKMODE</name></type>	<name>lockmode</name> <init>= <expr><name><name>locallock</name><operator>-&gt;</operator><name>tag</name><operator>.</operator><name>mode</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>LOCK</name>	   <modifier>*</modifier></type><name>lock</name> <init>= <expr><name><name>locallock</name><operator>-&gt;</operator><name>lock</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PROCLOCK</name>   <modifier>*</modifier></type><name>proclock</name> <init>= <expr><name><name>locallock</name><operator>-&gt;</operator><name>proclock</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32</name></type>		<name>hashcode</name> <init>= <expr><name><name>locallock</name><operator>-&gt;</operator><name>hashcode</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>LWLock</name>	   <modifier>*</modifier></type><name>partitionLock</name> <init>= <expr><call><name>LockHashPartitionLock</name><argument_list>(<argument><expr><name>hashcode</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PROC_QUEUE</name> <modifier>*</modifier></type><name>waitQueue</name> <init>= <expr><operator>&amp;</operator><operator>(</operator><name><name>lock</name><operator>-&gt;</operator><name>waitProcs</name></name><operator>)</operator></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>LOCKMASK</name></type>	<name>myHeldLocks</name> <init>= <expr><name><name>MyProc</name><operator>-&gt;</operator><name>heldLocks</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>early_deadlock</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>allow_autovacuum_cancel</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>myWaitStatus</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PGPROC</name>	   <modifier>*</modifier></type><name>proc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PGPROC</name>	   <modifier>*</modifier></type><name>leader</name> <init>= <expr><name><name>MyProc</name><operator>-&gt;</operator><name>lockGroupLeader</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * If group locking is in use, locks held by members of my locking group
	 * need to be included in myHeldLocks.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>leader</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>SHM_QUEUE</name>  <modifier>*</modifier></type><name>procLocks</name> <init>= <expr><operator>&amp;</operator><operator>(</operator><name><name>lock</name><operator>-&gt;</operator><name>procLocks</name></name><operator>)</operator></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>PROCLOCK</name>   <modifier>*</modifier></type><name>otherproclock</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>otherproclock</name> <operator>=</operator> <operator>(</operator><name>PROCLOCK</name> <operator>*</operator><operator>)</operator>
			<call><name>SHMQueueNext</name><argument_list>(<argument><expr><name>procLocks</name></expr></argument>, <argument><expr><name>procLocks</name></expr></argument>, <argument><expr><call><name>offsetof</name><argument_list>(<argument><expr><name>PROCLOCK</name></expr></argument>, <argument><expr><name>lockLink</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<while>while <condition>(<expr><name>otherproclock</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name><name>otherproclock</name><operator>-&gt;</operator><name>groupLeader</name></name> <operator>==</operator> <name>leader</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>myHeldLocks</name> <operator>|=</operator> <name><name>otherproclock</name><operator>-&gt;</operator><name>holdMask</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><name>otherproclock</name> <operator>=</operator> <operator>(</operator><name>PROCLOCK</name> <operator>*</operator><operator>)</operator>
				<call><name>SHMQueueNext</name><argument_list>(<argument><expr><name>procLocks</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>otherproclock</name><operator>-&gt;</operator><name>lockLink</name></name></expr></argument>,
							 <argument><expr><call><name>offsetof</name><argument_list>(<argument><expr><name>PROCLOCK</name></expr></argument>, <argument><expr><name>lockLink</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></while>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Determine where to add myself in the wait queue.
	 *
	 * Normally I should go at the end of the queue.  However, if I already
	 * hold locks that conflict with the request of any previous waiter, put
	 * myself in the queue just in front of the first such waiter. This is not
	 * a necessary step, since deadlock detection would move me to before that
	 * waiter anyway; but it's relatively cheap to detect such a conflict
	 * immediately, and avoid delaying till deadlock timeout.
	 *
	 * Special case: if I find I should go in front of some waiter, check to
	 * see if I conflict with already-held locks or the requests before that
	 * waiter.  If not, then just grant myself the requested lock immediately.
	 * This is the same as the test for immediate grant in LockAcquire, except
	 * we are only considering the part of the wait queue before my insertion
	 * point.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>myHeldLocks</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>LOCKMASK</name></type>	<name>aheadRequests</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>proc</name> <operator>=</operator> <operator>(</operator><name>PGPROC</name> <operator>*</operator><operator>)</operator> <name><name>waitQueue</name><operator>-&gt;</operator><name>links</name><operator>.</operator><name>next</name></name></expr>;</expr_stmt>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>waitQueue</name><operator>-&gt;</operator><name>size</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<comment type="block">/*
			 * If we're part of the same locking group as this waiter, its
			 * locks neither conflict with ours nor contribute to
			 * aheadRequests.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name>leader</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name>leader</name> <operator>==</operator> <name><name>proc</name><operator>-&gt;</operator><name>lockGroupLeader</name></name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>proc</name> <operator>=</operator> <operator>(</operator><name>PGPROC</name> <operator>*</operator><operator>)</operator> <name><name>proc</name><operator>-&gt;</operator><name>links</name><operator>.</operator><name>next</name></name></expr>;</expr_stmt>
				<continue>continue;</continue>
			</block_content>}</block></if></if_stmt>
			<comment type="block">/* Must he wait for me? */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>lockMethodTable</name><operator>-&gt;</operator><name>conflictTab</name><index>[<expr><name><name>proc</name><operator>-&gt;</operator><name>waitLockMode</name></name></expr>]</index></name> <operator>&amp;</operator> <name>myHeldLocks</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* Must I wait for him ? */</comment>
				<if_stmt><if>if <condition>(<expr><name><name>lockMethodTable</name><operator>-&gt;</operator><name>conflictTab</name><index>[<expr><name>lockmode</name></expr>]</index></name> <operator>&amp;</operator> <name><name>proc</name><operator>-&gt;</operator><name>heldLocks</name></name></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/*
					 * Yes, so we have a deadlock.  Easiest way to clean up
					 * correctly is to call RemoveFromWaitQueue(), but we
					 * can't do that until we are *on* the wait queue. So, set
					 * a flag to check below, and break out of loop.  Also,
					 * record deadlock info for later message.
					 */</comment>
					<expr_stmt><expr><call><name>RememberSimpleDeadLock</name><argument_list>(<argument><expr><name>MyProc</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>, <argument><expr><name>lock</name></expr></argument>, <argument><expr><name>proc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>early_deadlock</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
					<break>break;</break>
				</block_content>}</block></if></if_stmt>
				<comment type="block">/* I must go before this waiter.  Check special case. */</comment>
				<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>lockMethodTable</name><operator>-&gt;</operator><name>conflictTab</name><index>[<expr><name>lockmode</name></expr>]</index></name> <operator>&amp;</operator> <name>aheadRequests</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
					<call><name>LockCheckConflicts</name><argument_list>(<argument><expr><name>lockMethodTable</name></expr></argument>,
									   <argument><expr><name>lockmode</name></expr></argument>,
									   <argument><expr><name>lock</name></expr></argument>,
									   <argument><expr><name>proclock</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>STATUS_OK</name></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/* Skip the wait and just grant myself the lock. */</comment>
					<expr_stmt><expr><call><name>GrantLock</name><argument_list>(<argument><expr><name>lock</name></expr></argument>, <argument><expr><name>proclock</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>GrantAwaitedLock</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
					<return>return <expr><name>STATUS_OK</name></expr>;</return>
				</block_content>}</block></if></if_stmt>
				<comment type="block">/* Break out of loop to put myself before him */</comment>
				<break>break;</break>
			</block_content>}</block></if></if_stmt>
			<comment type="block">/* Nope, so advance to next waiter */</comment>
			<expr_stmt><expr><name>aheadRequests</name> <operator>|=</operator> <call><name>LOCKBIT_ON</name><argument_list>(<argument><expr><name><name>proc</name><operator>-&gt;</operator><name>waitLockMode</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>proc</name> <operator>=</operator> <operator>(</operator><name>PGPROC</name> <operator>*</operator><operator>)</operator> <name><name>proc</name><operator>-&gt;</operator><name>links</name><operator>.</operator><name>next</name></name></expr>;</expr_stmt>
		</block_content>}</block></for>

		<comment type="block">/*
		 * If we fall out of loop normally, proc points to waitQueue head, so
		 * we will insert at tail of queue as desired.
		 */</comment>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* I hold no locks, so I can't push in front of anyone. */</comment>
		<expr_stmt><expr><name>proc</name> <operator>=</operator> <operator>(</operator><name>PGPROC</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><operator>(</operator><name><name>waitQueue</name><operator>-&gt;</operator><name>links</name></name><operator>)</operator></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/*
	 * Insert self into queue, ahead of the given proc (or at tail of queue).
	 */</comment>
	<expr_stmt><expr><call><name>SHMQueueInsertBefore</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>proc</name><operator>-&gt;</operator><name>links</name></name><operator>)</operator></expr></argument>, <argument><expr><operator>&amp;</operator><operator>(</operator><name><name>MyProc</name><operator>-&gt;</operator><name>links</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>waitQueue</name><operator>-&gt;</operator><name>size</name></name><operator>++</operator></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>lock</name><operator>-&gt;</operator><name>waitMask</name></name> <operator>|=</operator> <call><name>LOCKBIT_ON</name><argument_list>(<argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Set up wait information in PGPROC object, too */</comment>
	<expr_stmt><expr><name><name>MyProc</name><operator>-&gt;</operator><name>waitLock</name></name> <operator>=</operator> <name>lock</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>MyProc</name><operator>-&gt;</operator><name>waitProcLock</name></name> <operator>=</operator> <name>proclock</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>MyProc</name><operator>-&gt;</operator><name>waitLockMode</name></name> <operator>=</operator> <name>lockmode</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>MyProc</name><operator>-&gt;</operator><name>waitStatus</name></name> <operator>=</operator> <name>STATUS_WAITING</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * If we detected deadlock, give up without waiting.  This must agree with
	 * CheckDeadLock's recovery code.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>early_deadlock</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>RemoveFromWaitQueue</name><argument_list>(<argument><expr><name>MyProc</name></expr></argument>, <argument><expr><name>hashcode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>STATUS_ERROR</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* mark that we are waiting for a lock */</comment>
	<expr_stmt><expr><name>lockAwaited</name> <operator>=</operator> <name>locallock</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Release the lock table's partition lock.
	 *
	 * NOTE: this may also cause us to exit critical-section state, possibly
	 * allowing a cancel/die interrupt to be accepted. This is OK because we
	 * have recorded the fact that we are waiting for a lock, and so
	 * LockErrorCleanup will clean up if cancel/die happens.
	 */</comment>
	<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>partitionLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Also, now that we will successfully clean up after an ereport, it's
	 * safe to check to see if there's a buffer pin deadlock against the
	 * Startup process.  Of course, that's only necessary if we're doing Hot
	 * Standby and are not the Startup process ourselves.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>RecoveryInProgress</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><name>InRecovery</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>CheckRecoveryConflictDeadlock</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Reset deadlock_state before enabling the timeout handler */</comment>
	<expr_stmt><expr><name>deadlock_state</name> <operator>=</operator> <name>DS_NOT_YET_CHECKED</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>got_deadlock_timeout</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<comment type="block">/* POLAR px: reset the PX wait lock timeout flag. */</comment>
	<expr_stmt><expr><name>px_wait_lock_alert</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<comment type="block">/* POLAR end */</comment>

	<comment type="block">/*
	 * Set timer so we can wake up after awhile and check for a deadlock. If a
	 * deadlock is detected, the handler sets MyProc-&gt;waitStatus =
	 * STATUS_ERROR, allowing us to know that we must report failure rather
	 * than success.
	 *
	 * By delaying the check until we've waited for a bit, we can avoid
	 * running the rather expensive deadlock-check code in most cases.
	 *
	 * If LockTimeout is set, also enable the timeout for that.  We can save a
	 * few cycles by enabling both timeout sources in one call.
	 *
	 * If InHotStandby we set lock waits slightly later for clarity with other
	 * code.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>InHotStandby</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>LockTimeout</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>EnableTimeoutParams</name></type> <name><name>timeouts</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>

			<expr_stmt><expr><name><name>timeouts</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>id</name> <operator>=</operator> <name>DEADLOCK_TIMEOUT</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>timeouts</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>type</name> <operator>=</operator> <name>TMPARAM_AFTER</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>timeouts</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>delay_ms</name> <operator>=</operator> <name>DeadlockTimeout</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>timeouts</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>id</name> <operator>=</operator> <name>LOCK_TIMEOUT</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>timeouts</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>type</name> <operator>=</operator> <name>TMPARAM_AFTER</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>timeouts</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>delay_ms</name> <operator>=</operator> <name>LockTimeout</name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>enable_timeouts</name><argument_list>(<argument><expr><name>timeouts</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>enable_timeout_after</name><argument_list>(<argument><expr><name>DEADLOCK_TIMEOUT</name></expr></argument>, <argument><expr><name>DeadlockTimeout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<comment type="block">/* POLAR px: enable timer if timeout interval is specified by GUC. */</comment>
		<if_stmt><if>if <condition>(<expr><name>px_wait_lock_timeout</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>enable_timeout_after</name><argument_list>(<argument><expr><name>px_wait_lock_timer_id</name></expr></argument>,
								 <argument><expr><name>px_wait_lock_timeout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<comment type="block">/* POLAR end */</comment>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * If somebody wakes us between LWLockRelease and WaitLatch, the latch
	 * will not wait. But a set latch does not necessarily mean that the lock
	 * is free now, as there are many other sources for latch sets than
	 * somebody releasing the lock.
	 *
	 * We process interrupts whenever the latch has been set, so cancel/die
	 * interrupts are processed quickly. This means we must not mind losing
	 * control to a cancel/die interrupt here.  We don't, because we have no
	 * shared-state-change work to do after being granted the lock (the
	 * grantor did it all).  We do have to worry about canceling the deadlock
	 * timeout and updating the locallock table, but if we lose control to an
	 * error, LockErrorCleanup will fix that up.
	 */</comment>
	<do>do
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>InHotStandby</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Set a timer and wait for that or for the Lock to be granted */</comment>
			<expr_stmt><expr><call><name>ResolveRecoveryConflictWithLock</name><argument_list>(<argument><expr><name><name>locallock</name><operator>-&gt;</operator><name>tag</name><operator>.</operator><name>lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><call><name>WaitLatch</name><argument_list>(<argument><expr><name>MyLatch</name></expr></argument>, <argument><expr><name>WL_LATCH_SET</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
					  <argument><expr><name>PG_WAIT_LOCK</name> <operator>|</operator> <name><name>locallock</name><operator>-&gt;</operator><name>tag</name><operator>.</operator><name>lock</name><operator>.</operator><name>locktag_type</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>ResetLatch</name><argument_list>(<argument><expr><name>MyLatch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* POLAR px: handle the wait lock timeout. */</comment>
			<if_stmt><if>if <condition>(<expr><name>px_wait_lock_alert</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>px_cancel_wait_lock</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>px_wait_lock_alert</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			<comment type="block">/* POLAR end */</comment>

			<comment type="block">/* check for deadlocks first, as that's probably log-worthy */</comment>
			<if_stmt><if>if <condition>(<expr><name>got_deadlock_timeout</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>CheckDeadLock</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>got_deadlock_timeout</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			<expr_stmt><expr><call><name>CHECK_FOR_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<comment type="block">/*
		 * waitStatus could change from STATUS_WAITING to something else
		 * asynchronously.  Read it just once per loop to prevent surprising
		 * behavior (such as missing log messages).
		 */</comment>
		<expr_stmt><expr><name>myWaitStatus</name> <operator>=</operator> <operator>*</operator><operator>(</operator><operator>(</operator><specifier>volatile</specifier> <name>int</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name><name>MyProc</name><operator>-&gt;</operator><name>waitStatus</name></name><operator>)</operator></expr>;</expr_stmt>

		<comment type="block">/*
		 * If we are not deadlocked, but are waiting on an autovacuum-induced
		 * task, send a signal to interrupt it.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>deadlock_state</name> <operator>==</operator> <name>DS_BLOCKED_BY_AUTOVACUUM</name> <operator>&amp;&amp;</operator> <name>allow_autovacuum_cancel</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>PGPROC</name>	   <modifier>*</modifier></type><name>autovac</name> <init>= <expr><call><name>GetBlockingAutoVacuumPgproc</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>PGXACT</name>	   <modifier>*</modifier></type><name>autovac_pgxact</name> <init>= <expr><operator>&amp;</operator><name><name>ProcGlobal</name><operator>-&gt;</operator><name>allPgXact</name><index>[<expr><name><name>autovac</name><operator>-&gt;</operator><name>pgprocno</name></name></expr>]</index></name></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>ProcArrayLock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * Only do it if the worker is not working to protect against Xid
			 * wraparound.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>autovac_pgxact</name><operator>-&gt;</operator><name>vacuumFlags</name></name> <operator>&amp;</operator> <name>PROC_IS_AUTOVACUUM</name><operator>)</operator> <operator>&amp;&amp;</operator>
				<operator>!</operator><operator>(</operator><name><name>autovac_pgxact</name><operator>-&gt;</operator><name>vacuumFlags</name></name> <operator>&amp;</operator> <name>PROC_VACUUM_FOR_WRAPAROUND</name><operator>)</operator></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>int</name></type>			<name>pid</name> <init>= <expr><name><name>autovac</name><operator>-&gt;</operator><name>pid</name></name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>StringInfoData</name></type> <name>locktagbuf</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>StringInfoData</name></type> <name>logbuf</name></decl>;</decl_stmt>	<comment type="block">/* errdetail for server log */</comment>

				<expr_stmt><expr><call><name>initStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>locktagbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>initStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>logbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>DescribeLockTag</name><argument_list>(<argument><expr><operator>&amp;</operator><name>locktagbuf</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>lock</name><operator>-&gt;</operator><name>tag</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>logbuf</name></expr></argument>,
								 <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Process %d waits for %s on %s."</literal></expr></argument>)</argument_list></call></expr></argument>,
								 <argument><expr><name>MyProcPid</name></expr></argument>,
								 <argument><expr><call><name>GetLockmodeName</name><argument_list>(<argument><expr><name><name>lock</name><operator>-&gt;</operator><name>tag</name><operator>.</operator><name>locktag_lockmethodid</name></name></expr></argument>,
												 <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr></argument>,
								 <argument><expr><name><name>locktagbuf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/* release lock as quickly as possible */</comment>
				<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>ProcArrayLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/* send the autovacuum worker Back to Old Kent Road */</comment>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"sending cancel to blocking autovacuum PID %d"</literal></expr></argument>,
								<argument><expr><name>pid</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errdetail_log</name><argument_list>(<argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name><name>logbuf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<if_stmt><if>if <condition>(<expr><call><name>kill</name><argument_list>(<argument><expr><name>pid</name></expr></argument>, <argument><expr><name>SIGINT</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/*
					 * There's a race condition here: once we release the
					 * ProcArrayLock, it's possible for the autovac worker to
					 * close up shop and exit before we can do the kill().
					 * Therefore, we do not whinge about no-such-process.
					 * Other errors such as EPERM could conceivably happen if
					 * the kernel recycles the PID fast enough, but such cases
					 * seem improbable enough that it's probably best to issue
					 * a warning if we see some other errno.
					 */</comment>
					<if_stmt><if>if <condition>(<expr><name>errno</name> <operator>!=</operator> <name>ESRCH</name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>,
								<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not send signal to process %d: %m"</literal></expr></argument>,
										<argument><expr><name>pid</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				</block_content>}</block></if></if_stmt>

				<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>logbuf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>locktagbuf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>ProcArrayLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

			<comment type="block">/* prevent signal from being resent more than once */</comment>
			<expr_stmt><expr><name>allow_autovacuum_cancel</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * If awoken after the deadlock check interrupt has run, and
		 * log_lock_waits is on, then report about the wait.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>log_lock_waits</name> <operator>&amp;&amp;</operator> <name>deadlock_state</name> <operator>!=</operator> <name>DS_NOT_YET_CHECKED</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>StringInfoData</name></type> <name>buf</name></decl>,
						<decl><type ref="prev"/><name>lock_waiters_sbuf</name></decl>,
						<decl><type ref="prev"/><name>lock_holders_sbuf</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>modename</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>long</name></type>		<name>secs</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int</name></type>			<name>usecs</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>long</name></type>		<name>msecs</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>SHM_QUEUE</name>  <modifier>*</modifier></type><name>procLocks</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>PROCLOCK</name>   <modifier>*</modifier></type><name>proclock</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>bool</name></type>		<name>first_holder</name> <init>= <expr><name>true</name></expr></init></decl>,
						<decl><type ref="prev"/><name>first_waiter</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int</name></type>			<name>lockHoldersNum</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>initStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>initStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>lock_waiters_sbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>initStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>lock_holders_sbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>DescribeLockTag</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>locallock</name><operator>-&gt;</operator><name>tag</name><operator>.</operator><name>lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>modename</name> <operator>=</operator> <call><name>GetLockmodeName</name><argument_list>(<argument><expr><name><name>locallock</name><operator>-&gt;</operator><name>tag</name><operator>.</operator><name>lock</name><operator>.</operator><name>locktag_lockmethodid</name></name></expr></argument>,
									   <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>TimestampDifference</name><argument_list>(<argument><expr><call><name>get_timeout_start_time</name><argument_list>(<argument><expr><name>DEADLOCK_TIMEOUT</name></expr></argument>)</argument_list></call></expr></argument>,
								<argument><expr><call><name>GetCurrentTimestamp</name><argument_list>()</argument_list></call></expr></argument>,
								<argument><expr><operator>&amp;</operator><name>secs</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>usecs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>msecs</name> <operator>=</operator> <name>secs</name> <operator>*</operator> <literal type="number">1000</literal> <operator>+</operator> <name>usecs</name> <operator>/</operator> <literal type="number">1000</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name>usecs</name> <operator>=</operator> <name>usecs</name> <operator>%</operator> <literal type="number">1000</literal></expr>;</expr_stmt>

			<comment type="block">/*
			 * we loop over the lock's procLocks to gather a list of all
			 * holders and waiters. Thus we will be able to provide more
			 * detailed information for lock debugging purposes.
			 *
			 * lock-&gt;procLocks contains all processes which hold or wait for
			 * this lock.
			 */</comment>

			<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>partitionLock</name></expr></argument>, <argument><expr><name>LW_SHARED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name>procLocks</name> <operator>=</operator> <operator>&amp;</operator><operator>(</operator><name><name>lock</name><operator>-&gt;</operator><name>procLocks</name></name><operator>)</operator></expr>;</expr_stmt>
			<expr_stmt><expr><name>proclock</name> <operator>=</operator> <operator>(</operator><name>PROCLOCK</name> <operator>*</operator><operator>)</operator> <call><name>SHMQueueNext</name><argument_list>(<argument><expr><name>procLocks</name></expr></argument>, <argument><expr><name>procLocks</name></expr></argument>,
												 <argument><expr><call><name>offsetof</name><argument_list>(<argument><expr><name>PROCLOCK</name></expr></argument>, <argument><expr><name>lockLink</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<while>while <condition>(<expr><name>proclock</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/*
				 * we are a waiter if myProc-&gt;waitProcLock == proclock; we are
				 * a holder if it is NULL or something different
				 */</comment>
				<if_stmt><if>if <condition>(<expr><name><name>proclock</name><operator>-&gt;</operator><name>tag</name><operator>.</operator><name>myProc</name><operator>-&gt;</operator><name>waitProcLock</name></name> <operator>==</operator> <name>proclock</name></expr>)</condition>
				<block>{<block_content>
					<if_stmt><if>if <condition>(<expr><name>first_waiter</name></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>lock_waiters_sbuf</name></expr></argument>, <argument><expr><literal type="string">"%d"</literal></expr></argument>,
										 <argument><expr><name><name>proclock</name><operator>-&gt;</operator><name>tag</name><operator>.</operator><name>myProc</name><operator>-&gt;</operator><name>pid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><name>first_waiter</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
					</block_content>}</block></if>
					<else>else<block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>lock_waiters_sbuf</name></expr></argument>, <argument><expr><literal type="string">", %d"</literal></expr></argument>,
										 <argument><expr><name><name>proclock</name><operator>-&gt;</operator><name>tag</name><operator>.</operator><name>myProc</name><operator>-&gt;</operator><name>pid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
				</block_content>}</block></if>
				<else>else
				<block>{<block_content>
					<if_stmt><if>if <condition>(<expr><name>first_holder</name></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>lock_holders_sbuf</name></expr></argument>, <argument><expr><literal type="string">"%d"</literal></expr></argument>,
										 <argument><expr><name><name>proclock</name><operator>-&gt;</operator><name>tag</name><operator>.</operator><name>myProc</name><operator>-&gt;</operator><name>pid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><name>first_holder</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
					</block_content>}</block></if>
					<else>else<block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>lock_holders_sbuf</name></expr></argument>, <argument><expr><literal type="string">", %d"</literal></expr></argument>,
										 <argument><expr><name><name>proclock</name><operator>-&gt;</operator><name>tag</name><operator>.</operator><name>myProc</name><operator>-&gt;</operator><name>pid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

					<expr_stmt><expr><name>lockHoldersNum</name><operator>++</operator></expr>;</expr_stmt>
				</block_content>}</block></else></if_stmt>

				<expr_stmt><expr><name>proclock</name> <operator>=</operator> <operator>(</operator><name>PROCLOCK</name> <operator>*</operator><operator>)</operator> <call><name>SHMQueueNext</name><argument_list>(<argument><expr><name>procLocks</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>proclock</name><operator>-&gt;</operator><name>lockLink</name></name></expr></argument>,
													 <argument><expr><call><name>offsetof</name><argument_list>(<argument><expr><name>PROCLOCK</name></expr></argument>, <argument><expr><name>lockLink</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></while>

			<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>partitionLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name>deadlock_state</name> <operator>==</operator> <name>DS_SOFT_DEADLOCK</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"process %d avoided deadlock for %s on %s by rearranging queue order after %ld.%03d ms"</literal></expr></argument>,
								<argument><expr><name>MyProcPid</name></expr></argument>, <argument><expr><name>modename</name></expr></argument>, <argument><expr><name><name>buf</name><operator>.</operator><name>data</name></name></expr></argument>, <argument><expr><name>msecs</name></expr></argument>, <argument><expr><name>usecs</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <operator>(</operator><call><name>errdetail_log_plural</name><argument_list>(<argument><expr><literal type="string">"Process holding the lock: %s. Wait queue: %s."</literal></expr></argument>,
											   <argument><expr><literal type="string">"Processes holding the lock: %s. Wait queue: %s."</literal></expr></argument>,
											   <argument><expr><name>lockHoldersNum</name></expr></argument>, <argument><expr><name><name>lock_holders_sbuf</name><operator>.</operator><name>data</name></name></expr></argument>, <argument><expr><name><name>lock_waiters_sbuf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call><operator>)</operator><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<if type="elseif">else if <condition>(<expr><name>deadlock_state</name> <operator>==</operator> <name>DS_HARD_DEADLOCK</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/*
				 * This message is a bit redundant with the error that will be
				 * reported subsequently, but in some cases the error report
				 * might not make it to the log (eg, if it's caught by an
				 * exception handler), and we want to ensure all long-wait
				 * events get logged.
				 */</comment>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"process %d detected deadlock while waiting for %s on %s after %ld.%03d ms"</literal></expr></argument>,
								<argument><expr><name>MyProcPid</name></expr></argument>, <argument><expr><name>modename</name></expr></argument>, <argument><expr><name><name>buf</name><operator>.</operator><name>data</name></name></expr></argument>, <argument><expr><name>msecs</name></expr></argument>, <argument><expr><name>usecs</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <operator>(</operator><call><name>errdetail_log_plural</name><argument_list>(<argument><expr><literal type="string">"Process holding the lock: %s. Wait queue: %s."</literal></expr></argument>,
											   <argument><expr><literal type="string">"Processes holding the lock: %s. Wait queue: %s."</literal></expr></argument>,
											   <argument><expr><name>lockHoldersNum</name></expr></argument>, <argument><expr><name><name>lock_holders_sbuf</name><operator>.</operator><name>data</name></name></expr></argument>, <argument><expr><name><name>lock_waiters_sbuf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call><operator>)</operator><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><name>myWaitStatus</name> <operator>==</operator> <name>STATUS_WAITING</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"process %d still waiting for %s on %s after %ld.%03d ms"</literal></expr></argument>,
								<argument><expr><name>MyProcPid</name></expr></argument>, <argument><expr><name>modename</name></expr></argument>, <argument><expr><name><name>buf</name><operator>.</operator><name>data</name></name></expr></argument>, <argument><expr><name>msecs</name></expr></argument>, <argument><expr><name>usecs</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <operator>(</operator><call><name>errdetail_log_plural</name><argument_list>(<argument><expr><literal type="string">"Process holding the lock: %s. Wait queue: %s."</literal></expr></argument>,
											   <argument><expr><literal type="string">"Processes holding the lock: %s. Wait queue: %s."</literal></expr></argument>,
											   <argument><expr><name>lockHoldersNum</name></expr></argument>, <argument><expr><name><name>lock_holders_sbuf</name><operator>.</operator><name>data</name></name></expr></argument>, <argument><expr><name><name>lock_waiters_sbuf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call><operator>)</operator><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<if type="elseif">else if <condition>(<expr><name>myWaitStatus</name> <operator>==</operator> <name>STATUS_OK</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"process %d acquired %s on %s after %ld.%03d ms"</literal></expr></argument>,
								<argument><expr><name>MyProcPid</name></expr></argument>, <argument><expr><name>modename</name></expr></argument>, <argument><expr><name><name>buf</name><operator>.</operator><name>data</name></name></expr></argument>, <argument><expr><name>msecs</name></expr></argument>, <argument><expr><name>usecs</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else
			<block>{<block_content>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>myWaitStatus</name> <operator>==</operator> <name>STATUS_ERROR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/*
				 * Currently, the deadlock checker always kicks its own
				 * process, which means that we'll only see STATUS_ERROR when
				 * deadlock_state == DS_HARD_DEADLOCK, and there's no need to
				 * print redundant messages.  But for completeness and
				 * future-proofing, print a message if it looks like someone
				 * else kicked us off the lock.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><name>deadlock_state</name> <operator>!=</operator> <name>DS_HARD_DEADLOCK</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"process %d failed to acquire %s on %s after %ld.%03d ms"</literal></expr></argument>,
									<argument><expr><name>MyProcPid</name></expr></argument>, <argument><expr><name>modename</name></expr></argument>, <argument><expr><name><name>buf</name><operator>.</operator><name>data</name></name></expr></argument>, <argument><expr><name>msecs</name></expr></argument>, <argument><expr><name>usecs</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <operator>(</operator><call><name>errdetail_log_plural</name><argument_list>(<argument><expr><literal type="string">"Process holding the lock: %s. Wait queue: %s."</literal></expr></argument>,
												   <argument><expr><literal type="string">"Processes holding the lock: %s. Wait queue: %s."</literal></expr></argument>,
												   <argument><expr><name>lockHoldersNum</name></expr></argument>, <argument><expr><name><name>lock_holders_sbuf</name><operator>.</operator><name>data</name></name></expr></argument>, <argument><expr><name><name>lock_waiters_sbuf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call><operator>)</operator><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block></else></if_stmt>

			<comment type="block">/*
			 * At this point we might still need to wait for the lock. Reset
			 * state so we don't print the above messages again.
			 */</comment>
			<expr_stmt><expr><name>deadlock_state</name> <operator>=</operator> <name>DS_NO_DEADLOCK</name></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>buf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>lock_holders_sbuf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>lock_waiters_sbuf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block> while <condition>(<expr><name>myWaitStatus</name> <operator>==</operator> <name>STATUS_WAITING</name></expr>)</condition>;</do>

	<comment type="block">/*
	 * Disable the timers, if they are still running.  As in LockErrorCleanup,
	 * we must preserve the LOCK_TIMEOUT indicator flag: if a lock timeout has
	 * already caused QueryCancelPending to become set, we want the cancel to
	 * be reported as a lock timeout, not a user cancel.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>InHotStandby</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>LockTimeout</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>DisableTimeoutParams</name></type> <name><name>timeouts</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>

			<expr_stmt><expr><name><name>timeouts</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>id</name> <operator>=</operator> <name>DEADLOCK_TIMEOUT</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>timeouts</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>keep_indicator</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>timeouts</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>id</name> <operator>=</operator> <name>LOCK_TIMEOUT</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>timeouts</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>keep_indicator</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>disable_timeouts</name><argument_list>(<argument><expr><name>timeouts</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>disable_timeout</name><argument_list>(<argument><expr><name>DEADLOCK_TIMEOUT</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<comment type="block">/* POLAR px: disable the wait lock timer. */</comment>
		<if_stmt><if>if <condition>(<expr><name>px_wait_lock_timeout</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>disable_timeout</name><argument_list>(<argument><expr><name>px_wait_lock_timer_id</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<comment type="block">/* POLAR end */</comment>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Re-acquire the lock table's partition lock.  We have to do this to hold
	 * off cancel/die interrupts before we can mess with lockAwaited (else we
	 * might have a missed or duplicated locallock update).
	 */</comment>
	<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>partitionLock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * We no longer want LockErrorCleanup to do anything.
	 */</comment>
	<expr_stmt><expr><name>lockAwaited</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * If we got the lock, be sure to remember it in the locallock table.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>MyProc</name><operator>-&gt;</operator><name>waitStatus</name></name> <operator>==</operator> <name>STATUS_OK</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>GrantAwaitedLock</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * We don't have to do anything else, because the awaker did all the
	 * necessary update of the lock table and MyProc.
	 */</comment>
	<return>return <expr><name><name>MyProc</name><operator>-&gt;</operator><name>waitStatus</name></name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * ProcWakeup -- wake up a process by setting its latch.
 *
 *	 Also remove the process from the wait queue and set its links invalid.
 *	 RETURN: the next process in the wait queue.
 *
 * The appropriate lock partition lock must be held by caller.
 *
 * XXX: presently, this code is only used for the "success" case, and only
 * works correctly for that case.  To clean up in failure case, would need
 * to twiddle the lock's request counts too --- see RemoveFromWaitQueue.
 * Hence, in practice the waitStatus parameter must be STATUS_OK.
 */</comment>
<function><type><name>PGPROC</name> <modifier>*</modifier></type>
<name>ProcWakeup</name><parameter_list>(<parameter><decl><type><name>PGPROC</name> <modifier>*</modifier></type><name>proc</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>waitStatus</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PGPROC</name>	   <modifier>*</modifier></type><name>retProc</name></decl>;</decl_stmt>

	<comment type="block">/* Proc should be sleeping ... */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>proc</name><operator>-&gt;</operator><name>links</name><operator>.</operator><name>prev</name></name> <operator>==</operator> <name>NULL</name> <operator>||</operator>
		<name><name>proc</name><operator>-&gt;</operator><name>links</name><operator>.</operator><name>next</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>proc</name><operator>-&gt;</operator><name>waitStatus</name></name> <operator>==</operator> <name>STATUS_WAITING</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Save next process before we zap the list link */</comment>
	<expr_stmt><expr><name>retProc</name> <operator>=</operator> <operator>(</operator><name>PGPROC</name> <operator>*</operator><operator>)</operator> <name><name>proc</name><operator>-&gt;</operator><name>links</name><operator>.</operator><name>next</name></name></expr>;</expr_stmt>

	<comment type="block">/* Remove process from wait queue */</comment>
	<expr_stmt><expr><call><name>SHMQueueDelete</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>proc</name><operator>-&gt;</operator><name>links</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><operator>(</operator><name><name>proc</name><operator>-&gt;</operator><name>waitLock</name><operator>-&gt;</operator><name>waitProcs</name><operator>.</operator><name>size</name></name><operator>)</operator><operator>--</operator></expr>;</expr_stmt>

	<comment type="block">/* Clean up process' state and pass it the ok/fail signal */</comment>
	<expr_stmt><expr><name><name>proc</name><operator>-&gt;</operator><name>waitLock</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>proc</name><operator>-&gt;</operator><name>waitProcLock</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>proc</name><operator>-&gt;</operator><name>waitStatus</name></name> <operator>=</operator> <name>waitStatus</name></expr>;</expr_stmt>

	<comment type="block">/* And awaken it */</comment>
	<expr_stmt><expr><call><name>SetLatch</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>proc</name><operator>-&gt;</operator><name>procLatch</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>retProc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * ProcLockWakeup -- routine for waking up processes when a lock is
 *		released (or a prior waiter is aborted).  Scan all waiters
 *		for lock, waken any that are no longer blocked.
 *
 * The appropriate lock partition lock must be held by caller.
 */</comment>
<function><type><name>void</name></type>
<name>ProcLockWakeup</name><parameter_list>(<parameter><decl><type><name>LockMethod</name></type> <name>lockMethodTable</name></decl></parameter>, <parameter><decl><type><name>LOCK</name> <modifier>*</modifier></type><name>lock</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PROC_QUEUE</name> <modifier>*</modifier></type><name>waitQueue</name> <init>= <expr><operator>&amp;</operator><operator>(</operator><name><name>lock</name><operator>-&gt;</operator><name>waitProcs</name></name><operator>)</operator></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>queue_size</name> <init>= <expr><name><name>waitQueue</name><operator>-&gt;</operator><name>size</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PGPROC</name>	   <modifier>*</modifier></type><name>proc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>LOCKMASK</name></type>	<name>aheadRequests</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>queue_size</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>queue_size</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>proc</name> <operator>=</operator> <operator>(</operator><name>PGPROC</name> <operator>*</operator><operator>)</operator> <name><name>waitQueue</name><operator>-&gt;</operator><name>links</name><operator>.</operator><name>next</name></name></expr>;</expr_stmt>

	<while>while <condition>(<expr><name>queue_size</name><operator>--</operator> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>LOCKMODE</name></type>	<name>lockmode</name> <init>= <expr><name><name>proc</name><operator>-&gt;</operator><name>waitLockMode</name></name></expr></init></decl>;</decl_stmt>

		<comment type="block">/*
		 * Waken if (a) doesn't conflict with requests of earlier waiters, and
		 * (b) doesn't conflict with already-held locks.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>lockMethodTable</name><operator>-&gt;</operator><name>conflictTab</name><index>[<expr><name>lockmode</name></expr>]</index></name> <operator>&amp;</operator> <name>aheadRequests</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
			<call><name>LockCheckConflicts</name><argument_list>(<argument><expr><name>lockMethodTable</name></expr></argument>,
							   <argument><expr><name>lockmode</name></expr></argument>,
							   <argument><expr><name>lock</name></expr></argument>,
							   <argument><expr><name><name>proc</name><operator>-&gt;</operator><name>waitProcLock</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <name>STATUS_OK</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* OK to waken */</comment>
			<expr_stmt><expr><call><name>GrantLock</name><argument_list>(<argument><expr><name>lock</name></expr></argument>, <argument><expr><name><name>proc</name><operator>-&gt;</operator><name>waitProcLock</name></name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>proc</name> <operator>=</operator> <call><name>ProcWakeup</name><argument_list>(<argument><expr><name>proc</name></expr></argument>, <argument><expr><name>STATUS_OK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * ProcWakeup removes proc from the lock's waiting process queue
			 * and returns the next proc in chain; don't use proc's next-link,
			 * because it's been cleared.
			 */</comment>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/*
			 * Cannot wake this guy. Remember his request for later checks.
			 */</comment>
			<expr_stmt><expr><name>aheadRequests</name> <operator>|=</operator> <call><name>LOCKBIT_ON</name><argument_list>(<argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>proc</name> <operator>=</operator> <operator>(</operator><name>PGPROC</name> <operator>*</operator><operator>)</operator> <name><name>proc</name><operator>-&gt;</operator><name>links</name><operator>.</operator><name>next</name></name></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></while>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>waitQueue</name><operator>-&gt;</operator><name>size</name></name> <operator>&gt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * CheckDeadLock
 *
 * We only get to this routine, if DEADLOCK_TIMEOUT fired while waiting for a
 * lock to be released by some other process.  Check if there's a deadlock; if
 * not, just return.  (But signal ProcSleep to log a message, if
 * log_lock_waits is true.)  If we have a real deadlock, remove ourselves from
 * the lock's wait queue and signal an error to ProcSleep.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>CheckDeadLock</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Acquire exclusive lock on the entire shared lock data structures. Must
	 * grab LWLocks in partition-number order to avoid LWLock deadlock.
	 *
	 * Note that the deadlock check interrupt had better not be enabled
	 * anywhere that this process itself holds lock partition locks, else this
	 * will wait forever.  Also note that LWLockAcquire creates a critical
	 * section, so that this routine cannot be interrupted by cancel/die
	 * interrupts.
	 */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>NUM_LOCK_PARTITIONS</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><call><name>LockHashPartitionLockByIndex</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>

	<comment type="block">/*
	 * Check to see if we've been awoken by anyone in the interim.
	 *
	 * If we have, we can return and resume our transaction -- happy day.
	 * Before we are awoken the process releasing the lock grants it to us so
	 * we know that we don't have to wait anymore.
	 *
	 * We check by looking to see if we've been unlinked from the wait queue.
	 * This is safe because we hold the lock partition lock.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>MyProc</name><operator>-&gt;</operator><name>links</name><operator>.</operator><name>prev</name></name> <operator>==</operator> <name>NULL</name> <operator>||</operator>
		<name><name>MyProc</name><operator>-&gt;</operator><name>links</name><operator>.</operator><name>next</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<goto>goto <name>check_done</name>;</goto></block_content></block></if></if_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>LOCK_DEBUG</name></cpp:ifdef>
	<if_stmt><if>if <condition>(<expr><name>Debug_deadlocks</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>DumpAllLocks</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<comment type="block">/* Run the deadlock check, and set deadlock_state for use by ProcSleep */</comment>
	<expr_stmt><expr><name>deadlock_state</name> <operator>=</operator> <call><name>DeadLockCheck</name><argument_list>(<argument><expr><name>MyProc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>deadlock_state</name> <operator>==</operator> <name>DS_HARD_DEADLOCK</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Oops.  We have a deadlock.
		 *
		 * Get this process out of wait state. (Note: we could do this more
		 * efficiently by relying on lockAwaited, but use this coding to
		 * preserve the flexibility to kill some other transaction than the
		 * one detecting the deadlock.)
		 *
		 * RemoveFromWaitQueue sets MyProc-&gt;waitStatus to STATUS_ERROR, so
		 * ProcSleep will report an error after we return from the signal
		 * handler.
		 */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>MyProc</name><operator>-&gt;</operator><name>waitLock</name></name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>RemoveFromWaitQueue</name><argument_list>(<argument><expr><name>MyProc</name></expr></argument>, <argument><expr><call><name>LockTagHashCode</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>MyProc</name><operator>-&gt;</operator><name>waitLock</name><operator>-&gt;</operator><name>tag</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * We're done here.  Transaction abort caused by the error that
		 * ProcSleep will raise will cause any other locks we hold to be
		 * released, thus allowing other processes to wake up; we don't need
		 * to do that here.  NOTE: an exception is that releasing locks we
		 * hold doesn't consider the possibility of waiters that were blocked
		 * behind us on the lock we just failed to get, and might now be
		 * wakable because we're not in front of them anymore.  However,
		 * RemoveFromWaitQueue took care of waking up any such processes.
		 */</comment>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * And release locks.  We do this in reverse order for two reasons: (1)
	 * Anyone else who needs more than one of the locks will be trying to lock
	 * them in increasing order; we don't want to release the other process
	 * until it can get all the locks it needs. (2) This avoids O(N^2)
	 * behavior inside LWLockRelease.
	 */</comment>
<label><name>check_done</name>:</label>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name>NUM_LOCK_PARTITIONS</name></expr>;</init> <condition><expr><operator>--</operator><name>i</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>;</condition><incr/>)</control><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><call><name>LockHashPartitionLockByIndex</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
</block_content>}</block></function>

<comment type="block">/*
 * CheckDeadLockAlert - Handle the expiry of deadlock_timeout.
 *
 * NB: Runs inside a signal handler, be careful.
 */</comment>
<function><type><name>void</name></type>
<name>CheckDeadLockAlert</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>save_errno</name> <init>= <expr><name>errno</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>got_deadlock_timeout</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Have to set the latch again, even if handle_sig_alarm already did. Back
	 * then got_deadlock_timeout wasn't yet set... It's unlikely that this
	 * ever would be a problem, but setting a set latch again is cheap.
	 */</comment>
	<expr_stmt><expr><call><name>SetLatch</name><argument_list>(<argument><expr><name>MyLatch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>errno</name> <operator>=</operator> <name>save_errno</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * ProcWaitForSignal - wait for a signal from another backend.
 *
 * As this uses the generic process latch the caller has to be robust against
 * unrelated wakeups: Always check that the desired state has occurred, and
 * wait again if not.
 */</comment>
<function><type><name>void</name></type>
<name>ProcWaitForSignal</name><parameter_list>(<parameter><decl><type><name>uint32</name></type> <name>wait_event_info</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WaitLatch</name><argument_list>(<argument><expr><name>MyLatch</name></expr></argument>, <argument><expr><name>WL_LATCH_SET</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>wait_event_info</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ResetLatch</name><argument_list>(<argument><expr><name>MyLatch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>CHECK_FOR_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * ProcSendSignal - send a signal to a backend identified by PID
 */</comment>
<function><type><name>void</name></type>
<name>ProcSendSignal</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>pid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PGPROC</name>	   <modifier>*</modifier></type><name>proc</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>RecoveryInProgress</name><argument_list>()</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>SpinLockAcquire</name><argument_list>(<argument><expr><name>ProcStructLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Check to see whether it is the Startup process we wish to signal.
		 * This call is made by the buffer manager when it wishes to wake up a
		 * process that has been waiting for a pin in so it can obtain a
		 * cleanup lock using LockBufferForCleanup(). Startup is not a normal
		 * backend, so BackendPidGetProc() will not return any pid at all. So
		 * we remember the information for this special case.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>pid</name> <operator>==</operator> <name><name>ProcGlobal</name><operator>-&gt;</operator><name>startupProcPid</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>proc</name> <operator>=</operator> <name><name>ProcGlobal</name><operator>-&gt;</operator><name>startupProc</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>SpinLockRelease</name><argument_list>(<argument><expr><name>ProcStructLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>proc</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>proc</name> <operator>=</operator> <call><name>BackendPidGetProc</name><argument_list>(<argument><expr><name>pid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>proc</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>SetLatch</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>proc</name><operator>-&gt;</operator><name>procLatch</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * BecomeLockGroupLeader - designate process as lock group leader
 *
 * Once this function has returned, other processes can join the lock group
 * by calling BecomeLockGroupMember.
 */</comment>
<function><type><name>void</name></type>
<name>BecomeLockGroupLeader</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>LWLock</name>	   <modifier>*</modifier></type><name>leader_lwlock</name></decl>;</decl_stmt>

	<comment type="block">/* If we already did it, we don't need to do it again. */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>MyProc</name><operator>-&gt;</operator><name>lockGroupLeader</name></name> <operator>==</operator> <name>MyProc</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/* We had better not be a follower. */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>MyProc</name><operator>-&gt;</operator><name>lockGroupLeader</name></name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Create single-member group, containing only ourselves. */</comment>
	<expr_stmt><expr><name>leader_lwlock</name> <operator>=</operator> <call><name>LockHashPartitionLockByProc</name><argument_list>(<argument><expr><name>MyProc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>leader_lwlock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>MyProc</name><operator>-&gt;</operator><name>lockGroupLeader</name></name> <operator>=</operator> <name>MyProc</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>dlist_push_head</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>MyProc</name><operator>-&gt;</operator><name>lockGroupMembers</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>MyProc</name><operator>-&gt;</operator><name>lockGroupLink</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>leader_lwlock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * BecomeLockGroupMember - designate process as lock group member
 *
 * This is pretty straightforward except for the possibility that the leader
 * whose group we're trying to join might exit before we manage to do so;
 * and the PGPROC might get recycled for an unrelated process.  To avoid
 * that, we require the caller to pass the PID of the intended PGPROC as
 * an interlock.  Returns true if we successfully join the intended lock
 * group, and false if not.
 */</comment>
<function><type><name>bool</name></type>
<name>BecomeLockGroupMember</name><parameter_list>(<parameter><decl><type><name>PGPROC</name> <modifier>*</modifier></type><name>leader</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>pid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>LWLock</name>	   <modifier>*</modifier></type><name>leader_lwlock</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>ok</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* Group leader can't become member of group */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>MyProc</name> <operator>!=</operator> <name>leader</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Can't already be a member of a group */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>MyProc</name><operator>-&gt;</operator><name>lockGroupLeader</name></name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* PID must be valid. */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>pid</name> <operator>!=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Get lock protecting the group fields.  Note LockHashPartitionLockByProc
	 * accesses leader-&gt;pgprocno in a PGPROC that might be free.  This is safe
	 * because all PGPROCs' pgprocno fields are set during shared memory
	 * initialization and never change thereafter; so we will acquire the
	 * correct lock even if the leader PGPROC is in process of being recycled.
	 */</comment>
	<expr_stmt><expr><name>leader_lwlock</name> <operator>=</operator> <call><name>LockHashPartitionLockByProc</name><argument_list>(<argument><expr><name>leader</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>leader_lwlock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Is this the leader we're looking for? */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>leader</name><operator>-&gt;</operator><name>pid</name></name> <operator>==</operator> <name>pid</name> <operator>&amp;&amp;</operator> <name><name>leader</name><operator>-&gt;</operator><name>lockGroupLeader</name></name> <operator>==</operator> <name>leader</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* OK, join the group */</comment>
		<expr_stmt><expr><name>ok</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>MyProc</name><operator>-&gt;</operator><name>lockGroupLeader</name></name> <operator>=</operator> <name>leader</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>dlist_push_tail</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>leader</name><operator>-&gt;</operator><name>lockGroupMembers</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>MyProc</name><operator>-&gt;</operator><name>lockGroupLink</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>leader_lwlock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>ok</name></expr>;</return>
</block_content>}</block></function>
</unit>
