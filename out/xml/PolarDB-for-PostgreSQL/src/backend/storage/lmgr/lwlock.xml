<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/PolarDB-for-PostgreSQL/src/backend/storage/lmgr/lwlock.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * lwlock.c
 *	  Lightweight lock manager
 *
 * Lightweight locks are intended primarily to provide mutual exclusion of
 * access to shared-memory data structures.  Therefore, they offer both
 * exclusive and shared lock modes (to support read/write and read-only
 * access to a shared object).  There are few other frammishes.  User-level
 * locking should be done with the full lock manager --- which depends on
 * LWLocks to protect its shared state.
 *
 * In addition to exclusive and shared modes, lightweight locks can be used to
 * wait until a variable changes value.  The variable is initially not set
 * when the lock is acquired with LWLockAcquire, i.e. it remains set to the
 * value it was set to when the lock was released last, and can be updated
 * without releasing the lock by calling LWLockUpdateVar.  LWLockWaitForVar
 * waits for the variable to be updated, or until the lock is free.  When
 * releasing the lock with LWLockReleaseClearVar() the value can be set to an
 * appropriate value for a free lock.  The meaning of the variable is up to
 * the caller, the lightweight lock code just assigns and compares it.
 *
 * Portions Copyright (c) 1996-2018, PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, Regents of the University of California
 *
 * IDENTIFICATION
 *	  src/backend/storage/lmgr/lwlock.c
 *
 * NOTES:
 *
 * This used to be a pretty straight forward reader-writer lock
 * implementation, in which the internal state was protected by a
 * spinlock. Unfortunately the overhead of taking the spinlock proved to be
 * too high for workloads/locks that were taken in shared mode very
 * frequently. Often we were spinning in the (obviously exclusive) spinlock,
 * while trying to acquire a shared lock that was actually free.
 *
 * Thus a new implementation was devised that provides wait-free shared lock
 * acquisition for locks that aren't exclusively locked.
 *
 * The basic idea is to have a single atomic variable 'lockcount' instead of
 * the formerly separate shared and exclusive counters and to use atomic
 * operations to acquire the lock. That's fairly easy to do for plain
 * rw-spinlocks, but a lot harder for something like LWLocks that want to wait
 * in the OS.
 *
 * For lock acquisition we use an atomic compare-and-exchange on the lockcount
 * variable. For exclusive lock we swap in a sentinel value
 * (LW_VAL_EXCLUSIVE), for shared locks we count the number of holders.
 *
 * To release the lock we use an atomic decrement to release the lock. If the
 * new value is zero (we get that atomically), we know we can/have to release
 * waiters.
 *
 * Obviously it is important that the sentinel value for exclusive locks
 * doesn't conflict with the maximum number of possible share lockers -
 * luckily MAX_BACKENDS makes that easily possible.
 *
 *
 * The attentive reader might have noticed that naively doing the above has a
 * glaring race condition: We try to lock using the atomic operations and
 * notice that we have to wait. Unfortunately by the time we have finished
 * queuing, the former locker very well might have already finished it's
 * work. That's problematic because we're now stuck waiting inside the OS.

 * To mitigate those races we use a two phased attempt at locking:
 *	 Phase 1: Try to do it atomically, if we succeed, nice
 *	 Phase 2: Add ourselves to the waitqueue of the lock
 *	 Phase 3: Try to grab the lock again, if we succeed, remove ourselves from
 *			  the queue
 *	 Phase 4: Sleep till wake-up, goto Phase 1
 *
 * This protects us against the problem from above as nobody can release too
 *	  quick, before we're queued, since after Phase 2 we're already queued.
 * -------------------------------------------------------------------------
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pgstat.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pg_trace.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postmaster/postmaster.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"replication/slot.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/ipc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/predicate.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/proc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/proclist.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/spin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/memutils.h"</cpp:file></cpp:include>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>LWLOCK_STATS</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/hsearch.h"</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* POLAR */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/polar_lock_stats.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/guc.h"</cpp:file></cpp:include>
<comment type="block">/* POLAR end */</comment>

<comment type="block">/* We use the ShmemLock spinlock to protect LWLockCounter */</comment>
<decl_stmt><decl><type><specifier>extern</specifier> <name>slock_t</name> <modifier>*</modifier></type><name>ShmemLock</name></decl>;</decl_stmt>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LW_FLAG_HAS_WAITERS</name></cpp:macro>			<cpp:value>((uint32) 1 &lt;&lt; 30)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LW_FLAG_RELEASE_OK</name></cpp:macro>			<cpp:value>((uint32) 1 &lt;&lt; 29)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LW_FLAG_LOCKED</name></cpp:macro>				<cpp:value>((uint32) 1 &lt;&lt; 28)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LW_VAL_EXCLUSIVE</name></cpp:macro>			<cpp:value>((uint32) 1 &lt;&lt; 24)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LW_VAL_SHARED</name></cpp:macro>				<cpp:value>1</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LW_LOCK_MASK</name></cpp:macro>				<cpp:value>((uint32) ((1 &lt;&lt; 25)-1))</cpp:value></cpp:define>
<comment type="block">/* Must be greater than MAX_BACKENDS - which is 2^23-1, so we're fine. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LW_SHARED_MASK</name></cpp:macro>				<cpp:value>((uint32) ((1 &lt;&lt; 24)-1))</cpp:value></cpp:define>

<comment type="block">/*
 * This is indexed by tranche ID and stores the names of all tranches known
 * to the current backend.
 */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>LWLockTrancheArray</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type>	<name>LWLockTranchesAllocated</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>T_NAME</name><parameter_list>(<parameter><type><name>lock</name></type></parameter>)</parameter_list></cpp:macro> \
	<cpp:value>(LWLockTrancheArray[(lock)-&gt;tranche])</cpp:value></cpp:define>

<comment type="block">/*
 * This points to the main array of LWLocks in shared memory.  Backends inherit
 * the pointer by fork from the postmaster (except in the EXEC_BACKEND case,
 * where we have special measures to pass it down).
 */</comment>
<decl_stmt><decl><type><name>LWLockPadded</name> <modifier>*</modifier></type><name>MainLWLockArray</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>LWLockPadded</name> <modifier>*</modifier></type><name>SysLoggerWriterLWLockArray</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt> 

<comment type="block">/*
 * We use this structure to keep track of locked LWLocks for release
 * during error recovery.  Normally, only a few will be held at once, but
 * occasionally the number can be much higher; for example, the pg_buffercache
 * extension locks all buffer partitions simultaneously.
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MAX_SIMUL_LWLOCKS</name></cpp:macro>	<cpp:value>200</cpp:value></cpp:define>

<comment type="block">/* struct representing the LWLocks we're holding */</comment>
<typedef>typedef <type><struct>struct <name>LWLockHandle</name>
<block>{
	<decl_stmt><decl><type><name>LWLock</name>	   <modifier>*</modifier></type><name>lock</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>LWLockMode</name></type>	<name>mode</name></decl>;</decl_stmt>
}</block></struct></type> <name>LWLockHandle</name>;</typedef>

<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type>	<name>num_held_lwlocks</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>LWLockHandle</name></type> <name><name>held_lwlocks</name><index>[<expr><name>MAX_SIMUL_LWLOCKS</name></expr>]</index></name></decl>;</decl_stmt>

<comment type="block">/* struct representing the LWLock tranche request for named tranche */</comment>
<typedef>typedef <type><struct>struct <name>NamedLWLockTrancheRequest</name>
<block>{
	<decl_stmt><decl><type><name>char</name></type>		<name><name>tranche_name</name><index>[<expr><name>NAMEDATALEN</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>num_lwlocks</name></decl>;</decl_stmt>
}</block></struct></type> <name>NamedLWLockTrancheRequest</name>;</typedef>

<decl_stmt><decl><type><name>NamedLWLockTrancheRequest</name> <modifier>*</modifier></type><name>NamedLWLockTrancheRequestArray</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type>	<name>NamedLWLockTrancheRequestsAllocated</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type>			<name>NamedLWLockTrancheRequests</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>NamedLWLockTranche</name> <modifier>*</modifier></type><name>NamedLWLockTrancheArray</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type> <name>lock_named_request_allowed</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>InitializeLWLocks</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>RegisterLWLockTranches</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type> <name>LWLockReportWaitStart</name><parameter_list>(<parameter><decl><type><name>LWLock</name> <modifier>*</modifier></type><name>lock</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type> <name>LWLockReportWaitEnd</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>LWLOCK_STATS</name></cpp:ifdef>
<typedef>typedef <type><struct>struct <name>lwlock_stats_key</name>
<block>{
	<decl_stmt><decl><type><name>int</name></type>			<name>tranche</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>void</name>	   <modifier>*</modifier></type><name>instance</name></decl>;</decl_stmt>
}</block></struct></type>			<name>lwlock_stats_key</name>;</typedef>

<typedef>typedef <type><struct>struct <name>lwlock_stats</name>
<block>{
	<decl_stmt><decl><type><name>lwlock_stats_key</name></type> <name>key</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>sh_acquire_count</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>ex_acquire_count</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>block_count</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>dequeue_self_count</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>spin_delay_count</name></decl>;</decl_stmt>
}</block></struct></type>			<name>lwlock_stats</name>;</typedef>

<decl_stmt><decl><type><specifier>static</specifier> <name>HTAB</name> <modifier>*</modifier></type><name>lwlock_stats_htab</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>lwlock_stats</name></type> <name>lwlock_stats_dummy</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>LWLOCK_DEBUG</name></cpp:ifdef>
<decl_stmt><decl><type><name>bool</name></type>		<name>Trace_lwlocks</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

<function><type><specifier>inline</specifier> <specifier>static</specifier> <name>void</name></type>
<name>PRINT_LWDEBUG</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>where</name></decl></parameter>, <parameter><decl><type><name>LWLock</name> <modifier>*</modifier></type><name>lock</name></decl></parameter>, <parameter><decl><type><name>LWLockMode</name></type> <name>mode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* hide statement &amp; context here, otherwise the log is just too verbose */</comment>
	<if_stmt><if>if <condition>(<expr><name>Trace_lwlocks</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>uint32</name></type>		<name>state</name> <init>= <expr><call><name>pg_atomic_read_u32</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>lock</name><operator>-&gt;</operator><name>state</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errhidestmt</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errhidecontext</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg_internal</name><argument_list>(<argument><expr><literal type="string">"%d: %s(%s %p): excl %u shared %u haswaiters %u waiters %u rOK %d"</literal></expr></argument>,
								 <argument><expr><name>MyProcPid</name></expr></argument>,
								 <argument><expr><name>where</name></expr></argument>, <argument><expr><call><name>T_NAME</name><argument_list>(<argument><expr><name>lock</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>lock</name></expr></argument>,
								 <argument><expr><operator>(</operator><name>state</name> <operator>&amp;</operator> <name>LW_VAL_EXCLUSIVE</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr></argument>,
								 <argument><expr><name>state</name> <operator>&amp;</operator> <name>LW_SHARED_MASK</name></expr></argument>,
								 <argument><expr><operator>(</operator><name>state</name> <operator>&amp;</operator> <name>LW_FLAG_HAS_WAITERS</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr></argument>,
								 <argument><expr><call><name>pg_atomic_read_u32</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>lock</name><operator>-&gt;</operator><name>nwaiters</name></name></expr></argument>)</argument_list></call></expr></argument>,
								 <argument><expr><operator>(</operator><name>state</name> <operator>&amp;</operator> <name>LW_FLAG_RELEASE_OK</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>inline</specifier> <specifier>static</specifier> <name>void</name></type>
<name>LOG_LWDEBUG</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>where</name></decl></parameter>, <parameter><decl><type><name>LWLock</name> <modifier>*</modifier></type><name>lock</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>msg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* hide statement &amp; context here, otherwise the log is just too verbose */</comment>
	<if_stmt><if>if <condition>(<expr><name>Trace_lwlocks</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errhidestmt</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errhidecontext</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg_internal</name><argument_list>(<argument><expr><literal type="string">"%s(%s %p): %s"</literal></expr></argument>, <argument><expr><name>where</name></expr></argument>,
								 <argument><expr><call><name>T_NAME</name><argument_list>(<argument><expr><name>lock</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>lock</name></expr></argument>, <argument><expr><name>msg</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>							<comment type="block">/* not LWLOCK_DEBUG */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PRINT_LWDEBUG</name><parameter_list>(<parameter><type><name>a</name></type></parameter>,<parameter><type><name>b</name></type></parameter>,<parameter><type><name>c</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((void)0)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LOG_LWDEBUG</name><parameter_list>(<parameter><type><name>a</name></type></parameter>,<parameter><type><name>b</name></type></parameter>,<parameter><type><name>c</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((void)0)</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>							<comment type="block">/* LWLOCK_DEBUG */</comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>LWLOCK_STATS</name></cpp:ifdef>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>init_lwlock_stats</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>print_lwlock_stats</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>code</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>arg</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>lwlock_stats</name> <modifier>*</modifier></type> <name>get_lwlock_stats_entry</name><parameter_list>(<parameter><decl><type><name>LWLock</name> <modifier>*</modifier></type><name>lockid</name></decl></parameter>)</parameter_list>;</function_decl>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>init_lwlock_stats</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HASHCTL</name></type>		<name>ctl</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>static</specifier> <name>MemoryContext</name></type> <name>lwlock_stats_cxt</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type> <name>exit_registered</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>lwlock_stats_cxt</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>MemoryContextDelete</name><argument_list>(<argument><expr><name>lwlock_stats_cxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * The LWLock stats will be updated within a critical section, which
	 * requires allocating new hash entries. Allocations within a critical
	 * section are normally not allowed because running out of memory would
	 * lead to a PANIC, but LWLOCK_STATS is debugging code that's not normally
	 * turned on in production, so that's an acceptable risk. The hash entries
	 * are small, so the risk of running out of memory is minimal in practice.
	 */</comment>
	<expr_stmt><expr><name>lwlock_stats_cxt</name> <operator>=</operator> <call><name>AllocSetContextCreate</name><argument_list>(<argument><expr><name>TopMemoryContext</name></expr></argument>,
											 <argument><expr><literal type="string">"LWLock stats"</literal></expr></argument>,
											 <argument><expr><name>ALLOCSET_DEFAULT_SIZES</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>MemoryContextAllowInCriticalSection</name><argument_list>(<argument><expr><name>lwlock_stats_cxt</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ctl</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ctl</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ctl</name><operator>.</operator><name>keysize</name></name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>lwlock_stats_key</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ctl</name><operator>.</operator><name>entrysize</name></name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>lwlock_stats</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ctl</name><operator>.</operator><name>hcxt</name></name> <operator>=</operator> <name>lwlock_stats_cxt</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>lwlock_stats_htab</name> <operator>=</operator> <call><name>hash_create</name><argument_list>(<argument><expr><literal type="string">"lwlock stats"</literal></expr></argument>, <argument><expr><literal type="number">16384</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>ctl</name></expr></argument>,
									<argument><expr><name>HASH_ELEM</name> <operator>|</operator> <name>HASH_BLOBS</name> <operator>|</operator> <name>HASH_CONTEXT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>exit_registered</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>on_shmem_exit</name><argument_list>(<argument><expr><name>print_lwlock_stats</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>exit_registered</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>print_lwlock_stats</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>code</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HASH_SEQ_STATUS</name></type> <name>scan</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>lwlock_stats</name> <modifier>*</modifier></type><name>lwstats</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>hash_seq_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>scan</name></expr></argument>, <argument><expr><name>lwlock_stats_htab</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Grab an LWLock to keep different backends from mixing reports */</comment>
	<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>MainLWLockArray</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>lock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<while>while <condition>(<expr><operator>(</operator><name>lwstats</name> <operator>=</operator> <operator>(</operator><name>lwlock_stats</name> <operator>*</operator><operator>)</operator> <call><name>hash_seq_search</name><argument_list>(<argument><expr><operator>&amp;</operator><name>scan</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>,
				<argument><expr><literal type="string">"PID %d lwlock %s %p: shacq %u exacq %u blk %u spindelay %u dequeue self %u\n"</literal></expr></argument>,
				<argument><expr><name>MyProcPid</name></expr></argument>, <argument><expr><name><name>LWLockTrancheArray</name><index>[<expr><name><name>lwstats</name><operator>-&gt;</operator><name>key</name><operator>.</operator><name>tranche</name></name></expr>]</index></name></expr></argument>,
				<argument><expr><name><name>lwstats</name><operator>-&gt;</operator><name>key</name><operator>.</operator><name>instance</name></name></expr></argument>, <argument><expr><name><name>lwstats</name><operator>-&gt;</operator><name>sh_acquire_count</name></name></expr></argument>,
				<argument><expr><name><name>lwstats</name><operator>-&gt;</operator><name>ex_acquire_count</name></name></expr></argument>, <argument><expr><name><name>lwstats</name><operator>-&gt;</operator><name>block_count</name></name></expr></argument>,
				<argument><expr><name><name>lwstats</name><operator>-&gt;</operator><name>spin_delay_count</name></name></expr></argument>, <argument><expr><name><name>lwstats</name><operator>-&gt;</operator><name>dequeue_self_count</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></while>

	<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>MainLWLockArray</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>lock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>lwlock_stats</name> <modifier>*</modifier></type>
<name>get_lwlock_stats_entry</name><parameter_list>(<parameter><decl><type><name>LWLock</name> <modifier>*</modifier></type><name>lock</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>lwlock_stats_key</name></type> <name>key</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>lwlock_stats</name> <modifier>*</modifier></type><name>lwstats</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>found</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * During shared memory initialization, the hash table doesn't exist yet.
	 * Stats of that phase aren't very interesting, so just collect operations
	 * on all locks in a single dummy entry.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>lwlock_stats_htab</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><operator>&amp;</operator><name>lwlock_stats_dummy</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* Fetch or create the entry. */</comment>
	<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><operator>&amp;</operator><name>key</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>key</name><operator>.</operator><name>tranche</name></name> <operator>=</operator> <name><name>lock</name><operator>-&gt;</operator><name>tranche</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>key</name><operator>.</operator><name>instance</name></name> <operator>=</operator> <name>lock</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>lwstats</name> <operator>=</operator> <call><name>hash_search</name><argument_list>(<argument><expr><name>lwlock_stats_htab</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>key</name></expr></argument>, <argument><expr><name>HASH_ENTER</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>found</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>lwstats</name><operator>-&gt;</operator><name>sh_acquire_count</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>lwstats</name><operator>-&gt;</operator><name>ex_acquire_count</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>lwstats</name><operator>-&gt;</operator><name>block_count</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>lwstats</name><operator>-&gt;</operator><name>dequeue_self_count</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>lwstats</name><operator>-&gt;</operator><name>spin_delay_count</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><name>lwstats</name></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>							<comment type="block">/* LWLOCK_STATS */</comment>


<comment type="block">/*
 * Compute number of LWLocks required by named tranches.  These will be
 * allocated in the main array.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>NumLWLocksByNamedTranches</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>numLocks</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>NamedLWLockTrancheRequests</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
		<expr_stmt><expr><name>numLocks</name> <operator>+=</operator> <name><name>NamedLWLockTrancheRequestArray</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>num_lwlocks</name></expr>;</expr_stmt></block_content></block></for>

	<return>return <expr><name>numLocks</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Compute shmem space needed for LWLocks and named tranches.
 */</comment>
<function><type><name>Size</name></type>
<name>LWLockShmemSize</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Size</name></type>		<name>size</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>numLocks</name> <init>= <expr><name>NUM_FIXED_LWLOCKS</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>numLocks</name> <operator>+=</operator> <call><name>NumLWLocksByNamedTranches</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Space for the LWLock array. */</comment>
	<expr_stmt><expr><name>size</name> <operator>=</operator> <call><name>mul_size</name><argument_list>(<argument><expr><name>numLocks</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>LWLockPadded</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Space for dynamic allocation counter, plus room for alignment. */</comment>
	<expr_stmt><expr><name>size</name> <operator>=</operator> <call><name>add_size</name><argument_list>(<argument><expr><name>size</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <name>LWLOCK_PADDED_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* space for named tranches. */</comment>
	<expr_stmt><expr><name>size</name> <operator>=</operator> <call><name>add_size</name><argument_list>(<argument><expr><name>size</name></expr></argument>, <argument><expr><call><name>mul_size</name><argument_list>(<argument><expr><name>NamedLWLockTrancheRequests</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>NamedLWLockTranche</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* space for name of each tranche. */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>NamedLWLockTrancheRequests</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
		<expr_stmt><expr><name>size</name> <operator>=</operator> <call><name>add_size</name><argument_list>(<argument><expr><name>size</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name><name>NamedLWLockTrancheRequestArray</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>tranche_name</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>

	<comment type="block">/* Disallow named LWLocks' requests after startup */</comment>
	<expr_stmt><expr><name>lock_named_request_allowed</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<return>return <expr><name>size</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Allocate shmem space for the main LWLock array and all tranches and
 * initialize it.  We also register all the LWLock tranches here.
 */</comment>
<function><type><name>void</name></type>
<name>CreateLWLocks</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>StaticAssertStmt</name><argument_list>(<argument><expr><name>LW_VAL_EXCLUSIVE</name> <operator>&gt;</operator> <operator>(</operator><name>uint32</name><operator>)</operator> <name>MAX_BACKENDS</name></expr></argument>,
					 <argument><expr><literal type="string">"MAX_BACKENDS too big for lwlock.c"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>StaticAssertStmt</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>LWLock</name></expr></argument>)</argument_list></sizeof> <operator>&lt;=</operator> <name>LWLOCK_MINIMAL_SIZE</name> <operator>&amp;&amp;</operator>
					 <sizeof>sizeof<argument_list>(<argument><expr><name>LWLock</name></expr></argument>)</argument_list></sizeof> <operator>&lt;=</operator> <name>LWLOCK_PADDED_SIZE</name></expr></argument>,
					 <argument><expr><literal type="string">"Miscalculated LWLock padding"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>IsUnderPostmaster</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Size</name></type>		<name>spaceLocks</name> <init>= <expr><call><name>LWLockShmemSize</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name>		   <modifier>*</modifier></type><name>LWLockCounter</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>ptr</name></decl>;</decl_stmt>

		<comment type="block">/* Allocate space */</comment>
		<expr_stmt><expr><name>ptr</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>ShmemAlloc</name><argument_list>(<argument><expr><name>spaceLocks</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Leave room for dynamic allocation of tranches */</comment>
		<expr_stmt><expr><name>ptr</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>

		<comment type="block">/* Ensure desired alignment of LWLock array */</comment>
		<expr_stmt><expr><name>ptr</name> <operator>+=</operator> <name>LWLOCK_PADDED_SIZE</name> <operator>-</operator> <operator>(</operator><operator>(</operator><name>uintptr_t</name><operator>)</operator> <name>ptr</name><operator>)</operator> <operator>%</operator> <name>LWLOCK_PADDED_SIZE</name></expr>;</expr_stmt>

		<expr_stmt><expr><name>MainLWLockArray</name> <operator>=</operator> <operator>(</operator><name>LWLockPadded</name> <operator>*</operator><operator>)</operator> <name>ptr</name></expr>;</expr_stmt>

		<comment type="block">/*
		 * Initialize the dynamic-allocation counter for tranches, which is
		 * stored just before the first LWLock.
		 */</comment>
		<expr_stmt><expr><name>LWLockCounter</name> <operator>=</operator> <operator>(</operator><name>int</name> <operator>*</operator><operator>)</operator> <operator>(</operator><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>MainLWLockArray</name> <operator>-</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof><operator>)</operator></expr>;</expr_stmt>
		<expr_stmt><expr><operator>*</operator><name>LWLockCounter</name> <operator>=</operator> <name>LWTRANCHE_FIRST_USER_DEFINED</name></expr>;</expr_stmt>

		<comment type="block">/* Initialize all LWLocks */</comment>
		<expr_stmt><expr><call><name>InitializeLWLocks</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Register all LWLock tranches */</comment>
	<expr_stmt><expr><call><name>RegisterLWLockTranches</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Initialize LWLocks that are fixed and those belonging to named tranches.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>InitializeLWLocks</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>numNamedLocks</name> <init>= <expr><call><name>NumLWLocksByNamedTranches</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>id</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>j</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>LWLockPadded</name> <modifier>*</modifier></type><name>lock</name></decl>;</decl_stmt>

	<comment type="block">/* Initialize all individual LWLocks in main array */</comment>
	<for>for <control>(<init><expr><name>id</name> <operator>=</operator> <literal type="number">0</literal></expr><operator>,</operator> <expr><name>lock</name> <operator>=</operator> <name>MainLWLockArray</name></expr>;</init> <condition><expr><name>id</name> <operator>&lt;</operator> <name>NUM_INDIVIDUAL_LWLOCKS</name></expr>;</condition> <incr><expr><name>id</name><operator>++</operator></expr><operator>,</operator> <expr><name>lock</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>LWLockInitialize</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>lock</name><operator>-&gt;</operator><name>lock</name></name></expr></argument>, <argument><expr><name>id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>

	<comment type="block">/* Initialize buffer mapping LWLocks in main array */</comment>
	<expr_stmt><expr><name>lock</name> <operator>=</operator> <name>MainLWLockArray</name> <operator>+</operator> <name>NUM_INDIVIDUAL_LWLOCKS</name></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>id</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>id</name> <operator>&lt;</operator> <name>NUM_BUFFER_PARTITIONS</name></expr>;</condition> <incr><expr><name>id</name><operator>++</operator></expr><operator>,</operator> <expr><name>lock</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>LWLockInitialize</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>lock</name><operator>-&gt;</operator><name>lock</name></name></expr></argument>, <argument><expr><name>LWTRANCHE_BUFFER_MAPPING</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>

	<comment type="block">/* Initialize lmgrs' LWLocks in main array */</comment>
	<expr_stmt><expr><name>lock</name> <operator>=</operator> <name>MainLWLockArray</name> <operator>+</operator> <name>NUM_INDIVIDUAL_LWLOCKS</name> <operator>+</operator> <name>NUM_BUFFER_PARTITIONS</name></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>id</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>id</name> <operator>&lt;</operator> <name>NUM_LOCK_PARTITIONS</name></expr>;</condition> <incr><expr><name>id</name><operator>++</operator></expr><operator>,</operator> <expr><name>lock</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>LWLockInitialize</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>lock</name><operator>-&gt;</operator><name>lock</name></name></expr></argument>, <argument><expr><name>LWTRANCHE_LOCK_MANAGER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>

	<comment type="block">/* Initialize predicate lmgrs' LWLocks in main array */</comment>
	<expr_stmt><expr><name>lock</name> <operator>=</operator> <name>MainLWLockArray</name> <operator>+</operator> <name>NUM_INDIVIDUAL_LWLOCKS</name> <operator>+</operator>
		<name>NUM_BUFFER_PARTITIONS</name> <operator>+</operator> <name>NUM_LOCK_PARTITIONS</name></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>id</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>id</name> <operator>&lt;</operator> <name>NUM_PREDICATELOCK_PARTITIONS</name></expr>;</condition> <incr><expr><name>id</name><operator>++</operator></expr><operator>,</operator> <expr><name>lock</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>LWLockInitialize</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>lock</name><operator>-&gt;</operator><name>lock</name></name></expr></argument>, <argument><expr><name>LWTRANCHE_PREDICATE_LOCK_MANAGER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>

	<comment type="block">/* Initialize syslogger write LWLocks  */</comment>
	<expr_stmt><expr><name>lock</name> <operator>=</operator> <name>MainLWLockArray</name> <operator>+</operator> <name>NUM_INDIVIDUAL_LWLOCKS</name> <operator>+</operator>
		<name>NUM_BUFFER_PARTITIONS</name> <operator>+</operator> <name>NUM_LOCK_PARTITIONS</name> <operator>+</operator> <name>NUM_PREDICATELOCK_PARTITIONS</name></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>id</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>id</name> <operator>&lt;</operator> <name>MAX_SYSLOGGER_LOCK_NUM</name></expr>;</condition> <incr><expr><name>id</name><operator>++</operator></expr><operator>,</operator> <expr><name>lock</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>LWLockInitialize</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>lock</name><operator>-&gt;</operator><name>lock</name></name></expr></argument>, <argument><expr><name>LWTRANCHE_SYSLOGGER_WRITER_MAPPING</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
    <expr_stmt><expr><name>SysLoggerWriterLWLockArray</name> <operator>=</operator> <name>MainLWLockArray</name> <operator>+</operator> <name>NUM_INDIVIDUAL_LWLOCKS</name> <operator>+</operator> 
		<name>NUM_BUFFER_PARTITIONS</name> <operator>+</operator> <name>NUM_LOCK_PARTITIONS</name> <operator>+</operator> <name>NUM_PREDICATELOCK_PARTITIONS</name></expr>;</expr_stmt>

	<comment type="block">/* POLAR end */</comment>

	<expr_stmt><expr><name>lock</name> <operator>=</operator> <name>MainLWLockArray</name> <operator>+</operator> <name>NUM_INDIVIDUAL_LWLOCKS</name> <operator>+</operator>
		<name>NUM_BUFFER_PARTITIONS</name> <operator>+</operator> <name>NUM_LOCK_PARTITIONS</name> <operator>+</operator> <name>NUM_PREDICATELOCK_PARTITIONS</name> <operator>+</operator>
		<name>MAX_SYSLOGGER_LOCK_NUM</name></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>id</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>id</name> <operator>&lt;</operator> <name>SR_PARTITIONS</name></expr>;</condition> <incr><expr><name>id</name><operator>++</operator></expr><operator>,</operator> <expr><name>lock</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>LWLockInitialize</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>lock</name><operator>-&gt;</operator><name>lock</name></name></expr></argument>, <argument><expr><name>LWTRANCHE_SR_LOCKS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>

	<comment type="block">/* Initialize named tranches. */</comment>
	<if_stmt><if>if <condition>(<expr><name>NamedLWLockTrancheRequests</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>trancheNames</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>NamedLWLockTrancheArray</name> <operator>=</operator> <operator>(</operator><name>NamedLWLockTranche</name> <operator>*</operator><operator>)</operator>
			<operator>&amp;</operator><name><name>MainLWLockArray</name><index>[<expr><name>NUM_FIXED_LWLOCKS</name> <operator>+</operator> <name>numNamedLocks</name></expr>]</index></name></expr>;</expr_stmt>

		<expr_stmt><expr><name>trancheNames</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>NamedLWLockTrancheArray</name> <operator>+</operator>
			<operator>(</operator><name>NamedLWLockTrancheRequests</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>NamedLWLockTranche</name></expr></argument>)</argument_list></sizeof><operator>)</operator></expr>;</expr_stmt>
		<expr_stmt><expr><name>lock</name> <operator>=</operator> <operator>&amp;</operator><name><name>MainLWLockArray</name><index>[<expr><name>NUM_FIXED_LWLOCKS</name></expr>]</index></name></expr>;</expr_stmt>

		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>NamedLWLockTrancheRequests</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>NamedLWLockTrancheRequest</name> <modifier>*</modifier></type><name>request</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>NamedLWLockTranche</name> <modifier>*</modifier></type><name>tranche</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>name</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>request</name> <operator>=</operator> <operator>&amp;</operator><name><name>NamedLWLockTrancheRequestArray</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
			<expr_stmt><expr><name>tranche</name> <operator>=</operator> <operator>&amp;</operator><name><name>NamedLWLockTrancheArray</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>

			<expr_stmt><expr><name>name</name> <operator>=</operator> <name>trancheNames</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>trancheNames</name> <operator>+=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name><name>request</name><operator>-&gt;</operator><name>tranche_name</name></name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name><name>request</name><operator>-&gt;</operator><name>tranche_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>tranche</name><operator>-&gt;</operator><name>trancheId</name></name> <operator>=</operator> <call><name>LWLockNewTrancheId</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>tranche</name><operator>-&gt;</operator><name>trancheName</name></name> <operator>=</operator> <name>name</name></expr>;</expr_stmt>

			<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name><name>request</name><operator>-&gt;</operator><name>num_lwlocks</name></name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr><operator>,</operator> <expr><name>lock</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>LWLockInitialize</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>lock</name><operator>-&gt;</operator><name>lock</name></name></expr></argument>, <argument><expr><name><name>tranche</name><operator>-&gt;</operator><name>trancheId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
		</block_content>}</block></for>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Register named tranches and tranches for fixed LWLocks.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>RegisterLWLockTranches</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>LWLockTrancheArray</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>LWLockTranchesAllocated</name> <operator>=</operator> <literal type="number">128</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name>LWLockTrancheArray</name> <operator>=</operator> <operator>(</operator><specifier>const</specifier> <name>char</name> <operator>*</operator><operator>*</operator><operator>)</operator>
			<call><name>MemoryContextAllocZero</name><argument_list>(<argument><expr><name>TopMemoryContext</name></expr></argument>,
								   <argument><expr><name>LWLockTranchesAllocated</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>char</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>LWLockTranchesAllocated</name> <operator>&gt;=</operator> <name>LWTRANCHE_FIRST_USER_DEFINED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>NUM_INDIVIDUAL_LWLOCKS</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>LWLockRegisterTranche</name><argument_list>(<argument><expr><name>i</name></expr></argument>, <argument><expr><name><name>MainLWLockNames</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>

	<expr_stmt><expr><call><name>LWLockRegisterTranche</name><argument_list>(<argument><expr><name>LWTRANCHE_BUFFER_MAPPING</name></expr></argument>, <argument><expr><literal type="string">"buffer_mapping"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* POLAR: register syslog_write tranche */</comment>
	<expr_stmt><expr><call><name>LWLockRegisterTranche</name><argument_list>(<argument><expr><name>LWTRANCHE_SYSLOGGER_WRITER_MAPPING</name></expr></argument>, <argument><expr><literal type="string">"syslog_write"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* POLAR end */</comment>
	<expr_stmt><expr><call><name>LWLockRegisterTranche</name><argument_list>(<argument><expr><name>LWTRANCHE_SR_LOCKS</name></expr></argument>, <argument><expr><literal type="string">"sr_locks"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>LWLockRegisterTranche</name><argument_list>(<argument><expr><name>LWTRANCHE_LOCK_MANAGER</name></expr></argument>, <argument><expr><literal type="string">"lock_manager"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>LWLockRegisterTranche</name><argument_list>(<argument><expr><name>LWTRANCHE_PREDICATE_LOCK_MANAGER</name></expr></argument>,
						  <argument><expr><literal type="string">"predicate_lock_manager"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>LWLockRegisterTranche</name><argument_list>(<argument><expr><name>LWTRANCHE_PARALLEL_QUERY_DSA</name></expr></argument>,
						  <argument><expr><literal type="string">"parallel_query_dsa"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>LWLockRegisterTranche</name><argument_list>(<argument><expr><name>LWTRANCHE_SESSION_DSA</name></expr></argument>,
						  <argument><expr><literal type="string">"session_dsa"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>LWLockRegisterTranche</name><argument_list>(<argument><expr><name>LWTRANCHE_SESSION_RECORD_TABLE</name></expr></argument>,
						  <argument><expr><literal type="string">"session_record_table"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>LWLockRegisterTranche</name><argument_list>(<argument><expr><name>LWTRANCHE_SESSION_TYPMOD_TABLE</name></expr></argument>,
						  <argument><expr><literal type="string">"session_typmod_table"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>LWLockRegisterTranche</name><argument_list>(<argument><expr><name>LWTRANCHE_SHARED_TUPLESTORE</name></expr></argument>,
						  <argument><expr><literal type="string">"shared_tuplestore"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>LWLockRegisterTranche</name><argument_list>(<argument><expr><name>LWTRANCHE_TBM</name></expr></argument>, <argument><expr><literal type="string">"tbm"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>LWLockRegisterTranche</name><argument_list>(<argument><expr><name>LWTRANCHE_PARALLEL_APPEND</name></expr></argument>, <argument><expr><literal type="string">"parallel_append"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>LWLockRegisterTranche</name><argument_list>(<argument><expr><name>LWTRANCHE_PARALLEL_HASH_JOIN</name></expr></argument>, <argument><expr><literal type="string">"parallel_hash_join"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Register named tranches. */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>NamedLWLockTrancheRequests</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>LWLockRegisterTranche</name><argument_list>(<argument><expr><name><name>NamedLWLockTrancheArray</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>trancheId</name></expr></argument>,
							  <argument><expr><name><name>NamedLWLockTrancheArray</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>trancheName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
</block_content>}</block></function>

<comment type="block">/*
 * InitLWLockAccess - initialize backend-local state needed to hold LWLocks
 */</comment>
<function><type><name>void</name></type>
<name>InitLWLockAccess</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>LWLOCK_STATS</name></cpp:ifdef>
	<expr_stmt><expr><call><name>init_lwlock_stats</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<comment type="block">/* POLAR: init lwlock local stats */</comment>
	<expr_stmt><expr><call><name>polar_init_lwlock_local_stats</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* POLAR end */</comment>
</block_content>}</block></function>

<comment type="block">/*
 * GetNamedLWLockTranche - returns the base address of LWLock from the
 *		specified tranche.
 *
 * Caller needs to retrieve the requested number of LWLocks starting from
 * the base lock address returned by this API.  This can be used for
 * tranches that are requested by using RequestNamedLWLockTranche() API.
 */</comment>
<function><type><name>LWLockPadded</name> <modifier>*</modifier></type>
<name>GetNamedLWLockTranche</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>tranche_name</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>lock_pos</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Obtain the position of base address of LWLock belonging to requested
	 * tranche_name in MainLWLockArray.  LWLocks for named tranches are placed
	 * in MainLWLockArray after fixed locks.
	 */</comment>
	<expr_stmt><expr><name>lock_pos</name> <operator>=</operator> <name>NUM_FIXED_LWLOCKS</name></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>NamedLWLockTrancheRequests</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>NamedLWLockTrancheRequestArray</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>tranche_name</name></expr></argument>,
				   <argument><expr><name>tranche_name</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><operator>&amp;</operator><name><name>MainLWLockArray</name><index>[<expr><name>lock_pos</name></expr>]</index></name></expr>;</return></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>lock_pos</name> <operator>+=</operator> <name><name>NamedLWLockTrancheRequestArray</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>num_lwlocks</name></expr>;</expr_stmt>
	</block_content>}</block></for>

	<if_stmt><if>if <condition>(<expr><name>i</name> <operator>&gt;=</operator> <name>NamedLWLockTrancheRequests</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"requested tranche is not registered"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* just to keep compiler quiet */</comment>
	<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Allocate a new tranche ID.
 */</comment>
<function><type><name>int</name></type>
<name>LWLockNewTrancheId</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name>		   <modifier>*</modifier></type><name>LWLockCounter</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>LWLockCounter</name> <operator>=</operator> <operator>(</operator><name>int</name> <operator>*</operator><operator>)</operator> <operator>(</operator><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>MainLWLockArray</name> <operator>-</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof><operator>)</operator></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SpinLockAcquire</name><argument_list>(<argument><expr><name>ShmemLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><operator>*</operator><name>LWLockCounter</name><operator>)</operator><operator>++</operator></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SpinLockRelease</name><argument_list>(<argument><expr><name>ShmemLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Register a tranche ID in the lookup table for the current process.  This
 * routine will save a pointer to the tranche name passed as an argument,
 * so the name should be allocated in a backend-lifetime context
 * (TopMemoryContext, static variable, or similar).
 */</comment>
<function><type><name>void</name></type>
<name>LWLockRegisterTranche</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>tranche_id</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>tranche_name</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>LWLockTrancheArray</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>tranche_id</name> <operator>&gt;=</operator> <name>LWLockTranchesAllocated</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>i</name> <init>= <expr><name>LWLockTranchesAllocated</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>j</name> <init>= <expr><name>LWLockTranchesAllocated</name></expr></init></decl>;</decl_stmt>

		<while>while <condition>(<expr><name>i</name> <operator>&lt;=</operator> <name>tranche_id</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>i</name> <operator>*=</operator> <literal type="number">2</literal></expr>;</expr_stmt></block_content></block></while>

		<expr_stmt><expr><name>LWLockTrancheArray</name> <operator>=</operator> <operator>(</operator><specifier>const</specifier> <name>char</name> <operator>*</operator><operator>*</operator><operator>)</operator>
			<call><name>repalloc</name><argument_list>(<argument><expr><name>LWLockTrancheArray</name></expr></argument>, <argument><expr><name>i</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>char</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>LWLockTranchesAllocated</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
		<while>while <condition>(<expr><name>j</name> <operator>&lt;</operator> <name>LWLockTranchesAllocated</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>LWLockTrancheArray</name><index>[<expr><name>j</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></while>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name><name>LWLockTrancheArray</name><index>[<expr><name>tranche_id</name></expr>]</index></name> <operator>=</operator> <name>tranche_name</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * RequestNamedLWLockTranche
 *		Request that extra LWLocks be allocated during postmaster
 *		startup.
 *
 * This is only useful for extensions if called from the _PG_init hook
 * of a library that is loaded into the postmaster via
 * shared_preload_libraries.  Once shared memory has been allocated, calls
 * will be ignored.  (We could raise an error, but it seems better to make
 * it a no-op, so that libraries containing such calls can be reloaded if
 * needed.)
 */</comment>
<function><type><name>void</name></type>
<name>RequestNamedLWLockTranche</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>tranche_name</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>num_lwlocks</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>NamedLWLockTrancheRequest</name> <modifier>*</modifier></type><name>request</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>IsUnderPostmaster</name> <operator>||</operator> <operator>!</operator><name>lock_named_request_allowed</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>					<comment type="block">/* too late */</comment>

	<if_stmt><if>if <condition>(<expr><name>NamedLWLockTrancheRequestArray</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>NamedLWLockTrancheRequestsAllocated</name> <operator>=</operator> <literal type="number">16</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name>NamedLWLockTrancheRequestArray</name> <operator>=</operator> <operator>(</operator><name>NamedLWLockTrancheRequest</name> <operator>*</operator><operator>)</operator>
			<call><name>MemoryContextAlloc</name><argument_list>(<argument><expr><name>TopMemoryContext</name></expr></argument>,
							   <argument><expr><name>NamedLWLockTrancheRequestsAllocated</name>
							   <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>NamedLWLockTrancheRequest</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>NamedLWLockTrancheRequests</name> <operator>&gt;=</operator> <name>NamedLWLockTrancheRequestsAllocated</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>i</name> <init>= <expr><name>NamedLWLockTrancheRequestsAllocated</name></expr></init></decl>;</decl_stmt>

		<while>while <condition>(<expr><name>i</name> <operator>&lt;=</operator> <name>NamedLWLockTrancheRequests</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>i</name> <operator>*=</operator> <literal type="number">2</literal></expr>;</expr_stmt></block_content></block></while>

		<expr_stmt><expr><name>NamedLWLockTrancheRequestArray</name> <operator>=</operator> <operator>(</operator><name>NamedLWLockTrancheRequest</name> <operator>*</operator><operator>)</operator>
			<call><name>repalloc</name><argument_list>(<argument><expr><name>NamedLWLockTrancheRequestArray</name></expr></argument>,
					 <argument><expr><name>i</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>NamedLWLockTrancheRequest</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>NamedLWLockTrancheRequestsAllocated</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>request</name> <operator>=</operator> <operator>&amp;</operator><name><name>NamedLWLockTrancheRequestArray</name><index>[<expr><name>NamedLWLockTrancheRequests</name></expr>]</index></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>tranche_name</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal> <operator>&lt;</operator> <name>NAMEDATALEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>StrNCpy</name><argument_list>(<argument><expr><name><name>request</name><operator>-&gt;</operator><name>tranche_name</name></name></expr></argument>, <argument><expr><name>tranche_name</name></expr></argument>, <argument><expr><name>NAMEDATALEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>request</name><operator>-&gt;</operator><name>num_lwlocks</name></name> <operator>=</operator> <name>num_lwlocks</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>NamedLWLockTrancheRequests</name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * LWLockInitialize - initialize a new lwlock; it's initially unlocked
 */</comment>
<function><type><name>void</name></type>
<name>LWLockInitialize</name><parameter_list>(<parameter><decl><type><name>LWLock</name> <modifier>*</modifier></type><name>lock</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>tranche_id</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>pg_atomic_init_u32</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>lock</name><operator>-&gt;</operator><name>state</name></name></expr></argument>, <argument><expr><name>LW_FLAG_RELEASE_OK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pg_atomic_init_u32</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>lock</name><operator>-&gt;</operator><name>nwaiters</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pg_atomic_init_u32</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>lock</name><operator>-&gt;</operator><name>x_pid</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>lock</name><operator>-&gt;</operator><name>tranche</name></name> <operator>=</operator> <name>tranche_id</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>proclist_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>lock</name><operator>-&gt;</operator><name>waiters</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Report start of wait event for light-weight locks.
 *
 * This function will be used by all the light-weight lock calls which
 * needs to wait to acquire the lock.  This function distinguishes wait
 * event based on tranche and lock id.
 */</comment>
<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type>
<name>LWLockReportWaitStart</name><parameter_list>(<parameter><decl><type><name>LWLock</name> <modifier>*</modifier></type><name>lock</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>pgstat_report_wait_start</name><argument_list>(<argument><expr><name>PG_WAIT_LWLOCK</name> <operator>|</operator> <name><name>lock</name><operator>-&gt;</operator><name>tranche</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Report end of wait event for light-weight locks.
 */</comment>
<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type>
<name>LWLockReportWaitEnd</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>pgstat_report_wait_end</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Return an identifier for an LWLock based on the wait class and event.
 */</comment>
<function><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>
<name>GetLWLockIdentifier</name><parameter_list>(<parameter><decl><type><name>uint32</name></type> <name>classId</name></decl></parameter>, <parameter><decl><type><name>uint16</name></type> <name>eventId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>classId</name> <operator>==</operator> <name>PG_WAIT_LWLOCK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * It is quite possible that user has registered tranche in one of the
	 * backends (e.g. by allocating lwlocks in dynamic shared memory) but not
	 * all of them, so we can't assume the tranche is registered here.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>eventId</name> <operator>&gt;=</operator> <name>LWLockTranchesAllocated</name> <operator>||</operator>
		<name><name>LWLockTrancheArray</name><index>[<expr><name>eventId</name></expr>]</index></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><literal type="string">"extension"</literal></expr>;</return></block_content></block></if></if_stmt>

	<return>return <expr><name><name>LWLockTrancheArray</name><index>[<expr><name>eventId</name></expr>]</index></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Internal function that tries to atomically acquire the lwlock in the passed
 * in mode.
 *
 * This function will not block waiting for a lock to become free - that's the
 * callers job.
 *
 * Returns true if the lock isn't free and we need to wait.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>LWLockAttemptLock</name><parameter_list>(<parameter><decl><type><name>LWLock</name> <modifier>*</modifier></type><name>lock</name></decl></parameter>, <parameter><decl><type><name>LWLockMode</name></type> <name>mode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>uint32</name></type>		<name>old_state</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>AssertArg</name><argument_list>(<argument><expr><name>mode</name> <operator>==</operator> <name>LW_EXCLUSIVE</name> <operator>||</operator> <name>mode</name> <operator>==</operator> <name>LW_SHARED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Read once outside the loop, later iterations will get the newer value
	 * via compare &amp; exchange.
	 */</comment>
	<expr_stmt><expr><name>old_state</name> <operator>=</operator> <call><name>pg_atomic_read_u32</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>lock</name><operator>-&gt;</operator><name>state</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* loop until we've determined whether we could acquire the lock or not */</comment>
	<while>while <condition>(<expr><name>true</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>uint32</name></type>		<name>desired_state</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>lock_free</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>desired_state</name> <operator>=</operator> <name>old_state</name></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>mode</name> <operator>==</operator> <name>LW_EXCLUSIVE</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>lock_free</name> <operator>=</operator> <operator>(</operator><name>old_state</name> <operator>&amp;</operator> <name>LW_LOCK_MASK</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>lock_free</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>desired_state</name> <operator>+=</operator> <name>LW_VAL_EXCLUSIVE</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><name>lock_free</name> <operator>=</operator> <operator>(</operator><name>old_state</name> <operator>&amp;</operator> <name>LW_VAL_EXCLUSIVE</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>lock_free</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>desired_state</name> <operator>+=</operator> <name>LW_VAL_SHARED</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></else></if_stmt>

		<comment type="block">/*
		 * Attempt to swap in the state we are expecting. If we didn't see
		 * lock to be free, that's just the old value. If we saw it as free,
		 * we'll attempt to mark it acquired. The reason that we always swap
		 * in the value is that this doubles as a memory barrier. We could try
		 * to be smarter and only swap in values if we saw the lock as free,
		 * but benchmark haven't shown it as beneficial so far.
		 *
		 * Retry if the value changed since we last looked at it.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>pg_atomic_compare_exchange_u32</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>lock</name><operator>-&gt;</operator><name>state</name></name></expr></argument>,
										   <argument><expr><operator>&amp;</operator><name>old_state</name></expr></argument>, <argument><expr><name>desired_state</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>lock_free</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* Great! Got the lock. */</comment>
				<if_stmt><if>if <condition>(<expr><name>mode</name> <operator>==</operator> <name>LW_EXCLUSIVE</name></expr>)</condition>
				<block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>LWLOCK_DEBUG</name></cpp:ifdef>
					<expr_stmt><expr><name><name>lock</name><operator>-&gt;</operator><name>owner</name></name> <operator>=</operator> <name>MyProc</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
					<comment type="block">/*
				 	* POLAR: We only record the last exclusive lock. 
				 	*/</comment>
					<if_stmt><if>if <condition>(<expr><name>MyProc</name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>pg_atomic_write_u32</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>lock</name><operator>-&gt;</operator><name>x_pid</name></name></expr></argument>, <argument><expr><name><name>MyProc</name><operator>-&gt;</operator><name>pid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				</block_content>}</block></if></if_stmt>
				<return>return <expr><name>false</name></expr>;</return>
			</block_content>}</block></if>
			<else>else<block type="pseudo"><block_content>
				<return>return <expr><name>true</name></expr>;</return></block_content></block></else></if_stmt>	<comment type="block">/* somebody else has the lock */</comment>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></while>
	<expr_stmt><expr><call><name>pg_unreachable</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Lock the LWLock's wait list against concurrent activity.
 *
 * NB: even though the wait list is locked, non-conflicting lock operations
 * may still happen concurrently.
 *
 * Time spent holding mutex should be short!
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>LWLockWaitListLock</name><parameter_list>(<parameter><decl><type><name>LWLock</name> <modifier>*</modifier></type><name>lock</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>uint32</name></type>		<name>old_state</name></decl>;</decl_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>LWLOCK_STATS</name></cpp:ifdef>
	<decl_stmt><decl><type><name>lwlock_stats</name> <modifier>*</modifier></type><name>lwstats</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32</name></type>		<name>delays</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>lwstats</name> <operator>=</operator> <call><name>get_lwlock_stats_entry</name><argument_list>(<argument><expr><name>lock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<while>while <condition>(<expr><name>true</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* always try once to acquire lock directly */</comment>
		<expr_stmt><expr><name>old_state</name> <operator>=</operator> <call><name>pg_atomic_fetch_or_u32</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>lock</name><operator>-&gt;</operator><name>state</name></name></expr></argument>, <argument><expr><name>LW_FLAG_LOCKED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>old_state</name> <operator>&amp;</operator> <name>LW_FLAG_LOCKED</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>				<comment type="block">/* got lock */</comment>

		<comment type="block">/* and then spin without atomic operations until lock is released */</comment>
		<block>{<block_content>
			<decl_stmt><decl><type><name>SpinDelayStatus</name></type> <name>delayStatus</name></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>init_local_spin_delay</name><argument_list>(<argument><expr><operator>&amp;</operator><name>delayStatus</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<while>while <condition>(<expr><name>old_state</name> <operator>&amp;</operator> <name>LW_FLAG_LOCKED</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>perform_spin_delay</name><argument_list>(<argument><expr><operator>&amp;</operator><name>delayStatus</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>old_state</name> <operator>=</operator> <call><name>pg_atomic_read_u32</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>lock</name><operator>-&gt;</operator><name>state</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></while>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>LWLOCK_STATS</name></cpp:ifdef>
			<expr_stmt><expr><name>delays</name> <operator>+=</operator> <name><name>delayStatus</name><operator>.</operator><name>delays</name></name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
			<expr_stmt><expr><call><name>finish_spin_delay</name><argument_list>(<argument><expr><operator>&amp;</operator><name>delayStatus</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>

		<comment type="block">/*
		 * Retry. The lock might obviously already be re-acquired by the time
		 * we're attempting to get it again.
		 */</comment>
	</block_content>}</block></while>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>LWLOCK_STATS</name></cpp:ifdef>
	<expr_stmt><expr><name><name>lwstats</name><operator>-&gt;</operator><name>spin_delay_count</name></name> <operator>+=</operator> <name>delays</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>

<comment type="block">/*
 * Unlock the LWLock's wait list.
 *
 * Note that it can be more efficient to manipulate flags and release the
 * locks in a single atomic operation.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>LWLockWaitListUnlock</name><parameter_list>(<parameter><decl><type><name>LWLock</name> <modifier>*</modifier></type><name>lock</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>uint32</name>		<name>old_state</name></type> <name>PG_USED_FOR_ASSERTS_ONLY</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>old_state</name> <operator>=</operator> <call><name>pg_atomic_fetch_and_u32</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>lock</name><operator>-&gt;</operator><name>state</name></name></expr></argument>, <argument><expr><operator>~</operator><name>LW_FLAG_LOCKED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>old_state</name> <operator>&amp;</operator> <name>LW_FLAG_LOCKED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Wakeup all the lockers that currently have a chance to acquire the lock.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>LWLockWakeup</name><parameter_list>(<parameter><decl><type><name>LWLock</name> <modifier>*</modifier></type><name>lock</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type>		<name>new_release_ok</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>wokeup_somebody</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>proclist_head</name></type> <name>wakeup</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>proclist_mutable_iter</name></type> <name>iter</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>proclist_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>wakeup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>new_release_ok</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

	<comment type="block">/* lock wait list while collecting backends to wake up */</comment>
	<expr_stmt><expr><call><name>LWLockWaitListLock</name><argument_list>(<argument><expr><name>lock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<macro><name>proclist_foreach_modify</name><argument_list>(<argument>iter</argument>, <argument>&amp;lock-&gt;waiters</argument>, <argument>lwWaitLink</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>PGPROC</name>	   <modifier>*</modifier></type><name>waiter</name> <init>= <expr><call><name>GetPGProcByNumber</name><argument_list>(<argument><expr><name><name>iter</name><operator>.</operator><name>cur</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>wokeup_somebody</name> <operator>&amp;&amp;</operator> <name><name>waiter</name><operator>-&gt;</operator><name>lwWaitMode</name></name> <operator>==</operator> <name>LW_EXCLUSIVE</name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>proclist_delete</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>lock</name><operator>-&gt;</operator><name>waiters</name></name></expr></argument>, <argument><expr><name><name>iter</name><operator>.</operator><name>cur</name></name></expr></argument>, <argument><expr><name>lwWaitLink</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>proclist_push_tail</name><argument_list>(<argument><expr><operator>&amp;</operator><name>wakeup</name></expr></argument>, <argument><expr><name><name>iter</name><operator>.</operator><name>cur</name></name></expr></argument>, <argument><expr><name>lwWaitLink</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>waiter</name><operator>-&gt;</operator><name>lwWaitMode</name></name> <operator>!=</operator> <name>LW_WAIT_UNTIL_FREE</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * Prevent additional wakeups until retryer gets to run. Backends
			 * that are just waiting for the lock to become free don't retry
			 * automatically.
			 */</comment>
			<expr_stmt><expr><name>new_release_ok</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

			<comment type="block">/*
			 * Don't wakeup (further) exclusive locks.
			 */</comment>
			<expr_stmt><expr><name>wokeup_somebody</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * Once we've woken up an exclusive lock, there's no point in waking
		 * up anybody else.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>waiter</name><operator>-&gt;</operator><name>lwWaitMode</name></name> <operator>==</operator> <name>LW_EXCLUSIVE</name></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>
	</block_content>}</block>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>proclist_is_empty</name><argument_list>(<argument><expr><operator>&amp;</operator><name>wakeup</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>pg_atomic_read_u32</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>lock</name><operator>-&gt;</operator><name>state</name></name></expr></argument>)</argument_list></call> <operator>&amp;</operator> <name>LW_FLAG_HAS_WAITERS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* unset required flags, and release lock, in one fell swoop */</comment>
	<block>{<block_content>
		<decl_stmt><decl><type><name>uint32</name></type>		<name>old_state</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>uint32</name></type>		<name>desired_state</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>old_state</name> <operator>=</operator> <call><name>pg_atomic_read_u32</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>lock</name><operator>-&gt;</operator><name>state</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<while>while <condition>(<expr><name>true</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>desired_state</name> <operator>=</operator> <name>old_state</name></expr>;</expr_stmt>

			<comment type="block">/* compute desired flags */</comment>

			<if_stmt><if>if <condition>(<expr><name>new_release_ok</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>desired_state</name> <operator>|=</operator> <name>LW_FLAG_RELEASE_OK</name></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name>desired_state</name> <operator>&amp;=</operator> <operator>~</operator><name>LW_FLAG_RELEASE_OK</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>proclist_is_empty</name><argument_list>(<argument><expr><operator>&amp;</operator><name>wakeup</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>desired_state</name> <operator>&amp;=</operator> <operator>~</operator><name>LW_FLAG_HAS_WAITERS</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<expr_stmt><expr><name>desired_state</name> <operator>&amp;=</operator> <operator>~</operator><name>LW_FLAG_LOCKED</name></expr>;</expr_stmt>	<comment type="block">/* release lock */</comment>

			<if_stmt><if>if <condition>(<expr><call><name>pg_atomic_compare_exchange_u32</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>lock</name><operator>-&gt;</operator><name>state</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>old_state</name></expr></argument>,
											   <argument><expr><name>desired_state</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<break>break;</break></block_content></block></if></if_stmt>
		</block_content>}</block></while>
	</block_content>}</block>

	<comment type="block">/* Awaken any waiters I removed from the queue. */</comment>
	<macro><name>proclist_foreach_modify</name><argument_list>(<argument>iter</argument>, <argument>&amp;wakeup</argument>, <argument>lwWaitLink</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>PGPROC</name>	   <modifier>*</modifier></type><name>waiter</name> <init>= <expr><call><name>GetPGProcByNumber</name><argument_list>(<argument><expr><name><name>iter</name><operator>.</operator><name>cur</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>LOG_LWDEBUG</name><argument_list>(<argument><expr><literal type="string">"LWLockRelease"</literal></expr></argument>, <argument><expr><name>lock</name></expr></argument>, <argument><expr><literal type="string">"release waiter"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>proclist_delete</name><argument_list>(<argument><expr><operator>&amp;</operator><name>wakeup</name></expr></argument>, <argument><expr><name><name>iter</name><operator>.</operator><name>cur</name></name></expr></argument>, <argument><expr><name>lwWaitLink</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Guarantee that lwWaiting being unset only becomes visible once the
		 * unlink from the link has completed. Otherwise the target backend
		 * could be woken up for other reason and enqueue for a new lock - if
		 * that happens before the list unlink happens, the list would end up
		 * being corrupted.
		 *
		 * The barrier pairs with the LWLockWaitListLock() when enqueuing for
		 * another lock.
		 */</comment>
		<expr_stmt><expr><call><name>pg_write_barrier</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>waiter</name><operator>-&gt;</operator><name>lwWaiting</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>PGSemaphoreUnlock</name><argument_list>(<argument><expr><name><name>waiter</name><operator>-&gt;</operator><name>sem</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
</block_content>}</block></function>

<comment type="block">/*
 * Add ourselves to the end of the queue.
 *
 * NB: Mode can be LW_WAIT_UNTIL_FREE here!
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>LWLockQueueSelf</name><parameter_list>(<parameter><decl><type><name>LWLock</name> <modifier>*</modifier></type><name>lock</name></decl></parameter>, <parameter><decl><type><name>LWLockMode</name></type> <name>mode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * If we don't have a PGPROC structure, there's no way to wait. This
	 * should never occur, since MyProc should only be null during shared
	 * memory initialization.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>MyProc</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>PANIC</name></expr></argument>, <argument><expr><literal type="string">"cannot wait without a PGPROC structure"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>MyProc</name><operator>-&gt;</operator><name>lwWaiting</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>PANIC</name></expr></argument>, <argument><expr><literal type="string">"queueing for lock while waiting on another one"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>LWLockWaitListLock</name><argument_list>(<argument><expr><name>lock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* setting the flag is protected by the spinlock */</comment>
	<expr_stmt><expr><call><name>pg_atomic_fetch_or_u32</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>lock</name><operator>-&gt;</operator><name>state</name></name></expr></argument>, <argument><expr><name>LW_FLAG_HAS_WAITERS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>MyProc</name><operator>-&gt;</operator><name>lwWaiting</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>MyProc</name><operator>-&gt;</operator><name>lwWaitMode</name></name> <operator>=</operator> <name>mode</name></expr>;</expr_stmt>

	<comment type="block">/* LW_WAIT_UNTIL_FREE waiters are always at the front of the queue */</comment>
	<if_stmt><if>if <condition>(<expr><name>mode</name> <operator>==</operator> <name>LW_WAIT_UNTIL_FREE</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>proclist_push_head</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>lock</name><operator>-&gt;</operator><name>waiters</name></name></expr></argument>, <argument><expr><name><name>MyProc</name><operator>-&gt;</operator><name>pgprocno</name></name></expr></argument>, <argument><expr><name>lwWaitLink</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>proclist_push_tail</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>lock</name><operator>-&gt;</operator><name>waiters</name></name></expr></argument>, <argument><expr><name><name>MyProc</name><operator>-&gt;</operator><name>pgprocno</name></name></expr></argument>, <argument><expr><name>lwWaitLink</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/* Can release the mutex now */</comment>
	<expr_stmt><expr><call><name>LWLockWaitListUnlock</name><argument_list>(<argument><expr><name>lock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>pg_atomic_fetch_add_u32</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>lock</name><operator>-&gt;</operator><name>nwaiters</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<comment type="block">/*
 * Remove ourselves from the waitlist.
 *
 * This is used if we queued ourselves because we thought we needed to sleep
 * but, after further checking, we discovered that we don't actually need to
 * do so.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>LWLockDequeueSelf</name><parameter_list>(<parameter><decl><type><name>LWLock</name> <modifier>*</modifier></type><name>lock</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type>		<name>found</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>proclist_mutable_iter</name></type> <name>iter</name></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>LWLOCK_STATS</name></cpp:ifdef>
	<decl_stmt><decl><type><name>lwlock_stats</name> <modifier>*</modifier></type><name>lwstats</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>lwstats</name> <operator>=</operator> <call><name>get_lwlock_stats_entry</name><argument_list>(<argument><expr><name>lock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>lwstats</name><operator>-&gt;</operator><name>dequeue_self_count</name></name><operator>++</operator></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<expr_stmt><expr><call><name>LWLockWaitListLock</name><argument_list>(<argument><expr><name>lock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Can't just remove ourselves from the list, but we need to iterate over
	 * all entries as somebody else could have dequeued us.
	 */</comment>
	<macro><name>proclist_foreach_modify</name><argument_list>(<argument>iter</argument>, <argument>&amp;lock-&gt;waiters</argument>, <argument>lwWaitLink</argument>)</argument_list></macro>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>iter</name><operator>.</operator><name>cur</name></name> <operator>==</operator> <name><name>MyProc</name><operator>-&gt;</operator><name>pgprocno</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>found</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>proclist_delete</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>lock</name><operator>-&gt;</operator><name>waiters</name></name></expr></argument>, <argument><expr><name><name>iter</name><operator>.</operator><name>cur</name></name></expr></argument>, <argument><expr><name>lwWaitLink</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>

	<if_stmt><if>if <condition>(<expr><call><name>proclist_is_empty</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>lock</name><operator>-&gt;</operator><name>waiters</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
		<operator>(</operator><call><name>pg_atomic_read_u32</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>lock</name><operator>-&gt;</operator><name>state</name></name></expr></argument>)</argument_list></call> <operator>&amp;</operator> <name>LW_FLAG_HAS_WAITERS</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>pg_atomic_fetch_and_u32</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>lock</name><operator>-&gt;</operator><name>state</name></name></expr></argument>, <argument><expr><operator>~</operator><name>LW_FLAG_HAS_WAITERS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* XXX: combine with fetch_and above? */</comment>
	<expr_stmt><expr><call><name>LWLockWaitListUnlock</name><argument_list>(<argument><expr><name>lock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* clear waiting state again, nice for debugging */</comment>
	<if_stmt><if>if <condition>(<expr><name>found</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>MyProc</name><operator>-&gt;</operator><name>lwWaiting</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></if>
	<else>else
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>extraWaits</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

		<comment type="block">/*
		 * Somebody else dequeued us and has or will wake us up. Deal with the
		 * superfluous absorption of a wakeup.
		 */</comment>

		<comment type="block">/*
		 * Reset releaseOk if somebody woke us before we removed ourselves -
		 * they'll have set it to false.
		 */</comment>
		<expr_stmt><expr><call><name>pg_atomic_fetch_or_u32</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>lock</name><operator>-&gt;</operator><name>state</name></name></expr></argument>, <argument><expr><name>LW_FLAG_RELEASE_OK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Now wait for the scheduled wakeup, otherwise our -&gt;lwWaiting would
		 * get reset at some inconvenient point later. Most of the time this
		 * will immediately return.
		 */</comment>
		<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
		<block>{<block_content>
			<expr_stmt><expr><call><name>PGSemaphoreLock</name><argument_list>(<argument><expr><name><name>MyProc</name><operator>-&gt;</operator><name>sem</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>MyProc</name><operator>-&gt;</operator><name>lwWaiting</name></name></expr>)</condition><block type="pseudo"><block_content>
				<break>break;</break></block_content></block></if></if_stmt>
			<expr_stmt><expr><name>extraWaits</name><operator>++</operator></expr>;</expr_stmt>
		</block_content>}</block></for>

		<comment type="block">/*
		 * Fix the process wait semaphore's count for any absorbed wakeups.
		 */</comment>
		<while>while <condition>(<expr><name>extraWaits</name><operator>--</operator> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>PGSemaphoreUnlock</name><argument_list>(<argument><expr><name><name>MyProc</name><operator>-&gt;</operator><name>sem</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></while>
	</block_content>}</block></else></if_stmt>

	<block>{<block_content>
		<comment type="block">/* not waiting anymore */</comment>
		<decl_stmt><decl><type><name>uint32</name>		<name>nwaiters</name></type> <name>PG_USED_FOR_ASSERTS_ONLY</name> <init>= <expr><call><name>pg_atomic_fetch_sub_u32</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>lock</name><operator>-&gt;</operator><name>nwaiters</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>nwaiters</name> <operator>&lt;</operator> <name>MAX_BACKENDS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
</block_content>}</block></function>

<comment type="block">/*
 * LWLockAcquire - acquire a lightweight lock in the specified mode
 *
 * If the lock is not available, sleep until it is.  Returns true if the lock
 * was available immediately, false if we had to sleep.
 *
 * Side effect: cancel/die interrupts are held off until lock release.
 */</comment>
<function><type><name>bool</name></type>
<name>LWLockAcquire</name><parameter_list>(<parameter><decl><type><name>LWLock</name> <modifier>*</modifier></type><name>lock</name></decl></parameter>, <parameter><decl><type><name>LWLockMode</name></type> <name>mode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PGPROC</name>	   <modifier>*</modifier></type><name>proc</name> <init>= <expr><name>MyProc</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>result</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>extraWaits</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<comment type="block">/* POLAR: lock timing */</comment>
	<decl_stmt><decl><type><name>instr_time</name></type> <name>lwlock_wait_start</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>is_blocking</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<comment type="block">/* POLAR end */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>LWLOCK_STATS</name></cpp:ifdef>
	<decl_stmt><decl><type><name>lwlock_stats</name> <modifier>*</modifier></type><name>lwstats</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>lwstats</name> <operator>=</operator> <call><name>get_lwlock_stats_entry</name><argument_list>(<argument><expr><name>lock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<comment type="block">/* POLAR: lock timing */</comment>
	<expr_stmt><expr><call><name>INSTR_TIME_SET_ZERO</name><argument_list>(<argument><expr><name>lwlock_wait_start</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* POLAR end */</comment>

	<expr_stmt><expr><call><name>AssertArg</name><argument_list>(<argument><expr><name>mode</name> <operator>==</operator> <name>LW_SHARED</name> <operator>||</operator> <name>mode</name> <operator>==</operator> <name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PRINT_LWDEBUG</name><argument_list>(<argument><expr><literal type="string">"LWLockAcquire"</literal></expr></argument>, <argument><expr><name>lock</name></expr></argument>, <argument><expr><name>mode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>LWLOCK_STATS</name></cpp:ifdef>
	<comment type="block">/* Count lock acquisition attempts */</comment>
	<if_stmt><if>if <condition>(<expr><name>mode</name> <operator>==</operator> <name>LW_EXCLUSIVE</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>lwstats</name><operator>-&gt;</operator><name>ex_acquire_count</name></name><operator>++</operator></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>lwstats</name><operator>-&gt;</operator><name>sh_acquire_count</name></name><operator>++</operator></expr>;</expr_stmt></block_content></block></else></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>							<comment type="block">/* LWLOCK_STATS */</comment>
	<comment type="block">/* POLAR: Count lock acquisition attempts */</comment>
	<expr_stmt><expr><call><name>polar_lwlock_stat_acquire</name><argument_list>(<argument><expr><name>lock</name></expr></argument>, <argument><expr><name>mode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* POLAR end */</comment>

	<comment type="block">/*
	 * We can't wait if we haven't got a PGPROC.  This should only occur
	 * during bootstrap or shared memory initialization.  Put an Assert here
	 * to catch unsafe coding practices.
	 */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><operator>(</operator><name>proc</name> <operator>==</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name>IsUnderPostmaster</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Ensure we will have room to remember the lock */</comment>
	<if_stmt><if>if <condition>(<expr><name>num_held_lwlocks</name> <operator>&gt;=</operator> <name>MAX_SIMUL_LWLOCKS</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"too many LWLocks taken"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Lock out cancel/die interrupts until we exit the code section protected
	 * by the LWLock.  This ensures that interrupts will not interfere with
	 * manipulations of data structures in shared memory.
	 */</comment>
	<expr_stmt><expr><call><name>HOLD_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Loop here to try to acquire lock after each time we are signaled by
	 * LWLockRelease.
	 *
	 * NOTE: it might seem better to have LWLockRelease actually grant us the
	 * lock, rather than retrying and possibly having to go back to sleep. But
	 * in practice that is no good because it means a process swap for every
	 * lock acquisition when two or more processes are contending for the same
	 * lock.  Since LWLocks are normally used to protect not-very-long
	 * sections of computation, a process needs to be able to acquire and
	 * release the same lock many times during a single CPU time slice, even
	 * in the presence of contention.  The efficiency of being able to do that
	 * outweighs the inefficiency of sometimes wasting a process dispatch
	 * cycle because the lock is not free when a released waiter finally gets
	 * to run.  See pgsql-hackers archives for 29-Dec-01.
	 */</comment>
	<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>bool</name></type>		<name>mustwait</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * Try to grab the lock the first time, we're not in the waitqueue
		 * yet/anymore.
		 */</comment>
		<expr_stmt><expr><name>mustwait</name> <operator>=</operator> <call><name>LWLockAttemptLock</name><argument_list>(<argument><expr><name>lock</name></expr></argument>, <argument><expr><name>mode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>mustwait</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>LOG_LWDEBUG</name><argument_list>(<argument><expr><literal type="string">"LWLockAcquire"</literal></expr></argument>, <argument><expr><name>lock</name></expr></argument>, <argument><expr><literal type="string">"immediately acquired lock"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>				<comment type="block">/* got the lock */</comment>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * Ok, at this point we couldn't grab the lock on the first try. We
		 * cannot simply queue ourselves to the end of the list and wait to be
		 * woken up because by now the lock could long have been released.
		 * Instead add us to the queue and try to grab the lock again. If we
		 * succeed we need to revert the queuing and be happy, otherwise we
		 * recheck the lock. If we still couldn't grab it, we know that the
		 * other locker will see our queue entries when releasing since they
		 * existed before we checked for the lock.
		 */</comment>

		<comment type="block">/* add to the queue */</comment>
		<expr_stmt><expr><call><name>LWLockQueueSelf</name><argument_list>(<argument><expr><name>lock</name></expr></argument>, <argument><expr><name>mode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* we're now guaranteed to be woken up if necessary */</comment>
		<expr_stmt><expr><name>mustwait</name> <operator>=</operator> <call><name>LWLockAttemptLock</name><argument_list>(<argument><expr><name>lock</name></expr></argument>, <argument><expr><name>mode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* ok, grabbed the lock the second time round, need to undo queueing */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>mustwait</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>LOG_LWDEBUG</name><argument_list>(<argument><expr><literal type="string">"LWLockAcquire"</literal></expr></argument>, <argument><expr><name>lock</name></expr></argument>, <argument><expr><literal type="string">"acquired, undoing queue"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>LWLockDequeueSelf</name><argument_list>(<argument><expr><name>lock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * Wait until awakened.
		 *
		 * Since we share the process wait semaphore with the regular lock
		 * manager and ProcWaitForSignal, and we may need to acquire an LWLock
		 * while one of those is pending, it is possible that we get awakened
		 * for a reason other than being signaled by LWLockRelease. If so,
		 * loop back and wait again.  Once we've gotten the LWLock,
		 * re-increment the sema by the number of additional signals received,
		 * so that the lock manager or signal manager will see the received
		 * signal when it next waits.
		 */</comment>
		<expr_stmt><expr><call><name>LOG_LWDEBUG</name><argument_list>(<argument><expr><literal type="string">"LWLockAcquire"</literal></expr></argument>, <argument><expr><name>lock</name></expr></argument>, <argument><expr><literal type="string">"waiting"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>LWLOCK_STATS</name></cpp:ifdef>
		<expr_stmt><expr><name><name>lwstats</name><operator>-&gt;</operator><name>block_count</name></name><operator>++</operator></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
		<comment type="block">/* POLAR: track lock wait */</comment>
		<block>{<block_content>
			<expr_stmt><expr><call><name>POLAR_LOCK_STATS_TIME_START</name><argument_list>(<argument><expr><name>lwlock_wait_start</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>is_blocking</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>polar_stat_wait_obj_and_time_set</name><argument_list>(<argument><expr><call><name>pg_atomic_read_u32</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>lock</name><operator>-&gt;</operator><name>x_pid</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>lwlock_wait_start</name></expr></argument>, <argument><expr><name>PGPROC_WAIT_PID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><call><name>POLAR_LWLOCK_STAT_BLOCK</name><argument_list>(<argument><expr><name>lock</name></expr></argument>, <argument><expr><name>is_blocking</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>
		<comment type="block">/* POLAR end */</comment>

		<expr_stmt><expr><call><name>LWLockReportWaitStart</name><argument_list>(<argument><expr><name>lock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>TRACE_POSTGRESQL_LWLOCK_WAIT_START</name><argument_list>(<argument><expr><call><name>T_NAME</name><argument_list>(<argument><expr><name>lock</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>mode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
		<block>{<block_content>
			<expr_stmt><expr><call><name>PGSemaphoreLock</name><argument_list>(<argument><expr><name><name>proc</name><operator>-&gt;</operator><name>sem</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>proc</name><operator>-&gt;</operator><name>lwWaiting</name></name></expr>)</condition><block type="pseudo"><block_content>
				<break>break;</break></block_content></block></if></if_stmt>
			<expr_stmt><expr><name>extraWaits</name><operator>++</operator></expr>;</expr_stmt>
		</block_content>}</block></for>

		<comment type="block">/* Retrying, allow LWLockRelease to release waiters again. */</comment>
		<expr_stmt><expr><call><name>pg_atomic_fetch_or_u32</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>lock</name><operator>-&gt;</operator><name>state</name></name></expr></argument>, <argument><expr><name>LW_FLAG_RELEASE_OK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<block>{<block_content>
			<comment type="block">/* not waiting anymore */</comment>
			<decl_stmt><decl><type><name>uint32</name>		<name>nwaiters</name></type> <name>PG_USED_FOR_ASSERTS_ONLY</name> <init>= <expr><call><name>pg_atomic_fetch_sub_u32</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>lock</name><operator>-&gt;</operator><name>nwaiters</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>nwaiters</name> <operator>&lt;</operator> <name>MAX_BACKENDS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>

		<expr_stmt><expr><call><name>TRACE_POSTGRESQL_LWLOCK_WAIT_DONE</name><argument_list>(<argument><expr><call><name>T_NAME</name><argument_list>(<argument><expr><name>lock</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>mode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>LWLockReportWaitEnd</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>LOG_LWDEBUG</name><argument_list>(<argument><expr><literal type="string">"LWLockAcquire"</literal></expr></argument>, <argument><expr><name>lock</name></expr></argument>, <argument><expr><literal type="string">"awakened"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Now loop back and try to acquire lock again. */</comment>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	</block_content>}</block></for>

	<comment type="block">/* POLAR: track lock timing */</comment>
	<expr_stmt><expr><call><name>polar_lwlock_stat_record_time</name><argument_list>(<argument><expr><name>lock</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>lwlock_wait_start</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>is_blocking</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>polar_stat_wait_obj_and_time_clear</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<comment type="block">/* POLAR end */</comment>

	<expr_stmt><expr><call><name>TRACE_POSTGRESQL_LWLOCK_ACQUIRE</name><argument_list>(<argument><expr><call><name>T_NAME</name><argument_list>(<argument><expr><name>lock</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>mode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Add lock to list of locks held by this backend */</comment>
	<expr_stmt><expr><name><name>held_lwlocks</name><index>[<expr><name>num_held_lwlocks</name></expr>]</index></name><operator>.</operator><name>lock</name> <operator>=</operator> <name>lock</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>held_lwlocks</name><index>[<expr><name>num_held_lwlocks</name><operator>++</operator></expr>]</index></name><operator>.</operator><name>mode</name> <operator>=</operator> <name>mode</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Fix the process wait semaphore's count for any absorbed wakeups.
	 */</comment>
	<while>while <condition>(<expr><name>extraWaits</name><operator>--</operator> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PGSemaphoreUnlock</name><argument_list>(<argument><expr><name><name>proc</name><operator>-&gt;</operator><name>sem</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></while>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * LWLockConditionalAcquire - acquire a lightweight lock in the specified mode
 *
 * If the lock is not available, return false with no side-effects.
 *
 * If successful, cancel/die interrupts are held off until lock release.
 */</comment>
<function><type><name>bool</name></type>
<name>LWLockConditionalAcquire</name><parameter_list>(<parameter><decl><type><name>LWLock</name> <modifier>*</modifier></type><name>lock</name></decl></parameter>, <parameter><decl><type><name>LWLockMode</name></type> <name>mode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type>		<name>mustwait</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>AssertArg</name><argument_list>(<argument><expr><name>mode</name> <operator>==</operator> <name>LW_SHARED</name> <operator>||</operator> <name>mode</name> <operator>==</operator> <name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PRINT_LWDEBUG</name><argument_list>(<argument><expr><literal type="string">"LWLockConditionalAcquire"</literal></expr></argument>, <argument><expr><name>lock</name></expr></argument>, <argument><expr><name>mode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Ensure we will have room to remember the lock */</comment>
	<if_stmt><if>if <condition>(<expr><name>num_held_lwlocks</name> <operator>&gt;=</operator> <name>MAX_SIMUL_LWLOCKS</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"too many LWLocks taken"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Lock out cancel/die interrupts until we exit the code section protected
	 * by the LWLock.  This ensures that interrupts will not interfere with
	 * manipulations of data structures in shared memory.
	 */</comment>
	<expr_stmt><expr><call><name>HOLD_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Check for the lock */</comment>
	<expr_stmt><expr><name>mustwait</name> <operator>=</operator> <call><name>LWLockAttemptLock</name><argument_list>(<argument><expr><name>lock</name></expr></argument>, <argument><expr><name>mode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>mustwait</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Failed to get lock, so release interrupt holdoff */</comment>
		<expr_stmt><expr><call><name>RESUME_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>LOG_LWDEBUG</name><argument_list>(<argument><expr><literal type="string">"LWLockConditionalAcquire"</literal></expr></argument>, <argument><expr><name>lock</name></expr></argument>, <argument><expr><literal type="string">"failed"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>TRACE_POSTGRESQL_LWLOCK_CONDACQUIRE_FAIL</name><argument_list>(<argument><expr><call><name>T_NAME</name><argument_list>(<argument><expr><name>lock</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>mode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* Add lock to list of locks held by this backend */</comment>
		<expr_stmt><expr><name><name>held_lwlocks</name><index>[<expr><name>num_held_lwlocks</name></expr>]</index></name><operator>.</operator><name>lock</name> <operator>=</operator> <name>lock</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>held_lwlocks</name><index>[<expr><name>num_held_lwlocks</name><operator>++</operator></expr>]</index></name><operator>.</operator><name>mode</name> <operator>=</operator> <name>mode</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>TRACE_POSTGRESQL_LWLOCK_CONDACQUIRE</name><argument_list>(<argument><expr><call><name>T_NAME</name><argument_list>(<argument><expr><name>lock</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>mode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
	<return>return <expr><operator>!</operator><name>mustwait</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * LWLockAcquireOrWait - Acquire lock, or wait until it's free
 *
 * The semantics of this function are a bit funky.  If the lock is currently
 * free, it is acquired in the given mode, and the function returns true.  If
 * the lock isn't immediately free, the function waits until it is released
 * and returns false, but does not acquire the lock.
 *
 * This is currently used for WALWriteLock: when a backend flushes the WAL,
 * holding WALWriteLock, it can flush the commit records of many other
 * backends as a side-effect.  Those other backends need to wait until the
 * flush finishes, but don't need to acquire the lock anymore.  They can just
 * wake up, observe that their records have already been flushed, and return.
 */</comment>
<function><type><name>bool</name></type>
<name>LWLockAcquireOrWait</name><parameter_list>(<parameter><decl><type><name>LWLock</name> <modifier>*</modifier></type><name>lock</name></decl></parameter>, <parameter><decl><type><name>LWLockMode</name></type> <name>mode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PGPROC</name>	   <modifier>*</modifier></type><name>proc</name> <init>= <expr><name>MyProc</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>mustwait</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>extraWaits</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<comment type="block">/* POLAR: lock timing */</comment>
	<decl_stmt><decl><type><name>instr_time</name></type> <name>lwlock_wait_start</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>is_blocking</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<comment type="block">/* POLAR end */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>LWLOCK_STATS</name></cpp:ifdef>
	<decl_stmt><decl><type><name>lwlock_stats</name> <modifier>*</modifier></type><name>lwstats</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>lwstats</name> <operator>=</operator> <call><name>get_lwlock_stats_entry</name><argument_list>(<argument><expr><name>lock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<comment type="block">/* POLAR: lock timing */</comment>
	<expr_stmt><expr><call><name>INSTR_TIME_SET_ZERO</name><argument_list>(<argument><expr><name>lwlock_wait_start</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* POLAR end */</comment>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>mode</name> <operator>==</operator> <name>LW_SHARED</name> <operator>||</operator> <name>mode</name> <operator>==</operator> <name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PRINT_LWDEBUG</name><argument_list>(<argument><expr><literal type="string">"LWLockAcquireOrWait"</literal></expr></argument>, <argument><expr><name>lock</name></expr></argument>, <argument><expr><name>mode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Ensure we will have room to remember the lock */</comment>
	<if_stmt><if>if <condition>(<expr><name>num_held_lwlocks</name> <operator>&gt;=</operator> <name>MAX_SIMUL_LWLOCKS</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"too many LWLocks taken"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Lock out cancel/die interrupts until we exit the code section protected
	 * by the LWLock.  This ensures that interrupts will not interfere with
	 * manipulations of data structures in shared memory.
	 */</comment>
	<expr_stmt><expr><call><name>HOLD_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * NB: We're using nearly the same twice-in-a-row lock acquisition
	 * protocol as LWLockAcquire(). Check its comments for details.
	 */</comment>
	<expr_stmt><expr><name>mustwait</name> <operator>=</operator> <call><name>LWLockAttemptLock</name><argument_list>(<argument><expr><name>lock</name></expr></argument>, <argument><expr><name>mode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>mustwait</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>LWLockQueueSelf</name><argument_list>(<argument><expr><name>lock</name></expr></argument>, <argument><expr><name>LW_WAIT_UNTIL_FREE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>mustwait</name> <operator>=</operator> <call><name>LWLockAttemptLock</name><argument_list>(<argument><expr><name>lock</name></expr></argument>, <argument><expr><name>mode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>mustwait</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * Wait until awakened.  Like in LWLockAcquire, be prepared for
			 * bogus wakeups, because we share the semaphore with
			 * ProcWaitForSignal.
			 */</comment>
			<expr_stmt><expr><call><name>LOG_LWDEBUG</name><argument_list>(<argument><expr><literal type="string">"LWLockAcquireOrWait"</literal></expr></argument>, <argument><expr><name>lock</name></expr></argument>, <argument><expr><literal type="string">"waiting"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>LWLOCK_STATS</name></cpp:ifdef>
			<expr_stmt><expr><name><name>lwstats</name><operator>-&gt;</operator><name>block_count</name></name><operator>++</operator></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
			<comment type="block">/* POLAR: track lock wait */</comment>
			<block>{<block_content>
				<expr_stmt><expr><call><name>POLAR_LOCK_STATS_TIME_START</name><argument_list>(<argument><expr><name>lwlock_wait_start</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><name>is_blocking</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>polar_stat_wait_obj_and_time_set</name><argument_list>(<argument><expr><call><name>pg_atomic_read_u32</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>lock</name><operator>-&gt;</operator><name>x_pid</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>lwlock_wait_start</name></expr></argument>, <argument><expr><name>PGPROC_WAIT_PID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<expr_stmt><expr><call><name>POLAR_LWLOCK_STAT_BLOCK</name><argument_list>(<argument><expr><name>lock</name></expr></argument>, <argument><expr><name>is_blocking</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block>
			<comment type="block">/* POLAR end */</comment>

			<expr_stmt><expr><call><name>LWLockReportWaitStart</name><argument_list>(<argument><expr><name>lock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>TRACE_POSTGRESQL_LWLOCK_WAIT_START</name><argument_list>(<argument><expr><call><name>T_NAME</name><argument_list>(<argument><expr><name>lock</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>mode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
			<block>{<block_content>
				<expr_stmt><expr><call><name>PGSemaphoreLock</name><argument_list>(<argument><expr><name><name>proc</name><operator>-&gt;</operator><name>sem</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>proc</name><operator>-&gt;</operator><name>lwWaiting</name></name></expr>)</condition><block type="pseudo"><block_content>
					<break>break;</break></block_content></block></if></if_stmt>
				<expr_stmt><expr><name>extraWaits</name><operator>++</operator></expr>;</expr_stmt>
			</block_content>}</block></for>

			<block>{<block_content>
				<comment type="block">/* not waiting anymore */</comment>
				<decl_stmt><decl><type><name>uint32</name>		<name>nwaiters</name></type> <name>PG_USED_FOR_ASSERTS_ONLY</name> <init>= <expr><call><name>pg_atomic_fetch_sub_u32</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>lock</name><operator>-&gt;</operator><name>nwaiters</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>nwaiters</name> <operator>&lt;</operator> <name>MAX_BACKENDS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block>
			<expr_stmt><expr><call><name>TRACE_POSTGRESQL_LWLOCK_WAIT_DONE</name><argument_list>(<argument><expr><call><name>T_NAME</name><argument_list>(<argument><expr><name>lock</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>mode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>LWLockReportWaitEnd</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* POLAR: track lock wait */</comment>
			<expr_stmt><expr><call><name>polar_lwlock_stat_record_time</name><argument_list>(<argument><expr><name>lock</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>lwlock_wait_start</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>is_blocking</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>polar_stat_wait_obj_and_time_clear</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<comment type="block">/* POLAR end */</comment>

			<expr_stmt><expr><call><name>LOG_LWDEBUG</name><argument_list>(<argument><expr><literal type="string">"LWLockAcquireOrWait"</literal></expr></argument>, <argument><expr><name>lock</name></expr></argument>, <argument><expr><literal type="string">"awakened"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><call><name>LOG_LWDEBUG</name><argument_list>(<argument><expr><literal type="string">"LWLockAcquireOrWait"</literal></expr></argument>, <argument><expr><name>lock</name></expr></argument>, <argument><expr><literal type="string">"acquired, undoing queue"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * Got lock in the second attempt, undo queueing. We need to treat
			 * this as having successfully acquired the lock, otherwise we'd
			 * not necessarily wake up people we've prevented from acquiring
			 * the lock.
			 */</comment>
			<expr_stmt><expr><call><name>LWLockDequeueSelf</name><argument_list>(<argument><expr><name>lock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Fix the process wait semaphore's count for any absorbed wakeups.
	 */</comment>
	<while>while <condition>(<expr><name>extraWaits</name><operator>--</operator> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PGSemaphoreUnlock</name><argument_list>(<argument><expr><name><name>proc</name><operator>-&gt;</operator><name>sem</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></while>

	<if_stmt><if>if <condition>(<expr><name>mustwait</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Failed to get lock, so release interrupt holdoff */</comment>
		<expr_stmt><expr><call><name>RESUME_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>LOG_LWDEBUG</name><argument_list>(<argument><expr><literal type="string">"LWLockAcquireOrWait"</literal></expr></argument>, <argument><expr><name>lock</name></expr></argument>, <argument><expr><literal type="string">"failed"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>TRACE_POSTGRESQL_LWLOCK_ACQUIRE_OR_WAIT_FAIL</name><argument_list>(<argument><expr><call><name>T_NAME</name><argument_list>(<argument><expr><name>lock</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>mode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>LOG_LWDEBUG</name><argument_list>(<argument><expr><literal type="string">"LWLockAcquireOrWait"</literal></expr></argument>, <argument><expr><name>lock</name></expr></argument>, <argument><expr><literal type="string">"succeeded"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* Add lock to list of locks held by this backend */</comment>
		<expr_stmt><expr><name><name>held_lwlocks</name><index>[<expr><name>num_held_lwlocks</name></expr>]</index></name><operator>.</operator><name>lock</name> <operator>=</operator> <name>lock</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>held_lwlocks</name><index>[<expr><name>num_held_lwlocks</name><operator>++</operator></expr>]</index></name><operator>.</operator><name>mode</name> <operator>=</operator> <name>mode</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>TRACE_POSTGRESQL_LWLOCK_ACQUIRE_OR_WAIT</name><argument_list>(<argument><expr><call><name>T_NAME</name><argument_list>(<argument><expr><name>lock</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>mode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<return>return <expr><operator>!</operator><name>mustwait</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Does the lwlock in its current state need to wait for the variable value to
 * change?
 *
 * If we don't need to wait, and it's because the value of the variable has
 * changed, store the current value in newval.
 *
 * *result is set to true if the lock was free, and false otherwise.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>LWLockConflictsWithVar</name><parameter_list>(<parameter><decl><type><name>LWLock</name> <modifier>*</modifier></type><name>lock</name></decl></parameter>,
					   <parameter><decl><type><name>uint64</name> <modifier>*</modifier></type><name>valptr</name></decl></parameter>, <parameter><decl><type><name>uint64</name></type> <name>oldval</name></decl></parameter>, <parameter><decl><type><name>uint64</name> <modifier>*</modifier></type><name>newval</name></decl></parameter>,
					   <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>result</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type>		<name>mustwait</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint64</name></type>		<name>value</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Test first to see if it the slot is free right now.
	 *
	 * XXX: the caller uses a spinlock before this, so we don't need a memory
	 * barrier here as far as the current usage is concerned.  But that might
	 * not be safe in general.
	 */</comment>
	<expr_stmt><expr><name>mustwait</name> <operator>=</operator> <operator>(</operator><call><name>pg_atomic_read_u32</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>lock</name><operator>-&gt;</operator><name>state</name></name></expr></argument>)</argument_list></call> <operator>&amp;</operator> <name>LW_VAL_EXCLUSIVE</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>mustwait</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><operator>*</operator><name>result</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><operator>*</operator><name>result</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Read value using the lwlock's wait list lock, as we can't generally
	 * rely on atomic 64 bit reads/stores.  TODO: On platforms with a way to
	 * do atomic 64 bit reads/writes the spinlock should be optimized away.
	 */</comment>
	<expr_stmt><expr><call><name>LWLockWaitListLock</name><argument_list>(<argument><expr><name>lock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>value</name> <operator>=</operator> <operator>*</operator><name>valptr</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>LWLockWaitListUnlock</name><argument_list>(<argument><expr><name>lock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>value</name> <operator>!=</operator> <name>oldval</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>mustwait</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<expr_stmt><expr><operator>*</operator><name>newval</name> <operator>=</operator> <name>value</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name>mustwait</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<return>return <expr><name>mustwait</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * LWLockWaitForVar - Wait until lock is free, or a variable is updated.
 *
 * If the lock is held and *valptr equals oldval, waits until the lock is
 * either freed, or the lock holder updates *valptr by calling
 * LWLockUpdateVar.  If the lock is free on exit (immediately or after
 * waiting), returns true.  If the lock is still held, but *valptr no longer
 * matches oldval, returns false and sets *newval to the current value in
 * *valptr.
 *
 * Note: this function ignores shared lock holders; if the lock is held
 * in shared mode, returns 'true'.
 */</comment>
<function><type><name>bool</name></type>
<name>LWLockWaitForVar</name><parameter_list>(<parameter><decl><type><name>LWLock</name> <modifier>*</modifier></type><name>lock</name></decl></parameter>, <parameter><decl><type><name>uint64</name> <modifier>*</modifier></type><name>valptr</name></decl></parameter>, <parameter><decl><type><name>uint64</name></type> <name>oldval</name></decl></parameter>, <parameter><decl><type><name>uint64</name> <modifier>*</modifier></type><name>newval</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PGPROC</name>	   <modifier>*</modifier></type><name>proc</name> <init>= <expr><name>MyProc</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>extraWaits</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>result</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<comment type="block">/* POLAR: lock stats */</comment>
	<decl_stmt><decl><type><name>instr_time</name></type> <name>lwlock_wait_start</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>is_blocking</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<comment type="block">/* POLAR end */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>LWLOCK_STATS</name></cpp:ifdef>
	<decl_stmt><decl><type><name>lwlock_stats</name> <modifier>*</modifier></type><name>lwstats</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>lwstats</name> <operator>=</operator> <call><name>get_lwlock_stats_entry</name><argument_list>(<argument><expr><name>lock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<comment type="block">/* POLAR: lock wait time */</comment>
	<expr_stmt><expr><call><name>INSTR_TIME_SET_ZERO</name><argument_list>(<argument><expr><name>lwlock_wait_start</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* POLAR end */</comment>

	<expr_stmt><expr><call><name>PRINT_LWDEBUG</name><argument_list>(<argument><expr><literal type="string">"LWLockWaitForVar"</literal></expr></argument>, <argument><expr><name>lock</name></expr></argument>, <argument><expr><name>LW_WAIT_UNTIL_FREE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Lock out cancel/die interrupts while we sleep on the lock.  There is no
	 * cleanup mechanism to remove us from the wait queue if we got
	 * interrupted.
	 */</comment>
	<expr_stmt><expr><call><name>HOLD_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Loop here to check the lock's status after each time we are signaled.
	 */</comment>
	<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>bool</name></type>		<name>mustwait</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>mustwait</name> <operator>=</operator> <call><name>LWLockConflictsWithVar</name><argument_list>(<argument><expr><name>lock</name></expr></argument>, <argument><expr><name>valptr</name></expr></argument>, <argument><expr><name>oldval</name></expr></argument>, <argument><expr><name>newval</name></expr></argument>,
										  <argument><expr><operator>&amp;</operator><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>mustwait</name></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>				<comment type="block">/* the lock was free or value didn't match */</comment>

		<comment type="block">/*
		 * Add myself to wait queue. Note that this is racy, somebody else
		 * could wakeup before we're finished queuing. NB: We're using nearly
		 * the same twice-in-a-row lock acquisition protocol as
		 * LWLockAcquire(). Check its comments for details. The only
		 * difference is that we also have to check the variable's values when
		 * checking the state of the lock.
		 */</comment>
		<expr_stmt><expr><call><name>LWLockQueueSelf</name><argument_list>(<argument><expr><name>lock</name></expr></argument>, <argument><expr><name>LW_WAIT_UNTIL_FREE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Set RELEASE_OK flag, to make sure we get woken up as soon as the
		 * lock is released.
		 */</comment>
		<expr_stmt><expr><call><name>pg_atomic_fetch_or_u32</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>lock</name><operator>-&gt;</operator><name>state</name></name></expr></argument>, <argument><expr><name>LW_FLAG_RELEASE_OK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * We're now guaranteed to be woken up if necessary. Recheck the lock
		 * and variables state.
		 */</comment>
		<expr_stmt><expr><name>mustwait</name> <operator>=</operator> <call><name>LWLockConflictsWithVar</name><argument_list>(<argument><expr><name>lock</name></expr></argument>, <argument><expr><name>valptr</name></expr></argument>, <argument><expr><name>oldval</name></expr></argument>, <argument><expr><name>newval</name></expr></argument>,
										  <argument><expr><operator>&amp;</operator><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Ok, no conflict after we queued ourselves. Undo queueing. */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>mustwait</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>LOG_LWDEBUG</name><argument_list>(<argument><expr><literal type="string">"LWLockWaitForVar"</literal></expr></argument>, <argument><expr><name>lock</name></expr></argument>, <argument><expr><literal type="string">"free, undoing queue"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>LWLockDequeueSelf</name><argument_list>(<argument><expr><name>lock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * Wait until awakened.
		 *
		 * Since we share the process wait semaphore with the regular lock
		 * manager and ProcWaitForSignal, and we may need to acquire an LWLock
		 * while one of those is pending, it is possible that we get awakened
		 * for a reason other than being signaled by LWLockRelease. If so,
		 * loop back and wait again.  Once we've gotten the LWLock,
		 * re-increment the sema by the number of additional signals received,
		 * so that the lock manager or signal manager will see the received
		 * signal when it next waits.
		 */</comment>
		<expr_stmt><expr><call><name>LOG_LWDEBUG</name><argument_list>(<argument><expr><literal type="string">"LWLockWaitForVar"</literal></expr></argument>, <argument><expr><name>lock</name></expr></argument>, <argument><expr><literal type="string">"waiting"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>LWLOCK_STATS</name></cpp:ifdef>
		<expr_stmt><expr><name><name>lwstats</name><operator>-&gt;</operator><name>block_count</name></name><operator>++</operator></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
		<comment type="block">/* POLAR: track lock wait */</comment>
		<block>{<block_content>
			<expr_stmt><expr><call><name>POLAR_LOCK_STATS_TIME_START</name><argument_list>(<argument><expr><name>lwlock_wait_start</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>is_blocking</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>polar_stat_wait_obj_and_time_set</name><argument_list>(<argument><expr><call><name>pg_atomic_read_u32</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>lock</name><operator>-&gt;</operator><name>x_pid</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>lwlock_wait_start</name></expr></argument>, <argument><expr><name>PGPROC_WAIT_PID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><call><name>POLAR_LWLOCK_STAT_BLOCK</name><argument_list>(<argument><expr><name>lock</name></expr></argument>, <argument><expr><name>is_blocking</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>
		<comment type="block">/* POLAR end */</comment>

		<expr_stmt><expr><call><name>LWLockReportWaitStart</name><argument_list>(<argument><expr><name>lock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>TRACE_POSTGRESQL_LWLOCK_WAIT_START</name><argument_list>(<argument><expr><call><name>T_NAME</name><argument_list>(<argument><expr><name>lock</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
		<block>{<block_content>
			<expr_stmt><expr><call><name>PGSemaphoreLock</name><argument_list>(<argument><expr><name><name>proc</name><operator>-&gt;</operator><name>sem</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>proc</name><operator>-&gt;</operator><name>lwWaiting</name></name></expr>)</condition><block type="pseudo"><block_content>
				<break>break;</break></block_content></block></if></if_stmt>
			<expr_stmt><expr><name>extraWaits</name><operator>++</operator></expr>;</expr_stmt>
		</block_content>}</block></for>

		<block>{<block_content>
			<comment type="block">/* not waiting anymore */</comment>
			<decl_stmt><decl><type><name>uint32</name>		<name>nwaiters</name></type> <name>PG_USED_FOR_ASSERTS_ONLY</name> <init>= <expr><call><name>pg_atomic_fetch_sub_u32</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>lock</name><operator>-&gt;</operator><name>nwaiters</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>nwaiters</name> <operator>&lt;</operator> <name>MAX_BACKENDS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>

		<expr_stmt><expr><call><name>TRACE_POSTGRESQL_LWLOCK_WAIT_DONE</name><argument_list>(<argument><expr><call><name>T_NAME</name><argument_list>(<argument><expr><name>lock</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>LWLockReportWaitEnd</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>LOG_LWDEBUG</name><argument_list>(<argument><expr><literal type="string">"LWLockWaitForVar"</literal></expr></argument>, <argument><expr><name>lock</name></expr></argument>, <argument><expr><literal type="string">"awakened"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Now loop back and check the status of the lock again. */</comment>
	</block_content>}</block></for>

	<comment type="block">/* POLAR: track lock timing */</comment>
	<expr_stmt><expr><call><name>polar_lwlock_stat_record_time</name><argument_list>(<argument><expr><name>lock</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>lwlock_wait_start</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>is_blocking</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>polar_stat_wait_obj_and_time_clear</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<comment type="block">/* POLAR end */</comment>

	<expr_stmt><expr><call><name>TRACE_POSTGRESQL_LWLOCK_ACQUIRE</name><argument_list>(<argument><expr><call><name>T_NAME</name><argument_list>(<argument><expr><name>lock</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Fix the process wait semaphore's count for any absorbed wakeups.
	 */</comment>
	<while>while <condition>(<expr><name>extraWaits</name><operator>--</operator> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PGSemaphoreUnlock</name><argument_list>(<argument><expr><name><name>proc</name><operator>-&gt;</operator><name>sem</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></while>

	<comment type="block">/*
	 * Now okay to allow cancel/die interrupts.
	 */</comment>
	<expr_stmt><expr><call><name>RESUME_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * LWLockUpdateVar - Update a variable and wake up waiters atomically
 *
 * Sets *valptr to 'val', and wakes up all processes waiting for us with
 * LWLockWaitForVar().  Setting the value and waking up the processes happen
 * atomically so that any process calling LWLockWaitForVar() on the same lock
 * is guaranteed to see the new value, and act accordingly.
 *
 * The caller must be holding the lock in exclusive mode.
 */</comment>
<function><type><name>void</name></type>
<name>LWLockUpdateVar</name><parameter_list>(<parameter><decl><type><name>LWLock</name> <modifier>*</modifier></type><name>lock</name></decl></parameter>, <parameter><decl><type><name>uint64</name> <modifier>*</modifier></type><name>valptr</name></decl></parameter>, <parameter><decl><type><name>uint64</name></type> <name>val</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>proclist_head</name></type> <name>wakeup</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>proclist_mutable_iter</name></type> <name>iter</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>PRINT_LWDEBUG</name><argument_list>(<argument><expr><literal type="string">"LWLockUpdateVar"</literal></expr></argument>, <argument><expr><name>lock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>proclist_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>wakeup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>LWLockWaitListLock</name><argument_list>(<argument><expr><name>lock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>pg_atomic_read_u32</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>lock</name><operator>-&gt;</operator><name>state</name></name></expr></argument>)</argument_list></call> <operator>&amp;</operator> <name>LW_VAL_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Update the lock's value */</comment>
	<expr_stmt><expr><operator>*</operator><name>valptr</name> <operator>=</operator> <name>val</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * See if there are any LW_WAIT_UNTIL_FREE waiters that need to be woken
	 * up. They are always in the front of the queue.
	 */</comment>
	<macro><name>proclist_foreach_modify</name><argument_list>(<argument>iter</argument>, <argument>&amp;lock-&gt;waiters</argument>, <argument>lwWaitLink</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>PGPROC</name>	   <modifier>*</modifier></type><name>waiter</name> <init>= <expr><call><name>GetPGProcByNumber</name><argument_list>(<argument><expr><name><name>iter</name><operator>.</operator><name>cur</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>waiter</name><operator>-&gt;</operator><name>lwWaitMode</name></name> <operator>!=</operator> <name>LW_WAIT_UNTIL_FREE</name></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>proclist_delete</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>lock</name><operator>-&gt;</operator><name>waiters</name></name></expr></argument>, <argument><expr><name><name>iter</name><operator>.</operator><name>cur</name></name></expr></argument>, <argument><expr><name>lwWaitLink</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>proclist_push_tail</name><argument_list>(<argument><expr><operator>&amp;</operator><name>wakeup</name></expr></argument>, <argument><expr><name><name>iter</name><operator>.</operator><name>cur</name></name></expr></argument>, <argument><expr><name>lwWaitLink</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<comment type="block">/* We are done updating shared state of the lock itself. */</comment>
	<expr_stmt><expr><call><name>LWLockWaitListUnlock</name><argument_list>(<argument><expr><name>lock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Awaken any waiters I removed from the queue.
	 */</comment>
	<macro><name>proclist_foreach_modify</name><argument_list>(<argument>iter</argument>, <argument>&amp;wakeup</argument>, <argument>lwWaitLink</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>PGPROC</name>	   <modifier>*</modifier></type><name>waiter</name> <init>= <expr><call><name>GetPGProcByNumber</name><argument_list>(<argument><expr><name><name>iter</name><operator>.</operator><name>cur</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>proclist_delete</name><argument_list>(<argument><expr><operator>&amp;</operator><name>wakeup</name></expr></argument>, <argument><expr><name><name>iter</name><operator>.</operator><name>cur</name></name></expr></argument>, <argument><expr><name>lwWaitLink</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* check comment in LWLockWakeup() about this barrier */</comment>
		<expr_stmt><expr><call><name>pg_write_barrier</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>waiter</name><operator>-&gt;</operator><name>lwWaiting</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>PGSemaphoreUnlock</name><argument_list>(<argument><expr><name><name>waiter</name><operator>-&gt;</operator><name>sem</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
</block_content>}</block></function>


<comment type="block">/*
 * LWLockRelease - release a previously acquired lock
 */</comment>
<function><type><name>void</name></type>
<name>LWLockRelease</name><parameter_list>(<parameter><decl><type><name>LWLock</name> <modifier>*</modifier></type><name>lock</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>LWLockMode</name></type>	<name>mode</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32</name></type>		<name>oldstate</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>check_waiters</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Remove lock from list of locks held.  Usually, but not always, it will
	 * be the latest-acquired lock; so search array backwards.
	 */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name>num_held_lwlocks</name></expr>;</init> <condition><expr><operator>--</operator><name>i</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>;</condition><incr/>)</control><block type="pseudo"><block_content>
		<if_stmt><if>if <condition>(<expr><name>lock</name> <operator>==</operator> <name><name>held_lwlocks</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>lock</name></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt></block_content></block></for>

	<if_stmt><if>if <condition>(<expr><name>i</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"lock %s is not held"</literal></expr></argument>, <argument><expr><call><name>T_NAME</name><argument_list>(<argument><expr><name>lock</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>mode</name> <operator>=</operator> <name><name>held_lwlocks</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>mode</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>num_held_lwlocks</name><operator>--</operator></expr>;</expr_stmt>
	<for>for <control>(<init>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>num_held_lwlocks</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>held_lwlocks</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>held_lwlocks</name><index>[<expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt></block_content></block></for>

	<expr_stmt><expr><call><name>PRINT_LWDEBUG</name><argument_list>(<argument><expr><literal type="string">"LWLockRelease"</literal></expr></argument>, <argument><expr><name>lock</name></expr></argument>, <argument><expr><name>mode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Release my hold on lock, after that it can immediately be acquired by
	 * others, even if we still have to wakeup other waiters.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>mode</name> <operator>==</operator> <name>LW_EXCLUSIVE</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>oldstate</name> <operator>=</operator> <call><name>pg_atomic_sub_fetch_u32</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>lock</name><operator>-&gt;</operator><name>state</name></name></expr></argument>, <argument><expr><name>LW_VAL_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>oldstate</name> <operator>=</operator> <call><name>pg_atomic_sub_fetch_u32</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>lock</name><operator>-&gt;</operator><name>state</name></name></expr></argument>, <argument><expr><name>LW_VAL_SHARED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/* nobody else can have that kind of lock */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><operator>(</operator><name>oldstate</name> <operator>&amp;</operator> <name>LW_VAL_EXCLUSIVE</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>mode</name> <operator>==</operator> <name>LW_EXCLUSIVE</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>pg_atomic_write_u32</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>lock</name><operator>-&gt;</operator><name>x_pid</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/*
	 * We're still waiting for backends to get scheduled, don't wake them up
	 * again.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>oldstate</name> <operator>&amp;</operator> <operator>(</operator><name>LW_FLAG_HAS_WAITERS</name> <operator>|</operator> <name>LW_FLAG_RELEASE_OK</name><operator>)</operator><operator>)</operator> <operator>==</operator>
		<operator>(</operator><name>LW_FLAG_HAS_WAITERS</name> <operator>|</operator> <name>LW_FLAG_RELEASE_OK</name><operator>)</operator> <operator>&amp;&amp;</operator>
		<operator>(</operator><name>oldstate</name> <operator>&amp;</operator> <name>LW_LOCK_MASK</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>check_waiters</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>check_waiters</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/*
	 * As waking up waiters requires the spinlock to be acquired, only do so
	 * if necessary.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>check_waiters</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* XXX: remove before commit? */</comment>
		<expr_stmt><expr><call><name>LOG_LWDEBUG</name><argument_list>(<argument><expr><literal type="string">"LWLockRelease"</literal></expr></argument>, <argument><expr><name>lock</name></expr></argument>, <argument><expr><literal type="string">"releasing waiters"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>LWLockWakeup</name><argument_list>(<argument><expr><name>lock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>TRACE_POSTGRESQL_LWLOCK_RELEASE</name><argument_list>(<argument><expr><call><name>T_NAME</name><argument_list>(<argument><expr><name>lock</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Now okay to allow cancel/die interrupts.
	 */</comment>
	<expr_stmt><expr><call><name>RESUME_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * LWLockReleaseClearVar - release a previously acquired lock, reset variable
 */</comment>
<function><type><name>void</name></type>
<name>LWLockReleaseClearVar</name><parameter_list>(<parameter><decl><type><name>LWLock</name> <modifier>*</modifier></type><name>lock</name></decl></parameter>, <parameter><decl><type><name>uint64</name> <modifier>*</modifier></type><name>valptr</name></decl></parameter>, <parameter><decl><type><name>uint64</name></type> <name>val</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>LWLockWaitListLock</name><argument_list>(<argument><expr><name>lock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Set the variable's value before releasing the lock, that prevents race
	 * a race condition wherein a new locker acquires the lock, but hasn't yet
	 * set the variables value.
	 */</comment>
	<expr_stmt><expr><operator>*</operator><name>valptr</name> <operator>=</operator> <name>val</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>LWLockWaitListUnlock</name><argument_list>(<argument><expr><name>lock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>lock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * LWLockReleaseAll - release all currently-held locks
 *
 * Used to clean up after ereport(ERROR). An important difference between this
 * function and retail LWLockRelease calls is that InterruptHoldoffCount is
 * unchanged by this operation.  This is necessary since InterruptHoldoffCount
 * has been set to an appropriate level earlier in error recovery. We could
 * decrement it below zero if we allow it to drop for each released lock!
 */</comment>
<function><type><name>void</name></type>
<name>LWLockReleaseAll</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<while>while <condition>(<expr><name>num_held_lwlocks</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>HOLD_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>		<comment type="block">/* match the upcoming RESUME_INTERRUPTS */</comment>

		<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name><name>held_lwlocks</name><index>[<expr><name>num_held_lwlocks</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>lock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></while>
</block_content>}</block></function>


<comment type="block">/*
 * LWLockHeldByMe - test whether my process holds a lock in any mode
 *
 * This is meant as debug support only.
 */</comment>
<function><type><name>bool</name></type>
<name>LWLockHeldByMe</name><parameter_list>(<parameter><decl><type><name>LWLock</name> <modifier>*</modifier></type><name>l</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>num_held_lwlocks</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>held_lwlocks</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>lock</name> <operator>==</operator> <name>l</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></for>
	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * LWLockHeldByMeInMode - test whether my process holds a lock in given mode
 *
 * This is meant as debug support only.
 */</comment>
<function><type><name>bool</name></type>
<name>LWLockHeldByMeInMode</name><parameter_list>(<parameter><decl><type><name>LWLock</name> <modifier>*</modifier></type><name>l</name></decl></parameter>, <parameter><decl><type><name>LWLockMode</name></type> <name>mode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>num_held_lwlocks</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>held_lwlocks</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>lock</name> <operator>==</operator> <name>l</name> <operator>&amp;&amp;</operator> <name><name>held_lwlocks</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>mode</name> <operator>==</operator> <name>mode</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></for>
	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * PALOR
 * polar_remaining_lwlock_slot_count -- return remaining slot count of held_lwlocks.
 */</comment>
<function><type><name>int</name></type>
<name>polar_remaining_lwlock_slot_count</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><name>MAX_SIMUL_LWLOCKS</name> <operator>-</operator> <name>num_held_lwlocks</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * POLAR: get max lock tranche id now
 */</comment> 
<function><type><name>int</name></type>
<name>polar_get_lwlock_counter</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name>		   <modifier>*</modifier></type><name>LWLockCounter</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>LWLockCounter</name> <operator>=</operator> <operator>(</operator><name>int</name> <operator>*</operator><operator>)</operator> <operator>(</operator><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>MainLWLockArray</name> <operator>-</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof><operator>)</operator></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SpinLockAcquire</name><argument_list>(<argument><expr><name>ShmemLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><operator>*</operator><name>LWLockCounter</name><operator>)</operator></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SpinLockRelease</name><argument_list>(<argument><expr><name>ShmemLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* POLAR end */</comment>
</unit>
