<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/PolarDB-for-PostgreSQL/src/backend/storage/buffer/polar_bufmgr.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * polar_bufmgr.c
 *    polardb buffer manager interface routines
 *
 * Copyright (c) 2021, Alibaba Group Holding Limited
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 *
 * IDENTIFICATION
 *    src/backend/storage/buffer/polar_bufmgr.c
 *
 *-------------------------------------------------------------------------
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/polar_log.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/polar_logindex_redo.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/xlog.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"polar_flashback/polar_flashback_log.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"polar_flashback/polar_flashback_log_repair_page.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postmaster/polar_parallel_bgwriter.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/polar_bufmgr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/polar_copybuf.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/polar_fd.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/polar_flushlist.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/polar_io_stat.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/polar_pbp.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/guc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/memutils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/timestamp.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/polar_backtrace.h"</cpp:file></cpp:include>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BUF_WRITTEN</name></cpp:macro>             <cpp:value>0x01</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>STOP_PARALLEL_BGWRITER_DELAY_FACTOR</name></cpp:macro> <cpp:value>10</cpp:value></cpp:define>

<comment type="block">/*
 * POLAR: some strategies are the same as polar_delay_dml_wait()
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>POLAR_ENABLE_CRASH_RECOVERY_RTO</name><parameter_list>()</parameter_list></cpp:macro> \
	<cpp:value>(polar_enable_shared_storage_mode &amp;&amp; polar_is_master() &amp;&amp; \
	!InRecovery &amp;&amp; (MyBackendId != InvalidBackendId) &amp;&amp; \
	 PolarGlobalIOReadStats != NULL &amp;&amp; PolarGlobalIOReadStats-&gt;enabled)</cpp:value></cpp:define>

<decl_stmt><decl><type><specifier>extern</specifier> <name>ParallelBgwriterInfo</name> <modifier>*</modifier></type><name>polar_parallel_bgwriter_info</name></decl>;</decl_stmt>
<function_decl><type><specifier>extern</specifier> <name>void</name></type> <name>ResourceOwnerEnlargeBuffers</name><parameter_list>(<parameter><decl><type><name>ResourceOwner</name></type> <name>owner</name></decl></parameter>)</parameter_list>;</function_decl>

<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type>        <name>prev_sync_count</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>int64</name></type>      <name>consistent_lsn_delta</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<function_decl><type><specifier>static</specifier> <name>XLogRecPtr</name></type> <name>polar_cal_cur_consistent_lsn</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>polar_sync_buffer_from_copy_buffer</name><parameter_list>(<parameter><decl><type><name>WritebackContext</name> <modifier>*</modifier></type><name>wb_context</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>polar_start_or_stop_parallel_bgwriter</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>is_normal_bgwriter</name></decl></parameter>, <parameter><decl><type><name>uint64</name></type> <name>lag</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>evaluate_sync_buffer_num</name><parameter_list>(<parameter><decl><type><name>uint64</name></type> <name>lag</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>XLogRecPtr</name></type> <name>update_consistent_lsn_delta</name><parameter_list>(<parameter><decl><type><name>XLogRecPtr</name></type> <name>cur_consistent_lsn</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Buffer</name></type> <name>polar_bulk_read_buffer_common</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>reln</name></decl></parameter>, <parameter><decl><type><name>char</name></type> <name>relpersistence</name></decl></parameter>, <parameter><decl><type><name>ForkNumber</name></type> <name>forkNum</name></decl></parameter>,
											<parameter><decl><type><name>BlockNumber</name></type> <name>firstBlockNum</name></decl></parameter>, <parameter><decl><type><name>ReadBufferMode</name></type> <name>mode</name></decl></parameter>,
											<parameter><decl><type><name>BufferAccessStrategy</name></type> <name>strategy</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>hit</name></decl></parameter>,
											<parameter><decl><type><name>int</name></type> <name>maxBlockCount</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/* POLAR: for crash recovery rto */</comment>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>polar_get_exclusive_buffer_lock_delay</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>

<decl_stmt><decl><type><name>POLAR_PROC_GLOBAL_IO_READ</name> <modifier>*</modifier></type><name>PolarGlobalIOReadStats</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>uint64</name></type>
<name>polar_get_max_xlog_delay_throughtput</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><name><name>PolarGlobalIOReadStats</name><operator>-&gt;</operator><name>max_throughtput</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * POLAR: xlog reserver delay
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>polar_get_exclusive_buffer_lock_delay</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DELAY_TIMES</name></cpp:macro> <cpp:value>10</cpp:value></cpp:define>

	<comment type="block">/*
	 * current_delay_lsn: current delay lsn of checkpoint lsn and xlog flush lsn
 	 * last_delay_lsn: the last time delay lsn of checkpoint lsn and xlog flush lsn
	 */</comment>
	<decl_stmt><decl><type><specifier>static</specifier> <name>XLogRecPtr</name></type> <name>last_delay_lsn</name> <init>= <expr><name>InvalidXLogRecPtr</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>last_delay_count</name> <init>= <expr><name>InvalidXLogRecPtr</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>delay_times</name> <init>= <expr><name>DELAY_TIMES</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>delay_count</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>XLogRecPtr</name></type> <name>current_delay_lsn</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>PolarGlobalIOReadStats</name><operator>-&gt;</operator><name>max_throughtput</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return ;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>current_delay_lsn</name> <operator>=</operator> <call><name>polar_get_diff_checkpoint_flush_lsn</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>XLogRecPtrIsInvalid</name><argument_list>(<argument><expr><name>current_delay_lsn</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return ;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>last_delay_lsn</name> <operator>==</operator> <name>InvalidXLogRecPtr</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>last_delay_lsn</name> <operator>=</operator> <name>current_delay_lsn</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
 	 * Strategy 1: if current_delay_lsn has already execeeded the max delay throughtput, it will
	 * trigger a delay strategy in force. This will delay at most DELAY_TIMES, the delay time
	 * will be power exponent rise.
	 */</comment>
	<while>while <condition>(<expr><name>current_delay_lsn</name> <operator>&gt;</operator> <call><name>polar_get_max_xlog_delay_throughtput</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <name>delay_times</name><operator>--</operator></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG5</name></expr></argument>, <argument><expr><literal type="string">"polar_get_exclusive_buffer_lock_delay:exceed max gap, delay for %dms"</literal></expr></argument>, <argument><expr><name>polar_crash_recovery_rto_delay_count</name> <operator>*</operator> <name>delay_count</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pg_usleep</name><argument_list>(<argument><expr><name>polar_crash_recovery_rto_delay_count</name> <operator>*</operator> <literal type="number">1000</literal> <operator>*</operator> <name>delay_count</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>delay_count</name> <operator>=</operator> <name>delay_count</name> <operator>*</operator> <literal type="number">2</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>PolarGlobalIOReadStats</name><operator>-&gt;</operator><name>force_delay</name></name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block></while>
	<if_stmt><if>if <condition>(<expr><name>delay_times</name> <operator>&lt;</operator> <name>DELAY_TIMES</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG5</name></expr></argument>, <argument><expr><literal type="string">"polar_get_exclusive_buffer_lock_delay:exceed max gap, has already delay, just return"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return ;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Strategy 2: if current_delay_lsn has just execeeded the given percentage of the max delay throughtput
	 * (calculate as 'the max xlog delay throughtput' * polar_crash_recovery_rto_threshold), there are three
	 * small strategies
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>current_delay_lsn</name> <operator>&gt;</operator> <call><name>polar_get_max_xlog_delay_throughtput</name><argument_list>()</argument_list></call> <operator>*</operator> <name>polar_crash_recovery_rto_threshold</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Strategy 2.1: if current_delay_lsn is less than or equal as last_delay_lsn, means in the last delay strategy, it is
 		 * effective, just follow it in current delay strategy.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>current_delay_lsn</name> <operator>&lt;=</operator> <name>last_delay_lsn</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG5</name></expr></argument>, <argument><expr><literal type="string">"polar_get_exclusive_buffer_lock_delay:exceed threshold gap, current has less gap, delay for %dms"</literal></expr></argument>, <argument><expr><name>polar_crash_recovery_rto_delay_count</name> <operator>*</operator> <name>last_delay_count</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>pg_usleep</name><argument_list>(<argument><expr><name>polar_crash_recovery_rto_delay_count</name> <operator>*</operator> <literal type="number">1000</literal> <operator>*</operator> <name>last_delay_count</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>PolarGlobalIOReadStats</name><operator>-&gt;</operator><name>less_than_delay</name></name><operator>++</operator></expr>;</expr_stmt>
		</block_content>}</block></if>
		<comment type="block">/*
		 * Strategy 2.2: if current_delay_lsn is more than last_delay_lsn, means in the last delay strategy, it is
 		 * ineffective, the delay lsn of checkpoint and xlog flush has grown, so we delay as a power time.
		 */</comment>
		<if type="elseif">else if <condition>(<expr><name>current_delay_lsn</name> <operator>&gt;</operator> <name>last_delay_lsn</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG5</name></expr></argument>, <argument><expr><literal type="string">"polar_get_exclusive_buffer_lock_delay:exceed threshold gap, currrent has more gap, delay for %dms"</literal></expr></argument>, <argument><expr><name>polar_crash_recovery_rto_delay_count</name> <operator>*</operator> <name>last_delay_count</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>last_delay_count</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name>last_delay_count</name> <operator>&gt;=</operator> <literal type="number">1024</literal><operator>)</operator></expr> ?</condition><then> <expr><literal type="number">1024</literal></expr> </then><else>: <expr><name>last_delay_count</name> <operator>*</operator> <literal type="number">2</literal></expr></else></ternary></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>pg_usleep</name><argument_list>(<argument><expr><name>polar_crash_recovery_rto_delay_count</name> <operator>*</operator> <literal type="number">1000</literal> <operator>*</operator> <name>last_delay_count</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>PolarGlobalIOReadStats</name><operator>-&gt;</operator><name>more_than_delay</name></name><operator>++</operator></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if>
	<comment type="block">/*
	 * Strategy 3: Every time if it no need to delay xlog reserve, reset last_delay_count.
	 */</comment>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>last_delay_count</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>
	<expr_stmt><expr><name>last_delay_lsn</name> <operator>=</operator> <call><name>polar_get_diff_checkpoint_flush_lsn</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Reset oldest lsn to invalid and remove it from flushlist. */</comment>
<function><type><name>void</name></type>
<name>polar_reset_buffer_oldest_lsn</name><parameter_list>(<parameter><decl><type><name>BufferDesc</name> <modifier>*</modifier></type><name>buf_hdr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>XLogRecPtr</name></type> <name>oldest_lsn</name> <init>= <expr><call><name>polar_buffer_get_oldest_lsn</name><argument_list>(<argument><expr><name>buf_hdr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>XLogRecPtr</name></type> <name>consistent_lsn</name> <init>= <expr><call><name>polar_get_consistent_lsn</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>XLogRecPtrIsInvalid</name><argument_list>(<argument><expr><name>oldest_lsn</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>buf_hdr</name><operator>-&gt;</operator><name>recently_modified_count</name></name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/*
		 * In master, we should check all flush related flag clear,
		 * so we assert each flags.
		 */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>(</operator><name><name>buf_hdr</name><operator>-&gt;</operator><name>polar_flags</name></name> <operator>&amp;</operator> <name>POLAR_BUF_OLDEST_LSN_IS_FAKE</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>(</operator><name><name>buf_hdr</name><operator>-&gt;</operator><name>polar_flags</name></name> <operator>&amp;</operator> <name>POLAR_BUF_FIRST_TOUCHED_AFTER_COPY</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* This should not happen */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>XLogRecPtrIsInvalid</name><argument_list>(<argument><expr><name>consistent_lsn</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>oldest_lsn</name> <operator>&lt;</operator> <name>consistent_lsn</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>, <argument><expr><literal type="string">"Buffer ([%u,%u,%u], %u, %d) oldest lsn %X/%X is less than consistent lsn %X/%X"</literal></expr></argument>,
				 <argument><expr><name><name>buf_hdr</name><operator>-&gt;</operator><name>tag</name><operator>.</operator><name>rnode</name><operator>.</operator><name>spcNode</name></name></expr></argument>,
				 <argument><expr><name><name>buf_hdr</name><operator>-&gt;</operator><name>tag</name><operator>.</operator><name>rnode</name><operator>.</operator><name>dbNode</name></name></expr></argument>,
				 <argument><expr><name><name>buf_hdr</name><operator>-&gt;</operator><name>tag</name><operator>.</operator><name>rnode</name><operator>.</operator><name>relNode</name></name></expr></argument>,
				 <argument><expr><name><name>buf_hdr</name><operator>-&gt;</operator><name>tag</name><operator>.</operator><name>blockNum</name></name></expr></argument>,
				 <argument><expr><name><name>buf_hdr</name><operator>-&gt;</operator><name>tag</name><operator>.</operator><name>forkNum</name></name></expr></argument>,
				 <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator><operator>(</operator><name>oldest_lsn</name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr></argument>, <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <name>oldest_lsn</name></expr></argument>,
				 <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator><operator>(</operator><name>consistent_lsn</name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr></argument>, <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <name>consistent_lsn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name><name>buf_hdr</name><operator>-&gt;</operator><name>recently_modified_count</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>buf_hdr</name><operator>-&gt;</operator><name>polar_flags</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>polar_remove_buffer_from_flush_list</name><argument_list>(<argument><expr><name>buf_hdr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * polar_bg_buffer_sync - Write out some dirty buffers in the flushlist.
 *
 * This is called periodically by the background writer process.
 *
 * Returns true if it's appropriate for the bgwriter process to go into
 * low-power hibernation mode.
 */</comment>
<function><type><name>bool</name></type>
<name>polar_bg_buffer_sync</name><parameter_list>(<parameter><decl><type><name>WritebackContext</name> <modifier>*</modifier></type><name>wb_context</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type>       <name>res</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>XLogRecPtr</name></type> <name>consistent_lsn</name> <init>= <expr><name>InvalidXLogRecPtr</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* Use normal BgBufferSync */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>polar_enable_shared_storage_mode</name> <operator>||</operator> <call><name>polar_in_replica_mode</name><argument_list>()</argument_list></call> <operator>||</operator>
			<call><name>polar_get_bg_redo_state</name><argument_list>(<argument><expr><name>polar_logindex_redo_instance</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>POLAR_BG_WAITING_RESET</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><call><name>BgBufferSync</name><argument_list>(<argument><expr><name>wb_context</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * For polardb, it should enable the flush list, otherwise, the consistent
	 * lsn always is invalid.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>polar_flush_list_enabled</name><argument_list>()</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>polar_enable_normal_bgwriter</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>BgBufferSync</name><argument_list>(<argument><expr><name>wb_context</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>polar_buffer_sync</name><argument_list>(<argument><expr><name>wb_context</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>consistent_lsn</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call> <operator>||</operator> <name>res</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>BgBufferSync</name><argument_list>(<argument><expr><name>wb_context</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<expr_stmt><expr><call><name>polar_set_consistent_lsn</name><argument_list>(<argument><expr><name>consistent_lsn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>res</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Whether we should control the vm buffer to flush. */</comment>
<function><type><name>bool</name></type>
<name>polar_donot_control_vm_buffer</name><parameter_list>(<parameter><decl><type><name>BufferDesc</name> <modifier>*</modifier></type><name>buf_hdr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>buf_hdr</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name><name>buf_hdr</name><operator>-&gt;</operator><name>tag</name><operator>.</operator><name>forkNum</name></name> <operator>==</operator> <name>VISIBILITYMAP_FORKNUM</name> <operator>&amp;&amp;</operator>
		   <operator>!</operator><name>polar_enable_control_vm_flush</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Calculate current consistent lsn, it is the minimum between first buffer of
 * flush list and all copy buffers. If oldest lsn of all buffers are invalid,
 * we use current insert RecPtr, because some commands generate wal records
 * but do not set any buffers oldest lsn.
 */</comment>
<function><type><specifier>static</specifier> <name>XLogRecPtr</name></type>
<name>polar_cal_cur_consistent_lsn</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>BufferDesc</name> <modifier>*</modifier></type><name>buf</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>XLogRecPtr</name></type>  <name>clsn</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>XLogRecPtr</name></type>  <name>lsn</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>polar_flush_list_enabled</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>SpinLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>polar_flush_list_ctl</name><operator>-&gt;</operator><name>flushlist_lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>polar_flush_list_is_empty</name><argument_list>()</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>unlikely</name><argument_list>(<argument><expr><call><name>polar_bg_redo_state_is_parallel</name><argument_list>(<argument><expr><name>polar_logindex_redo_instance</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>lsn</name> <operator>=</operator> <call><name>polar_online_promote_fake_oldest_lsn</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>lsn</name> <operator>=</operator> <call><name>polar_max_valid_lsn</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<expr_stmt><expr><call><name>SpinLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>polar_flush_list_ctl</name><operator>-&gt;</operator><name>flushlist_lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>polar_enable_debug</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>,
				 <argument><expr><literal type="string">"The flush list is empty, so use current insert lsn %X/%X as consistent lsn."</literal></expr></argument>,
				 <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator><operator>(</operator><name>lsn</name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr></argument>,
				 <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <name>lsn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<return>return <expr><name>lsn</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>polar_flush_list_ctl</name><operator>-&gt;</operator><name>first_flush_buffer</name></name> <operator>&gt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>buf</name> <operator>=</operator> <call><name>GetBufferDescriptor</name><argument_list>(<argument><expr><name><name>polar_flush_list_ctl</name><operator>-&gt;</operator><name>first_flush_buffer</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>lsn</name> <operator>=</operator> <call><name>pg_atomic_read_u64</name><argument_list>(<argument><expr><operator>(</operator><name>pg_atomic_uint64</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name><name>buf</name><operator>-&gt;</operator><name>oldest_lsn</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>SpinLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>polar_flush_list_ctl</name><operator>-&gt;</operator><name>flushlist_lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>clsn</name> <operator>=</operator> <call><name>polar_copy_buffers_get_oldest_lsn</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>XLogRecPtrIsInvalid</name><argument_list>(<argument><expr><name>clsn</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>lsn</name> <operator>=</operator> <call><name>Min</name><argument_list>(<argument><expr><name>lsn</name></expr></argument>, <argument><expr><name>clsn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>lsn</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>bool</name></type>
<name>polar_buffer_can_be_flushed</name><parameter_list>(<parameter><decl><type><name>BufferDesc</name> <modifier>*</modifier></type><name>buf_hdr</name></decl></parameter>,
							<parameter><decl><type><name>XLogRecPtr</name></type> <name>oldest_apply_lsn</name></decl></parameter>,
							<parameter><decl><type><name>bool</name></type> <name>use_cbuf</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>uint32</name></type>              <name>buf_state</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>                <name>res</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>XLogRecPtr</name></type>          <name>latest_lsn</name> <init>= <expr><call><name>BufferGetLSN</name><argument_list>(<argument><expr><name>buf_hdr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CopyBufferDesc</name>      <modifier>*</modifier></type><name>cbuf</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>polar_enable_shared_storage_mode</name> <operator>||</operator>
			<call><name>XLogRecPtrIsInvalid</name><argument_list>(<argument><expr><name>oldest_apply_lsn</name></expr></argument>)</argument_list></call> <operator>||</operator>
			<operator>(</operator><name>latest_lsn</name> <operator>&lt;=</operator> <name>oldest_apply_lsn</name><operator>)</operator> <operator>||</operator>
			<operator>(</operator><name><name>buf_hdr</name><operator>-&gt;</operator><name>tag</name><operator>.</operator><name>forkNum</name></name> <operator>==</operator> <name>FSM_FORKNUM</name><operator>)</operator> <operator>||</operator>
			<operator>(</operator><name><name>buf_hdr</name><operator>-&gt;</operator><name>tag</name><operator>.</operator><name>forkNum</name></name> <operator>==</operator> <name>INIT_FORKNUM</name><operator>)</operator> <operator>||</operator>
			<operator>(</operator><call><name>polar_donot_control_vm_buffer</name><argument_list>(<argument><expr><name>buf_hdr</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><name>use_cbuf</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>buf_state</name> <operator>=</operator> <call><name>LockBufHdr</name><argument_list>(<argument><expr><name>buf_hdr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>cbuf</name> <operator>=</operator> <name><name>buf_hdr</name><operator>-&gt;</operator><name>copy_buffer</name></name></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>cbuf</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>polar_copy_buffer_get_lsn</name><argument_list>(<argument><expr><name>cbuf</name></expr></argument>)</argument_list></call> <operator>&lt;=</operator> <name>oldest_apply_lsn</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>UnlockBufHdr</name><argument_list>(<argument><expr><name>buf_hdr</name></expr></argument>, <argument><expr><name>buf_state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>cbuf</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>res</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>pg_atomic_add_fetch_u32</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>cbuf</name><operator>-&gt;</operator><name>pass_count</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>res</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * For lazy checkpoint, we only flush buffers that background writer does not
 * flush; for normal checkpoint, we check whether the buffer can be flushed,
 * buffers that can be flushed will be flushed by checkpoint.
 */</comment>
<function><type><name>bool</name></type>
<name>polar_buffer_can_be_flushed_by_checkpoint</name><parameter_list>(<parameter><decl><type><name>BufferDesc</name> <modifier>*</modifier></type><name>buf_hdr</name></decl></parameter>,
										  <parameter><decl><type><name>XLogRecPtr</name></type> <name>oldest_apply_lsn</name></decl></parameter>,
										  <parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>flags</name> <operator>&amp;</operator> <name>CHECKPOINT_LAZY</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>buf_hdr</name><operator>-&gt;</operator><name>tag</name><operator>.</operator><name>forkNum</name></name> <operator>==</operator> <name>FSM_FORKNUM</name> <operator>||</operator>
				<name><name>buf_hdr</name><operator>-&gt;</operator><name>tag</name><operator>.</operator><name>forkNum</name></name> <operator>==</operator> <name>INIT_FORKNUM</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>true</name></expr>;</return></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<return>return <expr><name>false</name></expr>;</return></block_content></block></else></if_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<return>return <expr><call><name>polar_buffer_can_be_flushed</name><argument_list>(<argument><expr><name>buf_hdr</name></expr></argument>, <argument><expr><name>oldest_apply_lsn</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/* polar_buffer_sync - Sync buffers that are getting from flushlist.
 *
 * Returns true if it's appropriate for the bgwriter process to go into
 * low-power hibernation mode.
 */</comment>
<function><type><name>bool</name></type>
<name>polar_buffer_sync</name><parameter_list>(<parameter><decl><type><name>WritebackContext</name> <modifier>*</modifier></type><name>wb_context</name></decl></parameter>,
				  <parameter><decl><type><name>XLogRecPtr</name> <modifier>*</modifier></type><name>consistent_lsn</name></decl></parameter>,
				  <parameter><decl><type><name>bool</name></type> <name>is_normal_bgwriter</name></decl></parameter>,
				  <parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>static</specifier> <name>int</name>       <modifier>*</modifier></type><name>batch_buf</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>XLogRecPtr</name></type> <name>cur_consistent_lsn</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>XLogRecPtr</name></type> <name>oldest_apply_lsn</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>        <name>num_written</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>        <name>num_to_sync</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>        <name>sync_count</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint64</name></type>     <name>sleep_lag</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint64</name></type>     <name>lag</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>batch_buf</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<comment type="block">/* This is a static variable, do not need to free it explicitly. */</comment>
		<expr_stmt><expr><name>batch_buf</name> <operator>=</operator> <operator>(</operator><name>int</name> <operator>*</operator><operator>)</operator> <call><name>malloc</name><argument_list>(<argument><expr><name>polar_bgwriter_batch_size_flushlist</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>cur_consistent_lsn</name> <operator>=</operator> <call><name>polar_get_consistent_lsn</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>sleep_lag</name> <operator>=</operator> <name>polar_bgwriter_sleep_lsn_lag</name> <operator>*</operator> <literal type="number">1024</literal> <operator>*</operator> <literal type="number">1024L</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>oldest_apply_lsn</name> <operator>=</operator> <call><name>polar_get_oldest_applied_lsn</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>XLogRecPtrIsInvalid</name><argument_list>(<argument><expr><name>oldest_apply_lsn</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>lag</name> <operator>=</operator> <call><name>polar_max_valid_lsn</name><argument_list>()</argument_list></call> <operator>-</operator> <name>cur_consistent_lsn</name></expr>;</expr_stmt></block_content></block></if>
	<comment type="block">/* POLAR: when enable fullpage snapshot, we don't care about oledest_applied_lsn anymore */</comment>
	<if type="elseif">else if <condition>(<expr><call><name>POLAR_LOGINDEX_ENABLE_FULLPAGE</name><argument_list>()</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>uint64</name></type>  <name>consistent_lsn_lag</name> <init>= <expr><call><name>polar_max_valid_lsn</name><argument_list>()</argument_list></call> <operator>-</operator> <name>cur_consistent_lsn</name></expr></init></decl>;</decl_stmt>

		<comment type="block">/* If consistent_lsn is too old, start to trigger to write fullpage */</comment>
		<if_stmt><if>if <condition>(<expr><name>consistent_lsn_lag</name> <operator>&gt;</operator> <name>polar_fullpage_snapshot_oldest_lsn_delay_threshold</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>lag</name> <operator>=</operator> <name>consistent_lsn_lag</name> <operator>-</operator> <name>polar_fullpage_snapshot_oldest_lsn_delay_threshold</name></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>lag</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>lag</name> <operator>=</operator> <ternary><condition><expr><name>oldest_apply_lsn</name> <operator>&gt;</operator> <name>cur_consistent_lsn</name></expr> ?</condition><then> <expr><name>oldest_apply_lsn</name> <operator>-</operator> <name>cur_consistent_lsn</name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/* Normal background writer will create or close some parallel background workers. */</comment>
	<expr_stmt><expr><call><name>polar_start_or_stop_parallel_bgwriter</name><argument_list>(<argument><expr><name>is_normal_bgwriter</name></expr></argument>, <argument><expr><name>lag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Evaluate the number of buffers to sync. */</comment>
	<expr_stmt><expr><name>num_to_sync</name> <operator>=</operator> <call><name>evaluate_sync_buffer_num</name><argument_list>(<argument><expr><name>lag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Only normal bgwriter sync buffers from the copy buffer. */</comment>
	<if_stmt><if>if <condition>(<expr><name>is_normal_bgwriter</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>polar_sync_buffer_from_copy_buffer</name><argument_list>(<argument><expr><name>wb_context</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>polar_enable_debug</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>, <argument><expr><literal type="string">"Try to get %d buffers to flush from flushlist"</literal></expr></argument>, <argument><expr><name>num_to_sync</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Make sure we can handle the pin inside SyncOneBuffer */</comment>
	<expr_stmt><expr><call><name>ResourceOwnerEnlargeBuffers</name><argument_list>(<argument><expr><name>CurrentResourceOwner</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<while>while <condition>(<expr><name>sync_count</name> <operator>&lt;</operator> <name>num_to_sync</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type> <name>num</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

		<comment type="block">/* Get buffers from flush list */</comment>
		<expr_stmt><expr><name>num</name> <operator>=</operator> <call><name>polar_get_batch_flush_buffer</name><argument_list>(<argument><expr><name>batch_buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>num</name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <name>batch_buf</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>

		<comment type="block">/* Sync buffers */</comment>
		<while>while <condition>(<expr><name>i</name> <operator>&lt;</operator> <name>num</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>int</name></type> <name>sync_state</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><name>sync_state</name> <operator>=</operator> <call><name>SyncOneBuffer</name><argument_list>(<argument><expr><name><name>batch_buf</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,
									   <argument><expr><name>false</name></expr></argument>,
									   <argument><expr><name>wb_context</name></expr></argument>,
									   <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name>sync_state</name> <operator>&amp;</operator> <name>BUF_WRITTEN</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>num_written</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></while>

		<expr_stmt><expr><name>sync_count</name> <operator>+=</operator> <name>num</name></expr>;</expr_stmt>
	</block_content>}</block></while>

	<expr_stmt><expr><name><name>BgWriterStats</name><operator>.</operator><name>m_buf_written_clean</name></name> <operator>+=</operator> <name>num_written</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Reset StrategyControl-&gt;numBufferAllocs and report buffer alloc counts to pgstat.
	 *
	 * If BgBufferSync() is enabled, we can't do it. We should let BgBufferSync() handle it.
	 * Because BgBufferSync() use StrategyControl-&gt;numBufferAllocs as an important parameter
	 * to calculate the counter of pages to be scanned/flushed.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>polar_enable_normal_bgwriter</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>uint32</name></type>     <name>recent_alloc</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>StrategySyncStart</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>recent_alloc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>BgWriterStats</name><operator>.</operator><name>m_buf_alloc</name></name> <operator>+=</operator> <name>recent_alloc</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><operator>*</operator><name>consistent_lsn</name> <operator>=</operator> <call><name>update_consistent_lsn_delta</name><argument_list>(<argument><expr><name>cur_consistent_lsn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>lag</name> <operator>&lt;</operator> <name>sleep_lag</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>XLogRecPtr</name></type>
<name>update_consistent_lsn_delta</name><parameter_list>(<parameter><decl><type><name>XLogRecPtr</name></type> <name>cur_consistent_lsn</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>XLogRecPtr</name></type> <name>next_consistent_lsn</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>polar_logindex_redo_instance</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>unlikely</name><argument_list>(<argument><expr><call><name>polar_get_bg_redo_state</name><argument_list>(<argument><expr><name>polar_logindex_redo_instance</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>POLAR_BG_WAITING_RESET</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * During online promote when node is in rw mode, the logindex background state could be POLAR_BG_WAITING_RESET or POLAR_BG_ONLINE_PROMOTE.
			 * If logindex background state is POLAR_BG_WAITING_RESET then we can not accept connection
			 * from the client and the dirty buffer flush list is empty.
			 * So we don't update consistent lsn when the state is POLAR_BG_WAITING_RESET.
			 */</comment>
			<return>return <expr><name>cur_consistent_lsn</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>next_consistent_lsn</name> <operator>=</operator> <call><name>polar_cal_cur_consistent_lsn</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>consistent_lsn_delta</name> <operator>=</operator> <name>next_consistent_lsn</name> <operator>-</operator> <name>cur_consistent_lsn</name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>consistent_lsn_delta</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>polar_logindex_redo_instance</name>
				<operator>&amp;&amp;</operator> <operator>(</operator><call><name>XLogRecPtrIsInvalid</name><argument_list>(<argument><expr><name><name>polar_logindex_redo_instance</name><operator>-&gt;</operator><name>xlog_replay_from</name></name></expr></argument>)</argument_list></call>
					<operator>||</operator> <name>next_consistent_lsn</name> <operator>&lt;</operator> <name><name>polar_logindex_redo_instance</name><operator>-&gt;</operator><name>xlog_replay_from</name></name><operator>)</operator></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * BgWriter may start before logindex is initialized, and then it set consistent lsn as the checkpoint redo position.
			 * When logindex is initialized, it may change to replay from previsiou lsn, which is smaller than checkpoint redo lsn.
			 * Before xlog_replay_from we only insert record to logindex table and don't replay page buffer, so there's no dirty
			 * buffer in flush list. But we may set lastReplayedEndRecPtr as next consistent lsn, which is smaller than previous
			 * calculated consistent lsn. We ignore new calculated value in this case.
			 */</comment>
			<expr_stmt><expr><name>consistent_lsn_delta</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			<return>return <expr><name>cur_consistent_lsn</name></expr>;</return>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>PANIC</name></expr></argument>,
			 <argument><expr><literal type="string">"Current consistent lsn %X/%X is great than next consistent lsn %X/%X"</literal></expr></argument>,
			 <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator><operator>(</operator><name>cur_consistent_lsn</name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr></argument>,
			 <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <name>cur_consistent_lsn</name></expr></argument>,
			 <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator><operator>(</operator><name>next_consistent_lsn</name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr></argument>,
			 <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <name>next_consistent_lsn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>next_consistent_lsn</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Evaluate the number of buffers to sync. */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>evaluate_sync_buffer_num</name><parameter_list>(<parameter><decl><type><name>uint64</name></type> <name>lag</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>        <name>num_to_sync</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type>     <name>sync_per_lsn</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint64</name></type>     <name>max_lag</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type>     <name>cons_delta_per_worker</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>        <name>current_workers</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>polar_parallel_bgwriter_enabled</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>current_workers</name> <operator>=</operator> <name>CURRENT_PARALLEL_WORKERS</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>cons_delta_per_worker</name> <operator>=</operator> <name>consistent_lsn_delta</name> <operator>/</operator> <operator>(</operator><name>current_workers</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>

	<expr_stmt><expr><name>sync_per_lsn</name> <operator>=</operator> <operator>(</operator><name>double</name><operator>)</operator> <name>prev_sync_count</name> <operator>/</operator> <operator>(</operator><name>cons_delta_per_worker</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>

	<comment type="block">/* Avoid overflow */</comment>
	<expr_stmt><expr><name>max_lag</name> <operator>=</operator> <name>polar_bgwriter_max_batch_size</name> <operator>/</operator> <operator>(</operator><name>sync_per_lsn</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>lag</name> <operator>&gt;</operator> <name>max_lag</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>num_to_sync</name> <operator>=</operator> <name>polar_bgwriter_max_batch_size</name></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>num_to_sync</name> <operator>=</operator> <name>lag</name> <operator>*</operator> <name>sync_per_lsn</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>num_to_sync</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>num_to_sync</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>num_to_sync</name> <operator>=</operator> <name>polar_bgwriter_batch_size_flushlist</name> <operator>/</operator> <literal type="number">10</literal> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>prev_sync_count</name> <operator>=</operator> <name>num_to_sync</name></expr>;</expr_stmt>

	<return>return <expr><name>num_to_sync</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Normal background writer can start or stop some parallel background workers. */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>polar_start_or_stop_parallel_bgwriter</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>is_normal_bgwriter</name></decl></parameter>, <parameter><decl><type><name>uint64</name></type> <name>lag</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>static</specifier> <name>TimestampTz</name></type> <name>last_check_start_tz</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>static</specifier> <name>TimestampTz</name></type> <name>last_check_stop_tz</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>bool</name></type>        <name>ok</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>         <name>at_most_workers</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>         <name>current_workers</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>is_normal_bgwriter</name> <operator>||</operator> <call><name>RecoveryInProgress</name><argument_list>()</argument_list></call> <operator>||</operator> <name>lag</name> <operator>&lt;=</operator> <literal type="number">0</literal> <operator>||</operator>
			<operator>!</operator><call><name>polar_parallel_bgwriter_enabled</name><argument_list>()</argument_list></call> <operator>||</operator>
			<operator>!</operator><name>polar_parallel_bgwriter_enable_dynamic</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * The consistent lsn does not be updated. It may be unhelpful to add or
	 * stop parallel writers, so we do nothing.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>consistent_lsn_delta</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>polar_enable_debug</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>XLogRecPtr</name></type>  <name>consistent_lsn</name> <init>= <expr><call><name>polar_get_consistent_lsn</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
				 <argument><expr><literal type="string">"Consistent lsn does not update, current consistent lsn is %X/%X"</literal></expr></argument>,
				 <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator><operator>(</operator><name>consistent_lsn</name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr></argument>,
				 <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <name>consistent_lsn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>consistent_lsn_delta</name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>current_workers</name> <operator>=</operator> <name>CURRENT_PARALLEL_WORKERS</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>at_most_workers</name> <operator>=</operator> <name>POLAR_MAX_BGWRITER_WORKERS</name></expr>;</expr_stmt>

	<comment type="block">/* Try to start one parallel background writer */</comment>
	<if_stmt><if>if <condition>(<expr><name>lag</name> <operator>&gt;</operator> <operator>(</operator><name>polar_parallel_new_bgwriter_threshold_lag</name> <operator>*</operator> <literal type="number">1024</literal> <operator>*</operator> <literal type="number">1024L</literal><operator>)</operator></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Reset the last check stop timestamp */</comment>
		<expr_stmt><expr><name>last_check_stop_tz</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>current_workers</name> <operator>&gt;=</operator> <name>at_most_workers</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>polar_enable_debug</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
					 <argument><expr><literal type="string">"Can not start new parallel background workers, current workers: %d, at most workers %d"</literal></expr></argument>,
					 <argument><expr><name>current_workers</name></expr></argument>, <argument><expr><name>at_most_workers</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<return>return;</return>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>last_check_start_tz</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>last_check_start_tz</name> <operator>=</operator> <call><name>GetCurrentTimestamp</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<return>return;</return>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name>ok</name> <operator>=</operator> <call><name>TimestampDifferenceExceeds</name><argument_list>(<argument><expr><name>last_check_start_tz</name></expr></argument>,
										<argument><expr><call><name>GetCurrentTimestamp</name><argument_list>()</argument_list></call></expr></argument>,
										<argument><expr><name>polar_parallel_new_bgwriter_threshold_time</name> <operator>*</operator> <literal type="number">1000L</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Once start one */</comment>
		<if_stmt><if>if <condition>(<expr><name>ok</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>polar_register_parallel_bgwriter_workers</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>last_check_start_tz</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if>

	<comment type="block">/* Try to stop one parallel background writer */</comment>
	<if type="elseif">else if <condition>(<expr><name>current_workers</name> <operator>&gt;</operator> <name>polar_parallel_bgwriter_workers</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Reset the last check start timestamp */</comment>
		<expr_stmt><expr><name>last_check_start_tz</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>last_check_stop_tz</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>last_check_stop_tz</name> <operator>=</operator> <call><name>GetCurrentTimestamp</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<return>return;</return>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* Stop a background writer slowly, so wait more time. */</comment>
		<expr_stmt><expr><name>ok</name> <operator>=</operator> <call><name>TimestampDifferenceExceeds</name><argument_list>(<argument><expr><name>last_check_stop_tz</name></expr></argument>,
										<argument><expr><call><name>GetCurrentTimestamp</name><argument_list>()</argument_list></call></expr></argument>,
										<argument><expr><name>polar_parallel_new_bgwriter_threshold_time</name> <operator>*</operator>
										<literal type="number">1000L</literal> <operator>*</operator> <name>STOP_PARALLEL_BGWRITER_DELAY_FACTOR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Once stop one */</comment>
		<if_stmt><if>if <condition>(<expr><name>ok</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>polar_shutdown_parallel_bgwriter_workers</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>last_check_stop_tz</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * polar_redo_set_buffer_oldest_lsn - Set the buffer oldest lsn when redo.
 *
 * When redo, we have a valid record, so we set buffer oldest lsn to
 * record-&gt;ReadRecPtr. Do not use record-&gt;EndRecPtr, because oldest lsn
 * is always the start of wal not the end.
 */</comment>
<function><type><name>void</name></type>
<name>polar_redo_set_buffer_oldest_lsn</name><parameter_list>(<parameter><decl><type><name>Buffer</name></type> <name>buffer</name></decl></parameter>, <parameter><decl><type><name>XLogRecPtr</name></type> <name>lsn</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>BufferDesc</name> <modifier>*</modifier></type><name>buf_hdr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>XLogRecPtr</name></type>  <name>oldest_lsn</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>polar_flush_list_enabled</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>BufferIsValid</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"bad buffer ID: %d"</literal></expr></argument>, <argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>buf_hdr</name> <operator>=</operator> <call><name>GetBufferDescriptor</name><argument_list>(<argument><expr><name>buffer</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>XLogRecPtrIsInvalid</name><argument_list>(<argument><expr><name>lsn</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>POLAR_LOG_BUFFER_DESC</name><argument_list>(<argument><expr><name>buf_hdr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>PANIC</name></expr></argument>, <argument><expr><literal type="string">"Set invalid oldest lsn."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>BufferIsPinned</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* POLAR: If ro promoted to be rw, then we will mark buffer dirty when read buffer from storage and replay xlog */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>LWLockHeldByMeInMode</name><argument_list>(<argument><expr><call><name>BufferDescriptorGetContentLock</name><argument_list>(<argument><expr><name>buf_hdr</name></expr></argument>)</argument_list></call></expr></argument>,
								<argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call>
		   <operator>||</operator> <call><name>LWLockHeldByMeInMode</name><argument_list>(<argument><expr><call><name>BufferDescriptorGetIOLock</name><argument_list>(<argument><expr><name>buf_hdr</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>oldest_lsn</name> <operator>=</operator> <call><name>polar_buffer_get_oldest_lsn</name><argument_list>(<argument><expr><name>buf_hdr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * For standby or master in recovery, it always call this function to set
	 * a valid oldest lsn.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>XLogRecPtrIsInvalid</name><argument_list>(<argument><expr><name>oldest_lsn</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>polar_put_buffer_to_flush_list</name><argument_list>(<argument><expr><name>buf_hdr</name></expr></argument>, <argument><expr><name>lsn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name><name>buf_hdr</name><operator>-&gt;</operator><name>recently_modified_count</name></name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * polar_set_buffer_fake_oldest_lsn - Set a fake oldest_lsn for the buffer.
 *
 * Since generating lsn and inserting buffer to flushlist is not atomic, when
 * call MarkBufferDirty, we set a fake lsn for buffer and put it into flushlist.
 * The fake lsn is from GetXLogInsertRecPtr, it is incremental.
 */</comment>
<function><type><name>void</name></type>
<name>polar_set_buffer_fake_oldest_lsn</name><parameter_list>(<parameter><decl><type><name>BufferDesc</name> <modifier>*</modifier></type><name>buf_hdr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>XLogRecPtr</name></type>  <name>oldest_lsn</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>        <name>set</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * If server is in recovery, the buffer should be set a real lsn, so do not
	 * need to set a fake.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>polar_flush_list_enabled</name><argument_list>()</argument_list></call> <operator>||</operator>
		<operator>(</operator><call><name>RecoveryInProgress</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator>
		 <operator>!</operator><call><name>polar_bg_redo_state_is_parallel</name><argument_list>(<argument><expr><name>polar_logindex_redo_instance</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>BufferIsPinned</name><argument_list>(<argument><expr><call><name>BufferDescriptorGetBuffer</name><argument_list>(<argument><expr><name>buf_hdr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * POLAR: If ro promoted to be rw, then we will mark buffer dirty when read
	 * buffer from storage and replay xlog.
	 */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>LWLockHeldByMeInMode</name><argument_list>(<argument><expr><call><name>BufferDescriptorGetContentLock</name><argument_list>(<argument><expr><name>buf_hdr</name></expr></argument>)</argument_list></call></expr></argument>,
								<argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call>
		   <operator>||</operator> <call><name>LWLockHeldByMeInMode</name><argument_list>(<argument><expr><call><name>BufferDescriptorGetIOLock</name><argument_list>(<argument><expr><name>buf_hdr</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>oldest_lsn</name> <operator>=</operator> <call><name>polar_buffer_get_oldest_lsn</name><argument_list>(<argument><expr><name>buf_hdr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If oldest lsn is invalid, set a fake one and put buffer into flush list.
	 * If already has a valid oldest lsn, and it is first touched after copy,
	 * we also set one new fake oldest lsn.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>XLogRecPtrIsInvalid</name><argument_list>(<argument><expr><name>oldest_lsn</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>polar_put_buffer_to_flush_list</name><argument_list>(<argument><expr><name>buf_hdr</name></expr></argument>, <argument><expr><name>InvalidXLogRecPtr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>buf_hdr</name><operator>-&gt;</operator><name>polar_flags</name></name> <operator>|=</operator> <name>POLAR_BUF_OLDEST_LSN_IS_FAKE</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>set</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>polar_buffer_first_touch_after_copy</name><argument_list>(<argument><expr><name>buf_hdr</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Adjust its position in the flush list */</comment>
		<expr_stmt><expr><call><name>polar_adjust_position_in_flush_list</name><argument_list>(<argument><expr><name>buf_hdr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* First touch after copy done */</comment>
		<expr_stmt><expr><name><name>buf_hdr</name><operator>-&gt;</operator><name>polar_flags</name></name> <operator>|=</operator> <name>POLAR_BUF_FIRST_TOUCHED_AFTER_COPY</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>set</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>unlikely</name><argument_list>(<argument><expr><name>polar_trace_logindex_messages</name> <operator>&lt;=</operator> <name>DEBUG3</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>set</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>POLAR_LOG_BUFFER_DESC</name><argument_list>(<argument><expr><name>buf_hdr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name><name>buf_hdr</name><operator>-&gt;</operator><name>recently_modified_count</name></name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>polar_sync_buffer_from_copy_buffer</name><parameter_list>(<parameter><decl><type><name>WritebackContext</name> <modifier>*</modifier></type><name>wb_context</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CopyBufferDesc</name> <modifier>*</modifier></type><name>cbuf</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name></type>          <name>buf_id</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>polar_enable_copy_buffer</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/* Make sure we can handle the pin inside SyncOneBuffer */</comment>
	<expr_stmt><expr><call><name>ResourceOwnerEnlargeBuffers</name><argument_list>(<argument><expr><name>CurrentResourceOwner</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>polar_copy_buffers</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><name>cbuf</name> <operator>=</operator> <call><name>polar_get_copy_buffer_descriptor</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>buf_id</name> <operator>=</operator> <call><name>pg_atomic_read_u32</name><argument_list>(<argument><expr><operator>(</operator><name>pg_atomic_uint32</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name><name>cbuf</name><operator>-&gt;</operator><name>origin_buffer</name></name></expr></argument>)</argument_list></call> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>buf_id</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * SyncOneBuffer try to flush the original buffer, if it can be flushed,
		 * flush it and free its copy buffer, otherwise, flush its copy buffer.
		 */</comment>
		<expr_stmt><expr><call><name>SyncOneBuffer</name><argument_list>(<argument><expr><name>buf_id</name></expr></argument>,
					  <argument><expr><name>false</name></expr></argument>,
					  <argument><expr><name>wb_context</name></expr></argument>,
					  <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>
</block_content>}</block></function>

<comment type="block">/*
 * POLAR: An extended version LockBuffer. It can detect outdate status
 * before obtaining the lock.
 *
 * If fresh_check is True, it will try to check flag of corresponding buffer
 * descriptor and do replay, otherwise it will do what the origin one do.
 */</comment>
<function><type><name>void</name></type>
<name>polar_lock_buffer_ext</name><parameter_list>(<parameter><decl><type><name>Buffer</name></type> <name>buffer</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>mode</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>fresh_check</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>BufferDesc</name>  <modifier>*</modifier></type><name>buf_desc</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>BufferIsValid</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>BufferIsLocal</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>                 <comment type="block">/* local buffers need no lock */</comment>

	<expr_stmt><expr><name>buf_desc</name> <operator>=</operator> <call><name>GetBufferDescriptor</name><argument_list>(<argument><expr><name>buffer</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<do>do
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>mode</name> <operator>==</operator> <name>BUFFER_LOCK_UNLOCK</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* POLAR: clear unrecoverable flag safe now */</comment>
			<expr_stmt><expr><call><name>polar_clear_buffer_unrecoverable_flag</name><argument_list>(<argument><expr><name>buf_desc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><call><name>BufferDescriptorGetContentLock</name><argument_list>(<argument><expr><name>buf_desc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<return>return;</return>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name>mode</name> <operator>==</operator> <name>BUFFER_LOCK_SHARE</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><call><name>BufferDescriptorGetContentLock</name><argument_list>(<argument><expr><name>buf_desc</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>LW_SHARED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><name>mode</name> <operator>==</operator> <name>BUFFER_LOCK_EXCLUSIVE</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>bool</name></type>	<name>need_origin_buffer</name> <init>= <expr><operator>!</operator><name>fresh_check</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>RecoveryInProgress</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <call><name>polar_is_flog_enabled</name><argument_list>(<argument><expr><name>flog_instance</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<comment type="block">/* POLAR: check if we should delay xlog reserve insert for crash recovery rto */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>POLAR_ENABLE_CRASH_RECOVERY_RTO</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>polar_get_exclusive_buffer_lock_delay</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><call><name>BufferDescriptorGetContentLock</name><argument_list>(<argument><expr><name>buf_desc</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* Add the page to origin buffer */</comment>
			<if_stmt><if>if <condition>(<expr><name>need_origin_buffer</name> <operator>&amp;&amp;</operator>
					<call><name>polar_is_flog_needed</name><argument_list>(<argument><expr><name>flog_instance</name></expr></argument>, <argument><expr><name>polar_logindex_redo_instance</name></expr></argument>,
					<argument><expr><name><name>buf_desc</name><operator>-&gt;</operator><name>tag</name><operator>.</operator><name>forkNum</name></name></expr></argument>, <argument><expr><call><name>BufHdrGetBlock</name><argument_list>(<argument><expr><name>buf_desc</name></expr></argument>)</argument_list></call></expr></argument>,
					<argument><expr><call><name>pg_atomic_read_u32</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>buf_desc</name><operator>-&gt;</operator><name>state</name></name></expr></argument>)</argument_list></call> <operator>&amp;</operator> <name>BM_PERMANENT</name></expr></argument>,
					<argument><expr><name>InvalidXLogRecPtr</name></expr></argument>, <argument><expr><name>InvalidXLogRecPtr</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>polar_add_origin_buf</name><argument_list>(<argument><expr><name><name>flog_instance</name><operator>-&gt;</operator><name>list_ctl</name></name></expr></argument>, <argument><expr><name>buf_desc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/*
			 * POLAR: buffer maybe dirty later, mark buffer unrecoverable,
			 * avoid to reuse
			 */</comment>
			<expr_stmt><expr><call><name>polar_mark_buffer_unrecoverable_flag</name><argument_list>(<argument><expr><name>buf_desc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized buffer lock mode: %d"</literal></expr></argument>, <argument><expr><name>mode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return;</return>
		</block_content>}</block></else></if_stmt>

		<comment type="block">/* Is this fresh buffer? */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>fresh_check</name> <operator>||</operator> <operator>!</operator><call><name>polar_redo_check_state</name><argument_list>(<argument><expr><name>buf_desc</name></expr></argument>, <argument><expr><name>POLAR_REDO_OUTDATE</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>

		<switch>switch <condition>(<expr><name>mode</name></expr>)</condition>
		<block>{<block_content>
			<case>case <expr><name>BUFFER_LOCK_SHARE</name></expr>:</case>
				<comment type="block">/* release s-lock and acquire x-lock for redo */</comment>
				<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><call><name>BufferDescriptorGetContentLock</name><argument_list>(<argument><expr><name>buf_desc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><call><name>BufferDescriptorGetContentLock</name><argument_list>(<argument><expr><name>buf_desc</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><name>BUFFER_LOCK_EXCLUSIVE</name></expr>:</case>
				<break>break;</break>

			<default>default:</default>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized buffer lock mode: %d"</literal></expr></argument>, <argument><expr><name>mode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return;</return>
		</block_content>}</block></switch>

		<comment type="block">/*
		 * Now, we hold exclusive lock. Because we released lock
		 * while BUFFER_LOCK_SHARE mode, so we should re-check
		 * buffer outdate state.
		 */</comment>
		<expr_stmt><expr><call><name>polar_logindex_lock_apply_buffer</name><argument_list>(<argument><expr><name>polar_logindex_redo_instance</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<switch>switch <condition>(<expr><name>mode</name></expr>)</condition>
		<block>{<block_content>
			<case>case <expr><name>BUFFER_LOCK_SHARE</name></expr>:</case>
				<comment type="block">/*
				 * target lock mode is shared one, so we release exclusive lock
				 * and try to hold shared one
				 */</comment>
				<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><call><name>BufferDescriptorGetContentLock</name><argument_list>(<argument><expr><name>buf_desc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<continue>continue;</continue>

			<case>case <expr><name>BUFFER_LOCK_EXCLUSIVE</name></expr>:</case>
				<comment type="block">/* target lock mode is exclusive, so we are done here, just return. */</comment>
				<return>return;</return>

			<default>default:</default>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized buffer lock mode: %d"</literal></expr></argument>, <argument><expr><name>mode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return;</return>
		</block_content>}</block></switch>
	</block_content>}</block>
	while <condition>(<expr><name>true</name></expr>)</condition>;</do>
</block_content>}</block></function>

<comment type="block">/*
 * POLAR: An extended version ConditionalLockBuffer. It can detect outdate status
 * before obtaining the lock.
 *
 * If fresh_check is True, it will try to check flag of corresponding buffer
 * descriptor and redo the buffer, otherwise it will do what the origin one do.
 */</comment>
<function><type><name>bool</name></type>
<name>polar_conditional_lock_buffer_ext</name><parameter_list>(<parameter><decl><type><name>Buffer</name></type> <name>buffer</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>fresh_check</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>BufferDesc</name>  <modifier>*</modifier></type><name>buf_desc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>        <name>result</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>BufferIsValid</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>BufferIsLocal</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>            <comment type="block">/* act as though we got it */</comment>

	<expr_stmt><expr><name>buf_desc</name> <operator>=</operator> <call><name>GetBufferDescriptor</name><argument_list>(<argument><expr><name>buffer</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>LWLockConditionalAcquire</name><argument_list>(<argument><expr><call><name>BufferDescriptorGetContentLock</name><argument_list>(<argument><expr><name>buf_desc</name></expr></argument>)</argument_list></call></expr></argument>,
									  <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* POLAR: if lock successfully, mark unrecoverable flag now */</comment>
	<if_stmt><if>if <condition>(<expr><name>result</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>polar_mark_buffer_unrecoverable_flag</name><argument_list>(<argument><expr><name>buf_desc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>fresh_check</name> <operator>&amp;&amp;</operator> <name>result</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>polar_logindex_lock_apply_buffer</name><argument_list>(<argument><expr><name>polar_logindex_redo_instance</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>bool</name></type>
<name>polar_pin_buffer</name><parameter_list>(<parameter><decl><type><name>BufferDesc</name> <modifier>*</modifier></type><name>buf_desc</name></decl></parameter>, <parameter><decl><type><name>BufferAccessStrategy</name></type> <name>strategy</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>PinBuffer</name><argument_list>(<argument><expr><name>buf_desc</name></expr></argument>, <argument><expr><name>strategy</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<function><type><name>Buffer</name></type>
<name>polar_bulk_read_buffer_extended</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>reln</name></decl></parameter>, <parameter><decl><type><name>ForkNumber</name></type> <name>forkNum</name></decl></parameter>, <parameter><decl><type><name>BlockNumber</name></type> <name>blockNum</name></decl></parameter>,
								<parameter><decl><type><name>ReadBufferMode</name></type> <name>mode</name></decl></parameter>, <parameter><decl><type><name>BufferAccessStrategy</name></type> <name>strategy</name></decl></parameter>,
								<parameter><decl><type><name>int</name></type> <name>maxBlockCount</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type>        <name>hit</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Buffer</name></type>      <name>buf</name></decl>;</decl_stmt>

	<comment type="block">/* Open it at the smgr level if not already done */</comment>
	<expr_stmt><expr><call><name>RelationOpenSmgr</name><argument_list>(<argument><expr><name>reln</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Reject attempts to read non-local temporary relations; we would be
	 * likely to get wrong data since we have no visibility into the owning
	 * session's local buffers.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>RELATION_IS_OTHER_TEMP</name><argument_list>(<argument><expr><name>reln</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot access temporary tables of other sessions"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Read the buffer, and update pgstat counters to reflect a cache hit or
	 * miss.
	 */</comment>
	<expr_stmt><expr><call><name>pgstat_count_buffer_read</name><argument_list>(<argument><expr><name>reln</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>buf</name> <operator>=</operator> <call><name>polar_bulk_read_buffer_common</name><argument_list>(<argument><expr><name>reln</name></expr></argument>, <argument><expr><name><name>reln</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relpersistence</name></name></expr></argument>,
										<argument><expr><name>forkNum</name></expr></argument>, <argument><expr><name>blockNum</name></expr></argument>, <argument><expr><name>mode</name></expr></argument>, <argument><expr><name>strategy</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>hit</name></expr></argument>, <argument><expr><name>maxBlockCount</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>hit</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>pgstat_count_buffer_hit</name><argument_list>(<argument><expr><name>reln</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>buf</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * polar_bulk_read_buffer_common -- common logic for bulk read multi buffer one time.
 *
 * Try to read as many buffers as possible, up to maxBlockCount.
 * If first block hits shared_buffers, return immediately.
 * IF first block doesn't hit shared_buffer,
 * read buffers until up to maxBlockCount or
 * up to first block which hit shared_buffer.
 *
 * Returns: the buffer number for the first block blockNum.
 *      The returned buffer has been pinned.
 *      Does not return on error --- elog's instead.
 *
 * *hit is set to true if the first blockNum was satisfied from shared buffer cache.
 *
 * Deadlock avoidanceï¼Only ascending bulk read are allowed
 * to avoid dead lock on io_in_progress_lock.
 */</comment>
<function><type><specifier>static</specifier> <name>Buffer</name></type>
<name>polar_bulk_read_buffer_common</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>reln</name></decl></parameter>, <parameter><decl><type><name>char</name></type> <name>relpersistence</name></decl></parameter>, <parameter><decl><type><name>ForkNumber</name></type> <name>forkNum</name></decl></parameter>,
							  <parameter><decl><type><name>BlockNumber</name></type> <name>firstBlockNum</name></decl></parameter>, <parameter><decl><type><name>ReadBufferMode</name></type> <name>mode</name></decl></parameter>,
							  <parameter><decl><type><name>BufferAccessStrategy</name></type> <name>strategy</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>hit</name></decl></parameter>,
							  <parameter><decl><type><name>int</name></type> <name>maxBlockCount</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>SMgrRelation</name></type> <name>smgr</name> <init>= <expr><name><name>reln</name><operator>-&gt;</operator><name>rd_smgr</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BufferDesc</name> <modifier>*</modifier></type><name>bufHdr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BufferDesc</name> <modifier>*</modifier></type><name>first_buf_hdr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Block</name></type>       <name>bufBlock</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>        <name>found</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>        <name>isLocalBuf</name> <init>= <expr><call><name>SmgrIsTemp</name><argument_list>(<argument><expr><name>smgr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>         <name>actual_bulk_io_count</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>         <name>index</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>        <modifier>*</modifier></type><name>buf_read</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>        <modifier>*</modifier></type><name>aligned_buf_read</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>         <name>remaining_lwlock_slot_count</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>XLogRecPtr</name></type>  <name>checkpoint_redo_lsn</name> <init>= <expr><name>InvalidXLogRecPtr</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>XLogRecPtr</name></type>  <name>replay_from</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>polar_redo_action</name></type>       <name>redo_action</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>         <name>repeat_read_times</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name>        <modifier>*</modifier></type><name>checksum_fail</name></decl>;</decl_stmt>

	<comment type="block">/* POLAR: make sure that buffer pool has been inited */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>polar_buffer_pool_is_inited</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>PANIC</name></expr></argument>, <argument><expr><literal type="string">"buffer pool is not inited"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* POLAR end */</comment>

	<expr_stmt><expr><call><name>polar_pgstat_count_bulk_read_calls</name><argument_list>(<argument><expr><name>reln</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>maxBlockCount</name> <operator>=</operator> <call><name>Min</name><argument_list>(<argument><expr><name>maxBlockCount</name></expr></argument>, <argument><expr><name>polar_bulk_read_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>firstBlockNum</name> <operator>==</operator> <name>P_NEW</name> <operator>||</operator>
			<name>maxBlockCount</name> <operator>&lt;=</operator> <literal type="number">1</literal> <operator>||</operator>
			<name>mode</name> <operator>!=</operator> <name>RBM_NORMAL</name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><call><name>ReadBuffer_common</name><argument_list>(<argument><expr><name>smgr</name></expr></argument>, <argument><expr><name>relpersistence</name></expr></argument>, <argument><expr><name>forkNum</name></expr></argument>, <argument><expr><name>firstBlockNum</name></expr></argument>,
								 <argument><expr><name>mode</name></expr></argument>, <argument><expr><name>strategy</name></expr></argument>, <argument><expr><name>hit</name></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>polar_bulk_io_is_in_progress</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><literal type="number">0</literal> <operator>==</operator> <name>polar_bulk_io_in_progress_count</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* bulk read begin */</comment>
	<expr_stmt><expr><name>polar_bulk_io_is_in_progress</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Alloc buffer for polar_bulk_io_in_progress_buf and polar_bulk_io_is_for_input on demand.
	 * If bulk read is called once, there is a great possibility that bulk read will be called later.
	 * polar_bulk_io_in_progress_buf and polar_bulk_io_is_for_input will be not freed, until backend exit.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>==</operator> <name>polar_bulk_io_in_progress_buf</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>NULL</name> <operator>==</operator> <name>polar_bulk_io_is_for_input</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>polar_bulk_io_in_progress_buf</name> <operator>=</operator> <call><name>MemoryContextAlloc</name><argument_list>(<argument><expr><name>TopMemoryContext</name></expr></argument>,
														   <argument><expr><name>POLAR_MAX_BULK_IO_SIZE</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name><name>polar_bulk_io_in_progress_buf</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>polar_bulk_io_is_for_input</name> <operator>=</operator> <call><name>MemoryContextAlloc</name><argument_list>(<argument><expr><name>TopMemoryContext</name></expr></argument>,
														<argument><expr><name>POLAR_MAX_BULK_IO_SIZE</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name><name>polar_bulk_io_is_for_input</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><operator>*</operator><name>hit</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<comment type="block">/* Make sure we will have room to remember the buffer pin */</comment>
	<expr_stmt><expr><call><name>ResourceOwnerEnlargeBuffers</name><argument_list>(<argument><expr><name>CurrentResourceOwner</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>TRACE_POSTGRESQL_BUFFER_READ_START</name><argument_list>(<argument><expr><name>forkNum</name></expr></argument>, <argument><expr><name>firstBlockNum</name></expr></argument>,
									   <argument><expr><name><name>smgr</name><operator>-&gt;</operator><name>smgr_rnode</name><operator>.</operator><name>node</name><operator>.</operator><name>spcNode</name></name></expr></argument>,
									   <argument><expr><name><name>smgr</name><operator>-&gt;</operator><name>smgr_rnode</name><operator>.</operator><name>node</name><operator>.</operator><name>dbNode</name></name></expr></argument>,
									   <argument><expr><name><name>smgr</name><operator>-&gt;</operator><name>smgr_rnode</name><operator>.</operator><name>node</name><operator>.</operator><name>relNode</name></name></expr></argument>,
									   <argument><expr><name><name>smgr</name><operator>-&gt;</operator><name>smgr_rnode</name><operator>.</operator><name>backend</name></name></expr></argument>,
									   <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* false == isExtend */</comment>

	<if_stmt><if>if <condition>(<expr><name>isLocalBuf</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>bufHdr</name> <operator>=</operator> <call><name>LocalBufferAlloc</name><argument_list>(<argument><expr><name>smgr</name></expr></argument>, <argument><expr><name>forkNum</name></expr></argument>, <argument><expr><name>firstBlockNum</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>found</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>pgBufferUsage</name><operator>.</operator><name>local_blks_hit</name></name><operator>++</operator></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>pgBufferUsage</name><operator>.</operator><name>local_blks_read</name></name><operator>++</operator></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/*
		* lookup the buffer.  IO_IN_PROGRESS is set if the requested block is
		* not currently in memory.
		* If not found, polar_bulk_io_in_progress_count will be added by 1.
		*/</comment>
		<expr_stmt><expr><name>bufHdr</name> <operator>=</operator> <call><name>BufferAlloc</name><argument_list>(<argument><expr><name>smgr</name></expr></argument>, <argument><expr><name>relpersistence</name></expr></argument>, <argument><expr><name>forkNum</name></expr></argument>, <argument><expr><name>firstBlockNum</name></expr></argument>,
							 <argument><expr><name>strategy</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>found</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>pgBufferUsage</name><operator>.</operator><name>shared_blks_hit</name></name><operator>++</operator></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>pgBufferUsage</name><operator>.</operator><name>shared_blks_read</name></name><operator>++</operator></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/* At this point we do NOT hold any locks. */</comment>

	<comment type="block">/* if it was already in the buffer pool, we're done */</comment>
	<if_stmt><if>if <condition>(<expr><name>found</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Just need to update stats before we exit */</comment>
		<expr_stmt><expr><operator>*</operator><name>hit</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>VacuumPageHit</name><operator>++</operator></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>VacuumCostActive</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>VacuumCostBalance</name> <operator>+=</operator> <name>VacuumCostPageHit</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>TRACE_POSTGRESQL_BUFFER_READ_DONE</name><argument_list>(<argument><expr><name>forkNum</name></expr></argument>, <argument><expr><name>firstBlockNum</name></expr></argument>,
										  <argument><expr><name><name>smgr</name><operator>-&gt;</operator><name>smgr_rnode</name><operator>.</operator><name>node</name><operator>.</operator><name>spcNode</name></name></expr></argument>,
										  <argument><expr><name><name>smgr</name><operator>-&gt;</operator><name>smgr_rnode</name><operator>.</operator><name>node</name><operator>.</operator><name>dbNode</name></name></expr></argument>,
										  <argument><expr><name><name>smgr</name><operator>-&gt;</operator><name>smgr_rnode</name><operator>.</operator><name>node</name><operator>.</operator><name>relNode</name></name></expr></argument>,
										  <argument><expr><name><name>smgr</name><operator>-&gt;</operator><name>smgr_rnode</name><operator>.</operator><name>backend</name></name></expr></argument>,
										  <argument><expr><name>isExtend</name></expr></argument>,
										  <argument><expr><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><literal type="number">0</literal> <operator>==</operator> <name>polar_bulk_io_in_progress_count</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* important, mark bulk_io end */</comment>
		<expr_stmt><expr><name>polar_bulk_io_is_in_progress</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

		<return>return <expr><call><name>BufferDescriptorGetBuffer</name><argument_list>(<argument><expr><name>bufHdr</name></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * if we have gotten to this point, we have allocated a buffer for the
	 * page but its contents are not yet valid.  IO_IN_PROGRESS is set for it,
	 * if it's a shared buffer.
	 *
	 * Note: if smgrextend fails, we will end up with a buffer that is
	 * allocated but not marked BM_VALID.  P_NEW will still select the same
	 * block number (because the relation didn't get any longer on disk) and
	 * so future attempts to extend the relation will find the same buffer (if
	 * it's not been recycled) but come right back here to try smgrextend
	 * again.
	 */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><operator>(</operator><call><name>pg_atomic_read_u32</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>bufHdr</name><operator>-&gt;</operator><name>state</name></name></expr></argument>)</argument_list></call> <operator>&amp;</operator> <name>BM_VALID</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>   <comment type="block">/* spinlock not needed */</comment>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><literal type="number">1</literal> <operator>==</operator> <name>polar_bulk_io_in_progress_count</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>bufHdr</name> <operator>==</operator> <name><name>polar_bulk_io_in_progress_buf</name><index>[<expr><name>polar_bulk_io_in_progress_count</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Hold the first block bufHdr,
	 * after TerminateBufferIO(), polar_bulk_io_in_progress_buf is freed.
	 */</comment>
	<expr_stmt><expr><name>first_buf_hdr</name> <operator>=</operator> <name>bufHdr</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Make sure than single bulk_read will not read blocks across files.
	 *
	 * (BlockNumber) RELSEG_SIZE - (blockNum % (BlockNumber) RELSEG_SIZE) always &gt;= 1, and maxBlockCount always &gt;= 1,
	 * so finaly maxBlockCount always &gt;= 1.
	 */</comment>
	<expr_stmt><expr><name>maxBlockCount</name> <operator>=</operator> <call><name>Min</name><argument_list>(<argument><expr><name>maxBlockCount</name></expr></argument>, <argument><expr><operator>(</operator><name>BlockNumber</name><operator>)</operator> <name>RELSEG_SIZE</name> <operator>-</operator> <operator>(</operator><name>firstBlockNum</name> <operator>%</operator> <operator>(</operator><name>BlockNumber</name><operator>)</operator> <name>RELSEG_SIZE</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/*
	 * avoid lwlock count overflow.
	 * -2 : for temporary use of buf_mapping_partition_lock, content_lock&amp;io_in_progress_lock(for flushing evicted dirty page)
	 *      during multi BufferAlloc().
	 *
	 * if remaining_lwlock_slot_count &lt; 0, then maxBlockCount &lt; 0, no bulk read, just ok.
	 */</comment>
	<expr_stmt><expr><name>remaining_lwlock_slot_count</name> <operator>=</operator> <call><name>polar_remaining_lwlock_slot_count</name><argument_list>()</argument_list></call> <operator>-</operator> <literal type="number">2</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>maxBlockCount</name> <operator>=</operator> <call><name>Min</name><argument_list>(<argument><expr><name>maxBlockCount</name></expr></argument>, <argument><expr><name>remaining_lwlock_slot_count</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>index</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>index</name> <operator>&lt;</operator> <name>maxBlockCount</name></expr>;</condition> <incr><expr><name>index</name> <operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>BlockNumber</name></type> <name>blockNum</name> <init>= <expr><name>firstBlockNum</name> <operator>+</operator> <name>index</name></expr></init></decl>;</decl_stmt>

		<comment type="block">/* Make sure we will have room to remember the buffer pin */</comment>
		<expr_stmt><expr><call><name>ResourceOwnerEnlargeBuffers</name><argument_list>(<argument><expr><name>CurrentResourceOwner</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * lookup the buffer.  IO_IN_PROGRESS is set if the requested block is
		 * not currently in memory.
		 *
		 * If not found, polar_bulk_io_in_progress_count will be added by 1 by StartBufferIO().
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>isLocalBuf</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>bufHdr</name> <operator>=</operator> <call><name>LocalBufferAlloc</name><argument_list>(<argument><expr><name>smgr</name></expr></argument>, <argument><expr><name>forkNum</name></expr></argument>, <argument><expr><name>blockNum</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>bufHdr</name> <operator>=</operator> <call><name>BufferAlloc</name><argument_list>(<argument><expr><name>smgr</name></expr></argument>, <argument><expr><name>relpersistence</name></expr></argument>, <argument><expr><name>forkNum</name></expr></argument>, <argument><expr><name>blockNum</name></expr></argument>,
								 <argument><expr><name>strategy</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<comment type="block">/* For extra block, don't update pgBufferUsage.shared_blks_hit or pgBufferUsage.shared_blks_read */</comment>
		<comment type="block">/* bufHdr == NULL, all buffers are pinned. */</comment>
		<if_stmt><if>if <condition>(<expr><name>found</name> <operator>||</operator> <name>bufHdr</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* important: this buffer is the upper boundary, it should be excluded. */</comment>
			<if_stmt><if>if <condition>(<expr><name>bufHdr</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ReleaseBuffer</name><argument_list>(<argument><expr><call><name>BufferDescriptorGetBuffer</name><argument_list>(<argument><expr><name>bufHdr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<break>break;</break>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><operator>(</operator><call><name>pg_atomic_read_u32</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>bufHdr</name><operator>-&gt;</operator><name>state</name></name></expr></argument>)</argument_list></call> <operator>&amp;</operator> <name>BM_VALID</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>   <comment type="block">/* spinlock not needed */</comment>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>index</name> <operator>==</operator> <name>polar_bulk_io_in_progress_count</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Until now, as to {blockNum + [0, polar_bulk_io_in_progress_count)} block buffers,
	 * IO_IN_PROGRESS flag is set and io_in_progress_lock is holded.
	 *
	 * Other proc(include backend sql execãstart xlog replay) which read there buffers,
	 * would be blocked on io_in_progress_lock.
	 *
	 * Deadlock avoidanceï¼Only ascending bulk read are allowed to avoid dead lock on io_in_progress_lock.
	 */</comment>

	<comment type="block">/*
	 * polar_bulk_io_in_progress_count will be reduced by TerminateBufferIO(),
	 * For safety, its copy actual_bulk_io_count is used.
	 */</comment>
	<expr_stmt><expr><name>actual_bulk_io_count</name> <operator>=</operator> <name>polar_bulk_io_in_progress_count</name></expr>;</expr_stmt>

	<comment type="block">/* for eliminating palloc and memcpy */</comment>
	<if_stmt><if>if <condition>(<expr><literal type="number">1</literal> <operator>==</operator> <name>actual_bulk_io_count</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>buf_read</name> <operator>=</operator> <ternary><condition><expr><name>isLocalBuf</name></expr> ?</condition><then>
				   <expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><call><name>LocalBufHdrGetBlock</name><argument_list>(<argument><expr><name>first_buf_hdr</name></expr></argument>)</argument_list></call></expr> </then><else>:
				   <expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><call><name>BufHdrGetBlock</name><argument_list>(<argument><expr><name>first_buf_hdr</name></expr></argument>)</argument_list></call></expr></else></ternary></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>buf_read</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><ternary><condition><expr><name>polar_enable_buffer_alignment</name></expr> ?</condition><then>
								   <expr><call><name>POLAR_BUFFER_EXTEND_SIZE</name><argument_list>(<argument><expr><name>actual_bulk_io_count</name> <operator>*</operator> <name>BLCKSZ</name></expr></argument>)</argument_list></call></expr> </then><else>:
								   <expr><name>actual_bulk_io_count</name> <operator>*</operator> <name>BLCKSZ</name></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>polar_enable_buffer_alignment</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>aligned_buf_read</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>POLAR_BUFFER_ALIGN</name><argument_list>(<argument><expr><name>buf_read</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>aligned_buf_read</name> <operator>=</operator> <name>buf_read</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<expr_stmt><expr><name>checksum_fail</name> <operator>=</operator> <operator>(</operator><name>bool</name> <operator>*</operator><operator>)</operator><call><name>palloc0</name><argument_list>(<argument><expr><name>actual_bulk_io_count</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<label><name>repeat_read</name>:</label>
	<comment type="block">/*
	 * POLAR: page-replay.
	 *
	 * Get consistent and redo lsn which used by replay.
	 *
	 * Note: All modifications about replay-page must be
	 *       applied to both polar_bulk_read_buffer_common() and ReadBuffer_common().
	 */</comment>
	<expr_stmt><expr><name>redo_action</name> <operator>=</operator> <call><name>polar_require_backend_redo</name><argument_list>(<argument><expr><name>isLocalBuf</name></expr></argument>, <argument><expr><name>mode</name></expr></argument>, <argument><expr><name>forkNum</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>replay_from</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>redo_action</name> <operator>!=</operator> <name>POLAR_REDO_NO_ACTION</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>checkpoint_redo_lsn</name> <operator>=</operator> <call><name>GetRedoRecPtr</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>XLogRecPtrIsInvalid</name><argument_list>(<argument><expr><name>checkpoint_redo_lsn</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* POLAR end */</comment>

	<comment type="block">/*
	 * Read in the page, unless the caller intends to overwrite it and
	 * just wants us to allocate a buffer.
	 */</comment>
	<block>{<block_content>
		<decl_stmt><decl><type><name>instr_time</name></type>  <name>io_start</name></decl>,
					<decl><type ref="prev"/><name>io_time</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>track_io_timing</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>INSTR_TIME_SET_CURRENT</name><argument_list>(<argument><expr><name>io_start</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>polar_smgrbulkread</name><argument_list>(<argument><expr><name>smgr</name></expr></argument>, <argument><expr><name>forkNum</name></expr></argument>, <argument><expr><name>firstBlockNum</name></expr></argument>, <argument><expr><name>actual_bulk_io_count</name></expr></argument>, <argument><expr><name>aligned_buf_read</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>track_io_timing</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>INSTR_TIME_SET_CURRENT</name><argument_list>(<argument><expr><name>io_time</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>INSTR_TIME_SUBTRACT</name><argument_list>(<argument><expr><name>io_time</name></expr></argument>, <argument><expr><name>io_start</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>pgstat_count_buffer_read_time</name><argument_list>(<argument><expr><call><name>INSTR_TIME_GET_MICROSEC</name><argument_list>(<argument><expr><name>io_time</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>INSTR_TIME_ADD</name><argument_list>(<argument><expr><name><name>pgBufferUsage</name><operator>.</operator><name>blk_read_time</name></name></expr></argument>, <argument><expr><name>io_time</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<for>for <control>(<init><expr><name>index</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>index</name> <operator>&lt;</operator> <name>actual_bulk_io_count</name></expr>;</condition> <incr><expr><name>index</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>BlockNumber</name></type> <name>blockNum</name> <init>= <expr><name>firstBlockNum</name> <operator>+</operator> <name>index</name></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><name>bufBlock</name> <operator>=</operator> <operator>(</operator><name>Block</name><operator>)</operator><operator>(</operator><name>aligned_buf_read</name> <operator>+</operator> <name>index</name> <operator>*</operator> <name>BLCKSZ</name><operator>)</operator></expr>;</expr_stmt>

			<comment type="block">/* check for garbage data */</comment>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>PageIsVerified</name><argument_list>(<argument><expr><operator>(</operator><name>Page</name><operator>)</operator> <name>bufBlock</name></expr></argument>, <argument><expr><name>forkNum</name></expr></argument>, <argument><expr><name>blockNum</name></expr></argument>, <argument><expr><name>smgr</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name>zero_damaged_pages</name></expr>)</condition>
				<block>{<block_content>
					<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>relpath</name> <init>= <expr><call><name>relpath</name><argument_list>(<argument><expr><name><name>smgr</name><operator>-&gt;</operator><name>smgr_rnode</name></name></expr></argument>, <argument><expr><name>forkNum</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATA_CORRUPTED</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid page in block %u of relation %s; zeroing out page"</literal></expr></argument>,
									<argument><expr><name>blockNum</name></expr></argument>, <argument><expr><name>relpath</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>bufBlock</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>BLCKSZ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>relpath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if>
				<if type="elseif">else if <condition>(<expr><name>polar_has_partial_write</name> <operator>&amp;&amp;</operator> <call><name>polar_in_replica_mode</name><argument_list>()</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/*
					 * POLAR: If filesystem doesn't support atomic wirte. rw could write part of the page while ro read this page and failed to verify checksum.
					 * So in replica mode we will delay some time and read this page again
					 */</comment>
					<expr_stmt><expr><name>repeat_read_times</name><operator>++</operator></expr>;</expr_stmt>

					<if_stmt><if>if <condition>(<expr><name>repeat_read_times</name> <operator>%</operator> <name>POLAR_WARNING_REPEAT_TIMES</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
					<block>{<block_content>
						<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>relpath</name> <init>= <expr><call><name>relpath</name><argument_list>(<argument><expr><name><name>smgr</name><operator>-&gt;</operator><name>smgr_rnode</name></name></expr></argument>, <argument><expr><name>forkNum</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
						<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"%d times to repeat read from block %u of relation %s"</literal></expr></argument>,
												 <argument><expr><name>repeat_read_times</name></expr></argument>, <argument><expr><name>firstBlockNum</name></expr></argument>, <argument><expr><name>relpath</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>relpath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

						<expr_stmt><expr><call><name>CHECK_FOR_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block></if></if_stmt>

					<expr_stmt><expr><call><name>POLAR_DELAY_REPEAT_READ</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>POLAR_REPEAT_READ</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if>
				<if type="elseif">else if <condition>(<expr><name>fullPageWrites</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>redo_action</name> <operator>!=</operator> <name>POLAR_REDO_NO_ACTION</name><operator>)</operator></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/*
					 * POLAR: It's doing online promote if redo_required but is not in replica mode.
					 * We will replay this page from last checkpoint, so we can find the first FPI log to replay
					 */</comment>
					<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>relpath</name> <init>= <expr><call><name>relpath</name><argument_list>(<argument><expr><name><name>smgr</name><operator>-&gt;</operator><name>smgr_rnode</name></name></expr></argument>, <argument><expr><name>forkNum</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATA_CORRUPTED</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid page in block %u of relation %s; will replay from %lX"</literal></expr></argument>,
									<argument><expr><name>blockNum</name></expr></argument>, <argument><expr><name>relpath</name></expr></argument>, <argument><expr><name>checkpoint_redo_lsn</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>bufBlock</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>BLCKSZ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>checksum_fail</name><index>[<expr><name>index</name></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				</block_content>}</block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATA_CORRUPTED</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid page in block %u of relation %s"</literal></expr></argument>,
									<argument><expr><name>blockNum</name></expr></argument>,
									<argument><expr><call><name>relpath</name><argument_list>(<argument><expr><name><name>smgr</name><operator>-&gt;</operator><name>smgr_rnode</name></name></expr></argument>, <argument><expr><name>forkNum</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></for>
	</block_content>}</block>

	<comment type="block">/*
	 * notice:
	 * 1. buffers must be processed by TerminateBufferIO() from back to front.
	 *    a) TerminateBufferIO() release polar_bulk_io_in_progress_buf[] in decrement order.
	 *    b) For better performance, LWLockRelease() release io_in_progress_lock in decrement order.
	 * 2. polar_bulk_io_in_progress_count was reduced by TerminateBufferIO().
	 *    a) polar_bulk_io_in_progress_count must not be used here.
	 */</comment>
	<for>for <control>(<init><expr><name>index</name> <operator>=</operator> <name>actual_bulk_io_count</name> <operator>-</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>index</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr> ;</condition> <incr><expr><name>index</name><operator>--</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>BlockNumber</name></type> <name>blockNum</name> <init>= <expr><name>firstBlockNum</name> <operator>+</operator> <name>index</name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>bufHdr</name> <operator>=</operator> <name><name>polar_bulk_io_in_progress_buf</name><index>[<expr><name>index</name></expr>]</index></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>bufBlock</name> <operator>=</operator> <ternary><condition><expr><name>isLocalBuf</name></expr> ?</condition><then> <expr><call><name>LocalBufHdrGetBlock</name><argument_list>(<argument><expr><name>bufHdr</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><call><name>BufHdrGetBlock</name><argument_list>(<argument><expr><name>bufHdr</name></expr></argument>)</argument_list></call></expr></else></ternary></expr>;</expr_stmt>

		<comment type="block">/* need copy page content from aligned_buf_read to block shared_buffer */</comment>
		<if_stmt><if>if <condition>(<expr><name>actual_bulk_io_count</name> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>bufBlock</name></expr></argument>, <argument><expr><name>aligned_buf_read</name> <operator>+</operator> <name>index</name> <operator>*</operator> <name>BLCKSZ</name></expr></argument>, <argument><expr><name>BLCKSZ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>unlikely</name><argument_list>(<argument><expr><name>polar_trace_logindex_messages</name> <operator>&lt;=</operator> <name>DEBUG3</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>BufferTag</name> <modifier>*</modifier></type><name>tag</name> <init>= <expr><operator>&amp;</operator><name><name>bufHdr</name><operator>-&gt;</operator><name>tag</name></name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Buffer</name></type> <name>buf</name> <init>= <expr><call><name>BufferDescriptorGetBuffer</name><argument_list>(<argument><expr><name>bufHdr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Page</name></type> <name>page</name> <init>= <expr><call><name>BufferGetPage</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"read buffer lsn=%lX, redo_act=%d buf=%d, "</literal> <name>POLAR_LOG_BUFFER_TAG_FORMAT</name></expr></argument>,
								 <argument><expr><call><name>PageGetLSN</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr></argument>,
								 <argument><expr><name>redo_action</name></expr></argument>,
								 <argument><expr><name>buf</name></expr></argument>,
								 <argument><expr><call><name>POLAR_LOG_BUFFER_TAG</name><argument_list>(<argument><expr><name>tag</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
						  <call><name>errhidestmt</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call><operator>,</operator>
						  <call><name>errhidecontext</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * POLAR: page-replay.
		 *
		 * Apply logs to this old page when read from disk.
		 *
		 * Note: All modifications about replay-page must be
		 *       applied to both polar_bulk_read_buffer_common() and ReadBuffer_common().
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>redo_action</name> <operator>==</operator> <name>POLAR_REDO_REPLAY_XLOG</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>XLogRecPtr</name></type> <name>__replay_from</name> <init>= <expr><ternary><condition><expr><name><name>checksum_fail</name><index>[<expr><name>index</name></expr>]</index></name></expr> ?</condition><then> <expr><name>checkpoint_redo_lsn</name></expr> </then><else>: <expr><name>replay_from</name></expr></else></ternary></expr></init></decl>;</decl_stmt>

			<comment type="block">/*
			 * POLAR: we want to do record replay on page only in
			 * non-Startup process and consistency reached Startup process.
			 * This judge is *ONLY* valid in replica mode, so we set
			 * replica check above with polar_in_replica_mode().
			 */</comment>
			<expr_stmt><expr><call><name>polar_apply_io_locked_page</name><argument_list>(<argument><expr><name>bufHdr</name></expr></argument>, <argument><expr><name>__replay_from</name></expr></argument>, <argument><expr><name>checkpoint_redo_lsn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name>redo_action</name> <operator>==</operator> <name>POLAR_REDO_MARK_OUTDATE</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>uint32</name></type> <name>redo_state</name> <init>= <expr><call><name>polar_lock_redo_state</name><argument_list>(<argument><expr><name>bufHdr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><name>redo_state</name> <operator>|=</operator> <name>POLAR_REDO_OUTDATE</name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>polar_unlock_redo_state</name><argument_list>(<argument><expr><name>bufHdr</name></expr></argument>, <argument><expr><name>redo_state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* POLAR end */</comment>

		<comment type="block">/*
		 * After TerminateBufferIO, polar_bulk_io_in_progress_buf[index]
		 * can not be used any more.
		 */</comment>
		<comment type="block">/* Set BM_VALID, terminate IO, and wake up any waiters */</comment>
		<if_stmt><if>if <condition>(<expr><name>isLocalBuf</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Only need to adjust flags */</comment>
			<decl_stmt><decl><type><name>uint32</name></type>      <name>buf_state</name> <init>= <expr><call><name>pg_atomic_read_u32</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>bufHdr</name><operator>-&gt;</operator><name>state</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><name>buf_state</name> <operator>|=</operator> <name>BM_VALID</name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>pg_atomic_unlocked_write_u32</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>bufHdr</name><operator>-&gt;</operator><name>state</name></name></expr></argument>, <argument><expr><name>buf_state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* bulk io */</comment>
			<expr_stmt><expr><name>polar_bulk_io_in_progress_count</name><operator>--</operator></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>TerminateBufferIO</name><argument_list>(<argument><expr><name>bufHdr</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>BM_VALID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<comment type="block">/* important: buffers except firstBlockNum should release pin */</comment>
		<if_stmt><if>if <condition>(<expr><name>index</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ReleaseBuffer</name><argument_list>(<argument><expr><call><name>BufferDescriptorGetBuffer</name><argument_list>(<argument><expr><name>bufHdr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>VacuumPageMiss</name><operator>++</operator></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>VacuumCostActive</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>VacuumCostBalance</name> <operator>+=</operator> <name>VacuumCostPageMiss</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></for>

	<comment type="block">/*
	 * POLAR: page-replay.
	 *
	 * Reset consistent lsn which used by replay.
	 *
	 * Note: All modifications about replay-page must be
	 *       applied to both polar_bulk_read_buffer_common() and ReadBuffer_common().
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>redo_action</name> <operator>!=</operator> <name>POLAR_REDO_NO_ACTION</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>POLAR_RESET_BACKEND_READ_MIN_LSN</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Polar end */</comment>

	<expr_stmt><expr><call><name>TRACE_POSTGRESQL_BUFFER_READ_DONE</name><argument_list>(<argument><expr><name>forkNum</name></expr></argument>, <argument><expr><name>firstBlockNum</name></expr></argument>,
									  <argument><expr><name><name>smgr</name><operator>-&gt;</operator><name>smgr_rnode</name><operator>.</operator><name>node</name><operator>.</operator><name>spcNode</name></name></expr></argument>,
									  <argument><expr><name><name>smgr</name><operator>-&gt;</operator><name>smgr_rnode</name><operator>.</operator><name>node</name><operator>.</operator><name>dbNode</name></name></expr></argument>,
									  <argument><expr><name><name>smgr</name><operator>-&gt;</operator><name>smgr_rnode</name><operator>.</operator><name>node</name><operator>.</operator><name>relNode</name></name></expr></argument>,
									  <argument><expr><name><name>smgr</name><operator>-&gt;</operator><name>smgr_rnode</name><operator>.</operator><name>backend</name></name></expr></argument>,
									  <argument><expr><name>isExtend</name></expr></argument>,
									  <argument><expr><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * notice: polar_bulk_io_in_progress_count was reduced by TerminateBufferIO().
	 * polar_bulk_io_in_progress_count must not be used here.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>actual_bulk_io_count</name> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>buf_read</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>checksum_fail</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>polar_pgstat_count_bulk_read_calls_IO</name><argument_list>(<argument><expr><name>reln</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>polar_pgstat_count_bulk_read_blocks_IO</name><argument_list>(<argument><expr><name>reln</name></expr></argument>, <argument><expr><name>actual_bulk_io_count</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><literal type="number">0</literal> <operator>==</operator> <name>polar_bulk_io_in_progress_count</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* important, mark bulk_io end */</comment>
	<expr_stmt><expr><name>polar_bulk_io_is_in_progress</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<return>return <expr><call><name>BufferDescriptorGetBuffer</name><argument_list>(<argument><expr><name>first_buf_hdr</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * POLAR: check buffer need write fullpage snapshot image
 */</comment>
<function><type><name>bool</name></type>
<name>polar_buffer_need_fullpage_snapshot</name><parameter_list>(<parameter><decl><type><name>BufferDesc</name> <modifier>*</modifier></type><name>buf_hdr</name></decl></parameter>, <parameter><decl><type><name>XLogRecPtr</name></type> <name>oldest_apply_lsn</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>XLogRecPtr</name></type>  <name>cur_insert_lsn</name> <init>= <expr><name>InvalidXLogRecPtr</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>XLogRecPtr</name></type>  <name>buf_oldest_lsn</name> <init>= <expr><call><name>pg_atomic_read_u64</name><argument_list>(<argument><expr><operator>(</operator><name>pg_atomic_uint64</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name><name>buf_hdr</name><operator>-&gt;</operator><name>oldest_lsn</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>XLogRecPtr</name></type>  <name>page_latest_lsn</name> <init>= <expr><call><name>BufferGetLSN</name><argument_list>(<argument><expr><name>buf_hdr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CopyBufferDesc</name> <modifier>*</modifier></type><name>copy_buf</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32</name></type>      <name>buf_state</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>     <name>replay_threshold</name> <init>= <expr><name>polar_fullpage_snapshot_replay_delay_threshold</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>     <name>oldest_lsn_threshold</name> <init>= <expr><name>polar_fullpage_snapshot_oldest_lsn_delay_threshold</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>     <name>min_modified_count</name> <init>= <expr><name>polar_fullpage_snapshot_min_modified_count</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>unlikely</name><argument_list>(<argument><expr><call><name>polar_bg_redo_state_is_parallel</name><argument_list>(<argument><expr><name>polar_logindex_redo_instance</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * 1. if it's not a future page, quick check
	 * 2. only support main fork data page
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>PageIsNew</name><argument_list>(<argument><expr><call><name>BufHdrGetBlock</name><argument_list>(<argument><expr><name>buf_hdr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>||</operator>
			<name>page_latest_lsn</name> <operator>&lt;=</operator> <name>oldest_apply_lsn</name> <operator>||</operator>
			<name><name>buf_hdr</name><operator>-&gt;</operator><name>tag</name><operator>.</operator><name>forkNum</name></name> <operator>!=</operator> <name>MAIN_FORKNUM</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>buf_state</name> <operator>=</operator> <call><name>LockBufHdr</name><argument_list>(<argument><expr><name>buf_hdr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>copy_buf</name> <operator>=</operator> <name><name>buf_hdr</name><operator>-&gt;</operator><name>copy_buffer</name></name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>copy_buf</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>XLogRecPtrIsInvalid</name><argument_list>(<argument><expr><name>buf_oldest_lsn</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>XLogRecPtrIsInvalid</name><argument_list>(<argument><expr><call><name>polar_copy_buffer_get_lsn</name><argument_list>(<argument><expr><name>copy_buf</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>buf_oldest_lsn</name> <operator>=</operator> <call><name>Min</name><argument_list>(<argument><expr><call><name>pg_atomic_read_u64</name><argument_list>(<argument><expr><operator>(</operator><name>pg_atomic_uint64</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name><name>copy_buf</name><operator>-&gt;</operator><name>oldest_lsn</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>buf_oldest_lsn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>UnlockBufHdr</name><argument_list>(<argument><expr><name>buf_hdr</name></expr></argument>, <argument><expr><name>buf_state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>POLAR_LOGINDEX_ENABLE_FULLPAGE</name><argument_list>()</argument_list></call> <operator>||</operator>
			<call><name>RecoveryInProgress</name><argument_list>()</argument_list></call> <operator>||</operator> <comment type="block">/* Standby don't support fullpage snapshot */</comment>
			<call><name>XLogRecPtrIsInvalid</name><argument_list>(<argument><expr><name>oldest_apply_lsn</name></expr></argument>)</argument_list></call> <operator>||</operator>
			<call><name>XLogRecPtrIsInvalid</name><argument_list>(<argument><expr><name>buf_oldest_lsn</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ONE_MB</name></cpp:macro> <cpp:value>(1024 * 1024L)</cpp:value></cpp:define>
	<expr_stmt><expr><name>cur_insert_lsn</name> <operator>=</operator> <call><name>GetXLogInsertRecPtr</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * In following case togather, we need to write fullpage
	 * 1. buf_oldest_lsn is too old, block to advance consist_lsn
	 * 2. replica is too slow
	 * 3. is hot page
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>cur_insert_lsn</name> <operator>&gt;=</operator> <name>buf_oldest_lsn</name> <operator>+</operator> <name>oldest_lsn_threshold</name> <operator>*</operator> <name>ONE_MB</name> <operator>&amp;&amp;</operator>
			<operator>(</operator><name>page_latest_lsn</name> <operator>&gt;=</operator> <name>oldest_apply_lsn</name> <operator>+</operator> <name>replay_threshold</name> <operator>*</operator> <name>ONE_MB</name> <operator>||</operator>
			 <name><name>buf_hdr</name><operator>-&gt;</operator><name>recently_modified_count</name></name> <operator>&gt;</operator> <name>min_modified_count</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * In most scenarios, we always call MarkBufferDirty first, then call XLogInsert
 * to generate WAL and real lsn, so the buffer's oldest lsn will be set by
 * MarkBufferDirty. But there are always exceptions that call XLogInsert first
 * to generate WAL, then call MarkBufferDirty. The later MarkBufferDirty will
 * set a oldest lsn that greater than the real lsn, that will cause a wrong
 * consistent lsn, it is not as expected.
 *
 * So if we call XLogInsert first, we will call this function to set a fake oldest
 * lsn like MarkBufferDirty.
 */</comment>
<function><type><name>void</name></type>
<name>polar_set_reg_buffer_oldest_lsn</name><parameter_list>(<parameter><decl><type><name>Buffer</name></type> <name>buffer</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>BufferDesc</name> <modifier>*</modifier></type><name>buf_hdr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>XLogRecPtr</name></type>  <name>oldest_lsn</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>BufferIsInvalid</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * If server is in recovery, the buffer should be set a real lsn, so do not
	 * need to set a fake.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>polar_flush_list_enabled</name><argument_list>()</argument_list></call> <operator>||</operator> 
		<operator>(</operator><call><name>RecoveryInProgress</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator>
		 <operator>!</operator><call><name>polar_bg_redo_state_is_parallel</name><argument_list>(<argument><expr><name>polar_logindex_redo_instance</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>buf_hdr</name> <operator>=</operator> <call><name>GetBufferDescriptor</name><argument_list>(<argument><expr><name>buffer</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>BufferIsPinned</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Not all registered buffers hold the content exclusive lock, like
	 * hashbucketcleanup, if buffer does not hold the lock, we do not set
	 * its oldest lsn.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>LWLockHeldByMeInMode</name><argument_list>(<argument><expr><call><name>BufferDescriptorGetContentLock</name><argument_list>(<argument><expr><name>buf_hdr</name></expr></argument>)</argument_list></call></expr></argument>,
							  <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * If buffer oldest lsn is not set or it is first touch after copy, we
	 * believe that the MarkBufferDirty is not called, it's time to set buffer
	 * oldest lsn and mark it dirty. If buffer oldest lsn is set, but it is
	 * not mark dirty, it will always stay in the flush list, that will block
	 * the consistent lsn.
	 */</comment>
	<expr_stmt><expr><name>oldest_lsn</name> <operator>=</operator> <call><name>polar_buffer_get_oldest_lsn</name><argument_list>(<argument><expr><name>buf_hdr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>XLogRecPtrIsInvalid</name><argument_list>(<argument><expr><name>oldest_lsn</name></expr></argument>)</argument_list></call> <operator>||</operator>
			<call><name>polar_buffer_first_touch_after_copy</name><argument_list>(<argument><expr><name>buf_hdr</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>MarkBufferDirty</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<function><type><name>bool</name></type>
<name>polar_is_future_page</name><parameter_list>(<parameter><decl><type><name>BufferDesc</name> <modifier>*</modifier></type><name>buf_hdr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>XLogRecPtr</name></type> <name>replayed_lsn</name> <init>= <expr><call><name>GetXLogReplayRecPtr</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Page</name></type> <name>page</name> <init>= <expr><call><name>BufferGetPage</name><argument_list>(<argument><expr><call><name>BufferDescriptorGetBuffer</name><argument_list>(<argument><expr><name>buf_hdr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>XLogRecPtrIsInvalid</name><argument_list>(<argument><expr><name>replayed_lsn</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
			<call><name>PageGetLSN</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <name>replayed_lsn</name> <operator>&amp;&amp;</operator>
			<name><name>buf_hdr</name><operator>-&gt;</operator><name>tag</name><operator>.</operator><name>forkNum</name></name> <operator>==</operator> <name>MAIN_FORKNUM</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>POLAR_LOGINDEX_ENABLE_FULLPAGE</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>, <argument><expr><literal type="string">"Read a future page, page lsn = %lx, replayed_lsn = %lx, page_tag = "</literal> <name>POLAR_LOG_BUFFER_TAG_FORMAT</name></expr></argument>,
				 <argument><expr><call><name>PageGetLSN</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>replayed_lsn</name></expr></argument>, <argument><expr><call><name>POLAR_LOG_BUFFER_TAG</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>buf_hdr</name><operator>-&gt;</operator><name>tag</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Check whether we can use lazy checkpoint, if yes, set CHECKPOINT_LAZY and
 * set consistent lsn as lazy checkpoint redo lsn.
 */</comment>
<function><type><name>bool</name></type>
<name>polar_check_lazy_checkpoint</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>shutdown</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>flags</name></decl></parameter>, <parameter><decl><type><name>XLogRecPtr</name> <modifier>*</modifier></type><name>lazy_redo</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type> <name>is_lazy</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>XLogRecPtr</name></type> <name>consistent_lsn</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>polar_lazy_checkpoint_enabled</name><argument_list>()</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><operator>*</operator><name>flags</name> <operator>&amp;=</operator> <operator>~</operator><name>CHECKPOINT_LAZY</name></expr>;</expr_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * polar can use lazy checkpoint for end of recovery, if we use
	 * lazy checkpoint, the end of recovery checkpoint will be ignored,
	 * we will create a normal lazy checkpoint, we set the lazy flag at
	 * StartupXLOG.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>*</operator><name>flags</name> <operator>&amp;</operator> <name>CHECKPOINT_LAZY</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>is_lazy</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if>
	<comment type="block">/*
	 * for CHECKPOINT_CAUSE_XLOG or CHECKPOINT_CAUSE_TIME, we always use
	 * lazy checkpoint.
	 */</comment>
	<if type="elseif">else if <condition>(<expr><operator>!</operator><name>shutdown</name> <operator>&amp;&amp;</operator> <operator>(</operator><operator>*</operator><name>flags</name> <operator>&amp;</operator> <operator>(</operator><name>CHECKPOINT_CAUSE_TIME</name> <operator>|</operator> <name>CHECKPOINT_CAUSE_XLOG</name><operator>)</operator><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>is_lazy</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>is_lazy</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * shutdown checkpoint must not be lazy. For lazy checkpoint, we use
	 * the consistent lsn as its redo lsn, so we should check whether the
	 * consistent lsn is valid, if not, reset the lazy flag and make a normal
	 * checkpoint.
	 */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>shutdown</name> <operator>||</operator> <operator>!</operator><name>is_lazy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>consistent_lsn</name> <operator>=</operator> <call><name>polar_get_consistent_lsn</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* We have a valid consistent lsn, use it */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>XLogRecPtrIsInvalid</name><argument_list>(<argument><expr><name>consistent_lsn</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><operator>*</operator><name>lazy_redo</name> <operator>=</operator> <name>consistent_lsn</name></expr>;</expr_stmt></block_content></block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/*
		 * Try to calculate the consistent lsn by myself, maybe bgwriter
		 * is not started, nobody update the consistent lsn.
		 */</comment>
		<expr_stmt><expr><name>consistent_lsn</name> <operator>=</operator> <call><name>polar_cal_cur_consistent_lsn</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>XLogRecPtrIsInvalid</name><argument_list>(<argument><expr><name>consistent_lsn</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><operator>*</operator><name>lazy_redo</name> <operator>=</operator> <name>consistent_lsn</name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>polar_set_consistent_lsn</name><argument_list>(<argument><expr><name>consistent_lsn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>is_lazy</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>is_lazy</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><operator>*</operator><name>flags</name> <operator>|=</operator> <name>CHECKPOINT_LAZY</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
			 <argument><expr><literal type="string">"Try to create lazy checkpoint, redo lsn is %X/%X"</literal></expr></argument>,
			 <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator><operator>(</operator><operator>(</operator><operator>*</operator><name>lazy_redo</name><operator>)</operator> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr></argument>,
			 <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <operator>*</operator><name>lazy_redo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><operator>*</operator><name>flags</name> <operator>&amp;=</operator> <operator>~</operator><name>CHECKPOINT_LAZY</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<return>return <expr><name>is_lazy</name></expr>;</return>
</block_content>}</block></function>
</unit>
