<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/PolarDB-for-PostgreSQL/src/backend/storage/buffer/polar_copybuf.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * polar_copybuf.c
 *	  Basic copy buffer manager.
 *
 * Copyright (c) 2021, Alibaba Group Holding Limited
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 *
 * IDENTIFICATION
 *	  src/backend/storage/buffer/polar_copybuf.c
 *
 *-------------------------------------------------------------------------
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"polar_flashback/polar_flashback_log.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/polar_copybuf.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/polar_bufmgr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/polar_flushlist.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/guc.h"</cpp:file></cpp:include>

<decl_stmt><decl><type><name>CopyBufferControl</name>    <modifier>*</modifier></type><name>polar_copy_buffer_ctl</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>CopyBufferDescPadded</name> <modifier>*</modifier></type><name>polar_copy_buffer_descriptors</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name>                 <modifier>*</modifier></type><name>polar_copy_buffer_blocks</name></decl>;</decl_stmt>

<function_decl><type><specifier>extern</specifier> <name>XLogRecPtr</name></type> <name>GetXLogInsertRecPtr</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>extern</specifier> <name>void</name></type> <name>XLogFlush</name><parameter_list>(<parameter><decl><type><name>XLogRecPtr</name></type> <name>record</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>extern</specifier> <name>bool</name></type> <name>polar_in_replica_mode</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>extern</specifier> <name>XLogRecPtr</name></type> <name>polar_get_consistent_lsn</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>extern</specifier> <name>XLogRecPtr</name></type> <name>polar_get_oldest_applied_lsn</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>init_copy_buffer_ctl</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>init</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>copy_buffer_alloc</name><parameter_list>(<parameter><decl><type><name>BufferDesc</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><name>XLogRecPtr</name></type> <name>oldest_apply_lsn</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>start_copy_buffer_io</name><parameter_list>(<parameter><decl><type><name>BufferDesc</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>for_input</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/*
 * Initialize shared copy buffer pool
 *
 * This is called once during shared-memory initialization (either in the
 * postmaster, or in a standalone backend).
 */</comment>
<function><type><name>void</name></type>
<name>polar_init_copy_buffer_pool</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type>		<name>found_copy_bufs</name></decl>,
				<decl><type ref="prev"/><name>found_copy_descs</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>polar_copy_buffer_enabled</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/* Align descriptors to a cacheline boundary. */</comment>
	<expr_stmt><expr><name>polar_copy_buffer_descriptors</name> <operator>=</operator> <operator>(</operator><name>CopyBufferDescPadded</name> <operator>*</operator><operator>)</operator>
									<call><name>ShmemInitStruct</name><argument_list>(<argument><expr><literal type="string">"Copy Buffer Descriptors"</literal></expr></argument>,
											<argument><expr><name>polar_copy_buffers</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>CopyBufferDescPadded</name></expr></argument>)</argument_list></sizeof></expr></argument>,
											<argument><expr><operator>&amp;</operator><name>found_copy_descs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>polar_copy_buffer_blocks</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator>
							   <call><name>ShmemInitStruct</name><argument_list>(<argument><expr><literal type="string">"Copy Buffer Blocks"</literal></expr></argument>,
											   <argument><expr><ternary><condition><expr><name>polar_enable_buffer_alignment</name></expr> ?</condition><then>
											   	<expr><call><name>POLAR_BUFFER_EXTEND_SIZE</name><argument_list>(<argument><expr><name>polar_copy_buffers</name> <operator>*</operator> <operator>(</operator><name>Size</name><operator>)</operator> <name>BLCKSZ</name></expr></argument>)</argument_list></call></expr> </then><else>:
												<expr><name>polar_copy_buffers</name> <operator>*</operator> <operator>(</operator><name>Size</name><operator>)</operator> <name>BLCKSZ</name></expr></else></ternary></expr></argument>,
											   <argument><expr><operator>&amp;</operator><name>found_copy_bufs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>polar_enable_buffer_alignment</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>polar_copy_buffer_blocks</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>POLAR_BUFFER_ALIGN</name><argument_list>(<argument><expr><name>polar_copy_buffer_blocks</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>found_copy_bufs</name> <operator>||</operator> <name>found_copy_descs</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* should find all of these, or none of them */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>found_copy_descs</name> <operator>&amp;&amp;</operator> <name>found_copy_bufs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * Initialize all the copy buffer headers.
		 */</comment>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>polar_copy_buffers</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>CopyBufferDesc</name> <modifier>*</modifier></type><name>cbuf</name> <init>= <expr><call><name>polar_get_copy_buffer_descriptor</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>CLEAR_BUFFERTAG</name><argument_list>(<argument><expr><name><name>cbuf</name><operator>-&gt;</operator><name>tag</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>cbuf</name><operator>-&gt;</operator><name>buf_id</name></name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>cbuf</name><operator>-&gt;</operator><name>oldest_lsn</name></name> <operator>=</operator> <name>InvalidXLogRecPtr</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>cbuf</name><operator>-&gt;</operator><name>origin_buffer</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>pg_atomic_init_u32</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>cbuf</name><operator>-&gt;</operator><name>pass_count</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>cbuf</name><operator>-&gt;</operator><name>is_flushed</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>cbuf</name><operator>-&gt;</operator><name>state</name></name> <operator>=</operator> <name>POLAR_COPY_BUFFER_UNUSED</name></expr>;</expr_stmt>

			<comment type="block">/*
			 * Initially link all the buffers together as unused
			 */</comment>
			<expr_stmt><expr><name><name>cbuf</name><operator>-&gt;</operator><name>free_next</name></name> <operator>=</operator> <name>i</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
		</block_content>}</block></for>

		<comment type="block">/* Correct last entry of linked list */</comment>
		<expr_stmt><expr><call><name>polar_get_copy_buffer_descriptor</name><argument_list>(<argument><expr><name>polar_copy_buffers</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>free_next</name> <operator>=</operator> <name>FREENEXT_END_OF_LIST</name></expr>;</expr_stmt>

		<comment type="block">/* Initialize control structure */</comment>
		<expr_stmt><expr><call><name>init_copy_buffer_ctl</name><argument_list>(<argument><expr><operator>!</operator><name>found_copy_descs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>init_copy_buffer_ctl</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>init</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type>        <name>found</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>polar_copy_buffer_ctl</name> <operator>=</operator> <operator>(</operator><name>CopyBufferControl</name> <operator>*</operator><operator>)</operator>
							<call><name>ShmemInitStruct</name><argument_list>(<argument><expr><literal type="string">"Copy Buffer Status"</literal></expr></argument>,
											<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>CopyBufferControl</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><operator>&amp;</operator><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>found</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Only done once, usually in postmaster */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>init</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>SpinLockInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>polar_copy_buffer_ctl</name><operator>-&gt;</operator><name>copy_buffer_ctl_lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>polar_copy_buffer_ctl</name><operator>-&gt;</operator><name>first_free_buffer</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>polar_copy_buffer_ctl</name><operator>-&gt;</operator><name>last_free_buffer</name></name> <operator>=</operator> <name>polar_copy_buffers</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>pg_atomic_init_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>polar_copy_buffer_ctl</name><operator>-&gt;</operator><name>flushed_count</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pg_atomic_init_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>polar_copy_buffer_ctl</name><operator>-&gt;</operator><name>release_count</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pg_atomic_init_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>polar_copy_buffer_ctl</name><operator>-&gt;</operator><name>copied_count</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pg_atomic_init_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>polar_copy_buffer_ctl</name><operator>-&gt;</operator><name>unavailable_count</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pg_atomic_init_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>polar_copy_buffer_ctl</name><operator>-&gt;</operator><name>full_count</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>init</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * polar_copy_buffer_shmem_size
 *
 * Compute the size of shared memory for the copy buffer pool including
 * data pages, buffer descriptors, etc.
 */</comment>
<function><type><name>Size</name></type>
<name>polar_copy_buffer_shmem_size</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Size</name></type>        <name>size</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>polar_copy_buffer_enabled</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>size</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* size of copy buffer descriptors, polar_copy_buffers unit is BLOCKS */</comment>
	<expr_stmt><expr><name>size</name> <operator>=</operator> <call><name>add_size</name><argument_list>(<argument><expr><name>size</name></expr></argument>, <argument><expr><call><name>mul_size</name><argument_list>(<argument><expr><name>polar_copy_buffers</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>CopyBufferDescPadded</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* to allow aligning buffer descriptors */</comment>
	<expr_stmt><expr><name>size</name> <operator>=</operator> <call><name>add_size</name><argument_list>(<argument><expr><name>size</name></expr></argument>, <argument><expr><name>PG_CACHE_LINE_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* POLAR: extra alignment padding for data I/O buffers */</comment>
	<if_stmt><if>if <condition>(<expr><name>polar_enable_buffer_alignment</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>size</name> <operator>=</operator> <call><name>POLAR_BUFFER_EXTEND_SIZE</name><argument_list>(<argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<comment type="block">/* size of data pages */</comment>
	<expr_stmt><expr><name>size</name> <operator>=</operator> <call><name>add_size</name><argument_list>(<argument><expr><name>size</name></expr></argument>, <argument><expr><call><name>mul_size</name><argument_list>(<argument><expr><name>polar_copy_buffers</name></expr></argument>, <argument><expr><name>BLCKSZ</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* size of copy buffer control */</comment>
	<expr_stmt><expr><name>size</name> <operator>=</operator> <call><name>add_size</name><argument_list>(<argument><expr><name>size</name></expr></argument>, <argument><expr><call><name>MAXALIGN</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>CopyBufferControl</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>size</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Allocate a copy buffer and copy the buffer data into it.
 * Caller should pin and share-lock this buffer.
 */</comment>
<function><type><name>void</name></type>
<name>polar_buffer_copy_if_needed</name><parameter_list>(<parameter><decl><type><name>BufferDesc</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><name>XLogRecPtr</name></type> <name>oldest_apply_lsn</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>polar_copy_buffer_enabled</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>copy_buffer_alloc</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>oldest_apply_lsn</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>pg_atomic_add_fetch_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>polar_copy_buffer_ctl</name><operator>-&gt;</operator><name>copied_count</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>pg_atomic_add_fetch_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>polar_copy_buffer_ctl</name><operator>-&gt;</operator><name>unavailable_count</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/* Check if the buffer is satisfied to allocate a copy buffer. */</comment>
<function><type><name>bool</name></type>
<name>polar_buffer_copy_is_satisfied</name><parameter_list>(<parameter><decl><type><name>BufferDesc</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>,
							   <parameter><decl><type><name>XLogRecPtr</name></type> <name>oldest_apply_lsn</name></decl></parameter>,
							   <parameter><decl><type><name>bool</name></type> <name>check_io</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>uint32</name></type>     <name>buf_state</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32</name></type>     <name>lsn_lag_with_cons_lsn</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>XLogRecPtr</name></type> <name>oldest_lsn</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>       <name>is_dirty</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>polar_copy_buffer_enabled</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>polar_enable_shared_storage_mode</name> <operator>||</operator>
		<call><name>polar_in_replica_mode</name><argument_list>()</argument_list></call> <operator>||</operator>
		<call><name>XLogRecPtrIsInvalid</name><argument_list>(<argument><expr><name>oldest_apply_lsn</name></expr></argument>)</argument_list></call> <operator>||</operator>
		<name><name>buf</name><operator>-&gt;</operator><name>tag</name><operator>.</operator><name>forkNum</name></name> <operator>==</operator> <name>FSM_FORKNUM</name> <operator>||</operator>
		<name><name>buf</name><operator>-&gt;</operator><name>tag</name><operator>.</operator><name>forkNum</name></name> <operator>==</operator> <name>INIT_FORKNUM</name> <operator>||</operator>
		<call><name>polar_donot_control_vm_buffer</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call> <operator>||</operator>
		<call><name>BufferGetLSN</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call> <operator>&lt;=</operator> <name>oldest_apply_lsn</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>buf_state</name> <operator>=</operator> <call><name>LockBufHdr</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Already has a copy buffer */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>buf</name><operator>-&gt;</operator><name>copy_buffer</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>UnlockBufHdr</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>buf_state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>UnlockBufHdr</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>buf_state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>oldest_lsn</name> <operator>=</operator> <call><name>polar_buffer_get_oldest_lsn</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>is_dirty</name> <operator>=</operator> <name>buf_state</name> <operator>&amp;</operator> <name>BM_DIRTY</name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>XLogRecPtrIsInvalid</name><argument_list>(<argument><expr><name>oldest_lsn</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>,
			 <argument><expr><literal type="string">"The oldest lsn of buffer [%u,%u,%u], %u, %d) to copy is invalid, dirty: %d, page flags: %d"</literal></expr></argument>,
			 <argument><expr><name><name>buf</name><operator>-&gt;</operator><name>tag</name><operator>.</operator><name>rnode</name><operator>.</operator><name>spcNode</name></name></expr></argument>,
			 <argument><expr><name><name>buf</name><operator>-&gt;</operator><name>tag</name><operator>.</operator><name>rnode</name><operator>.</operator><name>dbNode</name></name></expr></argument>,
			 <argument><expr><name><name>buf</name><operator>-&gt;</operator><name>tag</name><operator>.</operator><name>rnode</name><operator>.</operator><name>relNode</name></name></expr></argument>,
			 <argument><expr><name><name>buf</name><operator>-&gt;</operator><name>tag</name><operator>.</operator><name>blockNum</name></name></expr></argument>,
			 <argument><expr><name><name>buf</name><operator>-&gt;</operator><name>tag</name><operator>.</operator><name>forkNum</name></name></expr></argument>,
			 <argument><expr><name>is_dirty</name></expr></argument>, <argument><expr><operator>(</operator><operator>(</operator><name>PageHeader</name><operator>)</operator><call><name>BufferGetPage</name><argument_list>(<argument><expr><name><name>buf</name><operator>-&gt;</operator><name>buf_id</name></name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call><operator>)</operator><operator>-&gt;</operator><name>pd_flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* If buffer oldest lsn is invalid, it must be not in the flushlist */</comment>
		<comment type="line">//Assert(buf-&gt;flush_next == POLAR_FLUSHNEXT_NOT_IN_LIST);</comment>
		<comment type="line">//Assert(buf-&gt;flush_prev == POLAR_FLUSHNEXT_NOT_IN_LIST);</comment>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>buf_state</name> <operator>&amp;</operator> <name>BM_PERMANENT</name><operator>)</operator> <operator>||</operator>
			<operator>(</operator><name>check_io</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>buf_state</name> <operator>&amp;</operator> <name>BM_IO_IN_PROGRESS</name><operator>)</operator><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>lsn_lag_with_cons_lsn</name> <operator>=</operator> <name>oldest_lsn</name> <operator>-</operator> <call><name>polar_get_consistent_lsn</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>buf</name><operator>-&gt;</operator><name>recently_modified_count</name></name> <operator>&gt;</operator> <name>polar_buffer_copy_min_modified_count</name> <operator>&amp;&amp;</operator>
		<name>lsn_lag_with_cons_lsn</name> <operator>&lt;</operator>
			<name>polar_buffer_copy_lsn_lag_with_cons_lsn</name> <operator>*</operator> <literal type="number">1024</literal> <operator>*</operator> <literal type="number">1024</literal><operator>)</operator> <operator>||</operator>
		<name>lsn_lag_with_cons_lsn</name> <operator>&lt;</operator>
			<name>polar_buffer_copy_lsn_lag_with_cons_lsn</name> <operator>*</operator> <literal type="number">1024</literal> <operator>*</operator> <literal type="number">1024</literal> <operator>/</operator> <literal type="number">2</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>copy_buffer_alloc</name><parameter_list>(<parameter><decl><type><name>BufferDesc</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><name>XLogRecPtr</name></type> <name>oldest_apply_lsn</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>CopyBufferDesc</name> <modifier>*</modifier></type><name>cbuf</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32</name></type>         <name>buf_state</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>XLogRecPtr</name></type>     <name>consistent_lsn</name></decl>;</decl_stmt>

	<comment type="block">/* Before copy, lock the buffer using io_in_progress lock like FlushBuffer */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>start_copy_buffer_io</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* Double check */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>polar_buffer_copy_is_satisfied</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>oldest_apply_lsn</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>TerminateBufferIO</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>consistent_lsn</name> <operator>=</operator> <call><name>polar_get_consistent_lsn</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>polar_enable_debug</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>,
			 <argument><expr><literal type="string">"Copy page ([%u,%u,%u], %u), page latest lsn %X/%X, page oldest lsn %X/%X, consistent lsn %X/%X"</literal></expr></argument>,
			 <argument><expr><name><name>buf</name><operator>-&gt;</operator><name>tag</name><operator>.</operator><name>rnode</name><operator>.</operator><name>spcNode</name></name></expr></argument>,
			 <argument><expr><name><name>buf</name><operator>-&gt;</operator><name>tag</name><operator>.</operator><name>rnode</name><operator>.</operator><name>dbNode</name></name></expr></argument>,
			 <argument><expr><name><name>buf</name><operator>-&gt;</operator><name>tag</name><operator>.</operator><name>rnode</name><operator>.</operator><name>relNode</name></name></expr></argument>,
			 <argument><expr><name><name>buf</name><operator>-&gt;</operator><name>tag</name><operator>.</operator><name>blockNum</name></name></expr></argument>,
			 <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <operator>(</operator><call><name>BufferGetLSN</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr></argument>,
			 <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <operator>(</operator><call><name>BufferGetLSN</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>,
			 <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <operator>(</operator><call><name>polar_buffer_get_oldest_lsn</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr></argument>,
			 <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <call><name>polar_buffer_get_oldest_lsn</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr></argument>,
			 <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <operator>(</operator><name>consistent_lsn</name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr></argument>,
			 <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <name>consistent_lsn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Acquire the spinlock to remove element from the freelist */</comment>
	<expr_stmt><expr><call><name>SpinLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>polar_copy_buffer_ctl</name><operator>-&gt;</operator><name>copy_buffer_ctl_lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>polar_copy_buffer_ctl</name><operator>-&gt;</operator><name>first_free_buffer</name></name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><specifier>static</specifier> <name>TimestampTz</name></type> <name>last_log_time</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>SpinLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>polar_copy_buffer_ctl</name><operator>-&gt;</operator><name>copy_buffer_ctl_lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>TerminateBufferIO</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pg_atomic_fetch_add_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>polar_copy_buffer_ctl</name><operator>-&gt;</operator><name>full_count</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Do not log frequently, every 1s log one */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>TimestampDifferenceExceeds</name><argument_list>(<argument><expr><name>last_log_time</name></expr></argument>, <argument><expr><call><name>GetCurrentTimestamp</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><literal type="number">1000</literal></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>, <argument><expr><literal type="string">"Copy buffer pool is full, pool size is %d"</literal></expr></argument>,
				 <argument><expr><name>polar_copy_buffers</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>last_log_time</name> <operator>=</operator> <call><name>GetCurrentTimestamp</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>cbuf</name> <operator>=</operator> <call><name>polar_get_copy_buffer_descriptor</name><argument_list>(<argument><expr><name><name>polar_copy_buffer_ctl</name><operator>-&gt;</operator><name>first_free_buffer</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>cbuf</name><operator>-&gt;</operator><name>free_next</name></name> <operator>!=</operator> <name>FREENEXT_NOT_IN_LIST</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Unconditionally remove buffer from freelist */</comment>
	<expr_stmt><expr><name><name>polar_copy_buffer_ctl</name><operator>-&gt;</operator><name>first_free_buffer</name></name> <operator>=</operator> <name><name>cbuf</name><operator>-&gt;</operator><name>free_next</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>cbuf</name><operator>-&gt;</operator><name>free_next</name></name> <operator>=</operator> <name>FREENEXT_NOT_IN_LIST</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Release the lock so someone else can access the freelist while
	 * we check out this buffer.
	 */</comment>
	<expr_stmt><expr><call><name>SpinLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>polar_copy_buffer_ctl</name><operator>-&gt;</operator><name>copy_buffer_ctl_lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>cbuf</name><operator>-&gt;</operator><name>state</name></name> <operator>==</operator> <name>POLAR_COPY_BUFFER_UNUSED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>XLogRecPtrIsInvalid</name><argument_list>(<argument><expr><name><name>buf</name><operator>-&gt;</operator><name>oldest_lsn</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><call><name>CopyBufHdrGetBlock</name><argument_list>(<argument><expr><name>cbuf</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>BufHdrGetBlock</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>BLCKSZ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>SET_COPYBUFFERTAG</name><argument_list>(<argument><expr><name><name>cbuf</name><operator>-&gt;</operator><name>tag</name></name></expr></argument>, <argument><expr><name><name>buf</name><operator>-&gt;</operator><name>tag</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pg_atomic_write_u64</name><argument_list>(<argument><expr><operator>(</operator><name>pg_atomic_uint64</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name><name>cbuf</name><operator>-&gt;</operator><name>oldest_lsn</name></name></expr></argument>,
						<argument><expr><name><name>buf</name><operator>-&gt;</operator><name>oldest_lsn</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pg_atomic_write_u32</name><argument_list>(<argument><expr><operator>(</operator><name>pg_atomic_uint32</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name><name>cbuf</name><operator>-&gt;</operator><name>origin_buffer</name></name></expr></argument>,
					   <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <call><name>BufferDescriptorGetBuffer</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>cbuf</name><operator>-&gt;</operator><name>state</name></name> <operator>=</operator> <name>POLAR_COPY_BUFFER_USED</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>buf_state</name> <operator>=</operator> <call><name>LockBufHdr</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>buf</name><operator>-&gt;</operator><name>copy_buffer</name></name> <operator>=</operator> <name>cbuf</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>UnlockBufHdr</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>buf_state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>TerminateBufferIO</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * polar_free_copy_buffer - free a copy buffer and put it into the freelist
 *
 * Caller have acquired the buffer's io_in_progress lock.
 */</comment>
<function><type><name>void</name></type>
<name>polar_free_copy_buffer</name><parameter_list>(<parameter><decl><type><name>BufferDesc</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>uint32</name></type>         <name>buf_state</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CopyBufferDesc</name> <modifier>*</modifier></type><name>cbuf</name> <init>= <expr><name><name>buf</name><operator>-&gt;</operator><name>copy_buffer</name></name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>cbuf</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>polar_enable_debug</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>,
				 <argument><expr><literal type="string">"Free copy buffer ([%u,%u,%u], %u), cbuf oldest lsn %X/%X, latest lsn %X/%X, is_flushed %d"</literal></expr></argument>,
				 <argument><expr><name><name>buf</name><operator>-&gt;</operator><name>tag</name><operator>.</operator><name>rnode</name><operator>.</operator><name>spcNode</name></name></expr></argument>,
				 <argument><expr><name><name>buf</name><operator>-&gt;</operator><name>tag</name><operator>.</operator><name>rnode</name><operator>.</operator><name>dbNode</name></name></expr></argument>,
				 <argument><expr><name><name>buf</name><operator>-&gt;</operator><name>tag</name><operator>.</operator><name>rnode</name><operator>.</operator><name>relNode</name></name></expr></argument>,
				 <argument><expr><name><name>buf</name><operator>-&gt;</operator><name>tag</name><operator>.</operator><name>blockNum</name></name></expr></argument>,
				 <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <operator>(</operator><name><name>cbuf</name><operator>-&gt;</operator><name>oldest_lsn</name></name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr></argument>,
				 <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <name><name>cbuf</name><operator>-&gt;</operator><name>oldest_lsn</name></name></expr></argument>,
				 <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <operator>(</operator><call><name>polar_copy_buffer_get_lsn</name><argument_list>(<argument><expr><name>cbuf</name></expr></argument>)</argument_list></call> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr></argument>,
				 <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <call><name>polar_copy_buffer_get_lsn</name><argument_list>(<argument><expr><name>cbuf</name></expr></argument>)</argument_list></call></expr></argument>,
				 <argument><expr><name><name>cbuf</name><operator>-&gt;</operator><name>is_flushed</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* First reset it */</comment>
		<expr_stmt><expr><name>buf_state</name> <operator>=</operator> <call><name>LockBufHdr</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>buf</name><operator>-&gt;</operator><name>copy_buffer</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>buf</name><operator>-&gt;</operator><name>polar_flags</name></name> <operator>&amp;=</operator> <operator>~</operator><name>POLAR_BUF_FIRST_TOUCHED_AFTER_COPY</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>UnlockBufHdr</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>buf_state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>pg_atomic_fetch_add_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>polar_copy_buffer_ctl</name><operator>-&gt;</operator><name>release_count</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>cbuf</name><operator>-&gt;</operator><name>is_flushed</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>pg_atomic_fetch_add_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>polar_copy_buffer_ctl</name><operator>-&gt;</operator><name>flushed_count</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>CLEAR_BUFFERTAG</name><argument_list>(<argument><expr><name><name>cbuf</name><operator>-&gt;</operator><name>tag</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pg_atomic_write_u32</name><argument_list>(<argument><expr><operator>(</operator><name>pg_atomic_uint32</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name><name>cbuf</name><operator>-&gt;</operator><name>origin_buffer</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pg_atomic_write_u32</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>cbuf</name><operator>-&gt;</operator><name>pass_count</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pg_atomic_write_u64</name><argument_list>(<argument><expr><operator>(</operator><name>pg_atomic_uint64</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name><name>cbuf</name><operator>-&gt;</operator><name>oldest_lsn</name></name></expr></argument>, <argument><expr><name>InvalidXLogRecPtr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>cbuf</name><operator>-&gt;</operator><name>state</name></name> <operator>=</operator> <name>POLAR_COPY_BUFFER_UNUSED</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>cbuf</name><operator>-&gt;</operator><name>is_flushed</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

		<comment type="block">/* Then put into the freelist */</comment>
		<expr_stmt><expr><call><name>SpinLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>polar_copy_buffer_ctl</name><operator>-&gt;</operator><name>copy_buffer_ctl_lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>cbuf</name><operator>-&gt;</operator><name>free_next</name></name> <operator>==</operator> <name>FREENEXT_NOT_IN_LIST</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>cbuf</name><operator>-&gt;</operator><name>free_next</name></name> <operator>=</operator> <name><name>polar_copy_buffer_ctl</name><operator>-&gt;</operator><name>first_free_buffer</name></name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>cbuf</name><operator>-&gt;</operator><name>free_next</name></name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>polar_copy_buffer_ctl</name><operator>-&gt;</operator><name>last_free_buffer</name></name> <operator>=</operator> <name><name>cbuf</name><operator>-&gt;</operator><name>buf_id</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name><name>polar_copy_buffer_ctl</name><operator>-&gt;</operator><name>first_free_buffer</name></name> <operator>=</operator> <name><name>cbuf</name><operator>-&gt;</operator><name>buf_id</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>SpinLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>polar_copy_buffer_ctl</name><operator>-&gt;</operator><name>copy_buffer_ctl_lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return;</return>
</block_content>}</block></function>

<comment type="block">/* Like FlushBuffer, flush a copy buffer. */</comment>
<function><type><name>void</name></type>
<name>polar_flush_copy_buffer</name><parameter_list>(<parameter><decl><type><name>BufferDesc</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><name>SMgrRelation</name></type> <name>reln</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>XLogRecPtr</name></type>     <name>latest_lsn</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>XLogRecPtr</name></type>     <name>oldest_apply_lsn</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Block</name></type>          <name>buf_block</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32</name></type>         <name>buf_state</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CopyBufferDesc</name> <modifier>*</modifier></type><name>cbuf</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>polar_copy_buffer_enabled</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Acquire the buffer's io_in_progress lock.  If start_copy_buffer_io
	 * returns false, then someone else flushed the buffer before we could,
	 * so we need not do anything.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>start_copy_buffer_io</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>cbuf</name> <operator>=</operator> <name><name>buf</name><operator>-&gt;</operator><name>copy_buffer</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>cbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Double check. The copy buffer may have been replaced by others,
	 * its latest lsn may be greater than oldest apply lsn.
	 */</comment>
	<expr_stmt><expr><name>oldest_apply_lsn</name> <operator>=</operator> <call><name>polar_get_oldest_applied_lsn</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>polar_buffer_can_be_flushed</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>oldest_apply_lsn</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>TerminateBufferIO</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Find smgr relation for buffer */</comment>
	<if_stmt><if>if <condition>(<expr><name>reln</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>reln</name> <operator>=</operator> <call><name>smgropen</name><argument_list>(<argument><expr><name><name>buf</name><operator>-&gt;</operator><name>tag</name><operator>.</operator><name>rnode</name></name></expr></argument>, <argument><expr><name>InvalidBackendId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* We already have the IO lock, don't need the header lock */</comment>
	<expr_stmt><expr><name>latest_lsn</name> <operator>=</operator> <call><name>polar_copy_buffer_get_lsn</name><argument_list>(<argument><expr><name>cbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>unlikely</name><argument_list>(<argument><expr><name>polar_enable_debug</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
			 <argument><expr><literal type="string">"Flush copy buffer ([%u,%u,%u], %u), copy buffer oldest lsn %X/%X, latest lsn %X/%X, oldest apply lsn %X/%X"</literal></expr></argument>,
			 <argument><expr><name><name>buf</name><operator>-&gt;</operator><name>tag</name><operator>.</operator><name>rnode</name><operator>.</operator><name>spcNode</name></name></expr></argument>,
			 <argument><expr><name><name>buf</name><operator>-&gt;</operator><name>tag</name><operator>.</operator><name>rnode</name><operator>.</operator><name>dbNode</name></name></expr></argument>,
			 <argument><expr><name><name>buf</name><operator>-&gt;</operator><name>tag</name><operator>.</operator><name>rnode</name><operator>.</operator><name>relNode</name></name></expr></argument>,
			 <argument><expr><name><name>buf</name><operator>-&gt;</operator><name>tag</name><operator>.</operator><name>blockNum</name></name></expr></argument>,
			 <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <operator>(</operator><name><name>cbuf</name><operator>-&gt;</operator><name>oldest_lsn</name></name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr></argument>,
			 <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <name><name>cbuf</name><operator>-&gt;</operator><name>oldest_lsn</name></name></expr></argument>,
			 <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <operator>(</operator><name>latest_lsn</name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr></argument>,
			 <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <name>latest_lsn</name></expr></argument>,
			 <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <operator>(</operator><name>oldest_apply_lsn</name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr></argument>,
			 <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <name>oldest_apply_lsn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Force XLOG flush up to buffer's LSN.  This implements the basic WAL
	 * rule that log updates must hit disk before any of the data-file changes
	 * they describe do.
	 *
	 * However, this rule does not apply to unlogged relations, which will be
	 * lost after a crash anyway.  Most unlogged relation pages do not bear
	 * LSNs since we never emit WAL records for them, and therefore flushing
	 * up through the buffer LSN would be useless, but harmless.  However,
	 * GiST indexes use LSNs internally to track page-splits, and therefore
	 * unlogged GiST pages bear "fake" LSNs generated by
	 * GetFakeLSNForUnloggedRel.  It is unlikely but possible that the fake
	 * LSN counter could advance past the WAL insertion point; and if it did
	 * happen, attempting to flush WAL through that location would fail, with
	 * disastrous system-wide consequences.  To make sure that can't happen,
	 * skip the flush if the buffer isn't permanent.
	 */</comment>
	<expr_stmt><expr><name>buf_state</name> <operator>=</operator> <call><name>LockBufHdr</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>UnlockBufHdr</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>buf_state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>buf_state</name> <operator>&amp;</operator> <name>BM_PERMANENT</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>XLogFlush</name><argument_list>(<argument><expr><name>latest_lsn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>polar_flush_buf_flog_rec</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>flog_instance</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Now it's safe to write copy buffer to disk. Note that no one else should
	 * have been able to write it while we were busy with log flushing because
	 * we have the io_in_progress lock.
	 */</comment>
	<expr_stmt><expr><name>buf_block</name> <operator>=</operator> <call><name>CopyBufHdrGetBlock</name><argument_list>(<argument><expr><name>cbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PageEncryptInplace</name><argument_list>(<argument><expr><operator>(</operator><name>Page</name><operator>)</operator> <name>buf_block</name></expr></argument>, <argument><expr><name><name>buf</name><operator>-&gt;</operator><name>tag</name><operator>.</operator><name>forkNum</name></name></expr></argument>, <argument><expr><name><name>buf</name><operator>-&gt;</operator><name>tag</name><operator>.</operator><name>blockNum</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * For copy buffer, only call the PageSetChecksumInplace instead of
	 * PageSetChecksumCopy for buffer, no other process can be modifying
	 * this copy buffer.
	 */</comment>
	<expr_stmt><expr><call><name>PageSetChecksumInplace</name><argument_list>(<argument><expr><operator>(</operator><name>Page</name><operator>)</operator> <name>buf_block</name></expr></argument>, <argument><expr><name><name>buf</name><operator>-&gt;</operator><name>tag</name><operator>.</operator><name>blockNum</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Write the copy buffer */</comment>
	<expr_stmt><expr><call><name>smgrwrite</name><argument_list>(<argument><expr><name>reln</name></expr></argument>,
			  <argument><expr><name><name>buf</name><operator>-&gt;</operator><name>tag</name><operator>.</operator><name>forkNum</name></name></expr></argument>,
			  <argument><expr><name><name>buf</name><operator>-&gt;</operator><name>tag</name><operator>.</operator><name>blockNum</name></name></expr></argument>,
			  <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>buf_block</name></expr></argument>,
			  <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* The oldest_lsn should be cleared once its copy buffer is flushed. */</comment>
	<expr_stmt><expr><name>buf_state</name> <operator>=</operator> <call><name>LockBufHdr</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>cbuf</name><operator>-&gt;</operator><name>is_flushed</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>UnlockBufHdr</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>buf_state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>polar_free_copy_buffer</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * For copy buffer, do not mark the original buffer as clean and
	 * end the io_in_progress state.
	 */</comment>
	<expr_stmt><expr><call><name>TerminateBufferIO</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Before copy the buffer, call this function to mark the buffer as I/O busy.
 * Avoid other backend to copy it.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>start_copy_buffer_io</name><parameter_list>(<parameter><decl><type><name>BufferDesc</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>for_input</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>polar_start_buffer_io_extend</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>for_input</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>XLogRecPtr</name></type>
<name>polar_copy_buffers_get_oldest_lsn</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CopyBufferDesc</name> <modifier>*</modifier></type><name>cbuf</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>XLogRecPtr</name></type>     <name>cur_lsn</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>XLogRecPtr</name></type>     <name>res</name> <init>= <expr><name>InvalidXLogRecPtr</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>polar_copy_buffer_enabled</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>res</name></expr>;</return></block_content></block></if></if_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>polar_copy_buffers</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><name>cbuf</name> <operator>=</operator> <call><name>polar_get_copy_buffer_descriptor</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Use atomic read */</comment>
		<expr_stmt><expr><name>cur_lsn</name> <operator>=</operator> <call><name>pg_atomic_read_u64</name><argument_list>(<argument><expr><operator>(</operator><name>pg_atomic_uint64</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name><name>cbuf</name><operator>-&gt;</operator><name>oldest_lsn</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>XLogRecPtrIsInvalid</name><argument_list>(<argument><expr><name>cur_lsn</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>XLogRecPtrIsInvalid</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call> <operator>||</operator> <name>res</name> <operator>&gt;</operator> <name>cur_lsn</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>res</name> <operator>=</operator> <name>cur_lsn</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></for>

	<return>return <expr><name>res</name></expr>;</return>
</block_content>}</block></function>
</unit>
