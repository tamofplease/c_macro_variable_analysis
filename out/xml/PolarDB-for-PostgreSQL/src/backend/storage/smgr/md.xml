<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/PolarDB-for-PostgreSQL/src/backend/storage/smgr/md.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * md.c
 *	  This code manages relations that reside on magnetic disk.
 *
 * Or at least, that was what the Berkeley folk had in mind when they named
 * this file.  In reality, what this code provides is an interface from
 * the smgr API to Unix-like filesystem APIs, so it will work with any type
 * of device for which the operating system provides filesystem support.
 * It doesn't matter whether the bits are on spinning rust or some other
 * storage technology.
 *
 * Portions Copyright (c) 1996-2018, PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, Regents of the University of California
 *
 *
 * IDENTIFICATION
 *	  src/backend/storage/smgr/md.c
 *
 *-------------------------------------------------------------------------
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;unistd.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;fcntl.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/file.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/xlogutils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/xlog.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pgstat.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"portability/instr_time.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postmaster/bgwriter.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/fd.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/bufmgr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/relfilenode.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/smgr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/hsearch.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/memutils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pg_trace.h"</cpp:file></cpp:include>

<comment type="block">/* POLAR */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/polar_logindex_redo.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/polar_fd.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/faultinjector.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/guc.h"</cpp:file></cpp:include>

<comment type="block">/* intervals for calling AbsorbFsyncRequests in mdsync and mdpostckpt */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FSYNCS_PER_ABSORB</name></cpp:macro>		<cpp:value>10</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>UNLINKS_PER_ABSORB</name></cpp:macro>		<cpp:value>10</cpp:value></cpp:define>

<comment type="block">/*
 * Special values for the segno arg to RememberFsyncRequest.
 *
 * Note that CompactCheckpointerRequestQueue assumes that it's OK to remove an
 * fsync request from the queue if an identical, subsequent request is found.
 * See comments there before making changes here.
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FORGET_RELATION_FSYNC</name></cpp:macro>	<cpp:value>(InvalidBlockNumber)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FORGET_DATABASE_FSYNC</name></cpp:macro>	<cpp:value>(InvalidBlockNumber-1)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>UNLINK_RELATION_REQUEST</name></cpp:macro> <cpp:value>(InvalidBlockNumber-2)</cpp:value></cpp:define>

<comment type="block">/*
 * On Windows, we have to interpret EACCES as possibly meaning the same as
 * ENOENT, because if a file is unlinked-but-not-yet-gone on that platform,
 * that's what you get.  Ugh.  This code is designed so that we don't
 * actually believe these cases are okay without further evidence (namely,
 * a pending fsync request getting canceled ... see mdsync).
 */</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>WIN32</name></cpp:ifndef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FILE_POSSIBLY_DELETED</name><parameter_list>(<parameter><type><name>err</name></type></parameter>)</parameter_list></cpp:macro>	<cpp:value>((err) == ENOENT)</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FILE_POSSIBLY_DELETED</name><parameter_list>(<parameter><type><name>err</name></type></parameter>)</parameter_list></cpp:macro>	<cpp:value>((err) == ENOENT || (err) == EACCES)</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
 *	The magnetic disk storage manager keeps track of open file
 *	descriptors in its own descriptor pool.  This is done to make it
 *	easier to support relations that are larger than the operating
 *	system's file size limit (often 2GBytes).  In order to do that,
 *	we break relations up into "segment" files that are each shorter than
 *	the OS file size limit.  The segment size is set by the RELSEG_SIZE
 *	configuration constant in pg_config.h.
 *
 *	On disk, a relation must consist of consecutively numbered segment
 *	files in the pattern
 *		-- Zero or more full segments of exactly RELSEG_SIZE blocks each
 *		-- Exactly one partial segment of size 0 &lt;= size &lt; RELSEG_SIZE blocks
 *		-- Optionally, any number of inactive segments of size 0 blocks.
 *	The full and partial segments are collectively the "active" segments.
 *	Inactive segments are those that once contained data but are currently
 *	not needed because of an mdtruncate() operation.  The reason for leaving
 *	them present at size zero, rather than unlinking them, is that other
 *	backends and/or the checkpointer might be holding open file references to
 *	such segments.  If the relation expands again after mdtruncate(), such
 *	that a deactivated segment becomes active again, it is important that
 *	such file references still be valid --- else data might get written
 *	out to an unlinked old copy of a segment file that will eventually
 *	disappear.
 *
 *	File descriptors are stored in the per-fork md_seg_fds arrays inside
 *	SMgrRelation. The length of these arrays is stored in md_num_open_segs.
 *	Note that a fork's md_num_open_segs having a specific value does not
 *	necessarily mean the relation doesn't have additional segments; we may
 *	just not have opened the next segment yet.  (We could not have "all
 *	segments are in the array" as an invariant anyway, since another backend
 *	could extend the relation while we aren't looking.)  We do not have
 *	entries for inactive segments, however; as soon as we find a partial
 *	segment, we assume that any subsequent segments are inactive.
 *
 *	The entire MdfdVec array is palloc'd in the MdCxt memory context.
 */</comment>

<typedef>typedef <type><struct>struct <name>_MdfdVec</name>
<block>{
	<decl_stmt><decl><type><name>File</name></type>		<name>mdfd_vfd</name></decl>;</decl_stmt>		<comment type="block">/* fd number in fd.c's pool */</comment>
	<decl_stmt><decl><type><name>BlockNumber</name></type> <name>mdfd_segno</name></decl>;</decl_stmt>		<comment type="block">/* segment number, from 0 */</comment>
}</block></struct></type> <name>MdfdVec</name>;</typedef>

<decl_stmt><decl><type><specifier>static</specifier> <name>MemoryContext</name></type> <name>MdCxt</name></decl>;</decl_stmt>		<comment type="block">/* context for all MdfdVec objects */</comment>


<comment type="block">/*
 * In some contexts (currently, standalone backends and the checkpointer)
 * we keep track of pending fsync operations: we need to remember all relation
 * segments that have been written since the last checkpoint, so that we can
 * fsync them down to disk before completing the next checkpoint.  This hash
 * table remembers the pending operations.  We use a hash table mostly as
 * a convenient way of merging duplicate requests.
 *
 * We use a similar mechanism to remember no-longer-needed files that can
 * be deleted after the next checkpoint, but we use a linked list instead of
 * a hash table, because we don't expect there to be any duplicate requests.
 *
 * These mechanisms are only used for non-temp relations; we never fsync
 * temp rels, nor do we need to postpone their deletion (see comments in
 * mdunlink).
 *
 * (Regular backends do not track pending operations locally, but forward
 * them to the checkpointer.)
 */</comment>
<typedef>typedef <type><name>uint16</name></type> <name>CycleCtr</name>;</typedef>		<comment type="block">/* can be any convenient integer size */</comment>

<typedef>typedef <type><struct>struct
<block>{
	<decl_stmt><decl><type><name>RelFileNode</name></type> <name>rnode</name></decl>;</decl_stmt>			<comment type="block">/* hash table key (must be first!) */</comment>
	<decl_stmt><decl><type><name>CycleCtr</name></type>	<name>cycle_ctr</name></decl>;</decl_stmt>		<comment type="block">/* mdsync_cycle_ctr of oldest request */</comment>
	<comment type="block">/* requests[f] has bit n set if we need to fsync segment n of fork f */</comment>
	<decl_stmt><decl><type><name>Bitmapset</name>  <modifier>*</modifier></type><name><name>requests</name><index>[<expr><name>MAX_FORKNUM</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>
	<comment type="block">/* canceled[f] is true if we canceled fsyncs for fork "recently" */</comment>
	<decl_stmt><decl><type><name>bool</name></type>		<name><name>canceled</name><index>[<expr><name>MAX_FORKNUM</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>
}</block></struct></type> <name>PendingOperationEntry</name>;</typedef>

<typedef>typedef <type><struct>struct
<block>{
	<decl_stmt><decl><type><name>RelFileNode</name></type> <name>rnode</name></decl>;</decl_stmt>			<comment type="block">/* the dead relation to delete */</comment>
	<decl_stmt><decl><type><name>CycleCtr</name></type>	<name>cycle_ctr</name></decl>;</decl_stmt>		<comment type="block">/* mdckpt_cycle_ctr when request was made */</comment>
}</block></struct></type> <name>PendingUnlinkEntry</name>;</typedef>

<decl_stmt><decl><type><specifier>static</specifier> <name>HTAB</name> <modifier>*</modifier></type><name>pendingOpsTable</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type><name>pendingUnlinks</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>MemoryContext</name></type> <name>pendingOpsCxt</name></decl>;</decl_stmt> <comment type="block">/* context for the above  */</comment>

<decl_stmt><decl><type><specifier>static</specifier> <name>CycleCtr</name></type> <name>mdsync_cycle_ctr</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>CycleCtr</name></type> <name>mdckpt_cycle_ctr</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>


<comment type="block" format="doxygen">/*** behavior for mdopen &amp; _mdfd_getseg ***/</comment>
<comment type="block">/* ereport if segment not present */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>EXTENSION_FAIL</name></cpp:macro>				<cpp:value>(1 &lt;&lt; 0)</cpp:value></cpp:define>
<comment type="block">/* return NULL if segment not present */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>EXTENSION_RETURN_NULL</name></cpp:macro>		<cpp:value>(1 &lt;&lt; 1)</cpp:value></cpp:define>
<comment type="block">/* create new segments as needed */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>EXTENSION_CREATE</name></cpp:macro>			<cpp:value>(1 &lt;&lt; 2)</cpp:value></cpp:define>
<comment type="block">/* create new segments if needed during recovery */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>EXTENSION_CREATE_RECOVERY</name></cpp:macro>	<cpp:value>(1 &lt;&lt; 3)</cpp:value></cpp:define>
<comment type="block">/*
 * Allow opening segments which are preceded by segments smaller than
 * RELSEG_SIZE, e.g. inactive segments (see above). Note that this is breaks
 * mdnblocks() and related functionality henceforth - which currently is ok,
 * because this is only required in the checkpointer which never uses
 * mdnblocks().
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>EXTENSION_DONT_CHECK_SIZE</name></cpp:macro>	<cpp:value>(1 &lt;&lt; 4)</cpp:value></cpp:define>


<comment type="block">/* local routines */</comment>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>mdunlinkfork</name><parameter_list>(<parameter><decl><type><name>RelFileNodeBackend</name></type> <name>rnode</name></decl></parameter>, <parameter><decl><type><name>ForkNumber</name></type> <name>forkNum</name></decl></parameter>,
			 <parameter><decl><type><name>bool</name></type> <name>isRedo</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>MdfdVec</name> <modifier>*</modifier></type><name>mdopen</name><parameter_list>(<parameter><decl><type><name>SMgrRelation</name></type> <name>reln</name></decl></parameter>, <parameter><decl><type><name>ForkNumber</name></type> <name>forknum</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>behavior</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>register_dirty_segment</name><parameter_list>(<parameter><decl><type><name>SMgrRelation</name></type> <name>reln</name></decl></parameter>, <parameter><decl><type><name>ForkNumber</name></type> <name>forknum</name></decl></parameter>,
					   <parameter><decl><type><name>MdfdVec</name> <modifier>*</modifier></type><name>seg</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>register_unlink</name><parameter_list>(<parameter><decl><type><name>RelFileNodeBackend</name></type> <name>rnode</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>_fdvec_resize</name><parameter_list>(<parameter><decl><type><name>SMgrRelation</name></type> <name>reln</name></decl></parameter>,
			  <parameter><decl><type><name>ForkNumber</name></type> <name>forknum</name></decl></parameter>,
			  <parameter><decl><type><name>int</name></type> <name>nseg</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>_mdfd_segpath</name><parameter_list>(<parameter><decl><type><name>SMgrRelation</name></type> <name>reln</name></decl></parameter>, <parameter><decl><type><name>ForkNumber</name></type> <name>forknum</name></decl></parameter>,
			  <parameter><decl><type><name>BlockNumber</name></type> <name>segno</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>MdfdVec</name> <modifier>*</modifier></type><name>_mdfd_openseg</name><parameter_list>(<parameter><decl><type><name>SMgrRelation</name></type> <name>reln</name></decl></parameter>, <parameter><decl><type><name>ForkNumber</name></type> <name>forkno</name></decl></parameter>,
			  <parameter><decl><type><name>BlockNumber</name></type> <name>segno</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>oflags</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>MdfdVec</name> <modifier>*</modifier></type><name>_mdfd_getseg</name><parameter_list>(<parameter><decl><type><name>SMgrRelation</name></type> <name>reln</name></decl></parameter>, <parameter><decl><type><name>ForkNumber</name></type> <name>forkno</name></decl></parameter>,
			 <parameter><decl><type><name>BlockNumber</name></type> <name>blkno</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>skipFsync</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>behavior</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>BlockNumber</name></type> <name>_mdnblocks</name><parameter_list>(<parameter><decl><type><name>SMgrRelation</name></type> <name>reln</name></decl></parameter>, <parameter><decl><type><name>ForkNumber</name></type> <name>forknum</name></decl></parameter>,
		   <parameter><decl><type><name>MdfdVec</name> <modifier>*</modifier></type><name>seg</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>BlockNumber</name></type> <name>polar_cache_mdnblocks</name><parameter_list>(<parameter><decl><type><name>SMgrRelation</name></type> <name>reln</name></decl></parameter>, <parameter><decl><type><name>ForkNumber</name></type> <name>forknum</name></decl></parameter>, <parameter><decl><type><name>MdfdVec</name> <modifier>*</modifier></type><name>seg</name></decl></parameter>)</parameter_list>;</function_decl>


<comment type="block">/*
 *	mdinit() -- Initialize private state for magnetic disk storage manager.
 */</comment>
<function><type><name>void</name></type>
<name>mdinit</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><name>MdCxt</name> <operator>=</operator> <call><name>AllocSetContextCreate</name><argument_list>(<argument><expr><name>TopMemoryContext</name></expr></argument>,
								  <argument><expr><literal type="string">"MdSmgr"</literal></expr></argument>,
								  <argument><expr><name>ALLOCSET_DEFAULT_SIZES</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Create pending-operations hashtable if we need it.  Currently, we need
	 * it if we are standalone (not under a postmaster) or if we are a startup
	 * or checkpointer auxiliary process.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>IsUnderPostmaster</name> <operator>||</operator> <call><name>AmStartupProcess</name><argument_list>()</argument_list></call> <operator>||</operator> <call><name>AmCheckpointerProcess</name><argument_list>()</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>HASHCTL</name></type>		<name>hash_ctl</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * XXX: The checkpointer needs to add entries to the pending ops table
		 * when absorbing fsync requests.  That is done within a critical
		 * section, which isn't usually allowed, but we make an exception. It
		 * means that there's a theoretical possibility that you run out of
		 * memory while absorbing fsync requests, which leads to a PANIC.
		 * Fortunately the hash table is small so that's unlikely to happen in
		 * practice.
		 */</comment>
		<expr_stmt><expr><name>pendingOpsCxt</name> <operator>=</operator> <call><name>AllocSetContextCreate</name><argument_list>(<argument><expr><name>MdCxt</name></expr></argument>,
											  <argument><expr><literal type="string">"Pending ops context"</literal></expr></argument>,
											  <argument><expr><name>ALLOCSET_DEFAULT_SIZES</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>MemoryContextAllowInCriticalSection</name><argument_list>(<argument><expr><name>pendingOpsCxt</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><operator>&amp;</operator><name>hash_ctl</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>hash_ctl</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>hash_ctl</name><operator>.</operator><name>keysize</name></name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>RelFileNode</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>hash_ctl</name><operator>.</operator><name>entrysize</name></name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>PendingOperationEntry</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>hash_ctl</name><operator>.</operator><name>hcxt</name></name> <operator>=</operator> <name>pendingOpsCxt</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>pendingOpsTable</name> <operator>=</operator> <call><name>hash_create</name><argument_list>(<argument><expr><literal type="string">"Pending Ops Table"</literal></expr></argument>,
									  <argument><expr><literal type="number">100L</literal></expr></argument>,
									  <argument><expr><operator>&amp;</operator><name>hash_ctl</name></expr></argument>,
									  <argument><expr><name>HASH_ELEM</name> <operator>|</operator> <name>HASH_BLOBS</name> <operator>|</operator> <name>HASH_CONTEXT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>pendingUnlinks</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>polar_env_init</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * In archive recovery, we rely on checkpointer to do fsyncs, but we will have
 * already created the pendingOpsTable during initialization of the startup
 * process.  Calling this function drops the local pendingOpsTable so that
 * subsequent requests will be forwarded to checkpointer.
 */</comment>
<function><type><name>void</name></type>
<name>SetForwardFsyncRequests</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* Perform any pending fsyncs we may have queued up, then drop table */</comment>
	<if_stmt><if>if <condition>(<expr><name>pendingOpsTable</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>mdsync</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>hash_destroy</name><argument_list>(<argument><expr><name>pendingOpsTable</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name>pendingOpsTable</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * We should not have any pending unlink requests, since mdunlink doesn't
	 * queue unlink requests when isRedo.
	 */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>pendingUnlinks</name> <operator>==</operator> <name>NIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 *	mdexists() -- Does the physical file exist?
 *
 * Note: this will return true for lingering files, with pending deletions
 */</comment>
<function><type><name>bool</name></type>
<name>mdexists</name><parameter_list>(<parameter><decl><type><name>SMgrRelation</name></type> <name>reln</name></decl></parameter>, <parameter><decl><type><name>ForkNumber</name></type> <name>forkNum</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * Close it first, to ensure that we notice if the fork has been unlinked
	 * since we opened it.
	 */</comment>
	<expr_stmt><expr><call><name>mdclose</name><argument_list>(<argument><expr><name>reln</name></expr></argument>, <argument><expr><name>forkNum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><operator>(</operator><call><name>mdopen</name><argument_list>(<argument><expr><name>reln</name></expr></argument>, <argument><expr><name>forkNum</name></expr></argument>, <argument><expr><name>EXTENSION_RETURN_NULL</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 *	mdcreate() -- Create a new relation on magnetic disk.
 *
 * If isRedo is true, it's okay for the relation to exist already.
 */</comment>
<function><type><name>void</name></type>
<name>mdcreate</name><parameter_list>(<parameter><decl><type><name>SMgrRelation</name></type> <name>reln</name></decl></parameter>, <parameter><decl><type><name>ForkNumber</name></type> <name>forkNum</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>isRedo</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>MdfdVec</name>    <modifier>*</modifier></type><name>mdfd</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>path</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>File</name></type>		<name>fd</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>isRedo</name> <operator>&amp;&amp;</operator> <name><name>reln</name><operator>-&gt;</operator><name>md_num_open_segs</name><index>[<expr><name>forkNum</name></expr>]</index></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>					<comment type="block">/* created and opened already... */</comment>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>reln</name><operator>-&gt;</operator><name>md_num_open_segs</name><index>[<expr><name>forkNum</name></expr>]</index></name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>path</name> <operator>=</operator> <call><name>relpath</name><argument_list>(<argument><expr><name><name>reln</name><operator>-&gt;</operator><name>smgr_rnode</name></name></expr></argument>, <argument><expr><name>forkNum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>fd</name> <operator>=</operator> <call><name>polar_path_name_open_file</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>O_RDWR</name> <operator>|</operator> <name>O_CREAT</name> <operator>|</operator> <name>O_EXCL</name> <operator>|</operator> <name>PG_BINARY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>fd</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>save_errno</name> <init>= <expr><name>errno</name></expr></init></decl>;</decl_stmt>

		<comment type="block">/*
		 * During bootstrap, there are cases where a system relation will be
		 * accessed (by internal backend processes) before the bootstrap
		 * script nominally creates it.  Therefore, allow the file to exist
		 * already, even if isRedo is not set.  (See also mdopen)
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>isRedo</name> <operator>||</operator> <call><name>IsBootstrapProcessingMode</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>fd</name> <operator>=</operator> <call><name>polar_path_name_open_file</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>O_RDWR</name> <operator>|</operator> <name>PG_BINARY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name>fd</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* be sure to report the error reported by create, not open */</comment>
			<expr_stmt><expr><name>errno</name> <operator>=</operator> <name>save_errno</name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not create file \"%s\": %m"</literal></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>_fdvec_resize</name><argument_list>(<argument><expr><name>reln</name></expr></argument>, <argument><expr><name>forkNum</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>mdfd</name> <operator>=</operator> <operator>&amp;</operator><name><name>reln</name><operator>-&gt;</operator><name>md_seg_fds</name><index>[<expr><name>forkNum</name></expr>]</index><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>mdfd</name><operator>-&gt;</operator><name>mdfd_vfd</name></name> <operator>=</operator> <name>fd</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>mdfd</name><operator>-&gt;</operator><name>mdfd_segno</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 *	mdunlink() -- Unlink a relation.
 *
 * Note that we're passed a RelFileNodeBackend --- by the time this is called,
 * there won't be an SMgrRelation hashtable entry anymore.
 *
 * forkNum can be a fork number to delete a specific fork, or InvalidForkNumber
 * to delete all forks.
 *
 * For regular relations, we don't unlink the first segment file of the rel,
 * but just truncate it to zero length, and record a request to unlink it after
 * the next checkpoint.  Additional segments can be unlinked immediately,
 * however.  Leaving the empty file in place prevents that relfilenode
 * number from being reused.  The scenario this protects us from is:
 * 1. We delete a relation (and commit, and actually remove its file).
 * 2. We create a new relation, which by chance gets the same relfilenode as
 *	  the just-deleted one (OIDs must've wrapped around for that to happen).
 * 3. We crash before another checkpoint occurs.
 * During replay, we would delete the file and then recreate it, which is fine
 * if the contents of the file were repopulated by subsequent WAL entries.
 * But if we didn't WAL-log insertions, but instead relied on fsyncing the
 * file after populating it (as for instance CLUSTER and CREATE INDEX do),
 * the contents of the file would be lost forever.  By leaving the empty file
 * until after the next checkpoint, we prevent reassignment of the relfilenode
 * number until it's safe, because relfilenode assignment skips over any
 * existing file.
 *
 * We do not need to go through this dance for temp relations, though, because
 * we never make WAL entries for temp rels, and so a temp rel poses no threat
 * to the health of a regular rel that has taken over its relfilenode number.
 * The fact that temp rels and regular rels have different file naming
 * patterns provides additional safety.
 *
 * All the above applies only to the relation's main fork; other forks can
 * just be removed immediately, since they are not needed to prevent the
 * relfilenode number from being recycled.  Also, we do not carefully
 * track whether other forks have been created or not, but just attempt to
 * unlink them unconditionally; so we should never complain about ENOENT.
 *
 * If isRedo is true, it's unsurprising for the relation to be already gone.
 * Also, we should remove the file immediately instead of queuing a request
 * for later, since during redo there's no possibility of creating a
 * conflicting relation.
 *
 * Note: any failure should be reported as WARNING not ERROR, because
 * we are usually not in a transaction anymore when this is called.
 */</comment>
<function><type><name>void</name></type>
<name>mdunlink</name><parameter_list>(<parameter><decl><type><name>RelFileNodeBackend</name></type> <name>rnode</name></decl></parameter>, <parameter><decl><type><name>ForkNumber</name></type> <name>forkNum</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>isRedo</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * We have to clean out any pending fsync requests for the doomed
	 * relation, else the next mdsync() will fail.  There can't be any such
	 * requests for a temp relation, though.  We can send just one request
	 * even when deleting multiple forks, since the fsync queuing code accepts
	 * the "InvalidForkNumber = all forks" convention.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>RelFileNodeBackendIsTemp</name><argument_list>(<argument><expr><name>rnode</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ForgetRelationFsyncRequests</name><argument_list>(<argument><expr><name><name>rnode</name><operator>.</operator><name>node</name></name></expr></argument>, <argument><expr><name>forkNum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Now do the per-fork work */</comment>
	<if_stmt><if>if <condition>(<expr><name>forkNum</name> <operator>==</operator> <name>InvalidForkNumber</name></expr>)</condition>
	<block>{<block_content>
		<for>for <control>(<init><expr><name>forkNum</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>forkNum</name> <operator>&lt;=</operator> <name>MAX_FORKNUM</name></expr>;</condition> <incr><expr><name>forkNum</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>mdunlinkfork</name><argument_list>(<argument><expr><name>rnode</name></expr></argument>, <argument><expr><name>forkNum</name></expr></argument>, <argument><expr><name>isRedo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>mdunlinkfork</name><argument_list>(<argument><expr><name>rnode</name></expr></argument>, <argument><expr><name>forkNum</name></expr></argument>, <argument><expr><name>isRedo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>mdunlinkfork</name><parameter_list>(<parameter><decl><type><name>RelFileNodeBackend</name></type> <name>rnode</name></decl></parameter>, <parameter><decl><type><name>ForkNumber</name></type> <name>forkNum</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>isRedo</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>path</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>ret</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>path</name> <operator>=</operator> <call><name>relpath</name><argument_list>(<argument><expr><name>rnode</name></expr></argument>, <argument><expr><name>forkNum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Delete or truncate the first segment.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>isRedo</name> <operator>||</operator> <name>forkNum</name> <operator>!=</operator> <name>MAIN_FORKNUM</name> <operator>||</operator> <call><name>RelFileNodeBackendIsTemp</name><argument_list>(<argument><expr><name>rnode</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>polar_unlink</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>errno</name> <operator>!=</operator> <name>ENOENT</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not remove file \"%s\": %m"</literal></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* truncate(2) would be easier here, but Windows hasn't got it */</comment>
		<decl_stmt><decl><type><name>int</name></type>			<name>fd</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>fd</name> <operator>=</operator> <call><name>polar_open_transient_file</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>O_RDWR</name> <operator>|</operator> <name>PG_BINARY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>fd</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>int</name></type>			<name>save_errno</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>polar_ftruncate</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>save_errno</name> <operator>=</operator> <name>errno</name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>CloseTransientFile</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>errno</name> <operator>=</operator> <name>save_errno</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>ret</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>
		<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>errno</name> <operator>!=</operator> <name>ENOENT</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not truncate file \"%s\": %m"</literal></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/* Register request to unlink first segment later */</comment>
		<expr_stmt><expr><call><name>register_unlink</name><argument_list>(<argument><expr><name>rnode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/*
	 * Delete any additional segments.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>segpath</name> <init>= <expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">12</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>BlockNumber</name></type> <name>segno</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * Note that because we loop until getting ENOENT, we will correctly
		 * remove all inactive segments as well as active ones.
		 */</comment>
		<for>for <control>(<init><expr><name>segno</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init><condition>;</condition> <incr><expr><name>segno</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>segpath</name></expr></argument>, <argument><expr><literal type="string">"%s.%u"</literal></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>segno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><call><name>polar_unlink</name><argument_list>(<argument><expr><name>segpath</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* ENOENT is expected after the last segment... */</comment>
				<if_stmt><if>if <condition>(<expr><name>errno</name> <operator>!=</operator> <name>ENOENT</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not remove file \"%s\": %m"</literal></expr></argument>, <argument><expr><name>segpath</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<break>break;</break>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></for>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>segpath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 *	mdextend() -- Add a block to the specified relation.
 *
 *		The semantics are nearly the same as mdwrite(): write at the
 *		specified position.  However, this is to be used for the case of
 *		extending a relation (i.e., blocknum is at or beyond the current
 *		EOF).  Note that we assume writing a block beyond current EOF
 *		causes intervening file space to become filled with zeroes.
 */</comment>
<function><type><name>void</name></type>
<name>mdextend</name><parameter_list>(<parameter><decl><type><name>SMgrRelation</name></type> <name>reln</name></decl></parameter>, <parameter><decl><type><name>ForkNumber</name></type> <name>forknum</name></decl></parameter>, <parameter><decl><type><name>BlockNumber</name></type> <name>blocknum</name></decl></parameter>,
		 <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>buffer</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>skipFsync</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>off_t</name></type>		<name>seekpos</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>nbytes</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MdfdVec</name>    <modifier>*</modifier></type><name>v</name></decl>;</decl_stmt>

	<comment type="block">/* POLAR: bulk extend */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>polar_smgr_being_bulk_extend</name><argument_list>(<argument><expr><name>reln</name></expr></argument>, <argument><expr><name>forknum</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>true</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>reln</name><operator>-&gt;</operator><name>polar_nblocks_faked_for_bulk_extend</name><index>[<expr><name>forknum</name></expr>]</index></name> <operator>==</operator> <name>blocknum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><operator>++</operator><name><name>reln</name><operator>-&gt;</operator><name>polar_nblocks_faked_for_bulk_extend</name><index>[<expr><name>forknum</name></expr>]</index></name></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* POLAR end */</comment>

	<comment type="block">/* This assert is too expensive to have on normally ... */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>CHECK_WRITE_VS_EXTEND</name></cpp:ifdef>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>blocknum</name> <operator>&gt;=</operator> <call><name>mdnblocks</name><argument_list>(<argument><expr><name>reln</name></expr></argument>, <argument><expr><name>forknum</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<comment type="block">/*
	 * If a relation manages to grow to 2^32-1 blocks, refuse to extend it any
	 * more --- we mustn't create a block whose number actually is
	 * InvalidBlockNumber.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>blocknum</name> <operator>==</operator> <name>InvalidBlockNumber</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_PROGRAM_LIMIT_EXCEEDED</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot extend file \"%s\" beyond %u blocks"</literal></expr></argument>,
						<argument><expr><call><name>relpath</name><argument_list>(<argument><expr><name><name>reln</name><operator>-&gt;</operator><name>smgr_rnode</name></name></expr></argument>, <argument><expr><name>forknum</name></expr></argument>)</argument_list></call></expr></argument>,
						<argument><expr><name>InvalidBlockNumber</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>v</name> <operator>=</operator> <call><name>_mdfd_getseg</name><argument_list>(<argument><expr><name>reln</name></expr></argument>, <argument><expr><name>forknum</name></expr></argument>, <argument><expr><name>blocknum</name></expr></argument>, <argument><expr><name>skipFsync</name></expr></argument>, <argument><expr><name>EXTENSION_CREATE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>seekpos</name> <operator>=</operator> <operator>(</operator><name>off_t</name><operator>)</operator> <name>BLCKSZ</name> <operator>*</operator> <operator>(</operator><name>blocknum</name> <operator>%</operator> <operator>(</operator><operator>(</operator><name>BlockNumber</name><operator>)</operator> <name>RELSEG_SIZE</name><operator>)</operator><operator>)</operator></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>seekpos</name> <operator>&lt;</operator> <operator>(</operator><name>off_t</name><operator>)</operator> <name>BLCKSZ</name> <operator>*</operator> <name>RELSEG_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* POLAR: use pwrite to replace lseek + write */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>POLAR_ENABLE_PWRITE</name><argument_list>()</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>nbytes</name> <operator>=</operator> <call><name>polar_file_pwrite</name><argument_list>(<argument><expr><name><name>v</name><operator>-&gt;</operator><name>mdfd_vfd</name></name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>BLCKSZ</name></expr></argument>, <argument><expr><name>seekpos</name></expr></argument>,
				<argument><expr><name>WAIT_EVENT_DATA_FILE_PWRITE_EXTEND</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/*
		 * Note: because caller usually obtained blocknum by calling mdnblocks,
		 * which did a seek(SEEK_END), this seek is often redundant and will be
		 * optimized away by fd.c.  It's not redundant, however, if there is a
		 * partial page at the end of the file. In that case we want to try to
		 * overwrite the partial page with a full page.  It's also not redundant
		 * if bufmgr.c had to dump another buffer of the same file to make room
		 * for the new page's buffer.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>FileSeek</name><argument_list>(<argument><expr><name><name>v</name><operator>-&gt;</operator><name>mdfd_vfd</name></name></expr></argument>, <argument><expr><name>seekpos</name></expr></argument>, <argument><expr><name>SEEK_SET</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>seekpos</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not seek to block %u in file \"%s\": %m"</literal></expr></argument>,
							<argument><expr><name>blocknum</name></expr></argument>, <argument><expr><call><name>FilePathName</name><argument_list>(<argument><expr><name><name>v</name><operator>-&gt;</operator><name>mdfd_vfd</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>nbytes</name> <operator>=</operator> <call><name>FileWrite</name><argument_list>(<argument><expr><name><name>v</name><operator>-&gt;</operator><name>mdfd_vfd</name></name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>BLCKSZ</name></expr></argument>, <argument><expr><name>WAIT_EVENT_DATA_FILE_EXTEND</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>nbytes</name> <operator>!=</operator> <name>BLCKSZ</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>nbytes</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not extend file \"%s\": %m"</literal></expr></argument>,
							<argument><expr><call><name>FilePathName</name><argument_list>(<argument><expr><name><name>v</name><operator>-&gt;</operator><name>mdfd_vfd</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Check free disk space."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<comment type="block">/* short write: complain appropriately */</comment>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DISK_FULL</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not extend file \"%s\": wrote only %d of %d bytes at block %u"</literal></expr></argument>,
						<argument><expr><call><name>FilePathName</name><argument_list>(<argument><expr><name><name>v</name><operator>-&gt;</operator><name>mdfd_vfd</name></name></expr></argument>)</argument_list></call></expr></argument>,
						<argument><expr><name>nbytes</name></expr></argument>, <argument><expr><name>BLCKSZ</name></expr></argument>, <argument><expr><name>blocknum</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Check free disk space."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>skipFsync</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>SmgrIsTemp</name><argument_list>(<argument><expr><name>reln</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>register_dirty_segment</name><argument_list>(<argument><expr><name>reln</name></expr></argument>, <argument><expr><name>forknum</name></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>_mdnblocks</name><argument_list>(<argument><expr><name>reln</name></expr></argument>, <argument><expr><name>forknum</name></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call> <operator>&lt;=</operator> <operator>(</operator><operator>(</operator><name>BlockNumber</name><operator>)</operator> <name>RELSEG_SIZE</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 *	mdopen() -- Open the specified relation.
 *
 * Note we only open the first segment, when there are multiple segments.
 *
 * If first segment is not present, either ereport or return NULL according
 * to "behavior".  We treat EXTENSION_CREATE the same as EXTENSION_FAIL;
 * EXTENSION_CREATE means it's OK to extend an existing relation, not to
 * invent one out of whole cloth.
 */</comment>
<function><type><specifier>static</specifier> <name>MdfdVec</name> <modifier>*</modifier></type>
<name>mdopen</name><parameter_list>(<parameter><decl><type><name>SMgrRelation</name></type> <name>reln</name></decl></parameter>, <parameter><decl><type><name>ForkNumber</name></type> <name>forknum</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>behavior</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>MdfdVec</name>    <modifier>*</modifier></type><name>mdfd</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>path</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>File</name></type>		<name>fd</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>flags</name> <init>= <expr><name>PG_BINARY</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* POLAR: read datafile only need O_RDONLY flag in replica */</comment>
	<if_stmt><if>if <condition>(<expr><name>polar_openfile_with_readonly_in_replica</name> <operator>&amp;&amp;</operator>
		<call><name>polar_in_replica_mode</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>flags</name> <operator>|=</operator> <name>O_RDONLY</name></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>flags</name> <operator>|=</operator> <name>O_RDWR</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/* No work if already open */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>reln</name><operator>-&gt;</operator><name>md_num_open_segs</name><index>[<expr><name>forknum</name></expr>]</index></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><operator>&amp;</operator><name><name>reln</name><operator>-&gt;</operator><name>md_seg_fds</name><index>[<expr><name>forknum</name></expr>]</index><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>path</name> <operator>=</operator> <call><name>relpath</name><argument_list>(<argument><expr><name><name>reln</name><operator>-&gt;</operator><name>smgr_rnode</name></name></expr></argument>, <argument><expr><name>forknum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>fd</name> <operator>=</operator> <call><name>polar_path_name_open_file</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>fd</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * During bootstrap, there are cases where a system relation will be
		 * accessed (by internal backend processes) before the bootstrap
		 * script nominally creates it.  Therefore, accept mdopen() as a
		 * substitute for mdcreate() in bootstrap mode only. (See mdcreate)
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>IsBootstrapProcessingMode</name><argument_list>()</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>polar_in_replica_mode</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>fd</name> <operator>=</operator> <call><name>polar_path_name_open_file</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>O_RDWR</name> <operator>|</operator> <name>O_CREAT</name> <operator>|</operator> <name>O_EXCL</name> <operator>|</operator> <name>PG_BINARY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name>fd</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><operator>(</operator><name>behavior</name> <operator>&amp;</operator> <name>EXTENSION_RETURN_NULL</name><operator>)</operator> <operator>&amp;&amp;</operator>
				<call><name>FILE_POSSIBLY_DELETED</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr><name>NULL</name></expr>;</return>
			</block_content>}</block></if></if_stmt>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not open file \"%s\": %m"</literal></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>_fdvec_resize</name><argument_list>(<argument><expr><name>reln</name></expr></argument>, <argument><expr><name>forknum</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>mdfd</name> <operator>=</operator> <operator>&amp;</operator><name><name>reln</name><operator>-&gt;</operator><name>md_seg_fds</name><index>[<expr><name>forknum</name></expr>]</index><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>mdfd</name><operator>-&gt;</operator><name>mdfd_vfd</name></name> <operator>=</operator> <name>fd</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>mdfd</name><operator>-&gt;</operator><name>mdfd_segno</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>_mdnblocks</name><argument_list>(<argument><expr><name>reln</name></expr></argument>, <argument><expr><name>forknum</name></expr></argument>, <argument><expr><name>mdfd</name></expr></argument>)</argument_list></call> <operator>&lt;=</operator> <operator>(</operator><operator>(</operator><name>BlockNumber</name><operator>)</operator> <name>RELSEG_SIZE</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>mdfd</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 *	mdclose() -- Close the specified relation, if it isn't closed already.
 */</comment>
<function><type><name>void</name></type>
<name>mdclose</name><parameter_list>(<parameter><decl><type><name>SMgrRelation</name></type> <name>reln</name></decl></parameter>, <parameter><decl><type><name>ForkNumber</name></type> <name>forknum</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>nopensegs</name> <init>= <expr><name><name>reln</name><operator>-&gt;</operator><name>md_num_open_segs</name><index>[<expr><name>forknum</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* No work if already closed */</comment>
	<if_stmt><if>if <condition>(<expr><name>nopensegs</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/* close segments starting from the end */</comment>
	<while>while <condition>(<expr><name>nopensegs</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>MdfdVec</name>    <modifier>*</modifier></type><name>v</name> <init>= <expr><operator>&amp;</operator><name><name>reln</name><operator>-&gt;</operator><name>md_seg_fds</name><index>[<expr><name>forknum</name></expr>]</index><index>[<expr><name>nopensegs</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>FileClose</name><argument_list>(<argument><expr><name><name>v</name><operator>-&gt;</operator><name>mdfd_vfd</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>_fdvec_resize</name><argument_list>(<argument><expr><name>reln</name></expr></argument>, <argument><expr><name>forknum</name></expr></argument>, <argument><expr><name>nopensegs</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>nopensegs</name><operator>--</operator></expr>;</expr_stmt>
	</block_content>}</block></while>
</block_content>}</block></function>

<comment type="block">/*
 *	mdprefetch() -- Initiate asynchronous read of the specified block of a relation
 */</comment>
<function><type><name>void</name></type>
<name>mdprefetch</name><parameter_list>(<parameter><decl><type><name>SMgrRelation</name></type> <name>reln</name></decl></parameter>, <parameter><decl><type><name>ForkNumber</name></type> <name>forknum</name></decl></parameter>, <parameter><decl><type><name>BlockNumber</name></type> <name>blocknum</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_PREFETCH</name></cpp:ifdef>
	<decl_stmt><decl><type><name>off_t</name></type>		<name>seekpos</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MdfdVec</name>    <modifier>*</modifier></type><name>v</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>v</name> <operator>=</operator> <call><name>_mdfd_getseg</name><argument_list>(<argument><expr><name>reln</name></expr></argument>, <argument><expr><name>forknum</name></expr></argument>, <argument><expr><name>blocknum</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>EXTENSION_FAIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>seekpos</name> <operator>=</operator> <operator>(</operator><name>off_t</name><operator>)</operator> <name>BLCKSZ</name> <operator>*</operator> <operator>(</operator><name>blocknum</name> <operator>%</operator> <operator>(</operator><operator>(</operator><name>BlockNumber</name><operator>)</operator> <name>RELSEG_SIZE</name><operator>)</operator><operator>)</operator></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>seekpos</name> <operator>&lt;</operator> <operator>(</operator><name>off_t</name><operator>)</operator> <name>BLCKSZ</name> <operator>*</operator> <name>RELSEG_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>FilePrefetch</name><argument_list>(<argument><expr><name><name>v</name><operator>-&gt;</operator><name>mdfd_vfd</name></name></expr></argument>, <argument><expr><name>seekpos</name></expr></argument>, <argument><expr><name>BLCKSZ</name></expr></argument>, <argument><expr><name>WAIT_EVENT_DATA_FILE_PREFETCH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>							<comment type="block">/* USE_PREFETCH */</comment>
</block_content>}</block></function>

<comment type="block">/*
 * mdwriteback() -- Tell the kernel to write pages back to storage.
 *
 * This accepts a range of blocks because flushing several pages at once is
 * considerably more efficient than doing so individually.
 */</comment>
<function><type><name>void</name></type>
<name>mdwriteback</name><parameter_list>(<parameter><decl><type><name>SMgrRelation</name></type> <name>reln</name></decl></parameter>, <parameter><decl><type><name>ForkNumber</name></type> <name>forknum</name></decl></parameter>,
			<parameter><decl><type><name>BlockNumber</name></type> <name>blocknum</name></decl></parameter>, <parameter><decl><type><name>BlockNumber</name></type> <name>nblocks</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * Issue flush requests in as few requests as possible; have to split at
	 * segment boundaries though, since those are actually separate files.
	 */</comment>
	<while>while <condition>(<expr><name>nblocks</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>BlockNumber</name></type> <name>nflush</name> <init>= <expr><name>nblocks</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>off_t</name></type>		<name>seekpos</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>MdfdVec</name>    <modifier>*</modifier></type><name>v</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>segnum_start</name></decl>,
					<decl><type ref="prev"/><name>segnum_end</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>v</name> <operator>=</operator> <call><name>_mdfd_getseg</name><argument_list>(<argument><expr><name>reln</name></expr></argument>, <argument><expr><name>forknum</name></expr></argument>, <argument><expr><name>blocknum</name></expr></argument>, <argument><expr><name>true</name></expr></argument> <comment type="block">/* not used */</comment> ,
						 <argument><expr><name>EXTENSION_RETURN_NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * We might be flushing buffers of already removed relations, that's
		 * ok, just ignore that case.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>v</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return;</return></block_content></block></if></if_stmt>

		<comment type="block">/* compute offset inside the current segment */</comment>
		<expr_stmt><expr><name>segnum_start</name> <operator>=</operator> <name>blocknum</name> <operator>/</operator> <name>RELSEG_SIZE</name></expr>;</expr_stmt>

		<comment type="block">/* compute number of desired writes within the current segment */</comment>
		<expr_stmt><expr><name>segnum_end</name> <operator>=</operator> <operator>(</operator><name>blocknum</name> <operator>+</operator> <name>nblocks</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator> <operator>/</operator> <name>RELSEG_SIZE</name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>segnum_start</name> <operator>!=</operator> <name>segnum_end</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>nflush</name> <operator>=</operator> <name>RELSEG_SIZE</name> <operator>-</operator> <operator>(</operator><name>blocknum</name> <operator>%</operator> <operator>(</operator><operator>(</operator><name>BlockNumber</name><operator>)</operator> <name>RELSEG_SIZE</name><operator>)</operator><operator>)</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>nflush</name> <operator>&gt;=</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>nflush</name> <operator>&lt;=</operator> <name>nblocks</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>seekpos</name> <operator>=</operator> <operator>(</operator><name>off_t</name><operator>)</operator> <name>BLCKSZ</name> <operator>*</operator> <operator>(</operator><name>blocknum</name> <operator>%</operator> <operator>(</operator><operator>(</operator><name>BlockNumber</name><operator>)</operator> <name>RELSEG_SIZE</name><operator>)</operator><operator>)</operator></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>FileWriteback</name><argument_list>(<argument><expr><name><name>v</name><operator>-&gt;</operator><name>mdfd_vfd</name></name></expr></argument>, <argument><expr><name>seekpos</name></expr></argument>, <argument><expr><operator>(</operator><name>off_t</name><operator>)</operator> <name>BLCKSZ</name> <operator>*</operator> <name>nflush</name></expr></argument>, <argument><expr><name>WAIT_EVENT_DATA_FILE_FLUSH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>nblocks</name> <operator>-=</operator> <name>nflush</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>blocknum</name> <operator>+=</operator> <name>nflush</name></expr>;</expr_stmt>
	</block_content>}</block></while>
</block_content>}</block></function>

<comment type="block">/*
 *	mdread() -- Read the specified block from a relation.
 */</comment>
<function><type><name>void</name></type>
<name>mdread</name><parameter_list>(<parameter><decl><type><name>SMgrRelation</name></type> <name>reln</name></decl></parameter>, <parameter><decl><type><name>ForkNumber</name></type> <name>forknum</name></decl></parameter>, <parameter><decl><type><name>BlockNumber</name></type> <name>blocknum</name></decl></parameter>,
	   <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>buffer</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>off_t</name></type>		<name>seekpos</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>nbytes</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MdfdVec</name>    <modifier>*</modifier></type><name>v</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>TRACE_POSTGRESQL_SMGR_MD_READ_START</name><argument_list>(<argument><expr><name>forknum</name></expr></argument>, <argument><expr><name>blocknum</name></expr></argument>,
										<argument><expr><name><name>reln</name><operator>-&gt;</operator><name>smgr_rnode</name><operator>.</operator><name>node</name><operator>.</operator><name>spcNode</name></name></expr></argument>,
										<argument><expr><name><name>reln</name><operator>-&gt;</operator><name>smgr_rnode</name><operator>.</operator><name>node</name><operator>.</operator><name>dbNode</name></name></expr></argument>,
										<argument><expr><name><name>reln</name><operator>-&gt;</operator><name>smgr_rnode</name><operator>.</operator><name>node</name><operator>.</operator><name>relNode</name></name></expr></argument>,
										<argument><expr><name><name>reln</name><operator>-&gt;</operator><name>smgr_rnode</name><operator>.</operator><name>backend</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>v</name> <operator>=</operator> <call><name>_mdfd_getseg</name><argument_list>(<argument><expr><name>reln</name></expr></argument>, <argument><expr><name>forknum</name></expr></argument>, <argument><expr><name>blocknum</name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
					 <argument><expr><name>EXTENSION_FAIL</name> <operator>|</operator> <name>EXTENSION_CREATE_RECOVERY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>seekpos</name> <operator>=</operator> <operator>(</operator><name>off_t</name><operator>)</operator> <name>BLCKSZ</name> <operator>*</operator> <operator>(</operator><name>blocknum</name> <operator>%</operator> <operator>(</operator><operator>(</operator><name>BlockNumber</name><operator>)</operator> <name>RELSEG_SIZE</name><operator>)</operator><operator>)</operator></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>seekpos</name> <operator>&lt;</operator> <operator>(</operator><name>off_t</name><operator>)</operator> <name>BLCKSZ</name> <operator>*</operator> <name>RELSEG_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>POLAR_ENABLE_PREAD</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>nbytes</name> <operator>=</operator> <call><name>polar_file_pread</name><argument_list>(<argument><expr><name><name>v</name><operator>-&gt;</operator><name>mdfd_vfd</name></name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>BLCKSZ</name></expr></argument>, <argument><expr><name>seekpos</name></expr></argument>, <argument><expr><name>WAIT_EVENT_DATA_FILE_PREAD</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>FileSeek</name><argument_list>(<argument><expr><name><name>v</name><operator>-&gt;</operator><name>mdfd_vfd</name></name></expr></argument>, <argument><expr><name>seekpos</name></expr></argument>, <argument><expr><name>SEEK_SET</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>seekpos</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not seek to block %u in file \"%s\": %m"</literal></expr></argument>,
							<argument><expr><name>blocknum</name></expr></argument>, <argument><expr><call><name>FilePathName</name><argument_list>(<argument><expr><name><name>v</name><operator>-&gt;</operator><name>mdfd_vfd</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>nbytes</name> <operator>=</operator> <call><name>FileRead</name><argument_list>(<argument><expr><name><name>v</name><operator>-&gt;</operator><name>mdfd_vfd</name></name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>BLCKSZ</name></expr></argument>, <argument><expr><name>WAIT_EVENT_DATA_FILE_READ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><call><name>TRACE_POSTGRESQL_SMGR_MD_READ_DONE</name><argument_list>(<argument><expr><name>forknum</name></expr></argument>, <argument><expr><name>blocknum</name></expr></argument>,
									   <argument><expr><name><name>reln</name><operator>-&gt;</operator><name>smgr_rnode</name><operator>.</operator><name>node</name><operator>.</operator><name>spcNode</name></name></expr></argument>,
									   <argument><expr><name><name>reln</name><operator>-&gt;</operator><name>smgr_rnode</name><operator>.</operator><name>node</name><operator>.</operator><name>dbNode</name></name></expr></argument>,
									   <argument><expr><name><name>reln</name><operator>-&gt;</operator><name>smgr_rnode</name><operator>.</operator><name>node</name><operator>.</operator><name>relNode</name></name></expr></argument>,
									   <argument><expr><name><name>reln</name><operator>-&gt;</operator><name>smgr_rnode</name><operator>.</operator><name>backend</name></name></expr></argument>,
									   <argument><expr><name>nbytes</name></expr></argument>,
									   <argument><expr><name>BLCKSZ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>nbytes</name> <operator>!=</operator> <name>BLCKSZ</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>nbytes</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not read block %u in file \"%s\": %m"</literal></expr></argument>,
							<argument><expr><name>blocknum</name></expr></argument>, <argument><expr><call><name>FilePathName</name><argument_list>(<argument><expr><name><name>v</name><operator>-&gt;</operator><name>mdfd_vfd</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * Short read: we are at or past EOF, or we read a partial block at
		 * EOF.  Normally this is an error; upper levels should never try to
		 * read a nonexistent block.  However, if zero_damaged_pages is ON or
		 * we are InRecovery, we should instead return zeroes without
		 * complaining.  This allows, for example, the case of trying to
		 * update a block that was later truncated away.
		 */</comment>
		<comment type="block">/*
		 * POLAR: If it's in logindex background process it may replay xlog which block doesn't exist in the storage,
		 * like FPI or init page.So we should to init this buffer to be zero if it doesn't exist.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>zero_damaged_pages</name> <operator>||</operator> <name>InRecovery</name>
				<operator>||</operator> <call><name>POLAR_IN_LOGINDEX_PARALLEL_REPLAY</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>BLCKSZ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATA_CORRUPTED</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not read block %u in file \"%s\": read only %d of %d bytes"</literal></expr></argument>,
							<argument><expr><name>blocknum</name></expr></argument>, <argument><expr><call><name>FilePathName</name><argument_list>(<argument><expr><name><name>v</name><operator>-&gt;</operator><name>mdfd_vfd</name></name></expr></argument>)</argument_list></call></expr></argument>,
							<argument><expr><name>nbytes</name></expr></argument>, <argument><expr><name>BLCKSZ</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 *  POLAR: bulk read
 *
 *	polar_mdbulkread() -- Read the specified continuous blocks from a relation.
 *
 *  Caller must ensure that the blockcount does not exceed the length of the relation file.
 */</comment>
<function><type><name>void</name></type>
<name>polar_mdbulkread</name><parameter_list>(<parameter><decl><type><name>SMgrRelation</name></type> <name>reln</name></decl></parameter>, <parameter><decl><type><name>ForkNumber</name></type> <name>forknum</name></decl></parameter>, <parameter><decl><type><name>BlockNumber</name></type> <name>blocknum</name></decl></parameter>,
				 <parameter><decl><type><name>int</name></type> <name>blockCount</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>buffer</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>off_t</name></type>		<name>seekpos</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>nbytes</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MdfdVec</name>    <modifier>*</modifier></type><name>v</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>         <name>amount</name> <init>= <expr><name>blockCount</name> <operator>*</operator> <name>BLCKSZ</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>TRACE_POSTGRESQL_SMGR_MD_READ_START</name><argument_list>(<argument><expr><name>forknum</name></expr></argument>, <argument><expr><name>blocknum</name></expr></argument>,
										<argument><expr><name><name>reln</name><operator>-&gt;</operator><name>smgr_rnode</name><operator>.</operator><name>node</name><operator>.</operator><name>spcNode</name></name></expr></argument>,
										<argument><expr><name><name>reln</name><operator>-&gt;</operator><name>smgr_rnode</name><operator>.</operator><name>node</name><operator>.</operator><name>dbNode</name></name></expr></argument>,
										<argument><expr><name><name>reln</name><operator>-&gt;</operator><name>smgr_rnode</name><operator>.</operator><name>node</name><operator>.</operator><name>relNode</name></name></expr></argument>,
										<argument><expr><name><name>reln</name><operator>-&gt;</operator><name>smgr_rnode</name><operator>.</operator><name>backend</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>v</name> <operator>=</operator> <call><name>_mdfd_getseg</name><argument_list>(<argument><expr><name>reln</name></expr></argument>, <argument><expr><name>forknum</name></expr></argument>, <argument><expr><name>blocknum</name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
					 <argument><expr><name>EXTENSION_FAIL</name> <operator>|</operator> <name>EXTENSION_CREATE_RECOVERY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>seekpos</name> <operator>=</operator> <operator>(</operator><name>off_t</name><operator>)</operator> <name>BLCKSZ</name> <operator>*</operator> <operator>(</operator><name>blocknum</name> <operator>%</operator> <operator>(</operator><operator>(</operator><name>BlockNumber</name><operator>)</operator> <name>RELSEG_SIZE</name><operator>)</operator><operator>)</operator></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>seekpos</name> <operator>&lt;</operator> <operator>(</operator><name>off_t</name><operator>)</operator> <name>BLCKSZ</name> <operator>*</operator> <name>RELSEG_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>seekpos</name> <operator>+</operator> <operator>(</operator><name>off_t</name><operator>)</operator> <name>amount</name> <operator>&lt;=</operator> <operator>(</operator><name>off_t</name><operator>)</operator> <name>BLCKSZ</name> <operator>*</operator> <name>RELSEG_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>POLAR_ENABLE_PREAD</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>nbytes</name> <operator>=</operator> <call><name>polar_file_pread</name><argument_list>(<argument><expr><name><name>v</name><operator>-&gt;</operator><name>mdfd_vfd</name></name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>amount</name></expr></argument>, <argument><expr><name>seekpos</name></expr></argument>, <argument><expr><name>WAIT_EVENT_DATA_FILE_PREAD</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>FileSeek</name><argument_list>(<argument><expr><name><name>v</name><operator>-&gt;</operator><name>mdfd_vfd</name></name></expr></argument>, <argument><expr><name>seekpos</name></expr></argument>, <argument><expr><name>SEEK_SET</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>seekpos</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not seek to block %u in file \"%s\": %m"</literal></expr></argument>,
							<argument><expr><name>blocknum</name></expr></argument>, <argument><expr><call><name>FilePathName</name><argument_list>(<argument><expr><name><name>v</name><operator>-&gt;</operator><name>mdfd_vfd</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>nbytes</name> <operator>=</operator> <call><name>FileRead</name><argument_list>(<argument><expr><name><name>v</name><operator>-&gt;</operator><name>mdfd_vfd</name></name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>amount</name></expr></argument>, <argument><expr><name>WAIT_EVENT_DATA_FILE_READ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><call><name>TRACE_POSTGRESQL_SMGR_MD_READ_DONE</name><argument_list>(<argument><expr><name>forknum</name></expr></argument>, <argument><expr><name>blocknum</name></expr></argument>,
									   <argument><expr><name><name>reln</name><operator>-&gt;</operator><name>smgr_rnode</name><operator>.</operator><name>node</name><operator>.</operator><name>spcNode</name></name></expr></argument>,
									   <argument><expr><name><name>reln</name><operator>-&gt;</operator><name>smgr_rnode</name><operator>.</operator><name>node</name><operator>.</operator><name>dbNode</name></name></expr></argument>,
									   <argument><expr><name><name>reln</name><operator>-&gt;</operator><name>smgr_rnode</name><operator>.</operator><name>node</name><operator>.</operator><name>relNode</name></name></expr></argument>,
									   <argument><expr><name><name>reln</name><operator>-&gt;</operator><name>smgr_rnode</name><operator>.</operator><name>backend</name></name></expr></argument>,
									   <argument><expr><name>nbytes</name></expr></argument>,
									   <argument><expr><name>amount</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>nbytes</name> <operator>!=</operator> <name>amount</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>nbytes</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not read block %u in file \"%s\": %m"</literal></expr></argument>,
							<argument><expr><name>blocknum</name></expr></argument>, <argument><expr><call><name>FilePathName</name><argument_list>(<argument><expr><name><name>v</name><operator>-&gt;</operator><name>mdfd_vfd</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * Short read: we are at or past EOF, or we read a partial block at
		 * EOF.  Normally this is an error; upper levels should never try to
		 * read a nonexistent block.  However, if zero_damaged_pages is ON or
		 * we are InRecovery, we should instead return zeroes without
		 * complaining.  This allows, for example, the case of trying to
		 * update a block that was later truncated away.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>zero_damaged_pages</name> <operator>||</operator> <name>InRecovery</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* only zero damaged_pages */</comment>
			<decl_stmt><decl><type><name>int</name></type> <name>damaged_pages_start_offset</name> <init>= <expr><name>nbytes</name> <operator>-</operator> <name>nbytes</name> <operator>%</operator> <name>BLCKSZ</name></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name>buffer</name> <operator>+</operator> <name>damaged_pages_start_offset</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>amount</name> <operator>-</operator> <name>damaged_pages_start_offset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATA_CORRUPTED</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not bulk read block %u in file \"%s\": read only %d of %d bytes"</literal></expr></argument>,
							<argument><expr><name>blocknum</name></expr></argument>, <argument><expr><call><name>FilePathName</name><argument_list>(<argument><expr><name><name>v</name><operator>-&gt;</operator><name>mdfd_vfd</name></name></expr></argument>)</argument_list></call></expr></argument>,
							<argument><expr><name>nbytes</name></expr></argument>, <argument><expr><name>amount</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>
<comment type="block">/* POLAR end */</comment>

<comment type="block">/*
 *	mdwrite() -- Write the supplied block at the appropriate location.
 *
 *		This is to be used only for updating already-existing blocks of a
 *		relation (ie, those before the current EOF).  To extend a relation,
 *		use mdextend().
 */</comment>
<function><type><name>void</name></type>
<name>mdwrite</name><parameter_list>(<parameter><decl><type><name>SMgrRelation</name></type> <name>reln</name></decl></parameter>, <parameter><decl><type><name>ForkNumber</name></type> <name>forknum</name></decl></parameter>, <parameter><decl><type><name>BlockNumber</name></type> <name>blocknum</name></decl></parameter>,
		<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>buffer</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>skipFsync</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>off_t</name></type>		<name>seekpos</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>nbytes</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MdfdVec</name>    <modifier>*</modifier></type><name>v</name></decl>;</decl_stmt>

	<comment type="block">/* This assert is too expensive to have on normally ... */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>CHECK_WRITE_VS_EXTEND</name></cpp:ifdef>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>blocknum</name> <operator>&lt;</operator> <call><name>mdnblocks</name><argument_list>(<argument><expr><name>reln</name></expr></argument>, <argument><expr><name>forknum</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<expr_stmt><expr><call><name>TRACE_POSTGRESQL_SMGR_MD_WRITE_START</name><argument_list>(<argument><expr><name>forknum</name></expr></argument>, <argument><expr><name>blocknum</name></expr></argument>,
										 <argument><expr><name><name>reln</name><operator>-&gt;</operator><name>smgr_rnode</name><operator>.</operator><name>node</name><operator>.</operator><name>spcNode</name></name></expr></argument>,
										 <argument><expr><name><name>reln</name><operator>-&gt;</operator><name>smgr_rnode</name><operator>.</operator><name>node</name><operator>.</operator><name>dbNode</name></name></expr></argument>,
										 <argument><expr><name><name>reln</name><operator>-&gt;</operator><name>smgr_rnode</name><operator>.</operator><name>node</name><operator>.</operator><name>relNode</name></name></expr></argument>,
										 <argument><expr><name><name>reln</name><operator>-&gt;</operator><name>smgr_rnode</name><operator>.</operator><name>backend</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>v</name> <operator>=</operator> <call><name>_mdfd_getseg</name><argument_list>(<argument><expr><name>reln</name></expr></argument>, <argument><expr><name>forknum</name></expr></argument>, <argument><expr><name>blocknum</name></expr></argument>, <argument><expr><name>skipFsync</name></expr></argument>,
					 <argument><expr><name>EXTENSION_FAIL</name> <operator>|</operator> <name>EXTENSION_CREATE_RECOVERY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>seekpos</name> <operator>=</operator> <operator>(</operator><name>off_t</name><operator>)</operator> <name>BLCKSZ</name> <operator>*</operator> <operator>(</operator><name>blocknum</name> <operator>%</operator> <operator>(</operator><operator>(</operator><name>BlockNumber</name><operator>)</operator> <name>RELSEG_SIZE</name><operator>)</operator><operator>)</operator></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>seekpos</name> <operator>&lt;</operator> <operator>(</operator><name>off_t</name><operator>)</operator> <name>BLCKSZ</name> <operator>*</operator> <name>RELSEG_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*no cover begin*/</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>FAULT_INJECTOR</name></cpp:ifdef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MAX_ATOM_WRITE_SIZE</name></cpp:macro> <cpp:value>4096</cpp:value></cpp:define>
	<if_stmt><if>if <condition>(<expr><call><name>SIMPLE_FAULT_INJECTOR</name><argument_list>(<argument><expr><literal type="string">"polar_partial_write_fault"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <name>FaultInjectorTypeEnable</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* POLAR: use pwrite to replace lseek + write */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>POLAR_ENABLE_PWRITE</name><argument_list>()</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>nbytes</name> <operator>=</operator> <call><name>polar_file_pwrite</name><argument_list>(<argument><expr><name><name>v</name><operator>-&gt;</operator><name>mdfd_vfd</name></name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>MAX_ATOM_WRITE_SIZE</name></expr></argument>, <argument><expr><name>seekpos</name></expr></argument>,
				<argument><expr><name>WAIT_EVENT_DATA_FILE_PWRITE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><call><name>FileSeek</name><argument_list>(<argument><expr><name><name>v</name><operator>-&gt;</operator><name>mdfd_vfd</name></name></expr></argument>, <argument><expr><name>seekpos</name></expr></argument>, <argument><expr><name>SEEK_SET</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>seekpos</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not seek to block %u in file \"%s\": %m"</literal></expr></argument>,
								<argument><expr><name>blocknum</name></expr></argument>, <argument><expr><call><name>FilePathName</name><argument_list>(<argument><expr><name><name>v</name><operator>-&gt;</operator><name>mdfd_vfd</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<expr_stmt><expr><name>nbytes</name> <operator>=</operator> <call><name>FileWrite</name><argument_list>(<argument><expr><name><name>v</name><operator>-&gt;</operator><name>mdfd_vfd</name></name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>MAX_ATOM_WRITE_SIZE</name></expr></argument>, <argument><expr><name>WAIT_EVENT_DATA_FILE_WRITE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>PANIC</name></expr></argument>, <argument><expr><literal type="string">"The block ([%u, %u, %u]), %u, %u is partial written."</literal></expr></argument>,
					        <argument><expr><name><name>reln</name><operator>-&gt;</operator><name>smgr_rnode</name><operator>.</operator><name>node</name><operator>.</operator><name>spcNode</name></name></expr></argument>, <argument><expr><name><name>reln</name><operator>-&gt;</operator><name>smgr_rnode</name><operator>.</operator><name>node</name><operator>.</operator><name>dbNode</name></name></expr></argument>,
					        <argument><expr><name><name>reln</name><operator>-&gt;</operator><name>smgr_rnode</name><operator>.</operator><name>node</name><operator>.</operator><name>relNode</name></name></expr></argument>, <argument><expr><name>forknum</name></expr></argument>, <argument><expr><name>blocknum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/*no cover end*/</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<comment type="block">/* POLAR: use pwrite to replace lseek + write */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>POLAR_ENABLE_PWRITE</name><argument_list>()</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>nbytes</name> <operator>=</operator> <call><name>polar_file_pwrite</name><argument_list>(<argument><expr><name><name>v</name><operator>-&gt;</operator><name>mdfd_vfd</name></name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>BLCKSZ</name></expr></argument>, <argument><expr><name>seekpos</name></expr></argument>, 
			<argument><expr><name>WAIT_EVENT_DATA_FILE_PWRITE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>FileSeek</name><argument_list>(<argument><expr><name><name>v</name><operator>-&gt;</operator><name>mdfd_vfd</name></name></expr></argument>, <argument><expr><name>seekpos</name></expr></argument>, <argument><expr><name>SEEK_SET</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>seekpos</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not seek to block %u in file \"%s\": %m"</literal></expr></argument>,
							<argument><expr><name>blocknum</name></expr></argument>, <argument><expr><call><name>FilePathName</name><argument_list>(<argument><expr><name><name>v</name><operator>-&gt;</operator><name>mdfd_vfd</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>nbytes</name> <operator>=</operator> <call><name>FileWrite</name><argument_list>(<argument><expr><name><name>v</name><operator>-&gt;</operator><name>mdfd_vfd</name></name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>BLCKSZ</name></expr></argument>, <argument><expr><name>WAIT_EVENT_DATA_FILE_WRITE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><call><name>TRACE_POSTGRESQL_SMGR_MD_WRITE_DONE</name><argument_list>(<argument><expr><name>forknum</name></expr></argument>, <argument><expr><name>blocknum</name></expr></argument>,
										<argument><expr><name><name>reln</name><operator>-&gt;</operator><name>smgr_rnode</name><operator>.</operator><name>node</name><operator>.</operator><name>spcNode</name></name></expr></argument>,
										<argument><expr><name><name>reln</name><operator>-&gt;</operator><name>smgr_rnode</name><operator>.</operator><name>node</name><operator>.</operator><name>dbNode</name></name></expr></argument>,
										<argument><expr><name><name>reln</name><operator>-&gt;</operator><name>smgr_rnode</name><operator>.</operator><name>node</name><operator>.</operator><name>relNode</name></name></expr></argument>,
										<argument><expr><name><name>reln</name><operator>-&gt;</operator><name>smgr_rnode</name><operator>.</operator><name>backend</name></name></expr></argument>,
										<argument><expr><name>nbytes</name></expr></argument>,
										<argument><expr><name>BLCKSZ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>nbytes</name> <operator>!=</operator> <name>BLCKSZ</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>nbytes</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not write block %u in file \"%s\": %m"</literal></expr></argument>,
							<argument><expr><name>blocknum</name></expr></argument>, <argument><expr><call><name>FilePathName</name><argument_list>(<argument><expr><name><name>v</name><operator>-&gt;</operator><name>mdfd_vfd</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<comment type="block">/* short write: complain appropriately */</comment>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DISK_FULL</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not write block %u in file \"%s\": wrote only %d of %d bytes"</literal></expr></argument>,
						<argument><expr><name>blocknum</name></expr></argument>,
						<argument><expr><call><name>FilePathName</name><argument_list>(<argument><expr><name><name>v</name><operator>-&gt;</operator><name>mdfd_vfd</name></name></expr></argument>)</argument_list></call></expr></argument>,
						<argument><expr><name>nbytes</name></expr></argument>, <argument><expr><name>BLCKSZ</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Check free disk space."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>skipFsync</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>SmgrIsTemp</name><argument_list>(<argument><expr><name>reln</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>register_dirty_segment</name><argument_list>(<argument><expr><name>reln</name></expr></argument>, <argument><expr><name>forknum</name></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 *	POLAR: bulk write
 *	mdwrite() -- Write the supplied continuous block at the appropriate location.
 *
 *		This is to be used only for updating already-existing blocks of a
 *		relation (ie, those before the current EOF).  To extend a relation,
 *		use mdextend().
 */</comment>
<function><type><name>void</name></type>
<name>polar_mdbulkwrite</name><parameter_list>(<parameter><decl><type><name>SMgrRelation</name></type> <name>reln</name></decl></parameter>, <parameter><decl><type><name>ForkNumber</name></type> <name>forknum</name></decl></parameter>, <parameter><decl><type><name>BlockNumber</name></type> <name>blocknum</name></decl></parameter>,
		<parameter><decl><type><name>int</name></type> <name>blockCount</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>buffer</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>skipFsync</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>off_t</name></type>		<name>seekpos</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>nbytes</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MdfdVec</name>    <modifier>*</modifier></type><name>v</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> 		<name>amount</name> <init>= <expr><name>blockCount</name> <operator>*</operator> <name>BLCKSZ</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* This assert is too expensive to have on normally ... */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>CHECK_WRITE_VS_EXTEND</name></cpp:ifdef>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>blocknum</name> <operator>&lt;</operator> <call><name>mdnblocks</name><argument_list>(<argument><expr><name>reln</name></expr></argument>, <argument><expr><name>forknum</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<expr_stmt><expr><call><name>TRACE_POSTGRESQL_SMGR_MD_WRITE_START</name><argument_list>(<argument><expr><name>forknum</name></expr></argument>, <argument><expr><name>blocknum</name></expr></argument>,
										 <argument><expr><name><name>reln</name><operator>-&gt;</operator><name>smgr_rnode</name><operator>.</operator><name>node</name><operator>.</operator><name>spcNode</name></name></expr></argument>,
										 <argument><expr><name><name>reln</name><operator>-&gt;</operator><name>smgr_rnode</name><operator>.</operator><name>node</name><operator>.</operator><name>dbNode</name></name></expr></argument>,
										 <argument><expr><name><name>reln</name><operator>-&gt;</operator><name>smgr_rnode</name><operator>.</operator><name>node</name><operator>.</operator><name>relNode</name></name></expr></argument>,
										 <argument><expr><name><name>reln</name><operator>-&gt;</operator><name>smgr_rnode</name><operator>.</operator><name>backend</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>v</name> <operator>=</operator> <call><name>_mdfd_getseg</name><argument_list>(<argument><expr><name>reln</name></expr></argument>, <argument><expr><name>forknum</name></expr></argument>, <argument><expr><name>blocknum</name></expr></argument>, <argument><expr><name>skipFsync</name></expr></argument>,
					 <argument><expr><name>EXTENSION_FAIL</name> <operator>|</operator> <name>EXTENSION_CREATE_RECOVERY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>seekpos</name> <operator>=</operator> <operator>(</operator><name>off_t</name><operator>)</operator> <name>BLCKSZ</name> <operator>*</operator> <operator>(</operator><name>blocknum</name> <operator>%</operator> <operator>(</operator><operator>(</operator><name>BlockNumber</name><operator>)</operator> <name>RELSEG_SIZE</name><operator>)</operator><operator>)</operator></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>seekpos</name> <operator>&lt;</operator> <operator>(</operator><name>off_t</name><operator>)</operator> <name>BLCKSZ</name> <operator>*</operator> <name>RELSEG_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>seekpos</name> <operator>+</operator> <operator>(</operator><name>off_t</name><operator>)</operator> <name>amount</name> <operator>&lt;=</operator> <operator>(</operator><name>off_t</name><operator>)</operator> <name>BLCKSZ</name> <operator>*</operator> <name>RELSEG_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* POLAR: use pwrite to replace lseek + write */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>POLAR_ENABLE_PWRITE</name><argument_list>()</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>nbytes</name> <operator>=</operator> <call><name>polar_file_pwrite</name><argument_list>(<argument><expr><name><name>v</name><operator>-&gt;</operator><name>mdfd_vfd</name></name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>amount</name></expr></argument>, <argument><expr><name>seekpos</name></expr></argument>, 
			<argument><expr><name>WAIT_EVENT_DATA_FILE_PWRITE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>FileSeek</name><argument_list>(<argument><expr><name><name>v</name><operator>-&gt;</operator><name>mdfd_vfd</name></name></expr></argument>, <argument><expr><name>seekpos</name></expr></argument>, <argument><expr><name>SEEK_SET</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>seekpos</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not seek to block %u in file \"%s\": %m"</literal></expr></argument>,
							<argument><expr><name>blocknum</name></expr></argument>, <argument><expr><call><name>FilePathName</name><argument_list>(<argument><expr><name><name>v</name><operator>-&gt;</operator><name>mdfd_vfd</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>nbytes</name> <operator>=</operator> <call><name>FileWrite</name><argument_list>(<argument><expr><name><name>v</name><operator>-&gt;</operator><name>mdfd_vfd</name></name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>amount</name></expr></argument>, <argument><expr><name>WAIT_EVENT_DATA_FILE_WRITE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><call><name>TRACE_POSTGRESQL_SMGR_MD_WRITE_DONE</name><argument_list>(<argument><expr><name>forknum</name></expr></argument>, <argument><expr><name>blocknum</name></expr></argument>,
									<argument><expr><name><name>reln</name><operator>-&gt;</operator><name>smgr_rnode</name><operator>.</operator><name>node</name><operator>.</operator><name>spcNode</name></name></expr></argument>,
									<argument><expr><name><name>reln</name><operator>-&gt;</operator><name>smgr_rnode</name><operator>.</operator><name>node</name><operator>.</operator><name>dbNode</name></name></expr></argument>,
									<argument><expr><name><name>reln</name><operator>-&gt;</operator><name>smgr_rnode</name><operator>.</operator><name>node</name><operator>.</operator><name>relNode</name></name></expr></argument>,
									<argument><expr><name><name>reln</name><operator>-&gt;</operator><name>smgr_rnode</name><operator>.</operator><name>backend</name></name></expr></argument>,
									<argument><expr><name>nbytes</name></expr></argument>,
									<argument><expr><name>amount</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>nbytes</name> <operator>!=</operator> <name>amount</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>nbytes</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not write block %u in file \"%s\": %m"</literal></expr></argument>,
							<argument><expr><name>blocknum</name></expr></argument>, <argument><expr><call><name>FilePathName</name><argument_list>(<argument><expr><name><name>v</name><operator>-&gt;</operator><name>mdfd_vfd</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<comment type="block">/* short write: complain appropriately */</comment>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DISK_FULL</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not write block %u in file \"%s\": wrote only %d of %d bytes"</literal></expr></argument>,
						<argument><expr><name>blocknum</name></expr></argument>,
						<argument><expr><call><name>FilePathName</name><argument_list>(<argument><expr><name><name>v</name><operator>-&gt;</operator><name>mdfd_vfd</name></name></expr></argument>)</argument_list></call></expr></argument>,
						<argument><expr><name>nbytes</name></expr></argument>, <argument><expr><name>BLCKSZ</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Check free disk space."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>skipFsync</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>SmgrIsTemp</name><argument_list>(<argument><expr><name>reln</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>register_dirty_segment</name><argument_list>(<argument><expr><name>reln</name></expr></argument>, <argument><expr><name>forknum</name></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 *	mdnblocks() -- Get the number of blocks stored in a relation.
 *
 *		Important side effect: all active segments of the relation are opened
 *		and added to the mdfd_seg_fds array.  If this routine has not been
 *		called, then only segments up to the last one actually touched
 *		are present in the array.
 */</comment>
<function><type><name>BlockNumber</name></type>
<name>mdnblocks</name><parameter_list>(<parameter><decl><type><name>SMgrRelation</name></type> <name>reln</name></decl></parameter>, <parameter><decl><type><name>ForkNumber</name></type> <name>forknum</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>polar_use_file_cache</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>MdfdVec</name>    <modifier>*</modifier></type><name>v</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BlockNumber</name></type> <name>nblocks</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BlockNumber</name></type> <name>segno</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<comment type="block">/* POLAR: bulk extend */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>polar_smgr_being_bulk_extend</name><argument_list>(<argument><expr><name>reln</name></expr></argument>, <argument><expr><name>forknum</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>true</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name><name>reln</name><operator>-&gt;</operator><name>polar_nblocks_faked_for_bulk_extend</name><index>[<expr><name>forknum</name></expr>]</index></name></expr>;</return></block_content></block></if></if_stmt>
	<comment type="block">/* POLAR end */</comment>

	<expr_stmt><expr><name>v</name> <operator>=</operator> <call><name>mdopen</name><argument_list>(<argument><expr><name>reln</name></expr></argument>, <argument><expr><name>forknum</name></expr></argument>, <argument><expr><name>EXTENSION_FAIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* mdopen has opened the first segment */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>reln</name><operator>-&gt;</operator><name>md_num_open_segs</name><index>[<expr><name>forknum</name></expr>]</index></name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Start from the last open segments, to avoid redundant seeks.  We have
	 * previously verified that these segments are exactly RELSEG_SIZE long,
	 * and it's useless to recheck that each time.
	 *
	 * NOTE: this assumption could only be wrong if another backend has
	 * truncated the relation.  We rely on higher code levels to handle that
	 * scenario by closing and re-opening the md fd, which is handled via
	 * relcache flush.  (Since the checkpointer doesn't participate in
	 * relcache flush, it could have segment entries for inactive segments;
	 * that's OK because the checkpointer never needs to compute relation
	 * size.)
	 */</comment>
	<expr_stmt><expr><name>segno</name> <operator>=</operator> <name><name>reln</name><operator>-&gt;</operator><name>md_num_open_segs</name><index>[<expr><name>forknum</name></expr>]</index></name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>v</name> <operator>=</operator> <operator>&amp;</operator><name><name>reln</name><operator>-&gt;</operator><name>md_seg_fds</name><index>[<expr><name>forknum</name></expr>]</index><index>[<expr><name>segno</name></expr>]</index></name></expr>;</expr_stmt>

	<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>polar_use_file_cache</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>nblocks</name> <operator>=</operator> <call><name>polar_cache_mdnblocks</name><argument_list>(<argument><expr><name>reln</name></expr></argument>, <argument><expr><name>forknum</name></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>nblocks</name> <operator>=</operator> <call><name>_mdnblocks</name><argument_list>(<argument><expr><name>reln</name></expr></argument>, <argument><expr><name>forknum</name></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
		<if_stmt><if>if <condition>(<expr><name>nblocks</name> <operator>&gt;</operator> <operator>(</operator><operator>(</operator><name>BlockNumber</name><operator>)</operator> <name>RELSEG_SIZE</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>, <argument><expr><literal type="string">"segment too big"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name>nblocks</name> <operator>&lt;</operator> <operator>(</operator><operator>(</operator><name>BlockNumber</name><operator>)</operator> <name>RELSEG_SIZE</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><operator>(</operator><name>segno</name> <operator>*</operator> <operator>(</operator><operator>(</operator><name>BlockNumber</name><operator>)</operator> <name>RELSEG_SIZE</name><operator>)</operator><operator>)</operator> <operator>+</operator> <name>nblocks</name></expr>;</return></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * If segment is exactly RELSEG_SIZE, advance to next one.
		 */</comment>
		<expr_stmt><expr><name>segno</name><operator>++</operator></expr>;</expr_stmt>

		<comment type="block">/*
		 * We used to pass O_CREAT here, but that's has the disadvantage that
		 * it might create a segment which has vanished through some operating
		 * system misadventure.  In such a case, creating the segment here
		 * undermines _mdfd_getseg's attempts to notice and report an error
		 * upon access to a missing segment.
		 */</comment>
		<expr_stmt><expr><name>v</name> <operator>=</operator> <call><name>_mdfd_openseg</name><argument_list>(<argument><expr><name>reln</name></expr></argument>, <argument><expr><name>forknum</name></expr></argument>, <argument><expr><name>segno</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>v</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>segno</name> <operator>*</operator> <operator>(</operator><operator>(</operator><name>BlockNumber</name><operator>)</operator> <name>RELSEG_SIZE</name><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></for>
</block_content>}</block></function>

<comment type="block">/*
 *	mdtruncate() -- Truncate relation to specified number of blocks.
 */</comment>
<function><type><name>void</name></type>
<name>mdtruncate</name><parameter_list>(<parameter><decl><type><name>SMgrRelation</name></type> <name>reln</name></decl></parameter>, <parameter><decl><type><name>ForkNumber</name></type> <name>forknum</name></decl></parameter>, <parameter><decl><type><name>BlockNumber</name></type> <name>nblocks</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>BlockNumber</name></type> <name>curnblk</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BlockNumber</name></type> <name>priorblocks</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>curopensegs</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * NOTE: mdnblocks makes sure we have opened all active segments, so that
	 * truncation loop will get them all!
	 */</comment>
	<expr_stmt><expr><name>curnblk</name> <operator>=</operator> <call><name>mdnblocks</name><argument_list>(<argument><expr><name>reln</name></expr></argument>, <argument><expr><name>forknum</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>nblocks</name> <operator>&gt;</operator> <name>curnblk</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Bogus request ... but no complaint if InRecovery */</comment>
		<if_stmt><if>if <condition>(<expr><name>InRecovery</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return;</return></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not truncate file \"%s\" to %u blocks: it's only %u blocks now"</literal></expr></argument>,
						<argument><expr><call><name>relpath</name><argument_list>(<argument><expr><name><name>reln</name><operator>-&gt;</operator><name>smgr_rnode</name></name></expr></argument>, <argument><expr><name>forknum</name></expr></argument>)</argument_list></call></expr></argument>,
						<argument><expr><name>nblocks</name></expr></argument>, <argument><expr><name>curnblk</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>nblocks</name> <operator>==</operator> <name>curnblk</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>					<comment type="block">/* no work */</comment>

	<comment type="block">/*
	 * Truncate segments, starting at the last one. Starting at the end makes
	 * managing the memory for the fd array easier, should there be errors.
	 */</comment>
	<expr_stmt><expr><name>curopensegs</name> <operator>=</operator> <name><name>reln</name><operator>-&gt;</operator><name>md_num_open_segs</name><index>[<expr><name>forknum</name></expr>]</index></name></expr>;</expr_stmt>
	<while>while <condition>(<expr><name>curopensegs</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>MdfdVec</name>    <modifier>*</modifier></type><name>v</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>priorblocks</name> <operator>=</operator> <operator>(</operator><name>curopensegs</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator> <operator>*</operator> <name>RELSEG_SIZE</name></expr>;</expr_stmt>

		<expr_stmt><expr><name>v</name> <operator>=</operator> <operator>&amp;</operator><name><name>reln</name><operator>-&gt;</operator><name>md_seg_fds</name><index>[<expr><name>forknum</name></expr>]</index><index>[<expr><name>curopensegs</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>priorblocks</name> <operator>&gt;</operator> <name>nblocks</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * This segment is no longer active. We truncate the file, but do
			 * not delete it, for reasons explained in the header comments.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>FileTruncate</name><argument_list>(<argument><expr><name><name>v</name><operator>-&gt;</operator><name>mdfd_vfd</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>WAIT_EVENT_DATA_FILE_TRUNCATE</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not truncate file \"%s\": %m"</literal></expr></argument>,
								<argument><expr><call><name>FilePathName</name><argument_list>(<argument><expr><name><name>v</name><operator>-&gt;</operator><name>mdfd_vfd</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>SmgrIsTemp</name><argument_list>(<argument><expr><name>reln</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>register_dirty_segment</name><argument_list>(<argument><expr><name>reln</name></expr></argument>, <argument><expr><name>forknum</name></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<comment type="block">/* we never drop the 1st segment */</comment>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>v</name> <operator>!=</operator> <operator>&amp;</operator><name><name>reln</name><operator>-&gt;</operator><name>md_seg_fds</name><index>[<expr><name>forknum</name></expr>]</index><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>FileClose</name><argument_list>(<argument><expr><name><name>v</name><operator>-&gt;</operator><name>mdfd_vfd</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>_fdvec_resize</name><argument_list>(<argument><expr><name>reln</name></expr></argument>, <argument><expr><name>forknum</name></expr></argument>, <argument><expr><name>curopensegs</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name>priorblocks</name> <operator>+</operator> <operator>(</operator><operator>(</operator><name>BlockNumber</name><operator>)</operator> <name>RELSEG_SIZE</name><operator>)</operator> <operator>&gt;</operator> <name>nblocks</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * This is the last segment we want to keep. Truncate the file to
			 * the right length. NOTE: if nblocks is exactly a multiple K of
			 * RELSEG_SIZE, we will truncate the K+1st segment to 0 length but
			 * keep it. This adheres to the invariant given in the header
			 * comments.
			 */</comment>
			<decl_stmt><decl><type><name>BlockNumber</name></type> <name>lastsegblocks</name> <init>= <expr><name>nblocks</name> <operator>-</operator> <name>priorblocks</name></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>FileTruncate</name><argument_list>(<argument><expr><name><name>v</name><operator>-&gt;</operator><name>mdfd_vfd</name></name></expr></argument>, <argument><expr><operator>(</operator><name>off_t</name><operator>)</operator> <name>lastsegblocks</name> <operator>*</operator> <name>BLCKSZ</name></expr></argument>, <argument><expr><name>WAIT_EVENT_DATA_FILE_TRUNCATE</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not truncate file \"%s\" to %u blocks: %m"</literal></expr></argument>,
								<argument><expr><call><name>FilePathName</name><argument_list>(<argument><expr><name><name>v</name><operator>-&gt;</operator><name>mdfd_vfd</name></name></expr></argument>)</argument_list></call></expr></argument>,
								<argument><expr><name>nblocks</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>SmgrIsTemp</name><argument_list>(<argument><expr><name>reln</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>register_dirty_segment</name><argument_list>(<argument><expr><name>reln</name></expr></argument>, <argument><expr><name>forknum</name></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/*
			 * We still need this segment, so nothing to do for this and any
			 * earlier segment.
			 */</comment>
			<break>break;</break>
		</block_content>}</block></else></if_stmt>
		<expr_stmt><expr><name>curopensegs</name><operator>--</operator></expr>;</expr_stmt>
	</block_content>}</block></while>
</block_content>}</block></function>

<comment type="block">/*
 *	mdimmedsync() -- Immediately sync a relation to stable storage.
 *
 * Note that only writes already issued are synced; this routine knows
 * nothing of dirty buffers that may exist inside the buffer manager.
 */</comment>
<function><type><name>void</name></type>
<name>mdimmedsync</name><parameter_list>(<parameter><decl><type><name>SMgrRelation</name></type> <name>reln</name></decl></parameter>, <parameter><decl><type><name>ForkNumber</name></type> <name>forknum</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>segno</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * NOTE: mdnblocks makes sure we have opened all active segments, so that
	 * fsync loop will get them all!
	 */</comment>
	<expr_stmt><expr><call><name>mdnblocks</name><argument_list>(<argument><expr><name>reln</name></expr></argument>, <argument><expr><name>forknum</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>segno</name> <operator>=</operator> <name><name>reln</name><operator>-&gt;</operator><name>md_num_open_segs</name><index>[<expr><name>forknum</name></expr>]</index></name></expr>;</expr_stmt>

	<while>while <condition>(<expr><name>segno</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>MdfdVec</name>    <modifier>*</modifier></type><name>v</name> <init>= <expr><operator>&amp;</operator><name><name>reln</name><operator>-&gt;</operator><name>md_seg_fds</name><index>[<expr><name>forknum</name></expr>]</index><index>[<expr><name>segno</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>FileSync</name><argument_list>(<argument><expr><name><name>v</name><operator>-&gt;</operator><name>mdfd_vfd</name></name></expr></argument>, <argument><expr><name>WAIT_EVENT_DATA_FILE_IMMEDIATE_SYNC</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><call><name>data_sync_elevel</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>)</argument_list></call></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not fsync file \"%s\": %m"</literal></expr></argument>,
							<argument><expr><call><name>FilePathName</name><argument_list>(<argument><expr><name><name>v</name><operator>-&gt;</operator><name>mdfd_vfd</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>segno</name><operator>--</operator></expr>;</expr_stmt>
	</block_content>}</block></while>
</block_content>}</block></function>

<comment type="block">/*
 *	mdsync() -- Sync previous writes to stable storage.
 */</comment>
<function><type><name>void</name></type>
<name>mdsync</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type> <name>mdsync_in_progress</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>HASH_SEQ_STATUS</name></type> <name>hstat</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PendingOperationEntry</name> <modifier>*</modifier></type><name>entry</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>absorb_counter</name></decl>;</decl_stmt>

	<comment type="block">/* Statistics on sync times */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>processed</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>instr_time</name></type>	<name>sync_start</name></decl>,
				<decl><type ref="prev"/><name>sync_end</name></decl>,
				<decl><type ref="prev"/><name>sync_diff</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint64</name></type>		<name>elapsed</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint64</name></type>		<name>longest</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint64</name></type>		<name>total_elapsed</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * This is only called during checkpoints, and checkpoints should only
	 * occur in processes that have created a pendingOpsTable.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>pendingOpsTable</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cannot sync without a pendingOpsTable"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * If we are in the checkpointer, the sync had better include all fsync
	 * requests that were queued by backends up to this point.  The tightest
	 * race condition that could occur is that a buffer that must be written
	 * and fsync'd for the checkpoint could have been dumped by a backend just
	 * before it was visited by BufferSync().  We know the backend will have
	 * queued an fsync request before clearing the buffer's dirtybit, so we
	 * are safe as long as we do an Absorb after completing BufferSync().
	 */</comment>
	<expr_stmt><expr><call><name>AbsorbFsyncRequests</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * To avoid excess fsync'ing (in the worst case, maybe a never-terminating
	 * checkpoint), we want to ignore fsync requests that are entered into the
	 * hashtable after this point --- they should be processed next time,
	 * instead.  We use mdsync_cycle_ctr to tell old entries apart from new
	 * ones: new ones will have cycle_ctr equal to the incremented value of
	 * mdsync_cycle_ctr.
	 *
	 * In normal circumstances, all entries present in the table at this point
	 * will have cycle_ctr exactly equal to the current (about to be old)
	 * value of mdsync_cycle_ctr.  However, if we fail partway through the
	 * fsync'ing loop, then older values of cycle_ctr might remain when we
	 * come back here to try again.  Repeated checkpoint failures would
	 * eventually wrap the counter around to the point where an old entry
	 * might appear new, causing us to skip it, possibly allowing a checkpoint
	 * to succeed that should not have.  To forestall wraparound, any time the
	 * previous mdsync() failed to complete, run through the table and
	 * forcibly set cycle_ctr = mdsync_cycle_ctr.
	 *
	 * Think not to merge this loop with the main loop, as the problem is
	 * exactly that that loop may fail before having visited all the entries.
	 * From a performance point of view it doesn't matter anyway, as this path
	 * will never be taken in a system that's functioning normally.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>mdsync_in_progress</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* prior try failed, so update any stale cycle_ctr values */</comment>
		<expr_stmt><expr><call><name>hash_seq_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>hstat</name></expr></argument>, <argument><expr><name>pendingOpsTable</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<while>while <condition>(<expr><operator>(</operator><name>entry</name> <operator>=</operator> <operator>(</operator><name>PendingOperationEntry</name> <operator>*</operator><operator>)</operator> <call><name>hash_seq_search</name><argument_list>(<argument><expr><operator>&amp;</operator><name>hstat</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>cycle_ctr</name></name> <operator>=</operator> <name>mdsync_cycle_ctr</name></expr>;</expr_stmt>
		</block_content>}</block></while>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Advance counter so that new hashtable entries are distinguishable */</comment>
	<expr_stmt><expr><name>mdsync_cycle_ctr</name><operator>++</operator></expr>;</expr_stmt>

	<comment type="block">/* Set flag to detect failure if we don't reach the end of the loop */</comment>
	<expr_stmt><expr><name>mdsync_in_progress</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

	<comment type="block">/* Now scan the hashtable for fsync requests to process */</comment>
	<expr_stmt><expr><name>absorb_counter</name> <operator>=</operator> <name>FSYNCS_PER_ABSORB</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>hash_seq_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>hstat</name></expr></argument>, <argument><expr><name>pendingOpsTable</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<while>while <condition>(<expr><operator>(</operator><name>entry</name> <operator>=</operator> <operator>(</operator><name>PendingOperationEntry</name> <operator>*</operator><operator>)</operator> <call><name>hash_seq_search</name><argument_list>(<argument><expr><operator>&amp;</operator><name>hstat</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ForkNumber</name></type>	<name>forknum</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * If the entry is new then don't process it this time; it might
		 * contain multiple fsync-request bits, but they are all new.  Note
		 * "continue" bypasses the hash-remove call at the bottom of the loop.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>entry</name><operator>-&gt;</operator><name>cycle_ctr</name></name> <operator>==</operator> <name>mdsync_cycle_ctr</name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<comment type="block">/* Else assert we haven't missed it */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>(</operator><name>CycleCtr</name><operator>)</operator> <operator>(</operator><name><name>entry</name><operator>-&gt;</operator><name>cycle_ctr</name></name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>==</operator> <name>mdsync_cycle_ctr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Scan over the forks and segments represented by the entry.
		 *
		 * The bitmap manipulations are slightly tricky, because we can call
		 * AbsorbFsyncRequests() inside the loop and that could result in
		 * bms_add_member() modifying and even re-palloc'ing the bitmapsets.
		 * So we detach it, but if we fail we'll merge it with any new
		 * requests that have arrived in the meantime.
		 */</comment>
		<for>for <control>(<init><expr><name>forknum</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>forknum</name> <operator>&lt;=</operator> <name>MAX_FORKNUM</name></expr>;</condition> <incr><expr><name>forknum</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Bitmapset</name>  <modifier>*</modifier></type><name>requests</name> <init>= <expr><name><name>entry</name><operator>-&gt;</operator><name>requests</name><index>[<expr><name>forknum</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int</name></type>			<name>segno</name></decl>;</decl_stmt>

			<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>requests</name><index>[<expr><name>forknum</name></expr>]</index></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>canceled</name><index>[<expr><name>forknum</name></expr>]</index></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

			<expr_stmt><expr><name>segno</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
			<while>while <condition>(<expr><operator>(</operator><name>segno</name> <operator>=</operator> <call><name>bms_next_member</name><argument_list>(<argument><expr><name>requests</name></expr></argument>, <argument><expr><name>segno</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>int</name></type>			<name>failures</name></decl>;</decl_stmt>

				<comment type="block">/*
				 * If fsync is off then we don't have to bother opening the
				 * file at all.  (We delay checking until this point so that
				 * changing fsync on the fly behaves sensibly.)
				 */</comment>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><name>enableFsync</name></expr>)</condition><block type="pseudo"><block_content>
					<continue>continue;</continue></block_content></block></if></if_stmt>

				<comment type="block">/*
				 * If in checkpointer, we want to absorb pending requests
				 * every so often to prevent overflow of the fsync request
				 * queue.  It is unspecified whether newly-added entries will
				 * be visited by hash_seq_search, but we don't care since we
				 * don't need to process them anyway.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><operator>--</operator><name>absorb_counter</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>AbsorbFsyncRequests</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>absorb_counter</name> <operator>=</operator> <name>FSYNCS_PER_ABSORB</name></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>

				<comment type="block">/*
				 * The fsync table could contain requests to fsync segments
				 * that have been deleted (unlinked) by the time we get to
				 * them. Rather than just hoping an ENOENT (or EACCES on
				 * Windows) error can be ignored, what we do on error is
				 * absorb pending requests and then retry.  Since mdunlink()
				 * queues a "cancel" message before actually unlinking, the
				 * fsync request is guaranteed to be marked canceled after the
				 * absorb if it really was this case. DROP DATABASE likewise
				 * has to tell us to forget fsync requests before it starts
				 * deletions.
				 */</comment>
				<for>for <control>(<init><expr><name>failures</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init><condition>;</condition> <incr><expr><name>failures</name><operator>++</operator></expr></incr>)</control> <comment type="block">/* loop exits at "break" */</comment>
				<block>{<block_content>
					<decl_stmt><decl><type><name>SMgrRelation</name></type> <name>reln</name></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>MdfdVec</name>    <modifier>*</modifier></type><name>seg</name></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>path</name></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>int</name></type>			<name>save_errno</name></decl>;</decl_stmt>

					<comment type="block">/*
					 * Find or create an smgr hash entry for this relation.
					 * This may seem a bit unclean -- md calling smgr?	But
					 * it's really the best solution.  It ensures that the
					 * open file reference isn't permanently leaked if we get
					 * an error here. (You may say "but an unreferenced
					 * SMgrRelation is still a leak!" Not really, because the
					 * only case in which a checkpoint is done by a process
					 * that isn't about to shut down is in the checkpointer,
					 * and it will periodically do smgrcloseall(). This fact
					 * justifies our not closing the reln in the success path
					 * either, which is a good thing since in non-checkpointer
					 * cases we couldn't safely do that.)
					 */</comment>
					<expr_stmt><expr><name>reln</name> <operator>=</operator> <call><name>smgropen</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>rnode</name></name></expr></argument>, <argument><expr><name>InvalidBackendId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<comment type="block">/* Attempt to open and fsync the target segment */</comment>
					<expr_stmt><expr><name>seg</name> <operator>=</operator> <call><name>_mdfd_getseg</name><argument_list>(<argument><expr><name>reln</name></expr></argument>, <argument><expr><name>forknum</name></expr></argument>,
									   <argument><expr><operator>(</operator><name>BlockNumber</name><operator>)</operator> <name>segno</name> <operator>*</operator> <operator>(</operator><name>BlockNumber</name><operator>)</operator> <name>RELSEG_SIZE</name></expr></argument>,
									   <argument><expr><name>false</name></expr></argument>,
									   <argument><expr><name>EXTENSION_RETURN_NULL</name>
									   <operator>|</operator> <name>EXTENSION_DONT_CHECK_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<expr_stmt><expr><call><name>INSTR_TIME_SET_CURRENT</name><argument_list>(<argument><expr><name>sync_start</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<if_stmt><if>if <condition>(<expr><name>seg</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator>
						<call><name>FileSync</name><argument_list>(<argument><expr><name><name>seg</name><operator>-&gt;</operator><name>mdfd_vfd</name></name></expr></argument>, <argument><expr><name>WAIT_EVENT_DATA_FILE_SYNC</name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition>
					<block>{<block_content>
						<comment type="block">/* Success; update statistics about sync timing */</comment>
						<expr_stmt><expr><call><name>INSTR_TIME_SET_CURRENT</name><argument_list>(<argument><expr><name>sync_end</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><name>sync_diff</name> <operator>=</operator> <name>sync_end</name></expr>;</expr_stmt>
						<expr_stmt><expr><call><name>INSTR_TIME_SUBTRACT</name><argument_list>(<argument><expr><name>sync_diff</name></expr></argument>, <argument><expr><name>sync_start</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><name>elapsed</name> <operator>=</operator> <call><name>INSTR_TIME_GET_MICROSEC</name><argument_list>(<argument><expr><name>sync_diff</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<if_stmt><if>if <condition>(<expr><name>elapsed</name> <operator>&gt;</operator> <name>longest</name></expr>)</condition><block type="pseudo"><block_content>
							<expr_stmt><expr><name>longest</name> <operator>=</operator> <name>elapsed</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
						<expr_stmt><expr><name>total_elapsed</name> <operator>+=</operator> <name>elapsed</name></expr>;</expr_stmt>
						<expr_stmt><expr><name>processed</name><operator>++</operator></expr>;</expr_stmt>
						<expr_stmt><expr><name>requests</name> <operator>=</operator> <call><name>bms_del_member</name><argument_list>(<argument><expr><name>requests</name></expr></argument>, <argument><expr><name>segno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<if_stmt><if>if <condition>(<expr><name>log_checkpoints</name></expr>)</condition><block type="pseudo"><block_content>
							<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>, <argument><expr><literal type="string">"checkpoint sync: number=%d file=%s time=%.3f msec"</literal></expr></argument>,
								 <argument><expr><name>processed</name></expr></argument>,
								 <argument><expr><call><name>FilePathName</name><argument_list>(<argument><expr><name><name>seg</name><operator>-&gt;</operator><name>mdfd_vfd</name></name></expr></argument>)</argument_list></call></expr></argument>,
								 <argument><expr><operator>(</operator><name>double</name><operator>)</operator> <name>elapsed</name> <operator>/</operator> <literal type="number">1000</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

						<break>break;</break>	<comment type="block">/* out of retry loop */</comment>
					</block_content>}</block></if></if_stmt>

					<comment type="block">/* Compute file name for use in message */</comment>
					<expr_stmt><expr><name>save_errno</name> <operator>=</operator> <name>errno</name></expr>;</expr_stmt>
					<expr_stmt><expr><name>path</name> <operator>=</operator> <call><name>_mdfd_segpath</name><argument_list>(<argument><expr><name>reln</name></expr></argument>, <argument><expr><name>forknum</name></expr></argument>, <argument><expr><operator>(</operator><name>BlockNumber</name><operator>)</operator> <name>segno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>errno</name> <operator>=</operator> <name>save_errno</name></expr>;</expr_stmt>

					<comment type="block">/*
					 * It is possible that the relation has been dropped or
					 * truncated since the fsync request was entered.
					 * Therefore, allow ENOENT, but only if we didn't fail
					 * already on this file.  This applies both for
					 * _mdfd_getseg() and for FileSync, since fd.c might have
					 * closed the file behind our back.
					 *
					 * XXX is there any point in allowing more than one retry?
					 * Don't see one at the moment, but easy to change the
					 * test here if so.
					 */</comment>
					<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>FILE_POSSIBLY_DELETED</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call> <operator>||</operator>
						<name>failures</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
					<block>{<block_content>
						<decl_stmt><decl><type><name>Bitmapset</name>  <modifier>*</modifier></type><name>new_requests</name></decl>;</decl_stmt>

						<comment type="block">/*
						 * We need to merge these unsatisfied requests with
						 * any others that have arrived since we started.
						 */</comment>
						<expr_stmt><expr><name>new_requests</name> <operator>=</operator> <name><name>entry</name><operator>-&gt;</operator><name>requests</name><index>[<expr><name>forknum</name></expr>]</index></name></expr>;</expr_stmt>
						<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>requests</name><index>[<expr><name>forknum</name></expr>]</index></name> <operator>=</operator>
							<call><name>bms_join</name><argument_list>(<argument><expr><name>new_requests</name></expr></argument>, <argument><expr><name>requests</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

						<expr_stmt><expr><name>errno</name> <operator>=</operator> <name>save_errno</name></expr>;</expr_stmt>
						<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><call><name>data_sync_elevel</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>)</argument_list></call></expr></argument>,
								<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
								 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not fsync file \"%s\": %m"</literal></expr></argument>,
										<argument><expr><name>path</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block></if>
					<else>else
					<block>{<block_content>
						<comment type="block">/* POLAR: force log */</comment>
						<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>,
								<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
								 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not fsync file \"%s\" but retrying: %m"</literal></expr></argument>,
										<argument><expr><name>path</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block></else></if_stmt>

					<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<comment type="block">/*
					 * Absorb incoming requests and check to see if a cancel
					 * arrived for this relation fork.
					 */</comment>
					<expr_stmt><expr><call><name>AbsorbFsyncRequests</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>absorb_counter</name> <operator>=</operator> <name>FSYNCS_PER_ABSORB</name></expr>;</expr_stmt> <comment type="block">/* might as well... */</comment>

					<if_stmt><if>if <condition>(<expr><name><name>entry</name><operator>-&gt;</operator><name>canceled</name><index>[<expr><name>forknum</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
						<break>break;</break></block_content></block></if></if_stmt>
				</block_content>}</block></for>				<comment type="block">/* end retry loop */</comment>
			</block_content>}</block></while>
			<expr_stmt><expr><call><name>bms_free</name><argument_list>(<argument><expr><name>requests</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></for>

		<comment type="block">/*
		 * We've finished everything that was requested before we started to
		 * scan the entry.  If no new requests have been inserted meanwhile,
		 * remove the entry.  Otherwise, update its cycle counter, as all the
		 * requests now in it must have arrived during this cycle.
		 */</comment>
		<for>for <control>(<init><expr><name>forknum</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>forknum</name> <operator>&lt;=</operator> <name>MAX_FORKNUM</name></expr>;</condition> <incr><expr><name>forknum</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name><name>entry</name><operator>-&gt;</operator><name>requests</name><index>[<expr><name>forknum</name></expr>]</index></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
				<break>break;</break></block_content></block></if></if_stmt>
		</block_content>}</block></for>
		<if_stmt><if>if <condition>(<expr><name>forknum</name> <operator>&lt;=</operator> <name>MAX_FORKNUM</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>cycle_ctr</name></name> <operator>=</operator> <name>mdsync_cycle_ctr</name></expr>;</expr_stmt></block_content></block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/* Okay to remove it */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>hash_search</name><argument_list>(<argument><expr><name>pendingOpsTable</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>entry</name><operator>-&gt;</operator><name>rnode</name></name></expr></argument>,
							<argument><expr><name>HASH_REMOVE</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"pendingOpsTable corrupted"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></while>							<comment type="block">/* end loop over hashtable entries */</comment>

	<comment type="block">/* Return sync performance metrics for report at checkpoint end */</comment>
	<expr_stmt><expr><name><name>CheckpointStats</name><operator>.</operator><name>ckpt_sync_rels</name></name> <operator>=</operator> <name>processed</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>CheckpointStats</name><operator>.</operator><name>ckpt_longest_sync</name></name> <operator>=</operator> <name>longest</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>CheckpointStats</name><operator>.</operator><name>ckpt_agg_sync_time</name></name> <operator>=</operator> <name>total_elapsed</name></expr>;</expr_stmt>

	<comment type="block">/* Flag successful completion of mdsync */</comment>
	<expr_stmt><expr><name>mdsync_in_progress</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * mdpreckpt() -- Do pre-checkpoint work
 *
 * To distinguish unlink requests that arrived before this checkpoint
 * started from those that arrived during the checkpoint, we use a cycle
 * counter similar to the one we use for fsync requests. That cycle
 * counter is incremented here.
 *
 * This must be called *before* the checkpoint REDO point is determined.
 * That ensures that we won't delete files too soon.
 *
 * Note that we can't do anything here that depends on the assumption
 * that the checkpoint will be completed.
 */</comment>
<function><type><name>void</name></type>
<name>mdpreckpt</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * Any unlink requests arriving after this point will be assigned the next
	 * cycle counter, and won't be unlinked until next checkpoint.
	 */</comment>
	<expr_stmt><expr><name>mdckpt_cycle_ctr</name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * mdpostckpt() -- Do post-checkpoint work
 *
 * Remove any lingering files that can now be safely removed.
 */</comment>
<function><type><name>void</name></type>
<name>mdpostckpt</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>absorb_counter</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>absorb_counter</name> <operator>=</operator> <name>UNLINKS_PER_ABSORB</name></expr>;</expr_stmt>
	<while>while <condition>(<expr><name>pendingUnlinks</name> <operator>!=</operator> <name>NIL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>PendingUnlinkEntry</name> <modifier>*</modifier></type><name>entry</name> <init>= <expr><operator>(</operator><name>PendingUnlinkEntry</name> <operator>*</operator><operator>)</operator> <call><name>linitial</name><argument_list>(<argument><expr><name>pendingUnlinks</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>path</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * New entries are appended to the end, so if the entry is new we've
		 * reached the end of old entries.
		 *
		 * Note: if just the right number of consecutive checkpoints fail, we
		 * could be fooled here by cycle_ctr wraparound.  However, the only
		 * consequence is that we'd delay unlinking for one more checkpoint,
		 * which is perfectly tolerable.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>entry</name><operator>-&gt;</operator><name>cycle_ctr</name></name> <operator>==</operator> <name>mdckpt_cycle_ctr</name></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>

		<comment type="block">/* Unlink the file */</comment>
		<expr_stmt><expr><name>path</name> <operator>=</operator> <call><name>relpathperm</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>rnode</name></name></expr></argument>, <argument><expr><name>MAIN_FORKNUM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>polar_unlink</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * There's a race condition, when the database is dropped at the
			 * same time that we process the pending unlink requests. If the
			 * DROP DATABASE deletes the file before we do, we will get ENOENT
			 * here. rmtree() also has to ignore ENOENT errors, to deal with
			 * the possibility that we delete the file first.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name>errno</name> <operator>!=</operator> <name>ENOENT</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not remove file \"%s\": %m"</literal></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* And remove the list entry */</comment>
		<expr_stmt><expr><name>pendingUnlinks</name> <operator>=</operator> <call><name>list_delete_first</name><argument_list>(<argument><expr><name>pendingUnlinks</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>entry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * As in mdsync, we don't want to stop absorbing fsync requests for a
		 * long time when there are many deletions to be done.  We can safely
		 * call AbsorbFsyncRequests() at this point in the loop (note it might
		 * try to delete list entries).
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>--</operator><name>absorb_counter</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>AbsorbFsyncRequests</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>absorb_counter</name> <operator>=</operator> <name>UNLINKS_PER_ABSORB</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></while>
</block_content>}</block></function>

<comment type="block">/*
 * register_dirty_segment() -- Mark a relation segment as needing fsync
 *
 * If there is a local pending-ops table, just make an entry in it for
 * mdsync to process later.  Otherwise, try to pass off the fsync request
 * to the checkpointer process.  If that fails, just do the fsync
 * locally before returning (we hope this will not happen often enough
 * to be a performance problem).
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>register_dirty_segment</name><parameter_list>(<parameter><decl><type><name>SMgrRelation</name></type> <name>reln</name></decl></parameter>, <parameter><decl><type><name>ForkNumber</name></type> <name>forknum</name></decl></parameter>, <parameter><decl><type><name>MdfdVec</name> <modifier>*</modifier></type><name>seg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* Temp relations should never be fsync'd */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>SmgrIsTemp</name><argument_list>(<argument><expr><name>reln</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>pendingOpsTable</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* push it into local pending-ops table */</comment>
		<expr_stmt><expr><call><name>RememberFsyncRequest</name><argument_list>(<argument><expr><name><name>reln</name><operator>-&gt;</operator><name>smgr_rnode</name><operator>.</operator><name>node</name></name></expr></argument>, <argument><expr><name>forknum</name></expr></argument>, <argument><expr><name><name>seg</name><operator>-&gt;</operator><name>mdfd_segno</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>ForwardFsyncRequest</name><argument_list>(<argument><expr><name><name>reln</name><operator>-&gt;</operator><name>smgr_rnode</name><operator>.</operator><name>node</name></name></expr></argument>, <argument><expr><name>forknum</name></expr></argument>, <argument><expr><name><name>seg</name><operator>-&gt;</operator><name>mdfd_segno</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<return>return;</return></block_content></block></if></if_stmt>				<comment type="block">/* passed it off successfully */</comment>

		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not forward fsync request because request queue is full"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>FileSync</name><argument_list>(<argument><expr><name><name>seg</name><operator>-&gt;</operator><name>mdfd_vfd</name></name></expr></argument>, <argument><expr><name>WAIT_EVENT_DATA_FILE_SYNC</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><call><name>data_sync_elevel</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>)</argument_list></call></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not fsync file \"%s\": %m"</literal></expr></argument>,
							<argument><expr><call><name>FilePathName</name><argument_list>(<argument><expr><name><name>seg</name><operator>-&gt;</operator><name>mdfd_vfd</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * register_unlink() -- Schedule a file to be deleted after next checkpoint
 *
 * We don't bother passing in the fork number, because this is only used
 * with main forks.
 *
 * As with register_dirty_segment, this could involve either a local or
 * a remote pending-ops table.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>register_unlink</name><parameter_list>(<parameter><decl><type><name>RelFileNodeBackend</name></type> <name>rnode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* Should never be used with temp relations */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>RelFileNodeBackendIsTemp</name><argument_list>(<argument><expr><name>rnode</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>pendingOpsTable</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* push it into local pending-ops table */</comment>
		<expr_stmt><expr><call><name>RememberFsyncRequest</name><argument_list>(<argument><expr><name><name>rnode</name><operator>.</operator><name>node</name></name></expr></argument>, <argument><expr><name>MAIN_FORKNUM</name></expr></argument>,
							 <argument><expr><name>UNLINK_RELATION_REQUEST</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/*
		 * Notify the checkpointer about it.  If we fail to queue the request
		 * message, we have to sleep and try again, because we can't simply
		 * delete the file now.  Ugly, but hopefully won't happen often.
		 *
		 * XXX should we just leave the file orphaned instead?
		 */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>IsUnderPostmaster</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<while>while <condition>(<expr><operator>!</operator><call><name>ForwardFsyncRequest</name><argument_list>(<argument><expr><name><name>rnode</name><operator>.</operator><name>node</name></name></expr></argument>, <argument><expr><name>MAIN_FORKNUM</name></expr></argument>,
									<argument><expr><name>UNLINK_RELATION_REQUEST</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>pg_usleep</name><argument_list>(<argument><expr><literal type="number">10000L</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></while>	<comment type="block">/* 10 msec seems a good number */</comment>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * RememberFsyncRequest() -- callback from checkpointer side of fsync request
 *
 * We stuff fsync requests into the local hash table for execution
 * during the checkpointer's next checkpoint.  UNLINK requests go into a
 * separate linked list, however, because they get processed separately.
 *
 * The range of possible segment numbers is way less than the range of
 * BlockNumber, so we can reserve high values of segno for special purposes.
 * We define three:
 * - FORGET_RELATION_FSYNC means to cancel pending fsyncs for a relation,
 *	 either for one fork, or all forks if forknum is InvalidForkNumber
 * - FORGET_DATABASE_FSYNC means to cancel pending fsyncs for a whole database
 * - UNLINK_RELATION_REQUEST is a request to delete the file after the next
 *	 checkpoint.
 * Note also that we're assuming real segment numbers don't exceed INT_MAX.
 *
 * (Handling FORGET_DATABASE_FSYNC requests is a tad slow because the hash
 * table has to be searched linearly, but dropping a database is a pretty
 * heavyweight operation anyhow, so we'll live with it.)
 */</comment>
<function><type><name>void</name></type>
<name>RememberFsyncRequest</name><parameter_list>(<parameter><decl><type><name>RelFileNode</name></type> <name>rnode</name></decl></parameter>, <parameter><decl><type><name>ForkNumber</name></type> <name>forknum</name></decl></parameter>, <parameter><decl><type><name>BlockNumber</name></type> <name>segno</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>pendingOpsTable</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>segno</name> <operator>==</operator> <name>FORGET_RELATION_FSYNC</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Remove any pending requests for the relation (one or all forks) */</comment>
		<decl_stmt><decl><type><name>PendingOperationEntry</name> <modifier>*</modifier></type><name>entry</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>entry</name> <operator>=</operator> <operator>(</operator><name>PendingOperationEntry</name> <operator>*</operator><operator>)</operator> <call><name>hash_search</name><argument_list>(<argument><expr><name>pendingOpsTable</name></expr></argument>,
													  <argument><expr><operator>&amp;</operator><name>rnode</name></expr></argument>,
													  <argument><expr><name>HASH_FIND</name></expr></argument>,
													  <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>entry</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * We can't just delete the entry since mdsync could have an
			 * active hashtable scan.  Instead we delete the bitmapsets; this
			 * is safe because of the way mdsync is coded.  We also set the
			 * "canceled" flags so that mdsync can tell that a cancel arrived
			 * for the fork(s).
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name>forknum</name> <operator>==</operator> <name>InvalidForkNumber</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* remove requests for all forks */</comment>
				<for>for <control>(<init><expr><name>forknum</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>forknum</name> <operator>&lt;=</operator> <name>MAX_FORKNUM</name></expr>;</condition> <incr><expr><name>forknum</name><operator>++</operator></expr></incr>)</control>
				<block>{<block_content>
					<expr_stmt><expr><call><name>bms_free</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>requests</name><index>[<expr><name>forknum</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>requests</name><index>[<expr><name>forknum</name></expr>]</index></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>canceled</name><index>[<expr><name>forknum</name></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				</block_content>}</block></for>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<comment type="block">/* remove requests for single fork */</comment>
				<expr_stmt><expr><call><name>bms_free</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>requests</name><index>[<expr><name>forknum</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>requests</name><index>[<expr><name>forknum</name></expr>]</index></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>canceled</name><index>[<expr><name>forknum</name></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>segno</name> <operator>==</operator> <name>FORGET_DATABASE_FSYNC</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Remove any pending requests for the entire database */</comment>
		<decl_stmt><decl><type><name>HASH_SEQ_STATUS</name></type> <name>hstat</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>PendingOperationEntry</name> <modifier>*</modifier></type><name>entry</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>cell</name></decl>,
				   <decl><type ref="prev"><modifier>*</modifier></type><name>prev</name></decl>,
				   <decl><type ref="prev"><modifier>*</modifier></type><name>next</name></decl>;</decl_stmt>

		<comment type="block">/* Remove fsync requests */</comment>
		<expr_stmt><expr><call><name>hash_seq_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>hstat</name></expr></argument>, <argument><expr><name>pendingOpsTable</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<while>while <condition>(<expr><operator>(</operator><name>entry</name> <operator>=</operator> <operator>(</operator><name>PendingOperationEntry</name> <operator>*</operator><operator>)</operator> <call><name>hash_seq_search</name><argument_list>(<argument><expr><operator>&amp;</operator><name>hstat</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name><name>entry</name><operator>-&gt;</operator><name>rnode</name><operator>.</operator><name>dbNode</name></name> <operator>==</operator> <name><name>rnode</name><operator>.</operator><name>dbNode</name></name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* remove requests for all forks */</comment>
				<for>for <control>(<init><expr><name>forknum</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>forknum</name> <operator>&lt;=</operator> <name>MAX_FORKNUM</name></expr>;</condition> <incr><expr><name>forknum</name><operator>++</operator></expr></incr>)</control>
				<block>{<block_content>
					<expr_stmt><expr><call><name>bms_free</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>requests</name><index>[<expr><name>forknum</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>requests</name><index>[<expr><name>forknum</name></expr>]</index></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>canceled</name><index>[<expr><name>forknum</name></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				</block_content>}</block></for>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></while>

		<comment type="block">/* Remove unlink requests */</comment>
		<expr_stmt><expr><name>prev</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<for>for <control>(<init><expr><name>cell</name> <operator>=</operator> <call><name>list_head</name><argument_list>(<argument><expr><name>pendingUnlinks</name></expr></argument>)</argument_list></call></expr>;</init> <condition><expr><name>cell</name></expr>;</condition> <incr><expr><name>cell</name> <operator>=</operator> <name>next</name></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>PendingUnlinkEntry</name> <modifier>*</modifier></type><name>entry</name> <init>= <expr><operator>(</operator><name>PendingUnlinkEntry</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>cell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><name>next</name> <operator>=</operator> <call><name>lnext</name><argument_list>(<argument><expr><name>cell</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>entry</name><operator>-&gt;</operator><name>rnode</name><operator>.</operator><name>dbNode</name></name> <operator>==</operator> <name><name>rnode</name><operator>.</operator><name>dbNode</name></name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>pendingUnlinks</name> <operator>=</operator> <call><name>list_delete_cell</name><argument_list>(<argument><expr><name>pendingUnlinks</name></expr></argument>, <argument><expr><name>cell</name></expr></argument>, <argument><expr><name>prev</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>entry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name>prev</name> <operator>=</operator> <name>cell</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
		</block_content>}</block></for>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>segno</name> <operator>==</operator> <name>UNLINK_RELATION_REQUEST</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcxt</name> <init>= <expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>pendingOpsCxt</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>PendingUnlinkEntry</name> <modifier>*</modifier></type><name>entry</name></decl>;</decl_stmt>

		<comment type="block">/* PendingUnlinkEntry doesn't store forknum, since it's always MAIN */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>forknum</name> <operator>==</operator> <name>MAIN_FORKNUM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>entry</name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>PendingUnlinkEntry</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>rnode</name></name> <operator>=</operator> <name>rnode</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>cycle_ctr</name></name> <operator>=</operator> <name>mdckpt_cycle_ctr</name></expr>;</expr_stmt>

		<expr_stmt><expr><name>pendingUnlinks</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>pendingUnlinks</name></expr></argument>, <argument><expr><name>entry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* Normal case: enter a request to fsync this segment */</comment>
		<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcxt</name> <init>= <expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>pendingOpsCxt</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>PendingOperationEntry</name> <modifier>*</modifier></type><name>entry</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>found</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>entry</name> <operator>=</operator> <operator>(</operator><name>PendingOperationEntry</name> <operator>*</operator><operator>)</operator> <call><name>hash_search</name><argument_list>(<argument><expr><name>pendingOpsTable</name></expr></argument>,
													  <argument><expr><operator>&amp;</operator><name>rnode</name></expr></argument>,
													  <argument><expr><name>HASH_ENTER</name></expr></argument>,
													  <argument><expr><operator>&amp;</operator><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* if new entry, initialize it */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>found</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>cycle_ctr</name></name> <operator>=</operator> <name>mdsync_cycle_ctr</name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>requests</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>requests</name></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>canceled</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>canceled</name></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * NB: it's intentional that we don't change cycle_ctr if the entry
		 * already exists.  The cycle_ctr must represent the oldest fsync
		 * request that could be in the entry.
		 */</comment>

		<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>requests</name><index>[<expr><name>forknum</name></expr>]</index></name> <operator>=</operator> <call><name>bms_add_member</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>requests</name><index>[<expr><name>forknum</name></expr>]</index></name></expr></argument>,
												  <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name>segno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * ForgetRelationFsyncRequests -- forget any fsyncs for a relation fork
 *
 * forknum == InvalidForkNumber means all forks, although this code doesn't
 * actually know that, since it's just forwarding the request elsewhere.
 */</comment>
<function><type><name>void</name></type>
<name>ForgetRelationFsyncRequests</name><parameter_list>(<parameter><decl><type><name>RelFileNode</name></type> <name>rnode</name></decl></parameter>, <parameter><decl><type><name>ForkNumber</name></type> <name>forknum</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>pendingOpsTable</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* standalone backend or startup process: fsync state is local */</comment>
		<expr_stmt><expr><call><name>RememberFsyncRequest</name><argument_list>(<argument><expr><name>rnode</name></expr></argument>, <argument><expr><name>forknum</name></expr></argument>, <argument><expr><name>FORGET_RELATION_FSYNC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>IsUnderPostmaster</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Notify the checkpointer about it.  If we fail to queue the cancel
		 * message, we have to sleep and try again ... ugly, but hopefully
		 * won't happen often.
		 *
		 * XXX should we CHECK_FOR_INTERRUPTS in this loop?  Escaping with an
		 * error would leave the no-longer-used file still present on disk,
		 * which would be bad, so I'm inclined to assume that the checkpointer
		 * will always empty the queue soon.
		 */</comment>
		<while>while <condition>(<expr><operator>!</operator><call><name>ForwardFsyncRequest</name><argument_list>(<argument><expr><name>rnode</name></expr></argument>, <argument><expr><name>forknum</name></expr></argument>, <argument><expr><name>FORGET_RELATION_FSYNC</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>pg_usleep</name><argument_list>(<argument><expr><literal type="number">10000L</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></while>	<comment type="block">/* 10 msec seems a good number */</comment>

		<comment type="block">/*
		 * Note we don't wait for the checkpointer to actually absorb the
		 * cancel message; see mdsync() for the implications.
		 */</comment>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * ForgetDatabaseFsyncRequests -- forget any fsyncs and unlinks for a DB
 */</comment>
<function><type><name>void</name></type>
<name>ForgetDatabaseFsyncRequests</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>dbid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>RelFileNode</name></type> <name>rnode</name></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>rnode</name><operator>.</operator><name>dbNode</name></name> <operator>=</operator> <name>dbid</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rnode</name><operator>.</operator><name>spcNode</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rnode</name><operator>.</operator><name>relNode</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>pendingOpsTable</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* standalone backend or startup process: fsync state is local */</comment>
		<expr_stmt><expr><call><name>RememberFsyncRequest</name><argument_list>(<argument><expr><name>rnode</name></expr></argument>, <argument><expr><name>InvalidForkNumber</name></expr></argument>, <argument><expr><name>FORGET_DATABASE_FSYNC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>IsUnderPostmaster</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* see notes in ForgetRelationFsyncRequests */</comment>
		<while>while <condition>(<expr><operator>!</operator><call><name>ForwardFsyncRequest</name><argument_list>(<argument><expr><name>rnode</name></expr></argument>, <argument><expr><name>InvalidForkNumber</name></expr></argument>,
									<argument><expr><name>FORGET_DATABASE_FSYNC</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>pg_usleep</name><argument_list>(<argument><expr><literal type="number">10000L</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></while>	<comment type="block">/* 10 msec seems a good number */</comment>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * DropRelationFiles -- drop files of all given relations
 */</comment>
<function><type><name>void</name></type>
<name>DropRelationFiles</name><parameter_list>(<parameter><decl><type><name>RelFileNode</name> <modifier>*</modifier></type><name>delrels</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>ndelrels</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>isRedo</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>SMgrRelation</name> <modifier>*</modifier></type><name>srels</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>srels</name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>SMgrRelation</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>ndelrels</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>ndelrels</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>SMgrRelation</name></type> <name>srel</name> <init>= <expr><call><name>smgropen</name><argument_list>(<argument><expr><name><name>delrels</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>InvalidBackendId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>isRedo</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>ForkNumber</name></type>	<name>fork</name></decl>;</decl_stmt>

			<for>for <control>(<init><expr><name>fork</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>fork</name> <operator>&lt;=</operator> <name>MAX_FORKNUM</name></expr>;</condition> <incr><expr><name>fork</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>XLogDropRelation</name><argument_list>(<argument><expr><name><name>delrels</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>fork</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><name><name>srels</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>srel</name></expr>;</expr_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>smgrdounlinkall</name><argument_list>(<argument><expr><name>srels</name></expr></argument>, <argument><expr><name>ndelrels</name></expr></argument>, <argument><expr><name>isRedo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>ndelrels</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>smgrclose</name><argument_list>(<argument><expr><name><name>srels</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>srels</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 *	_fdvec_resize() -- Resize the fork's open segments array
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>_fdvec_resize</name><parameter_list>(<parameter><decl><type><name>SMgrRelation</name></type> <name>reln</name></decl></parameter>,
			  <parameter><decl><type><name>ForkNumber</name></type> <name>forknum</name></decl></parameter>,
			  <parameter><decl><type><name>int</name></type> <name>nseg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>nseg</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>reln</name><operator>-&gt;</operator><name>md_num_open_segs</name><index>[<expr><name>forknum</name></expr>]</index></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>reln</name><operator>-&gt;</operator><name>md_seg_fds</name><index>[<expr><name>forknum</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>reln</name><operator>-&gt;</operator><name>md_seg_fds</name><index>[<expr><name>forknum</name></expr>]</index></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name><name>reln</name><operator>-&gt;</operator><name>md_num_open_segs</name><index>[<expr><name>forknum</name></expr>]</index></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>reln</name><operator>-&gt;</operator><name>md_seg_fds</name><index>[<expr><name>forknum</name></expr>]</index></name> <operator>=</operator>
			<call><name>MemoryContextAlloc</name><argument_list>(<argument><expr><name>MdCxt</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>MdfdVec</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>nseg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/*
		 * It doesn't seem worthwhile complicating the code to amortize
		 * repalloc() calls.  Those are far faster than PathNameOpenFile() or
		 * FileClose(), and the memory context internally will sometimes avoid
		 * doing an actual reallocation.
		 */</comment>
		<expr_stmt><expr><name><name>reln</name><operator>-&gt;</operator><name>md_seg_fds</name><index>[<expr><name>forknum</name></expr>]</index></name> <operator>=</operator>
			<call><name>repalloc</name><argument_list>(<argument><expr><name><name>reln</name><operator>-&gt;</operator><name>md_seg_fds</name><index>[<expr><name>forknum</name></expr>]</index></name></expr></argument>,
					 <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>MdfdVec</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>nseg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><name><name>reln</name><operator>-&gt;</operator><name>md_num_open_segs</name><index>[<expr><name>forknum</name></expr>]</index></name> <operator>=</operator> <name>nseg</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Return the filename for the specified segment of the relation. The
 * returned string is palloc'd.
 */</comment>
<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type>
<name>_mdfd_segpath</name><parameter_list>(<parameter><decl><type><name>SMgrRelation</name></type> <name>reln</name></decl></parameter>, <parameter><decl><type><name>ForkNumber</name></type> <name>forknum</name></decl></parameter>, <parameter><decl><type><name>BlockNumber</name></type> <name>segno</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>path</name></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name>fullpath</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>path</name> <operator>=</operator> <call><name>relpath</name><argument_list>(<argument><expr><name><name>reln</name><operator>-&gt;</operator><name>smgr_rnode</name></name></expr></argument>, <argument><expr><name>forknum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>segno</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>fullpath</name> <operator>=</operator> <call><name>psprintf</name><argument_list>(<argument><expr><literal type="string">"%s.%u"</literal></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>segno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>fullpath</name> <operator>=</operator> <name>path</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<return>return <expr><name>fullpath</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Open the specified segment of the relation,
 * and make a MdfdVec object for it.  Returns NULL on failure.
 */</comment>
<function><type><specifier>static</specifier> <name>MdfdVec</name> <modifier>*</modifier></type>
<name>_mdfd_openseg</name><parameter_list>(<parameter><decl><type><name>SMgrRelation</name></type> <name>reln</name></decl></parameter>, <parameter><decl><type><name>ForkNumber</name></type> <name>forknum</name></decl></parameter>, <parameter><decl><type><name>BlockNumber</name></type> <name>segno</name></decl></parameter>,
			  <parameter><decl><type><name>int</name></type> <name>oflags</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>MdfdVec</name>    <modifier>*</modifier></type><name>v</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>fd</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>fullpath</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>flags</name> <init>= <expr><name>PG_BINARY</name> <operator>|</operator> <name>oflags</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* POLAR: read datafile only need O_RDONLY flag in replica */</comment>
	<if_stmt><if>if <condition>(<expr><name>polar_openfile_with_readonly_in_replica</name> <operator>&amp;&amp;</operator>
		<call><name>polar_in_replica_mode</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>flags</name> <operator>|=</operator> <name>O_RDONLY</name></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>flags</name> <operator>|=</operator> <name>O_RDWR</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<expr_stmt><expr><name>fullpath</name> <operator>=</operator> <call><name>_mdfd_segpath</name><argument_list>(<argument><expr><name>reln</name></expr></argument>, <argument><expr><name>forknum</name></expr></argument>, <argument><expr><name>segno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* open the file */</comment>
	<expr_stmt><expr><name>fd</name> <operator>=</operator> <call><name>polar_path_name_open_file</name><argument_list>(<argument><expr><name>fullpath</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>fullpath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>fd</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>segno</name> <operator>&lt;=</operator> <name><name>reln</name><operator>-&gt;</operator><name>md_num_open_segs</name><index>[<expr><name>forknum</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>_fdvec_resize</name><argument_list>(<argument><expr><name>reln</name></expr></argument>, <argument><expr><name>forknum</name></expr></argument>, <argument><expr><name>segno</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* fill the entry */</comment>
	<expr_stmt><expr><name>v</name> <operator>=</operator> <operator>&amp;</operator><name><name>reln</name><operator>-&gt;</operator><name>md_seg_fds</name><index>[<expr><name>forknum</name></expr>]</index><index>[<expr><name>segno</name></expr>]</index></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>v</name><operator>-&gt;</operator><name>mdfd_vfd</name></name> <operator>=</operator> <name>fd</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>v</name><operator>-&gt;</operator><name>mdfd_segno</name></name> <operator>=</operator> <name>segno</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>_mdnblocks</name><argument_list>(<argument><expr><name>reln</name></expr></argument>, <argument><expr><name>forknum</name></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call> <operator>&lt;=</operator> <operator>(</operator><operator>(</operator><name>BlockNumber</name><operator>)</operator> <name>RELSEG_SIZE</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* all done */</comment>
	<return>return <expr><name>v</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 *	_mdfd_getseg() -- Find the segment of the relation holding the
 *		specified block.
 *
 * If the segment doesn't exist, we ereport, return NULL, or create the
 * segment, according to "behavior".  Note: skipFsync is only used in the
 * EXTENSION_CREATE case.
 */</comment>
<function><type><specifier>static</specifier> <name>MdfdVec</name> <modifier>*</modifier></type>
<name>_mdfd_getseg</name><parameter_list>(<parameter><decl><type><name>SMgrRelation</name></type> <name>reln</name></decl></parameter>, <parameter><decl><type><name>ForkNumber</name></type> <name>forknum</name></decl></parameter>, <parameter><decl><type><name>BlockNumber</name></type> <name>blkno</name></decl></parameter>,
			 <parameter><decl><type><name>bool</name></type> <name>skipFsync</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>behavior</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>MdfdVec</name>    <modifier>*</modifier></type><name>v</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BlockNumber</name></type> <name>targetseg</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BlockNumber</name></type> <name>nextsegno</name></decl>;</decl_stmt>

	<comment type="block">/* some way to handle non-existent segments needs to be specified */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>behavior</name> <operator>&amp;</operator>
		   <operator>(</operator><name>EXTENSION_FAIL</name> <operator>|</operator> <name>EXTENSION_CREATE</name> <operator>|</operator> <name>EXTENSION_RETURN_NULL</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>targetseg</name> <operator>=</operator> <name>blkno</name> <operator>/</operator> <operator>(</operator><operator>(</operator><name>BlockNumber</name><operator>)</operator> <name>RELSEG_SIZE</name><operator>)</operator></expr>;</expr_stmt>

	<comment type="block">/* if an existing and opened segment, we're done */</comment>
	<if_stmt><if>if <condition>(<expr><name>targetseg</name> <operator>&lt;</operator> <name><name>reln</name><operator>-&gt;</operator><name>md_num_open_segs</name><index>[<expr><name>forknum</name></expr>]</index></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>v</name> <operator>=</operator> <operator>&amp;</operator><name><name>reln</name><operator>-&gt;</operator><name>md_seg_fds</name><index>[<expr><name>forknum</name></expr>]</index><index>[<expr><name>targetseg</name></expr>]</index></name></expr>;</expr_stmt>
		<return>return <expr><name>v</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * The target segment is not yet open. Iterate over all the segments
	 * between the last opened and the target segment. This way missing
	 * segments either raise an error, or get created (according to
	 * 'behavior'). Start with either the last opened, or the first segment if
	 * none was opened before.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>reln</name><operator>-&gt;</operator><name>md_num_open_segs</name><index>[<expr><name>forknum</name></expr>]</index></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>v</name> <operator>=</operator> <operator>&amp;</operator><name><name>reln</name><operator>-&gt;</operator><name>md_seg_fds</name><index>[<expr><name>forknum</name></expr>]</index><index>[<expr><name><name>reln</name><operator>-&gt;</operator><name>md_num_open_segs</name><index>[<expr><name>forknum</name></expr>]</index></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt></block_content></block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name>v</name> <operator>=</operator> <call><name>mdopen</name><argument_list>(<argument><expr><name>reln</name></expr></argument>, <argument><expr><name>forknum</name></expr></argument>, <argument><expr><name>behavior</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>v</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>		<comment type="block">/* if behavior &amp; EXTENSION_RETURN_NULL */</comment>
	</block_content>}</block></else></if_stmt>

	<for>for <control>(<init><expr><name>nextsegno</name> <operator>=</operator> <name><name>reln</name><operator>-&gt;</operator><name>md_num_open_segs</name><index>[<expr><name>forknum</name></expr>]</index></name></expr>;</init>
		 <condition><expr><name>nextsegno</name> <operator>&lt;=</operator> <name>targetseg</name></expr>;</condition> <incr><expr><name>nextsegno</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>BlockNumber</name></type> <name>nblocks</name> <init>= <expr><call><name>_mdnblocks</name><argument_list>(<argument><expr><name>reln</name></expr></argument>, <argument><expr><name>forknum</name></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>flags</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>nextsegno</name> <operator>==</operator> <name><name>v</name><operator>-&gt;</operator><name>mdfd_segno</name></name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>nblocks</name> <operator>&gt;</operator> <operator>(</operator><operator>(</operator><name>BlockNumber</name><operator>)</operator> <name>RELSEG_SIZE</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>, <argument><expr><literal type="string">"segment too big"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/* POLAR: replica cannot create/extend file anytime */</comment>
		<if_stmt><if>if <condition>(<expr><operator>(</operator><name>behavior</name> <operator>&amp;</operator> <name>EXTENSION_CREATE</name><operator>)</operator> <operator>||</operator>
			<operator>(</operator><operator>!</operator><call><name>polar_in_replica_mode</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <name>InRecovery</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>behavior</name> <operator>&amp;</operator> <name>EXTENSION_CREATE_RECOVERY</name><operator>)</operator><operator>)</operator></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * Normally we will create new segments only if authorized by the
			 * caller (i.e., we are doing mdextend()).  But when doing WAL
			 * recovery, create segments anyway; this allows cases such as
			 * replaying WAL data that has a write into a high-numbered
			 * segment of a relation that was later deleted. We want to go
			 * ahead and create the segments so we can finish out the replay.
			 * However if the caller has specified
			 * EXTENSION_REALLY_RETURN_NULL, then extension is not desired
			 * even in recovery; we won't reach this point in that case.
			 *
			 * We have to maintain the invariant that segments before the last
			 * active segment are of size RELSEG_SIZE; therefore, if
			 * extending, pad them out with zeroes if needed.  (This only
			 * matters if in recovery, or if the caller is extending the
			 * relation discontiguously, but that can happen in hash indexes.)
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name>nblocks</name> <operator>&lt;</operator> <operator>(</operator><operator>(</operator><name>BlockNumber</name><operator>)</operator> <name>RELSEG_SIZE</name><operator>)</operator></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>zerobuf</name> <init>= <expr><call><name>palloc0</name><argument_list>(<argument><expr><name>BLCKSZ</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>mdextend</name><argument_list>(<argument><expr><name>reln</name></expr></argument>, <argument><expr><name>forknum</name></expr></argument>,
						 <argument><expr><name>nextsegno</name> <operator>*</operator> <operator>(</operator><operator>(</operator><name>BlockNumber</name><operator>)</operator> <name>RELSEG_SIZE</name><operator>)</operator> <operator>-</operator> <literal type="number">1</literal></expr></argument>,
						 <argument><expr><name>zerobuf</name></expr></argument>, <argument><expr><name>skipFsync</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>zerobuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			<expr_stmt><expr><name>flags</name> <operator>=</operator> <name>O_CREAT</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><operator>!</operator><operator>(</operator><name>behavior</name> <operator>&amp;</operator> <name>EXTENSION_DONT_CHECK_SIZE</name><operator>)</operator> <operator>&amp;&amp;</operator>
				 <name>nblocks</name> <operator>&lt;</operator> <operator>(</operator><operator>(</operator><name>BlockNumber</name><operator>)</operator> <name>RELSEG_SIZE</name><operator>)</operator></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * When not extending (or explicitly including truncated
			 * segments), only open the next segment if the current one is
			 * exactly RELSEG_SIZE.  If not (this branch), either return NULL
			 * or fail.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name>behavior</name> <operator>&amp;</operator> <name>EXTENSION_RETURN_NULL</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/*
				 * Some callers discern between reasons for _mdfd_getseg()
				 * returning NULL based on errno. As there's no failing
				 * syscall involved in this case, explicitly set errno to
				 * ENOENT, as that seems the closest interpretation.
				 */</comment>
				<expr_stmt><expr><name>errno</name> <operator>=</operator> <name>ENOENT</name></expr>;</expr_stmt>
				<return>return <expr><name>NULL</name></expr>;</return>
			</block_content>}</block></if></if_stmt>

			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not open file \"%s\" (target block %u): previous segment is only %u blocks"</literal></expr></argument>,
							<argument><expr><call><name>_mdfd_segpath</name><argument_list>(<argument><expr><name>reln</name></expr></argument>, <argument><expr><name>forknum</name></expr></argument>, <argument><expr><name>nextsegno</name></expr></argument>)</argument_list></call></expr></argument>,
							<argument><expr><name>blkno</name></expr></argument>, <argument><expr><name>nblocks</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name>v</name> <operator>=</operator> <call><name>_mdfd_openseg</name><argument_list>(<argument><expr><name>reln</name></expr></argument>, <argument><expr><name>forknum</name></expr></argument>, <argument><expr><name>nextsegno</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>v</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><operator>(</operator><name>behavior</name> <operator>&amp;</operator> <name>EXTENSION_RETURN_NULL</name><operator>)</operator> <operator>&amp;&amp;</operator>
				<call><name>FILE_POSSIBLY_DELETED</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not open file \"%s\" (target block %u): %m"</literal></expr></argument>,
							<argument><expr><call><name>_mdfd_segpath</name><argument_list>(<argument><expr><name>reln</name></expr></argument>, <argument><expr><name>forknum</name></expr></argument>, <argument><expr><name>nextsegno</name></expr></argument>)</argument_list></call></expr></argument>,
							<argument><expr><name>blkno</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>

	<return>return <expr><name>v</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Get number of blocks present in a single disk file
 */</comment>
<function><type><specifier>static</specifier> <name>BlockNumber</name></type>
<name>_mdnblocks</name><parameter_list>(<parameter><decl><type><name>SMgrRelation</name></type> <name>reln</name></decl></parameter>, <parameter><decl><type><name>ForkNumber</name></type> <name>forknum</name></decl></parameter>, <parameter><decl><type><name>MdfdVec</name> <modifier>*</modifier></type><name>seg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>off_t</name></type>		<name>len</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>FileSeek</name><argument_list>(<argument><expr><name><name>seg</name><operator>-&gt;</operator><name>mdfd_vfd</name></name></expr></argument>, <argument><expr><literal type="number">0L</literal></expr></argument>, <argument><expr><name>SEEK_END</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>len</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not seek to end of file \"%s\": %m"</literal></expr></argument>,
						<argument><expr><call><name>FilePathName</name><argument_list>(<argument><expr><name><name>seg</name><operator>-&gt;</operator><name>mdfd_vfd</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<comment type="block">/* note that this calculation will ignore any partial block at EOF */</comment>
	<return>return <expr><operator>(</operator><name>BlockNumber</name><operator>)</operator> <operator>(</operator><name>len</name> <operator>/</operator> <name>BLCKSZ</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 *	mdextendbatch() -- Add a block to the specified relation.
 *
 *		The semantics are nearly the same as mdwrite(): write at the
 *		specified position.  However, this is to be used for the case of
 *		extending a relation (i.e., blocknum is at or beyond the current
 *		EOF).  Note that we assume writing a block beyond current EOF
 *		causes intervening file space to become filled with zeroes.
 */</comment>
<function><type><name>void</name></type>
<name>mdextendbatch</name><parameter_list>(<parameter><decl><type><name>SMgrRelation</name></type> <name>reln</name></decl></parameter>, <parameter><decl><type><name>ForkNumber</name></type> <name>forknum</name></decl></parameter>, <parameter><decl><type><name>BlockNumber</name></type> <name>blocknum</name></decl></parameter>,
		 <parameter><decl><type><name>int</name></type> <name>blockCount</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>buffer</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>skipFsync</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>off_t</name></type>		<name>seekpos</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>nbytes</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MdfdVec</name>    <modifier>*</modifier></type><name>v</name></decl>;</decl_stmt>

	<comment type="block">/* This assert is too expensive to have on normally ... */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>CHECK_WRITE_VS_EXTEND</name></cpp:ifdef>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>blocknum</name> <operator>&gt;=</operator> <call><name>mdnblocks</name><argument_list>(<argument><expr><name>reln</name></expr></argument>, <argument><expr><name>forknum</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<comment type="block">/*
	 * If a relation manages to grow to 2^32-1 blocks, refuse to extend it any
	 * more --- we mustn't create a block whose number actually is
	 * InvalidBlockNumber.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>blocknum</name> <operator>==</operator> <name>InvalidBlockNumber</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_PROGRAM_LIMIT_EXCEEDED</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot extend file \"%s\" beyond %u blocks"</literal></expr></argument>,
						<argument><expr><call><name>relpath</name><argument_list>(<argument><expr><name><name>reln</name><operator>-&gt;</operator><name>smgr_rnode</name></name></expr></argument>, <argument><expr><name>forknum</name></expr></argument>)</argument_list></call></expr></argument>,
						<argument><expr><name>InvalidBlockNumber</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>v</name> <operator>=</operator> <call><name>_mdfd_getseg</name><argument_list>(<argument><expr><name>reln</name></expr></argument>, <argument><expr><name>forknum</name></expr></argument>, <argument><expr><name>blocknum</name></expr></argument>, <argument><expr><name>skipFsync</name></expr></argument>, <argument><expr><name>EXTENSION_CREATE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>seekpos</name> <operator>=</operator> <operator>(</operator><name>off_t</name><operator>)</operator> <name>BLCKSZ</name> <operator>*</operator> <operator>(</operator><name>blocknum</name> <operator>%</operator> <operator>(</operator><operator>(</operator><name>BlockNumber</name><operator>)</operator> <name>RELSEG_SIZE</name><operator>)</operator><operator>)</operator></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>seekpos</name> <operator>&lt;</operator> <operator>(</operator><name>off_t</name><operator>)</operator> <name>BLCKSZ</name> <operator>*</operator> <name>RELSEG_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* We assum all the block in the same segment file */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>(</operator><name>off_t</name><operator>)</operator> <name>BLCKSZ</name> <operator>*</operator> <operator>(</operator><operator>(</operator><name>blocknum</name> <operator>+</operator> <name>blockCount</name><operator>)</operator> <operator>%</operator> <operator>(</operator><operator>(</operator><name>BlockNumber</name><operator>)</operator> <name>RELSEG_SIZE</name><operator>)</operator><operator>)</operator> <operator>&lt;</operator> <operator>(</operator><name>off_t</name><operator>)</operator> <name>BLCKSZ</name> <operator>*</operator> <name>RELSEG_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>nbytes</name> <operator>=</operator> <call><name>polar_file_pwrite</name><argument_list>(<argument><expr><name><name>v</name><operator>-&gt;</operator><name>mdfd_vfd</name></name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>BLCKSZ</name> <operator>*</operator> <name>blockCount</name></expr></argument>, <argument><expr><name>seekpos</name></expr></argument>,
			<argument><expr><name>WAIT_EVENT_DATA_FILE_BATCH_PWRITE_EXTEND</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>BLCKSZ</name> <operator>*</operator> <name>blockCount</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>nbytes</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not extend file \"%s\": %m"</literal></expr></argument>,
							<argument><expr><call><name>FilePathName</name><argument_list>(<argument><expr><name><name>v</name><operator>-&gt;</operator><name>mdfd_vfd</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Check free disk space."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<comment type="block">/* short write: complain appropriately */</comment>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DISK_FULL</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not extend file \"%s\": wrote only %d of %d bytes at block %u"</literal></expr></argument>,
						<argument><expr><call><name>FilePathName</name><argument_list>(<argument><expr><name><name>v</name><operator>-&gt;</operator><name>mdfd_vfd</name></name></expr></argument>)</argument_list></call></expr></argument>,
						<argument><expr><name>nbytes</name></expr></argument>, <argument><expr><name>BLCKSZ</name> <operator>*</operator> <name>blockCount</name></expr></argument>, <argument><expr><name>blocknum</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Check free disk space."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>skipFsync</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>SmgrIsTemp</name><argument_list>(<argument><expr><name>reln</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>register_dirty_segment</name><argument_list>(<argument><expr><name>reln</name></expr></argument>, <argument><expr><name>forknum</name></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<function><type><name>bool</name></type>
<name>polar_need_skip_request</name><parameter_list>(<parameter><decl><type><name>BlockNumber</name></type> <name>segno</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type> <name>polar_need_skip</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* POLAR: bgwriter not unlink file and sync file from other process */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>AmCheckpointerProcess</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>polar_need_skip</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>AmPolarBackgroundWriterProcess</name><argument_list>()</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>segno</name> <operator>==</operator> <name>FORGET_DATABASE_FSYNC</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>polar_need_skip</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if<condition>(<expr><name>segno</name> <operator>==</operator> <name>FORGET_RELATION_FSYNC</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>polar_need_skip</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>polar_need_skip</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>BlockNumber</name></type>
<name>polar_cache_mdnblocks</name><parameter_list>(<parameter><decl><type><name>SMgrRelation</name></type> <name>reln</name></decl></parameter>, <parameter><decl><type><name>ForkNumber</name></type> <name>forknum</name></decl></parameter>, <parameter><decl><type><name>MdfdVec</name> <modifier>*</modifier></type><name>seg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>off_t</name></type>		<name>len</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>File</name></type>		<name>file</name> <init>= <expr><name><name>seg</name><operator>-&gt;</operator><name>mdfd_vfd</name></name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>polar_file_seek_end</name><argument_list>(<argument><expr><name>file</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>len</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not seek to end of file \"%s\": %m"</literal></expr></argument>,
						<argument><expr><call><name>FilePathName</name><argument_list>(<argument><expr><name><name>seg</name><operator>-&gt;</operator><name>mdfd_vfd</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<comment type="block">/* note that this calculation will ignore any partial block at EOF */</comment>
	<return>return <expr><operator>(</operator><name>BlockNumber</name><operator>)</operator> <operator>(</operator><name>len</name> <operator>/</operator> <name>BLCKSZ</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

</unit>
