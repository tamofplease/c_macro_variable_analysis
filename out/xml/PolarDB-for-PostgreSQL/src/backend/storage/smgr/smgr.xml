<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/PolarDB-for-PostgreSQL/src/backend/storage/smgr/smgr.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * smgr.c
 *	  public interface routines to storage manager switch.
 *
 *	  All file system operations in POSTGRES dispatch through these
 *	  routines.
 *
 * Portions Copyright (c) 1996-2018, PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, Regents of the University of California
 *
 *
 * IDENTIFICATION
 *	  src/backend/storage/smgr/smgr.c
 *
 *-------------------------------------------------------------------------
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/xlog.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pgstat.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/tablespace.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lib/ilist.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"port/atomics.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"port/pg_bitutils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/bufmgr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/shmem.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/ipc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/lwlock.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/s_lock.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/smgr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/hsearch.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/inval.h"</cpp:file></cpp:include>

<comment type="block">/* POLAR */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/polar_logindex_redo.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/guc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/rel.h"</cpp:file></cpp:include>

<comment type="block">/*
 * An entry in the hash table that allows us to look up objects in the
 * SMgrSharedRelation pool by rnode (+ backend).
 */</comment>
<typedef>typedef <type><struct>struct <name>SMgrSharedRelationMapping</name>
<block>{
	<decl_stmt><decl><type><name>RelFileNodeBackend</name></type> <name>rnode</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>				<name>index</name></decl>;</decl_stmt>
}</block></struct></type> <name>SMgrSharedRelationMapping</name>;</typedef>

<decl_stmt><decl><type><specifier>static</specifier> <name>SMgrSharedRelationPool</name> <modifier>*</modifier></type><name>sr_pool</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>HTAB</name> <modifier>*</modifier></type><name>sr_mapping_table</name></decl>;</decl_stmt>

<comment type="block">/*
 * This struct of function pointers defines the API between smgr.c and
 * any individual storage manager module.  Note that smgr subfunctions are
 * generally expected to report problems via elog(ERROR).  An exception is
 * that smgr_unlink should use elog(WARNING), rather than erroring out,
 * because we normally unlink relations during post-commit/abort cleanup,
 * and so it's too late to raise an error.  Also, various conditions that
 * would normally be errors should be allowed during bootstrap and/or WAL
 * recovery --- see comments in md.c for details.
 */</comment>
<typedef>typedef <type><struct>struct <name>f_smgr</name>
<block>{
	<function_decl><type><name>void</name></type>		(<modifier>*</modifier><name>smgr_init</name>) <parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>	<comment type="block">/* may be NULL */</comment>
	<function_decl><type><name>void</name></type>		(<modifier>*</modifier><name>smgr_shutdown</name>) <parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>	<comment type="block">/* may be NULL */</comment>
	<function_decl><type><name>void</name></type>		(<modifier>*</modifier><name>smgr_close</name>) <parameter_list>(<parameter><decl><type><name>SMgrRelation</name></type> <name>reln</name></decl></parameter>, <parameter><decl><type><name>ForkNumber</name></type> <name>forknum</name></decl></parameter>)</parameter_list>;</function_decl>
	<function_decl><type><name>void</name></type>		(<modifier>*</modifier><name>smgr_create</name>) <parameter_list>(<parameter><decl><type><name>SMgrRelation</name></type> <name>reln</name></decl></parameter>, <parameter><decl><type><name>ForkNumber</name></type> <name>forknum</name></decl></parameter>,
								<parameter><decl><type><name>bool</name></type> <name>isRedo</name></decl></parameter>)</parameter_list>;</function_decl>
	<function_decl><type><name>bool</name></type>		(<modifier>*</modifier><name>smgr_exists</name>) <parameter_list>(<parameter><decl><type><name>SMgrRelation</name></type> <name>reln</name></decl></parameter>, <parameter><decl><type><name>ForkNumber</name></type> <name>forknum</name></decl></parameter>)</parameter_list>;</function_decl>
	<function_decl><type><name>void</name></type>		(<modifier>*</modifier><name>smgr_unlink</name>) <parameter_list>(<parameter><decl><type><name>RelFileNodeBackend</name></type> <name>rnode</name></decl></parameter>, <parameter><decl><type><name>ForkNumber</name></type> <name>forknum</name></decl></parameter>,
								<parameter><decl><type><name>bool</name></type> <name>isRedo</name></decl></parameter>)</parameter_list>;</function_decl>
	<function_decl><type><name>void</name></type>		(<modifier>*</modifier><name>smgr_extend</name>) <parameter_list>(<parameter><decl><type><name>SMgrRelation</name></type> <name>reln</name></decl></parameter>, <parameter><decl><type><name>ForkNumber</name></type> <name>forknum</name></decl></parameter>,
								<parameter><decl><type><name>BlockNumber</name></type> <name>blocknum</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>buffer</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>skipFsync</name></decl></parameter>)</parameter_list>;</function_decl>
	<function_decl><type><name>void</name></type>		(<modifier>*</modifier><name>smgr_extendbatch</name>) <parameter_list>(<parameter><decl><type><name>SMgrRelation</name></type> <name>reln</name></decl></parameter>, <parameter><decl><type><name>ForkNumber</name></type> <name>forknum</name></decl></parameter>,
								<parameter><decl><type><name>BlockNumber</name></type> <name>blocknum</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>blockCount</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>buffer</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>skipFsync</name></decl></parameter>)</parameter_list>;</function_decl>
	<function_decl><type><name>void</name></type>		(<modifier>*</modifier><name>smgr_prefetch</name>) <parameter_list>(<parameter><decl><type><name>SMgrRelation</name></type> <name>reln</name></decl></parameter>, <parameter><decl><type><name>ForkNumber</name></type> <name>forknum</name></decl></parameter>,
								  <parameter><decl><type><name>BlockNumber</name></type> <name>blocknum</name></decl></parameter>)</parameter_list>;</function_decl>
	<comment type="block">/* POLAR: bulk read */</comment>
	<function_decl><type><name>void</name></type>        (<modifier>*</modifier><name>polar_smgr_bulkread</name>) <parameter_list>(<parameter><decl><type><name>SMgrRelation</name></type> <name>reln</name></decl></parameter>, <parameter><decl><type><name>ForkNumber</name></type> <name>forknum</name></decl></parameter>, <parameter><decl><type><name>BlockNumber</name></type> <name>blocknum</name></decl></parameter>,
										<parameter><decl><type><name>int</name></type> <name>blockCount</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>buffer</name></decl></parameter>)</parameter_list>;</function_decl>
	<comment type="block">/* POLAR end */</comment>
	<function_decl><type><name>void</name></type>        (<modifier>*</modifier><name>polar_smgr_bulkwrite</name>) <parameter_list>(<parameter><decl><type><name>SMgrRelation</name></type> <name>reln</name></decl></parameter>, <parameter><decl><type><name>ForkNumber</name></type> <name>forknum</name></decl></parameter>, <parameter><decl><type><name>BlockNumber</name></type> <name>blocknum</name></decl></parameter>,
										<parameter><decl><type><name>int</name></type> <name>blockCount</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>buffer</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>skipFsync</name></decl></parameter>)</parameter_list>;</function_decl>
	<function_decl><type><name>void</name></type>		(<modifier>*</modifier><name>smgr_read</name>) <parameter_list>(<parameter><decl><type><name>SMgrRelation</name></type> <name>reln</name></decl></parameter>, <parameter><decl><type><name>ForkNumber</name></type> <name>forknum</name></decl></parameter>,
							  <parameter><decl><type><name>BlockNumber</name></type> <name>blocknum</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>buffer</name></decl></parameter>)</parameter_list>;</function_decl>
	<function_decl><type><name>void</name></type>		(<modifier>*</modifier><name>smgr_write</name>) <parameter_list>(<parameter><decl><type><name>SMgrRelation</name></type> <name>reln</name></decl></parameter>, <parameter><decl><type><name>ForkNumber</name></type> <name>forknum</name></decl></parameter>,
							   <parameter><decl><type><name>BlockNumber</name></type> <name>blocknum</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>buffer</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>skipFsync</name></decl></parameter>)</parameter_list>;</function_decl>
	<function_decl><type><name>void</name></type>		(<modifier>*</modifier><name>smgr_writeback</name>) <parameter_list>(<parameter><decl><type><name>SMgrRelation</name></type> <name>reln</name></decl></parameter>, <parameter><decl><type><name>ForkNumber</name></type> <name>forknum</name></decl></parameter>,
								   <parameter><decl><type><name>BlockNumber</name></type> <name>blocknum</name></decl></parameter>, <parameter><decl><type><name>BlockNumber</name></type> <name>nblocks</name></decl></parameter>)</parameter_list>;</function_decl>
	<function_decl><type><name>BlockNumber</name></type> (<modifier>*</modifier><name>smgr_nblocks</name>) <parameter_list>(<parameter><decl><type><name>SMgrRelation</name></type> <name>reln</name></decl></parameter>, <parameter><decl><type><name>ForkNumber</name></type> <name>forknum</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>polar_cache_size</name></decl></parameter>)</parameter_list>;</function_decl>
	<function_decl><type><name>void</name></type>		(<modifier>*</modifier><name>smgr_truncate</name>) <parameter_list>(<parameter><decl><type><name>SMgrRelation</name></type> <name>reln</name></decl></parameter>, <parameter><decl><type><name>ForkNumber</name></type> <name>forknum</name></decl></parameter>,
								  <parameter><decl><type><name>BlockNumber</name></type> <name>nblocks</name></decl></parameter>)</parameter_list>;</function_decl>
	<function_decl><type><name>void</name></type>		(<modifier>*</modifier><name>smgr_immedsync</name>) <parameter_list>(<parameter><decl><type><name>SMgrRelation</name></type> <name>reln</name></decl></parameter>, <parameter><decl><type><name>ForkNumber</name></type> <name>forknum</name></decl></parameter>)</parameter_list>;</function_decl>
	<function_decl><type><name>void</name></type>		(<modifier>*</modifier><name>smgr_pre_ckpt</name>) <parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>	<comment type="block">/* may be NULL */</comment>
	<function_decl><type><name>void</name></type>		(<modifier>*</modifier><name>smgr_sync</name>) <parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>	<comment type="block">/* may be NULL */</comment>
	<function_decl><type><name>void</name></type>		(<modifier>*</modifier><name>smgr_post_ckpt</name>) <parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>	<comment type="block">/* may be NULL */</comment>
}</block></struct></type> <name>f_smgr</name>;</typedef>


<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>f_smgr</name></type> <name><name>smgrsw</name><index>[]</index></name> <init>= <expr><block>{
	<comment type="block">/* magnetic disk */</comment>
	<expr><block>{
		<expr><operator>.</operator><name>smgr_init</name> <operator>=</operator> <name>mdinit</name></expr>,
		<expr><operator>.</operator><name>smgr_shutdown</name> <operator>=</operator> <name>NULL</name></expr>,
		<expr><operator>.</operator><name>smgr_close</name> <operator>=</operator> <name>mdclose</name></expr>,
		<expr><operator>.</operator><name>smgr_create</name> <operator>=</operator> <name>mdcreate</name></expr>,
		<expr><operator>.</operator><name>smgr_exists</name> <operator>=</operator> <name>mdexists</name></expr>,
		<expr><operator>.</operator><name>smgr_unlink</name> <operator>=</operator> <name>mdunlink</name></expr>,
		<expr><operator>.</operator><name>smgr_extend</name> <operator>=</operator> <name>mdextend</name></expr>,
		<expr><operator>.</operator><name>smgr_extendbatch</name> <operator>=</operator> <name>mdextendbatch</name></expr>,
		<expr><operator>.</operator><name>smgr_prefetch</name> <operator>=</operator> <name>mdprefetch</name></expr>,
		<comment type="block">/* POLAR: bulk read */</comment>
		<expr><operator>.</operator><name>polar_smgr_bulkread</name> <operator>=</operator> <name>polar_mdbulkread</name></expr>,
		<expr><operator>.</operator><name>polar_smgr_bulkwrite</name> <operator>=</operator> <name>polar_mdbulkwrite</name></expr>,
		<comment type="block">/* POLAR end */</comment>
		<expr><operator>.</operator><name>smgr_read</name> <operator>=</operator> <name>mdread</name></expr>,
		<expr><operator>.</operator><name>smgr_write</name> <operator>=</operator> <name>mdwrite</name></expr>,
		<expr><operator>.</operator><name>smgr_writeback</name> <operator>=</operator> <name>mdwriteback</name></expr>,
		<expr><operator>.</operator><name>smgr_nblocks</name> <operator>=</operator> <name>mdnblocks</name></expr>,
		<expr><operator>.</operator><name>smgr_truncate</name> <operator>=</operator> <name>mdtruncate</name></expr>,
		<expr><operator>.</operator><name>smgr_immedsync</name> <operator>=</operator> <name>mdimmedsync</name></expr>,
		<expr><operator>.</operator><name>smgr_pre_ckpt</name> <operator>=</operator> <name>mdpreckpt</name></expr>,
		<expr><operator>.</operator><name>smgr_sync</name> <operator>=</operator> <name>mdsync</name></expr>,
		<expr><operator>.</operator><name>smgr_post_ckpt</name> <operator>=</operator> <name>mdpostckpt</name></expr>
	}</block></expr>
}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>int</name></type> <name>NSmgr</name> <init>= <expr><call><name>lengthof</name><argument_list>(<argument><expr><name>smgrsw</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>


<comment type="block">/*
 * Each backend has a hashtable that stores all extant SMgrRelation objects.
 * In addition, "unowned" SMgrRelation objects are chained together in a list.
 */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>HTAB</name> <modifier>*</modifier></type><name>SMgrRelationHash</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>dlist_head</name></type>	<name>unowned_relns</name></decl>;</decl_stmt>

<comment type="block">/* local function prototypes */</comment>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>smgrshutdown</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>code</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>arg</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/* GUCs. */</comment>
<decl_stmt><decl><type><name>int</name></type> <name>smgr_shared_relations</name> <init>= <expr><literal type="number">10000</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>smgr_pool_sweep_times</name> <init>= <expr><literal type="number">32</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>SMgrSharedRelation</name> <modifier>*</modifier></type><name>held_sr</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<comment type="block">/*
 * Try to get the size of a relation's fork without locking.
 */</comment>
<function><type><specifier>static</specifier> <name>BlockNumber</name></type>
<name>smgrnblocks_fast</name><parameter_list>(<parameter><decl><type><name>SMgrRelation</name></type> <name>reln</name></decl></parameter>, <parameter><decl><type><name>ForkNumber</name></type> <name>forknum</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>SMgrSharedRelation</name> <modifier>*</modifier></type><name>sr</name> <init>= <expr><name><name>reln</name><operator>-&gt;</operator><name>smgr_shared</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BlockNumber</name></type> <name>result</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>sr</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>pg_read_barrier</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* We can load int-sized values atomically without special measures. */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>sr</name><operator>-&gt;</operator><name>nblocks</name><index>[<expr><name>forknum</name></expr>]</index></name></expr></argument>)</argument_list></sizeof> <operator>==</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>uint32</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <name><name>sr</name><operator>-&gt;</operator><name>nblocks</name><index>[<expr><name>forknum</name></expr>]</index></name></expr>;</expr_stmt>

		<comment type="block">/*
		 * With a read barrier between the loads, we can check that the object
		 * still refers to the same rnode before trusting the answer.
		 */</comment>
		<expr_stmt><expr><call><name>pg_read_barrier</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>pg_atomic_read_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>sr</name><operator>-&gt;</operator><name>generation</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <name><name>reln</name><operator>-&gt;</operator><name>smgr_shared_generation</name></name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* no necessary to use a atomic operation, usecount can be imprecisely */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>sr</name><operator>-&gt;</operator><name>usecount</name></name> <operator>&lt;</operator> <name>smgr_pool_sweep_times</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>sr</name><operator>-&gt;</operator><name>usecount</name></name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<return>return <expr><name>result</name></expr>;</return>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * The generation doesn't match, the shared relation must have been
		 * evicted since we got a pointer to it.  We'll need to do more work.
		 */</comment>
		<expr_stmt><expr><name><name>reln</name><operator>-&gt;</operator><name>smgr_shared</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>InvalidBlockNumber</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Try to get the size of a relation's fork by looking it up in the mapping
 * table with a shared lock.  This will succeed if the SMgrRelation already
 * exists.
 */</comment>
<function><type><specifier>static</specifier> <name>BlockNumber</name></type>
<name>smgrnblocks_shared</name><parameter_list>(<parameter><decl><type><name>SMgrRelation</name></type> <name>reln</name></decl></parameter>, <parameter><decl><type><name>ForkNumber</name></type> <name>forknum</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>SMgrSharedRelationMapping</name> <modifier>*</modifier></type><name>mapping</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SMgrSharedRelation</name> <modifier>*</modifier></type><name>sr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32</name></type>	<name>hash</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>LWLock</name> <modifier>*</modifier></type><name>mapping_lock</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BlockNumber</name></type> <name>result</name> <init>= <expr><name>InvalidBlockNumber</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>hash</name> <operator>=</operator> <call><name>get_hash_value</name><argument_list>(<argument><expr><name>sr_mapping_table</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>reln</name><operator>-&gt;</operator><name>smgr_rnode</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>mapping_lock</name> <operator>=</operator> <call><name>SR_PARTITION_LOCK</name><argument_list>(<argument><expr><name>hash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>mapping_lock</name></expr></argument>, <argument><expr><name>LW_SHARED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>mapping</name> <operator>=</operator> <call><name>hash_search_with_hash_value</name><argument_list>(<argument><expr><name>sr_mapping_table</name></expr></argument>,
										  <argument><expr><operator>&amp;</operator><name><name>reln</name><operator>-&gt;</operator><name>smgr_rnode</name></name></expr></argument>,
										  <argument><expr><name>hash</name></expr></argument>,
										  <argument><expr><name>HASH_FIND</name></expr></argument>,
										  <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>mapping</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>sr</name> <operator>=</operator> <operator>&amp;</operator><name><name>sr_pool</name><operator>-&gt;</operator><name>objects</name><index>[<expr><name><name>mapping</name><operator>-&gt;</operator><name>index</name></name></expr>]</index></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <name><name>sr</name><operator>-&gt;</operator><name>nblocks</name><index>[<expr><name>forknum</name></expr>]</index></name></expr>;</expr_stmt>

		<comment type="block">/* no necessary to use a atomic operation, usecount can be imprecisely */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>sr</name><operator>-&gt;</operator><name>usecount</name></name> <operator>&lt;</operator> <name>smgr_pool_sweep_times</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>sr</name><operator>-&gt;</operator><name>usecount</name></name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/* We can take the fast path until this SR is eventually evicted. */</comment>
		<expr_stmt><expr><name><name>reln</name><operator>-&gt;</operator><name>smgr_shared</name></name> <operator>=</operator> <name>sr</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>reln</name><operator>-&gt;</operator><name>smgr_shared_generation</name></name> <operator>=</operator> <call><name>pg_atomic_read_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>sr</name><operator>-&gt;</operator><name>generation</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>mapping_lock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Lock a SMgrSharedRelation.  The lock is a spinlock that should be held for
 * only a few instructions.  The return value is the current set of flags,
 * which may be modified and then passed to smgr_unlock_sr() to be atomically
 * when the lock is released.
 */</comment>
<function><type><name>uint32</name></type>
<name>smgr_lock_sr</name><parameter_list>(<parameter><decl><type><name>SMgrSharedRelation</name> <modifier>*</modifier></type><name>sr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>SpinDelayStatus</name></type> <name>delayStatus</name></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>START_CRIT_SECTION</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>init_local_spin_delay</name><argument_list>(<argument><expr><operator>&amp;</operator><name>delayStatus</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>uint32</name></type>	<name>old_flags</name> <init>= <expr><call><name>pg_atomic_read_u32</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>sr</name><operator>-&gt;</operator><name>flags</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>uint32</name></type>	<name>flags</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>old_flags</name> <operator>&amp;</operator> <name>SR_LOCKED</name><operator>)</operator></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>flags</name> <operator>=</operator> <name>old_flags</name> <operator>|</operator> <name>SR_LOCKED</name></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><call><name>pg_atomic_compare_exchange_u32</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>sr</name><operator>-&gt;</operator><name>flags</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>old_flags</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>held_sr</name> <operator>=</operator> <name>sr</name></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>finish_spin_delay</name><argument_list>(<argument><expr><operator>&amp;</operator><name>delayStatus</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr><name>flags</name></expr>;</return>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><call><name>perform_spin_delay</name><argument_list>(<argument><expr><operator>&amp;</operator><name>delayStatus</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>
	<expr_stmt><expr><call><name>finish_spin_delay</name><argument_list>(<argument><expr><operator>&amp;</operator><name>delayStatus</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><literal type="number">0</literal></expr>;</return> <comment type="block">/* unreachable */</comment>
</block_content>}</block></function>

<comment type="block">/*
 * Unlock a SMgrSharedRelation, atomically updating its flags at the same
 * time.
 */</comment>
<function><type><name>void</name></type>
<name>smgr_unlock_sr</name><parameter_list>(<parameter><decl><type><name>SMgrSharedRelation</name> <modifier>*</modifier></type><name>sr</name></decl></parameter>, <parameter><decl><type><name>uint32</name></type> <name>flags</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>pg_write_barrier</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>held_sr</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pg_atomic_write_u32</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>sr</name><operator>-&gt;</operator><name>flags</name></name></expr></argument>, <argument><expr><name>flags</name> <operator>&amp;</operator> <operator>~</operator><name>SR_LOCKED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>END_CRIT_SECTION</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>polar_release_held_smgr_cache</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>held_sr</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>smgr_unlock_sr</name><argument_list>(<argument><expr><name>held_sr</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/* LRU: sweep to find a sr to use. Just lock the sr when it returns */</comment>
<function><type><specifier>static</specifier> <name>SMgrSharedRelation</name> <modifier>*</modifier></type>
<name>polar_smgr_pool_sweep</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>SMgrSharedRelation</name> <modifier>*</modifier></type><name>sr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32</name></type> <name>index</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32</name></type> <name>flags</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>sr_used_count</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
	<block>{<block_content>
		<comment type="block">/* Lock the next one in clock-hand order. */</comment>
		<expr_stmt><expr><name>index</name> <operator>=</operator> <call><name>pg_atomic_fetch_add_u32</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>sr_pool</name><operator>-&gt;</operator><name>next</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>%</operator> <name>smgr_shared_relations</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>sr</name> <operator>=</operator> <operator>&amp;</operator><name><name>sr_pool</name><operator>-&gt;</operator><name>objects</name><index>[<expr><name>index</name></expr>]</index></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>flags</name> <operator>=</operator> <call><name>smgr_lock_sr</name><argument_list>(<argument><expr><name>sr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>--</operator><operator>(</operator><name><name>sr</name><operator>-&gt;</operator><name>usecount</name></name><operator>)</operator> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG5</name></expr></argument>, <argument><expr><literal type="string">"find block cache in sweep cache, use it"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>sr</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><operator>++</operator><name>sr_used_count</name> <operator>&gt;=</operator> <name>smgr_pool_sweep_times</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG5</name></expr></argument>, <argument><expr><literal type="string">"all the scanned block caches are used frequently, use a random one"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* Unlock the old sr */</comment>
			<expr_stmt><expr><call><name>smgr_unlock_sr</name><argument_list>(<argument><expr><name>sr</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>sr</name> <operator>=</operator> <operator>&amp;</operator><name><name>sr_pool</name><operator>-&gt;</operator><name>objects</name><index>[<expr><call><name>random</name><argument_list>()</argument_list></call> <operator>%</operator> <name>smgr_shared_relations</name></expr>]</index></name></expr>;</expr_stmt>
			<comment type="block">/* Lock the new sr */</comment>
			<expr_stmt><expr><name>flags</name> <operator>=</operator> <call><name>smgr_lock_sr</name><argument_list>(<argument><expr><name>sr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>sr</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><call><name>smgr_unlock_sr</name><argument_list>(<argument><expr><name>sr</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>
</block_content>}</block></function>

<comment type="block">/*
 * Allocate a new invalid SMgrSharedRelation, and return it locked.
 *
 * The replacement algorithm is a simple FIFO design with no second chance for
 * now.
 */</comment>
<function><type><specifier>static</specifier> <name>SMgrSharedRelation</name> <modifier>*</modifier></type>
<name>smgr_alloc_sr</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>SMgrSharedRelationMapping</name> <modifier>*</modifier></type><name>mapping</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SMgrSharedRelation</name> <modifier>*</modifier></type><name>sr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SMgrRelation</name></type> <name>reln</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ForkNumber</name></type> <name>forknum</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32</name></type> <name>index</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>LWLock</name> <modifier>*</modifier></type><name>mapping_lock</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32</name></type> <name>flags</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RelFileNodeBackend</name></type> <name>rnode</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32</name></type> <name>hash</name></decl>;</decl_stmt>

 <label><name>retry</name>:</label>
	<expr_stmt><expr><name>sr</name> <operator>=</operator> <call><name>polar_smgr_pool_sweep</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>flags</name> <operator>=</operator> <call><name>pg_atomic_read_u32</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>sr</name><operator>-&gt;</operator><name>flags</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* If it's unused, can return it, still locked, immediately. */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>SR_VALID</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>sr</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Copy the rnode and unlock.  We'll briefly acquire both mapping and SR
	 * locks, but we need to do it in that order, so we'll unlock the SR
	 * first.
	 */</comment>
	<expr_stmt><expr><name>index</name> <operator>=</operator> <name>sr</name> <operator>-</operator> <name><name>sr_pool</name><operator>-&gt;</operator><name>objects</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>rnode</name> <operator>=</operator> <name><name>sr</name><operator>-&gt;</operator><name>rnode</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>smgr_unlock_sr</name><argument_list>(<argument><expr><name>sr</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>hash</name> <operator>=</operator> <call><name>get_hash_value</name><argument_list>(<argument><expr><name>sr_mapping_table</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rnode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>mapping_lock</name> <operator>=</operator> <call><name>SR_PARTITION_LOCK</name><argument_list>(<argument><expr><name>hash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>mapping_lock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>mapping</name> <operator>=</operator> <call><name>hash_search_with_hash_value</name><argument_list>(<argument><expr><name>sr_mapping_table</name></expr></argument>,
										  <argument><expr><operator>&amp;</operator><name>rnode</name></expr></argument>,
										  <argument><expr><name>hash</name></expr></argument>,
										  <argument><expr><name>HASH_FIND</name></expr></argument>,
										  <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>mapping</name> <operator>||</operator> <name><name>mapping</name><operator>-&gt;</operator><name>index</name></name> <operator>!=</operator> <name>index</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Too slow, it's gone or now points somewhere else.  Go around. */</comment>
		<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>mapping_lock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<goto>goto <name>retry</name>;</goto>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* We will lock the SR for just a few instructions. */</comment>
	<expr_stmt><expr><name>flags</name> <operator>=</operator> <call><name>smgr_lock_sr</name><argument_list>(<argument><expr><name>sr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>flags</name> <operator>&amp;</operator> <name>SR_VALID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If another backend is currently syncing any fork, we aren't allowed to
	 * evict it, and waiting for it would be pointless because that other
	 * backend already plans to allocate it.  So go around.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>flags</name> <operator>&amp;</operator> <name>SR_SYNCING_MASK</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>smgr_unlock_sr</name><argument_list>(<argument><expr><name>sr</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>mapping_lock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<goto>goto <name>retry</name>;</goto>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * We will sync every fork that is dirty, and then we'll try to
	 * evict it.
	 */</comment>
	<while>while <condition>(<expr><name>flags</name> <operator>&amp;</operator> <name>SR_DIRTY_MASK</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>forknum</name> <operator>=</operator> <call><name>SR_GET_ONE_DIRTY</name><argument_list>(<argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Set the sync bit, clear the just-dirtied bit and unlock. */</comment>
		<expr_stmt><expr><name>flags</name> <operator>|=</operator> <call><name>SR_SYNCING</name><argument_list>(<argument><expr><name>forknum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>flags</name> <operator>&amp;=</operator> <operator>~</operator><call><name>SR_JUST_DIRTIED</name><argument_list>(<argument><expr><name>forknum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>smgr_unlock_sr</name><argument_list>(<argument><expr><name>sr</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>mapping_lock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Perform the I/O, with no locks held.
		 * XXX It sucks that we fsync every segment, not just the ones that need it...
		 */</comment>
		<expr_stmt><expr><name>reln</name> <operator>=</operator> <call><name>smgropen</name><argument_list>(<argument><expr><name><name>rnode</name><operator>.</operator><name>node</name></name></expr></argument>, <argument><expr><name><name>rnode</name><operator>.</operator><name>backend</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>smgrimmedsync</name><argument_list>(<argument><expr><name>reln</name></expr></argument>, <argument><expr><name>forknum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Reacquire the locks.  The object can't have been evicted,
		 * because we set a sync bit.
		 * XXX And what if it's dropped?
		 */</comment>
		<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>mapping_lock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>flags</name> <operator>=</operator> <call><name>smgr_lock_sr</name><argument_list>(<argument><expr><name>sr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>flags</name> <operator>&amp;</operator> <call><name>SR_SYNCING</name><argument_list>(<argument><expr><name>forknum</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>flags</name> <operator>&amp;=</operator> <operator>~</operator><call><name>SR_SYNCING</name><argument_list>(<argument><expr><name>forknum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>flags</name> <operator>&amp;</operator> <call><name>SR_JUST_DIRTIED</name><argument_list>(<argument><expr><name>forknum</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * Someone else dirtied it while we were syncing, so we can't mark
			 * it clean.  Let's give up on this SR and go around again.
			 */</comment>
			<expr_stmt><expr><call><name>smgr_unlock_sr</name><argument_list>(<argument><expr><name>sr</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>mapping_lock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<goto>goto <name>retry</name>;</goto>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* This fork is clean! */</comment>
		<expr_stmt><expr><name>flags</name> <operator>&amp;=</operator> <operator>~</operator><call><name>SR_DIRTY</name><argument_list>(<argument><expr><name>forknum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></while>

	<comment type="block">/*
	 * If we made it this far, there are no dirty forks, so we're now allowed
	 * to evict the SR from the pool and the mapping table.  Make sure that
	 * smgrnblocks_fast() sees that its pointer is now invalid by bumping the
	 * generation.
	 */</comment>
	<expr_stmt><expr><name>flags</name> <operator>&amp;=</operator> <operator>~</operator><name>SR_VALID</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pg_atomic_write_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>sr</name><operator>-&gt;</operator><name>generation</name></name></expr></argument>,
						<argument><expr><call><name>pg_atomic_read_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>sr</name><operator>-&gt;</operator><name>generation</name></name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pg_write_barrier</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>smgr_unlock_sr</name><argument_list>(<argument><expr><name>sr</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	* If any callers to smgr_sr_drop() or smgr_sr_drop_db() had the misfortune
	* to have to wait for us to finish syncing, we can now wake them up.
	*/</comment>
	<expr_stmt><expr><call><name>ConditionVariableBroadcast</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>sr_pool</name><operator>-&gt;</operator><name>sync_flags_cleared</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Remove from the mapping table. */</comment>
	<expr_stmt><expr><call><name>hash_search_with_hash_value</name><argument_list>(<argument><expr><name>sr_mapping_table</name></expr></argument>,
								<argument><expr><operator>&amp;</operator><name>rnode</name></expr></argument>,
								<argument><expr><name>hash</name></expr></argument>,
								<argument><expr><name>HASH_REMOVE</name></expr></argument>,
								<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>mapping_lock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * XXX: We unlock while doing HASH_REMOVE on principle.  Maybe it'd be OK
	 * to hold it now that the clock hand is far away and there is no way
	 * anyone can look up this SR through buffer mapping table.
	 */</comment>
	<expr_stmt><expr><name>flags</name> <operator>=</operator> <call><name>smgr_lock_sr</name><argument_list>(<argument><expr><name>sr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>flags</name> <operator>&amp;</operator> <name>SR_VALID</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Oops, someone else got it. */</comment>
		<expr_stmt><expr><call><name>smgr_unlock_sr</name><argument_list>(<argument><expr><name>sr</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<goto>goto <name>retry</name>;</goto>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>sr</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Set the number of blocks in a relation, in shared memory, and optionally
 * also mark the relation as "dirty" (meaning the it must be fsync'd before it
 * can be evicted).
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>smgrnblocks_update</name><parameter_list>(<parameter><decl><type><name>SMgrRelation</name></type> <name>reln</name></decl></parameter>,
				   <parameter><decl><type><name>ForkNumber</name></type> <name>forknum</name></decl></parameter>,
				   <parameter><decl><type><name>BlockNumber</name></type> <name>nblocks</name></decl></parameter>,
				   <parameter><decl><type><name>bool</name></type> <name>mark_dirty</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>SMgrSharedRelationMapping</name> <modifier>*</modifier></type><name>mapping</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SMgrSharedRelation</name> <modifier>*</modifier></type><name>sr</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32</name></type>		<name>hash</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>LWLock</name> <modifier>*</modifier></type><name>mapping_lock</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32</name></type> <name>flags</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>POLAR_DISABLE_SR_UPDATE</name><argument_list>(<argument><expr><name>reln</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return ;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>hash</name> <operator>=</operator> <call><name>get_hash_value</name><argument_list>(<argument><expr><name>sr_mapping_table</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>reln</name><operator>-&gt;</operator><name>smgr_rnode</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>mapping_lock</name> <operator>=</operator> <call><name>SR_PARTITION_LOCK</name><argument_list>(<argument><expr><name>hash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

 <label><name>retry</name>:</label>
	<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>mapping_lock</name></expr></argument>, <argument><expr><name>LW_SHARED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>mapping</name> <operator>=</operator> <call><name>hash_search_with_hash_value</name><argument_list>(<argument><expr><name>sr_mapping_table</name></expr></argument>,
										  <argument><expr><operator>&amp;</operator><name><name>reln</name><operator>-&gt;</operator><name>smgr_rnode</name></name></expr></argument>,
										  <argument><expr><name>hash</name></expr></argument>,
										  <argument><expr><name>HASH_FIND</name></expr></argument>,
										  <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>mapping</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>sr</name> <operator>=</operator> <operator>&amp;</operator><name><name>sr_pool</name><operator>-&gt;</operator><name>objects</name><index>[<expr><name><name>mapping</name><operator>-&gt;</operator><name>index</name></name></expr>]</index></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>flags</name> <operator>=</operator> <call><name>smgr_lock_sr</name><argument_list>(<argument><expr><name>sr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>mark_dirty</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * Extend and truncate clobber the value, and there are no races
			 * to worry about because they can have higher level exclusive
			 * locking on the relation.
			 */</comment>
			<expr_stmt><expr><name><name>sr</name><operator>-&gt;</operator><name>nblocks</name><index>[<expr><name>forknum</name></expr>]</index></name> <operator>=</operator> <name>nblocks</name></expr>;</expr_stmt>

			<comment type="block">/*
			 * Mark it dirty, and if it's currently being sync'd, make sure it
			 * stays dirty after that completes.
			 */</comment>
			<expr_stmt><expr><name>flags</name> <operator>|=</operator> <call><name>SR_DIRTY</name><argument_list>(<argument><expr><name>forknum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>flags</name> <operator>&amp;</operator> <call><name>SR_SYNCING</name><argument_list>(<argument><expr><name>forknum</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>flags</name> <operator>|=</operator> <call><name>SR_JUST_DIRTIED</name><argument_list>(<argument><expr><name>forknum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><operator>!</operator><operator>(</operator><name>flags</name> <operator>&amp;</operator> <call><name>SR_DIRTY</name><argument_list>(<argument><expr><name>forknum</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * We won't clobber a dirty value with a non-dirty update, to
			 * avoid races against concurrent extend/truncate, but we can
			 * install a new clean value.
			 */</comment>
			<expr_stmt><expr><name><name>sr</name><operator>-&gt;</operator><name>nblocks</name><index>[<expr><name>forknum</name></expr>]</index></name> <operator>=</operator> <name>nblocks</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>sr</name><operator>-&gt;</operator><name>usecount</name></name> <operator>&lt;</operator> <name>smgr_pool_sweep_times</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>sr</name><operator>-&gt;</operator><name>usecount</name></name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>smgr_unlock_sr</name><argument_list>(<argument><expr><name>sr</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>mapping_lock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* If we didn't find it, then we'll need to allocate one. */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>sr</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>bool</name></type> <name>found</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>sr</name> <operator>=</operator> <call><name>smgr_alloc_sr</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Upgrade to exclusive lock so we can create a mapping. */</comment>
		<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>mapping_lock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>mapping</name> <operator>=</operator> <call><name>hash_search_with_hash_value</name><argument_list>(<argument><expr><name>sr_mapping_table</name></expr></argument>,
											  <argument><expr><operator>&amp;</operator><name><name>reln</name><operator>-&gt;</operator><name>smgr_rnode</name></name></expr></argument>,
											  <argument><expr><name>hash</name></expr></argument>,
											  <argument><expr><name>HASH_ENTER</name></expr></argument>,
											  <argument><expr><operator>&amp;</operator><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>found</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Success!  Initialize. */</comment>
			<expr_stmt><expr><name><name>mapping</name><operator>-&gt;</operator><name>index</name></name> <operator>=</operator> <name>sr</name> <operator>-</operator> <name><name>sr_pool</name><operator>-&gt;</operator><name>objects</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>sr</name><operator>-&gt;</operator><name>usecount</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>smgr_unlock_sr</name><argument_list>(<argument><expr><name>sr</name></expr></argument>, <argument><expr><name>SR_VALID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>sr</name><operator>-&gt;</operator><name>rnode</name></name> <operator>=</operator> <name><name>reln</name><operator>-&gt;</operator><name>smgr_rnode</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>pg_atomic_write_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>sr</name><operator>-&gt;</operator><name>generation</name></name></expr></argument>,
								<argument><expr><call><name>pg_atomic_read_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>sr</name><operator>-&gt;</operator><name>generation</name></name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;=</operator> <name>MAX_FORKNUM</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>sr</name><operator>-&gt;</operator><name>nblocks</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>InvalidBlockNumber</name></expr>;</expr_stmt></block_content></block></for>
			<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>mapping_lock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/* Someone beat us to it.  Go around again. */</comment>
			<expr_stmt><expr><call><name>smgr_unlock_sr</name><argument_list>(<argument><expr><name>sr</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>		<comment type="block">/* = not valid */</comment>
			<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>mapping_lock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<goto>goto <name>retry</name>;</goto>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Use this function to drop smgr shared cache.
 */</comment>
<function><type><name>void</name></type>
<name>smgr_drop_sr</name><parameter_list>(<parameter><decl><type><name>RelFileNodeBackend</name> <modifier>*</modifier></type><name>rnode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>SMgrSharedRelationMapping</name> <modifier>*</modifier></type><name>mapping</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SMgrSharedRelation</name> <modifier>*</modifier></type><name>sr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32</name></type>	<name>hash</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>LWLock</name> <modifier>*</modifier></type><name>mapping_lock</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32</name></type> <name>flags</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ForkNumber</name></type> <name>forknum</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>polar_enabled_nblock_cache</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return ;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>polar_in_replica_mode</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><name>polar_enable_replica_use_smgr_cache</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return ;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>polar_is_standby</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><name>polar_enable_standby_use_smgr_cache</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return ;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>hash</name> <operator>=</operator> <call><name>get_hash_value</name><argument_list>(<argument><expr><name>sr_mapping_table</name></expr></argument>, <argument><expr><name>rnode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>mapping_lock</name> <operator>=</operator> <call><name>SR_PARTITION_LOCK</name><argument_list>(<argument><expr><name>hash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<label><name>retry</name>:</label>
	<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>mapping_lock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>mapping</name> <operator>=</operator> <call><name>hash_search_with_hash_value</name><argument_list>(<argument><expr><name>sr_mapping_table</name></expr></argument>,
										  <argument><expr><name>rnode</name></expr></argument>,
										  <argument><expr><name>hash</name></expr></argument>,
										  <argument><expr><name>HASH_FIND</name></expr></argument>,
										  <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>mapping</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>sr</name> <operator>=</operator> <operator>&amp;</operator><name><name>sr_pool</name><operator>-&gt;</operator><name>objects</name><index>[<expr><name><name>mapping</name><operator>-&gt;</operator><name>index</name></name></expr>]</index></name></expr>;</expr_stmt>

		<expr_stmt><expr><name>flags</name> <operator>=</operator> <call><name>smgr_lock_sr</name><argument_list>(<argument><expr><name>sr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>flags</name> <operator>&amp;</operator> <name>SR_VALID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>flags</name> <operator>&amp;</operator> <name>SR_SYNCING_MASK</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * Oops, someone's syncing one of its forks; nothing to do but
			 * wait.
			 */</comment>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>polar_in_replica_mode</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>smgr_unlock_sr</name><argument_list>(<argument><expr><name>sr</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>mapping_lock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>ConditionVariableSleep</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>sr_pool</name><operator>-&gt;</operator><name>sync_flags_cleared</name></name></expr></argument>,
								   <argument><expr><name>WAIT_EVENT_SMGR_DROP_SYNC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<goto>goto <name>retry</name>;</goto>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><call><name>ConditionVariableCancelSleep</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<for>for <control>(<init><expr><name>forknum</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>forknum</name> <operator>&lt;=</operator> <name>MAX_FORKNUM</name></expr>;</condition> <incr><expr><name>forknum</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>sr</name><operator>-&gt;</operator><name>nblocks</name><index>[<expr><name>forknum</name></expr>]</index></name> <operator>=</operator> <name>InvalidBlockNumber</name></expr>;</expr_stmt></block_content></block></for>

		<comment type="block">/* Mark it invalid and drop the mapping. */</comment>
		<expr_stmt><expr><name><name>sr</name><operator>-&gt;</operator><name>usecount</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>smgr_unlock_sr</name><argument_list>(<argument><expr><name>sr</name></expr></argument>, <argument><expr><operator>~</operator><name>SR_VALID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>hash_search_with_hash_value</name><argument_list>(<argument><expr><name>sr_mapping_table</name></expr></argument>,
									<argument><expr><name>rnode</name></expr></argument>,
									<argument><expr><name>hash</name></expr></argument>,
									<argument><expr><name>HASH_REMOVE</name></expr></argument>,
									<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>mapping_lock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>size_t</name></type>
<name>smgr_shmem_size</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>size_t</name></type> <name>size</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>size</name> <operator>=</operator> <call><name>add_size</name><argument_list>(<argument><expr><name>size</name></expr></argument>,
					<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><call><name>offsetof</name><argument_list>(<argument><expr><name>SMgrSharedRelationPool</name></expr></argument>, <argument><expr><name>objects</name></expr></argument>)</argument_list></call> <operator>+</operator>
						   <sizeof>sizeof<argument_list>(<argument><expr><name>SMgrSharedRelation</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>smgr_shared_relations</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>size</name> <operator>=</operator> <call><name>add_size</name><argument_list>(<argument><expr><name>size</name></expr></argument>,
					<argument><expr><call><name>hash_estimate_size</name><argument_list>(<argument><expr><name>smgr_shared_relations</name></expr></argument>,
									   <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>SMgrSharedRelationMapping</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>size</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>smgr_shmem_init</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HASHCTL</name></type>		<name>info</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>found</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32</name></type> <name>i</name></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>info</name><operator>.</operator><name>keysize</name></name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>RelFileNodeBackend</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>info</name><operator>.</operator><name>entrysize</name></name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>SMgrSharedRelationMapping</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>info</name><operator>.</operator><name>num_partitions</name></name> <operator>=</operator> <name>SR_PARTITIONS</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>sr_mapping_table</name> <operator>=</operator> <call><name>ShmemInitHash</name><argument_list>(<argument><expr><literal type="string">"SMgrSharedRelation Mapping Table"</literal></expr></argument>,
									 <argument><expr><name>smgr_shared_relations</name></expr></argument>,
									 <argument><expr><name>smgr_shared_relations</name></expr></argument>,
									 <argument><expr><operator>&amp;</operator><name>info</name></expr></argument>,
									 <argument><expr><name>HASH_ELEM</name> <operator>|</operator> <name>HASH_BLOBS</name> <operator>|</operator> <name>HASH_PARTITION</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>sr_pool</name> <operator>=</operator> <call><name>ShmemInitStruct</name><argument_list>(<argument><expr><literal type="string">"SMgrSharedRelation Pool"</literal></expr></argument>,
							  <argument><expr><call><name>offsetof</name><argument_list>(<argument><expr><name>SMgrSharedRelationPool</name></expr></argument>, <argument><expr><name>objects</name></expr></argument>)</argument_list></call> <operator>+</operator>
							  <sizeof>sizeof<argument_list>(<argument><expr><name>SMgrSharedRelation</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>smgr_shared_relations</name></expr></argument>,
							  <argument><expr><operator>&amp;</operator><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>found</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ConditionVariableInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>sr_pool</name><operator>-&gt;</operator><name>sync_flags_cleared</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pg_atomic_init_u32</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>sr_pool</name><operator>-&gt;</operator><name>next</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>smgr_shared_relations</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control>
		<block>{<block_content>
			<expr_stmt><expr><call><name>pg_atomic_init_u32</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>sr_pool</name><operator>-&gt;</operator><name>objects</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>flags</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>pg_atomic_init_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>sr_pool</name><operator>-&gt;</operator><name>objects</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>generation</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>sr_pool</name><operator>-&gt;</operator><name>objects</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>usecount</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		</block_content>}</block></for>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><name>SMgrSharedRelationPool</name> <modifier>*</modifier></type>
<name>polar_get_smgr_shared_pool</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><name>sr_pool</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>HTAB</name> <modifier>*</modifier></type>
<name>polar_get_smgr_mapping_table</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><name>sr_mapping_table</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 *	smgrinit(), smgrshutdown() -- Initialize or shut down storage
 *								  managers.
 *
 * Note: smgrinit is called during backend startup (normal or standalone
 * case), *not* during postmaster start.  Therefore, any resources created
 * here or destroyed in smgrshutdown are backend-local.
 */</comment>
<function><type><name>void</name></type>
<name>smgrinit</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>NSmgr</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>smgrsw</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>smgr_init</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>smgrsw</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><call><name>smgr_init</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></for>

	<comment type="block">/* register the shutdown proc */</comment>
	<expr_stmt><expr><call><name>on_proc_exit</name><argument_list>(<argument><expr><name>smgrshutdown</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * on_proc_exit hook for smgr cleanup during backend shutdown
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>smgrshutdown</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>code</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>NSmgr</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>smgrsw</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>smgr_shutdown</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>smgrsw</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><call><name>smgr_shutdown</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></for>
</block_content>}</block></function>

<comment type="block">/*
 *	smgropen() -- Return an SMgrRelation object, creating it if need be.
 *
 *		This does not attempt to actually open the underlying file.
 */</comment>
<function><type><name>SMgrRelation</name></type>
<name>smgropen</name><parameter_list>(<parameter><decl><type><name>RelFileNode</name></type> <name>rnode</name></decl></parameter>, <parameter><decl><type><name>BackendId</name></type> <name>backend</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>RelFileNodeBackend</name></type> <name>brnode</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SMgrRelation</name></type> <name>reln</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>found</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>SMgrRelationHash</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* First time through: initialize the hash table */</comment>
		<decl_stmt><decl><type><name>HASHCTL</name></type>		<name>ctl</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ctl</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ctl</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>ctl</name><operator>.</operator><name>keysize</name></name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>RelFileNodeBackend</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>ctl</name><operator>.</operator><name>entrysize</name></name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>SMgrRelationData</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
		<expr_stmt><expr><name>SMgrRelationHash</name> <operator>=</operator> <call><name>hash_create</name><argument_list>(<argument><expr><literal type="string">"smgr relation table"</literal></expr></argument>, <argument><expr><literal type="number">400</literal></expr></argument>,
									   <argument><expr><operator>&amp;</operator><name>ctl</name></expr></argument>, <argument><expr><name>HASH_ELEM</name> <operator>|</operator> <name>HASH_BLOBS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>dlist_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>unowned_relns</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Look up or create an entry */</comment>
	<expr_stmt><expr><name><name>brnode</name><operator>.</operator><name>node</name></name> <operator>=</operator> <name>rnode</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>brnode</name><operator>.</operator><name>backend</name></name> <operator>=</operator> <name>backend</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>reln</name> <operator>=</operator> <operator>(</operator><name>SMgrRelation</name><operator>)</operator> <call><name>hash_search</name><argument_list>(<argument><expr><name>SMgrRelationHash</name></expr></argument>,
									  <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>brnode</name></expr></argument>,
									  <argument><expr><name>HASH_ENTER</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Initialize it if not present before */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>found</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>forknum</name></decl>;</decl_stmt>

		<comment type="block">/* hash_search already filled in the lookup key */</comment>
		<expr_stmt><expr><name><name>reln</name><operator>-&gt;</operator><name>smgr_owner</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>reln</name><operator>-&gt;</operator><name>smgr_targblock</name></name> <operator>=</operator> <name>InvalidBlockNumber</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>reln</name><operator>-&gt;</operator><name>smgr_shared</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>reln</name><operator>-&gt;</operator><name>smgr_shared_generation</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>reln</name><operator>-&gt;</operator><name>smgr_fsm_nblocks</name></name> <operator>=</operator> <name>InvalidBlockNumber</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>reln</name><operator>-&gt;</operator><name>smgr_vm_nblocks</name></name> <operator>=</operator> <name>InvalidBlockNumber</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>reln</name><operator>-&gt;</operator><name>smgr_which</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>	<comment type="block">/* we only have md.c at present */</comment>

		<comment type="block">/* mark it not open */</comment>
		<for>for <control>(<init><expr><name>forknum</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>forknum</name> <operator>&lt;=</operator> <name>MAX_FORKNUM</name></expr>;</condition> <incr><expr><name>forknum</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>reln</name><operator>-&gt;</operator><name>md_num_open_segs</name><index>[<expr><name>forknum</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></for>

		<comment type="block">/* POLAR: bulk extend status */</comment>
		<for>for <control>(<init><expr><name>forknum</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>forknum</name> <operator>&lt;=</operator> <name>MAX_FORKNUM</name></expr>;</condition> <incr><expr><name>forknum</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>polar_smgr_clear_bulk_extend</name><argument_list>(<argument><expr><name>reln</name></expr></argument>, <argument><expr><name>forknum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
		<comment type="block">/* POLAR end */</comment>

		<comment type="block">/* it has no owner yet */</comment>
		<expr_stmt><expr><call><name>dlist_push_tail</name><argument_list>(<argument><expr><operator>&amp;</operator><name>unowned_relns</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>reln</name><operator>-&gt;</operator><name>node</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>reln</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * smgrsetowner() -- Establish a long-lived reference to an SMgrRelation object
 *
 * There can be only one owner at a time; this is sufficient since currently
 * the only such owners exist in the relcache.
 */</comment>
<function><type><name>void</name></type>
<name>smgrsetowner</name><parameter_list>(<parameter><decl><type><name>SMgrRelation</name> <modifier>*</modifier></type><name>owner</name></decl></parameter>, <parameter><decl><type><name>SMgrRelation</name></type> <name>reln</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* We don't support "disowning" an SMgrRelation here, use smgrclearowner */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>owner</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * First, unhook any old owner.  (Normally there shouldn't be any, but it
	 * seems possible that this can happen during swap_relation_files()
	 * depending on the order of processing.  It's ok to close the old
	 * relcache entry early in that case.)
	 *
	 * If there isn't an old owner, then the reln should be in the unowned
	 * list, and we need to remove it.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>reln</name><operator>-&gt;</operator><name>smgr_owner</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><operator>*</operator><operator>(</operator><name><name>reln</name><operator>-&gt;</operator><name>smgr_owner</name></name><operator>)</operator> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>dlist_delete</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>reln</name><operator>-&gt;</operator><name>node</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/* Now establish the ownership relationship. */</comment>
	<expr_stmt><expr><name><name>reln</name><operator>-&gt;</operator><name>smgr_owner</name></name> <operator>=</operator> <name>owner</name></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>owner</name> <operator>=</operator> <name>reln</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * smgrclearowner() -- Remove long-lived reference to an SMgrRelation object
 *					   if one exists
 */</comment>
<function><type><name>void</name></type>
<name>smgrclearowner</name><parameter_list>(<parameter><decl><type><name>SMgrRelation</name> <modifier>*</modifier></type><name>owner</name></decl></parameter>, <parameter><decl><type><name>SMgrRelation</name></type> <name>reln</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* Do nothing if the SMgrRelation object is not owned by the owner */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>reln</name><operator>-&gt;</operator><name>smgr_owner</name></name> <operator>!=</operator> <name>owner</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/* unset the owner's reference */</comment>
	<expr_stmt><expr><operator>*</operator><name>owner</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<comment type="block">/* unset our reference to the owner */</comment>
	<expr_stmt><expr><name><name>reln</name><operator>-&gt;</operator><name>smgr_owner</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<comment type="block">/* add to list of unowned relations */</comment>
	<expr_stmt><expr><call><name>dlist_push_tail</name><argument_list>(<argument><expr><operator>&amp;</operator><name>unowned_relns</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>reln</name><operator>-&gt;</operator><name>node</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 *	smgrexists() -- Does the underlying file for a fork exist?
 */</comment>
<function><type><name>bool</name></type>
<name>smgrexists</name><parameter_list>(<parameter><decl><type><name>SMgrRelation</name></type> <name>reln</name></decl></parameter>, <parameter><decl><type><name>ForkNumber</name></type> <name>forknum</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><name><name>smgrsw</name><index>[<expr><name><name>reln</name><operator>-&gt;</operator><name>smgr_which</name></name></expr>]</index></name><operator>.</operator><call><name>smgr_exists</name><argument_list>(<argument><expr><name>reln</name></expr></argument>, <argument><expr><name>forknum</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 *	smgrclose() -- Close and delete an SMgrRelation object.
 */</comment>
<function><type><name>void</name></type>
<name>smgrclose</name><parameter_list>(<parameter><decl><type><name>SMgrRelation</name></type> <name>reln</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>SMgrRelation</name> <modifier>*</modifier></type><name>owner</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ForkNumber</name></type>	<name>forknum</name></decl>;</decl_stmt>

	<for>for <control>(<init><expr><name>forknum</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>forknum</name> <operator>&lt;=</operator> <name>MAX_FORKNUM</name></expr>;</condition> <incr><expr><name>forknum</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>smgrsw</name><index>[<expr><name><name>reln</name><operator>-&gt;</operator><name>smgr_which</name></name></expr>]</index></name><operator>.</operator><call><name>smgr_close</name><argument_list>(<argument><expr><name>reln</name></expr></argument>, <argument><expr><name>forknum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>

	<expr_stmt><expr><name>owner</name> <operator>=</operator> <name><name>reln</name><operator>-&gt;</operator><name>smgr_owner</name></name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>owner</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>dlist_delete</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>reln</name><operator>-&gt;</operator><name>node</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>hash_search</name><argument_list>(<argument><expr><name>SMgrRelationHash</name></expr></argument>,
					<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><operator>(</operator><name><name>reln</name><operator>-&gt;</operator><name>smgr_rnode</name></name><operator>)</operator></expr></argument>,
					<argument><expr><name>HASH_REMOVE</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"SMgrRelation hashtable corrupted"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Unhook the owner pointer, if any.  We do this last since in the remote
	 * possibility of failure above, the SMgrRelation object will still exist.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>owner</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><operator>*</operator><name>owner</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 *	smgrcloseall() -- Close all existing SMgrRelation objects.
 */</comment>
<function><type><name>void</name></type>
<name>smgrcloseall</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HASH_SEQ_STATUS</name></type> <name>status</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SMgrRelation</name></type> <name>reln</name></decl>;</decl_stmt>

	<comment type="block">/* Nothing to do if hashtable not set up */</comment>
	<if_stmt><if>if <condition>(<expr><name>SMgrRelationHash</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>hash_seq_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>status</name></expr></argument>, <argument><expr><name>SMgrRelationHash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<while>while <condition>(<expr><operator>(</operator><name>reln</name> <operator>=</operator> <operator>(</operator><name>SMgrRelation</name><operator>)</operator> <call><name>hash_seq_search</name><argument_list>(<argument><expr><operator>&amp;</operator><name>status</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>smgrclose</name><argument_list>(<argument><expr><name>reln</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></while>
</block_content>}</block></function>

<comment type="block">/*
 *	smgrclosenode() -- Close SMgrRelation object for given RelFileNode,
 *					   if one exists.
 *
 * This has the same effects as smgrclose(smgropen(rnode)), but it avoids
 * uselessly creating a hashtable entry only to drop it again when no
 * such entry exists already.
 */</comment>
<function><type><name>void</name></type>
<name>smgrclosenode</name><parameter_list>(<parameter><decl><type><name>RelFileNodeBackend</name></type> <name>rnode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>SMgrRelation</name></type> <name>reln</name></decl>;</decl_stmt>

	<comment type="block">/* Nothing to do if hashtable not set up */</comment>
	<if_stmt><if>if <condition>(<expr><name>SMgrRelationHash</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>reln</name> <operator>=</operator> <operator>(</operator><name>SMgrRelation</name><operator>)</operator> <call><name>hash_search</name><argument_list>(<argument><expr><name>SMgrRelationHash</name></expr></argument>,
									  <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>rnode</name></expr></argument>,
									  <argument><expr><name>HASH_FIND</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>reln</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>smgrclose</name><argument_list>(<argument><expr><name>reln</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 *	smgrcreate() -- Create a new relation.
 *
 *		Given an already-created (but presumably unused) SMgrRelation,
 *		cause the underlying disk file or other storage for the fork
 *		to be created.
 *
 *		If isRedo is true, it is okay for the underlying file to exist
 *		already because we are in a WAL replay sequence.
 */</comment>
<function><type><name>void</name></type>
<name>smgrcreate</name><parameter_list>(<parameter><decl><type><name>SMgrRelation</name></type> <name>reln</name></decl></parameter>, <parameter><decl><type><name>ForkNumber</name></type> <name>forknum</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>isRedo</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * Exit quickly in WAL replay mode if we've already opened the file. If
	 * it's open, it surely must exist.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>isRedo</name> <operator>&amp;&amp;</operator> <name><name>reln</name><operator>-&gt;</operator><name>md_num_open_segs</name><index>[<expr><name>forknum</name></expr>]</index></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * We may be using the target table space for the first time in this
	 * database, so create a per-database subdirectory if needed.
	 *
	 * XXX this is a fairly ugly violation of module layering, but this seems
	 * to be the best place to put the check.  Maybe TablespaceCreateDbspace
	 * should be here and not in commands/tablespace.c?  But that would imply
	 * importing a lot of stuff that smgr.c oughtn't know, either.
	 */</comment>
	<expr_stmt><expr><call><name>TablespaceCreateDbspace</name><argument_list>(<argument><expr><name><name>reln</name><operator>-&gt;</operator><name>smgr_rnode</name><operator>.</operator><name>node</name><operator>.</operator><name>spcNode</name></name></expr></argument>,
							<argument><expr><name><name>reln</name><operator>-&gt;</operator><name>smgr_rnode</name><operator>.</operator><name>node</name><operator>.</operator><name>dbNode</name></name></expr></argument>,
							<argument><expr><name>isRedo</name></expr></argument>,
							<argument><expr><call><name>SmgrIsTemp</name><argument_list>(<argument><expr><name>reln</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>smgrsw</name><index>[<expr><name><name>reln</name><operator>-&gt;</operator><name>smgr_which</name></name></expr>]</index></name><operator>.</operator><call><name>smgr_create</name><argument_list>(<argument><expr><name>reln</name></expr></argument>, <argument><expr><name>forknum</name></expr></argument>, <argument><expr><name>isRedo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 *	smgrdounlink() -- Immediately unlink all forks of a relation.
 *
 *		All forks of the relation are removed from the store.  This should
 *		not be used during transactional operations, since it can't be undone.
 *
 *		If isRedo is true, it is okay for the underlying file(s) to be gone
 *		already.
 *
 *		This is equivalent to calling smgrdounlinkfork for each fork, but
 *		it's significantly quicker so should be preferred when possible.
 */</comment>
<function><type><name>void</name></type>
<name>smgrdounlink</name><parameter_list>(<parameter><decl><type><name>SMgrRelation</name></type> <name>reln</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>isRedo</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>RelFileNodeBackend</name></type> <name>rnode</name> <init>= <expr><name><name>reln</name><operator>-&gt;</operator><name>smgr_rnode</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>which</name> <init>= <expr><name><name>reln</name><operator>-&gt;</operator><name>smgr_which</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ForkNumber</name></type>	<name>forknum</name></decl>;</decl_stmt>

	<comment type="block">/* Close the forks at smgr level */</comment>
	<for>for <control>(<init><expr><name>forknum</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>forknum</name> <operator>&lt;=</operator> <name>MAX_FORKNUM</name></expr>;</condition> <incr><expr><name>forknum</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>smgrsw</name><index>[<expr><name>which</name></expr>]</index></name><operator>.</operator><call><name>smgr_close</name><argument_list>(<argument><expr><name>reln</name></expr></argument>, <argument><expr><name>forknum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>

	<comment type="block">/*
	 * Get rid of any remaining buffers for the relation.  bufmgr will just
	 * drop them without bothering to write the contents.
	 */</comment>
	<expr_stmt><expr><call><name>DropRelFileNodesAllBuffers</name><argument_list>(<argument><expr><operator>&amp;</operator><name>rnode</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * It'd be nice to tell the stats collector to forget it immediately, too.
	 * But we can't because we don't know the OID (and in cases involving
	 * relfilenode swaps, it's not always clear which table OID to forget,
	 * anyway).
	 */</comment>

	<comment type="block">/*
	 * Send a shared-inval message to force other backends to close any
	 * dangling smgr references they may have for this rel.  We should do this
	 * before starting the actual unlinking, in case we fail partway through
	 * that step.  Note that the sinval message will eventually come back to
	 * this backend, too, and thereby provide a backstop that we closed our
	 * own smgr rel.
	 */</comment>
	<expr_stmt><expr><call><name>CacheInvalidateSmgr</name><argument_list>(<argument><expr><name>rnode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>smgr_drop_sr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>rnode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Delete the physical file(s).
	 *
	 * Note: smgr_unlink must treat deletion failure as a WARNING, not an
	 * ERROR, because we've already decided to commit or abort the current
	 * xact.
	 */</comment>
	<expr_stmt><expr><name><name>smgrsw</name><index>[<expr><name>which</name></expr>]</index></name><operator>.</operator><call><name>smgr_unlink</name><argument_list>(<argument><expr><name>rnode</name></expr></argument>, <argument><expr><name>InvalidForkNumber</name></expr></argument>, <argument><expr><name>isRedo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 *	smgrdounlinkall() -- Immediately unlink all forks of all given relations
 *
 *		All forks of all given relations are removed from the store.  This
 *		should not be used during transactional operations, since it can't be
 *		undone.
 *
 *		If isRedo is true, it is okay for the underlying file(s) to be gone
 *		already.
 *
 *		This is equivalent to calling smgrdounlink for each relation, but it's
 *		significantly quicker so should be preferred when possible.
 */</comment>
<function><type><name>void</name></type>
<name>smgrdounlinkall</name><parameter_list>(<parameter><decl><type><name>SMgrRelation</name> <modifier>*</modifier></type><name>rels</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nrels</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>isRedo</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RelFileNodeBackend</name> <modifier>*</modifier></type><name>rnodes</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ForkNumber</name></type>	<name>forknum</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>nrels</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * create an array which contains all relations to be dropped, and close
	 * each relation's forks at the smgr level while at it
	 */</comment>
	<expr_stmt><expr><name>rnodes</name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>RelFileNodeBackend</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>nrels</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nrels</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>RelFileNodeBackend</name></type> <name>rnode</name> <init>= <expr><name><name>rels</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>smgr_rnode</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>which</name> <init>= <expr><name><name>rels</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>smgr_which</name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>rnodes</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>rnode</name></expr>;</expr_stmt>

		<comment type="block">/* Close the forks at smgr level */</comment>
		<for>for <control>(<init><expr><name>forknum</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>forknum</name> <operator>&lt;=</operator> <name>MAX_FORKNUM</name></expr>;</condition> <incr><expr><name>forknum</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>smgrsw</name><index>[<expr><name>which</name></expr>]</index></name><operator>.</operator><call><name>smgr_close</name><argument_list>(<argument><expr><name><name>rels</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>forknum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
	</block_content>}</block></for>

	<comment type="block">/* POLAR: Record relation size change infomation */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>polar_in_replica_mode</name><argument_list>()</argument_list></call> <operator>||</operator> <call><name>polar_bg_redo_state_is_parallel</name><argument_list>(<argument><expr><name>polar_logindex_redo_instance</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nrels</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<for>for <control>(<init><expr><name>forknum</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>forknum</name> <operator>&lt;=</operator> <name>MAX_FORKNUM</name></expr>;</condition> <incr><expr><name>forknum</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>POLAR_RECORD_REL_SIZE</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>rnodes</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>node</name></expr></argument>, <argument><expr><name>forknum</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
		</block_content>}</block></for>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Get rid of any remaining buffers for the relations.  bufmgr will just
	 * drop them without bothering to write the contents.
	 */</comment>
	<expr_stmt><expr><call><name>DropRelFileNodesAllBuffers</name><argument_list>(<argument><expr><name>rnodes</name></expr></argument>, <argument><expr><name>nrels</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * It'd be nice to tell the stats collector to forget them immediately,
	 * too. But we can't because we don't know the OIDs.
	 */</comment>

	<comment type="block">/*
	 * Send a shared-inval message to force other backends to close any
	 * dangling smgr references they may have for these rels.  We should do
	 * this before starting the actual unlinking, in case we fail partway
	 * through that step.  Note that the sinval messages will eventually come
	 * back to this backend, too, and thereby provide a backstop that we
	 * closed our own smgr rel.
	 */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nrels</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>CacheInvalidateSmgr</name><argument_list>(<argument><expr><name><name>rnodes</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nrels</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>smgr_drop_sr</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>rnodes</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>

	<comment type="block">/*
	 * Delete the physical file(s).
	 *
	 * Note: smgr_unlink must treat deletion failure as a WARNING, not an
	 * ERROR, because we've already decided to commit or abort the current
	 * xact.
	 */</comment>
	<comment type="block">/* POLAR: rw unlink rel files */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>polar_in_replica_mode</name><argument_list>()</argument_list></call> <operator>==</operator> <name>false</name></expr>)</condition>
	<block>{<block_content>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nrels</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>int</name></type>			<name>which</name> <init>= <expr><name><name>rels</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>smgr_which</name></expr></init></decl>;</decl_stmt>

			<for>for <control>(<init><expr><name>forknum</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>forknum</name> <operator>&lt;=</operator> <name>MAX_FORKNUM</name></expr>;</condition> <incr><expr><name>forknum</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>smgrsw</name><index>[<expr><name>which</name></expr>]</index></name><operator>.</operator><call><name>smgr_unlink</name><argument_list>(<argument><expr><name><name>rnodes</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>forknum</name></expr></argument>, <argument><expr><name>isRedo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
		</block_content>}</block></for>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* POLAR end */</comment>

	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>rnodes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 *	smgrdounlinkfork() -- Immediately unlink one fork of a relation.
 *
 *		The specified fork of the relation is removed from the store.  This
 *		should not be used during transactional operations, since it can't be
 *		undone.
 *
 *		If isRedo is true, it is okay for the underlying file to be gone
 *		already.
 */</comment>
<function><type><name>void</name></type>
<name>smgrdounlinkfork</name><parameter_list>(<parameter><decl><type><name>SMgrRelation</name></type> <name>reln</name></decl></parameter>, <parameter><decl><type><name>ForkNumber</name></type> <name>forknum</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>isRedo</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>RelFileNodeBackend</name></type> <name>rnode</name> <init>= <expr><name><name>reln</name><operator>-&gt;</operator><name>smgr_rnode</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>which</name> <init>= <expr><name><name>reln</name><operator>-&gt;</operator><name>smgr_which</name></name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* Close the fork at smgr level */</comment>
	<expr_stmt><expr><name><name>smgrsw</name><index>[<expr><name>which</name></expr>]</index></name><operator>.</operator><call><name>smgr_close</name><argument_list>(<argument><expr><name>reln</name></expr></argument>, <argument><expr><name>forknum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Get rid of any remaining buffers for the fork.  bufmgr will just drop
	 * them without bothering to write the contents.
	 */</comment>
	<expr_stmt><expr><call><name>DropRelFileNodeBuffers</name><argument_list>(<argument><expr><name>rnode</name></expr></argument>, <argument><expr><name>forknum</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * It'd be nice to tell the stats collector to forget it immediately, too.
	 * But we can't because we don't know the OID (and in cases involving
	 * relfilenode swaps, it's not always clear which table OID to forget,
	 * anyway).
	 */</comment>

	<comment type="block">/*
	 * Send a shared-inval message to force other backends to close any
	 * dangling smgr references they may have for this rel.  We should do this
	 * before starting the actual unlinking, in case we fail partway through
	 * that step.  Note that the sinval message will eventually come back to
	 * this backend, too, and thereby provide a backstop that we closed our
	 * own smgr rel.
	 */</comment>
	<expr_stmt><expr><call><name>CacheInvalidateSmgr</name><argument_list>(<argument><expr><name>rnode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>smgr_drop_sr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>rnode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Delete the physical file(s).
	 *
	 * Note: smgr_unlink must treat deletion failure as a WARNING, not an
	 * ERROR, because we've already decided to commit or abort the current
	 * xact.
	 */</comment>
	<expr_stmt><expr><name><name>smgrsw</name><index>[<expr><name>which</name></expr>]</index></name><operator>.</operator><call><name>smgr_unlink</name><argument_list>(<argument><expr><name>rnode</name></expr></argument>, <argument><expr><name>forknum</name></expr></argument>, <argument><expr><name>isRedo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 *	smgrextend() -- Add a new block to a file.
 *
 *		The semantics are nearly the same as smgrwrite(): write at the
 *		specified position.  However, this is to be used for the case of
 *		extending a relation (i.e., blocknum is at or beyond the current
 *		EOF).  Note that we assume writing a block beyond current EOF
 *		causes intervening file space to become filled with zeroes.
 */</comment>
<function><type><name>void</name></type>
<name>smgrextend</name><parameter_list>(<parameter><decl><type><name>SMgrRelation</name></type> <name>reln</name></decl></parameter>, <parameter><decl><type><name>ForkNumber</name></type> <name>forknum</name></decl></parameter>, <parameter><decl><type><name>BlockNumber</name></type> <name>blocknum</name></decl></parameter>,
		   <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>buffer</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>skipFsync</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><name><name>smgrsw</name><index>[<expr><name><name>reln</name><operator>-&gt;</operator><name>smgr_which</name></name></expr>]</index></name><operator>.</operator><call><name>smgr_extend</name><argument_list>(<argument><expr><name>reln</name></expr></argument>, <argument><expr><name>forknum</name></expr></argument>, <argument><expr><name>blocknum</name></expr></argument>,
										 <argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>skipFsync</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* POLAR: bulk extend will call smgrnblocks_update in smgrextendbatch */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>polar_smgr_being_bulk_extend</name><argument_list>(<argument><expr><name>reln</name></expr></argument>, <argument><expr><name>forknum</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>false</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>smgrnblocks_update</name><argument_list>(<argument><expr><name>reln</name></expr></argument>, <argument><expr><name>forknum</name></expr></argument>, <argument><expr><name>blocknum</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 *	smgrprefetch() -- Initiate asynchronous read of the specified block of a relation.
 */</comment>
<function><type><name>void</name></type>
<name>smgrprefetch</name><parameter_list>(<parameter><decl><type><name>SMgrRelation</name></type> <name>reln</name></decl></parameter>, <parameter><decl><type><name>ForkNumber</name></type> <name>forknum</name></decl></parameter>, <parameter><decl><type><name>BlockNumber</name></type> <name>blocknum</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><name><name>smgrsw</name><index>[<expr><name><name>reln</name><operator>-&gt;</operator><name>smgr_which</name></name></expr>]</index></name><operator>.</operator><call><name>smgr_prefetch</name><argument_list>(<argument><expr><name>reln</name></expr></argument>, <argument><expr><name>forknum</name></expr></argument>, <argument><expr><name>blocknum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 *  POLAR: bulk read
 *
 *	polar_smgrbulkread() -- read multi particular block from a relation into the supplied
 *    				  buffer.
 *
 *		This routine is called from the buffer manager in order to
 *		instantiate pages in the shared buffer cache.  All storage managers
 *		return pages in the format that POSTGRES expects.
 */</comment>
<function><type><name>void</name></type>
<name>polar_smgrbulkread</name><parameter_list>(<parameter><decl><type><name>SMgrRelation</name></type> <name>reln</name></decl></parameter>, <parameter><decl><type><name>ForkNumber</name></type> <name>forknum</name></decl></parameter>, <parameter><decl><type><name>BlockNumber</name></type> <name>blocknum</name></decl></parameter>,
			 <parameter><decl><type><name>int</name></type> <name>blockCount</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>buffer</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><name><name>smgrsw</name><index>[<expr><name><name>reln</name><operator>-&gt;</operator><name>smgr_which</name></name></expr>]</index></name><operator>.</operator><call><name>polar_smgr_bulkread</name><argument_list>(<argument><expr><name>reln</name></expr></argument>, <argument><expr><name>forknum</name></expr></argument>, <argument><expr><name>blocknum</name></expr></argument>, <argument><expr><name>blockCount</name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<comment type="block">/* POLAR end */</comment>

<comment type="block">/*
 *	smgrread() -- read a particular block from a relation into the supplied
 *				  buffer.
 *
 *		This routine is called from the buffer manager in order to
 *		instantiate pages in the shared buffer cache.  All storage managers
 *		return pages in the format that POSTGRES expects.
 */</comment>
<function><type><name>void</name></type>
<name>smgrread</name><parameter_list>(<parameter><decl><type><name>SMgrRelation</name></type> <name>reln</name></decl></parameter>, <parameter><decl><type><name>ForkNumber</name></type> <name>forknum</name></decl></parameter>, <parameter><decl><type><name>BlockNumber</name></type> <name>blocknum</name></decl></parameter>,
		 <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>buffer</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><name><name>smgrsw</name><index>[<expr><name><name>reln</name><operator>-&gt;</operator><name>smgr_which</name></name></expr>]</index></name><operator>.</operator><call><name>smgr_read</name><argument_list>(<argument><expr><name>reln</name></expr></argument>, <argument><expr><name>forknum</name></expr></argument>, <argument><expr><name>blocknum</name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 *	POLAR: bulk write
 *	polar_smgrbulkwrite() -- Write the supplied buffer out.
 *
 *		This is to be used only for updating already-existing blocks of a
 *		relation (ie, those before the current EOF).  To extend a relation,
 *		use smgrextendbatch().
 *
 *		This is not a synchronous write -- the block is not necessarily
 *		on disk at return, only dumped out to the kernel.  However,
 *		provisions will be made to fsync the write before the next checkpoint.
 *
 *		skipFsync indicates that the caller will make other provisions to
 *		fsync the relation, so we needn't bother.  Temporary relations also
 *		do not require fsync.
 */</comment>
<function><type><name>void</name></type>
<name>polar_smgrbulkwrite</name><parameter_list>(<parameter><decl><type><name>SMgrRelation</name></type> <name>reln</name></decl></parameter>, <parameter><decl><type><name>ForkNumber</name></type> <name>forknum</name></decl></parameter>, <parameter><decl><type><name>BlockNumber</name></type> <name>blocknum</name></decl></parameter>,
				<parameter><decl><type><name>int</name></type> <name>blockCount</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>buffer</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>skipFsync</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><name><name>smgrsw</name><index>[<expr><name><name>reln</name><operator>-&gt;</operator><name>smgr_which</name></name></expr>]</index></name><operator>.</operator><call><name>polar_smgr_bulkwrite</name><argument_list>(<argument><expr><name>reln</name></expr></argument>, <argument><expr><name>forknum</name></expr></argument>, <argument><expr><name>blocknum</name></expr></argument>, <argument><expr><name>blockCount</name></expr></argument>,
		<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>skipFsync</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 *	smgrwrite() -- Write the supplied buffer out.
 *
 *		This is to be used only for updating already-existing blocks of a
 *		relation (ie, those before the current EOF).  To extend a relation,
 *		use smgrextend().
 *
 *		This is not a synchronous write -- the block is not necessarily
 *		on disk at return, only dumped out to the kernel.  However,
 *		provisions will be made to fsync the write before the next checkpoint.
 *
 *		skipFsync indicates that the caller will make other provisions to
 *		fsync the relation, so we needn't bother.  Temporary relations also
 *		do not require fsync.
 */</comment>
<function><type><name>void</name></type>
<name>smgrwrite</name><parameter_list>(<parameter><decl><type><name>SMgrRelation</name></type> <name>reln</name></decl></parameter>, <parameter><decl><type><name>ForkNumber</name></type> <name>forknum</name></decl></parameter>, <parameter><decl><type><name>BlockNumber</name></type> <name>blocknum</name></decl></parameter>,
		  <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>buffer</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>skipFsync</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><name><name>smgrsw</name><index>[<expr><name><name>reln</name><operator>-&gt;</operator><name>smgr_which</name></name></expr>]</index></name><operator>.</operator><call><name>smgr_write</name><argument_list>(<argument><expr><name>reln</name></expr></argument>, <argument><expr><name>forknum</name></expr></argument>, <argument><expr><name>blocknum</name></expr></argument>,
		<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>skipFsync</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 *	smgrwriteback() -- Trigger kernel writeback for the supplied range of
 *					   blocks.
 */</comment>
<function><type><name>void</name></type>
<name>smgrwriteback</name><parameter_list>(<parameter><decl><type><name>SMgrRelation</name></type> <name>reln</name></decl></parameter>, <parameter><decl><type><name>ForkNumber</name></type> <name>forknum</name></decl></parameter>, <parameter><decl><type><name>BlockNumber</name></type> <name>blocknum</name></decl></parameter>,
			  <parameter><decl><type><name>BlockNumber</name></type> <name>nblocks</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><name><name>smgrsw</name><index>[<expr><name><name>reln</name><operator>-&gt;</operator><name>smgr_which</name></name></expr>]</index></name><operator>.</operator><call><name>smgr_writeback</name><argument_list>(<argument><expr><name>reln</name></expr></argument>, <argument><expr><name>forknum</name></expr></argument>, <argument><expr><name>blocknum</name></expr></argument>,
											<argument><expr><name>nblocks</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * When a database is dropped, we have to find and throw away all its
 * SMgrSharedRelation objects.
 */</comment>
<function><type><name>void</name></type>
<name>polar_dropdb_smgr_shared_relation_pool</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>dbid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>	<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32</name></type> <name>flags</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RelFileNodeBackend</name></type> <name>rnode</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SMgrSharedRelation</name> <modifier>*</modifier></type><name>sr</name></decl>;</decl_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>smgr_shared_relations</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><name>sr</name> <operator>=</operator> <operator>&amp;</operator><name><name>sr_pool</name><operator>-&gt;</operator><name>objects</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>flags</name> <operator>=</operator> <call><name>smgr_lock_sr</name><argument_list>(<argument><expr><name>sr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>SR_VALID</name><operator>)</operator> <operator>&amp;&amp;</operator> <name><name>sr</name><operator>-&gt;</operator><name>rnode</name><operator>.</operator><name>node</name><operator>.</operator><name>dbNode</name></name> <operator>==</operator> <name>dbid</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>rnode</name> <operator>=</operator> <name><name>sr</name><operator>-&gt;</operator><name>rnode</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>smgr_unlock_sr</name><argument_list>(<argument><expr><name>sr</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* Drop, if it's still valid. */</comment>
			<expr_stmt><expr><call><name>smgr_drop_sr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>rnode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>smgr_unlock_sr</name><argument_list>(<argument><expr><name>sr</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></for>
</block_content>}</block></function>

<comment type="block">/* POLAR: smgr cache search and update */</comment>
<function><type><name>BlockNumber</name></type>
<name>polar_nblocks_cache_search_and_update</name><parameter_list>(<parameter><decl><type><name>SMgrRelation</name></type> <name>reln</name></decl></parameter>, <parameter><decl><type><name>ForkNumber</name></type> <name>forknum</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>need_update</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>BlockNumber</name></type> <name>result</name></decl>;</decl_stmt>

	<comment type="block">/* POLAR: For some scenes, we don't support nblocks cache. */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>polar_nouse_nblocks_cache</name><argument_list>(<argument><expr><name>reln</name></expr></argument>, <argument><expr><name>forknum</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <name><name>smgrsw</name><index>[<expr><name><name>reln</name><operator>-&gt;</operator><name>smgr_which</name></name></expr>]</index></name><operator>.</operator><call><name>smgr_nblocks</name><argument_list>(<argument><expr><name>reln</name></expr></argument>, <argument><expr><name>forknum</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>result</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Can we get the answer from shared memory without locking? */</comment>
	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>smgrnblocks_fast</name><argument_list>(<argument><expr><name>reln</name></expr></argument>, <argument><expr><name>forknum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>result</name> <operator>!=</operator> <name>InvalidBlockNumber</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>result</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* Can we get the answer from shared memory with only a share lock? */</comment>
	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>smgrnblocks_shared</name><argument_list>(<argument><expr><name>reln</name></expr></argument>, <argument><expr><name>forknum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>result</name> <operator>!=</operator> <name>InvalidBlockNumber</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>result</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* Ask the kernel. */</comment>
	<expr_stmt><expr><name>result</name> <operator>=</operator> <name><name>smgrsw</name><index>[<expr><name><name>reln</name><operator>-&gt;</operator><name>smgr_which</name></name></expr>]</index></name><operator>.</operator><call><name>smgr_nblocks</name><argument_list>(<argument><expr><name>reln</name></expr></argument>, <argument><expr><name>forknum</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Update the value in shared memory for faster service next time. */</comment>
	<if_stmt><if>if <condition>(<expr><name>need_update</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>smgrnblocks_update</name><argument_list>(<argument><expr><name>reln</name></expr></argument>, <argument><expr><name>forknum</name></expr></argument>, <argument><expr><name>result</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 *	smgrnblocks() -- Calculate the number of blocks in the
 *					 supplied relation.
 * polar_enabled_nblock_cache_all() means enable smgr cache and the mode is 
 * cache all.
 */</comment>
<function><type><name>BlockNumber</name></type>
<name>smgrnblocks</name><parameter_list>(<parameter><decl><type><name>SMgrRelation</name></type> <name>reln</name></decl></parameter>, <parameter><decl><type><name>ForkNumber</name></type> <name>forknum</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>BlockNumber</name></type> <name>result</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>polar_enabled_nblock_cache_all</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>polar_nblocks_cache_search_and_update</name><argument_list>(<argument><expr><name>reln</name></expr></argument>, <argument><expr><name>forknum</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <name><name>smgrsw</name><index>[<expr><name><name>reln</name><operator>-&gt;</operator><name>smgr_which</name></name></expr>]</index></name><operator>.</operator><call><name>smgr_nblocks</name><argument_list>(<argument><expr><name>reln</name></expr></argument>, <argument><expr><name>forknum</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * POLAR: Calculate the number of blocks for some scene. Only in nblock cache
 * no-all, we get nblocks from smgr cache.
 * polar_enabled_nblock_cache() means disable smgr cache or the cache mode 
 * is no-all. When smgr cache is disabled, polar_smgrnblocks_cache -&gt; smgrnblocks
 * -&gt; smgrsw[reln-&gt;smgr_which].smgr_nblocks, it will get the real number of blocks
 */</comment>
<function><type><name>BlockNumber</name></type>
<name>polar_smgrnblocks_cache</name><parameter_list>(<parameter><decl><type><name>SMgrRelation</name></type> <name>reln</name></decl></parameter>, <parameter><decl><type><name>ForkNumber</name></type> <name>forknum</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>BlockNumber</name></type> <name>result</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>polar_enabled_nblock_cache</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>polar_nblocks_cache_search_and_update</name><argument_list>(<argument><expr><name>reln</name></expr></argument>, <argument><expr><name>forknum</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>smgrnblocks</name><argument_list>(<argument><expr><name>reln</name></expr></argument>, <argument><expr><name>forknum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 *	smgrtruncate() -- Truncate supplied relation to the specified number
 *					  of blocks
 *
 * The truncation is done immediately, so this can't be rolled back.
 */</comment>
<function><type><name>void</name></type>
<name>smgrtruncate</name><parameter_list>(<parameter><decl><type><name>SMgrRelation</name></type> <name>reln</name></decl></parameter>, <parameter><decl><type><name>ForkNumber</name></type> <name>forknum</name></decl></parameter>, <parameter><decl><type><name>BlockNumber</name></type> <name>nblocks</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* POLAR :record the new relation size to the cache */</comment>
	<expr_stmt><expr><call><name>POLAR_RECORD_REL_SIZE</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>reln</name><operator>-&gt;</operator><name>smgr_rnode</name><operator>.</operator><name>node</name></name><operator>)</operator></expr></argument>, <argument><expr><name>forknum</name></expr></argument>, <argument><expr><name>nblocks</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* POLAR end */</comment>

	<comment type="block">/*
	 * Get rid of any buffers for the about-to-be-deleted blocks. bufmgr will
	 * just drop them without bothering to write the contents.
	 */</comment>
	<expr_stmt><expr><call><name>DropRelFileNodeBuffers</name><argument_list>(<argument><expr><name><name>reln</name><operator>-&gt;</operator><name>smgr_rnode</name></name></expr></argument>, <argument><expr><name>forknum</name></expr></argument>, <argument><expr><name>nblocks</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Send a shared-inval message to force other backends to close any smgr
	 * references they may have for this rel.  This is useful because they
	 * might have open file pointers to segments that got removed, and/or
	 * smgr_targblock variables pointing past the new rel end.  (The inval
	 * message will come back to our backend, too, causing a
	 * probably-unnecessary local smgr flush.  But we don't expect that this
	 * is a performance-critical path.)  As in the unlink code, we want to be
	 * sure the message is sent before we start changing things on-disk.
	 */</comment>
	<expr_stmt><expr><call><name>CacheInvalidateSmgr</name><argument_list>(<argument><expr><name><name>reln</name><operator>-&gt;</operator><name>smgr_rnode</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Do the truncation.
	 */</comment>
	<expr_stmt><expr><name><name>smgrsw</name><index>[<expr><name><name>reln</name><operator>-&gt;</operator><name>smgr_which</name></name></expr>]</index></name><operator>.</operator><call><name>smgr_truncate</name><argument_list>(<argument><expr><name>reln</name></expr></argument>, <argument><expr><name>forknum</name></expr></argument>, <argument><expr><name>nblocks</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>smgrnblocks_update</name><argument_list>(<argument><expr><name>reln</name></expr></argument>, <argument><expr><name>forknum</name></expr></argument>, <argument><expr><name>nblocks</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * POLAR: The same as smgrtruncate except there is no DropRelFileNodeBuffers
 */</comment>
<function><type><name>void</name></type>
<name>polar_smgrtruncate_no_drop_buffer</name><parameter_list>(<parameter><decl><type><name>SMgrRelation</name></type> <name>reln</name></decl></parameter>, <parameter><decl><type><name>ForkNumber</name></type> <name>forknum</name></decl></parameter>, <parameter><decl><type><name>BlockNumber</name></type> <name>nblocks</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><name><name>smgrsw</name><index>[<expr><name><name>reln</name><operator>-&gt;</operator><name>smgr_which</name></name></expr>]</index></name><operator>.</operator><call><name>smgr_truncate</name><argument_list>(<argument><expr><name>reln</name></expr></argument>, <argument><expr><name>forknum</name></expr></argument>, <argument><expr><name>nblocks</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>smgrnblocks_update</name><argument_list>(<argument><expr><name>reln</name></expr></argument>, <argument><expr><name>forknum</name></expr></argument>, <argument><expr><name>nblocks</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 *	smgrimmedsync() -- Force the specified relation to stable storage.
 *
 *		Synchronously force all previous writes to the specified relation
 *		down to disk.
 *
 *		This is useful for building completely new relations (eg, new
 *		indexes).  Instead of incrementally WAL-logging the index build
 *		steps, we can just write completed index pages to disk with smgrwrite
 *		or smgrextend, and then fsync the completed index file before
 *		committing the transaction.  (This is sufficient for purposes of
 *		crash recovery, since it effectively duplicates forcing a checkpoint
 *		for the completed index.  But it is *not* sufficient if one wishes
 *		to use the WAL log for PITR or replication purposes: in that case
 *		we have to make WAL entries as well.)
 *
 *		The preceding writes should specify skipFsync = true to avoid
 *		duplicative fsyncs.
 *
 *		Note that you need to do FlushRelationBuffers() first if there is
 *		any possibility that there are dirty buffers for the relation;
 *		otherwise the sync is not very meaningful.
 */</comment>
<function><type><name>void</name></type>
<name>smgrimmedsync</name><parameter_list>(<parameter><decl><type><name>SMgrRelation</name></type> <name>reln</name></decl></parameter>, <parameter><decl><type><name>ForkNumber</name></type> <name>forknum</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><name><name>smgrsw</name><index>[<expr><name><name>reln</name><operator>-&gt;</operator><name>smgr_which</name></name></expr>]</index></name><operator>.</operator><call><name>smgr_immedsync</name><argument_list>(<argument><expr><name>reln</name></expr></argument>, <argument><expr><name>forknum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 *	smgrpreckpt() -- Prepare for checkpoint.
 */</comment>
<function><type><name>void</name></type>
<name>smgrpreckpt</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>NSmgr</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>smgrsw</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>smgr_pre_ckpt</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>smgrsw</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><call><name>smgr_pre_ckpt</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></for>
</block_content>}</block></function>

<comment type="block">/*
 *	smgrsync() -- Sync files to disk during checkpoint.
 */</comment>
<function><type><name>void</name></type>
<name>smgrsync</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>NSmgr</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>smgrsw</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>smgr_sync</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>smgrsw</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><call><name>smgr_sync</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></for>
</block_content>}</block></function>

<comment type="block">/*
 *	smgrpostckpt() -- Post-checkpoint cleanup.
 */</comment>
<function><type><name>void</name></type>
<name>smgrpostckpt</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>NSmgr</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>smgrsw</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>smgr_post_ckpt</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>smgrsw</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><call><name>smgr_post_ckpt</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></for>
</block_content>}</block></function>

<comment type="block">/*
 * AtEOXact_SMgr
 *
 * This routine is called during transaction commit or abort (it doesn't
 * particularly care which).  All transient SMgrRelation objects are closed.
 *
 * We do this as a compromise between wanting transient SMgrRelations to
 * live awhile (to amortize the costs of blind writes of multiple blocks)
 * and needing them to not live forever (since we're probably holding open
 * a kernel file descriptor for the underlying file, and we need to ensure
 * that gets closed reasonably soon if the file gets deleted).
 */</comment>
<function><type><name>void</name></type>
<name>AtEOXact_SMgr</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>dlist_mutable_iter</name></type>	<name>iter</name></decl>;</decl_stmt>

	<comment type="block">/* POLAR: unlock the smgr shared cache */</comment>
	<expr_stmt><expr><call><name>polar_release_held_smgr_cache</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Zap all unowned SMgrRelations.  We rely on smgrclose() to remove each
	 * one from the list.
	 */</comment>
	<macro><name>dlist_foreach_modify</name><argument_list>(<argument>iter</argument>, <argument>&amp;unowned_relns</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>SMgrRelation</name></type>	<name>rel</name> <init>= <expr><call><name>dlist_container</name><argument_list>(<argument><expr><name>SMgrRelationData</name></expr></argument>, <argument><expr><name>node</name></expr></argument>,
											  <argument><expr><name><name>iter</name><operator>.</operator><name>cur</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>smgr_owner</name></name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>smgrclose</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
</block_content>}</block></function>

<comment type="block">/* POLAR: bulk extend */</comment>
<function><type><name>void</name></type>
<name>smgrextendbatch</name><parameter_list>(<parameter><decl><type><name>SMgrRelation</name></type> <name>reln</name></decl></parameter>, <parameter><decl><type><name>ForkNumber</name></type> <name>forknum</name></decl></parameter>, <parameter><decl><type><name>BlockNumber</name></type> <name>blocknum</name></decl></parameter>,
		   <parameter><decl><type><name>int</name></type> <name>blockCount</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>buffer</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>skipFsync</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>polar_enable_shared_storage_mode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>blockCount</name> <operator>&gt;=</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>smgrsw</name><index>[<expr><name><name>reln</name><operator>-&gt;</operator><name>smgr_which</name></name></expr>]</index></name><operator>.</operator><call><name>smgr_extendbatch</name><argument_list>(<argument><expr><name>reln</name></expr></argument>, <argument><expr><name>forknum</name></expr></argument>, <argument><expr><name>blocknum</name></expr></argument>, <argument><expr><name>blockCount</name></expr></argument>,
											   <argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>skipFsync</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>smgrnblocks_update</name><argument_list>(<argument><expr><name>reln</name></expr></argument>, <argument><expr><name>forknum</name></expr></argument>, <argument><expr><name>blocknum</name> <operator>+</operator> <name>blockCount</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>BlockNumber</name></type>
<name>polar_smgrnblocks_use_file_cache</name><parameter_list>(<parameter><decl><type><name>SMgrRelation</name></type> <name>reln</name></decl></parameter>, <parameter><decl><type><name>ForkNumber</name></type> <name>forknum</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><name><name>smgrsw</name><index>[<expr><name><name>reln</name><operator>-&gt;</operator><name>smgr_which</name></name></expr>]</index></name><operator>.</operator><call><name>smgr_nblocks</name><argument_list>(<argument><expr><name>reln</name></expr></argument>, <argument><expr><name>forknum</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * polar_smgr_init_bulk_extend() -- Init polar bulk extend backend-local-variable.
 */</comment>
<function><type><name>void</name></type>
<name>polar_smgr_init_bulk_extend</name><parameter_list>(<parameter><decl><type><name>SMgrRelation</name></type> <name>reln</name></decl></parameter>, <parameter><decl><type><name>ForkNumber</name></type> <name>forknum</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>false</name> <operator>==</operator> <call><name>polar_smgr_being_bulk_extend</name><argument_list>(<argument><expr><name>reln</name></expr></argument>, <argument><expr><name>forknum</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>reln</name><operator>-&gt;</operator><name>polar_nblocks_faked_for_bulk_extend</name><index>[<expr><name>forknum</name></expr>]</index></name> <operator>=</operator> <call><name>smgrnblocks</name><argument_list>(<argument><expr><name>reln</name></expr></argument>, <argument><expr><name>forknum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/*
	 * polar_flag_for_bulk_extend must be set after polar_nblocks_faked_for_bulk_extend,
	 * as polar_flag_for_bulk_extend have an effort on result of smgrnblocks().
	 */</comment>
	<expr_stmt><expr><name><name>reln</name><operator>-&gt;</operator><name>polar_flag_for_bulk_extend</name><index>[<expr><name>forknum</name></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * polar_smgr_clear_bulk_extend() -- Clear polar bulk extend backend-local-variable.
 */</comment>
<function><type><name>void</name></type>
<name>polar_smgr_clear_bulk_extend</name><parameter_list>(<parameter><decl><type><name>SMgrRelation</name></type> <name>reln</name></decl></parameter>, <parameter><decl><type><name>ForkNumber</name></type> <name>forknum</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><name><name>reln</name><operator>-&gt;</operator><name>polar_flag_for_bulk_extend</name><index>[<expr><name>forknum</name></expr>]</index></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* POLAR end */</comment>

</unit>
