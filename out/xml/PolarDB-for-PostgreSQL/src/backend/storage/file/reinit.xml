<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/PolarDB-for-PostgreSQL/src/backend/storage/file/reinit.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * reinit.c
 *	  Reinitialization of unlogged relations
 *
 * Portions Copyright (c) 1996-2018, PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, Regents of the University of California
 *
 * IDENTIFICATION
 *	  src/backend/storage/file/reinit.c
 *
 *-------------------------------------------------------------------------
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;unistd.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"common/relpath.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/copydir.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/fd.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/reinit.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/hsearch.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/memutils.h"</cpp:file></cpp:include>

<comment type="block">/* POLAR */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/polar_fd.h"</cpp:file></cpp:include>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ResetUnloggedRelationsInTablespaceDir</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>tsdirname</name></decl></parameter>,
									  <parameter><decl><type><name>int</name></type> <name>op</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ResetUnloggedRelationsInDbspaceDir</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>dbspacedirname</name></decl></parameter>,
								   <parameter><decl><type><name>int</name></type> <name>op</name></decl></parameter>)</parameter_list>;</function_decl>

<typedef>typedef <type><struct>struct
<block>{
	<decl_stmt><decl><type><name>char</name></type>		<name><name>oid</name><index>[<expr><name>OIDCHARS</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>
}</block></struct></type> <name>unlogged_relation_entry</name>;</typedef>

<comment type="block">/*
 * Reset unlogged relations from before the last restart.
 *
 * If op includes UNLOGGED_RELATION_CLEANUP, we remove all forks of any
 * relation with an "init" fork, except for the "init" fork itself.
 *
 * If op includes UNLOGGED_RELATION_INIT, we copy the "init" fork to the main
 * fork.
 */</comment>
<function><type><name>void</name></type>
<name>ResetUnloggedRelations</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>op</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>temp_path</name><index>[<expr><name>MAXPGPATH</name> <operator>+</operator> <literal type="number">10</literal> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>TABLESPACE_VERSION_DIRECTORY</name></expr></argument>)</argument_list></sizeof></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>DIR</name>		   <modifier>*</modifier></type><name>spc_dir</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>dirent</name></name> <modifier>*</modifier></type><name>spc_de</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>tmpctx</name></decl>,
				<decl><type ref="prev"/><name>oldctx</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>polar_path</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name></decl>;</decl_stmt>

	<comment type="block">/* Log it. */</comment>
	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>, <argument><expr><literal type="string">"resetting unlogged relations: cleanup %d init %d"</literal></expr></argument>,
		 <argument><expr><operator>(</operator><name>op</name> <operator>&amp;</operator> <name>UNLOGGED_RELATION_CLEANUP</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr></argument>,
		 <argument><expr><operator>(</operator><name>op</name> <operator>&amp;</operator> <name>UNLOGGED_RELATION_INIT</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Just to be sure we don't leak any memory, let's create a temporary
	 * memory context for this operation.
	 */</comment>
	<expr_stmt><expr><name>tmpctx</name> <operator>=</operator> <call><name>AllocSetContextCreate</name><argument_list>(<argument><expr><name>CurrentMemoryContext</name></expr></argument>,
								   <argument><expr><literal type="string">"ResetUnloggedRelations"</literal></expr></argument>,
								   <argument><expr><name>ALLOCSET_DEFAULT_SIZES</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>oldctx</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>tmpctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * First process unlogged files in pg_default ($PGDATA/base)
	 */</comment>
	<expr_stmt><expr><call><name>ResetUnloggedRelationsInTablespaceDir</name><argument_list>(<argument><expr><literal type="string">"base"</literal></expr></argument>, <argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Cycle through directories for all non-default tablespaces.
	 */</comment>
	<expr_stmt><expr><call><name>polar_make_file_path_level2</name><argument_list>(<argument><expr><name>polar_path</name></expr></argument>, <argument><expr><literal type="string">"pg_tblspc"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>spc_dir</name> <operator>=</operator> <call><name>polar_allocate_dir</name><argument_list>(<argument><expr><name>polar_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<while>while <condition>(<expr><operator>(</operator><name>spc_de</name> <operator>=</operator> <call><name>ReadDir</name><argument_list>(<argument><expr><name>spc_dir</name></expr></argument>, <argument><expr><name>polar_path</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>spc_de</name><operator>-&gt;</operator><name>d_name</name></name></expr></argument>, <argument><expr><literal type="string">"."</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
			<call><name>strcmp</name><argument_list>(<argument><expr><name><name>spc_de</name><operator>-&gt;</operator><name>d_name</name></name></expr></argument>, <argument><expr><literal type="string">".."</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>temp_path</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>temp_path</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"pg_tblspc/%s/%s"</literal></expr></argument>,
				 <argument><expr><name><name>spc_de</name><operator>-&gt;</operator><name>d_name</name></name></expr></argument>, <argument><expr><name>TABLESPACE_VERSION_DIRECTORY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ResetUnloggedRelationsInTablespaceDir</name><argument_list>(<argument><expr><name>temp_path</name></expr></argument>, <argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></while>

	<expr_stmt><expr><call><name>FreeDir</name><argument_list>(<argument><expr><name>spc_dir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Restore memory context.
	 */</comment>
	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>MemoryContextDelete</name><argument_list>(<argument><expr><name>tmpctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Process one tablespace directory for ResetUnloggedRelations
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ResetUnloggedRelationsInTablespaceDir</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>tsdirname</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>op</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>DIR</name>		   <modifier>*</modifier></type><name>ts_dir</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>dirent</name></name> <modifier>*</modifier></type><name>de</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>dbspace_path</name><index>[<expr><name>MAXPGPATH</name> <operator>*</operator> <literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>

	<expr_stmt><expr><name>ts_dir</name> <operator>=</operator> <call><name>AllocateDir</name><argument_list>(<argument><expr><name>tsdirname</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If we get ENOENT on a tablespace directory, log it and return.  This
	 * can happen if a previous DROP TABLESPACE crashed between removing the
	 * tablespace directory and removing the symlink in pg_tblspc.  We don't
	 * really want to prevent database startup in that scenario, so let it
	 * pass instead.  Any other type of error will be reported by ReadDir
	 * (causing a startup failure).
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>ts_dir</name> <operator>==</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name>errno</name> <operator>==</operator> <name>ENOENT</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not open directory \"%s\": %m"</literal></expr></argument>,
						<argument><expr><name>tsdirname</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<while>while <condition>(<expr><operator>(</operator><name>de</name> <operator>=</operator> <call><name>ReadDir</name><argument_list>(<argument><expr><name>ts_dir</name></expr></argument>, <argument><expr><name>tsdirname</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * We're only interested in the per-database directories, which have
		 * numeric names.  Note that this code will also (properly) ignore "."
		 * and "..".
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>strspn</name><argument_list>(<argument><expr><name><name>de</name><operator>-&gt;</operator><name>d_name</name></name></expr></argument>, <argument><expr><literal type="string">"0123456789"</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name><name>de</name><operator>-&gt;</operator><name>d_name</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>dbspace_path</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>dbspace_path</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"%s/%s"</literal></expr></argument>,
				 <argument><expr><name>tsdirname</name></expr></argument>, <argument><expr><name><name>de</name><operator>-&gt;</operator><name>d_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ResetUnloggedRelationsInDbspaceDir</name><argument_list>(<argument><expr><name>dbspace_path</name></expr></argument>, <argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></while>

	<expr_stmt><expr><call><name>FreeDir</name><argument_list>(<argument><expr><name>ts_dir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Process one per-dbspace directory for ResetUnloggedRelations
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ResetUnloggedRelationsInDbspaceDir</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>dbspacedirname</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>op</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>DIR</name>		   <modifier>*</modifier></type><name>dbspace_dir</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>dirent</name></name> <modifier>*</modifier></type><name>de</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>rm_path</name><index>[<expr><name>MAXPGPATH</name> <operator>*</operator> <literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>

	<comment type="block">/* Caller must specify at least one operation. */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>(</operator><name>op</name> <operator>&amp;</operator> <operator>(</operator><name>UNLOGGED_RELATION_CLEANUP</name> <operator>|</operator> <name>UNLOGGED_RELATION_INIT</name><operator>)</operator><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Cleanup is a two-pass operation.  First, we go through and identify all
	 * the files with init forks.  Then, we go through again and nuke
	 * everything with the same OID except the init fork.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>op</name> <operator>&amp;</operator> <name>UNLOGGED_RELATION_CLEANUP</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>HTAB</name>	   <modifier>*</modifier></type><name>hash</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>HASHCTL</name></type>		<name>ctl</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * It's possible that someone could create a ton of unlogged relations
		 * in the same database &amp; tablespace, so we'd better use a hash table
		 * rather than an array or linked list to keep track of which files
		 * need to be reset.  Otherwise, this cleanup operation would be
		 * O(n^2).
		 */</comment>
		<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ctl</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ctl</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>ctl</name><operator>.</operator><name>keysize</name></name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>unlogged_relation_entry</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>ctl</name><operator>.</operator><name>entrysize</name></name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>unlogged_relation_entry</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
		<expr_stmt><expr><name>hash</name> <operator>=</operator> <call><name>hash_create</name><argument_list>(<argument><expr><literal type="string">"unlogged hash"</literal></expr></argument>, <argument><expr><literal type="number">32</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>ctl</name></expr></argument>, <argument><expr><name>HASH_ELEM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Scan the directory. */</comment>
		<expr_stmt><expr><name>dbspace_dir</name> <operator>=</operator> <call><name>AllocateDir</name><argument_list>(<argument><expr><name>dbspacedirname</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<while>while <condition>(<expr><operator>(</operator><name>de</name> <operator>=</operator> <call><name>ReadDir</name><argument_list>(<argument><expr><name>dbspace_dir</name></expr></argument>, <argument><expr><name>dbspacedirname</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>ForkNumber</name></type>	<name>forkNum</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int</name></type>			<name>oidchars</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>unlogged_relation_entry</name></type> <name>ent</name></decl>;</decl_stmt>

			<comment type="block">/* Skip anything that doesn't look like a relation data file. */</comment>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>parse_filename_for_nontemp_relation</name><argument_list>(<argument><expr><name><name>de</name><operator>-&gt;</operator><name>d_name</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>oidchars</name></expr></argument>,
													 <argument><expr><operator>&amp;</operator><name>forkNum</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>

			<comment type="block">/* Also skip it unless this is the init fork. */</comment>
			<if_stmt><if>if <condition>(<expr><name>forkNum</name> <operator>!=</operator> <name>INIT_FORKNUM</name></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>

			<comment type="block">/*
			 * Put the OID portion of the name into the hash table, if it
			 * isn't already.
			 */</comment>
			<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name><name>ent</name><operator>.</operator><name>oid</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>ent</name><operator>.</operator><name>oid</name></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>ent</name><operator>.</operator><name>oid</name></name></expr></argument>, <argument><expr><name><name>de</name><operator>-&gt;</operator><name>d_name</name></name></expr></argument>, <argument><expr><name>oidchars</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>hash_search</name><argument_list>(<argument><expr><name>hash</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ent</name></expr></argument>, <argument><expr><name>HASH_ENTER</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></while>

		<comment type="block">/* Done with the first pass. */</comment>
		<expr_stmt><expr><call><name>FreeDir</name><argument_list>(<argument><expr><name>dbspace_dir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * If we didn't find any init forks, there's no point in continuing;
		 * we can bail out now.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>hash_get_num_entries</name><argument_list>(<argument><expr><name>hash</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>hash_destroy</name><argument_list>(<argument><expr><name>hash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return;</return>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * Now, make a second pass and remove anything that matches.
		 */</comment>
		<expr_stmt><expr><name>dbspace_dir</name> <operator>=</operator> <call><name>AllocateDir</name><argument_list>(<argument><expr><name>dbspacedirname</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<while>while <condition>(<expr><operator>(</operator><name>de</name> <operator>=</operator> <call><name>ReadDir</name><argument_list>(<argument><expr><name>dbspace_dir</name></expr></argument>, <argument><expr><name>dbspacedirname</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>ForkNumber</name></type>	<name>forkNum</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int</name></type>			<name>oidchars</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>bool</name></type>		<name>found</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>unlogged_relation_entry</name></type> <name>ent</name></decl>;</decl_stmt>

			<comment type="block">/* Skip anything that doesn't look like a relation data file. */</comment>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>parse_filename_for_nontemp_relation</name><argument_list>(<argument><expr><name><name>de</name><operator>-&gt;</operator><name>d_name</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>oidchars</name></expr></argument>,
													 <argument><expr><operator>&amp;</operator><name>forkNum</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>

			<comment type="block">/* We never remove the init fork. */</comment>
			<if_stmt><if>if <condition>(<expr><name>forkNum</name> <operator>==</operator> <name>INIT_FORKNUM</name></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>

			<comment type="block">/*
			 * See whether the OID portion of the name shows up in the hash
			 * table.
			 */</comment>
			<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name><name>ent</name><operator>.</operator><name>oid</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>ent</name><operator>.</operator><name>oid</name></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>ent</name><operator>.</operator><name>oid</name></name></expr></argument>, <argument><expr><name><name>de</name><operator>-&gt;</operator><name>d_name</name></name></expr></argument>, <argument><expr><name>oidchars</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>hash_search</name><argument_list>(<argument><expr><name>hash</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ent</name></expr></argument>, <argument><expr><name>HASH_FIND</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* If so, nuke it! */</comment>
			<if_stmt><if>if <condition>(<expr><name>found</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>rm_path</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>rm_path</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"%s/%s"</literal></expr></argument>,
						 <argument><expr><name>dbspacedirname</name></expr></argument>, <argument><expr><name><name>de</name><operator>-&gt;</operator><name>d_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><call><name>unlink</name><argument_list>(<argument><expr><name>rm_path</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not remove file \"%s\": %m"</literal></expr></argument>,
									<argument><expr><name>rm_path</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG2</name></expr></argument>, <argument><expr><literal type="string">"unlinked file \"%s\""</literal></expr></argument>, <argument><expr><name>rm_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></while>

		<comment type="block">/* Cleanup is complete. */</comment>
		<expr_stmt><expr><call><name>FreeDir</name><argument_list>(<argument><expr><name>dbspace_dir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>hash_destroy</name><argument_list>(<argument><expr><name>hash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Initialization happens after cleanup is complete: we copy each init
	 * fork file to the corresponding main fork file.  Note that if we are
	 * asked to do both cleanup and init, we may never get here: if the
	 * cleanup code determines that there are no init forks in this dbspace,
	 * it will return before we get to this point.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>op</name> <operator>&amp;</operator> <name>UNLOGGED_RELATION_INIT</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Scan the directory. */</comment>
		<expr_stmt><expr><name>dbspace_dir</name> <operator>=</operator> <call><name>AllocateDir</name><argument_list>(<argument><expr><name>dbspacedirname</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<while>while <condition>(<expr><operator>(</operator><name>de</name> <operator>=</operator> <call><name>ReadDir</name><argument_list>(<argument><expr><name>dbspace_dir</name></expr></argument>, <argument><expr><name>dbspacedirname</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>ForkNumber</name></type>	<name>forkNum</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int</name></type>			<name>oidchars</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>char</name></type>		<name><name>oidbuf</name><index>[<expr><name>OIDCHARS</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>char</name></type>		<name><name>srcpath</name><index>[<expr><name>MAXPGPATH</name> <operator>*</operator> <literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>char</name></type>		<name><name>dstpath</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name></decl>;</decl_stmt>

			<comment type="block">/* Skip anything that doesn't look like a relation data file. */</comment>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>parse_filename_for_nontemp_relation</name><argument_list>(<argument><expr><name><name>de</name><operator>-&gt;</operator><name>d_name</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>oidchars</name></expr></argument>,
													 <argument><expr><operator>&amp;</operator><name>forkNum</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>

			<comment type="block">/* Also skip it unless this is the init fork. */</comment>
			<if_stmt><if>if <condition>(<expr><name>forkNum</name> <operator>!=</operator> <name>INIT_FORKNUM</name></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>

			<comment type="block">/* Construct source pathname. */</comment>
			<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>srcpath</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>srcpath</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"%s/%s"</literal></expr></argument>,
					 <argument><expr><name>dbspacedirname</name></expr></argument>, <argument><expr><name><name>de</name><operator>-&gt;</operator><name>d_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* Construct destination pathname. */</comment>
			<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>oidbuf</name></expr></argument>, <argument><expr><name><name>de</name><operator>-&gt;</operator><name>d_name</name></name></expr></argument>, <argument><expr><name>oidchars</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>oidbuf</name><index>[<expr><name>oidchars</name></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>dstpath</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>dstpath</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"%s/%s%s"</literal></expr></argument>,
					 <argument><expr><name>dbspacedirname</name></expr></argument>, <argument><expr><name>oidbuf</name></expr></argument>, <argument><expr><name><name>de</name><operator>-&gt;</operator><name>d_name</name></name> <operator>+</operator> <name>oidchars</name> <operator>+</operator> <literal type="number">1</literal> <operator>+</operator>
					 <call><name>strlen</name><argument_list>(<argument><expr><name><name>forkNames</name><index>[<expr><name>INIT_FORKNUM</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* OK, we're ready to perform the actual copy. */</comment>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG2</name></expr></argument>, <argument><expr><literal type="string">"copying %s to %s"</literal></expr></argument>, <argument><expr><name>srcpath</name></expr></argument>, <argument><expr><name>dstpath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>copy_file</name><argument_list>(<argument><expr><name>srcpath</name></expr></argument>, <argument><expr><name>dstpath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></while>

		<expr_stmt><expr><call><name>FreeDir</name><argument_list>(<argument><expr><name>dbspace_dir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * copy_file() above has already called pg_flush_data() on the files
		 * it created. Now we need to fsync those files, because a checkpoint
		 * won't do it for us while we're in recovery. We do this in a
		 * separate pass to allow the kernel to perform all the flushes
		 * (especially the metadata ones) at once.
		 */</comment>
		<expr_stmt><expr><name>dbspace_dir</name> <operator>=</operator> <call><name>AllocateDir</name><argument_list>(<argument><expr><name>dbspacedirname</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<while>while <condition>(<expr><operator>(</operator><name>de</name> <operator>=</operator> <call><name>ReadDir</name><argument_list>(<argument><expr><name>dbspace_dir</name></expr></argument>, <argument><expr><name>dbspacedirname</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>ForkNumber</name></type>	<name>forkNum</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int</name></type>			<name>oidchars</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>char</name></type>		<name><name>oidbuf</name><index>[<expr><name>OIDCHARS</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>char</name></type>		<name><name>mainpath</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name></decl>;</decl_stmt>

			<comment type="block">/* Skip anything that doesn't look like a relation data file. */</comment>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>parse_filename_for_nontemp_relation</name><argument_list>(<argument><expr><name><name>de</name><operator>-&gt;</operator><name>d_name</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>oidchars</name></expr></argument>,
													 <argument><expr><operator>&amp;</operator><name>forkNum</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>

			<comment type="block">/* Also skip it unless this is the init fork. */</comment>
			<if_stmt><if>if <condition>(<expr><name>forkNum</name> <operator>!=</operator> <name>INIT_FORKNUM</name></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>

			<comment type="block">/* Construct main fork pathname. */</comment>
			<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>oidbuf</name></expr></argument>, <argument><expr><name><name>de</name><operator>-&gt;</operator><name>d_name</name></name></expr></argument>, <argument><expr><name>oidchars</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>oidbuf</name><index>[<expr><name>oidchars</name></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>mainpath</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>mainpath</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"%s/%s%s"</literal></expr></argument>,
					 <argument><expr><name>dbspacedirname</name></expr></argument>, <argument><expr><name>oidbuf</name></expr></argument>, <argument><expr><name><name>de</name><operator>-&gt;</operator><name>d_name</name></name> <operator>+</operator> <name>oidchars</name> <operator>+</operator> <literal type="number">1</literal> <operator>+</operator>
					 <call><name>strlen</name><argument_list>(<argument><expr><name><name>forkNames</name><index>[<expr><name>INIT_FORKNUM</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>fsync_fname</name><argument_list>(<argument><expr><name>mainpath</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></while>

		<expr_stmt><expr><call><name>FreeDir</name><argument_list>(<argument><expr><name>dbspace_dir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Lastly, fsync the database directory itself, ensuring the
		 * filesystem remembers the file creations and deletions we've done.
		 * We don't bother with this during a call that does only
		 * UNLOGGED_RELATION_CLEANUP, because if recovery crashes before we
		 * get to doing UNLOGGED_RELATION_INIT, we'll redo the cleanup step
		 * too at the next startup attempt.
		 */</comment>
		<expr_stmt><expr><call><name>fsync_fname</name><argument_list>(<argument><expr><name>dbspacedirname</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Basic parsing of putative relation filenames.
 *
 * This function returns true if the file appears to be in the correct format
 * for a non-temporary relation and false otherwise.
 *
 * NB: If this function returns true, the caller is entitled to assume that
 * *oidchars has been set to the a value no more than OIDCHARS, and thus
 * that a buffer of OIDCHARS+1 characters is sufficient to hold the OID
 * portion of the filename.  This is critical to protect against a possible
 * buffer overrun.
 */</comment>
<function><type><name>bool</name></type>
<name>parse_filename_for_nontemp_relation</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>oidchars</name></decl></parameter>,
									<parameter><decl><type><name>ForkNumber</name> <modifier>*</modifier></type><name>fork</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>pos</name></decl>;</decl_stmt>

	<comment type="block">/* Look for a non-empty string of digits (that isn't too long). */</comment>
	<for>for <control>(<init><expr><name>pos</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><call><name>isdigit</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator> <name><name>name</name><index>[<expr><name>pos</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><operator>++</operator><name>pos</name></expr></incr>)</control><block type="pseudo"><block_content>
		<empty_stmt>;</empty_stmt></block_content></block></for>
	<if_stmt><if>if <condition>(<expr><name>pos</name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <name>pos</name> <operator>&gt;</operator> <name>OIDCHARS</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
	<expr_stmt><expr><operator>*</operator><name>oidchars</name> <operator>=</operator> <name>pos</name></expr>;</expr_stmt>

	<comment type="block">/* Check for a fork name. */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>name</name><index>[<expr><name>pos</name></expr>]</index></name> <operator>!=</operator> <literal type="char">'_'</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><operator>*</operator><name>fork</name> <operator>=</operator> <name>MAIN_FORKNUM</name></expr>;</expr_stmt></block_content></block></if>
	<else>else
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>forkchar</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>forkchar</name> <operator>=</operator> <call><name>forkname_chars</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>name</name><index>[<expr><name>pos</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name>fork</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>forkchar</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>pos</name> <operator>+=</operator> <name>forkchar</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/* Check for a segment number. */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>name</name><index>[<expr><name>pos</name></expr>]</index></name> <operator>==</operator> <literal type="char">'.'</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>segchar</name></decl>;</decl_stmt>

		<for>for <control>(<init><expr><name>segchar</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><call><name>isdigit</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator> <name><name>name</name><index>[<expr><name>pos</name> <operator>+</operator> <name>segchar</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><operator>++</operator><name>segchar</name></expr></incr>)</control><block type="pseudo"><block_content>
			<empty_stmt>;</empty_stmt></block_content></block></for>
		<if_stmt><if>if <condition>(<expr><name>segchar</name> <operator>&lt;=</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>pos</name> <operator>+=</operator> <name>segchar</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Now we should be at the end. */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>name</name><index>[<expr><name>pos</name></expr>]</index></name> <operator>!=</operator> <literal type="char">'\0'</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>
</unit>
