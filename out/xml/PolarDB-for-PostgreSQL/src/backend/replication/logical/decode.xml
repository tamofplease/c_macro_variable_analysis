<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/PolarDB-for-PostgreSQL/src/backend/replication/logical/decode.c"><comment type="block">/* -------------------------------------------------------------------------
 *
 * decode.c
 *		This module decodes WAL records read using xlogreader.h's APIs for the
 *		purpose of logical decoding by passing information to the
 *		reorderbuffer module (containing the actual changes) and to the
 *		snapbuild module to build a fitting catalog snapshot (to be able to
 *		properly decode the changes in the reorderbuffer).
 *
 * NOTE:
 *		This basically tries to handle all low level xlog stuff for
 *		reorderbuffer.c and snapbuild.c. There's some minor leakage where a
 *		specific record's struct is used to pass data along, but those just
 *		happen to contain the right amount of data in a convenient
 *		format. There isn't and shouldn't be much intelligence about the
 *		contents of records in here except turning them into a more usable
 *		format.
 *
 * Portions Copyright (c) 1996-2018, PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, Regents of the University of California
 *
 * IDENTIFICATION
 *	  src/backend/replication/logical/decode.c
 *
 * -------------------------------------------------------------------------
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/heapam.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/heapam_xlog.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/transam.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/xact.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/xlog_internal.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/xlogutils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/xlogreader.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/xlogrecord.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_control.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"replication/decode.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"replication/logical.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"replication/message.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"replication/reorderbuffer.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"replication/origin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"replication/snapbuild.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/standby.h"</cpp:file></cpp:include>

<typedef>typedef <type><struct>struct <name>XLogRecordBuffer</name>
<block>{
	<decl_stmt><decl><type><name>XLogRecPtr</name></type>	<name>origptr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>XLogRecPtr</name></type>	<name>endptr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>XLogReaderState</name> <modifier>*</modifier></type><name>record</name></decl>;</decl_stmt>
}</block></struct></type> <name>XLogRecordBuffer</name>;</typedef>

<comment type="block">/* RMGR Handlers */</comment>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>DecodeXLogOp</name><parameter_list>(<parameter><decl><type><name>LogicalDecodingContext</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>, <parameter><decl><type><name>XLogRecordBuffer</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>DecodeHeapOp</name><parameter_list>(<parameter><decl><type><name>LogicalDecodingContext</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>, <parameter><decl><type><name>XLogRecordBuffer</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>DecodeHeap2Op</name><parameter_list>(<parameter><decl><type><name>LogicalDecodingContext</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>, <parameter><decl><type><name>XLogRecordBuffer</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>DecodeXactOp</name><parameter_list>(<parameter><decl><type><name>LogicalDecodingContext</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>, <parameter><decl><type><name>XLogRecordBuffer</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>DecodeStandbyOp</name><parameter_list>(<parameter><decl><type><name>LogicalDecodingContext</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>, <parameter><decl><type><name>XLogRecordBuffer</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>DecodeLogicalMsgOp</name><parameter_list>(<parameter><decl><type><name>LogicalDecodingContext</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>, <parameter><decl><type><name>XLogRecordBuffer</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/* individual record(group)'s handlers */</comment>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>DecodeInsert</name><parameter_list>(<parameter><decl><type><name>LogicalDecodingContext</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>, <parameter><decl><type><name>XLogRecordBuffer</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>DecodeUpdate</name><parameter_list>(<parameter><decl><type><name>LogicalDecodingContext</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>, <parameter><decl><type><name>XLogRecordBuffer</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>DecodeDelete</name><parameter_list>(<parameter><decl><type><name>LogicalDecodingContext</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>, <parameter><decl><type><name>XLogRecordBuffer</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>DecodeTruncate</name><parameter_list>(<parameter><decl><type><name>LogicalDecodingContext</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>, <parameter><decl><type><name>XLogRecordBuffer</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>DecodeMultiInsert</name><parameter_list>(<parameter><decl><type><name>LogicalDecodingContext</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>, <parameter><decl><type><name>XLogRecordBuffer</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>DecodeSpecConfirm</name><parameter_list>(<parameter><decl><type><name>LogicalDecodingContext</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>, <parameter><decl><type><name>XLogRecordBuffer</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>DecodeCommit</name><parameter_list>(<parameter><decl><type><name>LogicalDecodingContext</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>, <parameter><decl><type><name>XLogRecordBuffer</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>,
			 <parameter><decl><type><name>xl_xact_parsed_commit</name> <modifier>*</modifier></type><name>parsed</name></decl></parameter>, <parameter><decl><type><name>TransactionId</name></type> <name>xid</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>DecodeAbort</name><parameter_list>(<parameter><decl><type><name>LogicalDecodingContext</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>, <parameter><decl><type><name>XLogRecordBuffer</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>,
			<parameter><decl><type><name>xl_xact_parsed_abort</name> <modifier>*</modifier></type><name>parsed</name></decl></parameter>, <parameter><decl><type><name>TransactionId</name></type> <name>xid</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/* common function to decode tuples */</comment>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>DecodeXLogTuple</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>data</name></decl></parameter>, <parameter><decl><type><name>Size</name></type> <name>len</name></decl></parameter>, <parameter><decl><type><name>ReorderBufferTupleBuf</name> <modifier>*</modifier></type><name>tup</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/*
 * Take every XLogReadRecord()ed record and perform the actions required to
 * decode it using the output plugin already setup in the logical decoding
 * context.
 *
 * NB: Note that every record's xid needs to be processed by reorderbuffer
 * (xids contained in the content of records are not relevant for this rule).
 * That means that for records which'd otherwise not go through the
 * reorderbuffer ReorderBufferProcessXid() has to be called. We don't want to
 * call ReorderBufferProcessXid for each record type by default, because
 * e.g. empty xacts can be handled more efficiently if there's no previous
 * state for them.
 *
 * We also support the ability to fast forward thru records, skipping some
 * record types completely - see individual record types for details.
 */</comment>
<function><type><name>void</name></type>
<name>LogicalDecodingProcessRecord</name><parameter_list>(<parameter><decl><type><name>LogicalDecodingContext</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>, <parameter><decl><type><name>XLogReaderState</name> <modifier>*</modifier></type><name>record</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>XLogRecordBuffer</name></type> <name>buf</name></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>buf</name><operator>.</operator><name>origptr</name></name> <operator>=</operator> <name><name>ctx</name><operator>-&gt;</operator><name>reader</name><operator>-&gt;</operator><name>ReadRecPtr</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>buf</name><operator>.</operator><name>endptr</name></name> <operator>=</operator> <name><name>ctx</name><operator>-&gt;</operator><name>reader</name><operator>-&gt;</operator><name>EndRecPtr</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>buf</name><operator>.</operator><name>record</name></name> <operator>=</operator> <name>record</name></expr>;</expr_stmt>

	<comment type="block">/* cast so we get a warning when new rmgrs are added */</comment>
	<switch>switch <condition>(<expr><operator>(</operator><name>RmgrIds</name><operator>)</operator> <call><name>XLogRecGetRmid</name><argument_list>(<argument><expr><name>record</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
			<comment type="block">/*
			 * Rmgrs we care about for logical decoding. Add new rmgrs in
			 * rmgrlist.h's order.
			 */</comment>
		<case>case <expr><name>RM_XLOG_ID</name></expr>:</case>
			<expr_stmt><expr><call><name>DecodeXLogOp</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>RM_XACT_ID</name></expr>:</case>
			<expr_stmt><expr><call><name>DecodeXactOp</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>RM_STANDBY_ID</name></expr>:</case>
			<expr_stmt><expr><call><name>DecodeStandbyOp</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>RM_HEAP2_ID</name></expr>:</case>
			<expr_stmt><expr><call><name>DecodeHeap2Op</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>RM_HEAP_ID</name></expr>:</case>
			<expr_stmt><expr><call><name>DecodeHeapOp</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>RM_LOGICALMSG_ID</name></expr>:</case>
			<expr_stmt><expr><call><name>DecodeLogicalMsgOp</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

			<comment type="block">/*
			 * Rmgrs irrelevant for logical decoding; they describe stuff not
			 * represented in logical decoding. Add new rmgrs in rmgrlist.h's
			 * order.
			 */</comment>
		<case>case <expr><name>RM_SMGR_ID</name></expr>:</case>
		<case>case <expr><name>RM_CLOG_ID</name></expr>:</case>
		<case>case <expr><name>RM_DBASE_ID</name></expr>:</case>
		<case>case <expr><name>RM_TBLSPC_ID</name></expr>:</case>
		<case>case <expr><name>RM_MULTIXACT_ID</name></expr>:</case>
		<case>case <expr><name>RM_RELMAP_ID</name></expr>:</case>
		<case>case <expr><name>RM_BTREE_ID</name></expr>:</case>
		<case>case <expr><name>RM_HASH_ID</name></expr>:</case>
		<case>case <expr><name>RM_GIN_ID</name></expr>:</case>
		<case>case <expr><name>RM_GIST_ID</name></expr>:</case>
		<case>case <expr><name>RM_SEQ_ID</name></expr>:</case>
		<case>case <expr><name>RM_SPGIST_ID</name></expr>:</case>
		<case>case <expr><name>RM_BRIN_ID</name></expr>:</case>
		<case>case <expr><name>RM_COMMIT_TS_ID</name></expr>:</case>
		<case>case <expr><name>RM_REPLORIGIN_ID</name></expr>:</case>
		<case>case <expr><name>RM_GENERIC_ID</name></expr>:</case>
			<comment type="block">/* just deal with xid, and done */</comment>
			<expr_stmt><expr><call><name>ReorderBufferProcessXid</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>reorder</name></name></expr></argument>, <argument><expr><call><name>XLogRecGetXid</name><argument_list>(<argument><expr><name>record</name></expr></argument>)</argument_list></call></expr></argument>,
									<argument><expr><name><name>buf</name><operator>.</operator><name>origptr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>RM_NEXT_ID</name></expr>:</case>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unexpected RM_NEXT_ID rmgr_id: %u"</literal></expr></argument>, <argument><expr><operator>(</operator><name>RmgrIds</name><operator>)</operator> <call><name>XLogRecGetRmid</name><argument_list>(<argument><expr><name><name>buf</name><operator>.</operator><name>record</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></switch>
</block_content>}</block></function>

<comment type="block">/*
 * Handle rmgr XLOG_ID records for DecodeRecordIntoReorderBuffer().
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>DecodeXLogOp</name><parameter_list>(<parameter><decl><type><name>LogicalDecodingContext</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>, <parameter><decl><type><name>XLogRecordBuffer</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>SnapBuild</name>  <modifier>*</modifier></type><name>builder</name> <init>= <expr><name><name>ctx</name><operator>-&gt;</operator><name>snapshot_builder</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint8</name></type>		<name>info</name> <init>= <expr><call><name>XLogRecGetInfo</name><argument_list>(<argument><expr><name><name>buf</name><operator>-&gt;</operator><name>record</name></name></expr></argument>)</argument_list></call> <operator>&amp;</operator> <operator>~</operator><name>XLR_INFO_MASK</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>ReorderBufferProcessXid</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>reorder</name></name></expr></argument>, <argument><expr><call><name>XLogRecGetXid</name><argument_list>(<argument><expr><name><name>buf</name><operator>-&gt;</operator><name>record</name></name></expr></argument>)</argument_list></call></expr></argument>,
							<argument><expr><name><name>buf</name><operator>-&gt;</operator><name>origptr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<switch>switch <condition>(<expr><name>info</name></expr>)</condition>
	<block>{<block_content>
			<comment type="block">/* this is also used in END_OF_RECOVERY checkpoints */</comment>
		<case>case <expr><name>XLOG_CHECKPOINT_SHUTDOWN</name></expr>:</case>
		<case>case <expr><name>XLOG_END_OF_RECOVERY</name></expr>:</case>
			<expr_stmt><expr><call><name>SnapBuildSerializationPoint</name><argument_list>(<argument><expr><name>builder</name></expr></argument>, <argument><expr><name><name>buf</name><operator>-&gt;</operator><name>origptr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<break>break;</break>
		<case>case <expr><name>XLOG_CHECKPOINT_ONLINE</name></expr>:</case>

			<comment type="block">/*
			 * a RUNNING_XACTS record will have been logged near to this, we
			 * can restart from there.
			 */</comment>
			<break>break;</break>
		<case>case <expr><name>XLOG_NOOP</name></expr>:</case>
		<case>case <expr><name>XLOG_NEXTOID</name></expr>:</case>
		<case>case <expr><name>XLOG_SWITCH</name></expr>:</case>
		<case>case <expr><name>XLOG_BACKUP_END</name></expr>:</case>
		<case>case <expr><name>XLOG_PARAMETER_CHANGE</name></expr>:</case>
		<case>case <expr><name>XLOG_RESTORE_POINT</name></expr>:</case>
		<case>case <expr><name>XLOG_FPW_CHANGE</name></expr>:</case>
		<case>case <expr><name>XLOG_FPI_FOR_HINT</name></expr>:</case>
		<case>case <expr><name>XLOG_FPI</name></expr>:</case>
		<comment type="block">/* POLAR: for fullpage snapshot */</comment>
		<case>case <expr><name>XLOG_FPSI</name></expr>:</case>
		<case>case <expr><name>XLOG_CSNLOG_ZEROPAGE</name></expr>:</case>
		<case>case <expr><name>XLOG_CSNLOG_TRUNCATE</name></expr>:</case>
		<comment type="block">/* POLAR end */</comment>
		<case>case <expr><name>XLOG_FPI_MULTI</name></expr>:</case>
			<break>break;</break>
		<default>default:</default>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unexpected RM_XLOG_ID record type: %u"</literal></expr></argument>, <argument><expr><name>info</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></switch>
</block_content>}</block></function>

<comment type="block">/*
 * Handle rmgr XACT_ID records for DecodeRecordIntoReorderBuffer().
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>DecodeXactOp</name><parameter_list>(<parameter><decl><type><name>LogicalDecodingContext</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>, <parameter><decl><type><name>XLogRecordBuffer</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>SnapBuild</name>  <modifier>*</modifier></type><name>builder</name> <init>= <expr><name><name>ctx</name><operator>-&gt;</operator><name>snapshot_builder</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ReorderBuffer</name> <modifier>*</modifier></type><name>reorder</name> <init>= <expr><name><name>ctx</name><operator>-&gt;</operator><name>reorder</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>XLogReaderState</name> <modifier>*</modifier></type><name>r</name> <init>= <expr><name><name>buf</name><operator>-&gt;</operator><name>record</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint8</name></type>		<name>info</name> <init>= <expr><call><name>XLogRecGetInfo</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call> <operator>&amp;</operator> <name>XLOG_XACT_OPMASK</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * If the snapshot isn't yet fully built, we cannot decode anything, so
	 * bail out.
	 *
	 * However, it's critical to process XLOG_XACT_ASSIGNMENT records even
	 * when the snapshot is being built: it is possible to get later records
	 * that require subxids to be properly assigned.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>SnapBuildCurrentState</name><argument_list>(<argument><expr><name>builder</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <name>SNAPBUILD_FULL_SNAPSHOT</name> <operator>&amp;&amp;</operator>
		<name>info</name> <operator>!=</operator> <name>XLOG_XACT_ASSIGNMENT</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<switch>switch <condition>(<expr><name>info</name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>XLOG_XACT_COMMIT</name></expr>:</case>
		<case>case <expr><name>XLOG_XACT_COMMIT_PREPARED</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>xl_xact_commit</name> <modifier>*</modifier></type><name>xlrec</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>xl_xact_parsed_commit</name></type> <name>parsed</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>TransactionId</name></type> <name>xid</name></decl>;</decl_stmt>

				<expr_stmt><expr><name>xlrec</name> <operator>=</operator> <operator>(</operator><name>xl_xact_commit</name> <operator>*</operator><operator>)</operator> <call><name>XLogRecGetData</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>ParseCommitRecord</name><argument_list>(<argument><expr><call><name>XLogRecGetInfo</name><argument_list>(<argument><expr><name><name>buf</name><operator>-&gt;</operator><name>record</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>xlrec</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>parsed</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>TransactionIdIsValid</name><argument_list>(<argument><expr><name><name>parsed</name><operator>.</operator><name>twophase_xid</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>xid</name> <operator>=</operator> <call><name>XLogRecGetXid</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><name>xid</name> <operator>=</operator> <name><name>parsed</name><operator>.</operator><name>twophase_xid</name></name></expr>;</expr_stmt></block_content></block></else></if_stmt>

				<expr_stmt><expr><call><name>DecodeCommit</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>parsed</name></expr></argument>, <argument><expr><name>xid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block>
		<case>case <expr><name>XLOG_XACT_ABORT</name></expr>:</case>
		<case>case <expr><name>XLOG_XACT_ABORT_PREPARED</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>xl_xact_abort</name> <modifier>*</modifier></type><name>xlrec</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>xl_xact_parsed_abort</name></type> <name>parsed</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>TransactionId</name></type> <name>xid</name></decl>;</decl_stmt>

				<expr_stmt><expr><name>xlrec</name> <operator>=</operator> <operator>(</operator><name>xl_xact_abort</name> <operator>*</operator><operator>)</operator> <call><name>XLogRecGetData</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>ParseAbortRecord</name><argument_list>(<argument><expr><call><name>XLogRecGetInfo</name><argument_list>(<argument><expr><name><name>buf</name><operator>-&gt;</operator><name>record</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>xlrec</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>parsed</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>TransactionIdIsValid</name><argument_list>(<argument><expr><name><name>parsed</name><operator>.</operator><name>twophase_xid</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>xid</name> <operator>=</operator> <call><name>XLogRecGetXid</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><name>xid</name> <operator>=</operator> <name><name>parsed</name><operator>.</operator><name>twophase_xid</name></name></expr>;</expr_stmt></block_content></block></else></if_stmt>

				<expr_stmt><expr><call><name>DecodeAbort</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>parsed</name></expr></argument>, <argument><expr><name>xid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block>
		<case>case <expr><name>XLOG_XACT_ASSIGNMENT</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>xl_xact_assignment</name> <modifier>*</modifier></type><name>xlrec</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>TransactionId</name> <modifier>*</modifier></type><name>sub_xid</name></decl>;</decl_stmt>

				<expr_stmt><expr><name>xlrec</name> <operator>=</operator> <operator>(</operator><name>xl_xact_assignment</name> <operator>*</operator><operator>)</operator> <call><name>XLogRecGetData</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><name>sub_xid</name> <operator>=</operator> <operator>&amp;</operator><name><name>xlrec</name><operator>-&gt;</operator><name>xsub</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>

				<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>xlrec</name><operator>-&gt;</operator><name>nsubxacts</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
				<block>{<block_content>
					<expr_stmt><expr><call><name>ReorderBufferAssignChild</name><argument_list>(<argument><expr><name>reorder</name></expr></argument>, <argument><expr><name><name>xlrec</name><operator>-&gt;</operator><name>xtop</name></name></expr></argument>,
											 <argument><expr><operator>*</operator><operator>(</operator><name>sub_xid</name><operator>++</operator><operator>)</operator></expr></argument>, <argument><expr><name><name>buf</name><operator>-&gt;</operator><name>origptr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></for>
				<break>break;</break>
			</block_content>}</block>
		<case>case <expr><name>XLOG_XACT_PREPARE</name></expr>:</case>

			<comment type="block">/*
			 * Currently decoding ignores PREPARE TRANSACTION and will just
			 * decode the transaction when the COMMIT PREPARED is sent or
			 * throw away the transaction's contents when a ROLLBACK PREPARED
			 * is received. In the future we could add code to expose prepared
			 * transactions in the changestream allowing for a kind of
			 * distributed 2PC.
			 */</comment>
			<expr_stmt><expr><call><name>ReorderBufferProcessXid</name><argument_list>(<argument><expr><name>reorder</name></expr></argument>, <argument><expr><call><name>XLogRecGetXid</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>buf</name><operator>-&gt;</operator><name>origptr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<default>default:</default>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unexpected RM_XACT_ID record type: %u"</literal></expr></argument>, <argument><expr><name>info</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></switch>
</block_content>}</block></function>

<comment type="block">/*
 * Handle rmgr STANDBY_ID records for DecodeRecordIntoReorderBuffer().
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>DecodeStandbyOp</name><parameter_list>(<parameter><decl><type><name>LogicalDecodingContext</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>, <parameter><decl><type><name>XLogRecordBuffer</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>SnapBuild</name>  <modifier>*</modifier></type><name>builder</name> <init>= <expr><name><name>ctx</name><operator>-&gt;</operator><name>snapshot_builder</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>XLogReaderState</name> <modifier>*</modifier></type><name>r</name> <init>= <expr><name><name>buf</name><operator>-&gt;</operator><name>record</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint8</name></type>		<name>info</name> <init>= <expr><call><name>XLogRecGetInfo</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call> <operator>&amp;</operator> <operator>~</operator><name>XLR_INFO_MASK</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>ReorderBufferProcessXid</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>reorder</name></name></expr></argument>, <argument><expr><call><name>XLogRecGetXid</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>buf</name><operator>-&gt;</operator><name>origptr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<switch>switch <condition>(<expr><name>info</name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>XLOG_RUNNING_XACTS</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>xl_running_xacts</name> <modifier>*</modifier></type><name>running</name> <init>= <expr><operator>(</operator><name>xl_running_xacts</name> <operator>*</operator><operator>)</operator> <call><name>XLogRecGetData</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>SnapBuildProcessRunningXacts</name><argument_list>(<argument><expr><name>builder</name></expr></argument>, <argument><expr><name><name>buf</name><operator>-&gt;</operator><name>origptr</name></name></expr></argument>, <argument><expr><name>running</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/*
				 * Abort all transactions that we keep track of, that are
				 * older than the record's oldestRunningXid. This is the most
				 * convenient spot for doing so since, in contrast to shutdown
				 * or end-of-recovery checkpoints, we have information about
				 * all running transactions which includes prepared ones,
				 * while shutdown checkpoints just know that no non-prepared
				 * transactions are in progress.
				 */</comment>
				<expr_stmt><expr><call><name>ReorderBufferAbortOld</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>reorder</name></name></expr></argument>, <argument><expr><name><name>running</name><operator>-&gt;</operator><name>oldestRunningXid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>XLOG_STANDBY_LOCK</name></expr>:</case>
			<break>break;</break>
		<case>case <expr><name>XLOG_INVALIDATIONS</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>xl_invalidations</name> <modifier>*</modifier></type><name>invalidations</name> <init>=
				<expr><operator>(</operator><name>xl_invalidations</name> <operator>*</operator><operator>)</operator> <call><name>XLogRecGetData</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>ctx</name><operator>-&gt;</operator><name>fast_forward</name></name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ReorderBufferImmediateInvalidation</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>reorder</name></name></expr></argument>,
													   <argument><expr><name><name>invalidations</name><operator>-&gt;</operator><name>nmsgs</name></name></expr></argument>,
													   <argument><expr><name><name>invalidations</name><operator>-&gt;</operator><name>msgs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block>
			<break>break;</break>
		<default>default:</default>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unexpected RM_STANDBY_ID record type: %u"</literal></expr></argument>, <argument><expr><name>info</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></switch>
</block_content>}</block></function>

<comment type="block">/*
 * Handle rmgr HEAP2_ID records for DecodeRecordIntoReorderBuffer().
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>DecodeHeap2Op</name><parameter_list>(<parameter><decl><type><name>LogicalDecodingContext</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>, <parameter><decl><type><name>XLogRecordBuffer</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>uint8</name></type>		<name>info</name> <init>= <expr><call><name>XLogRecGetInfo</name><argument_list>(<argument><expr><name><name>buf</name><operator>-&gt;</operator><name>record</name></name></expr></argument>)</argument_list></call> <operator>&amp;</operator> <name>XLOG_HEAP_OPMASK</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TransactionId</name></type> <name>xid</name> <init>= <expr><call><name>XLogRecGetXid</name><argument_list>(<argument><expr><name><name>buf</name><operator>-&gt;</operator><name>record</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SnapBuild</name>  <modifier>*</modifier></type><name>builder</name> <init>= <expr><name><name>ctx</name><operator>-&gt;</operator><name>snapshot_builder</name></name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>ReorderBufferProcessXid</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>reorder</name></name></expr></argument>, <argument><expr><name>xid</name></expr></argument>, <argument><expr><name><name>buf</name><operator>-&gt;</operator><name>origptr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If we don't have snapshot or we are just fast-forwarding, there is no
	 * point in decoding changes.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>SnapBuildCurrentState</name><argument_list>(<argument><expr><name>builder</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <name>SNAPBUILD_FULL_SNAPSHOT</name> <operator>||</operator>
		<name><name>ctx</name><operator>-&gt;</operator><name>fast_forward</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<switch>switch <condition>(<expr><name>info</name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>XLOG_HEAP2_MULTI_INSERT</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>ctx</name><operator>-&gt;</operator><name>fast_forward</name></name> <operator>&amp;&amp;</operator>
				<call><name>SnapBuildProcessChange</name><argument_list>(<argument><expr><name>builder</name></expr></argument>, <argument><expr><name>xid</name></expr></argument>, <argument><expr><name><name>buf</name><operator>-&gt;</operator><name>origptr</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>DecodeMultiInsert</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<break>break;</break>
		<case>case <expr><name>XLOG_HEAP2_NEW_CID</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>xl_heap_new_cid</name> <modifier>*</modifier></type><name>xlrec</name></decl>;</decl_stmt>

				<expr_stmt><expr><name>xlrec</name> <operator>=</operator> <operator>(</operator><name>xl_heap_new_cid</name> <operator>*</operator><operator>)</operator> <call><name>XLogRecGetData</name><argument_list>(<argument><expr><name><name>buf</name><operator>-&gt;</operator><name>record</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>SnapBuildProcessNewCid</name><argument_list>(<argument><expr><name>builder</name></expr></argument>, <argument><expr><name>xid</name></expr></argument>, <argument><expr><name><name>buf</name><operator>-&gt;</operator><name>origptr</name></name></expr></argument>, <argument><expr><name>xlrec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<break>break;</break>
			</block_content>}</block>
		<case>case <expr><name>XLOG_HEAP2_REWRITE</name></expr>:</case>

			<comment type="block">/*
			 * Although these records only exist to serve the needs of logical
			 * decoding, all the work happens as part of crash or archive
			 * recovery, so we don't need to do anything here.
			 */</comment>
			<break>break;</break>

			<comment type="block">/*
			 * Everything else here is just low level physical stuff we're not
			 * interested in.
			 */</comment>
		<case>case <expr><name>XLOG_HEAP2_FREEZE_PAGE</name></expr>:</case>
		<case>case <expr><name>XLOG_HEAP2_CLEAN</name></expr>:</case>
		<case>case <expr><name>XLOG_HEAP2_CLEANUP_INFO</name></expr>:</case>
		<case>case <expr><name>XLOG_HEAP2_VISIBLE</name></expr>:</case>
		<case>case <expr><name>XLOG_HEAP2_LOCK_UPDATED</name></expr>:</case>
			<break>break;</break>
		<default>default:</default>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unexpected RM_HEAP2_ID record type: %u"</literal></expr></argument>, <argument><expr><name>info</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></switch>
</block_content>}</block></function>

<comment type="block">/*
 * Handle rmgr HEAP_ID records for DecodeRecordIntoReorderBuffer().
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>DecodeHeapOp</name><parameter_list>(<parameter><decl><type><name>LogicalDecodingContext</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>, <parameter><decl><type><name>XLogRecordBuffer</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>uint8</name></type>		<name>info</name> <init>= <expr><call><name>XLogRecGetInfo</name><argument_list>(<argument><expr><name><name>buf</name><operator>-&gt;</operator><name>record</name></name></expr></argument>)</argument_list></call> <operator>&amp;</operator> <name>XLOG_HEAP_OPMASK</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TransactionId</name></type> <name>xid</name> <init>= <expr><call><name>XLogRecGetXid</name><argument_list>(<argument><expr><name><name>buf</name><operator>-&gt;</operator><name>record</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SnapBuild</name>  <modifier>*</modifier></type><name>builder</name> <init>= <expr><name><name>ctx</name><operator>-&gt;</operator><name>snapshot_builder</name></name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>ReorderBufferProcessXid</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>reorder</name></name></expr></argument>, <argument><expr><name>xid</name></expr></argument>, <argument><expr><name><name>buf</name><operator>-&gt;</operator><name>origptr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If we don't have snapshot or we are just fast-forwarding, there is no
	 * point in decoding data changes.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>SnapBuildCurrentState</name><argument_list>(<argument><expr><name>builder</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <name>SNAPBUILD_FULL_SNAPSHOT</name> <operator>||</operator>
		<name><name>ctx</name><operator>-&gt;</operator><name>fast_forward</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<switch>switch <condition>(<expr><name>info</name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>XLOG_HEAP_INSERT</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><call><name>SnapBuildProcessChange</name><argument_list>(<argument><expr><name>builder</name></expr></argument>, <argument><expr><name>xid</name></expr></argument>, <argument><expr><name><name>buf</name><operator>-&gt;</operator><name>origptr</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>DecodeInsert</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<break>break;</break>

			<comment type="block">/*
			 * Treat HOT update as normal updates. There is no useful
			 * information in the fact that we could make it a HOT update
			 * locally and the WAL layout is compatible.
			 */</comment>
		<case>case <expr><name>XLOG_HEAP_HOT_UPDATE</name></expr>:</case>
		<case>case <expr><name>XLOG_HEAP_UPDATE</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><call><name>SnapBuildProcessChange</name><argument_list>(<argument><expr><name>builder</name></expr></argument>, <argument><expr><name>xid</name></expr></argument>, <argument><expr><name><name>buf</name><operator>-&gt;</operator><name>origptr</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>DecodeUpdate</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<break>break;</break>

		<case>case <expr><name>XLOG_HEAP_DELETE</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><call><name>SnapBuildProcessChange</name><argument_list>(<argument><expr><name>builder</name></expr></argument>, <argument><expr><name>xid</name></expr></argument>, <argument><expr><name><name>buf</name><operator>-&gt;</operator><name>origptr</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>DecodeDelete</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<break>break;</break>

		<case>case <expr><name>XLOG_HEAP_TRUNCATE</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><call><name>SnapBuildProcessChange</name><argument_list>(<argument><expr><name>builder</name></expr></argument>, <argument><expr><name>xid</name></expr></argument>, <argument><expr><name><name>buf</name><operator>-&gt;</operator><name>origptr</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>DecodeTruncate</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<break>break;</break>

		<case>case <expr><name>XLOG_HEAP_INPLACE</name></expr>:</case>

			<comment type="block">/*
			 * Inplace updates are only ever performed on catalog tuples and
			 * can, per definition, not change tuple visibility.  Since we
			 * don't decode catalog tuples, we're not interested in the
			 * record's contents.
			 *
			 * In-place updates can be used either by XID-bearing transactions
			 * (e.g.  in CREATE INDEX CONCURRENTLY) or by XID-less
			 * transactions (e.g.  VACUUM).  In the former case, the commit
			 * record will include cache invalidations, so we mark the
			 * transaction as catalog modifying here. Currently that's
			 * redundant because the commit will do that as well, but once we
			 * support decoding in-progress relations, this will be important.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>TransactionIdIsValid</name><argument_list>(<argument><expr><name>xid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<break>break;</break></block_content></block></if></if_stmt>

			<expr_stmt><expr><call><name>SnapBuildProcessChange</name><argument_list>(<argument><expr><name>builder</name></expr></argument>, <argument><expr><name>xid</name></expr></argument>, <argument><expr><name><name>buf</name><operator>-&gt;</operator><name>origptr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>ReorderBufferXidSetCatalogChanges</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>reorder</name></name></expr></argument>, <argument><expr><name>xid</name></expr></argument>, <argument><expr><name><name>buf</name><operator>-&gt;</operator><name>origptr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>XLOG_HEAP_CONFIRM</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><call><name>SnapBuildProcessChange</name><argument_list>(<argument><expr><name>builder</name></expr></argument>, <argument><expr><name>xid</name></expr></argument>, <argument><expr><name><name>buf</name><operator>-&gt;</operator><name>origptr</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>DecodeSpecConfirm</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<break>break;</break>

		<case>case <expr><name>XLOG_HEAP_LOCK</name></expr>:</case>
			<comment type="block">/* we don't care about row level locks for now */</comment>
			<break>break;</break>

		<default>default:</default>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unexpected RM_HEAP_ID record type: %u"</literal></expr></argument>, <argument><expr><name>info</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
	</block_content>}</block></switch>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>bool</name></type>
<name>FilterByOrigin</name><parameter_list>(<parameter><decl><type><name>LogicalDecodingContext</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>, <parameter><decl><type><name>RepOriginId</name></type> <name>origin_id</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name><name>ctx</name><operator>-&gt;</operator><name>callbacks</name><operator>.</operator><name>filter_by_origin_cb</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<return>return <expr><call><name>filter_by_origin_cb_wrapper</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>origin_id</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Handle rmgr LOGICALMSG_ID records for DecodeRecordIntoReorderBuffer().
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>DecodeLogicalMsgOp</name><parameter_list>(<parameter><decl><type><name>LogicalDecodingContext</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>, <parameter><decl><type><name>XLogRecordBuffer</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>SnapBuild</name>  <modifier>*</modifier></type><name>builder</name> <init>= <expr><name><name>ctx</name><operator>-&gt;</operator><name>snapshot_builder</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>XLogReaderState</name> <modifier>*</modifier></type><name>r</name> <init>= <expr><name><name>buf</name><operator>-&gt;</operator><name>record</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TransactionId</name></type> <name>xid</name> <init>= <expr><call><name>XLogRecGetXid</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint8</name></type>		<name>info</name> <init>= <expr><call><name>XLogRecGetInfo</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call> <operator>&amp;</operator> <operator>~</operator><name>XLR_INFO_MASK</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RepOriginId</name></type> <name>origin_id</name> <init>= <expr><call><name>XLogRecGetOrigin</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Snapshot</name></type>	<name>snapshot</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>xl_logical_message</name> <modifier>*</modifier></type><name>message</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>info</name> <operator>!=</operator> <name>XLOG_LOGICAL_MESSAGE</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unexpected RM_LOGICALMSG_ID record type: %u"</literal></expr></argument>, <argument><expr><name>info</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>ReorderBufferProcessXid</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>reorder</name></name></expr></argument>, <argument><expr><call><name>XLogRecGetXid</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>buf</name><operator>-&gt;</operator><name>origptr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If we don't have snapshot or we are just fast-forwarding, there is no
	 * point in decoding messages.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>SnapBuildCurrentState</name><argument_list>(<argument><expr><name>builder</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <name>SNAPBUILD_FULL_SNAPSHOT</name> <operator>||</operator>
		<name><name>ctx</name><operator>-&gt;</operator><name>fast_forward</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>message</name> <operator>=</operator> <operator>(</operator><name>xl_logical_message</name> <operator>*</operator><operator>)</operator> <call><name>XLogRecGetData</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>message</name><operator>-&gt;</operator><name>dbId</name></name> <operator>!=</operator> <name><name>ctx</name><operator>-&gt;</operator><name>slot</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>database</name></name> <operator>||</operator>
		<call><name>FilterByOrigin</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>origin_id</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>message</name><operator>-&gt;</operator><name>transactional</name></name> <operator>&amp;&amp;</operator>
		<operator>!</operator><call><name>SnapBuildProcessChange</name><argument_list>(<argument><expr><name>builder</name></expr></argument>, <argument><expr><name>xid</name></expr></argument>, <argument><expr><name><name>buf</name><operator>-&gt;</operator><name>origptr</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><operator>!</operator><name><name>message</name><operator>-&gt;</operator><name>transactional</name></name> <operator>&amp;&amp;</operator>
			 <operator>(</operator><call><name>SnapBuildCurrentState</name><argument_list>(<argument><expr><name>builder</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>SNAPBUILD_CONSISTENT</name> <operator>||</operator>
			  <call><name>SnapBuildXactNeedsSkip</name><argument_list>(<argument><expr><name>builder</name></expr></argument>, <argument><expr><name><name>buf</name><operator>-&gt;</operator><name>origptr</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>snapshot</name> <operator>=</operator> <call><name>SnapBuildGetOrBuildSnapshot</name><argument_list>(<argument><expr><name>builder</name></expr></argument>, <argument><expr><name>xid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ReorderBufferQueueMessage</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>reorder</name></name></expr></argument>, <argument><expr><name>xid</name></expr></argument>, <argument><expr><name>snapshot</name></expr></argument>, <argument><expr><name><name>buf</name><operator>-&gt;</operator><name>endptr</name></name></expr></argument>,
							  <argument><expr><name><name>message</name><operator>-&gt;</operator><name>transactional</name></name></expr></argument>,
							  <argument><expr><name><name>message</name><operator>-&gt;</operator><name>message</name></name></expr></argument>, <comment type="block">/* first part of message is
												 * prefix */</comment>
							  <argument><expr><name><name>message</name><operator>-&gt;</operator><name>message_size</name></name></expr></argument>,
							  <argument><expr><name><name>message</name><operator>-&gt;</operator><name>message</name></name> <operator>+</operator> <name><name>message</name><operator>-&gt;</operator><name>prefix_size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Consolidated commit record handling between the different form of commit
 * records.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>DecodeCommit</name><parameter_list>(<parameter><decl><type><name>LogicalDecodingContext</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>, <parameter><decl><type><name>XLogRecordBuffer</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>,
			 <parameter><decl><type><name>xl_xact_parsed_commit</name> <modifier>*</modifier></type><name>parsed</name></decl></parameter>, <parameter><decl><type><name>TransactionId</name></type> <name>xid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>XLogRecPtr</name></type>	<name>origin_lsn</name> <init>= <expr><name>InvalidXLogRecPtr</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TimestampTz</name></type> <name>commit_time</name> <init>= <expr><name><name>parsed</name><operator>-&gt;</operator><name>xact_time</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RepOriginId</name></type> <name>origin_id</name> <init>= <expr><call><name>XLogRecGetOrigin</name><argument_list>(<argument><expr><name><name>buf</name><operator>-&gt;</operator><name>record</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>parsed</name><operator>-&gt;</operator><name>xinfo</name></name> <operator>&amp;</operator> <name>XACT_XINFO_HAS_ORIGIN</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>origin_lsn</name> <operator>=</operator> <name><name>parsed</name><operator>-&gt;</operator><name>origin_lsn</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>commit_time</name> <operator>=</operator> <name><name>parsed</name><operator>-&gt;</operator><name>origin_timestamp</name></name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Process invalidation messages, even if we're not interested in the
	 * transaction's contents, since the various caches need to always be
	 * consistent.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>parsed</name><operator>-&gt;</operator><name>nmsgs</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>ctx</name><operator>-&gt;</operator><name>fast_forward</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ReorderBufferAddInvalidations</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>reorder</name></name></expr></argument>, <argument><expr><name>xid</name></expr></argument>, <argument><expr><name><name>buf</name><operator>-&gt;</operator><name>origptr</name></name></expr></argument>,
										  <argument><expr><name><name>parsed</name><operator>-&gt;</operator><name>nmsgs</name></name></expr></argument>, <argument><expr><name><name>parsed</name><operator>-&gt;</operator><name>msgs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>ReorderBufferXidSetCatalogChanges</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>reorder</name></name></expr></argument>, <argument><expr><name>xid</name></expr></argument>, <argument><expr><name><name>buf</name><operator>-&gt;</operator><name>origptr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>SnapBuildCommitTxn</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>snapshot_builder</name></name></expr></argument>, <argument><expr><name><name>buf</name><operator>-&gt;</operator><name>origptr</name></name></expr></argument>, <argument><expr><name>xid</name></expr></argument>,
					   <argument><expr><name><name>parsed</name><operator>-&gt;</operator><name>nsubxacts</name></name></expr></argument>, <argument><expr><name><name>parsed</name><operator>-&gt;</operator><name>subxacts</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* ----
	 * Check whether we are interested in this specific transaction, and tell
	 * the reorderbuffer to forget the content of the (sub-)transactions
	 * if not.
	 *
	 * There can be several reasons we might not be interested in this
	 * transaction:
	 * 1) We might not be interested in decoding transactions up to this
	 *	  LSN. This can happen because we previously decoded it and now just
	 *	  are restarting or if we haven't assembled a consistent snapshot yet.
	 * 2) The transaction happened in another database.
	 * 3) The output plugin is not interested in the origin.
	 * 4) We are doing fast-forwarding
	 *
	 * We can't just use ReorderBufferAbort() here, because we need to execute
	 * the transaction's invalidations.  This currently won't be needed if
	 * we're just skipping over the transaction because currently we only do
	 * so during startup, to get to the first transaction the client needs. As
	 * we have reset the catalog caches before starting to read WAL, and we
	 * haven't yet touched any catalogs, there can't be anything to invalidate.
	 * But if we're "forgetting" this commit because it's it happened in
	 * another database, the invalidations might be important, because they
	 * could be for shared catalogs and we might have loaded data into the
	 * relevant syscaches.
	 * ---
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>SnapBuildXactNeedsSkip</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>snapshot_builder</name></name></expr></argument>, <argument><expr><name><name>buf</name><operator>-&gt;</operator><name>origptr</name></name></expr></argument>)</argument_list></call> <operator>||</operator>
		<operator>(</operator><name><name>parsed</name><operator>-&gt;</operator><name>dbId</name></name> <operator>!=</operator> <name>InvalidOid</name> <operator>&amp;&amp;</operator> <name><name>parsed</name><operator>-&gt;</operator><name>dbId</name></name> <operator>!=</operator> <name><name>ctx</name><operator>-&gt;</operator><name>slot</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>database</name></name><operator>)</operator> <operator>||</operator>
		<name><name>ctx</name><operator>-&gt;</operator><name>fast_forward</name></name> <operator>||</operator> <call><name>FilterByOrigin</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>origin_id</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>parsed</name><operator>-&gt;</operator><name>nsubxacts</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ReorderBufferForget</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>reorder</name></name></expr></argument>, <argument><expr><name><name>parsed</name><operator>-&gt;</operator><name>subxacts</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>buf</name><operator>-&gt;</operator><name>origptr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></for>
		<expr_stmt><expr><call><name>ReorderBufferForget</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>reorder</name></name></expr></argument>, <argument><expr><name>xid</name></expr></argument>, <argument><expr><name><name>buf</name><operator>-&gt;</operator><name>origptr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* tell the reorderbuffer about the surviving subtransactions */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>parsed</name><operator>-&gt;</operator><name>nsubxacts</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ReorderBufferCommitChild</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>reorder</name></name></expr></argument>, <argument><expr><name>xid</name></expr></argument>, <argument><expr><name><name>parsed</name><operator>-&gt;</operator><name>subxacts</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,
								 <argument><expr><name><name>buf</name><operator>-&gt;</operator><name>origptr</name></name></expr></argument>, <argument><expr><name><name>buf</name><operator>-&gt;</operator><name>endptr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<comment type="block">/* replay actions of all transaction + subtransactions in order */</comment>
	<expr_stmt><expr><call><name>ReorderBufferCommit</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>reorder</name></name></expr></argument>, <argument><expr><name>xid</name></expr></argument>, <argument><expr><name><name>buf</name><operator>-&gt;</operator><name>origptr</name></name></expr></argument>, <argument><expr><name><name>buf</name><operator>-&gt;</operator><name>endptr</name></name></expr></argument>,
						<argument><expr><name>commit_time</name></expr></argument>, <argument><expr><name>origin_id</name></expr></argument>, <argument><expr><name>origin_lsn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Get the data from the various forms of abort records and pass it on to
 * snapbuild.c and reorderbuffer.c
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>DecodeAbort</name><parameter_list>(<parameter><decl><type><name>LogicalDecodingContext</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>, <parameter><decl><type><name>XLogRecordBuffer</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>,
			<parameter><decl><type><name>xl_xact_parsed_abort</name> <modifier>*</modifier></type><name>parsed</name></decl></parameter>, <parameter><decl><type><name>TransactionId</name></type> <name>xid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>parsed</name><operator>-&gt;</operator><name>nsubxacts</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ReorderBufferAbort</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>reorder</name></name></expr></argument>, <argument><expr><name><name>parsed</name><operator>-&gt;</operator><name>subxacts</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,
						   <argument><expr><name><name>buf</name><operator>-&gt;</operator><name>record</name><operator>-&gt;</operator><name>EndRecPtr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>ReorderBufferAbort</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>reorder</name></name></expr></argument>, <argument><expr><name>xid</name></expr></argument>, <argument><expr><name><name>buf</name><operator>-&gt;</operator><name>record</name><operator>-&gt;</operator><name>EndRecPtr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Parse XLOG_HEAP_INSERT (not MULTI_INSERT!) records into tuplebufs.
 *
 * Deletes can contain the new tuple.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>DecodeInsert</name><parameter_list>(<parameter><decl><type><name>LogicalDecodingContext</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>, <parameter><decl><type><name>XLogRecordBuffer</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Size</name></type>		<name>datalen</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>tupledata</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Size</name></type>		<name>tuplelen</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>XLogReaderState</name> <modifier>*</modifier></type><name>r</name> <init>= <expr><name><name>buf</name><operator>-&gt;</operator><name>record</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>xl_heap_insert</name> <modifier>*</modifier></type><name>xlrec</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ReorderBufferChange</name> <modifier>*</modifier></type><name>change</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RelFileNode</name></type> <name>target_node</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>xlrec</name> <operator>=</operator> <operator>(</operator><name>xl_heap_insert</name> <operator>*</operator><operator>)</operator> <call><name>XLogRecGetData</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Ignore insert records without new tuples (this does happen when
	 * raw_heap_insert marks the TOAST record as HEAP_INSERT_NO_LOGICAL).
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name><name>xlrec</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>XLH_INSERT_CONTAINS_NEW_TUPLE</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/* only interested in our database */</comment>
	<expr_stmt><expr><call><name>XLogRecGetBlockTag</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>target_node</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>target_node</name><operator>.</operator><name>dbNode</name></name> <operator>!=</operator> <name><name>ctx</name><operator>-&gt;</operator><name>slot</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>database</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/* output plugin doesn't look for this origin, no need to queue */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>FilterByOrigin</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><call><name>XLogRecGetOrigin</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>change</name> <operator>=</operator> <call><name>ReorderBufferGetChange</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>reorder</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name><name>xlrec</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>XLH_INSERT_IS_SPECULATIVE</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>change</name><operator>-&gt;</operator><name>action</name></name> <operator>=</operator> <name>REORDER_BUFFER_CHANGE_INSERT</name></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>change</name><operator>-&gt;</operator><name>action</name></name> <operator>=</operator> <name>REORDER_BUFFER_CHANGE_INTERNAL_SPEC_INSERT</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
	<expr_stmt><expr><name><name>change</name><operator>-&gt;</operator><name>origin_id</name></name> <operator>=</operator> <call><name>XLogRecGetOrigin</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>change</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>tp</name><operator>.</operator><name>relnode</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>target_node</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>RelFileNode</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>tupledata</name> <operator>=</operator> <call><name>XLogRecGetBlockData</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>datalen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>tuplelen</name> <operator>=</operator> <name>datalen</name> <operator>-</operator> <name>SizeOfHeapHeader</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>change</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>tp</name><operator>.</operator><name>newtuple</name></name> <operator>=</operator>
		<call><name>ReorderBufferGetTupleBuf</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>reorder</name></name></expr></argument>, <argument><expr><name>tuplelen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>DecodeXLogTuple</name><argument_list>(<argument><expr><name>tupledata</name></expr></argument>, <argument><expr><name>datalen</name></expr></argument>, <argument><expr><name><name>change</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>tp</name><operator>.</operator><name>newtuple</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>change</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>tp</name><operator>.</operator><name>clear_toast_afterwards</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ReorderBufferQueueChange</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>reorder</name></name></expr></argument>, <argument><expr><call><name>XLogRecGetXid</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>buf</name><operator>-&gt;</operator><name>origptr</name></name></expr></argument>, <argument><expr><name>change</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Parse XLOG_HEAP_UPDATE and XLOG_HEAP_HOT_UPDATE, which have the same layout
 * in the record, from wal into proper tuplebufs.
 *
 * Updates can possibly contain a new tuple and the old primary key.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>DecodeUpdate</name><parameter_list>(<parameter><decl><type><name>LogicalDecodingContext</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>, <parameter><decl><type><name>XLogRecordBuffer</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>XLogReaderState</name> <modifier>*</modifier></type><name>r</name> <init>= <expr><name><name>buf</name><operator>-&gt;</operator><name>record</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>xl_heap_update</name> <modifier>*</modifier></type><name>xlrec</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ReorderBufferChange</name> <modifier>*</modifier></type><name>change</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>data</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RelFileNode</name></type> <name>target_node</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>xlrec</name> <operator>=</operator> <operator>(</operator><name>xl_heap_update</name> <operator>*</operator><operator>)</operator> <call><name>XLogRecGetData</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* only interested in our database */</comment>
	<expr_stmt><expr><call><name>XLogRecGetBlockTag</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>target_node</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>target_node</name><operator>.</operator><name>dbNode</name></name> <operator>!=</operator> <name><name>ctx</name><operator>-&gt;</operator><name>slot</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>database</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/* output plugin doesn't look for this origin, no need to queue */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>FilterByOrigin</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><call><name>XLogRecGetOrigin</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>change</name> <operator>=</operator> <call><name>ReorderBufferGetChange</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>reorder</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>change</name><operator>-&gt;</operator><name>action</name></name> <operator>=</operator> <name>REORDER_BUFFER_CHANGE_UPDATE</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>change</name><operator>-&gt;</operator><name>origin_id</name></name> <operator>=</operator> <call><name>XLogRecGetOrigin</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>change</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>tp</name><operator>.</operator><name>relnode</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>target_node</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>RelFileNode</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>xlrec</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>XLH_UPDATE_CONTAINS_NEW_TUPLE</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Size</name></type>		<name>datalen</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Size</name></type>		<name>tuplelen</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>data</name> <operator>=</operator> <call><name>XLogRecGetBlockData</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>datalen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>tuplelen</name> <operator>=</operator> <name>datalen</name> <operator>-</operator> <name>SizeOfHeapHeader</name></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>change</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>tp</name><operator>.</operator><name>newtuple</name></name> <operator>=</operator>
			<call><name>ReorderBufferGetTupleBuf</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>reorder</name></name></expr></argument>, <argument><expr><name>tuplelen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>DecodeXLogTuple</name><argument_list>(<argument><expr><name>data</name></expr></argument>, <argument><expr><name>datalen</name></expr></argument>, <argument><expr><name><name>change</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>tp</name><operator>.</operator><name>newtuple</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>xlrec</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>XLH_UPDATE_CONTAINS_OLD</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Size</name></type>		<name>datalen</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Size</name></type>		<name>tuplelen</name></decl>;</decl_stmt>

		<comment type="block">/* caution, remaining data in record is not aligned */</comment>
		<expr_stmt><expr><name>data</name> <operator>=</operator> <call><name>XLogRecGetData</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call> <operator>+</operator> <name>SizeOfHeapUpdate</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>datalen</name> <operator>=</operator> <call><name>XLogRecGetDataLen</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call> <operator>-</operator> <name>SizeOfHeapUpdate</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>tuplelen</name> <operator>=</operator> <name>datalen</name> <operator>-</operator> <name>SizeOfHeapHeader</name></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>change</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>tp</name><operator>.</operator><name>oldtuple</name></name> <operator>=</operator>
			<call><name>ReorderBufferGetTupleBuf</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>reorder</name></name></expr></argument>, <argument><expr><name>tuplelen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>DecodeXLogTuple</name><argument_list>(<argument><expr><name>data</name></expr></argument>, <argument><expr><name>datalen</name></expr></argument>, <argument><expr><name><name>change</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>tp</name><operator>.</operator><name>oldtuple</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name><name>change</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>tp</name><operator>.</operator><name>clear_toast_afterwards</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ReorderBufferQueueChange</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>reorder</name></name></expr></argument>, <argument><expr><call><name>XLogRecGetXid</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>buf</name><operator>-&gt;</operator><name>origptr</name></name></expr></argument>, <argument><expr><name>change</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Parse XLOG_HEAP_DELETE from wal into proper tuplebufs.
 *
 * Deletes can possibly contain the old primary key.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>DecodeDelete</name><parameter_list>(<parameter><decl><type><name>LogicalDecodingContext</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>, <parameter><decl><type><name>XLogRecordBuffer</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>XLogReaderState</name> <modifier>*</modifier></type><name>r</name> <init>= <expr><name><name>buf</name><operator>-&gt;</operator><name>record</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>xl_heap_delete</name> <modifier>*</modifier></type><name>xlrec</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ReorderBufferChange</name> <modifier>*</modifier></type><name>change</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RelFileNode</name></type> <name>target_node</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>xlrec</name> <operator>=</operator> <operator>(</operator><name>xl_heap_delete</name> <operator>*</operator><operator>)</operator> <call><name>XLogRecGetData</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* only interested in our database */</comment>
	<expr_stmt><expr><call><name>XLogRecGetBlockTag</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>target_node</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>target_node</name><operator>.</operator><name>dbNode</name></name> <operator>!=</operator> <name><name>ctx</name><operator>-&gt;</operator><name>slot</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>database</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Super deletions are irrelevant for logical decoding, it's driven by the
	 * confirmation records.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>xlrec</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>XLH_DELETE_IS_SUPER</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/* output plugin doesn't look for this origin, no need to queue */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>FilterByOrigin</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><call><name>XLogRecGetOrigin</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>change</name> <operator>=</operator> <call><name>ReorderBufferGetChange</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>reorder</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>change</name><operator>-&gt;</operator><name>action</name></name> <operator>=</operator> <name>REORDER_BUFFER_CHANGE_DELETE</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>change</name><operator>-&gt;</operator><name>origin_id</name></name> <operator>=</operator> <call><name>XLogRecGetOrigin</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>change</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>tp</name><operator>.</operator><name>relnode</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>target_node</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>RelFileNode</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* old primary key stored */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>xlrec</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>XLH_DELETE_CONTAINS_OLD</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Size</name></type>		<name>datalen</name> <init>= <expr><call><name>XLogRecGetDataLen</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call> <operator>-</operator> <name>SizeOfHeapDelete</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Size</name></type>		<name>tuplelen</name> <init>= <expr><name>datalen</name> <operator>-</operator> <name>SizeOfHeapHeader</name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>XLogRecGetDataLen</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <operator>(</operator><name>SizeOfHeapDelete</name> <operator>+</operator> <name>SizeOfHeapHeader</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>change</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>tp</name><operator>.</operator><name>oldtuple</name></name> <operator>=</operator>
			<call><name>ReorderBufferGetTupleBuf</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>reorder</name></name></expr></argument>, <argument><expr><name>tuplelen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>DecodeXLogTuple</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>xlrec</name> <operator>+</operator> <name>SizeOfHeapDelete</name></expr></argument>,
						<argument><expr><name>datalen</name></expr></argument>, <argument><expr><name><name>change</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>tp</name><operator>.</operator><name>oldtuple</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name><name>change</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>tp</name><operator>.</operator><name>clear_toast_afterwards</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ReorderBufferQueueChange</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>reorder</name></name></expr></argument>, <argument><expr><call><name>XLogRecGetXid</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>buf</name><operator>-&gt;</operator><name>origptr</name></name></expr></argument>, <argument><expr><name>change</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Parse XLOG_HEAP_TRUNCATE from wal
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>DecodeTruncate</name><parameter_list>(<parameter><decl><type><name>LogicalDecodingContext</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>, <parameter><decl><type><name>XLogRecordBuffer</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>XLogReaderState</name> <modifier>*</modifier></type><name>r</name> <init>= <expr><name><name>buf</name><operator>-&gt;</operator><name>record</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>xl_heap_truncate</name> <modifier>*</modifier></type><name>xlrec</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ReorderBufferChange</name> <modifier>*</modifier></type><name>change</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>xlrec</name> <operator>=</operator> <operator>(</operator><name>xl_heap_truncate</name> <operator>*</operator><operator>)</operator> <call><name>XLogRecGetData</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* only interested in our database */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>xlrec</name><operator>-&gt;</operator><name>dbId</name></name> <operator>!=</operator> <name><name>ctx</name><operator>-&gt;</operator><name>slot</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>database</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/* output plugin doesn't look for this origin, no need to queue */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>FilterByOrigin</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><call><name>XLogRecGetOrigin</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>change</name> <operator>=</operator> <call><name>ReorderBufferGetChange</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>reorder</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>change</name><operator>-&gt;</operator><name>action</name></name> <operator>=</operator> <name>REORDER_BUFFER_CHANGE_TRUNCATE</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>change</name><operator>-&gt;</operator><name>origin_id</name></name> <operator>=</operator> <call><name>XLogRecGetOrigin</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>xlrec</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>XLH_TRUNCATE_CASCADE</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>change</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>truncate</name><operator>.</operator><name>cascade</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>xlrec</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>XLH_TRUNCATE_RESTART_SEQS</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>change</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>truncate</name><operator>.</operator><name>restart_seqs</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name><name>change</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>truncate</name><operator>.</operator><name>nrelids</name></name> <operator>=</operator> <name><name>xlrec</name><operator>-&gt;</operator><name>nrelids</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>change</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>truncate</name><operator>.</operator><name>relids</name></name> <operator>=</operator> <call><name>ReorderBufferGetRelids</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>reorder</name></name></expr></argument>,
														  <argument><expr><name><name>xlrec</name><operator>-&gt;</operator><name>nrelids</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>change</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>truncate</name><operator>.</operator><name>relids</name></name></expr></argument>, <argument><expr><name><name>xlrec</name><operator>-&gt;</operator><name>relids</name></name></expr></argument>,
		   <argument><expr><name><name>xlrec</name><operator>-&gt;</operator><name>nrelids</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ReorderBufferQueueChange</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>reorder</name></name></expr></argument>, <argument><expr><call><name>XLogRecGetXid</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr></argument>,
							 <argument><expr><name><name>buf</name><operator>-&gt;</operator><name>origptr</name></name></expr></argument>, <argument><expr><name>change</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Decode XLOG_HEAP2_MULTI_INSERT_insert record into multiple tuplebufs.
 *
 * Currently MULTI_INSERT will always contain the full tuples.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>DecodeMultiInsert</name><parameter_list>(<parameter><decl><type><name>LogicalDecodingContext</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>, <parameter><decl><type><name>XLogRecordBuffer</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>XLogReaderState</name> <modifier>*</modifier></type><name>r</name> <init>= <expr><name><name>buf</name><operator>-&gt;</operator><name>record</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>xl_heap_multi_insert</name> <modifier>*</modifier></type><name>xlrec</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>data</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>tupledata</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Size</name></type>		<name>tuplelen</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RelFileNode</name></type> <name>rnode</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>xlrec</name> <operator>=</operator> <operator>(</operator><name>xl_heap_multi_insert</name> <operator>*</operator><operator>)</operator> <call><name>XLogRecGetData</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* only interested in our database */</comment>
	<expr_stmt><expr><call><name>XLogRecGetBlockTag</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>rnode</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>rnode</name><operator>.</operator><name>dbNode</name></name> <operator>!=</operator> <name><name>ctx</name><operator>-&gt;</operator><name>slot</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>database</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/* output plugin doesn't look for this origin, no need to queue */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>FilterByOrigin</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><call><name>XLogRecGetOrigin</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>tupledata</name> <operator>=</operator> <call><name>XLogRecGetBlockData</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>tuplelen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>data</name> <operator>=</operator> <name>tupledata</name></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>xlrec</name><operator>-&gt;</operator><name>ntuples</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ReorderBufferChange</name> <modifier>*</modifier></type><name>change</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>xl_multi_insert_tuple</name> <modifier>*</modifier></type><name>xlhdr</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>datalen</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ReorderBufferTupleBuf</name> <modifier>*</modifier></type><name>tuple</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>change</name> <operator>=</operator> <call><name>ReorderBufferGetChange</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>reorder</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>change</name><operator>-&gt;</operator><name>action</name></name> <operator>=</operator> <name>REORDER_BUFFER_CHANGE_INSERT</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>change</name><operator>-&gt;</operator><name>origin_id</name></name> <operator>=</operator> <call><name>XLogRecGetOrigin</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>change</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>tp</name><operator>.</operator><name>relnode</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rnode</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>RelFileNode</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * CONTAINS_NEW_TUPLE will always be set currently as multi_insert
		 * isn't used for catalogs, but better be future proof.
		 *
		 * We decode the tuple in pretty much the same way as DecodeXLogTuple,
		 * but since the layout is slightly different, we can't use it here.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>xlrec</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>XLH_INSERT_CONTAINS_NEW_TUPLE</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>HeapTupleHeader</name></type> <name>header</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>xlhdr</name> <operator>=</operator> <operator>(</operator><name>xl_multi_insert_tuple</name> <operator>*</operator><operator>)</operator> <call><name>SHORTALIGN</name><argument_list>(<argument><expr><name>data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>data</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>xlhdr</name><operator>)</operator> <operator>+</operator> <name>SizeOfMultiInsertTuple</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>datalen</name> <operator>=</operator> <name><name>xlhdr</name><operator>-&gt;</operator><name>datalen</name></name></expr>;</expr_stmt>

			<expr_stmt><expr><name><name>change</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>tp</name><operator>.</operator><name>newtuple</name></name> <operator>=</operator>
				<call><name>ReorderBufferGetTupleBuf</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>reorder</name></name></expr></argument>, <argument><expr><name>datalen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name>tuple</name> <operator>=</operator> <name><name>change</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>tp</name><operator>.</operator><name>newtuple</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name>header</name> <operator>=</operator> <name><name>tuple</name><operator>-&gt;</operator><name>tuple</name><operator>.</operator><name>t_data</name></name></expr>;</expr_stmt>

			<comment type="block">/* not a disk based tuple */</comment>
			<expr_stmt><expr><call><name>ItemPointerSetInvalid</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>tuple</name><operator>-&gt;</operator><name>tuple</name><operator>.</operator><name>t_self</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * We can only figure this out after reassembling the
			 * transactions.
			 */</comment>
			<expr_stmt><expr><name><name>tuple</name><operator>-&gt;</operator><name>tuple</name><operator>.</operator><name>t_tableOid</name></name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>

			<expr_stmt><expr><name><name>tuple</name><operator>-&gt;</operator><name>tuple</name><operator>.</operator><name>t_len</name></name> <operator>=</operator> <name>datalen</name> <operator>+</operator> <name>SizeofHeapTupleHeader</name></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>header</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SizeofHeapTupleHeader</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name><name>tuple</name><operator>-&gt;</operator><name>tuple</name><operator>.</operator><name>t_data</name></name> <operator>+</operator> <name>SizeofHeapTupleHeader</name></expr></argument>,
				   <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>data</name></expr></argument>,
				   <argument><expr><name>datalen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>data</name> <operator>+=</operator> <name>datalen</name></expr>;</expr_stmt>

			<expr_stmt><expr><name><name>header</name><operator>-&gt;</operator><name>t_infomask</name></name> <operator>=</operator> <name><name>xlhdr</name><operator>-&gt;</operator><name>t_infomask</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>header</name><operator>-&gt;</operator><name>t_infomask2</name></name> <operator>=</operator> <name><name>xlhdr</name><operator>-&gt;</operator><name>t_infomask2</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>header</name><operator>-&gt;</operator><name>t_hoff</name></name> <operator>=</operator> <name><name>xlhdr</name><operator>-&gt;</operator><name>t_hoff</name></name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * Reset toast reassembly state only after the last row in the last
		 * xl_multi_insert_tuple record emitted by one heap_multi_insert()
		 * call.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>xlrec</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>XLH_INSERT_LAST_IN_MULTI</name> <operator>&amp;&amp;</operator>
			<operator>(</operator><name>i</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>==</operator> <name><name>xlrec</name><operator>-&gt;</operator><name>ntuples</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>change</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>tp</name><operator>.</operator><name>clear_toast_afterwards</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>change</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>tp</name><operator>.</operator><name>clear_toast_afterwards</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<expr_stmt><expr><call><name>ReorderBufferQueueChange</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>reorder</name></name></expr></argument>, <argument><expr><call><name>XLogRecGetXid</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr></argument>,
								 <argument><expr><name><name>buf</name><operator>-&gt;</operator><name>origptr</name></name></expr></argument>, <argument><expr><name>change</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>data</name> <operator>==</operator> <name>tupledata</name> <operator>+</operator> <name>tuplelen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Parse XLOG_HEAP_CONFIRM from wal into a confirmation change.
 *
 * This is pretty trivial, all the state essentially already setup by the
 * speculative insertion.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>DecodeSpecConfirm</name><parameter_list>(<parameter><decl><type><name>LogicalDecodingContext</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>, <parameter><decl><type><name>XLogRecordBuffer</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>XLogReaderState</name> <modifier>*</modifier></type><name>r</name> <init>= <expr><name><name>buf</name><operator>-&gt;</operator><name>record</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ReorderBufferChange</name> <modifier>*</modifier></type><name>change</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RelFileNode</name></type> <name>target_node</name></decl>;</decl_stmt>

	<comment type="block">/* only interested in our database */</comment>
	<expr_stmt><expr><call><name>XLogRecGetBlockTag</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>target_node</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>target_node</name><operator>.</operator><name>dbNode</name></name> <operator>!=</operator> <name><name>ctx</name><operator>-&gt;</operator><name>slot</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>database</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/* output plugin doesn't look for this origin, no need to queue */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>FilterByOrigin</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><call><name>XLogRecGetOrigin</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>change</name> <operator>=</operator> <call><name>ReorderBufferGetChange</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>reorder</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>change</name><operator>-&gt;</operator><name>action</name></name> <operator>=</operator> <name>REORDER_BUFFER_CHANGE_INTERNAL_SPEC_CONFIRM</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>change</name><operator>-&gt;</operator><name>origin_id</name></name> <operator>=</operator> <call><name>XLogRecGetOrigin</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>change</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>tp</name><operator>.</operator><name>relnode</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>target_node</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>RelFileNode</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>change</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>tp</name><operator>.</operator><name>clear_toast_afterwards</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ReorderBufferQueueChange</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>reorder</name></name></expr></argument>, <argument><expr><call><name>XLogRecGetXid</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>buf</name><operator>-&gt;</operator><name>origptr</name></name></expr></argument>, <argument><expr><name>change</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * Read a HeapTuple as WAL logged by heap_insert, heap_update and heap_delete
 * (but not by heap_multi_insert) into a tuplebuf.
 *
 * The size 'len' and the pointer 'data' in the record need to be
 * computed outside as they are record specific.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>DecodeXLogTuple</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>data</name></decl></parameter>, <parameter><decl><type><name>Size</name></type> <name>len</name></decl></parameter>, <parameter><decl><type><name>ReorderBufferTupleBuf</name> <modifier>*</modifier></type><name>tuple</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>xl_heap_header</name></type> <name>xlhdr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>datalen</name> <init>= <expr><name>len</name> <operator>-</operator> <name>SizeOfHeapHeader</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTupleHeader</name></type> <name>header</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>datalen</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>tuple</name><operator>-&gt;</operator><name>tuple</name><operator>.</operator><name>t_len</name></name> <operator>=</operator> <name>datalen</name> <operator>+</operator> <name>SizeofHeapTupleHeader</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>header</name> <operator>=</operator> <name><name>tuple</name><operator>-&gt;</operator><name>tuple</name><operator>.</operator><name>t_data</name></name></expr>;</expr_stmt>

	<comment type="block">/* not a disk based tuple */</comment>
	<expr_stmt><expr><call><name>ItemPointerSetInvalid</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>tuple</name><operator>-&gt;</operator><name>tuple</name><operator>.</operator><name>t_self</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* we can only figure this out after reassembling the transactions */</comment>
	<expr_stmt><expr><name><name>tuple</name><operator>-&gt;</operator><name>tuple</name><operator>.</operator><name>t_tableOid</name></name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>

	<comment type="block">/* data is not stored aligned, copy to aligned storage */</comment>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>xlhdr</name></expr></argument>,
		   <argument><expr><name>data</name></expr></argument>,
		   <argument><expr><name>SizeOfHeapHeader</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>header</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SizeofHeapTupleHeader</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name><name>tuple</name><operator>-&gt;</operator><name>tuple</name><operator>.</operator><name>t_data</name></name><operator>)</operator> <operator>+</operator> <name>SizeofHeapTupleHeader</name></expr></argument>,
		   <argument><expr><name>data</name> <operator>+</operator> <name>SizeOfHeapHeader</name></expr></argument>,
		   <argument><expr><name>datalen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>header</name><operator>-&gt;</operator><name>t_infomask</name></name> <operator>=</operator> <name><name>xlhdr</name><operator>.</operator><name>t_infomask</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>header</name><operator>-&gt;</operator><name>t_infomask2</name></name> <operator>=</operator> <name><name>xlhdr</name><operator>.</operator><name>t_infomask2</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>header</name><operator>-&gt;</operator><name>t_hoff</name></name> <operator>=</operator> <name><name>xlhdr</name><operator>.</operator><name>t_hoff</name></name></expr>;</expr_stmt>
</block_content>}</block></function>
</unit>
