<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/PolarDB-for-PostgreSQL/src/backend/replication/basebackup.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * basebackup.c
 *	  code for taking a base backup and streaming it to a standby
 *
 * Portions Copyright (c) 2010-2018, PostgreSQL Global Development Group
 *
 * IDENTIFICATION
 *	  src/backend/replication/basebackup.c
 *
 *-------------------------------------------------------------------------
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/stat.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;unistd.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;time.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/xlog_internal.h"</cpp:file></cpp:include>	<comment type="block">/* for pg_start/stop_backup */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_type.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"common/file_perm.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lib/stringinfo.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"libpq/libpq.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"libpq/pqformat.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/pg_list.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pgtar.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pgstat.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"port.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postmaster/syslogger.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"replication/basebackup.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"replication/walsender.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"replication/walsender_private.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/bufpage.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/checksum.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/dsm_impl.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/fd.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/ipc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/reinit.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/builtins.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/ps_status.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/relcache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/timestamp.h"</cpp:file></cpp:include>

<comment type="block">/* POLAR */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postmaster/syslogger.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/polar_fd.h"</cpp:file></cpp:include>

<typedef>typedef <type><struct>struct
<block>{
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>label</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>progress</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>fastcheckpoint</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>nowait</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>includewal</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32</name></type>		<name>maxrate</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>sendtblspcmapfile</name></decl>;</decl_stmt>
}</block></struct></type> <name>basebackup_options</name>;</typedef>


<function_decl><type><specifier>static</specifier> <name>int64</name></type> <name>sendDir</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>path</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>basepathlen</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>sizeonly</name></decl></parameter>,
		<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>tablespaces</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>sendtblspclinks</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>is_pfs</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>senddmafiles</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>sendFile</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>readfilename</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>tarfilename</name></decl></parameter>,
		 <parameter><decl><type><name><name>struct</name> <name>stat</name></name> <modifier>*</modifier></type><name>statbuf</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>missing_ok</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type>
<name>sendPolarFile</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>readfilename</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>tarfilename</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>stat</name></name> <modifier>*</modifier></type><name>statbuf</name></decl></parameter>,
		 <parameter><decl><type><name>bool</name></type> <name>missing_ok</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>sendFileWithContent</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>filename</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>content</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int64</name></type> <name>_tarWriteHeader</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>filename</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>linktarget</name></decl></parameter>,
				<parameter><decl><type><name><name>struct</name> <name>stat</name></name> <modifier>*</modifier></type><name>statbuf</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>sizeonly</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int64</name></type> <name>_tarWriteDir</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>pathbuf</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>basepathlen</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>stat</name></name> <modifier>*</modifier></type><name>statbuf</name></decl></parameter>,
			 <parameter><decl><type><name>bool</name></type> <name>sizeonly</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>send_int8_string</name><parameter_list>(<parameter><decl><type><name>StringInfoData</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><name>int64</name></type> <name>intval</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>SendBackupHeader</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>tablespaces</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>perform_base_backup</name><parameter_list>(<parameter><decl><type><name>basebackup_options</name> <modifier>*</modifier></type><name>opt</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>parse_basebackup_options</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>options</name></decl></parameter>, <parameter><decl><type><name>basebackup_options</name> <modifier>*</modifier></type><name>opt</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>SendXlogRecPtrResult</name><parameter_list>(<parameter><decl><type><name>XLogRecPtr</name></type> <name>ptr</name></decl></parameter>, <parameter><decl><type><name>TimeLineID</name></type> <name>tli</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type>	<name>compareWalFileNames</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>throttle</name><parameter_list>(<parameter><decl><type><name>size_t</name></type> <name>increment</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>is_checksummed_file</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>fullpath</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>filename</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>is_pfs</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/* Was the backup currently in-progress initiated in recovery mode? */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type> <name>backup_started_in_recovery</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

<comment type="block">/* Relative path of temporary statistics directory */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>statrelpath</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<comment type="block">/*
 * Size of each block sent into the tar stream for larger files.
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TAR_SEND_SIZE</name></cpp:macro> <cpp:value>32768</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>POLAR_TAR_SEND_SIZE</name></cpp:macro> <cpp:value>(TAR_SEND_SIZE * 64)</cpp:value></cpp:define>

<comment type="block">/*
 * How frequently to throttle, as a fraction of the specified rate-second.
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>THROTTLING_FREQUENCY</name></cpp:macro>	<cpp:value>8</cpp:value></cpp:define>

<comment type="block">/*
 * Checks whether we encountered any error in fread().  fread() doesn't give
 * any clue what has happened, so we check with ferror().  Also, neither
 * fread() nor ferror() set errno, so we just throw a generic error.
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CHECK_FREAD_ERROR</name><parameter_list>(<parameter><type><name>fp</name></type></parameter>, <parameter><type><name>filename</name></type></parameter>)</parameter_list></cpp:macro> \
<cpp:value>do { \
	if (ferror(fp)) \
		ereport(ERROR, \
				(errmsg("could not read from file \"%s\"", filename))); \
} while (0)</cpp:value></cpp:define>

<comment type="block">/* The actual number of bytes, transfer of which may cause sleep. */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>uint64</name></type> <name>throttling_sample</name></decl>;</decl_stmt>

<comment type="block">/* Amount of data already transferred but not yet throttled.  */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>int64</name></type> <name>throttling_counter</name></decl>;</decl_stmt>

<comment type="block">/* The minimum time required to transfer throttling_sample bytes. */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>TimeOffset</name></type> <name>elapsed_min_unit</name></decl>;</decl_stmt>

<comment type="block">/* The last check of the transfer rate. */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>TimestampTz</name></type> <name>throttled_last</name></decl>;</decl_stmt>

<comment type="block">/* The starting XLOG position of the base backup. */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>XLogRecPtr</name></type> <name>startptr</name></decl>;</decl_stmt>

<comment type="block">/* Total number of checksum failures during base backup. */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>int64</name></type> <name>total_checksum_failures</name></decl>;</decl_stmt>

<comment type="block">/* Do not verify checksums. */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type> <name>noverify_checksums</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

<comment type="block">/*
 * Definition of one element part of an exclusion list, used for paths part
 * of checksum validation or base backups.  "name" is the name of the file
 * or path to check for exclusion.  If "match_prefix" is true, any items
 * matching the name as prefix are excluded.
 */</comment>
<struct>struct <name>exclude_list_item</name>
<block>{
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>match_prefix</name></decl>;</decl_stmt>
}</block>;</struct>

<comment type="block">/*
 * The contents of these directories are removed or recreated during server
 * start so they are not included in backups.  The directories themselves are
 * kept and included as empty to preserve access permissions.
 *
 * Note: this list should be kept in sync with the filter lists in pg_rewind's
 * filemap.c.
 */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name><name>excludeDirContents</name><index>[]</index></name> <init>=
<expr><block>{
	<comment type="block">/*
	 * Skip temporary statistics files. PG_STAT_TMP_DIR must be skipped even
	 * when stats_temp_directory is set because PGSS_TEXT_FILE is always
	 * created there.
	 */</comment>
	<expr><name>PG_STAT_TMP_DIR</name></expr>,

	<comment type="block">/*
	 * It is generally not useful to backup the contents of this directory
	 * even if the intention is to restore to another master. See backup.sgml
	 * for a more detailed description.
	 */</comment>
	<expr><literal type="string">"pg_replslot"</literal></expr>,

	<comment type="block">/* Contents removed on startup, see dsm_cleanup_for_mmap(). */</comment>
	<expr><name>PG_DYNSHMEM_DIR</name></expr>,

	<comment type="block">/* Contents removed on startup, see AsyncShmemInit(). */</comment>
	<expr><literal type="string">"pg_notify"</literal></expr>,

	<comment type="block">/*
	 * Old contents are loaded for possible debugging but are not required for
	 * normal operation, see OldSerXidInit().
	 */</comment>
	<expr><literal type="string">"pg_serial"</literal></expr>,

	<comment type="block">/* Contents removed on startup, see DeleteAllExportedSnapshotFiles(). */</comment>
	<expr><literal type="string">"pg_snapshots"</literal></expr>,

	<comment type="block">/* Contents zeroed on startup, see StartupSUBTRANS(). */</comment>
	<expr><literal type="string">"pg_subtrans"</literal></expr>,

	<comment type="block">/* POLAR: excluede pg_logindex, new backup will rebuild it's own logindex */</comment>
	<expr><literal type="string">"pg_logindex"</literal></expr>,

	<comment type="block">/* end of list */</comment>
	<expr><name>NULL</name></expr>
}</block></expr></init></decl>;</decl_stmt>

<comment type="block">/*
 * List of files excluded from backups.
 */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name><name>struct</name> <name>exclude_list_item</name></name></type> <name><name>excludeFiles</name><index>[]</index></name> <init>=
<expr><block>{
	<comment type="block">/* Skip auto conf temporary file. */</comment>
	<expr><block>{<expr><name>PG_AUTOCONF_FILENAME</name> <literal type="string">".tmp"</literal></expr>, <expr><name>false</name></expr>}</block></expr>,

	<comment type="block">/* Skip current log file temporary file */</comment>
	<expr><block>{<expr><name>LOG_METAINFO_DATAFILE_TMP</name></expr>, <expr><name>false</name></expr>}</block></expr>,

	<comment type="block">/*
	 * Skip relation cache because it is rebuilt on startup.  This includes
	 * temporary files.
	 */</comment>
	<expr><block>{<expr><name>RELCACHE_INIT_FILENAME</name></expr>, <expr><name>true</name></expr>}</block></expr>,

	<comment type="block">/*
	 * If there's a backup_label or tablespace_map file, it belongs to a
	 * backup started by the user with pg_start_backup().  It is *not* correct
	 * for this backup.  Our backup_label/tablespace_map is injected into the
	 * tar separately.
	 */</comment>
	<expr><block>{<expr><name>BACKUP_LABEL_FILE</name></expr>, <expr><name>false</name></expr>}</block></expr>,
	<expr><block>{<expr><name>TABLESPACE_MAP</name></expr>, <expr><name>false</name></expr>}</block></expr>,

	<expr><block>{<expr><literal type="string">"postmaster.pid"</literal></expr>, <expr><name>false</name></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"postmaster.opts"</literal></expr>, <expr><name>false</name></expr>}</block></expr>,

	<comment type="block">/* POLAR */</comment>
	<expr><block>{<expr><literal type="string">"polar_node_static.conf"</literal></expr>, <expr><name>false</name></expr>}</block></expr>,
	<comment type="block">/* POLAR end */</comment>

	<comment type="block">/* end of list */</comment>
	<expr><block>{<expr><name>NULL</name></expr>, <expr><name>false</name></expr>}</block></expr>
}</block></expr></init></decl>;</decl_stmt>

<comment type="block">/*
 * List of files excluded from checksum validation.
 *
 * Note: this list should be kept in sync with what pg_verify_checksums.c
 * includes.
 */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name><name>struct</name> <name>exclude_list_item</name></name></type> <name><name>noChecksumFiles</name><index>[]</index></name> <init>= <expr><block>{
	<expr><block>{<expr><literal type="string">"pg_control"</literal></expr>, <expr><name>false</name></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"pg_filenode.map"</literal></expr>, <expr><name>false</name></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"pg_internal.init"</literal></expr>, <expr><name>true</name></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"PG_VERSION"</literal></expr>, <expr><name>false</name></expr>}</block></expr>,
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>EXEC_BACKEND</name></cpp:ifdef>
	<expr><block>{<expr><literal type="string">"config_exec_params"</literal></expr>, <expr><name>true</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<comment type="block">/* POLAR: Do not checksum for sqlprotect's files */</comment>
	<expr><block>{<expr><literal type="string">"polar_sqlprotect.stat"</literal></expr>, <expr><name>false</name></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"polar_sqlprotect.query"</literal></expr>, <expr><name>false</name></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"polar_sqlprotect.qtxt"</literal></expr>, <expr><name>false</name></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"polar_sql_protect_roles"</literal></expr>, <expr><name>false</name></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"polar_sql_protect_rels"</literal></expr>, <expr><name>false</name></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"polar_sql_protect_stats"</literal></expr>, <expr><name>false</name></expr>}</block></expr>,
	<comment type="block">/* POLAR end */</comment>

	<expr><block>{<expr><name>NULL</name></expr>, <expr><name>false</name></expr>}</block></expr>
}</block></expr></init></decl>;</decl_stmt>

<comment type="block">/*
 * Actually do a base backup for the specified tablespaces.
 *
 * This is split out mainly to avoid complaints about "variable might be
 * clobbered by longjmp" from stupider versions of gcc.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>perform_base_backup</name><parameter_list>(<parameter><decl><type><name>basebackup_options</name> <modifier>*</modifier></type><name>opt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TimeLineID</name></type>	<name>starttli</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>XLogRecPtr</name></type>	<name>endptr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TimeLineID</name></type>	<name>endtli</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>StringInfo</name></type>	<name>labelfile</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>StringInfo</name></type>	<name>tblspc_map_file</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>datadirpathlen</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>tablespaces</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>polar_full_path</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name></decl>;</decl_stmt>

	<expr_stmt><expr><name>datadirpathlen</name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>DataDir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>backup_started_in_recovery</name> <operator>=</operator> <call><name>RecoveryInProgress</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>labelfile</name> <operator>=</operator> <call><name>makeStringInfo</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>tblspc_map_file</name> <operator>=</operator> <call><name>makeStringInfo</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>total_checksum_failures</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<expr_stmt><expr><name>startptr</name> <operator>=</operator> <call><name>do_pg_start_backup</name><argument_list>(<argument><expr><name><name>opt</name><operator>-&gt;</operator><name>label</name></name></expr></argument>, <argument><expr><name><name>opt</name><operator>-&gt;</operator><name>fastcheckpoint</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>starttli</name></expr></argument>,
								  <argument><expr><name>labelfile</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tablespaces</name></expr></argument>,
								  <argument><expr><name>tblspc_map_file</name></expr></argument>,
								  <argument><expr><name><name>opt</name><operator>-&gt;</operator><name>progress</name></name></expr></argument>, <argument><expr><name><name>opt</name><operator>-&gt;</operator><name>sendtblspcmapfile</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Once do_pg_start_backup has been called, ensure that any failure causes
	 * us to abort the backup so we don't "leak" a backup counter. For this
	 * reason, *all* functionality between do_pg_start_backup() and the end of
	 * do_pg_stop_backup() should be inside the error cleanup block!
	 */</comment>

	<expr_stmt><expr><call><name>PG_ENSURE_ERROR_CLEANUP</name><argument_list>(<argument><expr><name>do_pg_abort_backup</name></expr></argument>, <argument><expr><call><name>BoolGetDatum</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>tablespaceinfo</name> <modifier>*</modifier></type><name>tibase</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>tablespaceinfo</name> <modifier>*</modifier></type><name>tidata</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>SendXlogRecPtrResult</name><argument_list>(<argument><expr><name>startptr</name></expr></argument>, <argument><expr><name>starttli</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Calculate the relative path of temporary statistics directory in
		 * order to skip the files which are located in that directory later.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>is_absolute_path</name><argument_list>(<argument><expr><name>pgstat_stat_directory</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
			<call><name>strncmp</name><argument_list>(<argument><expr><name>pgstat_stat_directory</name></expr></argument>, <argument><expr><name>DataDir</name></expr></argument>, <argument><expr><name>datadirpathlen</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>statrelpath</name> <operator>=</operator> <call><name>psprintf</name><argument_list>(<argument><expr><literal type="string">"./%s"</literal></expr></argument>, <argument><expr><name>pgstat_stat_directory</name> <operator>+</operator> <name>datadirpathlen</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><call><name>strncmp</name><argument_list>(<argument><expr><name>pgstat_stat_directory</name></expr></argument>, <argument><expr><literal type="string">"./"</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>statrelpath</name> <operator>=</operator> <call><name>psprintf</name><argument_list>(<argument><expr><literal type="string">"./%s"</literal></expr></argument>, <argument><expr><name>pgstat_stat_directory</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>statrelpath</name> <operator>=</operator> <name>pgstat_stat_directory</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<comment type="block">/* Add a node for the base directory at the end */</comment>
		<expr_stmt><expr><name>tibase</name> <operator>=</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>tablespaceinfo</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>tibase</name><operator>-&gt;</operator><name>size</name></name> <operator>=</operator> <ternary><condition><expr><name><name>opt</name><operator>-&gt;</operator><name>progress</name></name></expr> ?</condition><then> <expr><call><name>sendDir</name><argument_list>(<argument><expr><literal type="string">"."</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>tablespaces</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><operator>-</operator><literal type="number">1</literal></expr></else></ternary></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>tibase</name><operator>-&gt;</operator><name>polar_shared</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>tablespaces</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>tablespaces</name></expr></argument>, <argument><expr><name>tibase</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* if in polar, we need to send data dir */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>POLAR_FILE_IN_SHARED_STORAGE</name><argument_list>()</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>tidata</name> <operator>=</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>tablespaceinfo</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>tidata</name><operator>-&gt;</operator><name>size</name></name> <operator>=</operator> <ternary><condition><expr><name><name>opt</name><operator>-&gt;</operator><name>progress</name></name></expr> ?</condition><then> <expr><call><name>sendDir</name><argument_list>(<argument><expr><name>polar_datadir</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>polar_datadir</name></expr></argument>)</argument_list></call></expr></argument>, 
					<argument><expr><name>true</name></expr></argument>, <argument><expr><name>tablespaces</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><operator>-</operator><literal type="number">1</literal></expr></else></ternary></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>tidata</name><operator>-&gt;</operator><name>polar_shared</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>tablespaces</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>tablespaces</name></expr></argument>, <argument><expr><name>tidata</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* Send tablespace header */</comment>
		<expr_stmt><expr><call><name>SendBackupHeader</name><argument_list>(<argument><expr><name>tablespaces</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Setup and activate network throttling, if client requested it */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>opt</name><operator>-&gt;</operator><name>maxrate</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>throttling_sample</name> <operator>=</operator>
				<operator>(</operator><name>int64</name><operator>)</operator> <name><name>opt</name><operator>-&gt;</operator><name>maxrate</name></name> <operator>*</operator> <operator>(</operator><name>int64</name><operator>)</operator> <literal type="number">1024</literal> <operator>/</operator> <name>THROTTLING_FREQUENCY</name></expr>;</expr_stmt>

			<comment type="block">/*
			 * The minimum amount of time for throttling_sample bytes to be
			 * transferred.
			 */</comment>
			<expr_stmt><expr><name>elapsed_min_unit</name> <operator>=</operator> <name>USECS_PER_SEC</name> <operator>/</operator> <name>THROTTLING_FREQUENCY</name></expr>;</expr_stmt>

			<comment type="block">/* Enable throttling. */</comment>
			<expr_stmt><expr><name>throttling_counter</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

			<comment type="block">/* The 'real data' starts now (header was ignored). */</comment>
			<expr_stmt><expr><name>throttled_last</name> <operator>=</operator> <call><name>GetCurrentTimestamp</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/* Disable throttling. */</comment>
			<expr_stmt><expr><name>throttling_counter</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<comment type="block">/* Send off our tablespaces one by one */</comment>
		<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>tablespaces</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>tablespaceinfo</name> <modifier>*</modifier></type><name>ti</name> <init>= <expr><operator>(</operator><name>tablespaceinfo</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>StringInfoData</name></type> <name>buf</name></decl>;</decl_stmt>

			<comment type="block">/* Send CopyOutResponse message */</comment>
			<expr_stmt><expr><call><name>pq_beginmessage</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="char">'H'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>pq_sendbyte</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>	<comment type="block">/* overall format */</comment>
			<expr_stmt><expr><call><name>pq_sendint16</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>	<comment type="block">/* natts */</comment>
			<expr_stmt><expr><call><name>pq_endmessage</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>ti</name><operator>-&gt;</operator><name>path</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name><name>struct</name> <name>stat</name></name></type> <name>statbuf</name></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><name><name>ti</name><operator>-&gt;</operator><name>polar_shared</name></name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>sendDir</name><argument_list>(<argument><expr><name>polar_datadir</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>polar_datadir</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>tablespaces</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, 
							<argument><expr><name><name>ti</name><operator>-&gt;</operator><name>polar_shared</name></name></expr></argument>, <argument><expr><operator>!</operator><call><name>POLAR_ENABLE_DMA</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<comment type="block">/* ... and pg_control after everything else. */</comment>
					<expr_stmt><expr><call><name>polar_make_file_path_level2</name><argument_list>(<argument><expr><name>polar_full_path</name></expr></argument>, <argument><expr><name>XLOG_CONTROL_FILE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<if_stmt><if>if <condition>(<expr><call><name>polar_stat</name><argument_list>(<argument><expr><name>polar_full_path</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>statbuf</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
								<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
								 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not stat control file \"%s\": %m"</literal></expr></argument>,
										<argument><expr><name>XLOG_CONTROL_FILE</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
					<expr_stmt><expr><call><name>sendPolarFile</name><argument_list>(<argument><expr><name>polar_full_path</name></expr></argument>, <argument><expr><name>XLOG_CONTROL_FILE</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>statbuf</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<comment type="block">/* POLAR: backup polar_dma after pg_control */</comment>
					<if_stmt><if>if <condition>(<expr><call><name>POLAR_ENABLE_DMA</name><argument_list>()</argument_list></call></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><call><name>polar_make_file_path_level2</name><argument_list>(<argument><expr><name>polar_full_path</name></expr></argument>, <argument><expr><literal type="string">"polar_dma/consensus_meta"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<if_stmt><if>if <condition>(<expr><call><name>polar_stat</name><argument_list>(<argument><expr><name>polar_full_path</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>statbuf</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
							<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
									<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
									 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not stat consensus meta file \"%s\": %m"</literal></expr></argument>,
										 <argument><expr><literal type="string">"polar_dma/consensus_meta"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
						<expr_stmt><expr><call><name>sendPolarFile</name><argument_list>(<argument><expr><name>polar_full_path</name></expr></argument>, <argument><expr><literal type="string">"polar_dma/consensus_meta"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>statbuf</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

						<expr_stmt><expr><call><name>polar_make_file_path_level2</name><argument_list>(<argument><expr><name>polar_full_path</name></expr></argument>, <argument><expr><literal type="string">"polar_dma/consensus_log"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><call><name>sendDir</name><argument_list>(<argument><expr><name>polar_full_path</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>polar_datadir</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>NIL</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, 
								<argument><expr><name><name>ti</name><operator>-&gt;</operator><name>polar_shared</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

						<expr_stmt><expr><call><name>polar_make_file_path_level2</name><argument_list>(<argument><expr><name>polar_full_path</name></expr></argument>, <argument><expr><literal type="string">"polar_dma/consensus_cc_log"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><call><name>sendDir</name><argument_list>(<argument><expr><name>polar_full_path</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>polar_datadir</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>NIL</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, 
								<argument><expr><name><name>ti</name><operator>-&gt;</operator><name>polar_shared</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block></if></if_stmt>
					<comment type="block">/* POLAR end */</comment>
				</block_content>}</block></if>
				<else>else
				<block>{<block_content>
					
					<if_stmt><if>if <condition>(<expr><call><name>POLAR_FILE_IN_SHARED_STORAGE</name><argument_list>()</argument_list></call></expr>)</condition>
					<block>{<block_content>
						<comment type="block">/* In the main tar, include the backup_label first... */</comment>
						<expr_stmt><expr><call><name>sendFileWithContent</name><argument_list>(<argument><expr><name>BACKUP_LABEL_FILE</name></expr></argument>, <argument><expr><name><name>labelfile</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

						<if_stmt><if>if <condition>(<expr><name>tblspc_map_file</name> <operator>&amp;&amp;</operator> <name><name>opt</name><operator>-&gt;</operator><name>sendtblspcmapfile</name></name></expr>)</condition>
						<block>{<block_content>
							<expr_stmt><expr><call><name>sendFileWithContent</name><argument_list>(<argument><expr><name>TABLESPACE_MAP</name></expr></argument>, <argument><expr><name><name>tblspc_map_file</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							<expr_stmt><expr><call><name>sendDir</name><argument_list>(<argument><expr><literal type="string">"."</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>tablespaces</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name><name>ti</name><operator>-&gt;</operator><name>polar_shared</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						</block_content>}</block></if>
						<else>else<block type="pseudo"><block_content>
							<expr_stmt><expr><call><name>sendDir</name><argument_list>(<argument><expr><literal type="string">"."</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>tablespaces</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name><name>ti</name><operator>-&gt;</operator><name>polar_shared</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
					</block_content>}</block></if>
					<else>else
					<block>{<block_content>
						<comment type="block">/* In the main tar, include the backup_label first... */</comment>
						<expr_stmt><expr><call><name>sendFileWithContent</name><argument_list>(<argument><expr><name>BACKUP_LABEL_FILE</name></expr></argument>, <argument><expr><name><name>labelfile</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

						<comment type="block">/*
						* Send tablespace_map file if required and then the bulk of
						* the files.
						*/</comment>
						<if_stmt><if>if <condition>(<expr><name>tblspc_map_file</name> <operator>&amp;&amp;</operator> <name><name>opt</name><operator>-&gt;</operator><name>sendtblspcmapfile</name></name></expr>)</condition>
						<block>{<block_content>
							<expr_stmt><expr><call><name>sendFileWithContent</name><argument_list>(<argument><expr><name>TABLESPACE_MAP</name></expr></argument>, <argument><expr><name><name>tblspc_map_file</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							<expr_stmt><expr><call><name>sendDir</name><argument_list>(<argument><expr><literal type="string">"."</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>tablespaces</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name><name>ti</name><operator>-&gt;</operator><name>polar_shared</name></name></expr></argument>, <argument><expr><operator>!</operator><call><name>POLAR_ENABLE_DMA</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						</block_content>}</block></if>
						<else>else<block type="pseudo"><block_content>
							<expr_stmt><expr><call><name>sendDir</name><argument_list>(<argument><expr><literal type="string">"."</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>tablespaces</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name><name>ti</name><operator>-&gt;</operator><name>polar_shared</name></name></expr></argument>, <argument><expr><operator>!</operator><call><name>POLAR_ENABLE_DMA</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

						<comment type="block">/* ... and pg_control after everything else. */</comment>
						<if_stmt><if>if <condition>(<expr><call><name>lstat</name><argument_list>(<argument><expr><name>XLOG_CONTROL_FILE</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>statbuf</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
							<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
									<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
									<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not stat control file \"%s\": %m"</literal></expr></argument>,
											<argument><expr><name>XLOG_CONTROL_FILE</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
						<expr_stmt><expr><call><name>sendFile</name><argument_list>(<argument><expr><name>XLOG_CONTROL_FILE</name></expr></argument>, <argument><expr><name>XLOG_CONTROL_FILE</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>statbuf</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

						<comment type="block">/* POLAR: backup polar_dma after pg_control */</comment>
						<if_stmt><if>if <condition>(<expr><call><name>POLAR_ENABLE_DMA</name><argument_list>()</argument_list></call></expr>)</condition>
						<block>{<block_content>
							<if_stmt><if>if <condition>(<expr><call><name>lstat</name><argument_list>(<argument><expr><literal type="string">"polar_dma/consensus_meta"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>statbuf</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
								<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
										<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
										 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not stat control file \"%s\": %m"</literal></expr></argument>,
											 <argument><expr><literal type="string">"polar_dma/consensus_meta"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
							<expr_stmt><expr><call><name>sendFile</name><argument_list>(<argument><expr><literal type="string">"polar_dma/consensus_meta"</literal></expr></argument>, <argument><expr><literal type="string">"polar_dma/consensus_meta"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>statbuf</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							<expr_stmt><expr><call><name>sendDir</name><argument_list>(<argument><expr><literal type="string">"./polar_dma/consensus_log"</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>NIL</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name><name>ti</name><operator>-&gt;</operator><name>polar_shared</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							<expr_stmt><expr><call><name>sendDir</name><argument_list>(<argument><expr><literal type="string">"./polar_dma/consensus_cc_log"</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>NIL</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name><name>ti</name><operator>-&gt;</operator><name>polar_shared</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						</block_content>}</block></if></if_stmt>
						<comment type="block">/* POLAR end */</comment>
					</block_content>}</block></else></if_stmt>
				</block_content>}</block></else></if_stmt>
			</block_content>}</block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>sendTablespace</name><argument_list>(<argument><expr><name><name>ti</name><operator>-&gt;</operator><name>path</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

			<comment type="block">/*
			 * If we're including WAL, and this is the main data directory we
			 * don't terminate the tar stream here. Instead, we will append
			 * the xlog files below and terminate it then. This is safe since
			 * the main data directory is always sent *last*.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>opt</name><operator>-&gt;</operator><name>includewal</name></name> <operator>&amp;&amp;</operator> <name><name>ti</name><operator>-&gt;</operator><name>path</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><call><name>POLAR_FILE_IN_SHARED_STORAGE</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>ti</name><operator>-&gt;</operator><name>polar_shared</name></name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>pq_putemptymessage</name><argument_list>(<argument><expr><literal type="char">'c'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>	<comment type="block">/* CopyDone */</comment>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>lnext</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
			</block_content>}</block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>pq_putemptymessage</name><argument_list>(<argument><expr><literal type="char">'c'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>	<comment type="block">/* CopyDone */</comment>
		</block_content>}</block>

		<expr_stmt><expr><name>endptr</name> <operator>=</operator> <call><name>do_pg_stop_backup</name><argument_list>(<argument><expr><name><name>labelfile</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><operator>!</operator><name><name>opt</name><operator>-&gt;</operator><name>nowait</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>endtli</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
	<expr_stmt><expr><call><name>PG_END_ENSURE_ERROR_CLEANUP</name><argument_list>(<argument><expr><name>do_pg_abort_backup</name></expr></argument>, <argument><expr><call><name>BoolGetDatum</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>


	<if_stmt><if>if <condition>(<expr><name><name>opt</name><operator>-&gt;</operator><name>includewal</name></name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * We've left the last tar file "open", so we can now append the
		 * required WAL files to it.
		 */</comment>
		<decl_stmt><decl><type><name>char</name></type>		<name><name>pathbuf</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name></type>		<name><name>polar_full_path</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>XLogSegNo</name></type>	<name>segno</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>XLogSegNo</name></type>	<name>startsegno</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>XLogSegNo</name></type>	<name>endsegno</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name><name>struct</name> <name>stat</name></name></type> <name>statbuf</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>historyFileList</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>walFileList</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name>	  <modifier>*</modifier><modifier>*</modifier></type><name>walFiles</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>nWalFiles</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name></type>		<name><name>firstoff</name><index>[<expr><name>MAXFNAMELEN</name></expr>]</index></name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name></type>		<name><name>lastoff</name><index>[<expr><name>MAXFNAMELEN</name></expr>]</index></name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>DIR</name>		   <modifier>*</modifier></type><name>dir</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name><name>struct</name> <name>dirent</name></name> <modifier>*</modifier></type><name>de</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>TimeLineID</name></type>	<name>tli</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * I'd rather not worry about timelines here, so scan pg_wal and
		 * include all WAL files in the range between 'startptr' and 'endptr',
		 * regardless of the timeline the file is stamped with. If there are
		 * some spurious WAL files belonging to timelines that don't belong in
		 * this server's history, they will be included too. Normally there
		 * shouldn't be such files, but if there are, there's little harm in
		 * including them.
		 */</comment>
		<expr_stmt><expr><call><name>XLByteToSeg</name><argument_list>(<argument><expr><name>startptr</name></expr></argument>, <argument><expr><name>startsegno</name></expr></argument>, <argument><expr><name>wal_segment_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>XLogFileName</name><argument_list>(<argument><expr><name>firstoff</name></expr></argument>, <argument><expr><name>ThisTimeLineID</name></expr></argument>, <argument><expr><name>startsegno</name></expr></argument>, <argument><expr><name>wal_segment_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>XLByteToPrevSeg</name><argument_list>(<argument><expr><name>endptr</name></expr></argument>, <argument><expr><name>endsegno</name></expr></argument>, <argument><expr><name>wal_segment_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>XLogFileName</name><argument_list>(<argument><expr><name>lastoff</name></expr></argument>, <argument><expr><name>ThisTimeLineID</name></expr></argument>, <argument><expr><name>endsegno</name></expr></argument>, <argument><expr><name>wal_segment_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>polar_make_file_path_level2</name><argument_list>(<argument><expr><name>polar_full_path</name></expr></argument>, <argument><expr><literal type="string">"pg_wal"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>dir</name> <operator>=</operator> <call><name>AllocateDir</name><argument_list>(<argument><expr><name>polar_full_path</name></expr></argument>, <argument><expr><call><name>POLAR_FILE_IN_SHARED_STORAGE</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<while>while <condition>(<expr><operator>(</operator><name>de</name> <operator>=</operator> <call><name>ReadDir</name><argument_list>(<argument><expr><name>dir</name></expr></argument>, <argument><expr><name>polar_full_path</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Does it look like a WAL segment, and is it in the range? */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>IsXLogFileName</name><argument_list>(<argument><expr><name><name>de</name><operator>-&gt;</operator><name>d_name</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
				<call><name>strcmp</name><argument_list>(<argument><expr><name><name>de</name><operator>-&gt;</operator><name>d_name</name></name> <operator>+</operator> <literal type="number">8</literal></expr></argument>, <argument><expr><name>firstoff</name> <operator>+</operator> <literal type="number">8</literal></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
				<call><name>strcmp</name><argument_list>(<argument><expr><name><name>de</name><operator>-&gt;</operator><name>d_name</name></name> <operator>+</operator> <literal type="number">8</literal></expr></argument>, <argument><expr><name>lastoff</name> <operator>+</operator> <literal type="number">8</literal></expr></argument>)</argument_list></call> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>walFileList</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>walFileList</name></expr></argument>, <argument><expr><call><name>pstrdup</name><argument_list>(<argument><expr><name><name>de</name><operator>-&gt;</operator><name>d_name</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if>
			<comment type="block">/* Does it look like a timeline history file? */</comment>
			<if type="elseif">else if <condition>(<expr><call><name>IsTLHistoryFileName</name><argument_list>(<argument><expr><name><name>de</name><operator>-&gt;</operator><name>d_name</name></name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>historyFileList</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>historyFileList</name></expr></argument>, <argument><expr><call><name>pstrdup</name><argument_list>(<argument><expr><name><name>de</name><operator>-&gt;</operator><name>d_name</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></while>
		<expr_stmt><expr><call><name>FreeDir</name><argument_list>(<argument><expr><name>dir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Before we go any further, check that none of the WAL segments we
		 * need were removed.
		 */</comment>
		<expr_stmt><expr><call><name>CheckXLogRemoved</name><argument_list>(<argument><expr><name>startsegno</name></expr></argument>, <argument><expr><name>ThisTimeLineID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Put the WAL filenames into an array, and sort. We send the files in
		 * order from oldest to newest, to reduce the chance that a file is
		 * recycled before we get a chance to send it over.
		 */</comment>
		<expr_stmt><expr><name>nWalFiles</name> <operator>=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name>walFileList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>walFiles</name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>nWalFiles</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>char</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>walFileList</argument>)</argument_list></macro>
		<block>{<block_content>
			<expr_stmt><expr><name><name>walFiles</name><index>[<expr><name>i</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>
		<expr_stmt><expr><call><name>qsort</name><argument_list>(<argument><expr><name>walFiles</name></expr></argument>, <argument><expr><name>nWalFiles</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>char</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>compareWalFileNames</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * There must be at least one xlog file in the pg_wal directory, since
		 * we are doing backup-including-xlog.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>nWalFiles</name> <operator>&lt;</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not find any WAL files"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * Sanity check: the first and last segment should cover startptr and
		 * endptr, with no gaps in between.
		 */</comment>
		<expr_stmt><expr><call><name>XLogFromFileName</name><argument_list>(<argument><expr><name><name>walFiles</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tli</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>segno</name></expr></argument>, <argument><expr><name>wal_segment_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>segno</name> <operator>!=</operator> <name>startsegno</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>char</name></type>		<name><name>startfname</name><index>[<expr><name>MAXFNAMELEN</name></expr>]</index></name></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>XLogFileName</name><argument_list>(<argument><expr><name>startfname</name></expr></argument>, <argument><expr><name>ThisTimeLineID</name></expr></argument>, <argument><expr><name>startsegno</name></expr></argument>,
						 <argument><expr><name>wal_segment_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not find WAL file \"%s\""</literal></expr></argument>, <argument><expr><name>startfname</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nWalFiles</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>XLogSegNo</name></type>	<name>currsegno</name> <init>= <expr><name>segno</name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>XLogSegNo</name></type>	<name>nextsegno</name> <init>= <expr><name>segno</name> <operator>+</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>XLogFromFileName</name><argument_list>(<argument><expr><name><name>walFiles</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tli</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>segno</name></expr></argument>, <argument><expr><name>wal_segment_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>nextsegno</name> <operator>==</operator> <name>segno</name> <operator>||</operator> <name>currsegno</name> <operator>==</operator> <name>segno</name><operator>)</operator></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>char</name></type>		<name><name>nextfname</name><index>[<expr><name>MAXFNAMELEN</name></expr>]</index></name></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>XLogFileName</name><argument_list>(<argument><expr><name>nextfname</name></expr></argument>, <argument><expr><name>ThisTimeLineID</name></expr></argument>, <argument><expr><name>nextsegno</name></expr></argument>,
							 <argument><expr><name>wal_segment_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not find WAL file \"%s\""</literal></expr></argument>, <argument><expr><name>nextfname</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></for>
		<if_stmt><if>if <condition>(<expr><name>segno</name> <operator>!=</operator> <name>endsegno</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>char</name></type>		<name><name>endfname</name><index>[<expr><name>MAXFNAMELEN</name></expr>]</index></name></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>XLogFileName</name><argument_list>(<argument><expr><name>endfname</name></expr></argument>, <argument><expr><name>ThisTimeLineID</name></expr></argument>, <argument><expr><name>endsegno</name></expr></argument>, <argument><expr><name>wal_segment_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not find WAL file \"%s\""</literal></expr></argument>, <argument><expr><name>endfname</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* Ok, we have everything we need. Send the WAL files. */</comment>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nWalFiles</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>int</name></type>			<name>fd</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>char</name></type>		<name><name>buf</name><index>[<expr><name>TAR_SEND_SIZE</name></expr>]</index></name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>size_t</name></type>		<name>cnt</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>pgoff_t</name></type>		<name>len</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>pathbuf</name></expr></argument>, <argument><expr><name>MAXPGPATH</name></expr></argument>, <argument><expr><name>XLOGDIR</name> <literal type="string">"/%s"</literal></expr></argument>, <argument><expr><name><name>walFiles</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>polar_make_file_path_level3</name><argument_list>(<argument><expr><name>polar_full_path</name></expr></argument>, <argument><expr><literal type="string">"pg_wal"</literal></expr></argument>, <argument><expr><name><name>walFiles</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>XLogFromFileName</name><argument_list>(<argument><expr><name><name>walFiles</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tli</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>segno</name></expr></argument>, <argument><expr><name>wal_segment_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><operator>(</operator><name>fd</name> <operator>=</operator> <call><name>polar_open</name><argument_list>(<argument><expr><name>polar_full_path</name></expr></argument>, <argument><expr><name>O_RDONLY</name> <operator>|</operator> <name>PG_BINARY</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>int</name></type>			<name>save_errno</name> <init>= <expr><name>errno</name></expr></init></decl>;</decl_stmt>

				<comment type="block">/*
				 * Most likely reason for this is that the file was already
				 * removed by a checkpoint, so check for that to get a better
				 * error message.
				 */</comment>
				<expr_stmt><expr><call><name>CheckXLogRemoved</name><argument_list>(<argument><expr><name>segno</name></expr></argument>, <argument><expr><name>tli</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><name>errno</name> <operator>=</operator> <name>save_errno</name></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not open file \"%s\": %m"</literal></expr></argument>, <argument><expr><name>polar_full_path</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>polar_stat</name><argument_list>(<argument><expr><name>polar_full_path</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>statbuf</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not stat file \"%s\": %m"</literal></expr></argument>,
								<argument><expr><name>polar_full_path</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>statbuf</name><operator>.</operator><name>st_size</name></name> <operator>!=</operator> <name>wal_segment_size</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>CheckXLogRemoved</name><argument_list>(<argument><expr><name>segno</name></expr></argument>, <argument><expr><name>tli</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"unexpected WAL file size \"%s\""</literal></expr></argument>, <argument><expr><name><name>walFiles</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/* send the WAL file itself */</comment>
			<expr_stmt><expr><call><name>_tarWriteHeader</name><argument_list>(<argument><expr><name>pathbuf</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>statbuf</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<while>while <condition>(<expr><operator>(</operator><name>cnt</name> <operator>=</operator> <call><name>polar_read</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>,
							<argument><expr><call><name>Min</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>wal_segment_size</name> <operator>-</operator> <name>len</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>CheckXLogRemoved</name><argument_list>(<argument><expr><name>segno</name></expr></argument>, <argument><expr><name>tli</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<comment type="block">/* Send the chunk as a CopyData message */</comment>
				<if_stmt><if>if <condition>(<expr><call><name>pq_putmessage</name><argument_list>(<argument><expr><literal type="char">'d'</literal></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>cnt</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"base backup could not send data, aborting backup"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

				<expr_stmt><expr><name>len</name> <operator>+=</operator> <name>cnt</name></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>throttle</name><argument_list>(<argument><expr><name>cnt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<if_stmt><if>if <condition>(<expr><name>len</name> <operator>==</operator> <name>wal_segment_size</name></expr>)</condition><block type="pseudo"><block_content>
					<break>break;</break></block_content></block></if></if_stmt>
			</block_content>}</block></while>

			<if_stmt><if>if <condition>(<expr><name>len</name> <operator>!=</operator> <name>wal_segment_size</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>CheckXLogRemoved</name><argument_list>(<argument><expr><name>segno</name></expr></argument>, <argument><expr><name>tli</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"unexpected WAL file size \"%s\""</literal></expr></argument>, <argument><expr><name><name>walFiles</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/* wal_segment_size is a multiple of 512, so no need for padding */</comment>

			<expr_stmt><expr><call><name>polar_close</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * Mark file as archived, otherwise files can get archived again
			 * after promotion of a new node. This is in line with
			 * walreceiver.c always doing an XLogArchiveForceDone() after a
			 * complete segment.
			 */</comment>
			<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>pathbuf</name></expr></argument>, <argument><expr><name>MAXPGPATH</name></expr></argument>, <argument><expr><name>XLOGDIR</name> <literal type="string">"/archive_status/%s%s"</literal></expr></argument>, <argument><expr><name><name>walFiles</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">".done"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>sendFileWithContent</name><argument_list>(<argument><expr><name>pathbuf</name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></for>

		<comment type="block">/*
		 * Send timeline history files too. Only the latest timeline history
		 * file is required for recovery, and even that only if there happens
		 * to be a timeline switch in the first WAL segment that contains the
		 * checkpoint record, or if we're taking a base backup from a standby
		 * server and the target timeline changes while the backup is taken.
		 * But they are small and highly useful for debugging purposes, so
		 * better include them all, always.
		 */</comment>
		<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>historyFileList</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>fname</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>pathbuf</name></expr></argument>, <argument><expr><name>MAXPGPATH</name></expr></argument>, <argument><expr><name>XLOGDIR</name> <literal type="string">"/%s"</literal></expr></argument>, <argument><expr><name>fname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>polar_make_file_path_level3</name><argument_list>(<argument><expr><name>polar_full_path</name></expr></argument>, <argument><expr><literal type="string">"pg_wal"</literal></expr></argument>, <argument><expr><name>fname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>polar_lstat</name><argument_list>(<argument><expr><name>polar_full_path</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>statbuf</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not stat file \"%s\": %m"</literal></expr></argument>, <argument><expr><name>pathbuf</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>POLAR_FILE_IN_SHARED_STORAGE</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>sendPolarFile</name><argument_list>(<argument><expr><name>polar_full_path</name></expr></argument>, <argument><expr><name>pathbuf</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>statbuf</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>sendFile</name><argument_list>(<argument><expr><name>polar_full_path</name></expr></argument>, <argument><expr><name>pathbuf</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>statbuf</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

			<comment type="block">/* unconditionally mark file as archived */</comment>
			<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>pathbuf</name></expr></argument>, <argument><expr><name>MAXPGPATH</name></expr></argument>, <argument><expr><name>XLOGDIR</name> <literal type="string">"/archive_status/%s%s"</literal></expr></argument>, <argument><expr><name>fname</name></expr></argument>, <argument><expr><literal type="string">".done"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>sendFileWithContent</name><argument_list>(<argument><expr><name>pathbuf</name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>

		<comment type="block">/* Send CopyDone message for the last tar file */</comment>
		<expr_stmt><expr><call><name>pq_putemptymessage</name><argument_list>(<argument><expr><literal type="char">'c'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>SendXlogRecPtrResult</name><argument_list>(<argument><expr><name>endptr</name></expr></argument>, <argument><expr><name>endtli</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>total_checksum_failures</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>total_checksum_failures</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>char</name></type>		<name><name>buf</name><index>[<expr><literal type="number">64</literal></expr>]</index></name></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>INT64_FORMAT</name></expr></argument>, <argument><expr><name>total_checksum_failures</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"%s total checksum verification failures"</literal></expr></argument>, <argument><expr><name>buf</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATA_CORRUPTED</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"checksum verification failure during base backup"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

</block_content>}</block></function>

<comment type="block">/*
 * qsort comparison function, to compare log/seg portion of WAL segment
 * filenames, ignoring the timeline portion.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>compareWalFileNames</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>fna</name> <init>= <expr><operator>*</operator><operator>(</operator><operator>(</operator><name>char</name> <operator>*</operator><operator>*</operator><operator>)</operator> <name>a</name><operator>)</operator></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>fnb</name> <init>= <expr><operator>*</operator><operator>(</operator><operator>(</operator><name>char</name> <operator>*</operator><operator>*</operator><operator>)</operator> <name>b</name><operator>)</operator></expr></init></decl>;</decl_stmt>

	<return>return <expr><call><name>strcmp</name><argument_list>(<argument><expr><name>fna</name> <operator>+</operator> <literal type="number">8</literal></expr></argument>, <argument><expr><name>fnb</name> <operator>+</operator> <literal type="number">8</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Parse the base backup options passed down by the parser
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>parse_basebackup_options</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>options</name></decl></parameter>, <parameter><decl><type><name>basebackup_options</name> <modifier>*</modifier></type><name>opt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lopt</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>o_label</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>o_progress</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>o_fast</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>o_nowait</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>o_wal</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>o_maxrate</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>o_tablespace_map</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>o_noverify_checksums</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><name>opt</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>opt</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<macro><name>foreach</name><argument_list>(<argument>lopt</argument>, <argument>options</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>DefElem</name>    <modifier>*</modifier></type><name>defel</name> <init>= <expr><operator>(</operator><name>DefElem</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lopt</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>defel</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>, <argument><expr><literal type="string">"label"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>o_label</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"duplicate option \"%s\""</literal></expr></argument>, <argument><expr><name><name>defel</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><name><name>opt</name><operator>-&gt;</operator><name>label</name></name> <operator>=</operator> <call><name>strVal</name><argument_list>(<argument><expr><name><name>defel</name><operator>-&gt;</operator><name>arg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>o_label</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>defel</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>, <argument><expr><literal type="string">"progress"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>o_progress</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"duplicate option \"%s\""</literal></expr></argument>, <argument><expr><name><name>defel</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><name><name>opt</name><operator>-&gt;</operator><name>progress</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>o_progress</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>defel</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>, <argument><expr><literal type="string">"fast"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>o_fast</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"duplicate option \"%s\""</literal></expr></argument>, <argument><expr><name><name>defel</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><name><name>opt</name><operator>-&gt;</operator><name>fastcheckpoint</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>o_fast</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>defel</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>, <argument><expr><literal type="string">"nowait"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>o_nowait</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"duplicate option \"%s\""</literal></expr></argument>, <argument><expr><name><name>defel</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><name><name>opt</name><operator>-&gt;</operator><name>nowait</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>o_nowait</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>defel</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>, <argument><expr><literal type="string">"wal"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>o_wal</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"duplicate option \"%s\""</literal></expr></argument>, <argument><expr><name><name>defel</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><name><name>opt</name><operator>-&gt;</operator><name>includewal</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>o_wal</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>defel</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>, <argument><expr><literal type="string">"max_rate"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>long</name></type>		<name>maxrate</name></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name>o_maxrate</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"duplicate option \"%s\""</literal></expr></argument>, <argument><expr><name><name>defel</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<expr_stmt><expr><name>maxrate</name> <operator>=</operator> <call><name>intVal</name><argument_list>(<argument><expr><name><name>defel</name><operator>-&gt;</operator><name>arg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>maxrate</name> <argument_list type="generic">&lt; <argument><expr><name>MAX_RATE_LOWER</name> <operator>||</operator> <name>maxrate</name></expr></argument> &gt;</argument_list></name> <name>MAX_RATE_UPPER</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_NUMERIC_VALUE_OUT_OF_RANGE</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"%d is outside the valid range for parameter \"%s\" (%d .. %d)"</literal></expr></argument>,
								<argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name>maxrate</name></expr></argument>, <argument><expr><literal type="string">"MAX_RATE"</literal></expr></argument>, <argument><expr><name>MAX_RATE_LOWER</name></expr></argument>, <argument><expr><name>MAX_RATE_UPPER</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<expr_stmt><expr><name><name>opt</name><operator>-&gt;</operator><name>maxrate</name></name> <operator>=</operator> <operator>(</operator><name>uint32</name><operator>)</operator> <name>maxrate</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>o_maxrate</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>defel</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>, <argument><expr><literal type="string">"tablespace_map"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>o_tablespace_map</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"duplicate option \"%s\""</literal></expr></argument>, <argument><expr><name><name>defel</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><name><name>opt</name><operator>-&gt;</operator><name>sendtblspcmapfile</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>o_tablespace_map</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>defel</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>, <argument><expr><literal type="string">"noverify_checksums"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>o_noverify_checksums</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"duplicate option \"%s\""</literal></expr></argument>, <argument><expr><name><name>defel</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><name>noverify_checksums</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>o_noverify_checksums</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"option \"%s\" not recognized"</literal></expr></argument>,
				 <argument><expr><name><name>defel</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block>
	<if_stmt><if>if <condition>(<expr><name><name>opt</name><operator>-&gt;</operator><name>label</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>opt</name><operator>-&gt;</operator><name>label</name></name> <operator>=</operator> <literal type="string">"base backup"</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * SendBaseBackup() - send a complete base backup.
 *
 * The function will put the system into backup mode like pg_start_backup()
 * does, so that the backup is consistent even though we read directly from
 * the filesystem, bypassing the buffer cache.
 */</comment>
<function><type><name>void</name></type>
<name>SendBaseBackup</name><parameter_list>(<parameter><decl><type><name>BaseBackupCmd</name> <modifier>*</modifier></type><name>cmd</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>basebackup_options</name></type> <name>opt</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>parse_basebackup_options</name><argument_list>(<argument><expr><name><name>cmd</name><operator>-&gt;</operator><name>options</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>opt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WalSndSetState</name><argument_list>(<argument><expr><name>WALSNDSTATE_BACKUP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>update_process_title</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name></type>		<name><name>activitymsg</name><index>[<expr><literal type="number">50</literal></expr>]</index></name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>activitymsg</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>activitymsg</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"sending backup \"%s\""</literal></expr></argument>,
				 <argument><expr><name><name>opt</name><operator>.</operator><name>label</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>set_ps_display</name><argument_list>(<argument><expr><name>activitymsg</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>perform_base_backup</name><argument_list>(<argument><expr><operator>&amp;</operator><name>opt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>send_int8_string</name><parameter_list>(<parameter><decl><type><name>StringInfoData</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><name>int64</name></type> <name>intval</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>is</name><index>[<expr><literal type="number">32</literal></expr>]</index></name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>is</name></expr></argument>, <argument><expr><name>INT64_FORMAT</name></expr></argument>, <argument><expr><name>intval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pq_sendint32</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>is</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pq_sendbytes</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>is</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>is</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>SendBackupHeader</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>tablespaces</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>StringInfoData</name></type> <name>buf</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

	<comment type="block">/* Construct and send the directory information */</comment>
	<expr_stmt><expr><call><name>pq_beginmessage</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="char">'T'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* RowDescription */</comment>
	<expr_stmt><expr><call><name>pq_sendint16</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>		<comment type="block">/* 4 fields */</comment>

	<comment type="block">/* First field - spcoid */</comment>
	<expr_stmt><expr><call><name>pq_sendstring</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"spcoid"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pq_sendint32</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>		<comment type="block">/* table oid */</comment>
	<expr_stmt><expr><call><name>pq_sendint16</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>		<comment type="block">/* attnum */</comment>
	<expr_stmt><expr><call><name>pq_sendint32</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name>OIDOID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* type oid */</comment>
	<expr_stmt><expr><call><name>pq_sendint16</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>		<comment type="block">/* typlen */</comment>
	<expr_stmt><expr><call><name>pq_sendint32</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>		<comment type="block">/* typmod */</comment>
	<expr_stmt><expr><call><name>pq_sendint16</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>		<comment type="block">/* format code */</comment>

	<comment type="block">/* Second field - spcpath */</comment>
	<expr_stmt><expr><call><name>pq_sendstring</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"spclocation"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pq_sendint32</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pq_sendint16</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pq_sendint32</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name>TEXTOID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pq_sendint16</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pq_sendint32</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pq_sendint16</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Third field - size */</comment>
	<expr_stmt><expr><call><name>pq_sendstring</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"size"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pq_sendint32</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pq_sendint16</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pq_sendint32</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name>INT8OID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pq_sendint16</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pq_sendint32</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pq_sendint16</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Third field - shared_storage */</comment>
	<expr_stmt><expr><call><name>pq_sendstring</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"shared_storage"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pq_sendint32</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pq_sendint16</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pq_sendint32</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name>INT2OID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pq_sendint16</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pq_sendint32</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pq_sendint16</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pq_endmessage</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>tablespaces</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>tablespaceinfo</name> <modifier>*</modifier></type><name>ti</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/* Send one datarow message */</comment>
		<expr_stmt><expr><call><name>pq_beginmessage</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="char">'D'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pq_sendint16</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>	<comment type="block">/* number of columns */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>ti</name><operator>-&gt;</operator><name>path</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>pq_sendint32</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* Length = -1 ==&gt; NULL */</comment>
			<expr_stmt><expr><call><name>pq_sendint32</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<decl_stmt><decl><type><name>Size</name></type>		<name>len</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name><name>ti</name><operator>-&gt;</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>pq_sendint32</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>pq_sendbytes</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name><name>ti</name><operator>-&gt;</operator><name>oid</name></name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name><name>ti</name><operator>-&gt;</operator><name>path</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>pq_sendint32</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>pq_sendbytes</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name><name>ti</name><operator>-&gt;</operator><name>path</name></name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>ti</name><operator>-&gt;</operator><name>size</name></name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>send_int8_string</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name><name>ti</name><operator>-&gt;</operator><name>size</name></name> <operator>/</operator> <literal type="number">1024</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>pq_sendint32</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt> <comment type="block">/* NULL */</comment>

		<if_stmt><if>if <condition>(<expr><name><name>ti</name><operator>-&gt;</operator><name>polar_shared</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>pq_sendint32</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>pq_sendbytes</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"1"</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><call><name>pq_sendint32</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* Length = -1 ==&gt; NULL */</comment>
		</block_content>}</block></else></if_stmt>
		
		<expr_stmt><expr><call><name>pq_endmessage</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<comment type="block">/* Send a CommandComplete message */</comment>
	<expr_stmt><expr><call><name>pq_puttextmessage</name><argument_list>(<argument><expr><literal type="char">'C'</literal></expr></argument>, <argument><expr><literal type="string">"SELECT"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Send a single resultset containing just a single
 * XLogRecPtr record (in text format)
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>SendXlogRecPtrResult</name><parameter_list>(<parameter><decl><type><name>XLogRecPtr</name></type> <name>ptr</name></decl></parameter>, <parameter><decl><type><name>TimeLineID</name></type> <name>tli</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>StringInfoData</name></type> <name>buf</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>str</name><index>[<expr><name>MAXFNAMELEN</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Size</name></type>		<name>len</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>pq_beginmessage</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="char">'T'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* RowDescription */</comment>
	<expr_stmt><expr><call><name>pq_sendint16</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>		<comment type="block">/* 2 fields */</comment>

	<comment type="block">/* Field headers */</comment>
	<expr_stmt><expr><call><name>pq_sendstring</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"recptr"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pq_sendint32</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>		<comment type="block">/* table oid */</comment>
	<expr_stmt><expr><call><name>pq_sendint16</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>		<comment type="block">/* attnum */</comment>
	<expr_stmt><expr><call><name>pq_sendint32</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name>TEXTOID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>	<comment type="block">/* type oid */</comment>
	<expr_stmt><expr><call><name>pq_sendint16</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pq_sendint32</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pq_sendint16</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>pq_sendstring</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"tli"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pq_sendint32</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>		<comment type="block">/* table oid */</comment>
	<expr_stmt><expr><call><name>pq_sendint16</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>		<comment type="block">/* attnum */</comment>

	<comment type="block">/*
	 * int8 may seem like a surprising data type for this, but in theory int4
	 * would not be wide enough for this, as TimeLineID is unsigned.
	 */</comment>
	<expr_stmt><expr><call><name>pq_sendint32</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name>INT8OID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>	<comment type="block">/* type oid */</comment>
	<expr_stmt><expr><call><name>pq_sendint16</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pq_sendint32</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pq_sendint16</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pq_endmessage</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Data row */</comment>
	<expr_stmt><expr><call><name>pq_beginmessage</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="char">'D'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pq_sendint16</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>		<comment type="block">/* number of columns */</comment>

	<expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>snprintf</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></sizeof></expr></argument>,
				   <argument><expr><literal type="string">"%X/%X"</literal></expr></argument>, <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <operator>(</operator><name>ptr</name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr></argument>, <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <name>ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pq_sendint32</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pq_sendbytes</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name>str</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>snprintf</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"%u"</literal></expr></argument>, <argument><expr><name>tli</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pq_sendint32</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pq_sendbytes</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name>str</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>pq_endmessage</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Send a CommandComplete message */</comment>
	<expr_stmt><expr><call><name>pq_puttextmessage</name><argument_list>(<argument><expr><literal type="char">'C'</literal></expr></argument>, <argument><expr><literal type="string">"SELECT"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Inject a file with given name and content in the output tar stream.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>sendFileWithContent</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>filename</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>content</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name><name>struct</name> <name>stat</name></name></type> <name>statbuf</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>pad</name></decl>,
				<decl><type ref="prev"/><name>len</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>content</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Construct a stat struct for the backup_label file we're injecting in
	 * the tar.
	 */</comment>
	<comment type="block">/* Windows doesn't have the concept of uid and gid */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WIN32</name></cpp:ifdef>
	<expr_stmt><expr><name><name>statbuf</name><operator>.</operator><name>st_uid</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>statbuf</name><operator>.</operator><name>st_gid</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	<expr_stmt><expr><name><name>statbuf</name><operator>.</operator><name>st_uid</name></name> <operator>=</operator> <call><name>geteuid</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>statbuf</name><operator>.</operator><name>st_gid</name></name> <operator>=</operator> <call><name>getegid</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<expr_stmt><expr><name><name>statbuf</name><operator>.</operator><name>st_mtime</name></name> <operator>=</operator> <call><name>time</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>statbuf</name><operator>.</operator><name>st_mode</name></name> <operator>=</operator> <name>pg_file_create_mode</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>statbuf</name><operator>.</operator><name>st_size</name></name> <operator>=</operator> <name>len</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>_tarWriteHeader</name><argument_list>(<argument><expr><name>filename</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>statbuf</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* Send the contents as a CopyData message */</comment>
	<expr_stmt><expr><call><name>pq_putmessage</name><argument_list>(<argument><expr><literal type="char">'d'</literal></expr></argument>, <argument><expr><name>content</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Pad to 512 byte boundary, per tar format requirements */</comment>
	<expr_stmt><expr><name>pad</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>len</name> <operator>+</operator> <literal type="number">511</literal><operator>)</operator> <operator>&amp;</operator> <operator>~</operator><literal type="number">511</literal><operator>)</operator> <operator>-</operator> <name>len</name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>pad</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name></type>		<name><name>buf</name><index>[<expr><literal type="number">512</literal></expr>]</index></name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>pad</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pq_putmessage</name><argument_list>(<argument><expr><literal type="char">'d'</literal></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>pad</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Include the tablespace directory pointed to by 'path' in the output tar
 * stream.  If 'sizeonly' is true, we just calculate a total length and return
 * it, without actually sending anything.
 *
 * Only used to send auxiliary tablespaces, not PGDATA.
 */</comment>
<function><type><name>int64</name></type>
<name>sendTablespace</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>path</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>sizeonly</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int64</name></type>		<name>size</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>pathbuf</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>stat</name></name></type> <name>statbuf</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * 'path' points to the tablespace location, but we only want to include
	 * the version directory in it that belongs to us.
	 */</comment>
	<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>pathbuf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>pathbuf</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"%s/%s"</literal></expr></argument>, <argument><expr><name>path</name></expr></argument>,
			 <argument><expr><name>TABLESPACE_VERSION_DIRECTORY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Store a directory entry in the tar file so we get the permissions
	 * right.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>lstat</name><argument_list>(<argument><expr><name>pathbuf</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>statbuf</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>errno</name> <operator>!=</operator> <name>ENOENT</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not stat file or directory \"%s\": %m"</literal></expr></argument>,
							<argument><expr><name>pathbuf</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/* If the tablespace went away while scanning, it's no error. */</comment>
		<return>return <expr><literal type="number">0</literal></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>size</name> <operator>=</operator> <call><name>_tarWriteHeader</name><argument_list>(<argument><expr><name>TABLESPACE_VERSION_DIRECTORY</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>statbuf</name></expr></argument>,
						   <argument><expr><name>sizeonly</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Send all the files in the tablespace version directory */</comment>
	<expr_stmt><expr><name>size</name> <operator>+=</operator> <call><name>sendDir</name><argument_list>(<argument><expr><name>pathbuf</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>sizeonly</name></expr></argument>, <argument><expr><name>NIL</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><call><name>POLAR_FILE_IN_SHARED_STORAGE</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>size</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Include all files from the given directory in the output tar stream. If
 * 'sizeonly' is true, we just calculate a total length and return it, without
 * actually sending anything.
 *
 * Omit any directory in the tablespaces list, to avoid backing up
 * tablespaces twice when they were created inside PGDATA.
 *
 * If sendtblspclinks is true, we need to include symlink
 * information in the tar file. If not, we can skip that
 * as it will be sent separately in the tablespace_map file.
 */</comment>
<function><type><specifier>static</specifier> <name>int64</name></type>
<name>sendDir</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>path</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>basepathlen</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>sizeonly</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>tablespaces</name></decl></parameter>,
		<parameter><decl><type><name>bool</name></type> <name>sendtblspclinks</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>is_pfs</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>senddmafiles</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>DIR</name>		   <modifier>*</modifier></type><name>dir</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>dirent</name></name> <modifier>*</modifier></type><name>de</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>pathbuf</name><index>[<expr><name>MAXPGPATH</name> <operator>*</operator> <literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>pathbuf2</name><index>[<expr><name>MAXPGPATH</name> <operator>*</operator> <literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>stat</name></name></type> <name>statbuf</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int64</name></type>		<name>size</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>lastDir</name></decl>;</decl_stmt>		<comment type="block">/* Split last dir from parent path. */</comment>
	<decl_stmt><decl><type><name>bool</name></type>		<name>isDbDir</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>	<comment type="block">/* Does this directory contain relations? */</comment>

	<comment type="block">/*
	 * Determine if the current path is a database directory that can contain
	 * relations.
	 *
	 * Start by finding the location of the delimiter between the parent path
	 * and the current path.
	 */</comment>
	<expr_stmt><expr><name>lastDir</name> <operator>=</operator> <call><name>last_dir_separator</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Does this path look like a database path (i.e. all digits)? */</comment>
	<if_stmt><if>if <condition>(<expr><name>lastDir</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator>
		<call><name>strspn</name><argument_list>(<argument><expr><name>lastDir</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><literal type="string">"0123456789"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>lastDir</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Part of path that contains the parent directory. */</comment>
		<decl_stmt><decl><type><name>int</name></type>			<name>parentPathLen</name> <init>= <expr><name>lastDir</name> <operator>-</operator> <name>path</name></expr></init></decl>;</decl_stmt>

		<comment type="block">/*
		 * Mark path as a database directory if the parent path is either
		 * $PGDATA/base or a tablespace version path.
		 */</comment>
		<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>pathbuf2</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>pathbuf2</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"%s/base"</literal></expr></argument>, <argument><expr><ternary><condition><expr><name>is_pfs</name></expr> ?</condition><then> <expr><name>polar_datadir</name></expr> </then><else>: <expr><literal type="string">"."</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>strncmp</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>pathbuf2</name></expr></argument>, <argument><expr><name>parentPathLen</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
			<operator>(</operator><name>parentPathLen</name> <operator>&gt;=</operator> <operator>(</operator><sizeof>sizeof<argument_list>(<argument><expr><name>TABLESPACE_VERSION_DIRECTORY</name></expr></argument>)</argument_list></sizeof> <operator>-</operator> <literal type="number">1</literal><operator>)</operator> <operator>&amp;&amp;</operator>
			 <call><name>strncmp</name><argument_list>(<argument><expr><name>lastDir</name> <operator>-</operator> <operator>(</operator><sizeof>sizeof<argument_list>(<argument><expr><name>TABLESPACE_VERSION_DIRECTORY</name></expr></argument>)</argument_list></sizeof> <operator>-</operator> <literal type="number">1</literal><operator>)</operator></expr></argument>,
					 <argument><expr><name>TABLESPACE_VERSION_DIRECTORY</name></expr></argument>,
					 <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>TABLESPACE_VERSION_DIRECTORY</name></expr></argument>)</argument_list></sizeof> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>isDbDir</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>dir</name> <operator>=</operator> <call><name>AllocateDir</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>is_pfs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<while>while <condition>(<expr><operator>(</operator><name>de</name> <operator>=</operator> <call><name>ReadDir</name><argument_list>(<argument><expr><name>dir</name></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>excludeIdx</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>excludeFound</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ForkNumber</name></type>	<name>relForkNum</name></decl>;</decl_stmt> <comment type="block">/* Type of fork if file is a relation */</comment>
		<decl_stmt><decl><type><name>int</name></type>			<name>relOidChars</name></decl>;</decl_stmt>	<comment type="block">/* Chars in filename that are the rel oid */</comment>

		<comment type="block">/* Skip special stuff */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>de</name><operator>-&gt;</operator><name>d_name</name></name></expr></argument>, <argument><expr><literal type="string">"."</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <call><name>strcmp</name><argument_list>(<argument><expr><name><name>de</name><operator>-&gt;</operator><name>d_name</name></name></expr></argument>, <argument><expr><literal type="string">".."</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<comment type="block">/* Skip temporary files */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>strncmp</name><argument_list>(<argument><expr><name><name>de</name><operator>-&gt;</operator><name>d_name</name></name></expr></argument>,
					<argument><expr><name>PG_TEMP_FILE_PREFIX</name></expr></argument>,
					<argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>PG_TEMP_FILE_PREFIX</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * Check if the postmaster has signaled us to exit, and abort with an
		 * error in that case. The error handler further up will call
		 * do_pg_abort_backup() for us. Also check that if the backup was
		 * started while still in recovery, the server wasn't promoted.
		 * dp_pg_stop_backup() will check that too, but it's better to stop
		 * the backup early than continue to the end and fail there.
		 */</comment>
		<expr_stmt><expr><call><name>CHECK_FOR_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>RecoveryInProgress</name><argument_list>()</argument_list></call> <operator>!=</operator> <name>backup_started_in_recovery</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"the standby was promoted during online backup"</literal></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"This means that the backup being taken is corrupt "</literal>
							 <literal type="string">"and should not be used. "</literal>
							 <literal type="string">"Try taking another online backup."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/* Scan for files that should be excluded */</comment>
		<expr_stmt><expr><name>excludeFound</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<for>for <control>(<init><expr><name>excludeIdx</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name><name>excludeFiles</name><index>[<expr><name>excludeIdx</name></expr>]</index></name><operator>.</operator><name>name</name> <operator>!=</operator> <name>NULL</name></expr>;</condition> <incr><expr><name>excludeIdx</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>int</name></type>			<name>cmplen</name> <init>= <expr><call><name>strlen</name><argument_list>(<argument><expr><name><name>excludeFiles</name><index>[<expr><name>excludeIdx</name></expr>]</index></name><operator>.</operator><name>name</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>excludeFiles</name><index>[<expr><name>excludeIdx</name></expr>]</index></name><operator>.</operator><name>match_prefix</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>cmplen</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><call><name>strncmp</name><argument_list>(<argument><expr><name><name>de</name><operator>-&gt;</operator><name>d_name</name></name></expr></argument>, <argument><expr><name><name>excludeFiles</name><index>[<expr><name>excludeIdx</name></expr>]</index></name><operator>.</operator><name>name</name></expr></argument>, <argument><expr><name>cmplen</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>, <argument><expr><literal type="string">"file \"%s\" excluded from backup"</literal></expr></argument>, <argument><expr><name><name>de</name><operator>-&gt;</operator><name>d_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>excludeFound</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></for>

		<if_stmt><if>if <condition>(<expr><name>excludeFound</name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<comment type="block">/* Exclude all forks for unlogged tables except the init fork */</comment>
		<if_stmt><if>if <condition>(<expr><name>isDbDir</name> <operator>&amp;&amp;</operator>
			<call><name>parse_filename_for_nontemp_relation</name><argument_list>(<argument><expr><name><name>de</name><operator>-&gt;</operator><name>d_name</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>relOidChars</name></expr></argument>,
												<argument><expr><operator>&amp;</operator><name>relForkNum</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Never exclude init forks */</comment>
			<if_stmt><if>if <condition>(<expr><name>relForkNum</name> <operator>!=</operator> <name>INIT_FORKNUM</name></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>char</name></type>		<name><name>initForkFile</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>char</name></type>		<name><name>relOid</name><index>[<expr><name>OIDCHARS</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>

				<comment type="block">/*
				 * If any other type of fork, check if there is an init fork
				 * with the same OID. If so, the file can be excluded.
				 */</comment>
				<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>relOid</name></expr></argument>, <argument><expr><name><name>de</name><operator>-&gt;</operator><name>d_name</name></name></expr></argument>, <argument><expr><name>relOidChars</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>relOid</name><index>[<expr><name>relOidChars</name></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>initForkFile</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>initForkFile</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"%s/%s_init"</literal></expr></argument>,
						 <argument><expr><name>path</name></expr></argument>, <argument><expr><name>relOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<if_stmt><if>if <condition>(<expr><call><name>lstat</name><argument_list>(<argument><expr><name>initForkFile</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>statbuf</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG2</name></expr></argument>,
						 <argument><expr><literal type="string">"unlogged relation file \"%s\" excluded from backup"</literal></expr></argument>,
						 <argument><expr><name><name>de</name><operator>-&gt;</operator><name>d_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<continue>continue;</continue>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* Exclude temporary relations */</comment>
		<if_stmt><if>if <condition>(<expr><name>isDbDir</name> <operator>&amp;&amp;</operator> <call><name>looks_like_temp_rel_name</name><argument_list>(<argument><expr><name><name>de</name><operator>-&gt;</operator><name>d_name</name></name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG2</name></expr></argument>,
				 <argument><expr><literal type="string">"temporary relation file \"%s\" excluded from backup"</literal></expr></argument>,
				 <argument><expr><name><name>de</name><operator>-&gt;</operator><name>d_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>pathbuf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>pathbuf</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"%s/%s"</literal></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name><name>de</name><operator>-&gt;</operator><name>d_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Skip pg_control here to back up it last */</comment>
		<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>pathbuf2</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>pathbuf2</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"%s/global/pg_control"</literal></expr></argument>, <argument><expr><ternary><condition><expr><name>is_pfs</name></expr> ?</condition><then> <expr><name>polar_datadir</name></expr> </then><else>: <expr><literal type="string">"."</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>pathbuf</name></expr></argument>, <argument><expr><name>pathbuf2</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * POLAR: for security, we skip transmission of
		 * pg_log/recovery.conf/pg_stat_statements files.
		 */</comment>
		<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>pathbuf2</name></expr></argument>, <argument><expr><name>MAXPGPATH</name></expr></argument>, <argument><expr><literal type="string">"%s/%s"</literal></expr></argument>, <argument><expr><ternary><condition><expr><name>is_pfs</name></expr> ?</condition><then> <expr><name>polar_datadir</name></expr> </then><else>: <expr><literal type="string">"."</literal></expr></else></ternary></expr></argument>, <argument><expr><name>Log_directory</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>pathbuf</name></expr></argument>, <argument><expr><name>pathbuf2</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>pathbuf2</name></expr></argument>, <argument><expr><name>MAXPGPATH</name></expr></argument>, <argument><expr><literal type="string">"%s/%s"</literal></expr></argument>, <argument><expr><ternary><condition><expr><name>is_pfs</name></expr> ?</condition><then> <expr><name>polar_datadir</name></expr> </then><else>: <expr><literal type="string">"."</literal></expr></else></ternary></expr></argument>, <argument><expr><name>RECOVERY_COMMAND_DONE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>pathbuf</name></expr></argument>, <argument><expr><name>pathbuf2</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>pathbuf2</name></expr></argument>, <argument><expr><name>MAXPGPATH</name></expr></argument>, <argument><expr><literal type="string">"%s/pg_stat/pg_stat_statements.stat"</literal></expr></argument>, <argument><expr><ternary><condition><expr><name>is_pfs</name></expr> ?</condition><then> <expr><name>polar_datadir</name></expr> </then><else>: <expr><literal type="string">"."</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>pathbuf</name></expr></argument>, <argument><expr><name>pathbuf2</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>pathbuf2</name></expr></argument>, <argument><expr><name>MAXPGPATH</name></expr></argument>, <argument><expr><literal type="string">"%s/pg_stat_tmp/pgss_query_texts.stat"</literal></expr></argument>, <argument><expr><ternary><condition><expr><name>is_pfs</name></expr> ?</condition><then> <expr><name>polar_datadir</name></expr> </then><else>: <expr><literal type="string">"."</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>pathbuf</name></expr></argument>,	<argument><expr><name>pathbuf2</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>
		<comment type="block">/* POLAR end */</comment>

		<if_stmt><if>if <condition>(<expr><call><name>polar_lstat</name><argument_list>(<argument><expr><name>pathbuf</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>statbuf</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>errno</name> <operator>!=</operator> <name>ENOENT</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not stat file or directory \"%s\": %m"</literal></expr></argument>,
								<argument><expr><name>pathbuf</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<comment type="block">/* If the file went away while scanning, it's not an error. */</comment>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* Scan for directories whose contents should be excluded */</comment>
		<expr_stmt><expr><name>excludeFound</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<for>for <control>(<init><expr><name>excludeIdx</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name><name>excludeDirContents</name><index>[<expr><name>excludeIdx</name></expr>]</index></name> <operator>!=</operator> <name>NULL</name></expr>;</condition> <incr><expr><name>excludeIdx</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>de</name><operator>-&gt;</operator><name>d_name</name></name></expr></argument>, <argument><expr><name><name>excludeDirContents</name><index>[<expr><name>excludeIdx</name></expr>]</index></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>, <argument><expr><literal type="string">"contents of directory \"%s\" excluded from backup"</literal></expr></argument>, <argument><expr><name><name>de</name><operator>-&gt;</operator><name>d_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>size</name> <operator>+=</operator> <call><name>_tarWriteDir</name><argument_list>(<argument><expr><name>pathbuf</name></expr></argument>, <argument><expr><name>basepathlen</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>statbuf</name></expr></argument>, <argument><expr><name>sizeonly</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>excludeFound</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></for>

		<comment type="block">/* POLAR: ignore polar_datadir inside data_directory when is_pfs is false. */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>excludeFound</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>is_pfs</name> <operator>&amp;&amp;</operator> <call><name>POLAR_FILE_IN_SHARED_STORAGE</name><argument_list>()</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>char</name></type> <name><name>full_dir</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>tmp_dir</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>tmp_polar_datadir</name></decl>;</decl_stmt>
			<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>full_dir</name></expr></argument>, <argument><expr><name>MAXPGPATH</name></expr></argument>, <argument><expr><literal type="string">"%s/%s"</literal></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name><name>de</name><operator>-&gt;</operator><name>d_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>tmp_dir</name> <operator>=</operator> <call><name>realpath</name><argument_list>(<argument><expr><name>full_dir</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>tmp_polar_datadir</name> <operator>=</operator> <call><name>realpath</name><argument_list>(<argument><expr><call><name>polar_path_remove_protocol</name><argument_list>(<argument><expr><name>polar_datadir</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>tmp_dir</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator>
				<name>tmp_polar_datadir</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator>
				<call><name>strcmp</name><argument_list>(<argument><expr><name>tmp_polar_datadir</name></expr></argument>, <argument><expr><name>tmp_dir</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>excludeFound</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><name>tmp_dir</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>tmp_dir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><name>tmp_polar_datadir</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>tmp_polar_datadir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
		<comment type="block">/* POLAR end */</comment>

		<if_stmt><if>if <condition>(<expr><name>excludeFound</name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * Exclude contents of directory specified by statrelpath if not set
		 * to the default (pg_stat_tmp) which is caught in the loop above.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>statrelpath</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <call><name>strcmp</name><argument_list>(<argument><expr><name>pathbuf</name></expr></argument>, <argument><expr><name>statrelpath</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>, <argument><expr><literal type="string">"contents of directory \"%s\" excluded from backup"</literal></expr></argument>, <argument><expr><name>statrelpath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>size</name> <operator>+=</operator> <call><name>_tarWriteDir</name><argument_list>(<argument><expr><name>pathbuf</name></expr></argument>, <argument><expr><name>basepathlen</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>statbuf</name></expr></argument>, <argument><expr><name>sizeonly</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * We can skip pg_wal, the WAL segments need to be fetched from the
		 * WAL archive anyway. But include it as an empty directory anyway, so
		 * we get permissions right.
		 */</comment>
		<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>pathbuf2</name></expr></argument>, <argument><expr><name>MAXPGPATH</name></expr></argument>, <argument><expr><literal type="string">"%s/pg_wal"</literal></expr></argument>, <argument><expr><ternary><condition><expr><name>is_pfs</name></expr> ?</condition><then> <expr><name>polar_datadir</name></expr> </then><else>: <expr><literal type="string">"."</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>pathbuf</name></expr></argument>, <argument><expr><name>pathbuf2</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* If pg_wal is a symlink, write it as a directory anyway */</comment>
			<expr_stmt><expr><name>size</name> <operator>+=</operator> <call><name>_tarWriteDir</name><argument_list>(<argument><expr><name>pathbuf</name></expr></argument>, <argument><expr><name>basepathlen</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>statbuf</name></expr></argument>, <argument><expr><name>sizeonly</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * Also send archive_status directory (by hackishly reusing
			 * statbuf from above ...).
			 */</comment>
			<expr_stmt><expr><name>size</name> <operator>+=</operator> <call><name>_tarWriteHeader</name><argument_list>(<argument><expr><literal type="string">"./pg_wal/archive_status"</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>statbuf</name></expr></argument>,
									<argument><expr><name>sizeonly</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<continue>continue;</continue>			<comment type="block">/* don't recurse into pg_wal */</comment>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* Skip polar_dma meta file if not required */</comment>
		<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>pathbuf2</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>pathbuf2</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"%s/polar_dma/consensus_meta"</literal></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>pathbuf</name></expr></argument>, <argument><expr><name>pathbuf2</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>!</operator><name>senddmafiles</name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<comment type="block">/* Skip polar_dma log files if not required */</comment>
		<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>pathbuf2</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>pathbuf2</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"%s/polar_dma/consensus"</literal></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>strncmp</name><argument_list>(<argument><expr><name>pathbuf</name></expr></argument>, <argument><expr><name>pathbuf2</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>pathbuf2</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>!</operator><name>senddmafiles</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* don't recurse into polar_dma/consensus_log &amp; consensus_cc_log */</comment>
			<expr_stmt><expr><name>size</name> <operator>+=</operator> <call><name>_tarWriteDir</name><argument_list>(<argument><expr><name>pathbuf</name></expr></argument>, <argument><expr><name>basepathlen</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>statbuf</name></expr></argument>, <argument><expr><name>sizeonly</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<continue>continue;</continue> 
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* Allow symbolic links in pg_tblspc only */</comment>
		<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>pathbuf2</name></expr></argument>, <argument><expr><name>MAXPGPATH</name></expr></argument>, <argument><expr><literal type="string">"%s/pg_tblspc"</literal></expr></argument>, <argument><expr><ternary><condition><expr><name>is_pfs</name></expr> ?</condition><then> <expr><name>polar_datadir</name></expr> </then><else>: <expr><literal type="string">"."</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>pathbuf2</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>!</operator><name>is_pfs</name> <operator>&amp;&amp;</operator>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>WIN32</name></cpp:ifndef>
			<macro><name>S_ISLNK</name><argument_list>(<argument>statbuf.st_mode</argument>)</argument_list></macro>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
			<call><name>pgwin32_is_junction</name><argument_list>(<argument><expr><name>pathbuf</name></expr></argument>)</argument_list></call></expr>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
			)</condition>
		<block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_READLINK</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>WIN32</name></expr></argument>)</argument_list></call></expr></cpp:if>
			<decl_stmt><decl><type><name>char</name></type>		<name><name>linkpath</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int</name></type>			<name>rllen</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>rllen</name> <operator>=</operator> <call><name>readlink</name><argument_list>(<argument><expr><name>pathbuf</name></expr></argument>, <argument><expr><name>linkpath</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>linkpath</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>rllen</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not read symbolic link \"%s\": %m"</literal></expr></argument>,
								<argument><expr><name>pathbuf</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><name>rllen</name> <operator>&gt;=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>linkpath</name></expr></argument>)</argument_list></sizeof></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_PROGRAM_LIMIT_EXCEEDED</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"symbolic link \"%s\" target is too long"</literal></expr></argument>,
								<argument><expr><name>pathbuf</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><name><name>linkpath</name><index>[<expr><name>rllen</name></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>

			<expr_stmt><expr><name>size</name> <operator>+=</operator> <call><name>_tarWriteHeader</name><argument_list>(<argument><expr><name>pathbuf</name> <operator>+</operator> <name>basepathlen</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>linkpath</name></expr></argument>,
									<argument><expr><operator>&amp;</operator><name>statbuf</name></expr></argument>, <argument><expr><name>sizeonly</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

			<comment type="block">/*
			 * If the platform does not have symbolic links, it should not be
			 * possible to have tablespaces - clearly somebody else created
			 * them. Warn about it and ignore.
			 */</comment>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"tablespaces are not supported on this platform"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<continue>continue;</continue>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>							<comment type="block">/* HAVE_READLINK */</comment>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><call><name>S_ISDIR</name><argument_list>(<argument><expr><name><name>statbuf</name><operator>.</operator><name>st_mode</name></name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>bool</name></type>		<name>skip_this_dir</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

			<comment type="block">/*
			 * Store a directory entry in the tar file so we can get the
			 * permissions right.
			 */</comment>
			<expr_stmt><expr><name>size</name> <operator>+=</operator> <call><name>_tarWriteHeader</name><argument_list>(<argument><expr><name>pathbuf</name> <operator>+</operator> <name>basepathlen</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>statbuf</name></expr></argument>,
									<argument><expr><name>sizeonly</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * Call ourselves recursively for a directory, unless it happens
			 * to be a separate tablespace located within PGDATA.
			 */</comment>
			<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>tablespaces</argument>)</argument_list></macro>
			<block>{<block_content>
				<decl_stmt><decl><type><name>tablespaceinfo</name> <modifier>*</modifier></type><name>ti</name> <init>= <expr><operator>(</operator><name>tablespaceinfo</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

				<comment type="block">/*
				 * ti-&gt;rpath is the tablespace relative path within PGDATA, or
				 * NULL if the tablespace has been properly located somewhere
				 * else.
				 *
				 * Skip past the leading "./" in pathbuf when comparing.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><name><name>ti</name><operator>-&gt;</operator><name>rpath</name></name> <operator>&amp;&amp;</operator> <call><name>strcmp</name><argument_list>(<argument><expr><name><name>ti</name><operator>-&gt;</operator><name>rpath</name></name></expr></argument>, <argument><expr><name>pathbuf</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name>skip_this_dir</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
					<break>break;</break>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block>

			<comment type="block">/*
			 * skip sending directories inside pg_tblspc, if not required.
			 */</comment>
			<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>pathbuf2</name></expr></argument>, <argument><expr><name>MAXPGPATH</name></expr></argument>, <argument><expr><literal type="string">"%s/pg_tblspc"</literal></expr></argument>, <argument><expr><ternary><condition><expr><name>is_pfs</name></expr> ?</condition><then> <expr><name>polar_datadir</name></expr> </then><else>: <expr><literal type="string">"."</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>pathbuf</name></expr></argument>, <argument><expr><name>pathbuf2</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>!</operator><name>sendtblspclinks</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>skip_this_dir</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>skip_this_dir</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>size</name> <operator>+=</operator> <call><name>sendDir</name><argument_list>(<argument><expr><name>pathbuf</name></expr></argument>, <argument><expr><name>basepathlen</name></expr></argument>, <argument><expr><name>sizeonly</name></expr></argument>, <argument><expr><name>tablespaces</name></expr></argument>, <argument><expr><name>sendtblspclinks</name></expr></argument>, <argument><expr><name>is_pfs</name></expr></argument>, <argument><expr><name>senddmafiles</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><call><name>S_ISREG</name><argument_list>(<argument><expr><name><name>statbuf</name><operator>.</operator><name>st_mode</name></name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>bool</name></type>		<name>sent</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>sizeonly</name></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name>is_pfs</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>sent</name> <operator>=</operator> <call><name>sendPolarFile</name><argument_list>(<argument><expr><name>pathbuf</name></expr></argument>, <argument><expr><name>pathbuf</name> <operator>+</operator> <name>basepathlen</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>statbuf</name></expr></argument>,
								<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><name>sent</name> <operator>=</operator> <call><name>sendFile</name><argument_list>(<argument><expr><name>pathbuf</name></expr></argument>, <argument><expr><name>pathbuf</name> <operator>+</operator> <name>basepathlen</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>statbuf</name></expr></argument>,
								<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
			</block_content>}</block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><name>sent</name> <operator>||</operator> <name>sizeonly</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* Add size, rounded up to 512byte block */</comment>
				<expr_stmt><expr><name>size</name> <operator>+=</operator> <operator>(</operator><operator>(</operator><name><name>statbuf</name><operator>.</operator><name>st_size</name></name> <operator>+</operator> <literal type="number">511</literal><operator>)</operator> <operator>&amp;</operator> <operator>~</operator><literal type="number">511</literal><operator>)</operator></expr>;</expr_stmt>
				<expr_stmt><expr><name>size</name> <operator>+=</operator> <literal type="number">512</literal></expr>;</expr_stmt>	<comment type="block">/* Size of the header of the file */</comment>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"skipping special file \"%s\""</literal></expr></argument>, <argument><expr><name>pathbuf</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></while>
	<expr_stmt><expr><call><name>FreeDir</name><argument_list>(<argument><expr><name>dir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>size</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Check if a file should have its checksum validated.
 * We validate checksums on files in regular tablespaces
 * (including global and default) only, and in those there
 * are some files that are explicitly excluded.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>is_checksummed_file</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>fullpath</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>filename</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>is_pfs</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type> 	<name>checkdir</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> 	<name>polardatalen</name> <init>= <expr><call><name>strlen</name><argument_list>(<argument><expr><name>polar_datadir</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>is_pfs</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>checkdir</name> <operator>=</operator> <call><name>strncmp</name><argument_list>(<argument><expr><name>fullpath</name> <operator>+</operator> <name>polardatalen</name></expr></argument>, <argument><expr><literal type="string">"/global"</literal></expr></argument>, <argument><expr><literal type="number">7</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
					<call><name>strncmp</name><argument_list>(<argument><expr><name>fullpath</name> <operator>+</operator> <name>polardatalen</name></expr></argument>, <argument><expr><literal type="string">"/base"</literal></expr></argument>, <argument><expr><literal type="number">5</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>checkdir</name> <operator>=</operator> <call><name>strncmp</name><argument_list>(<argument><expr><name>fullpath</name></expr></argument>, <argument><expr><literal type="string">"./global/"</literal></expr></argument>, <argument><expr><literal type="number">9</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
					<call><name>strncmp</name><argument_list>(<argument><expr><name>fullpath</name></expr></argument>, <argument><expr><literal type="string">"./base/"</literal></expr></argument>, <argument><expr><literal type="number">7</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
					<call><name>strncmp</name><argument_list>(<argument><expr><name>fullpath</name></expr></argument>, <argument><expr><literal type="string">"/"</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>	

	<comment type="block">/* Check that the file is in a tablespace */</comment>
	<if_stmt><if>if <condition>(<expr><name>checkdir</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>excludeIdx</name></decl>;</decl_stmt>

		<comment type="block">/* Compare file against noChecksumFiles skip list */</comment>
		<for>for <control>(<init><expr><name>excludeIdx</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name><name>noChecksumFiles</name><index>[<expr><name>excludeIdx</name></expr>]</index></name><operator>.</operator><name>name</name> <operator>!=</operator> <name>NULL</name></expr>;</condition> <incr><expr><name>excludeIdx</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>int</name></type>			<name>cmplen</name> <init>= <expr><call><name>strlen</name><argument_list>(<argument><expr><name><name>noChecksumFiles</name><index>[<expr><name>excludeIdx</name></expr>]</index></name><operator>.</operator><name>name</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>noChecksumFiles</name><index>[<expr><name>excludeIdx</name></expr>]</index></name><operator>.</operator><name>match_prefix</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>cmplen</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><call><name>strncmp</name><argument_list>(<argument><expr><name>filename</name></expr></argument>, <argument><expr><name><name>noChecksumFiles</name><index>[<expr><name>excludeIdx</name></expr>]</index></name><operator>.</operator><name>name</name></expr></argument>,
						<argument><expr><name>cmplen</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
		</block_content>}</block></for>

		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/*****
 * Functions for handling tar file format
 *
 * Copied from pg_dump, but modified to work with libpq for sending
 */</comment>


<comment type="block">/*
 * Given the member, write the TAR header &amp; send the file.
 *
 * If 'missing_ok' is true, will not throw an error if the file is not found.
 *
 * Returns true if the file was successfully sent, false if 'missing_ok',
 * and the file did not exist.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>sendFile</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>readfilename</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>tarfilename</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>stat</name></name> <modifier>*</modifier></type><name>statbuf</name></decl></parameter>,
		 <parameter><decl><type><name>bool</name></type> <name>missing_ok</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>FILE</name>	   <modifier>*</modifier></type><name>fp</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BlockNumber</name></type> <name>blkno</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>block_retry</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>buf</name><index>[<expr><name>TAR_SEND_SIZE</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint16</name></type>		<name>checksum</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>checksum_failures</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>off_t</name></type>		<name>cnt</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>pgoff_t</name></type>		<name>len</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>page</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>size_t</name></type>		<name>pad</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PageHeader</name></type>	<name>phdr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>segmentno</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>segmentpath</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>verify_checksum</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>fp</name> <operator>=</operator> <call><name>AllocateFile</name><argument_list>(<argument><expr><name>readfilename</name></expr></argument>, <argument><expr><literal type="string">"rb"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>fp</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>errno</name> <operator>==</operator> <name>ENOENT</name> <operator>&amp;&amp;</operator> <name>missing_ok</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not open file \"%s\": %m"</literal></expr></argument>, <argument><expr><name>readfilename</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>_tarWriteHeader</name><argument_list>(<argument><expr><name>tarfilename</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>statbuf</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>noverify_checksums</name> <operator>&amp;&amp;</operator> <call><name>DataChecksumsEnabled</name><argument_list>()</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>filename</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * Get the filename (excluding path).  As last_dir_separator()
		 * includes the last directory separator, we chop that off by
		 * incrementing the pointer.
		 */</comment>
		<expr_stmt><expr><name>filename</name> <operator>=</operator> <call><name>last_dir_separator</name><argument_list>(<argument><expr><name>readfilename</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>is_checksummed_file</name><argument_list>(<argument><expr><name>readfilename</name></expr></argument>, <argument><expr><name>filename</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>verify_checksum</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

			<comment type="block">/*
			 * Cut off at the segment boundary (".") to get the segment number
			 * in order to mix it into the checksum.
			 */</comment>
			<expr_stmt><expr><name>segmentpath</name> <operator>=</operator> <call><name>strstr</name><argument_list>(<argument><expr><name>filename</name></expr></argument>, <argument><expr><literal type="string">"."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>segmentpath</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>segmentno</name> <operator>=</operator> <call><name>atoi</name><argument_list>(<argument><expr><name>segmentpath</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name>segmentno</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid segment number %d in file \"%s\""</literal></expr></argument>,
									<argument><expr><name>segmentno</name></expr></argument>, <argument><expr><name>filename</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<while>while <condition>(<expr><operator>(</operator><name>cnt</name> <operator>=</operator> <call><name>fread</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><call><name>Min</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name><name>statbuf</name><operator>-&gt;</operator><name>st_size</name></name> <operator>-</operator> <name>len</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>fp</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * The checksums are verified at block level, so we iterate over the
		 * buffer in chunks of BLCKSZ, after making sure that
		 * TAR_SEND_SIZE/buf is divisible by BLCKSZ and we read a multiple of
		 * BLCKSZ bytes.
		 */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>TAR_SEND_SIZE</name> <operator>%</operator> <name>BLCKSZ</name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>verify_checksum</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>cnt</name> <operator>%</operator> <name>BLCKSZ</name> <operator>!=</operator> <literal type="number">0</literal><operator>)</operator></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot verify checksum in file \"%s\", block "</literal>
							<literal type="string">"%d: read buffer size %d and page size %d "</literal>
							<literal type="string">"differ"</literal></expr></argument>,
							<argument><expr><name>readfilename</name></expr></argument>, <argument><expr><name>blkno</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name>cnt</name></expr></argument>, <argument><expr><name>BLCKSZ</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>verify_checksum</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>verify_checksum</name></expr>)</condition>
		<block>{<block_content>
			<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>cnt</name> <operator>/</operator> <name>BLCKSZ</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
			<block>{<block_content>
				<expr_stmt><expr><name>page</name> <operator>=</operator> <name>buf</name> <operator>+</operator> <name>BLCKSZ</name> <operator>*</operator> <name>i</name></expr>;</expr_stmt>

				<comment type="block">/*
				 * Only check pages which have not been modified since the
				 * start of the base backup. Otherwise, they might have been
				 * written only halfway and the checksum would not be valid.
				 * However, replaying WAL would reinstate the correct page in
				 * this case. We also skip completely new pages, since they
				 * don't have a checksum yet.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>PageIsNew</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>PageGetLSN</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <name>startptr</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name>checksum</name> <operator>=</operator> <call><name>pg_checksum_page</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>page</name></expr></argument>, <argument><expr><name>blkno</name> <operator>+</operator> <name>segmentno</name> <operator>*</operator> <name>RELSEG_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>phdr</name> <operator>=</operator> <operator>(</operator><name>PageHeader</name><operator>)</operator> <name>page</name></expr>;</expr_stmt>
					<if_stmt><if>if <condition>(<expr><name><name>phdr</name><operator>-&gt;</operator><name>pd_checksum</name></name> <operator>!=</operator> <name>checksum</name></expr>)</condition>
					<block>{<block_content>
						<comment type="block">/*
						 * Retry the block on the first failure.  It's
						 * possible that we read the first 4K page of the
						 * block just before postgres updated the entire block
						 * so it ends up looking torn to us.  We only need to
						 * retry once because the LSN should be updated to
						 * something we can ignore on the next pass.  If the
						 * error happens again then it is a true validation
						 * failure.
						 */</comment>
						<if_stmt><if>if <condition>(<expr><name>block_retry</name> <operator>==</operator> <name>false</name></expr>)</condition>
						<block>{<block_content>
							<comment type="block">/* Reread the failed block */</comment>
							<if_stmt><if>if <condition>(<expr><call><name>fseek</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><operator>-</operator><operator>(</operator><name>cnt</name> <operator>-</operator> <name>BLCKSZ</name> <operator>*</operator> <name>i</name><operator>)</operator></expr></argument>, <argument><expr><name>SEEK_CUR</name></expr></argument>)</argument_list></call> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>
							<block>{<block_content>
								<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
										<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
										 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not fseek in file \"%s\": %m"</literal></expr></argument>,
												<argument><expr><name>readfilename</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							</block_content>}</block></if></if_stmt>

							<if_stmt><if>if <condition>(<expr><call><name>fread</name><argument_list>(<argument><expr><name>buf</name> <operator>+</operator> <name>BLCKSZ</name> <operator>*</operator> <name>i</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>BLCKSZ</name></expr></argument>, <argument><expr><name>fp</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>BLCKSZ</name></expr>)</condition>
							<block>{<block_content>
								<comment type="block">/*
								 * If we hit end-of-file, a concurrent
								 * truncation must have occurred, so break out
								 * of this loop just as if the initial fread()
								 * returned 0. We'll drop through to the same
								 * code that handles that case. (We must fix
								 * up cnt first, though.)
								 */</comment>
								<if_stmt><if>if <condition>(<expr><call><name>feof</name><argument_list>(<argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>)</condition>
								<block>{<block_content>
									<expr_stmt><expr><name>cnt</name> <operator>=</operator> <name>BLCKSZ</name> <operator>*</operator> <name>i</name></expr>;</expr_stmt>
									<break>break;</break>
								</block_content>}</block></if></if_stmt>

								<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
										<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
										 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not reread block %d of file \"%s\": %m"</literal></expr></argument>,
												<argument><expr><name>blkno</name></expr></argument>, <argument><expr><name>readfilename</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							</block_content>}</block></if></if_stmt>

							<if_stmt><if>if <condition>(<expr><call><name>fseek</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><name>cnt</name> <operator>-</operator> <name>BLCKSZ</name> <operator>*</operator> <name>i</name> <operator>-</operator> <name>BLCKSZ</name></expr></argument>, <argument><expr><name>SEEK_CUR</name></expr></argument>)</argument_list></call> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>
							<block>{<block_content>
								<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
										<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
										 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not fseek in file \"%s\": %m"</literal></expr></argument>,
												<argument><expr><name>readfilename</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							</block_content>}</block></if></if_stmt>

							<comment type="block">/* Set flag so we know a retry was attempted */</comment>
							<expr_stmt><expr><name>block_retry</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

							<comment type="block">/* Reset loop to validate the block again */</comment>
							<expr_stmt><expr><name>i</name><operator>--</operator></expr>;</expr_stmt>
							<continue>continue;</continue>
						</block_content>}</block></if></if_stmt>

						<expr_stmt><expr><name>checksum_failures</name><operator>++</operator></expr>;</expr_stmt>

						<if_stmt><if>if <condition>(<expr><name>checksum_failures</name> <operator>&lt;=</operator> <literal type="number">5</literal></expr>)</condition><block type="pseudo"><block_content>
							<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>,
									<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"checksum verification failed in "</literal>
											<literal type="string">"file \"%s\", block %d: calculated "</literal>
											<literal type="string">"%X but expected %X"</literal></expr></argument>,
											<argument><expr><name>readfilename</name></expr></argument>, <argument><expr><name>blkno</name></expr></argument>, <argument><expr><name>checksum</name></expr></argument>,
											<argument><expr><name><name>phdr</name><operator>-&gt;</operator><name>pd_checksum</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
						<if_stmt><if>if <condition>(<expr><name>checksum_failures</name> <operator>==</operator> <literal type="number">5</literal></expr>)</condition><block type="pseudo"><block_content>
							<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>,
									<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"further checksum verification "</literal>
											<literal type="string">"failures in file \"%s\" will not "</literal>
											<literal type="string">"be reported"</literal></expr></argument>, <argument><expr><name>readfilename</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
					</block_content>}</block></if></if_stmt>
				</block_content>}</block></if></if_stmt>
				<expr_stmt><expr><name>block_retry</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>blkno</name><operator>++</operator></expr>;</expr_stmt>
			</block_content>}</block></for>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* Send the chunk as a CopyData message */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>pq_putmessage</name><argument_list>(<argument><expr><literal type="char">'d'</literal></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>cnt</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"base backup could not send data, aborting backup"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>len</name> <operator>+=</operator> <name>cnt</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>throttle</name><argument_list>(<argument><expr><name>cnt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>feof</name><argument_list>(<argument><expr><name>fp</name></expr></argument>)</argument_list></call> <operator>||</operator> <name>len</name> <operator>&gt;=</operator> <name><name>statbuf</name><operator>-&gt;</operator><name>st_size</name></name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * Reached end of file. The file could be longer, if it was
			 * extended while we were sending it, but for a base backup we can
			 * ignore such extended data. It will be restored from WAL.
			 */</comment>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></while>

	<expr_stmt><expr><call><name>CHECK_FREAD_ERROR</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><name>readfilename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* If the file was truncated while we were sending it, pad it with zeros */</comment>
	<if_stmt><if>if <condition>(<expr><name>len</name> <operator>&lt;</operator> <name><name>statbuf</name><operator>-&gt;</operator><name>st_size</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<while>while <condition>(<expr><name>len</name> <operator>&lt;</operator> <name><name>statbuf</name><operator>-&gt;</operator><name>st_size</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>cnt</name> <operator>=</operator> <call><name>Min</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name><name>statbuf</name><operator>-&gt;</operator><name>st_size</name></name> <operator>-</operator> <name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>pq_putmessage</name><argument_list>(<argument><expr><literal type="char">'d'</literal></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>cnt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>len</name> <operator>+=</operator> <name>cnt</name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>throttle</name><argument_list>(<argument><expr><name>cnt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></while>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Pad to 512 byte boundary, per tar format requirements. (This small
	 * piece of data is probably not worth throttling.)
	 */</comment>
	<expr_stmt><expr><name>pad</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>len</name> <operator>+</operator> <literal type="number">511</literal><operator>)</operator> <operator>&amp;</operator> <operator>~</operator><literal type="number">511</literal><operator>)</operator> <operator>-</operator> <name>len</name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>pad</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>pad</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pq_putmessage</name><argument_list>(<argument><expr><literal type="char">'d'</literal></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>pad</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>FreeFile</name><argument_list>(<argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>checksum_failures</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"file \"%s\" has a total of %d checksum verification "</literal>
						<literal type="string">"failures"</literal></expr></argument>, <argument><expr><name>readfilename</name></expr></argument>, <argument><expr><name>checksum_failures</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name>total_checksum_failures</name> <operator>+=</operator> <name>checksum_failures</name></expr>;</expr_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Given the member, write the TAR header &amp; send the file.
 *
 * If 'missing_ok' is true, will not throw an error if the file is not found.
 *
 * Returns true if the file was successfully sent, false if 'missing_ok',
 * and the file did not exist.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>sendPolarFile</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>readfilename</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>tarfilename</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>stat</name></name> <modifier>*</modifier></type><name>statbuf</name></decl></parameter>,
		 <parameter><decl><type><name>bool</name></type> <name>missing_ok</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>	   		<name>fd</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BlockNumber</name></type> <name>blkno</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>block_retry</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>buf</name><index>[<expr><name>POLAR_TAR_SEND_SIZE</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint16</name></type>		<name>checksum</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>checksum_failures</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>off_t</name></type>		<name>cnt</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>pgoff_t</name></type>		<name>len</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>page</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>size_t</name></type>		<name>pad</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PageHeader</name></type>	<name>phdr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>segmentno</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>segmentpath</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>verify_checksum</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>fd</name> <operator>=</operator> <call><name>polar_open</name><argument_list>(<argument><expr><name>readfilename</name></expr></argument>, <argument><expr><name>O_RDONLY</name> <operator>|</operator> <name>PG_BINARY</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>errno</name> <operator>==</operator> <name>ENOENT</name> <operator>&amp;&amp;</operator> <name>missing_ok</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not open file \"%s\": %m"</literal></expr></argument>, <argument><expr><name>readfilename</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>_tarWriteHeader</name><argument_list>(<argument><expr><name>tarfilename</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>statbuf</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>noverify_checksums</name> <operator>&amp;&amp;</operator> <call><name>DataChecksumsEnabled</name><argument_list>()</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>filename</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * Get the filename (excluding path).  As last_dir_separator()
		 * includes the last directory separator, we chop that off by
		 * incrementing the pointer.
		 */</comment>
		<expr_stmt><expr><name>filename</name> <operator>=</operator> <call><name>last_dir_separator</name><argument_list>(<argument><expr><name>readfilename</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>is_checksummed_file</name><argument_list>(<argument><expr><name>readfilename</name></expr></argument>, <argument><expr><name>filename</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>verify_checksum</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

			<comment type="block">/*
			 * Cut off at the segment boundary (".") to get the segment number
			 * in order to mix it into the checksum.
			 */</comment>
			<expr_stmt><expr><name>segmentpath</name> <operator>=</operator> <call><name>strstr</name><argument_list>(<argument><expr><name>filename</name></expr></argument>, <argument><expr><literal type="string">"."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>segmentpath</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>segmentno</name> <operator>=</operator> <call><name>atoi</name><argument_list>(<argument><expr><name>segmentpath</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name>segmentno</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid segment number %d in file \"%s\""</literal></expr></argument>,
									<argument><expr><name>segmentno</name></expr></argument>, <argument><expr><name>filename</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<empty_stmt>;</empty_stmt>
	<while>while <condition>(<expr><operator>(</operator><name>cnt</name> <operator>=</operator> <call><name>polar_read</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><call><name>Min</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name><name>statbuf</name><operator>-&gt;</operator><name>st_size</name></name> <operator>-</operator> <name>len</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * The checksums are verified at block level, so we iterate over the
		 * buffer in chunks of BLCKSZ, after making sure that
		 * POLAR_TAR_SEND_SIZE/buf is divisible by BLCKSZ and we read a multiple of
		 * BLCKSZ bytes.
		 */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>POLAR_TAR_SEND_SIZE</name> <operator>%</operator> <name>BLCKSZ</name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>verify_checksum</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>cnt</name> <operator>%</operator> <name>BLCKSZ</name> <operator>!=</operator> <literal type="number">0</literal><operator>)</operator></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot verify checksum in file \"%s\", block "</literal>
							<literal type="string">"%d: read buffer size %d and page size %d "</literal>
							<literal type="string">"differ"</literal></expr></argument>,
							<argument><expr><name>readfilename</name></expr></argument>, <argument><expr><name>blkno</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name>cnt</name></expr></argument>, <argument><expr><name>BLCKSZ</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>verify_checksum</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>verify_checksum</name></expr>)</condition>
		<block>{<block_content>
			<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>cnt</name> <operator>/</operator> <name>BLCKSZ</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
			<block>{<block_content>
				<expr_stmt><expr><name>page</name> <operator>=</operator> <name>buf</name> <operator>+</operator> <name>BLCKSZ</name> <operator>*</operator> <name>i</name></expr>;</expr_stmt>

				<comment type="block">/*
				 * Only check pages which have not been modified since the
				 * start of the base backup. Otherwise, they might have been
				 * written only halfway and the checksum would not be valid.
				 * However, replaying WAL would reinstate the correct page in
				 * this case. We also skip completely new pages, since they
				 * don't have a checksum yet.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>PageIsNew</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>PageGetLSN</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <name>startptr</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name>checksum</name> <operator>=</operator> <call><name>pg_checksum_page</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>page</name></expr></argument>, <argument><expr><name>blkno</name> <operator>+</operator> <name>segmentno</name> <operator>*</operator> <name>RELSEG_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>phdr</name> <operator>=</operator> <operator>(</operator><name>PageHeader</name><operator>)</operator> <name>page</name></expr>;</expr_stmt>
					<if_stmt><if>if <condition>(<expr><name><name>phdr</name><operator>-&gt;</operator><name>pd_checksum</name></name> <operator>!=</operator> <name>checksum</name></expr>)</condition>
					<block>{<block_content>
						<comment type="block">/*
						 * Retry the block on the first failure.  It's
						 * possible that we read the first 4K page of the
						 * block just before postgres updated the entire block
						 * so it ends up looking torn to us.  We only need to
						 * retry once because the LSN should be updated to
						 * something we can ignore on the next pass.  If the
						 * error happens again then it is a true validation
						 * failure.
						 */</comment>
						<if_stmt><if>if <condition>(<expr><name>block_retry</name> <operator>==</operator> <name>false</name></expr>)</condition>
						<block>{<block_content>
							<comment type="block">/* Reread the failed block */</comment>
							<if_stmt><if>if <condition>(<expr><call><name>polar_lseek</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><operator>-</operator><operator>(</operator><name>cnt</name> <operator>-</operator> <name>BLCKSZ</name> <operator>*</operator> <name>i</name><operator>)</operator></expr></argument>, <argument><expr><name>SEEK_CUR</name></expr></argument>)</argument_list></call> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>
							<block>{<block_content>
								<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
										<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
										 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not lseek in file \"%s\": %m"</literal></expr></argument>,
												<argument><expr><name>readfilename</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							</block_content>}</block></if></if_stmt>

							<if_stmt><if>if <condition>(<expr><call><name>polar_read</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name>buf</name> <operator>+</operator> <name>BLCKSZ</name> <operator>*</operator> <name>i</name></expr></argument>, <argument><expr><name>BLCKSZ</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>BLCKSZ</name></expr>)</condition>
							<block>{<block_content>
								<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
										<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
										 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not reread block %d of file \"%s\": %m"</literal></expr></argument>,
												<argument><expr><name>blkno</name></expr></argument>, <argument><expr><name>readfilename</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							</block_content>}</block></if></if_stmt>

							<if_stmt><if>if <condition>(<expr><call><name>polar_lseek</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name>cnt</name> <operator>-</operator> <name>BLCKSZ</name> <operator>*</operator> <name>i</name> <operator>-</operator> <name>BLCKSZ</name></expr></argument>, <argument><expr><name>SEEK_CUR</name></expr></argument>)</argument_list></call> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>
							<block>{<block_content>
								<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
										<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
										 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not fseek in file \"%s\": %m"</literal></expr></argument>,
												<argument><expr><name>readfilename</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							</block_content>}</block></if></if_stmt>

							<comment type="block">/* Set flag so we know a retry was attempted */</comment>
							<expr_stmt><expr><name>block_retry</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

							<comment type="block">/* Reset loop to validate the block again */</comment>
							<expr_stmt><expr><name>i</name><operator>--</operator></expr>;</expr_stmt>
							<continue>continue;</continue>
						</block_content>}</block></if></if_stmt>

						<expr_stmt><expr><name>checksum_failures</name><operator>++</operator></expr>;</expr_stmt>

						<if_stmt><if>if <condition>(<expr><name>checksum_failures</name> <operator>&lt;=</operator> <literal type="number">5</literal></expr>)</condition><block type="pseudo"><block_content>
							<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>,
									<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"checksum verification failed in "</literal>
											<literal type="string">"file \"%s\", block %d: calculated "</literal>
											<literal type="string">"%X but expected %X"</literal></expr></argument>,
											<argument><expr><name>readfilename</name></expr></argument>, <argument><expr><name>blkno</name></expr></argument>, <argument><expr><name>checksum</name></expr></argument>,
											<argument><expr><name><name>phdr</name><operator>-&gt;</operator><name>pd_checksum</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
						<if_stmt><if>if <condition>(<expr><name>checksum_failures</name> <operator>==</operator> <literal type="number">5</literal></expr>)</condition><block type="pseudo"><block_content>
							<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>,
									<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"further checksum verification "</literal>
											<literal type="string">"failures in file \"%s\" will not "</literal>
											<literal type="string">"be reported"</literal></expr></argument>, <argument><expr><name>readfilename</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
					</block_content>}</block></if></if_stmt>
				</block_content>}</block></if></if_stmt>
				<expr_stmt><expr><name>block_retry</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>blkno</name><operator>++</operator></expr>;</expr_stmt>
			</block_content>}</block></for>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* Send the chunk as a CopyData message */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>pq_putmessage</name><argument_list>(<argument><expr><literal type="char">'d'</literal></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>cnt</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"base backup could not send data, aborting backup"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>len</name> <operator>+=</operator> <name>cnt</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>throttle</name><argument_list>(<argument><expr><name>cnt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>len</name> <operator>&gt;=</operator> <name><name>statbuf</name><operator>-&gt;</operator><name>st_size</name></name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * Reached end of file. The file could be longer, if it was
			 * extended while we were sending it, but for a base backup we can
			 * ignore such extended data. It will be restored from WAL.
			 */</comment>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></while>

	<comment type="block">/* If the file was truncated while we were sending it, pad it with zeros */</comment>
	<if_stmt><if>if <condition>(<expr><name>len</name> <operator>&lt;</operator> <name><name>statbuf</name><operator>-&gt;</operator><name>st_size</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<while>while <condition>(<expr><name>len</name> <operator>&lt;</operator> <name><name>statbuf</name><operator>-&gt;</operator><name>st_size</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>cnt</name> <operator>=</operator> <call><name>Min</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name><name>statbuf</name><operator>-&gt;</operator><name>st_size</name></name> <operator>-</operator> <name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>pq_putmessage</name><argument_list>(<argument><expr><literal type="char">'d'</literal></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>cnt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>len</name> <operator>+=</operator> <name>cnt</name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>throttle</name><argument_list>(<argument><expr><name>cnt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></while>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Pad to 512 byte boundary, per tar format requirements. (This small
	 * piece of data is probably not worth throttling.)
	 */</comment>
	<expr_stmt><expr><name>pad</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>len</name> <operator>+</operator> <literal type="number">511</literal><operator>)</operator> <operator>&amp;</operator> <operator>~</operator><literal type="number">511</literal><operator>)</operator> <operator>-</operator> <name>len</name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>pad</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>pad</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pq_putmessage</name><argument_list>(<argument><expr><literal type="char">'d'</literal></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>pad</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>polar_close</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>checksum_failures</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"file \"%s\" has a total of %d checksum verification "</literal>
						<literal type="string">"failures"</literal></expr></argument>, <argument><expr><name>readfilename</name></expr></argument>, <argument><expr><name>checksum_failures</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name>total_checksum_failures</name> <operator>+=</operator> <name>checksum_failures</name></expr>;</expr_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int64</name></type>
<name>_tarWriteHeader</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>filename</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>linktarget</name></decl></parameter>,
				<parameter><decl><type><name><name>struct</name> <name>stat</name></name> <modifier>*</modifier></type><name>statbuf</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>sizeonly</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>h</name><index>[<expr><literal type="number">512</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>enum</name> <name>tarError</name></name></type> <name>rc</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>sizeonly</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>tarCreateHeader</name><argument_list>(<argument><expr><name>h</name></expr></argument>, <argument><expr><name>filename</name></expr></argument>, <argument><expr><name>linktarget</name></expr></argument>, <argument><expr><name><name>statbuf</name><operator>-&gt;</operator><name>st_size</name></name></expr></argument>,
							 <argument><expr><name><name>statbuf</name><operator>-&gt;</operator><name>st_mode</name></name></expr></argument>, <argument><expr><name><name>statbuf</name><operator>-&gt;</operator><name>st_uid</name></name></expr></argument>, <argument><expr><name><name>statbuf</name><operator>-&gt;</operator><name>st_gid</name></name></expr></argument>,
							 <argument><expr><name><name>statbuf</name><operator>-&gt;</operator><name>st_mtime</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<switch>switch <condition>(<expr><name>rc</name></expr>)</condition>
		<block>{<block_content>
			<case>case <expr><name>TAR_OK</name></expr>:</case>
				<break>break;</break>
			<case>case <expr><name>TAR_NAME_TOO_LONG</name></expr>:</case>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"file name too long for tar format: \"%s\""</literal></expr></argument>,
								<argument><expr><name>filename</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>TAR_SYMLINK_TOO_LONG</name></expr>:</case>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"symbolic link target too long for tar format: "</literal>
								<literal type="string">"file name \"%s\", target \"%s\""</literal></expr></argument>,
								<argument><expr><name>filename</name></expr></argument>, <argument><expr><name>linktarget</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<default>default:</default>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized tar error: %d"</literal></expr></argument>, <argument><expr><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></switch>

		<expr_stmt><expr><call><name>pq_putmessage</name><argument_list>(<argument><expr><literal type="char">'d'</literal></expr></argument>, <argument><expr><name>h</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>h</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><sizeof>sizeof<argument_list>(<argument><expr><name>h</name></expr></argument>)</argument_list></sizeof></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Write tar header for a directory.  If the entry in statbuf is a link then
 * write it as a directory anyway.
 */</comment>
<function><type><specifier>static</specifier> <name>int64</name></type>
<name>_tarWriteDir</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>pathbuf</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>basepathlen</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>stat</name></name> <modifier>*</modifier></type><name>statbuf</name></decl></parameter>,
			 <parameter><decl><type><name>bool</name></type> <name>sizeonly</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* If symlink, write it as a directory anyway */</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>WIN32</name></cpp:ifndef>
	<if_stmt><if>if <condition>(<expr><call><name>S_ISLNK</name><argument_list>(<argument><expr><name><name>statbuf</name><operator>-&gt;</operator><name>st_mode</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	<if_stmt><if>if <condition>(<expr><call><name>pgwin32_is_junction</name><argument_list>(<argument><expr><name>pathbuf</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
		<expr_stmt><expr><name><name>statbuf</name><operator>-&gt;</operator><name>st_mode</name></name> <operator>=</operator> <name>S_IFDIR</name> <operator>|</operator> <name>pg_dir_create_mode</name></expr>;</expr_stmt></block_content></block></if></if_stmt></block_content></block></if></if_stmt>

	<return>return <expr><call><name>_tarWriteHeader</name><argument_list>(<argument><expr><name>pathbuf</name> <operator>+</operator> <name>basepathlen</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>statbuf</name></expr></argument>, <argument><expr><name>sizeonly</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Increment the network transfer counter by the given number of bytes,
 * and sleep if necessary to comply with the requested network transfer
 * rate.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>throttle</name><parameter_list>(<parameter><decl><type><name>size_t</name></type> <name>increment</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TimeOffset</name></type>	<name>elapsed_min</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>throttling_counter</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>throttling_counter</name> <operator>+=</operator> <name>increment</name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>throttling_counter</name> <operator>&lt;</operator> <name>throttling_sample</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/* How much time should have elapsed at minimum? */</comment>
	<expr_stmt><expr><name>elapsed_min</name> <operator>=</operator> <name>elapsed_min_unit</name> <operator>*</operator>
		<operator>(</operator><name>throttling_counter</name> <operator>/</operator> <name>throttling_sample</name><operator>)</operator></expr>;</expr_stmt>

	<comment type="block">/*
	 * Since the latch could be set repeatedly because of concurrently WAL
	 * activity, sleep in a loop to ensure enough time has passed.
	 */</comment>
	<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>TimeOffset</name></type>	<name>elapsed</name></decl>,
					<decl><type ref="prev"/><name>sleep</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>wait_result</name></decl>;</decl_stmt>

		<comment type="block">/* Time elapsed since the last measurement (and possible wake up). */</comment>
		<expr_stmt><expr><name>elapsed</name> <operator>=</operator> <call><name>GetCurrentTimestamp</name><argument_list>()</argument_list></call> <operator>-</operator> <name>throttled_last</name></expr>;</expr_stmt>

		<comment type="block">/* sleep if the transfer is faster than it should be */</comment>
		<expr_stmt><expr><name>sleep</name> <operator>=</operator> <name>elapsed_min</name> <operator>-</operator> <name>elapsed</name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>sleep</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>ResetLatch</name><argument_list>(<argument><expr><name>MyLatch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* We're eating a potentially set latch, so check for interrupts */</comment>
		<expr_stmt><expr><call><name>CHECK_FOR_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * (TAR_SEND_SIZE / throttling_sample * elapsed_min_unit) should be
		 * the maximum time to sleep. Thus the cast to long is safe.
		 */</comment>
		<expr_stmt><expr><name>wait_result</name> <operator>=</operator> <call><name>WaitLatch</name><argument_list>(<argument><expr><name>MyLatch</name></expr></argument>,
								<argument><expr><name>WL_LATCH_SET</name> <operator>|</operator> <name>WL_TIMEOUT</name> <operator>|</operator> <name>WL_POSTMASTER_DEATH</name></expr></argument>,
								<argument><expr><operator>(</operator><name>long</name><operator>)</operator> <operator>(</operator><name>sleep</name> <operator>/</operator> <literal type="number">1000</literal><operator>)</operator></expr></argument>,
								<argument><expr><name>WAIT_EVENT_BASE_BACKUP_THROTTLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>wait_result</name> <operator>&amp;</operator> <name>WL_LATCH_SET</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>CHECK_FOR_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/* Done waiting? */</comment>
		<if_stmt><if>if <condition>(<expr><name>wait_result</name> <operator>&amp;</operator> <name>WL_TIMEOUT</name></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>
	</block_content>}</block></for>

	<comment type="block">/*
	 * As we work with integers, only whole multiple of throttling_sample was
	 * processed. The rest will be done during the next call of this function.
	 */</comment>
	<expr_stmt><expr><name>throttling_counter</name> <operator>%=</operator> <name>throttling_sample</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Time interval for the remaining amount and possible next increments
	 * starts now.
	 */</comment>
	<expr_stmt><expr><name>throttled_last</name> <operator>=</operator> <call><name>GetCurrentTimestamp</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
</unit>
