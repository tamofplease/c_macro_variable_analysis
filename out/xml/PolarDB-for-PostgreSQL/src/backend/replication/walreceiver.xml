<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/PolarDB-for-PostgreSQL/src/backend/replication/walreceiver.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * walreceiver.c
 *
 * The WAL receiver process (walreceiver) is new as of Postgres 9.0. It
 * is the process in the standby server that takes charge of receiving
 * XLOG records from a primary server during streaming replication.
 *
 * When the startup process determines that it's time to start streaming,
 * it instructs postmaster to start walreceiver. Walreceiver first connects
 * to the primary server (it will be served by a walsender process
 * in the primary server), and then keeps receiving XLOG records and
 * writing them to the disk as long as the connection is alive. As XLOG
 * records are received and flushed to disk, it updates the
 * WalRcv-&gt;receivedUpto variable in shared memory, to inform the startup
 * process of how far it can proceed with XLOG replay.
 *
 * If the primary server ends streaming, but doesn't disconnect, walreceiver
 * goes into "waiting" mode, and waits for the startup process to give new
 * instructions. The startup process will treat that the same as
 * disconnection, and will rescan the archive/pg_wal directory. But when the
 * startup process wants to try streaming replication again, it will just
 * nudge the existing walreceiver process that's waiting, instead of launching
 * a new one.
 *
 * Normal termination is by SIGTERM, which instructs the walreceiver to
 * exit(0). Emergency termination is by SIGQUIT; like any postmaster child
 * process, the walreceiver will simply abort and exit on SIGQUIT. A close
 * of the connection and a FATAL error are treated not as a crash but as
 * normal operation.
 *
 * This file contains the server-facing parts of walreceiver. The libpq-
 * specific parts are in the libpqwalreceiver module. It's loaded
 * dynamically to avoid linking the server with libpq.
 *
 * Portions Copyright (c) 2010-2018, PostgreSQL Global Development Group
 *
 *
 * IDENTIFICATION
 *	  src/backend/replication/walreceiver.c
 *
 *-------------------------------------------------------------------------
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;signal.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;unistd.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/htup_details.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/timeline.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/transam.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/xlog_internal.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_authid.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_type.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"common/ip.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"funcapi.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lib/ilist.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"libpq/pqformat.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"libpq/pqsignal.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pgstat.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postmaster/startup.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"replication/walreceiver.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"replication/walsender.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"replication/walsender_private.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/ipc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/pmsignal.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/procarray.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/builtins.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/guc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/pg_lsn.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/polar_coredump.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/ps_status.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/resowner.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/timestamp.h"</cpp:file></cpp:include>

<comment type="block">/* POLAR */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/polar_logindex_redo.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/polar_async_ddl_lock_replay.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"polar_datamax/polar_datamax.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/polar_fd.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/guc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"polar_dma/polar_dma.h"</cpp:file></cpp:include>

<comment type="block">/* GUC variables */</comment>
<decl_stmt><decl><type><name>int</name></type>			<name>wal_receiver_status_interval</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type>			<name>wal_receiver_timeout</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type>		<name>hot_standby_feedback</name></decl>;</decl_stmt>

<comment type="block">/*
 * POLAR: in polar standby, use polar_standby_feedback
 * to control hot_standby_feedback. It is set to false
 * by default, so polar standby disable the value of
 * hot_standby_feedback
 */</comment>
<decl_stmt><decl><type><name>bool</name></type>		<name>polar_standby_feedback</name></decl>;</decl_stmt>

<comment type="block">/* libpqwalreceiver connection */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>WalReceiverConn</name> <modifier>*</modifier></type><name>wrconn</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>WalReceiverFunctionsType</name> <modifier>*</modifier></type><name>WalReceiverFunctions</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NAPTIME_PER_CYCLE</name></cpp:macro> <cpp:value>100</cpp:value></cpp:define>	<comment type="block">/* max sleep time between cycles (100ms) */</comment>

<comment type="block">/* POLAR: timeout for send promote request to walsnd */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>POLAR_SEND_PROMOTE_REQUEST_TIMEOUT</name></cpp:macro>	<cpp:value>500</cpp:value></cpp:define>
<comment type="block">/* POLAR end */</comment>

<comment type="block">/*
 * These variables are used similarly to openLogFile/SegNo/Off,
 * but for walreceiver to write the XLOG. recvFileTLI is the TimeLineID
 * corresponding the filename of recvFile.
 */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type>	<name>recvFile</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>TimeLineID</name></type> <name>recvFileTLI</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>XLogSegNo</name></type> <name>recvSegNo</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>uint32</name></type> <name>recvOff</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<comment type="block">/* POLAR: local flag for datamax */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type> 	<name>polar_is_initial_datamax</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<comment type="block">/* list for primary's last valid lsn, used for keep xlog consistency between primary and datamax */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>polar_datamax_valid_lsn_list</name>	 <modifier>*</modifier></type><name>polar_datamax_received_valid_lsn_list</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<comment type="block">/* POLAR end */</comment>
<comment type="block">/*
 * Flags set by interrupt handlers of walreceiver for later service in the
 * main loop.
 */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>volatile</specifier> <name>sig_atomic_t</name></type> <name>got_SIGHUP</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>volatile</specifier> <name>sig_atomic_t</name></type> <name>got_SIGTERM</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

<comment type="block">/*
 * LogstreamResult indicates the byte positions that we have already
 * written/fsynced.
 */</comment>
<struct><specifier>static</specifier> struct
<block>{
	<decl_stmt><decl><type><name>XLogRecPtr</name></type>	<name>Write</name></decl>;</decl_stmt>			<comment type="block">/* last byte + 1 written out in the standby */</comment>
	<decl_stmt><decl><type><name>XLogRecPtr</name></type>	<name>Flush</name></decl>;</decl_stmt>			<comment type="block">/* last byte + 1 flushed in the standby */</comment>
}</block>			<decl><name>LogstreamResult</name></decl>;</struct>

<decl_stmt><decl><type><specifier>static</specifier> <name>StringInfoData</name></type> <name>reply_message</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>StringInfoData</name></type> <name>incoming_message</name></decl>;</decl_stmt>

<comment type="block">/* Prototypes for private functions */</comment>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>WalRcvFetchTimeLineHistoryFiles</name><parameter_list>(<parameter><decl><type><name>TimeLineID</name></type> <name>first</name></decl></parameter>, <parameter><decl><type><name>TimeLineID</name></type> <name>last</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>WalRcvWaitForStartPosition</name><parameter_list>(<parameter><decl><type><name>XLogRecPtr</name> <modifier>*</modifier></type><name>startpoint</name></decl></parameter>, <parameter><decl><type><name>TimeLineID</name> <modifier>*</modifier></type><name>startpointTLI</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>WalRcvDie</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>code</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>arg</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>XLogWalRcvProcessMsg</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>char</name></type> <name>type</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><name>Size</name></type> <name>len</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>XLogWalRcvWrite</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><name>Size</name></type> <name>nbytes</name></decl></parameter>, <parameter><decl><type><name>XLogRecPtr</name></type> <name>recptr</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>XLogWalRcvFlush</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>dying</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>XLogWalRcvSendReply</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>force</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>requestReply</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>XLogWalRcvSendHSFeedback</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>immed</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ProcessWalSndrMessage</name><parameter_list>(<parameter><decl><type><name>XLogRecPtr</name></type> <name>walEnd</name></decl></parameter>, <parameter><decl><type><name>TimestampTz</name></type> <name>sendTime</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/* Signal handlers */</comment>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>WalRcvSigHupHandler</name><parameter_list>(<parameter><decl><type><name>SIGNAL_ARGS</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>WalRcvSigUsr1Handler</name><parameter_list>(<parameter><decl><type><name>SIGNAL_ARGS</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>WalRcvShutdownHandler</name><parameter_list>(<parameter><decl><type><name>SIGNAL_ARGS</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>WalRcvQuickDieHandler</name><parameter_list>(<parameter><decl><type><name>SIGNAL_ARGS</name></type></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/* POLAR: callback function when waiting free space from polar_xlog_queue */</comment>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>polar_receiver_xlog_queue_callback</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>polar_notify_read_wal_file</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>code</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>arg</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/*
 * Process any interrupts the walreceiver process may have received.
 * This should be called any time the process's latch has become set.
 *
 * Currently, only SIGTERM is of interest.  We can't just exit(1) within the
 * SIGTERM signal handler, because the signal might arrive in the middle of
 * some critical operation, like while we're holding a spinlock.  Instead, the
 * signal handler sets a flag variable as well as setting the process's latch.
 * We must check the flag (by calling ProcessWalRcvInterrupts) anytime the
 * latch has become set.  Operations that could block for a long time, such as
 * reading from a remote server, must pay attention to the latch too; see
 * libpqrcv_PQgetResult for example.
 */</comment>
<function><type><name>void</name></type>
<name>ProcessWalRcvInterrupts</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * Although walreceiver interrupt handling doesn't use the same scheme as
	 * regular backends, call CHECK_FOR_INTERRUPTS() to make sure we receive
	 * any incoming signals on Win32.
	 */</comment>
	<expr_stmt><expr><call><name>CHECK_FOR_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>got_SIGTERM</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_ADMIN_SHUTDOWN</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"terminating walreceiver process due to administrator command"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>


<comment type="block">/* Main entry point for walreceiver process */</comment>
<function><type><name>void</name></type>
<name>WalReceiverMain</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>conninfo</name><index>[<expr><name>MAXCONNINFO</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>tmp_conninfo</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>slotname</name><index>[<expr><name>NAMEDATALEN</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>XLogRecPtr</name></type>	<name>startpoint</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TimeLineID</name></type>	<name>startpointTLI</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TimeLineID</name></type>	<name>primaryTLI</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>first_stream</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>WalRcvData</name> <modifier>*</modifier></type><name>walrcv</name> <init>= <expr><name>WalRcv</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TimestampTz</name></type> <name>last_recv_timestamp</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TimestampTz</name></type> <name>now</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>ping_sent</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>err</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>sender_host</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>sender_port</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * WalRcv should be set up already (if we are a backend, we inherit this
	 * by fork() or EXEC_BACKEND mechanism from the postmaster).
	 */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>walrcv</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>now</name> <operator>=</operator> <call><name>GetCurrentTimestamp</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Mark walreceiver as running in shared memory.
	 *
	 * Do this as early as possible, so that if we fail later on, we'll set
	 * state to STOPPED. If we die before this, the startup process will keep
	 * waiting for us to start up, until it times out.
	 */</comment>
	<expr_stmt><expr><call><name>SpinLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>walrcv</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>walrcv</name><operator>-&gt;</operator><name>pid</name></name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<switch>switch <condition>(<expr><name><name>walrcv</name><operator>-&gt;</operator><name>walRcvState</name></name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>WALRCV_STOPPING</name></expr>:</case>
			<comment type="block">/* If we've already been requested to stop, don't start up. */</comment>
			<expr_stmt><expr><name><name>walrcv</name><operator>-&gt;</operator><name>walRcvState</name></name> <operator>=</operator> <name>WALRCV_STOPPED</name></expr>;</expr_stmt>
			<comment type="block">/* fall through */</comment>

		<case>case <expr><name>WALRCV_STOPPED</name></expr>:</case>
			<expr_stmt><expr><call><name>SpinLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>walrcv</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>proc_exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>WALRCV_STARTING</name></expr>:</case>
			<comment type="block">/* The usual case */</comment>
			<break>break;</break>

		<case>case <expr><name>WALRCV_WAITING</name></expr>:</case>
		<case>case <expr><name>WALRCV_STREAMING</name></expr>:</case>
		<case>case <expr><name>WALRCV_RESTARTING</name></expr>:</case>
		<default>default:</default>
			<comment type="block">/* Shouldn't happen */</comment>
			<expr_stmt><expr><call><name>SpinLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>walrcv</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>PANIC</name></expr></argument>, <argument><expr><literal type="string">"walreceiver still running according to shared memory state"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></switch>
	<comment type="block">/* Advertise our PID so that the startup process can kill us */</comment>
	<expr_stmt><expr><name><name>walrcv</name><operator>-&gt;</operator><name>pid</name></name> <operator>=</operator> <name>MyProcPid</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>walrcv</name><operator>-&gt;</operator><name>walRcvState</name></name> <operator>=</operator> <name>WALRCV_STREAMING</name></expr>;</expr_stmt>

	<comment type="block">/* Fetch information required to start streaming */</comment>
	<expr_stmt><expr><name><name>walrcv</name><operator>-&gt;</operator><name>ready_to_display</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>strlcpy</name><argument_list>(<argument><expr><name>conninfo</name></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name><name>walrcv</name><operator>-&gt;</operator><name>conninfo</name></name></expr></argument>, <argument><expr><name>MAXCONNINFO</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>strlcpy</name><argument_list>(<argument><expr><name>slotname</name></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name><name>walrcv</name><operator>-&gt;</operator><name>slotname</name></name></expr></argument>, <argument><expr><name>NAMEDATALEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>startpoint</name> <operator>=</operator> <name><name>walrcv</name><operator>-&gt;</operator><name>receiveStart</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>startpointTLI</name> <operator>=</operator> <name><name>walrcv</name><operator>-&gt;</operator><name>receiveStartTLI</name></name></expr>;</expr_stmt>

	<comment type="block">/* Initialise to a sanish value */</comment>
	<expr_stmt><expr><name><name>walrcv</name><operator>-&gt;</operator><name>lastMsgSendTime</name></name> <operator>=</operator>
		<name><name>walrcv</name><operator>-&gt;</operator><name>lastMsgReceiptTime</name></name> <operator>=</operator> <name><name>walrcv</name><operator>-&gt;</operator><name>latestWalEndTime</name></name> <operator>=</operator> <name>now</name></expr>;</expr_stmt>

	<comment type="block">/* Report the latch to use to awaken this process */</comment>
	<expr_stmt><expr><name><name>walrcv</name><operator>-&gt;</operator><name>latch</name></name> <operator>=</operator> <operator>&amp;</operator><name><name>MyProc</name><operator>-&gt;</operator><name>procLatch</name></name></expr>;</expr_stmt>

	<comment type="block">/* POLAR: Reset consistent lsn received from primary node while starting up walreceiver. */</comment>
	<expr_stmt><expr><name><name>WalRcv</name><operator>-&gt;</operator><name>curr_primary_consistent_lsn</name></name> <operator>=</operator> <name>InvalidXLogRecPtr</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>SpinLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>walrcv</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* POLAR:notify startup to read wal file instead of logindex queue */</comment>
	<expr_stmt><expr><call><name>before_shmem_exit</name><argument_list>(<argument><expr><name>polar_notify_read_wal_file</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* POLAR: free memory of datamax_valid_lsn_list */</comment>
	<expr_stmt><expr><call><name>before_shmem_exit</name><argument_list>(<argument><expr><name>polar_datamax_free_valid_lsn_list</name></expr></argument>, <argument><expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>polar_datamax_received_valid_lsn_list</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Arrange to clean up at walreceiver exit */</comment>
	<expr_stmt><expr><call><name>on_shmem_exit</name><argument_list>(<argument><expr><name>WalRcvDie</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Properly accept or ignore signals the postmaster might send us */</comment>
	<expr_stmt><expr><call><name>pqsignal</name><argument_list>(<argument><expr><name>SIGHUP</name></expr></argument>, <argument><expr><name>WalRcvSigHupHandler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>	<comment type="block">/* set flag to read config file */</comment>
	<expr_stmt><expr><call><name>pqsignal</name><argument_list>(<argument><expr><name>SIGINT</name></expr></argument>, <argument><expr><name>SIG_IGN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pqsignal</name><argument_list>(<argument><expr><name>SIGTERM</name></expr></argument>, <argument><expr><name>WalRcvShutdownHandler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>	<comment type="block">/* request shutdown */</comment>
	<expr_stmt><expr><call><name>pqsignal</name><argument_list>(<argument><expr><name>SIGQUIT</name></expr></argument>, <argument><expr><name>WalRcvQuickDieHandler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>	<comment type="block">/* hard crash time */</comment>
	<expr_stmt><expr><call><name>pqsignal</name><argument_list>(<argument><expr><name>SIGALRM</name></expr></argument>, <argument><expr><name>SIG_IGN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pqsignal</name><argument_list>(<argument><expr><name>SIGPIPE</name></expr></argument>, <argument><expr><name>SIG_IGN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pqsignal</name><argument_list>(<argument><expr><name>SIGUSR1</name></expr></argument>, <argument><expr><name>WalRcvSigUsr1Handler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pqsignal</name><argument_list>(<argument><expr><name>SIGUSR2</name></expr></argument>, <argument><expr><name>SIG_IGN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Reset some signals that are accepted by postmaster but not here */</comment>
	<expr_stmt><expr><call><name>pqsignal</name><argument_list>(<argument><expr><name>SIGCHLD</name></expr></argument>, <argument><expr><name>SIG_DFL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pqsignal</name><argument_list>(<argument><expr><name>SIGTTIN</name></expr></argument>, <argument><expr><name>SIG_DFL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pqsignal</name><argument_list>(<argument><expr><name>SIGTTOU</name></expr></argument>, <argument><expr><name>SIG_DFL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pqsignal</name><argument_list>(<argument><expr><name>SIGCONT</name></expr></argument>, <argument><expr><name>SIG_DFL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pqsignal</name><argument_list>(<argument><expr><name>SIGWINCH</name></expr></argument>, <argument><expr><name>SIG_DFL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* POLAR : register for coredump print */</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>_WIN32</name></cpp:ifndef>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SIGILL</name></cpp:ifdef>
	<expr_stmt><expr><call><name>pqsignal</name><argument_list>(<argument><expr><name>SIGILL</name></expr></argument>, <argument><expr><name>polar_program_error_handler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SIGSEGV</name></cpp:ifdef>
	<expr_stmt><expr><call><name>pqsignal</name><argument_list>(<argument><expr><name>SIGSEGV</name></expr></argument>, <argument><expr><name>polar_program_error_handler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SIGBUS</name></cpp:ifdef>
	<expr_stmt><expr><call><name>pqsignal</name><argument_list>(<argument><expr><name>SIGBUS</name></expr></argument>, <argument><expr><name>polar_program_error_handler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>	<comment type="block">/* _WIN32 */</comment>
	<comment type="block">/* POLAR: end */</comment>

	<comment type="block">/* We allow SIGQUIT (quickdie) at all times */</comment>
	<expr_stmt><expr><call><name>sigdelset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>BlockSig</name></expr></argument>, <argument><expr><name>SIGQUIT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Load the libpq-specific functions */</comment>
	<expr_stmt><expr><call><name>load_file</name><argument_list>(<argument><expr><literal type="string">"libpqwalreceiver"</literal></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>WalReceiverFunctions</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"libpqwalreceiver didn't initialize correctly"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Create a resource owner to keep track of our resources (not clear that
	 * we need this, but may as well have one).
	 */</comment>
	<expr_stmt><expr><name>CurrentResourceOwner</name> <operator>=</operator> <call><name>ResourceOwnerCreate</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="string">"Wal Receiver"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Unblock signals (they were blocked when the postmaster forked us) */</comment>
	<expr_stmt><expr><call><name>PG_SETMASK</name><argument_list>(<argument><expr><operator>&amp;</operator><name>UnBlockSig</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Establish the connection to the primary for XLOG streaming */</comment>
	<expr_stmt><expr><name>wrconn</name> <operator>=</operator> <call><name>walrcv_connect</name><argument_list>(<argument><expr><name>conninfo</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><literal type="string">"walreceiver"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>wrconn</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not connect to the primary server: %s"</literal></expr></argument>, <argument><expr><name>err</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Save user-visible connection string.  This clobbers the original
	 * conninfo, for security. Also save host and port of the sender server
	 * this walreceiver is connected to.
	 */</comment>
	<expr_stmt><expr><name>tmp_conninfo</name> <operator>=</operator> <call><name>walrcv_get_conninfo</name><argument_list>(<argument><expr><name>wrconn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>walrcv_get_senderinfo</name><argument_list>(<argument><expr><name>wrconn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sender_host</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sender_port</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SpinLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>walrcv</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name><name>walrcv</name><operator>-&gt;</operator><name>conninfo</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>MAXCONNINFO</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>tmp_conninfo</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>strlcpy</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name><name>walrcv</name><operator>-&gt;</operator><name>conninfo</name></name></expr></argument>, <argument><expr><name>tmp_conninfo</name></expr></argument>, <argument><expr><name>MAXCONNINFO</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name><name>walrcv</name><operator>-&gt;</operator><name>sender_host</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NI_MAXHOST</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>sender_host</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>strlcpy</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name><name>walrcv</name><operator>-&gt;</operator><name>sender_host</name></name></expr></argument>, <argument><expr><name>sender_host</name></expr></argument>, <argument><expr><name>NI_MAXHOST</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name><name>walrcv</name><operator>-&gt;</operator><name>sender_port</name></name> <operator>=</operator> <name>sender_port</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>walrcv</name><operator>-&gt;</operator><name>ready_to_display</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SpinLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>walrcv</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>tmp_conninfo</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>tmp_conninfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>sender_host</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>sender_host</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>first_stream</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<comment type="block">/* POLAR: create and init list for recording primary's valid lsn in datamax mode */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>polar_is_datamax</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>POLAR_ENABLE_DMA</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>polar_datamax_received_valid_lsn_list</name> <operator>=</operator> <call><name>polar_datamax_create_valid_lsn_list</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>primary_sysid</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name></type>		<name><name>standby_sysid</name><index>[<expr><literal type="number">32</literal></expr>]</index></name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>server_version</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>WalRcvStreamOptions</name></type> <name>options</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>polar_replica</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

		<comment type="block">/* POLAR: enable replica stream replication */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>polar_in_replica_mode</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>polar_replica</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/* POLAR: force log */</comment>
		<if_stmt><if>if <condition>(<expr><name>polar_replica</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Start wal receiver on polardb"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * Check that we're connected to a valid server using the
		 * IDENTIFY_SYSTEM replication command.
		 */</comment>
		<expr_stmt><expr><name>primary_sysid</name> <operator>=</operator> <call><name>walrcv_identify_system</name><argument_list>(<argument><expr><name>wrconn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>primaryTLI</name></expr></argument>,
											   <argument><expr><operator>&amp;</operator><name>server_version</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>standby_sysid</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>standby_sysid</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>UINT64_FORMAT</name></expr></argument>,
				 <argument><expr><call><name>GetSystemIdentifier</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>primary_sysid</name></expr></argument>, <argument><expr><name>standby_sysid</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"database system identifier differs between the primary and standby"</literal></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"The primary's identifier is %s, the standby's identifier is %s."</literal></expr></argument>,
							   <argument><expr><name>primary_sysid</name></expr></argument>, <argument><expr><name>standby_sysid</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* POLAR: Update DataMax timeline if current is a initial one. */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>polar_is_datamax</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> 
				<operator>(</operator><operator>(</operator><operator>!</operator><call><name>POLAR_ENABLE_DMA</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <call><name>polar_datamax_is_initial</name><argument_list>(<argument><expr><name>polar_datamax_ctl</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>||</operator>
				 <operator>(</operator><call><name>POLAR_ENABLE_DMA</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <name>startpointTLI</name> <operator>==</operator> <name>POLAR_INVALID_TIMELINE_ID</name><operator>)</operator><operator>)</operator></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>startpointTLI</name> <operator>==</operator> <name>POLAR_INVALID_TIMELINE_ID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name>polar_is_initial_datamax</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name>startpointTLI</name> <operator>==</operator> <name>POLAR_INVALID_TIMELINE_ID</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* 
				 * POLAR: If we are in DataMax mode and requested timeline is invalid,
				 * it means that we are a initial one, so we need to fetch as much as 
				 * possible  WAL from Primary's current timeline, so update walreceiver's 
				 * receiveStartTLI with primary's current one.  
				 */</comment>
				<expr_stmt><expr><call><name>SpinLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>walrcv</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>walrcv</name><operator>-&gt;</operator><name>receiveStartTLI</name></name> <operator>=</operator> <name>startpointTLI</name> <operator>=</operator> <name>primaryTLI</name></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>SpinLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>walrcv</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"initial DataMax node update requested streaming timeline with primary's current one %d"</literal></expr></argument>, 
						<argument><expr><name>primaryTLI</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"initial datamax requested with certain timeline id: %d"</literal></expr></argument>, <argument><expr><name>startpointTLI</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
		</block_content>}</block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>polar_is_initial_datamax</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
		<comment type="block">/* POLAR end */</comment>

		<comment type="block">/*
		 * Confirm that the current timeline of the primary is the same or
		 * ahead of ours.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>primaryTLI</name> <operator>&lt;</operator> <name>startpointTLI</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"highest timeline %u of the primary is behind recovery timeline %u"</literal></expr></argument>,
							<argument><expr><name>primaryTLI</name></expr></argument>, <argument><expr><name>startpointTLI</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * Get any missing history files. We do this always, even when we're
		 * not interested in that timeline, so that if we're promoted to
		 * become the master later on, we don't select the same timeline that
		 * was already used in the current master. This isn't bullet-proof -
		 * you'll need some external software to manage your cluster if you
		 * need to ensure that a unique timeline id is chosen in every case,
		 * but let's avoid the confusion of timeline id collisions where we
		 * can.
		 */</comment>
		<expr_stmt><expr><call><name>WalRcvFetchTimeLineHistoryFiles</name><argument_list>(<argument><expr><name>startpointTLI</name></expr></argument>, <argument><expr><name>primaryTLI</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Start streaming.
		 *
		 * We'll try to start at the requested starting point and timeline,
		 * even if it's different from the server's latest timeline. In case
		 * we've already reached the end of the old timeline, the server will
		 * finish the streaming immediately, and we will go back to await
		 * orders from the startup process. If recovery_target_timeline is
		 * 'latest', the startup process will scan pg_wal and find the new
		 * history file, bump recovery target timeline, and ask us to restart
		 * on the new timeline.
		 */</comment>
		<expr_stmt><expr><name><name>options</name><operator>.</operator><name>logical</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>options</name><operator>.</operator><name>startpoint</name></name> <operator>=</operator> <name>startpoint</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>options</name><operator>.</operator><name>slotname</name></name> <operator>=</operator> <ternary><condition><expr><name><name>slotname</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'\0'</literal></expr> ?</condition><then> <expr><name>slotname</name></expr> </then><else>: <expr><name>NULL</name></expr></else></ternary></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>options</name><operator>.</operator><name>proto</name><operator>.</operator><name>physical</name><operator>.</operator><name>startpointTLI</name></name> <operator>=</operator> <name>startpointTLI</name></expr>;</expr_stmt>
		<comment type="block">/* POLAR: Set current replication mode */</comment>
		<expr_stmt><expr><name><name>options</name><operator>.</operator><name>polar_repl_mode</name></name> <operator>=</operator> <call><name>polar_gen_replication_mode</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* POLAR end */</comment>
		<expr_stmt><expr><name>ThisTimeLineID</name> <operator>=</operator> <name>startpointTLI</name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>walrcv_startstreaming</name><argument_list>(<argument><expr><name>wrconn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>options</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>first_stream</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/*
				 * POLAR: If logindex meta start lsn is invalid ,standby reach consistency and start to create streaming,
				 * we will set valid information to enable logindex parse.
				 * For rw node this will be set after parsed all xlog in startup process
				 * For ro node, logindex snapshot is readonly, so there is no need to set valid information
				 * For datamax node, logindex won't be enabled
				 */</comment>
				<if_stmt><if>if <condition>(<expr><name>polar_logindex_redo_instance</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>polar_logindex_redo_set_valid_info</name><argument_list>(<argument><expr><name>polar_logindex_redo_instance</name></expr></argument>, <argument><expr><call><name>GetXLogReplayRecPtr</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"started streaming WAL from primary at %X/%X on timeline %u"</literal></expr></argument>,
								<argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <operator>(</operator><name>startpoint</name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr></argument>, <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <name>startpoint</name></expr></argument>,
								<argument><expr><name>startpointTLI</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"restarted WAL streaming at %X/%X on timeline %u"</literal></expr></argument>,
								<argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <operator>(</operator><name>startpoint</name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr></argument>, <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <name>startpoint</name></expr></argument>,
								<argument><expr><name>startpointTLI</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
			<expr_stmt><expr><name>first_stream</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<comment type="block">/* Initialize LogstreamResult and buffers for processing messages */</comment>
			<comment type="block">/* 
			 * POLAR: Initialize LogstreamResult as last valid received lsn when in datamax mode
			 * otherwise, when datamax_replay_lsn &gt; received_lsn and we set flush_lsn = datamax_replay_lsn
			 * the wal received won't be flushed to disk because flush_lsn &gt; received_lsn(which is write lsn) in this case
			 */</comment>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>polar_is_datamax</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>LogstreamResult</name><operator>.</operator><name>Write</name></name> <operator>=</operator> <name><name>LogstreamResult</name><operator>.</operator><name>Flush</name></name> <operator>=</operator> <call><name>GetXLogReplayRecPtr</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<if type="elseif">else if <condition>(<expr><call><name>POLAR_ENABLE_DMA</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>LogstreamResult</name><operator>.</operator><name>Write</name></name> <operator>=</operator> <name><name>LogstreamResult</name><operator>.</operator><name>Flush</name></name> <operator>=</operator> <call><name>polar_dma_get_received_lsn</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>LogstreamResult</name><operator>.</operator><name>Write</name></name> <operator>=</operator> <name><name>LogstreamResult</name><operator>.</operator><name>Flush</name></name> <operator>=</operator> <call><name>polar_datamax_get_last_valid_received_lsn</name><argument_list>(<argument><expr><name>polar_datamax_ctl</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
			<comment type="block">/* POLAR end */</comment>
			<expr_stmt><expr><call><name>initStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>reply_message</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>initStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>incoming_message</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* Initialize the last recv timestamp */</comment>
			<expr_stmt><expr><name>last_recv_timestamp</name> <operator>=</operator> <call><name>GetCurrentTimestamp</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>ping_sent</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

			<comment type="block">/* Loop until end-of-streaming or error */</comment>
			<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
			<block>{<block_content>
				<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>buf</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>int</name></type>			<name>len</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>bool</name></type>		<name>endofwal</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>pgsocket</name></type>	<name>wait_fd</name> <init>= <expr><name>PGINVALID_SOCKET</name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>int</name></type>			<name>rc</name></decl>;</decl_stmt>

				<comment type="block">/*
				 * Exit walreceiver if we're not in recovery. This should not
				 * happen, but cross-check the status here.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>RecoveryInProgress</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot continue WAL streaming, recovery has already ended"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

				<comment type="block">/* Process any requests or signals received recently */</comment>
				<expr_stmt><expr><call><name>ProcessWalRcvInterrupts</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

				<if_stmt><if>if <condition>(<expr><name>got_SIGHUP</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name>got_SIGHUP</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>ProcessConfigFile</name><argument_list>(<argument><expr><name>PGC_SIGHUP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>XLogWalRcvSendHSFeedback</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>

				<comment type="block">/* See if we can read data immediately */</comment>
				<expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>walrcv_receive</name><argument_list>(<argument><expr><name>wrconn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>wait_fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name>len</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/*
					 * Process the received data, and any subsequent data we
					 * can read without blocking.
					 */</comment>
					<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
					<block>{<block_content>
						<if_stmt><if>if <condition>(<expr><name>len</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
						<block>{<block_content>
							<comment type="block">/*
							 * Something was received from master, so reset
							 * timeout
							 */</comment>
							<expr_stmt><expr><name>last_recv_timestamp</name> <operator>=</operator> <call><name>GetCurrentTimestamp</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
							<expr_stmt><expr><name>ping_sent</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
							<expr_stmt><expr><call><name>XLogWalRcvProcessMsg</name><argument_list>(<argument><expr><name><name>buf</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>buf</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name>len</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						</block_content>}</block></if>
						<if type="elseif">else if <condition>(<expr><name>len</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
							<break>break;</break></block_content></block></if>
						<if type="elseif">else if <condition>(<expr><name>len</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
						<block>{<block_content>
							<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
									<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"replication terminated by primary server"</literal></expr></argument>)</argument_list></call><operator>,</operator>
									 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"End of WAL reached on timeline %u at %X/%X."</literal></expr></argument>,
											   <argument><expr><name>startpointTLI</name></expr></argument>,
											   <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <operator>(</operator><name><name>LogstreamResult</name><operator>.</operator><name>Write</name></name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr></argument>, <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <name><name>LogstreamResult</name><operator>.</operator><name>Write</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							<expr_stmt><expr><name>endofwal</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
							<break>break;</break>
						</block_content>}</block></if></if_stmt>

						<comment type="block">/* POLAR: ask walsender whether promote can be executed */</comment>
						<if_stmt><if>if <condition>(<expr><call><name>polar_send_promote_request</name><argument_list>()</argument_list></call></expr>)</condition>
						<block>{<block_content>
							<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,<argument><expr><literal type="string">"ask walsender for whether promote can be executed"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							<expr_stmt><expr><call><name>polar_walrcv_send_promote</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						</block_content>}</block></if></if_stmt>
						<comment type="block">/* POLAR end */</comment>

						<comment type="block">/* Let the master know that we received some data. 
						 *
						 * POLAR: When standby is much slower than primary server,
						 * walreceiver process will be trapped in this loop so that it
						 * can not keep alive with walsender. If walsender can't get
						 * reply message after wal_sender_timeout, it will terminate
						 * replication. In order to avoid this issue, we force to send
						 * reply message after wal_receiver_status_interval seconds.
						 */</comment>
						<expr_stmt><expr><call><name>XLogWalRcvSendReply</name><argument_list>(<argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

						<expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>walrcv_receive</name><argument_list>(<argument><expr><name>wrconn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>wait_fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block></for>

					<comment type="block">/*
					 * If we've written some records, flush them to disk and
					 * let the startup process and primary server know about
					 * them.
					 */</comment>
					<expr_stmt><expr><call><name>XLogWalRcvFlush</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>

				<comment type="block">/* 
				 * POLAR: ask walsender whether promote can be executed 
				 * when receive nothing from primary, and we haven't send this info before, send it now
				 */</comment>
				<if_stmt><if>if <condition>(<expr><call><name>polar_send_promote_request</name><argument_list>()</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,<argument><expr><literal type="string">"ask walsender for whether promote can be executed"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>polar_walrcv_send_promote</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>

				<comment type="block">/* POLAR: check whether all wal have been received, if so, promote is allowed */</comment>
				<expr_stmt><expr><call><name>polar_promote_check_received_all_wal</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<comment type="block">/* POLAR end */</comment>

				<comment type="block">/* Check if we need to exit the streaming loop. */</comment>
				<if_stmt><if>if <condition>(<expr><name>endofwal</name></expr>)</condition><block type="pseudo"><block_content>
					<break>break;</break></block_content></block></if></if_stmt>

				<comment type="block">/*
				 * Ideally we would reuse a WaitEventSet object repeatedly
				 * here to avoid the overheads of WaitLatchOrSocket on epoll
				 * systems, but we can't be sure that libpq (or any other
				 * walreceiver implementation) has the same socket (even if
				 * the fd is the same number, it may have been closed and
				 * reopened since the last time).  In future, if there is a
				 * function for removing sockets from WaitEventSet, then we
				 * could add and remove just the socket each time, potentially
				 * avoiding some system calls.
				 */</comment>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>wait_fd</name> <operator>!=</operator> <name>PGINVALID_SOCKET</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>WaitLatchOrSocket</name><argument_list>(<argument><expr><name><name>walrcv</name><operator>-&gt;</operator><name>latch</name></name></expr></argument>,
									   <argument><expr><name>WL_POSTMASTER_DEATH</name> <operator>|</operator> <name>WL_SOCKET_READABLE</name> <operator>|</operator>
									   <name>WL_TIMEOUT</name> <operator>|</operator> <name>WL_LATCH_SET</name></expr></argument>,
									   <argument><expr><name>wait_fd</name></expr></argument>,
									   <argument><expr><name>NAPTIME_PER_CYCLE</name></expr></argument>,
									   <argument><expr><name>WAIT_EVENT_WAL_RECEIVER_MAIN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name>rc</name> <operator>&amp;</operator> <name>WL_LATCH_SET</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>ResetLatch</name><argument_list>(<argument><expr><name><name>walrcv</name><operator>-&gt;</operator><name>latch</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>ProcessWalRcvInterrupts</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

					<if_stmt><if>if <condition>(<expr><name><name>walrcv</name><operator>-&gt;</operator><name>force_reply</name></name></expr>)</condition>
					<block>{<block_content>
						<comment type="block">/*
						 * The recovery process has asked us to send apply
						 * feedback now.  Make sure the flag is really set to
						 * false in shared memory before sending the reply, so
						 * we don't miss a new request for a reply.
						 */</comment>
						<expr_stmt><expr><name><name>walrcv</name><operator>-&gt;</operator><name>force_reply</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
						<expr_stmt><expr><call><name>pg_memory_barrier</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><call><name>XLogWalRcvSendReply</name><argument_list>(<argument><expr><name>true</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block></if></if_stmt>
				</block_content>}</block></if></if_stmt>
				<if_stmt><if>if <condition>(<expr><name>rc</name> <operator>&amp;</operator> <name>WL_POSTMASTER_DEATH</name></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/*
					 * Emergency bailout if postmaster has died.  This is to
					 * avoid the necessity for manual cleanup of all
					 * postmaster children.
					 */</comment>
					<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
				<if_stmt><if>if <condition>(<expr><name>rc</name> <operator>&amp;</operator> <name>WL_TIMEOUT</name></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/*
					 * We didn't receive anything new. If we haven't heard
					 * anything from the server for more than
					 * wal_receiver_timeout / 2, ping the server. Also, if
					 * it's been longer than wal_receiver_status_interval
					 * since the last update we sent, send a status update to
					 * the master anyway, to report any progress in applying
					 * WAL.
					 */</comment>
					<decl_stmt><decl><type><name>bool</name></type>		<name>requestReply</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

					<comment type="block">/*
					 * Check if time since last receive from standby has
					 * reached the configured limit.
					 */</comment>
					<if_stmt><if>if <condition>(<expr><name>wal_receiver_timeout</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
					<block>{<block_content>
						<decl_stmt><decl><type><name>TimestampTz</name></type> <name>now</name> <init>= <expr><call><name>GetCurrentTimestamp</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
						<decl_stmt><decl><type><name>TimestampTz</name></type> <name>timeout</name></decl>;</decl_stmt>

						<expr_stmt><expr><name>timeout</name> <operator>=</operator>
							<call><name>TimestampTzPlusMilliseconds</name><argument_list>(<argument><expr><name>last_recv_timestamp</name></expr></argument>,
														<argument><expr><name>wal_receiver_timeout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

						<if_stmt><if>if <condition>(<expr><name>now</name> <operator>&gt;=</operator> <name>timeout</name></expr>)</condition><block type="pseudo"><block_content>
							<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
									<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"terminating walreceiver due to timeout"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

						<comment type="block">/*
						 * We didn't receive anything new, for half of
						 * receiver replication timeout. Ping the server.
						 */</comment>
						<if_stmt><if>if <condition>(<expr><operator>!</operator><name>ping_sent</name></expr>)</condition>
						<block>{<block_content>
							<expr_stmt><expr><name>timeout</name> <operator>=</operator> <call><name>TimestampTzPlusMilliseconds</name><argument_list>(<argument><expr><name>last_recv_timestamp</name></expr></argument>,
																  <argument><expr><operator>(</operator><name>wal_receiver_timeout</name> <operator>/</operator> <literal type="number">2</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							<if_stmt><if>if <condition>(<expr><name>now</name> <operator>&gt;=</operator> <name>timeout</name></expr>)</condition>
							<block>{<block_content>
								<expr_stmt><expr><name>requestReply</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
								<expr_stmt><expr><name>ping_sent</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
							</block_content>}</block></if></if_stmt>
						</block_content>}</block></if></if_stmt>
					</block_content>}</block></if></if_stmt>

					<expr_stmt><expr><call><name>XLogWalRcvSendReply</name><argument_list>(<argument><expr><name>requestReply</name></expr></argument>, <argument><expr><name>requestReply</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>XLogWalRcvSendHSFeedback</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></for>

			<comment type="block">/*
			 * The backend finished streaming. Exit streaming COPY-mode from
			 * our side, too.
			 */</comment>
			<expr_stmt><expr><call><name>walrcv_endstreaming</name><argument_list>(<argument><expr><name>wrconn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>primaryTLI</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * If the server had switched to a new timeline that we didn't
			 * know about when we began streaming, fetch its timeline history
			 * file now.
			 */</comment>
			<expr_stmt><expr><call><name>WalRcvFetchTimeLineHistoryFiles</name><argument_list>(<argument><expr><name>startpointTLI</name></expr></argument>, <argument><expr><name>primaryTLI</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"primary server contains no more WAL on requested timeline %u"</literal></expr></argument>,
							<argument><expr><name>startpointTLI</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<comment type="block">/*
		 * End of WAL reached on the requested timeline. Close the last
		 * segment, and await for new orders from the startup process.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>recvFile</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>char</name></type>		<name><name>xlogfname</name><index>[<expr><name>MAXFNAMELEN</name></expr>]</index></name></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>XLogWalRcvFlush</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><call><name>polar_close</name><argument_list>(<argument><expr><name>recvFile</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>PANIC</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not close log segment %s: %m"</literal></expr></argument>,
								<argument><expr><call><name>XLogFileNameP</name><argument_list>(<argument><expr><name>recvFileTLI</name></expr></argument>, <argument><expr><name>recvSegNo</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<comment type="block">/*
			 * Create .done file forcibly to prevent the streamed segment from
			 * being archived later.
			 */</comment>
			<expr_stmt><expr><name>polar_is_datamax_mode</name> <operator>=</operator> <call><name>polar_is_datamax</name><argument_list>()</argument_list></call></expr>;</expr_stmt>		<comment type="block">/* POLAR: Enter datamax Mode. */</comment>
			<expr_stmt><expr><call><name>XLogFileName</name><argument_list>(<argument><expr><name>xlogfname</name></expr></argument>, <argument><expr><name>recvFileTLI</name></expr></argument>, <argument><expr><name>recvSegNo</name></expr></argument>, <argument><expr><name>wal_segment_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>XLogArchiveMode</name> <operator>!=</operator> <name>ARCHIVE_MODE_ALWAYS</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>XLogArchiveForceDone</name><argument_list>(<argument><expr><name>xlogfname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<if type="elseif">else if <condition>(<expr><call><name>POLAR_ENABLE_DMA</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>polar_dma_xlog_archive_notify</name><argument_list>(<argument><expr><name>xlogfname</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>XLogArchiveNotify</name><argument_list>(<argument><expr><name>xlogfname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
			<expr_stmt><expr><name>polar_is_datamax_mode</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>				<comment type="block">/* POLAR: Leave datamax mode. */</comment>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><name>recvFile</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>, <argument><expr><literal type="string">"walreceiver ended streaming and awaits new instructions"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>WalRcvWaitForStartPosition</name><argument_list>(<argument><expr><operator>&amp;</operator><name>startpoint</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>startpointTLI</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>
	<comment type="block">/* not reached */</comment>
</block_content>}</block></function>

<comment type="block">/*
 * Wait for startup process to set receiveStart and receiveStartTLI.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>WalRcvWaitForStartPosition</name><parameter_list>(<parameter><decl><type><name>XLogRecPtr</name> <modifier>*</modifier></type><name>startpoint</name></decl></parameter>, <parameter><decl><type><name>TimeLineID</name> <modifier>*</modifier></type><name>startpointTLI</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>WalRcvData</name> <modifier>*</modifier></type><name>walrcv</name> <init>= <expr><name>WalRcv</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>state</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>SpinLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>walrcv</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>state</name> <operator>=</operator> <name><name>walrcv</name><operator>-&gt;</operator><name>walRcvState</name></name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>state</name> <operator>!=</operator> <name>WALRCV_STREAMING</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>SpinLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>walrcv</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>state</name> <operator>==</operator> <name>WALRCV_STOPPING</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>proc_exit</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>, <argument><expr><literal type="string">"unexpected walreceiver state"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name><name>walrcv</name><operator>-&gt;</operator><name>walRcvState</name></name> <operator>=</operator> <name>WALRCV_WAITING</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>walrcv</name><operator>-&gt;</operator><name>receiveStart</name></name> <operator>=</operator> <name>InvalidXLogRecPtr</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>walrcv</name><operator>-&gt;</operator><name>receiveStartTLI</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SpinLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>walrcv</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>update_process_title</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>set_ps_display</name><argument_list>(<argument><expr><literal type="string">"idle"</literal></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * nudge startup process to notice that we've stopped streaming and are
	 * now waiting for instructions.
	 */</comment>
	<expr_stmt><expr><call><name>WakeupRecovery</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ResetLatch</name><argument_list>(<argument><expr><name><name>walrcv</name><operator>-&gt;</operator><name>latch</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Emergency bailout if postmaster has died.  This is to avoid the
		 * necessity for manual cleanup of all postmaster children.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>PostmasterIsAlive</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>ProcessWalRcvInterrupts</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>SpinLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>walrcv</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>walrcv</name><operator>-&gt;</operator><name>walRcvState</name></name> <operator>==</operator> <name>WALRCV_RESTARTING</name> <operator>||</operator>
			   <name><name>walrcv</name><operator>-&gt;</operator><name>walRcvState</name></name> <operator>==</operator> <name>WALRCV_WAITING</name> <operator>||</operator>
			   <name><name>walrcv</name><operator>-&gt;</operator><name>walRcvState</name></name> <operator>==</operator> <name>WALRCV_STOPPING</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>walrcv</name><operator>-&gt;</operator><name>walRcvState</name></name> <operator>==</operator> <name>WALRCV_RESTARTING</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* we don't expect primary_conninfo to change */</comment>
			<expr_stmt><expr><operator>*</operator><name>startpoint</name> <operator>=</operator> <name><name>walrcv</name><operator>-&gt;</operator><name>receiveStart</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><operator>*</operator><name>startpointTLI</name> <operator>=</operator> <name><name>walrcv</name><operator>-&gt;</operator><name>receiveStartTLI</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>walrcv</name><operator>-&gt;</operator><name>walRcvState</name></name> <operator>=</operator> <name>WALRCV_STREAMING</name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>SpinLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>walrcv</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>walrcv</name><operator>-&gt;</operator><name>walRcvState</name></name> <operator>==</operator> <name>WALRCV_STOPPING</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * We should've received SIGTERM if the startup process wants us
			 * to die, but might as well check it here too.
			 */</comment>
			<expr_stmt><expr><call><name>SpinLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>walrcv</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><call><name>SpinLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>walrcv</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>WaitLatch</name><argument_list>(<argument><expr><name><name>walrcv</name><operator>-&gt;</operator><name>latch</name></name></expr></argument>, <argument><expr><name>WL_LATCH_SET</name> <operator>|</operator> <name>WL_POSTMASTER_DEATH</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
				  <argument><expr><name>WAIT_EVENT_WAL_RECEIVER_WAIT_START</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<if_stmt><if>if <condition>(<expr><name>update_process_title</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name></type>		<name><name>activitymsg</name><index>[<expr><literal type="number">50</literal></expr>]</index></name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>activitymsg</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>activitymsg</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"restarting at %X/%X"</literal></expr></argument>,
				 <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <operator>(</operator><operator>*</operator><name>startpoint</name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr></argument>,
				 <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <operator>*</operator><name>startpoint</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>set_ps_display</name><argument_list>(<argument><expr><name>activitymsg</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Fetch any missing timeline history files between 'first' and 'last'
 * (inclusive) from the server.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>WalRcvFetchTimeLineHistoryFiles</name><parameter_list>(<parameter><decl><type><name>TimeLineID</name></type> <name>first</name></decl></parameter>, <parameter><decl><type><name>TimeLineID</name></type> <name>last</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TimeLineID</name></type>	<name>tli</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>polar_is_datamax_mode</name> <operator>=</operator> <call><name>polar_is_datamax</name><argument_list>()</argument_list></call></expr>;</expr_stmt>		<comment type="block">/* POLAR: Enter datamax Mode. */</comment>
	<for>for <control>(<init><expr><name>tli</name> <operator>=</operator> <name>first</name></expr>;</init> <condition><expr><name>tli</name> <operator>&lt;=</operator> <name>last</name></expr>;</condition> <incr><expr><name>tli</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<comment type="block">/* there's no history file for timeline 1 */</comment>
		<if_stmt><if>if <condition>(<expr><name>tli</name> <operator>!=</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>existsTimeLineHistory</name><argument_list>(<argument><expr><name>tli</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>fname</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>content</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int</name></type>			<name>len</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>char</name></type>		<name><name>expectedfname</name><index>[<expr><name>MAXFNAMELEN</name></expr>]</index></name></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"fetching timeline history file for timeline %u from primary server"</literal></expr></argument>,
							<argument><expr><name>tli</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>walrcv_readtimelinehistoryfile</name><argument_list>(<argument><expr><name>wrconn</name></expr></argument>, <argument><expr><name>tli</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>fname</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>content</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * Check that the filename on the master matches what we
			 * calculated ourselves. This is just a sanity check, it should
			 * always match.
			 */</comment>
			<expr_stmt><expr><call><name>TLHistoryFileName</name><argument_list>(<argument><expr><name>expectedfname</name></expr></argument>, <argument><expr><name>tli</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>fname</name></expr></argument>, <argument><expr><name>expectedfname</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_PROTOCOL_VIOLATION</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg_internal</name><argument_list>(<argument><expr><literal type="string">"primary reported unexpected file name for timeline history file of timeline %u"</literal></expr></argument>,
										 <argument><expr><name>tli</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<comment type="block">/*
			 * Write the file to pg_wal.
			 */</comment>
			<expr_stmt><expr><call><name>writeTimeLineHistoryFile</name><argument_list>(<argument><expr><name>tli</name></expr></argument>, <argument><expr><name>content</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * In DMA mode, archive history file for standby
			 */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>POLAR_ENABLE_DMA</name><argument_list>()</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name>XLogArchiveMode</name> <operator>!=</operator> <name>ARCHIVE_MODE_ALWAYS</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>XLogArchiveForceDone</name><argument_list>(<argument><expr><name>expectedfname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>polar_dma_xlog_archive_notify</name><argument_list>(<argument><expr><name>expectedfname</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
			</block_content>}</block></if></if_stmt>

			<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>fname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>content</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>
	<expr_stmt><expr><name>polar_is_datamax_mode</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>				<comment type="block">/* POLAR: Leave datamax mode. */</comment>
</block_content>}</block></function>

<comment type="block">/*
 * Mark us as STOPPED in shared memory at exit.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>WalRcvDie</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>code</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>WalRcvData</name> <modifier>*</modifier></type><name>walrcv</name> <init>= <expr><name>WalRcv</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* Ensure that all WAL records received are flushed to disk */</comment>
	<expr_stmt><expr><call><name>XLogWalRcvFlush</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Mark ourselves inactive in shared memory */</comment>
	<expr_stmt><expr><call><name>SpinLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>walrcv</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>walrcv</name><operator>-&gt;</operator><name>walRcvState</name></name> <operator>==</operator> <name>WALRCV_STREAMING</name> <operator>||</operator>
		   <name><name>walrcv</name><operator>-&gt;</operator><name>walRcvState</name></name> <operator>==</operator> <name>WALRCV_RESTARTING</name> <operator>||</operator>
		   <name><name>walrcv</name><operator>-&gt;</operator><name>walRcvState</name></name> <operator>==</operator> <name>WALRCV_STARTING</name> <operator>||</operator>
		   <name><name>walrcv</name><operator>-&gt;</operator><name>walRcvState</name></name> <operator>==</operator> <name>WALRCV_WAITING</name> <operator>||</operator>
		   <name><name>walrcv</name><operator>-&gt;</operator><name>walRcvState</name></name> <operator>==</operator> <name>WALRCV_STOPPING</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>walrcv</name><operator>-&gt;</operator><name>pid</name></name> <operator>==</operator> <name>MyProcPid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>walrcv</name><operator>-&gt;</operator><name>walRcvState</name></name> <operator>=</operator> <name>WALRCV_STOPPED</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>walrcv</name><operator>-&gt;</operator><name>pid</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>walrcv</name><operator>-&gt;</operator><name>ready_to_display</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>walrcv</name><operator>-&gt;</operator><name>latch</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SpinLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>walrcv</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Terminate the connection gracefully. */</comment>
	<if_stmt><if>if <condition>(<expr><name>wrconn</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>walrcv_disconnect</name><argument_list>(<argument><expr><name>wrconn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Wake up the startup process to notice promptly that we're gone */</comment>
	<expr_stmt><expr><call><name>WakeupRecovery</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* SIGHUP: set flag to re-read config file at next convenient time */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>WalRcvSigHupHandler</name><parameter_list>(<parameter><decl><type><name>SIGNAL_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><name>got_SIGHUP</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/* SIGUSR1: used by latch mechanism */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>WalRcvSigUsr1Handler</name><parameter_list>(<parameter><decl><type><name>SIGNAL_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>save_errno</name> <init>= <expr><name>errno</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>latch_sigusr1_handler</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>errno</name> <operator>=</operator> <name>save_errno</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* SIGTERM: set flag for ProcessWalRcvInterrupts */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>WalRcvShutdownHandler</name><parameter_list>(<parameter><decl><type><name>SIGNAL_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>save_errno</name> <init>= <expr><name>errno</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>got_SIGTERM</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>WalRcv</name><operator>-&gt;</operator><name>latch</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>SetLatch</name><argument_list>(<argument><expr><name><name>WalRcv</name><operator>-&gt;</operator><name>latch</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>errno</name> <operator>=</operator> <name>save_errno</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * WalRcvQuickDieHandler() occurs when signalled SIGQUIT by the postmaster.
 *
 * Some backend has bought the farm, so we need to stop what we're doing and
 * exit.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>WalRcvQuickDieHandler</name><parameter_list>(<parameter><decl><type><name>SIGNAL_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * We DO NOT want to run proc_exit() or atexit() callbacks -- we're here
	 * because shared memory may be corrupted, so we don't want to try to
	 * clean up our transaction.  Just nail the windows shut and get out of
	 * town.  The callbacks wouldn't be safe to run from a signal handler,
	 * anyway.
	 *
	 * Note we use _exit(2) not _exit(0).  This is to force the postmaster
	 * into a system reset cycle if someone sends a manual SIGQUIT to a
	 * random backend.  This is necessary precisely because we don't clean up
	 * our shared memory state.  (The "dead man switch" mechanism in
	 * pmsignal.c should ensure the postmaster sees this as a crash, too, but
	 * no harm in being doubly sure.)
	 */</comment>
	<expr_stmt><expr><call><name>_exit</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Set new consistent lsn received from primary node */</comment>
<function><type><name>void</name></type>
<name>polar_set_primary_consistent_lsn</name><parameter_list>(<parameter><decl><type><name>XLogRecPtr</name></type> <name>new_consistent_lsn</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name><name>WalRcv</name><operator>-&gt;</operator><name>curr_primary_consistent_lsn</name></name> <operator>&lt;</operator> <name>new_consistent_lsn</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>SpinLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>WalRcv</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>WalRcv</name><operator>-&gt;</operator><name>curr_primary_consistent_lsn</name></name> <operator>=</operator> <name>new_consistent_lsn</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>SpinLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>WalRcv</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Primay instance send the consistant lsn by walsender process,
 * replica walreceiver process receives consistant lsn, and saves
 * it in WalRcv-&gt;curr_primary_consistent_lsn
 */</comment>
<function><type><name>XLogRecPtr</name></type>
<name>polar_get_primary_consist_ptr</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>XLogRecPtr</name></type> <name>curr_primary_consist_lsn</name> <init>= <expr><name>InvalidXLogRecPtr</name></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>SpinLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>WalRcv</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>curr_primary_consist_lsn</name> <operator>=</operator> <name><name>WalRcv</name><operator>-&gt;</operator><name>curr_primary_consistent_lsn</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SpinLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>WalRcv</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>curr_primary_consist_lsn</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Accept the message from XLOG stream, and process it.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>XLogWalRcvProcessMsg</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>char</name></type> <name>type</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><name>Size</name></type> <name>len</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>hdrlen</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>XLogRecPtr</name></type>	<name>dataStart</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>XLogRecPtr</name></type>	<name>walEnd</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TimestampTz</name></type> <name>sendTime</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>replyRequested</name></decl>;</decl_stmt>

	<comment type="block">/* POLAR */</comment>
	<decl_stmt><decl><type><name>XLogRecPtr</name></type>	<name>curr_primary_consist_lsn_new</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>is_promote_allowed</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>XLogRecPtr</name></type>  <name>end_lsn</name> <init>= <expr><name>InvalidXLogRecPtr</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TransactionId</name></type> <name>polar_primary_next_xid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32</name></type>		<name>polar_primary_epoch</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>XLogRecPtr</name></type>	<name>polar_primary_last_lsn</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>XLogSegNo</name></type>	<name>polar_upstream_last_removed_segno</name></decl>;</decl_stmt>
	<comment type="block">/* POLAR end */</comment>

	<expr_stmt><expr><call><name>resetStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>incoming_message</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<switch>switch <condition>(<expr><name>type</name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><literal type="char">'w'</literal></expr>:</case>				<comment type="block">/* WAL records */</comment>
			<block>{<block_content>
				<comment type="block">/* copy message to StringInfo */</comment>
				<expr_stmt><expr><name>hdrlen</name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int64</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int64</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int64</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name>len</name> <operator>&lt;</operator> <name>hdrlen</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_PROTOCOL_VIOLATION</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errmsg_internal</name><argument_list>(<argument><expr><literal type="string">"invalid WAL message received from primary"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<expr_stmt><expr><call><name>appendBinaryStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>incoming_message</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>hdrlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/* read the fields */</comment>
				<expr_stmt><expr><name>dataStart</name> <operator>=</operator> <call><name>pq_getmsgint64</name><argument_list>(<argument><expr><operator>&amp;</operator><name>incoming_message</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>walEnd</name> <operator>=</operator> <call><name>pq_getmsgint64</name><argument_list>(<argument><expr><operator>&amp;</operator><name>incoming_message</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>sendTime</name> <operator>=</operator> <call><name>pq_getmsgint64</name><argument_list>(<argument><expr><operator>&amp;</operator><name>incoming_message</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>ProcessWalSndrMessage</name><argument_list>(<argument><expr><name>walEnd</name></expr></argument>, <argument><expr><name>sendTime</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><name>buf</name> <operator>+=</operator> <name>hdrlen</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>len</name> <operator>-=</operator> <name>hdrlen</name></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>XLogWalRcvWrite</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name>dataStart</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block>
		<case>case <expr><literal type="char">'k'</literal></expr>:</case>				<comment type="block">/* Keepalive */</comment>
			<block>{<block_content>
				<comment type="block">/* copy message to StringInfo */</comment>
				<expr_stmt><expr><name>hdrlen</name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int64</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int64</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>char</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name>len</name> <operator>!=</operator> <name>hdrlen</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_PROTOCOL_VIOLATION</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errmsg_internal</name><argument_list>(<argument><expr><literal type="string">"invalid keepalive message received from primary"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<expr_stmt><expr><call><name>appendBinaryStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>incoming_message</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>hdrlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/* read the fields */</comment>
				<expr_stmt><expr><name>walEnd</name> <operator>=</operator> <call><name>pq_getmsgint64</name><argument_list>(<argument><expr><operator>&amp;</operator><name>incoming_message</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>sendTime</name> <operator>=</operator> <call><name>pq_getmsgint64</name><argument_list>(<argument><expr><operator>&amp;</operator><name>incoming_message</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>replyRequested</name> <operator>=</operator> <call><name>pq_getmsgbyte</name><argument_list>(<argument><expr><operator>&amp;</operator><name>incoming_message</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><call><name>ProcessWalSndrMessage</name><argument_list>(<argument><expr><name>walEnd</name></expr></argument>, <argument><expr><name>sendTime</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/* If the primary requested a reply, send one immediately */</comment>
				<if_stmt><if>if <condition>(<expr><name>replyRequested</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>XLogWalRcvSendReply</name><argument_list>(<argument><expr><name>true</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<break>break;</break>
			</block_content>}</block>
		<case>case <expr><literal type="char">'p'</literal></expr>:</case>				<comment type="block">/* polardb lsn */</comment>
			<block>{<block_content>
				<comment type="block">/*
				 * POLAR: replicamode
				 * Does not contain any wal data
				 * copy message to StringInfo
				 */</comment>
				<expr_stmt><expr><name>hdrlen</name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int64</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int64</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int64</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int64</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name>len</name> <operator>&lt;</operator> <name>hdrlen</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_PROTOCOL_VIOLATION</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errmsg_internal</name><argument_list>(<argument><expr><literal type="string">"invalid consist lsn message received from primary"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<expr_stmt><expr><call><name>appendBinaryStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>incoming_message</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>hdrlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><name>dataStart</name> <operator>=</operator> <call><name>pq_getmsgint64</name><argument_list>(<argument><expr><operator>&amp;</operator><name>incoming_message</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>walEnd</name> <operator>=</operator> <call><name>pq_getmsgint64</name><argument_list>(<argument><expr><operator>&amp;</operator><name>incoming_message</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>curr_primary_consist_lsn_new</name> <operator>=</operator> <call><name>pq_getmsgint64</name><argument_list>(<argument><expr><operator>&amp;</operator><name>incoming_message</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>sendTime</name> <operator>=</operator> <call><name>pq_getmsgint64</name><argument_list>(<argument><expr><operator>&amp;</operator><name>incoming_message</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>ProcessWalSndrMessage</name><argument_list>(<argument><expr><name>walEnd</name></expr></argument>, <argument><expr><name>sendTime</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<if_stmt><if>if <condition>(<expr><name><name>WalRcv</name><operator>-&gt;</operator><name>polar_use_xlog_queue</name></name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>POLAR_LOGINDEX_ENABLE_XLOG_QUEUE</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<expr_stmt><expr><call><name>polar_xlog_recv_queue_push_storage_begin</name><argument_list>(<argument><expr><name><name>polar_logindex_redo_instance</name><operator>-&gt;</operator><name>xlog_queue</name></name></expr></argument>, <argument><expr><name>ProcessWalRcvInterrupts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<expr_stmt><expr><call><name>SpinLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>WalRcv</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>WalRcv</name><operator>-&gt;</operator><name>polar_use_xlog_queue</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>SpinLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>WalRcv</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"master xlog queue is full, changed to send from file"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>

				<comment type="block">/*
				 * POLAR: As a polardb replica, we do not write the xlog,
				 * we just update the LogstreamResult.write and call XLogWalRcvFlush
				 * to update shared-memory status as the case 'w'.
				 */</comment>
				<expr_stmt><expr><name><name>LogstreamResult</name><operator>.</operator><name>Write</name></name> <operator>=</operator> <name>walEnd</name></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>XLogWalRcvFlush</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/* POLAR: Update consistent lsn */</comment>
				<expr_stmt><expr><call><name>polar_set_primary_consistent_lsn</name><argument_list>(<argument><expr><name>curr_primary_consist_lsn_new</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<if_stmt><if>if <condition>(<expr><name>polar_enable_debug</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"Receive primary on polardb flush xlog from %X/%X to %X/%X, "</literal></expr></argument>,
									<argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <operator>(</operator><name>dataStart</name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr></argument>, <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <name>dataStart</name></expr></argument>,
									<argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <operator>(</operator><name>walEnd</name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr></argument>, <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <name>walEnd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
				<break>break;</break>
			</block_content>}</block>
		<comment type="block">/* POLAR: streaming xlog meta */</comment>
		<case>case <expr><literal type="char">'y'</literal></expr>:</case>
			<block>{<block_content>
				<comment type="block">/* POLAR: copy message to StringInfo */</comment>
				<expr_stmt><expr><name>hdrlen</name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int64</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int64</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int64</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name>len</name> <operator>&lt;</operator> <name>hdrlen</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_PROTOCOL_VIOLATION</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errmsg_internal</name><argument_list>(<argument><expr><literal type="string">"invalid WAL message received from primary"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<expr_stmt><expr><call><name>appendBinaryStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>incoming_message</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>hdrlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/* POLAR: read the fields */</comment>
				<expr_stmt><expr><name>walEnd</name> <operator>=</operator> <call><name>pq_getmsgint64</name><argument_list>(<argument><expr><operator>&amp;</operator><name>incoming_message</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>curr_primary_consist_lsn_new</name> <operator>=</operator> <call><name>pq_getmsgint64</name><argument_list>(<argument><expr><operator>&amp;</operator><name>incoming_message</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>sendTime</name> <operator>=</operator> <call><name>pq_getmsgint64</name><argument_list>(<argument><expr><operator>&amp;</operator><name>incoming_message</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>ProcessWalSndrMessage</name><argument_list>(<argument><expr><name>walEnd</name></expr></argument>, <argument><expr><name>sendTime</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><name>buf</name> <operator>+=</operator> <name>hdrlen</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>len</name> <operator>-=</operator> <name>hdrlen</name></expr>;</expr_stmt>

				<if_stmt><if>if <condition>(<expr><name>len</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>polar_xlog_recv_queue_push</name><argument_list>(<argument><expr><name><name>polar_logindex_redo_instance</name><operator>-&gt;</operator><name>xlog_queue</name></name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>len</name></expr></argument>,
							<argument><expr><name>polar_receiver_xlog_queue_callback</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>WalRcv</name><operator>-&gt;</operator><name>polar_use_xlog_queue</name></name></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><call><name>SpinLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>WalRcv</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><name><name>WalRcv</name><operator>-&gt;</operator><name>polar_use_xlog_queue</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
						<expr_stmt><expr><call><name>SpinLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>WalRcv</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

						<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"master send data changed from file to queue"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block></if></if_stmt>
				</block_content>}</block></if></if_stmt>

				<comment type="block">/* POLAR: As a polardb replica, we do not write the xlog,
				 * we just update the LogstreamResult.write and call XLogWalRcvFlush
				 * to update shared-memory status as the case 'w'.
				 */</comment>
				<expr_stmt><expr><name><name>LogstreamResult</name><operator>.</operator><name>Write</name></name> <operator>=</operator> <name>walEnd</name></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>XLogWalRcvFlush</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/* POLAR: Update new consistent lsn */</comment>
				<expr_stmt><expr><call><name>polar_set_primary_consistent_lsn</name><argument_list>(<argument><expr><name>curr_primary_consist_lsn_new</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<if_stmt><if>if <condition>(<expr><name>polar_enable_debug</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"Receive XLOG without payload, and end lsn is %X/%X"</literal></expr></argument>,
							<argument><expr><operator>(</operator><name>uint32</name><operator>)</operator><operator>(</operator><name>walEnd</name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr></argument>, <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator><name>walEnd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
				<break>break;</break>
			</block_content>}</block>
		<comment type="block">/* POLAR: keepalive with consistent lsn */</comment>
		<case>case <expr><literal type="char">'K'</literal></expr>:</case>
			<block>{<block_content>
				<comment type="block">/* POLAR: Copy message to StringInfo */</comment>
				<expr_stmt><expr><name>hdrlen</name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int64</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int64</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int64</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>char</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name>len</name> <operator>!=</operator> <name>hdrlen</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_PROTOCOL_VIOLATION</name></expr></argument>)</argument_list></call><operator>,</operator>
									<call><name>errmsg_internal</name><argument_list>(<argument><expr><literal type="string">"invalid keepalive message received from primary"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>

				<expr_stmt><expr><call><name>appendBinaryStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>incoming_message</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>hdrlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/* POLAR: Read the fields */</comment>
				<expr_stmt><expr><name>walEnd</name> <operator>=</operator> <call><name>pq_getmsgint64</name><argument_list>(<argument><expr><operator>&amp;</operator><name>incoming_message</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>curr_primary_consist_lsn_new</name> <operator>=</operator> <call><name>pq_getmsgint64</name><argument_list>(<argument><expr><operator>&amp;</operator><name>incoming_message</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>sendTime</name> <operator>=</operator> <call><name>pq_getmsgint64</name><argument_list>(<argument><expr><operator>&amp;</operator><name>incoming_message</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>replyRequested</name> <operator>=</operator> <call><name>pq_getmsgbyte</name><argument_list>(<argument><expr><operator>&amp;</operator><name>incoming_message</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><call><name>ProcessWalSndrMessage</name><argument_list>(<argument><expr><name>walEnd</name></expr></argument>, <argument><expr><name>sendTime</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/*
				 * POLAR: As a polardb replica, we do not write the xlog,
				 * we just update the LogstreamResult.write and call XLogWalRcvFlush
				 * to update shared-memory status as the case 'w'.
				 */</comment>
				<expr_stmt><expr><name><name>LogstreamResult</name><operator>.</operator><name>Write</name></name> <operator>=</operator> <name>walEnd</name></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>XLogWalRcvFlush</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/* POLAR: Update consistent lsn */</comment>
				<expr_stmt><expr><call><name>polar_set_primary_consistent_lsn</name><argument_list>(<argument><expr><name>curr_primary_consist_lsn_new</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<if_stmt><if>if <condition>(<expr><name>polar_enable_debug</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"Receive primary on polardb keepalive with walEnd %X/%X and consistent lsn %X/%X"</literal></expr></argument>,
						 <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <operator>(</operator><name>walEnd</name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr></argument>, <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <name>walEnd</name></expr></argument>,
						 <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <operator>(</operator><name>curr_primary_consist_lsn_new</name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr></argument>, <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <name>curr_primary_consist_lsn_new</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>

				<comment type="block">/* POLAR: If the primary requested a reply, send one immediately */</comment>
				<if_stmt><if>if <condition>(<expr><name>replyRequested</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>XLogWalRcvSendReply</name><argument_list>(<argument><expr><name>true</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<break>break;</break>
			</block_content>}</block>
		<comment type="block">/* POLAR: endlsn from walsender, when receivedlsn = endlsn, promote is ready */</comment>
		<case>case <expr><literal type="char">'l'</literal></expr>:</case>
			<block>{<block_content>
				<expr_stmt><expr><name>hdrlen</name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>char</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int64</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name>len</name> <operator>!=</operator> <name>hdrlen</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_PROTOCOL_VIOLATION</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errmsg_internal</name><argument_list>(<argument><expr><literal type="string">"invalid endlsn message received from primary"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<expr_stmt><expr><call><name>appendBinaryStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>incoming_message</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>hdrlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			
				<comment type="block">/* read the fields */</comment>
				<expr_stmt><expr><name>is_promote_allowed</name> <operator>=</operator> <call><name>pq_getmsgbyte</name><argument_list>(<argument><expr><operator>&amp;</operator><name>incoming_message</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>end_lsn</name> <operator>=</operator> <call><name>pq_getmsgint64</name><argument_list>(<argument><expr><operator>&amp;</operator><name>incoming_message</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,<argument><expr><literal type="string">"received reply from walsender, is_promote_allowed:%d, end_lsn:%lx"</literal></expr></argument>, <argument><expr><name>is_promote_allowed</name></expr></argument>, <argument><expr><name>end_lsn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>polar_process_walsender_reply</name><argument_list>(<argument><expr><name>is_promote_allowed</name></expr></argument>, <argument><expr><name>end_lsn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block>
		<comment type="block">/* 
		 * POLAR: with next_xid and epoch of primary, needed when feedback standby xmin in datamax mode 
		 * with last_valid_lsn of primary, used to keep xlog consistency 
		 * also with last_removed_segno of primary, used to keep wal file those haven't been removed in primary
		 */</comment>
		<case>case <expr><literal type="char">'e'</literal></expr>:</case>
			<block>{<block_content>
				<comment type="block">/* copy message to StringInfo */</comment>
				<expr_stmt><expr><name>hdrlen</name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int64</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int64</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int32</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int32</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int64</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int64</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int64</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name>len</name> <operator>&lt;</operator> <name>hdrlen</name></expr>)</condition><block type="pseudo"><block_content>
				<comment type="block">/*no cover begin*/</comment>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_PROTOCOL_VIOLATION</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errmsg_internal</name><argument_list>(<argument><expr><literal type="string">"invalid WAL message received from primary"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<comment type="block">/*no cover end*/</comment>
				<expr_stmt><expr><call><name>appendBinaryStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>incoming_message</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>hdrlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/* read the fields */</comment>
				<expr_stmt><expr><name>dataStart</name> <operator>=</operator> <call><name>pq_getmsgint64</name><argument_list>(<argument><expr><operator>&amp;</operator><name>incoming_message</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>walEnd</name> <operator>=</operator> <call><name>pq_getmsgint64</name><argument_list>(<argument><expr><operator>&amp;</operator><name>incoming_message</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>polar_primary_next_xid</name> <operator>=</operator> <call><name>pq_getmsgint</name><argument_list>(<argument><expr><operator>&amp;</operator><name>incoming_message</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>polar_primary_epoch</name> <operator>=</operator> <call><name>pq_getmsgint</name><argument_list>(<argument><expr><operator>&amp;</operator><name>incoming_message</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>polar_primary_last_lsn</name> <operator>=</operator> <call><name>pq_getmsgint64</name><argument_list>(<argument><expr><operator>&amp;</operator><name>incoming_message</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>polar_upstream_last_removed_segno</name> <operator>=</operator> <call><name>pq_getmsgint64</name><argument_list>(<argument><expr><operator>&amp;</operator><name>incoming_message</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>sendTime</name> <operator>=</operator> <call><name>pq_getmsgint64</name><argument_list>(<argument><expr><operator>&amp;</operator><name>incoming_message</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>ProcessWalSndrMessage</name><argument_list>(<argument><expr><name>walEnd</name></expr></argument>, <argument><expr><name>sendTime</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/* record next_xid and epoch of primary */</comment>
				<expr_stmt><expr><call><name>POLAR_DATAMAX_SET_PRIMARY_NEXTXID</name><argument_list>(<argument><expr><name>polar_primary_next_xid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>POLAR_DATAMAX_SET_PRIMARY_NEXTEPOCH</name><argument_list>(<argument><expr><name>polar_primary_epoch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<comment type="block">/* record polar_primary_last_lsn into list */</comment>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>POLAR_ENABLE_DMA</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>polar_datamax_insert_last_valid_lsn</name><argument_list>(<argument><expr><name>polar_datamax_received_valid_lsn_list</name></expr></argument>, <argument><expr><name>polar_primary_last_lsn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<comment type="block">/* record polar_upstream_last_removed_segno */</comment>
				<expr_stmt><expr><call><name>polar_datamax_update_upstream_last_removed_segno</name><argument_list>(<argument><expr><name>polar_datamax_ctl</name></expr></argument>, <argument><expr><name>polar_upstream_last_removed_segno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><name>buf</name> <operator>+=</operator> <name>hdrlen</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>len</name> <operator>-=</operator> <name>hdrlen</name></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>XLogWalRcvWrite</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name>dataStart</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/* init timeline id and lsn if intial datamax */</comment>
				<if_stmt><if>if <condition>(<expr><call><name>unlikely</name><argument_list>(<argument><expr><name>polar_is_initial_datamax</name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/* POLAR: init timeline and lsn */</comment>
					<expr_stmt><expr><call><name>polar_datamax_update_min_received_info</name><argument_list>(<argument><expr><name>polar_datamax_ctl</name></expr></argument>, <argument><expr><name>ThisTimeLineID</name></expr></argument>, <argument><expr><name>dataStart</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<comment type="block">/* POLAR: write meta to storage */</comment>
					<expr_stmt><expr><call><name>polar_datamax_write_meta</name><argument_list>(<argument><expr><name>polar_datamax_ctl</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<expr_stmt><expr><name>polar_is_initial_datamax</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
				<break>break;</break>
			</block_content>}</block>
		<comment type="block">/* POLAR end */</comment>
		<default>default:</default>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_PROTOCOL_VIOLATION</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg_internal</name><argument_list>(<argument><expr><literal type="string">"invalid replication message type %d"</literal></expr></argument>,
									 <argument><expr><name>type</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></switch>
</block_content>}</block></function>

<comment type="block">/*
 * Write XLOG data to disk.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>XLogWalRcvWrite</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><name>Size</name></type> <name>nbytes</name></decl></parameter>, <parameter><decl><type><name>XLogRecPtr</name></type> <name>recptr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>startoff</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>byteswritten</name></decl>;</decl_stmt>

	<while>while <condition>(<expr><name>nbytes</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>segbytes</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>recvFile</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator> <operator>!</operator><call><name>XLByteInSeg</name><argument_list>(<argument><expr><name>recptr</name></expr></argument>, <argument><expr><name>recvSegNo</name></expr></argument>, <argument><expr><name>wal_segment_size</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>bool</name></type>		<name>use_existent</name></decl>;</decl_stmt>

			<comment type="block">/*
			 * fsync() and close current file before we switch to next one. We
			 * would otherwise have to reopen this file to fsync it later
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name>recvFile</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>char</name></type>		<name><name>xlogfname</name><index>[<expr><name>MAXFNAMELEN</name></expr>]</index></name></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>XLogWalRcvFlush</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/*
				 * XLOG segment files will be re-read by recovery in startup
				 * process soon, so we don't advise the OS to release cache
				 * pages associated with the file like XLogFileClose() does.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><call><name>polar_close</name><argument_list>(<argument><expr><name>recvFile</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>PANIC</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not close log segment %s: %m"</literal></expr></argument>,
									<argument><expr><call><name>XLogFileNameP</name><argument_list>(<argument><expr><name>recvFileTLI</name></expr></argument>, <argument><expr><name>recvSegNo</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

				<comment type="block">/*
				 * Create .done file forcibly to prevent the streamed segment
				 * from being archived later.
				 */</comment>
				<expr_stmt><expr><call><name>XLogFileName</name><argument_list>(<argument><expr><name>xlogfname</name></expr></argument>, <argument><expr><name>recvFileTLI</name></expr></argument>, <argument><expr><name>recvSegNo</name></expr></argument>, <argument><expr><name>wal_segment_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>polar_is_datamax_mode</name> <operator>=</operator> <call><name>polar_is_datamax</name><argument_list>()</argument_list></call></expr>;</expr_stmt>		<comment type="block">/* POLAR: Enter datamax Mode. */</comment>
				<if_stmt><if>if <condition>(<expr><name>XLogArchiveMode</name> <operator>!=</operator> <name>ARCHIVE_MODE_ALWAYS</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>XLogArchiveForceDone</name><argument_list>(<argument><expr><name>xlogfname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
				<if type="elseif">else if <condition>(<expr><call><name>POLAR_ENABLE_DMA</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>polar_dma_xlog_archive_notify</name><argument_list>(<argument><expr><name>xlogfname</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>XLogArchiveNotify</name><argument_list>(<argument><expr><name>xlogfname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
				<expr_stmt><expr><name>polar_is_datamax_mode</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>				<comment type="block">/* POLAR: Leave datamax mode. */</comment>
			</block_content>}</block></if></if_stmt>
			<expr_stmt><expr><name>recvFile</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>

			<comment type="block">/* Create/use new log file */</comment>
			<expr_stmt><expr><call><name>XLByteToSeg</name><argument_list>(<argument><expr><name>recptr</name></expr></argument>, <argument><expr><name>recvSegNo</name></expr></argument>, <argument><expr><name>wal_segment_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>use_existent</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>polar_is_datamax_mode</name> <operator>=</operator> <call><name>polar_is_datamax</name><argument_list>()</argument_list></call></expr>;</expr_stmt>		<comment type="block">/* POLAR: Enter datamax Mode. */</comment>
			<expr_stmt><expr><name>recvFile</name> <operator>=</operator> <call><name>XLogFileInit</name><argument_list>(<argument><expr><name>recvSegNo</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>use_existent</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>polar_is_datamax_mode</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>				<comment type="block">/* POLAR: Leave datamax mode. */</comment>
			<expr_stmt><expr><name>recvFileTLI</name> <operator>=</operator> <name>ThisTimeLineID</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>recvOff</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* Calculate the start offset of the received logs */</comment>
		<expr_stmt><expr><name>startoff</name> <operator>=</operator> <call><name>XLogSegmentOffset</name><argument_list>(<argument><expr><name>recptr</name></expr></argument>, <argument><expr><name>wal_segment_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>startoff</name> <operator>+</operator> <name>nbytes</name> <operator>&gt;</operator> <name>wal_segment_size</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>segbytes</name> <operator>=</operator> <name>wal_segment_size</name> <operator>-</operator> <name>startoff</name></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>segbytes</name> <operator>=</operator> <name>nbytes</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<comment type="block">/* Need to seek in the file? */</comment>
		<if_stmt><if>if <condition>(<expr><name>recvOff</name> <operator>!=</operator> <name>startoff</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><call><name>polar_lseek</name><argument_list>(<argument><expr><name>recvFile</name></expr></argument>, <argument><expr><operator>(</operator><name>off_t</name><operator>)</operator> <name>startoff</name></expr></argument>, <argument><expr><name>SEEK_SET</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>PANIC</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not seek in log segment %s to offset %u: %m"</literal></expr></argument>,
								<argument><expr><call><name>XLogFileNameP</name><argument_list>(<argument><expr><name>recvFileTLI</name></expr></argument>, <argument><expr><name>recvSegNo</name></expr></argument>)</argument_list></call></expr></argument>,
								<argument><expr><name>startoff</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><name>recvOff</name> <operator>=</operator> <name>startoff</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* OK to write the logs */</comment>
		<expr_stmt><expr><name>errno</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

		<expr_stmt><expr><name>byteswritten</name> <operator>=</operator> <call><name>polar_write</name><argument_list>(<argument><expr><name>recvFile</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>segbytes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>byteswritten</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* if write didn't set errno, assume no disk space */</comment>
			<if_stmt><if>if <condition>(<expr><name>errno</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>errno</name> <operator>=</operator> <name>ENOSPC</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>PANIC</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not write to log segment %s "</literal>
							<literal type="string">"at offset %u, length %lu: %m"</literal></expr></argument>,
							<argument><expr><call><name>XLogFileNameP</name><argument_list>(<argument><expr><name>recvFileTLI</name></expr></argument>, <argument><expr><name>recvSegNo</name></expr></argument>)</argument_list></call></expr></argument>,
							<argument><expr><name>recvOff</name></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name> <name>long</name><operator>)</operator> <name>segbytes</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* Update state for write */</comment>
		<expr_stmt><expr><name>recptr</name> <operator>+=</operator> <name>byteswritten</name></expr>;</expr_stmt>

		<expr_stmt><expr><name>recvOff</name> <operator>+=</operator> <name>byteswritten</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>nbytes</name> <operator>-=</operator> <name>byteswritten</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>buf</name> <operator>+=</operator> <name>byteswritten</name></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>LogstreamResult</name><operator>.</operator><name>Write</name></name> <operator>=</operator> <name>recptr</name></expr>;</expr_stmt>
	</block_content>}</block></while>
</block_content>}</block></function>

<comment type="block">/*
 * Flush the log to disk.
 *
 * If we're in the midst of dying, it's unwise to do anything that might throw
 * an error, so we skip sending a reply in that case.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>XLogWalRcvFlush</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>dying</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name><name>LogstreamResult</name><operator>.</operator><name>Flush</name></name> <operator>&lt;</operator> <name><name>LogstreamResult</name><operator>.</operator><name>Write</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>WalRcvData</name> <modifier>*</modifier></type><name>walrcv</name> <init>= <expr><name>WalRcv</name></expr></init></decl>;</decl_stmt>

		<comment type="block">/* POLAR */</comment>
		<decl_stmt><decl><type><name>XLogRecPtr</name></type> <name>curr_primary_consistent_lsn</name> <init>= <expr><name>InvalidXLogRecPtr</name></expr></init></decl>;</decl_stmt>

		<comment type="block">/* POLAR: only replica mode not write data */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>polar_in_replica_mode</name><argument_list>()</argument_list></call> <operator>==</operator> <name>false</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>issue_xlog_fsync</name><argument_list>(<argument><expr><name>recvFile</name></expr></argument>, <argument><expr><name>recvSegNo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name><name>LogstreamResult</name><operator>.</operator><name>Flush</name></name> <operator>=</operator> <name><name>LogstreamResult</name><operator>.</operator><name>Write</name></name></expr>;</expr_stmt>

		<comment type="block">/* Update shared-memory status */</comment>
		<expr_stmt><expr><call><name>SpinLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>walrcv</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>walrcv</name><operator>-&gt;</operator><name>receivedUpto</name></name> <operator>&lt;</operator> <name><name>LogstreamResult</name><operator>.</operator><name>Flush</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>walrcv</name><operator>-&gt;</operator><name>latestChunkStart</name></name> <operator>=</operator> <name><name>walrcv</name><operator>-&gt;</operator><name>receivedUpto</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>walrcv</name><operator>-&gt;</operator><name>receivedUpto</name></name> <operator>=</operator> <name><name>LogstreamResult</name><operator>.</operator><name>Flush</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>walrcv</name><operator>-&gt;</operator><name>receivedTLI</name></name> <operator>=</operator> <name>ThisTimeLineID</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>curr_primary_consistent_lsn</name> <operator>=</operator> <name><name>walrcv</name><operator>-&gt;</operator><name>curr_primary_consistent_lsn</name></name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><call><name>SpinLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>walrcv</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* POLAR: update lastet flush lsn */</comment>
		<expr_stmt><expr><call><name>pg_atomic_write_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>WalRcv</name><operator>-&gt;</operator><name>polar_latest_flush_lsn</name></name></expr></argument>, <argument><expr><name><name>LogstreamResult</name><operator>.</operator><name>Flush</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* POLAR end */</comment>

		<comment type="block">/* POLAR: update received WAL lsn */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>POLAR_ENABLE_DMA</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ConsensusSetXLogFlushedLSN</name><argument_list>(<argument><expr><name><name>LogstreamResult</name><operator>.</operator><name>Flush</name></name></expr></argument>, <argument><expr><name>ThisTimeLineID</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>	
		<if type="elseif">else if <condition>(<expr><call><name>polar_is_datamax</name><argument_list>()</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>polar_datamax_update_received_info</name><argument_list>(
					<argument><expr><name>polar_datamax_ctl</name></expr></argument>, <argument><expr><name>ThisTimeLineID</name></expr></argument>, <argument><expr><name><name>LogstreamResult</name><operator>.</operator><name>Flush</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* update last received valid lsn */</comment>
			<expr_stmt><expr><call><name>polar_datamax_update_cur_valid_lsn</name><argument_list>(<argument><expr><name>polar_datamax_received_valid_lsn_list</name></expr></argument>, <argument><expr><name><name>LogstreamResult</name><operator>.</operator><name>Flush</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>polar_datamax_write_meta</name><argument_list>(<argument><expr><name>polar_datamax_ctl</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<comment type="block">/* POLAR end */</comment>

		<comment type="block">/* Signal the startup process and walsender that new WAL has arrived */</comment>
		<expr_stmt><expr><call><name>WakeupRecovery</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>AllowCascadeReplication</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>WalSndWakeup</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/* POLAR: wakeup the fullpage process that new WAL has arrived */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>POLAR_LOGINDEX_ENABLE_FULLPAGE</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>polar_fullpage_bgworker_wakeup</name><argument_list>(<argument><expr><name><name>polar_logindex_redo_instance</name><operator>-&gt;</operator><name>fullpage_ctl</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/* Report XLOG streaming progress in PS display */</comment>
		<if_stmt><if>if <condition>(<expr><name>update_process_title</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>char</name></type>		<name><name>activitymsg</name><index>[<expr><name>MAX_REPLICATION_PS_BUFFER_SIZE</name></expr>]</index></name> <init>= <expr><block>{<expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt>

			<comment type="block">/* POLAR */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>polar_in_replica_mode</name><argument_list>()</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>activitymsg</name></expr></argument>,
						 <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>activitymsg</name></expr></argument>)</argument_list></sizeof></expr></argument>,
						 <argument><expr><literal type="string">"streaming %X/%X, consistent lsn %X/%X"</literal></expr></argument>,
						 <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <operator>(</operator><name><name>LogstreamResult</name><operator>.</operator><name>Write</name></name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr></argument>,
						 <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <name><name>LogstreamResult</name><operator>.</operator><name>Write</name></name></expr></argument>,
						 <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <operator>(</operator><name>curr_primary_consistent_lsn</name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr></argument>,
						 <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <name>curr_primary_consistent_lsn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>activitymsg</name></expr></argument>,
						 <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>activitymsg</name></expr></argument>)</argument_list></sizeof></expr></argument>,
						 <argument><expr><literal type="string">"streaming %X/%X"</literal></expr></argument>,
						 <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <operator>(</operator><name><name>LogstreamResult</name><operator>.</operator><name>Write</name></name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr></argument>,
						 <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <name><name>LogstreamResult</name><operator>.</operator><name>Write</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
			<expr_stmt><expr><call><name>set_ps_display</name><argument_list>(<argument><expr><name>activitymsg</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* Also let the master know that we made some progress */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>dying</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>XLogWalRcvSendReply</name><argument_list>(<argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>XLogWalRcvSendHSFeedback</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Send reply message to primary, indicating our current WAL locations, oldest
 * xmin and the current time.
 *
 * If 'force' is not set, the message is only sent if enough time has
 * passed since last status update to reach wal_receiver_status_interval.
 * If wal_receiver_status_interval is disabled altogether and 'force' is
 * false, this is a no-op.
 *
 * If 'requestReply' is true, requests the server to reply immediately upon
 * receiving this message. This is used for heartbearts, when approaching
 * wal_receiver_timeout.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>XLogWalRcvSendReply</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>force</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>requestReply</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>static</specifier> <name>XLogRecPtr</name></type> <name>writePtr</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>static</specifier> <name>XLogRecPtr</name></type> <name>flushPtr</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>XLogRecPtr</name></type>	<name>applyPtr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>static</specifier> <name>TimestampTz</name></type> <name>sendTime</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TimestampTz</name></type> <name>now</name></decl>;</decl_stmt>

	<comment type="block">/* POLAR: */</comment>
	<decl_stmt><decl><type><name>XLogRecPtr</name></type> <name>polar_lock_replay_lsn</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<comment type="block">/* POLAR end */</comment>

	<comment type="block">/*
	 * If the user doesn't want status to be reported to the master, be sure
	 * to exit before doing anything at all.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>force</name> <operator>&amp;&amp;</operator> <name>wal_receiver_status_interval</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/* Get current timestamp. */</comment>
	<expr_stmt><expr><name>now</name> <operator>=</operator> <call><name>GetCurrentTimestamp</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * We can compare the write and flush positions to the last message we
	 * sent without taking any lock, but the apply position requires a spin
	 * lock, so we don't check that unless something else has changed or 10
	 * seconds have passed.  This means that the apply WAL location will
	 * appear, from the master's point of view, to lag slightly, but since
	 * this is only for reporting purposes and only on idle systems, that's
	 * probably OK.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>force</name>
		<operator>&amp;&amp;</operator> <name>writePtr</name> <operator>==</operator> <name><name>LogstreamResult</name><operator>.</operator><name>Write</name></name>
		<operator>&amp;&amp;</operator> <name>flushPtr</name> <operator>==</operator> <name><name>LogstreamResult</name><operator>.</operator><name>Flush</name></name>
		<operator>&amp;&amp;</operator> <operator>!</operator><call><name>TimestampDifferenceExceeds</name><argument_list>(<argument><expr><name>sendTime</name></expr></argument>, <argument><expr><name>now</name></expr></argument>,
									   <argument><expr><name>wal_receiver_status_interval</name> <operator>*</operator> <literal type="number">1000</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>sendTime</name> <operator>=</operator> <name>now</name></expr>;</expr_stmt>

	<comment type="block">/* Construct a new message */</comment>
	<expr_stmt><expr><name>writePtr</name> <operator>=</operator> <name><name>LogstreamResult</name><operator>.</operator><name>Write</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>flushPtr</name> <operator>=</operator> <name><name>LogstreamResult</name><operator>.</operator><name>Flush</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>applyPtr</name> <operator>=</operator> <ternary><condition><expr><call><name>polar_is_datamax</name><argument_list>()</argument_list></call></expr> ?</condition><then> <expr><name><name>LogstreamResult</name><operator>.</operator><name>Flush</name></name></expr> </then><else>: <expr><call><name>GetXLogReplayRecPtr</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></else></ternary></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>resetStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>reply_message</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pq_sendbyte</name><argument_list>(<argument><expr><operator>&amp;</operator><name>reply_message</name></expr></argument>, <argument><expr><literal type="char">'r'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pq_sendint64</name><argument_list>(<argument><expr><operator>&amp;</operator><name>reply_message</name></expr></argument>, <argument><expr><name>writePtr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pq_sendint64</name><argument_list>(<argument><expr><operator>&amp;</operator><name>reply_message</name></expr></argument>, <argument><expr><name>flushPtr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pq_sendint64</name><argument_list>(<argument><expr><operator>&amp;</operator><name>reply_message</name></expr></argument>, <argument><expr><name>applyPtr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pq_sendint64</name><argument_list>(<argument><expr><operator>&amp;</operator><name>reply_message</name></expr></argument>, <argument><expr><call><name>GetCurrentTimestamp</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pq_sendbyte</name><argument_list>(<argument><expr><operator>&amp;</operator><name>reply_message</name></expr></argument>, <argument><expr><ternary><condition><expr><name>requestReply</name></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>polar_in_replica_mode</name><argument_list>()</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><specifier>static</specifier> <name>XLogRecPtr</name></type> <name>bg_replayed_lsn</name> <init>= <expr><name>InvalidXLogRecPtr</name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>XLogRecPtrIsInvalid</name><argument_list>(<argument><expr><name>applyPtr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* POLAR: return the oldest ddl lock lsn if enable async ddl lock */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>polar_allow_async_ddl_lock_replay</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>polar_lock_replay_lsn</name> <operator>=</operator> <call><name>polar_get_async_lock_replay_rec_ptr</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>polar_lock_replay_lsn</name> <operator>=</operator> <name>applyPtr</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<expr_stmt><expr><call><name>pq_sendint64</name><argument_list>(<argument><expr><operator>&amp;</operator><name>reply_message</name></expr></argument>, <argument><expr><name>polar_lock_replay_lsn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG3</name></expr></argument>, <argument><expr><literal type="string">"polar_lock_replay_lsn: %X/%X"</literal></expr></argument>, <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <operator>(</operator><name>polar_lock_replay_lsn</name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr></argument>, <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <name>polar_lock_replay_lsn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* POLAR: useless message, original value of polar_ro_is_invalid, keep it for upgrade compatibility */</comment>
		<expr_stmt><expr><call><name>pq_sendbyte</name><argument_list>(<argument><expr><operator>&amp;</operator><name>reply_message</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* 
		 * POLAR: Send background replay lsn. Even if page outdate is disabled, 
		 * it also send a lsn to keep protocol compatibility.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>polar_in_replica_mode</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <call><name>POLAR_LOGINDEX_ENABLE_XLOG_QUEUE</name><argument_list>()</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><specifier>static</specifier> <name>TimestampTz</name></type> <name>last_update_time</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><specifier>static</specifier> <name>XLogRecPtr</name></type>  <name>last_bg_replayed_lsn</name> <init>= <expr><name>InvalidXLogRecPtr</name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>TimestampTz</name></type> <name>now</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>now</name> <operator>=</operator> <call><name>GetCurrentTimestamp</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* 
			 * POLAR: Page replay in backend process need xlog after consistent lsn, 
			 * so we should keep xlog after consisten lsn. To avoid holding ProcArrayLock
			 * too frequently, we call polar_get_read_min_lsn() every second.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>TimestampDifferenceExceeds</name><argument_list>(<argument><expr><name>last_update_time</name></expr></argument>, <argument><expr><name>now</name></expr></argument>, <argument><expr><name>POLAR_UPDATE_BACKEND_LSN_INTERVAL</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>last_bg_replayed_lsn</name> <operator>=</operator> <call><name>polar_get_read_min_lsn</name><argument_list>(<argument><expr><call><name>polar_get_primary_consist_ptr</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>last_update_time</name> <operator>=</operator> <name>now</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			<expr_stmt><expr><name>bg_replayed_lsn</name> <operator>=</operator> <name>last_bg_replayed_lsn</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>bg_replayed_lsn</name> <operator>=</operator> <name>InvalidXLogRecPtr</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
		<expr_stmt><expr><call><name>pq_sendint64</name><argument_list>(<argument><expr><operator>&amp;</operator><name>reply_message</name></expr></argument>, <argument><expr><name>bg_replayed_lsn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Send it */</comment>
	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG2</name></expr></argument>, <argument><expr><literal type="string">"sending write %X/%X flush %X/%X apply %X/%X%s"</literal></expr></argument>,
		 <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <operator>(</operator><name>writePtr</name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr></argument>, <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <name>writePtr</name></expr></argument>,
		 <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <operator>(</operator><name>flushPtr</name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr></argument>, <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <name>flushPtr</name></expr></argument>,
		 <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <operator>(</operator><name>applyPtr</name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr></argument>, <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <name>applyPtr</name></expr></argument>,
		 <argument><expr><ternary><condition><expr><name>requestReply</name></expr> ?</condition><then> <expr><literal type="string">" (reply requested)"</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>walrcv_send</name><argument_list>(<argument><expr><name>wrconn</name></expr></argument>, <argument><expr><name><name>reply_message</name><operator>.</operator><name>data</name></name></expr></argument>, <argument><expr><name><name>reply_message</name><operator>.</operator><name>len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Send hot standby feedback message to primary, plus the current time,
 * in case they don't have a watch.
 *
 * If the user disables feedback, send one final message to tell sender
 * to forget about the xmin on this standby. We also send this message
 * on first connect because a previous connection might have set xmin
 * on a replication slot. (If we're not using a slot it's harmless to
 * send a feedback message explicitly setting InvalidTransactionId).
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>XLogWalRcvSendHSFeedback</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>immed</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TimestampTz</name></type> <name>now</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TransactionId</name></type> <name>nextXid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32</name></type>		<name>xmin_epoch</name></decl>,
				<decl><type ref="prev"/><name>catalog_xmin_epoch</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TransactionId</name></type> <name>xmin</name></decl>,
				<decl><type ref="prev"/><name>catalog_xmin</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>static</specifier> <name>TimestampTz</name></type> <name>sendTime</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<comment type="block">/* initially true so we always send at least one feedback message */</comment>
	<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type> <name>master_has_standby_xmin</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * If the user doesn't want status to be reported to the master, be sure
	 * to exit before doing anything at all.
	 * POLAR: set polar_standby_feedback to false to disable hot_standby_feedback
	 * in polar standby
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>wal_receiver_status_interval</name> <operator>&lt;=</operator> <literal type="number">0</literal> <operator>||</operator>
		<operator>!</operator><call><name>POLAR_ENABLE_FEEDBACK</name><argument_list>()</argument_list></call><operator>)</operator> <operator>&amp;&amp;</operator>
		<operator>!</operator><name>master_has_standby_xmin</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/* Get current timestamp. */</comment>
	<expr_stmt><expr><name>now</name> <operator>=</operator> <call><name>GetCurrentTimestamp</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>immed</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Send feedback at most once per wal_receiver_status_interval.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>TimestampDifferenceExceeds</name><argument_list>(<argument><expr><name>sendTime</name></expr></argument>, <argument><expr><name>now</name></expr></argument>,
										<argument><expr><name>wal_receiver_status_interval</name> <operator>*</operator> <literal type="number">1000</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<return>return;</return></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>sendTime</name> <operator>=</operator> <name>now</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * If Hot Standby is not yet accepting connections there is nothing to
	 * send. Check this after the interval has expired to reduce number of
	 * calls.
	 *
	 * Bailing out here also ensures that we don't send feedback until we've
	 * read our own replication slot state, so we don't tell the master to
	 * discard needed xmin or catalog_xmin from any slots that may exist on
	 * this replica.
	 */</comment>
	<comment type="block">/* POLAR: Allow to send feedback in datamax mode */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HotStandbyActive</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>polar_is_datamax</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Make the expensive call to get the oldest xmin once we are certain
	 * everything else has been checked.
	 * POLAR: set polar_standby_feedback to true to enable hot_standby_feedback
	 * in polar standby
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>POLAR_ENABLE_FEEDBACK</name><argument_list>()</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>TransactionId</name></type> <name>slot_xmin</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * Usually GetOldestXmin() would include both global replication slot
		 * xmin and catalog_xmin in its calculations, but we want to derive
		 * separate values for each of those. So we ask for an xmin that
		 * excludes the catalog_xmin.
		 */</comment>
		<expr_stmt><expr><name>xmin</name> <operator>=</operator> <call><name>GetOldestXmin</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>,
							 <argument><expr><name>PROCARRAY_FLAGS_DEFAULT</name> <operator>|</operator> <name>PROCARRAY_SLOTS_XMIN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>ProcArrayGetReplicationSlotXmin</name><argument_list>(<argument><expr><operator>&amp;</operator><name>slot_xmin</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>catalog_xmin</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>TransactionIdIsValid</name><argument_list>(<argument><expr><name>slot_xmin</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
			<call><name>TransactionIdPrecedes</name><argument_list>(<argument><expr><name>slot_xmin</name></expr></argument>, <argument><expr><name>xmin</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>xmin</name> <operator>=</operator> <name>slot_xmin</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		
		<comment type="block">/* 
		 * POLAR: Don't consider oldestXmin in datamax mode
		 * otherwise when datamax_oldestXmin &lt; slot_xmin, datamax_oldestXmin 
		 * will be sent to primary, which will infect the vacuum process of primary, 
		 * but primary only cares about the xmin of standby in fact
		 * datamax just records and sends them to primary
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>polar_is_datamax</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>xmin</name> <operator>=</operator> <name>slot_xmin</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<comment type="block">/* POLAR end */</comment>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name>xmin</name> <operator>=</operator> <name>InvalidTransactionId</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>catalog_xmin</name> <operator>=</operator> <name>InvalidTransactionId</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/*
	 * Get epoch and adjust if nextXid and oldestXmin are different sides of
	 * the epoch boundary.
	 */</comment>
	<comment type="block">/*
	 * POLAR: get nextXid and epoch from polar_datamax_ctl when in datamax mode
	 * we have checked the sanity of xmin feedbacked by standby in ProcessStandbyHSFeedbackMessage func
	 * and there is no primary's data in datamax node
	 * so we can feedback the epoch according to primary's epoch recorded in polar_datamax_ctl
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>polar_is_datamax</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>GetNextXidAndEpoch</name><argument_list>(<argument><expr><operator>&amp;</operator><name>nextXid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>xmin_epoch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name>nextXid</name> <operator>=</operator> <call><name>pg_atomic_read_u32</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>polar_datamax_ctl</name><operator>-&gt;</operator><name>polar_primary_next_xid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>xmin_epoch</name> <operator>=</operator> <call><name>pg_atomic_read_u32</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>polar_datamax_ctl</name><operator>-&gt;</operator><name>polar_primary_epoch</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
	<comment type="block">/* POLAR end */</comment>
	<expr_stmt><expr><name>catalog_xmin_epoch</name> <operator>=</operator> <name>xmin_epoch</name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>nextXid</name> <operator>&lt;</operator> <name>xmin</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>xmin_epoch</name><operator>--</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>nextXid</name> <operator>&lt;</operator> <name>catalog_xmin</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>catalog_xmin_epoch</name><operator>--</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG2</name></expr></argument>, <argument><expr><literal type="string">"sending hot standby feedback xmin %u epoch %u catalog_xmin %u catalog_xmin_epoch %u"</literal></expr></argument>,
		 <argument><expr><name>xmin</name></expr></argument>, <argument><expr><name>xmin_epoch</name></expr></argument>, <argument><expr><name>catalog_xmin</name></expr></argument>, <argument><expr><name>catalog_xmin_epoch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Construct the message and send it. */</comment>
	<expr_stmt><expr><call><name>resetStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>reply_message</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pq_sendbyte</name><argument_list>(<argument><expr><operator>&amp;</operator><name>reply_message</name></expr></argument>, <argument><expr><literal type="char">'h'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pq_sendint64</name><argument_list>(<argument><expr><operator>&amp;</operator><name>reply_message</name></expr></argument>, <argument><expr><call><name>GetCurrentTimestamp</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pq_sendint32</name><argument_list>(<argument><expr><operator>&amp;</operator><name>reply_message</name></expr></argument>, <argument><expr><name>xmin</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pq_sendint32</name><argument_list>(<argument><expr><operator>&amp;</operator><name>reply_message</name></expr></argument>, <argument><expr><name>xmin_epoch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pq_sendint32</name><argument_list>(<argument><expr><operator>&amp;</operator><name>reply_message</name></expr></argument>, <argument><expr><name>catalog_xmin</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pq_sendint32</name><argument_list>(<argument><expr><operator>&amp;</operator><name>reply_message</name></expr></argument>, <argument><expr><name>catalog_xmin_epoch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>walrcv_send</name><argument_list>(<argument><expr><name>wrconn</name></expr></argument>, <argument><expr><name><name>reply_message</name><operator>.</operator><name>data</name></name></expr></argument>, <argument><expr><name><name>reply_message</name><operator>.</operator><name>len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>TransactionIdIsValid</name><argument_list>(<argument><expr><name>xmin</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>TransactionIdIsValid</name><argument_list>(<argument><expr><name>catalog_xmin</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>master_has_standby_xmin</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>master_has_standby_xmin</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Update shared memory status upon receiving a message from primary.
 *
 * 'walEnd' and 'sendTime' are the end-of-WAL and timestamp of the latest
 * message, reported by primary.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ProcessWalSndrMessage</name><parameter_list>(<parameter><decl><type><name>XLogRecPtr</name></type> <name>walEnd</name></decl></parameter>, <parameter><decl><type><name>TimestampTz</name></type> <name>sendTime</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>WalRcvData</name> <modifier>*</modifier></type><name>walrcv</name> <init>= <expr><name>WalRcv</name></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>TimestampTz</name></type> <name>lastMsgReceiptTime</name> <init>= <expr><call><name>GetCurrentTimestamp</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/* Update shared-memory status */</comment>
	<expr_stmt><expr><call><name>SpinLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>walrcv</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>walrcv</name><operator>-&gt;</operator><name>latestWalEnd</name></name> <operator>&lt;</operator> <name>walEnd</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>walrcv</name><operator>-&gt;</operator><name>latestWalEndTime</name></name> <operator>=</operator> <name>sendTime</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name><name>walrcv</name><operator>-&gt;</operator><name>latestWalEnd</name></name> <operator>=</operator> <name>walEnd</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>walrcv</name><operator>-&gt;</operator><name>lastMsgSendTime</name></name> <operator>=</operator> <name>sendTime</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>walrcv</name><operator>-&gt;</operator><name>lastMsgReceiptTime</name></name> <operator>=</operator> <name>lastMsgReceiptTime</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SpinLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>walrcv</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>log_min_messages</name> <operator>&lt;=</operator> <name>DEBUG2</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>sendtime</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>receipttime</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>applyDelay</name></decl>;</decl_stmt>

		<comment type="block">/* Copy because timestamptz_to_str returns a static buffer */</comment>
		<expr_stmt><expr><name>sendtime</name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><call><name>timestamptz_to_str</name><argument_list>(<argument><expr><name>sendTime</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>receipttime</name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><call><name>timestamptz_to_str</name><argument_list>(<argument><expr><name>lastMsgReceiptTime</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>applyDelay</name> <operator>=</operator> <call><name>GetReplicationApplyDelay</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* apply delay is not available */</comment>
		<if_stmt><if>if <condition>(<expr><name>applyDelay</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG2</name></expr></argument>, <argument><expr><literal type="string">"sendtime %s receipttime %s replication apply delay (N/A) transfer latency %d ms"</literal></expr></argument>,
				 <argument><expr><name>sendtime</name></expr></argument>,
				 <argument><expr><name>receipttime</name></expr></argument>,
				 <argument><expr><call><name>GetReplicationTransferLatency</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG2</name></expr></argument>, <argument><expr><literal type="string">"sendtime %s receipttime %s replication apply delay %d ms transfer latency %d ms"</literal></expr></argument>,
				 <argument><expr><name>sendtime</name></expr></argument>,
				 <argument><expr><name>receipttime</name></expr></argument>,
				 <argument><expr><name>applyDelay</name></expr></argument>,
				 <argument><expr><call><name>GetReplicationTransferLatency</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>sendtime</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>receipttime</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Wake up the walreceiver main loop.
 *
 * This is called by the startup process whenever interesting xlog records
 * are applied, so that walreceiver can check if it needs to send an apply
 * notification back to the master which may be waiting in a COMMIT with
 * synchronous_commit = remote_apply.
 */</comment>
<function><type><name>void</name></type>
<name>WalRcvForceReply</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Latch</name>	   <modifier>*</modifier></type><name>latch</name></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>WalRcv</name><operator>-&gt;</operator><name>force_reply</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<comment type="block">/* fetching the latch pointer might not be atomic, so use spinlock */</comment>
	<expr_stmt><expr><call><name>SpinLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>WalRcv</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>latch</name> <operator>=</operator> <name><name>WalRcv</name><operator>-&gt;</operator><name>latch</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SpinLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>WalRcv</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>latch</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>SetLatch</name><argument_list>(<argument><expr><name>latch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Return a string constant representing the state. This is used
 * in system functions and views, and should *not* be translated.
 */</comment>
<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>
<name>WalRcvGetStateString</name><parameter_list>(<parameter><decl><type><name>WalRcvState</name></type> <name>state</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<switch>switch <condition>(<expr><name>state</name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>WALRCV_STOPPED</name></expr>:</case>
			<return>return <expr><literal type="string">"stopped"</literal></expr>;</return>
		<case>case <expr><name>WALRCV_STARTING</name></expr>:</case>
			<return>return <expr><literal type="string">"starting"</literal></expr>;</return>
		<case>case <expr><name>WALRCV_STREAMING</name></expr>:</case>
			<return>return <expr><literal type="string">"streaming"</literal></expr>;</return>
		<case>case <expr><name>WALRCV_WAITING</name></expr>:</case>
			<return>return <expr><literal type="string">"waiting"</literal></expr>;</return>
		<case>case <expr><name>WALRCV_RESTARTING</name></expr>:</case>
			<return>return <expr><literal type="string">"restarting"</literal></expr>;</return>
		<case>case <expr><name>WALRCV_STOPPING</name></expr>:</case>
			<return>return <expr><literal type="string">"stopping"</literal></expr>;</return>
	</block_content>}</block></switch>
	<return>return <expr><literal type="string">"UNKNOWN"</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Returns activity of WAL receiver, including pid, state and xlog locations
 * received from the WAL sender of another server.
 */</comment>
<function><type><name>Datum</name></type>
<name>pg_stat_get_wal_receiver</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TupleDesc</name></type>	<name>tupdesc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name>	   <modifier>*</modifier></type><name>values</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name>	   <modifier>*</modifier></type><name>nulls</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>pid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>ready_to_display</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>WalRcvState</name></type> <name>state</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>XLogRecPtr</name></type>	<name>receive_start_lsn</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TimeLineID</name></type>	<name>receive_start_tli</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>XLogRecPtr</name></type>	<name>received_lsn</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TimeLineID</name></type>	<name>received_tli</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TimestampTz</name></type> <name>last_send_time</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TimestampTz</name></type> <name>last_receipt_time</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>XLogRecPtr</name></type>	<name>latest_end_lsn</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TimestampTz</name></type> <name>latest_end_time</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>sender_host</name><index>[<expr><name>NI_MAXHOST</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>sender_port</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>slotname</name><index>[<expr><name>NAMEDATALEN</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>conninfo</name><index>[<expr><name>MAXCONNINFO</name></expr>]</index></name></decl>;</decl_stmt>

	<comment type="block">/* Take a lock to ensure value consistency */</comment>
	<expr_stmt><expr><call><name>SpinLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>WalRcv</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>pid</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator> <name><name>WalRcv</name><operator>-&gt;</operator><name>pid</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>ready_to_display</name> <operator>=</operator> <name><name>WalRcv</name><operator>-&gt;</operator><name>ready_to_display</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>state</name> <operator>=</operator> <name><name>WalRcv</name><operator>-&gt;</operator><name>walRcvState</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>receive_start_lsn</name> <operator>=</operator> <name><name>WalRcv</name><operator>-&gt;</operator><name>receiveStart</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>receive_start_tli</name> <operator>=</operator> <name><name>WalRcv</name><operator>-&gt;</operator><name>receiveStartTLI</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>received_lsn</name> <operator>=</operator> <name><name>WalRcv</name><operator>-&gt;</operator><name>receivedUpto</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>received_tli</name> <operator>=</operator> <name><name>WalRcv</name><operator>-&gt;</operator><name>receivedTLI</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>last_send_time</name> <operator>=</operator> <name><name>WalRcv</name><operator>-&gt;</operator><name>lastMsgSendTime</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>last_receipt_time</name> <operator>=</operator> <name><name>WalRcv</name><operator>-&gt;</operator><name>lastMsgReceiptTime</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>latest_end_lsn</name> <operator>=</operator> <name><name>WalRcv</name><operator>-&gt;</operator><name>latestWalEnd</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>latest_end_time</name> <operator>=</operator> <name><name>WalRcv</name><operator>-&gt;</operator><name>latestWalEndTime</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>strlcpy</name><argument_list>(<argument><expr><name>slotname</name></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name><name>WalRcv</name><operator>-&gt;</operator><name>slotname</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>slotname</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>strlcpy</name><argument_list>(<argument><expr><name>sender_host</name></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name><name>WalRcv</name><operator>-&gt;</operator><name>sender_host</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>sender_host</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>sender_port</name> <operator>=</operator> <name><name>WalRcv</name><operator>-&gt;</operator><name>sender_port</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>strlcpy</name><argument_list>(<argument><expr><name>conninfo</name></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name><name>WalRcv</name><operator>-&gt;</operator><name>conninfo</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>conninfo</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SpinLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>WalRcv</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * No WAL receiver (or not ready yet), just return a tuple with NULL
	 * values
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>pid</name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <operator>!</operator><name>ready_to_display</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* determine result type */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>get_call_result_type</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tupdesc</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>TYPEFUNC_COMPOSITE</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"return type must be a row type"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>values</name> <operator>=</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Datum</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>tupdesc</name><operator>-&gt;</operator><name>natts</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>nulls</name> <operator>=</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>tupdesc</name><operator>-&gt;</operator><name>natts</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Fetch values */</comment>
	<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>Int32GetDatum</name><argument_list>(<argument><expr><name>pid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>is_member_of_role</name><argument_list>(<argument><expr><call><name>GetUserId</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>DEFAULT_ROLE_READ_ALL_STATS</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Only superusers and members of pg_read_all_stats can see details.
		 * Other users only get the pid value to know whether it is a WAL
		 * receiver, but no details.
		 */</comment>
		<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>nulls</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <operator>(</operator><name><name>tupdesc</name><operator>-&gt;</operator><name>natts</name></name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>CStringGetTextDatum</name><argument_list>(<argument><expr><call><name>WalRcvGetStateString</name><argument_list>(<argument><expr><name>state</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>XLogRecPtrIsInvalid</name><argument_list>(<argument><expr><name>receive_start_lsn</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>nulls</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <call><name>LSNGetDatum</name><argument_list>(<argument><expr><name>receive_start_lsn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
		<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>=</operator> <call><name>Int32GetDatum</name><argument_list>(<argument><expr><name>receive_start_tli</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>XLogRecPtrIsInvalid</name><argument_list>(<argument><expr><name>received_lsn</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>nulls</name><index>[<expr><literal type="number">4</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">4</literal></expr>]</index></name> <operator>=</operator> <call><name>LSNGetDatum</name><argument_list>(<argument><expr><name>received_lsn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
		<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">5</literal></expr>]</index></name> <operator>=</operator> <call><name>Int32GetDatum</name><argument_list>(<argument><expr><name>received_tli</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>last_send_time</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>nulls</name><index>[<expr><literal type="number">6</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">6</literal></expr>]</index></name> <operator>=</operator> <call><name>TimestampTzGetDatum</name><argument_list>(<argument><expr><name>last_send_time</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
		<if_stmt><if>if <condition>(<expr><name>last_receipt_time</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>nulls</name><index>[<expr><literal type="number">7</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">7</literal></expr>]</index></name> <operator>=</operator> <call><name>TimestampTzGetDatum</name><argument_list>(<argument><expr><name>last_receipt_time</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>XLogRecPtrIsInvalid</name><argument_list>(<argument><expr><name>latest_end_lsn</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>nulls</name><index>[<expr><literal type="number">8</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">8</literal></expr>]</index></name> <operator>=</operator> <call><name>LSNGetDatum</name><argument_list>(<argument><expr><name>latest_end_lsn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
		<if_stmt><if>if <condition>(<expr><name>latest_end_time</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>nulls</name><index>[<expr><literal type="number">9</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">9</literal></expr>]</index></name> <operator>=</operator> <call><name>TimestampTzGetDatum</name><argument_list>(<argument><expr><name>latest_end_time</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
		<if_stmt><if>if <condition>(<expr><operator>*</operator><name>slotname</name> <operator>==</operator> <literal type="char">'\0'</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>nulls</name><index>[<expr><literal type="number">10</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">10</literal></expr>]</index></name> <operator>=</operator> <call><name>CStringGetTextDatum</name><argument_list>(<argument><expr><name>slotname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
		<if_stmt><if>if <condition>(<expr><operator>*</operator><name>sender_host</name> <operator>==</operator> <literal type="char">'\0'</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>nulls</name><index>[<expr><literal type="number">11</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">11</literal></expr>]</index></name> <operator>=</operator> <call><name>CStringGetTextDatum</name><argument_list>(<argument><expr><name>sender_host</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
		<if_stmt><if>if <condition>(<expr><name>sender_port</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>nulls</name><index>[<expr><literal type="number">12</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">12</literal></expr>]</index></name> <operator>=</operator> <call><name>Int32GetDatum</name><argument_list>(<argument><expr><name>sender_port</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
		<if_stmt><if>if <condition>(<expr><operator>*</operator><name>conninfo</name> <operator>==</operator> <literal type="char">'\0'</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>nulls</name><index>[<expr><literal type="number">13</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">13</literal></expr>]</index></name> <operator>=</operator> <call><name>CStringGetTextDatum</name><argument_list>(<argument><expr><name>conninfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/* Returns the record as Datum */</comment>
	<expr_stmt><expr><call><name>PG_RETURN_DATUM</name><argument_list>(<argument><expr><call><name>HeapTupleGetDatum</name><argument_list>(<argument><expr><call><name>heap_form_tuple</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><name>values</name></expr></argument>, <argument><expr><name>nulls</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * POLAR: This is callback function used when waiting free space from
 * polar_xlog_queue.It will send feedback and handle interrupts
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>polar_receiver_xlog_queue_callback</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>ProcessWalRcvInterrupts</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>XLogWalRcvSendReply</name><argument_list>(<argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>XLogWalRcvSendHSFeedback</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>polar_notify_read_wal_file</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>code</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * POLAR: The wal receiver is exiting, tell startup to read from file if it want to read more xlog.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>got_SIGTERM</name> <operator>&amp;&amp;</operator> <call><name>polar_in_replica_mode</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <call><name>POLAR_LOGINDEX_ENABLE_XLOG_QUEUE</name><argument_list>()</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"polar replica exit wal receiver and request to read from WAL file"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>polar_xlog_recv_queue_push_storage_begin</name><argument_list>(<argument><expr><name><name>polar_logindex_redo_instance</name><operator>-&gt;</operator><name>xlog_queue</name></name></expr></argument>, <argument><expr><name>ProcessWalRcvInterrupts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * POLAR: get lastMsgReceiptTime
 */</comment>
<function><type><name>TimestampTz</name></type>
<name>polar_get_walrcv_last_msg_receipt_time</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>WalRcvData</name> <modifier>*</modifier></type><name>walrcv</name> <init>= <expr><name>WalRcv</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TimestampTz</name></type> <name>last_msg_receipt_time</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>SpinLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>walrcv</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>last_msg_receipt_time</name> <operator>=</operator> <name><name>walrcv</name><operator>-&gt;</operator><name>lastMsgReceiptTime</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SpinLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>walrcv</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>last_msg_receipt_time</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * POLAR: Judge whether promote request is necessary to be sent to walsender
 * 1) if promote is triggered in current instance, send request when 
 * polar_enable_promote_wait_for_walreceive_done = on and WalRcv received promote trigger;
 * 2) if promote is triggered in downstream instance, send request when
 * WalSnd received promote trigger from downstream;
 * 3) at last, send request when we haven't received promote reply from walsender after timeout. 
 * 
 * Return true if it is necessary to send request to walsender.
 * Return false if it is unnecessary to send request to walsender.
 */</comment>
<function><type><name>bool</name></type>
<name>polar_send_promote_request</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>static</specifier> <name>TimestampTz</name></type> <name>last_send_time</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	
	<comment type="block">/* walrcv already exists when call this func */</comment>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><operator>(</operator><name>polar_enable_promote_wait_for_walreceive_done</name> <operator>&amp;&amp;</operator> <call><name>POLAR_PROMOTE_IS_TRIGGERED</name><argument_list>()</argument_list></call><operator>)</operator> <operator>||</operator> <call><name>POLAR_WALSNDCTL_RECEIVE_PROMOTE_TRIGGER</name><argument_list>()</argument_list></call><operator>)</operator>
		<operator>&amp;&amp;</operator> <operator>!</operator><call><name>POLAR_PROMOTE_REPLY_IS_RECEIVED</name><argument_list>()</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>TimestampTz</name></type> <name>send_now</name> <init>= <expr><call><name>GetCurrentTimestamp</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if<condition>(<expr><call><name>TimestampDifferenceExceeds</name><argument_list>(<argument><expr><name>last_send_time</name></expr></argument>, <argument><expr><name>send_now</name></expr></argument>, <argument><expr><name>POLAR_SEND_PROMOTE_REQUEST_TIMEOUT</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>last_send_time</name> <operator>=</operator> <name>send_now</name></expr>;</expr_stmt>
			<return>return <expr><name>true</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>POLAR_PROMOTE_REPLY_IS_RECEIVED</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>last_send_time</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
	
	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* POLAR: send promote information to walsender */</comment>
<function><type><name>void</name></type>
<name>polar_walrcv_send_promote</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>polar_request_reply</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type> <name>polar_promote_trigger</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>resetStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>reply_message</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pq_sendbyte</name><argument_list>(<argument><expr><operator>&amp;</operator><name>reply_message</name></expr></argument>, <argument><expr><literal type="char">'p'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pq_sendbyte</name><argument_list>(<argument><expr><operator>&amp;</operator><name>reply_message</name></expr></argument>, <argument><expr><name>polar_promote_trigger</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pq_sendbyte</name><argument_list>(<argument><expr><operator>&amp;</operator><name>reply_message</name></expr></argument>, <argument><expr><ternary><condition><expr><name>polar_request_reply</name></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,<argument><expr><literal type="string">"send promote trigger %d, polar_request_reply:%d"</literal></expr></argument>, <argument><expr><name>polar_promote_trigger</name></expr></argument>, <argument><expr><name>polar_request_reply</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>walrcv_send</name><argument_list>(<argument><expr><name>wrconn</name></expr></argument>, <argument><expr><name><name>reply_message</name><operator>.</operator><name>data</name></name></expr></argument>, <argument><expr><name><name>reply_message</name><operator>.</operator><name>len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* POLAR: process promote reply received from walsender */</comment>
<function><type><name>void</name></type>
<name>polar_process_walsender_reply</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>is_promote_allowed</name></decl></parameter>, <parameter><decl><type><name>XLogRecPtr</name></type> <name>end_lsn</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>WalRcv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* already receive and process reply */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>POLAR_PROMOTE_REPLY_IS_RECEIVED</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* promote is allowed */</comment>
		<if_stmt><if>if <condition>(<expr><name>is_promote_allowed</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>XLogRecPtrIsInvalid</name><argument_list>(<argument><expr><name>end_lsn</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>POLAR_SET_END_LSN</name><argument_list>(<argument><expr><name>end_lsn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if>
		<comment type="block">/* disable promote */</comment>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>POLAR_SET_PROMOTE_NOT_ALLOWED</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<comment type="block">/* having received reply from walsender, don't send promote request to walsender again */</comment>
		<expr_stmt><expr><call><name>POLAR_SET_RECEIVE_PROMOTE_REPLY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>	
		
		<comment type="block">/* tell walsender we have received reply, so walsender won't send reply again */</comment>
		<expr_stmt><expr><call><name>polar_walrcv_send_promote</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/* POLAR: get end_lsn when received promote request from downstream */</comment>
<function><type><name>XLogRecPtr</name></type>
<name>polar_promote_get_end_lsn</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>XLogRecPtr</name></type> <name>end_lsn</name> <init>= <expr><name>InvalidXLogRecPtr</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>end_lsn</name> <operator>=</operator> <call><name>pg_atomic_read_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>WalRcv</name><operator>-&gt;</operator><name>polar_latest_flush_lsn</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* polar_latest_flush_lsn is 0 when datamax/standby restart and no walrcvstream */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>XLogRecPtrIsInvalid</name><argument_list>(<argument><expr><name>end_lsn</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>polar_is_datamax</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>end_lsn</name> <operator>=</operator> <call><name>polar_datamax_get_last_received_lsn</name><argument_list>(<argument><expr><name>polar_datamax_ctl</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>end_lsn</name> <operator>=</operator> <call><name>GetXLogReplayRecPtr</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><name>end_lsn</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* 
 * POLAR: judge whether upstream node state is alive via WalStreaming
 * return true when upstream node can be connected rightly, which is walreceiver is ready
 */</comment>
<function><type><name>bool</name></type>
<name>polar_upstream_node_is_alive</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>pid</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>ready_to_display</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>WalRcv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>SpinLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>WalRcv</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>pid</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator> <name><name>WalRcv</name><operator>-&gt;</operator><name>pid</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>ready_to_display</name> <operator>=</operator> <name><name>WalRcv</name><operator>-&gt;</operator><name>ready_to_display</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SpinLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>WalRcv</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><operator>(</operator><name>pid</name> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>ready_to_display</name><operator>)</operator></expr>;</return>
</block_content>}</block></function> 

<comment type="block">/* 
 * POLAR: judge whether having received all wal
 * if so, set polar_is_promote_allowed = true indicates that promote can be executed now 
 */</comment>
<function><type><name>void</name></type> 
<name>polar_promote_check_received_all_wal</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>WalRcv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>POLAR_IS_PROMOTE_NOT_ALLOWED</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> 
		<operator>!</operator><call><name>POLAR_IS_END_LSN_INVALID</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> 
		<operator>!</operator><call><name>POLAR_IS_PROMOTE_ALLOWED</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator>
		<call><name>pg_atomic_read_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>WalRcv</name><operator>-&gt;</operator><name>polar_end_lsn</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <name><name>LogstreamResult</name><operator>.</operator><name>Flush</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,<argument><expr><literal type="string">"polar_endlsn:%lx, flush_lsn:%lx, received all wal, promote is allowed"</literal></expr></argument>, <argument><expr><call><name>pg_atomic_read_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>WalRcv</name><operator>-&gt;</operator><name>polar_end_lsn</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>LogstreamResult</name><operator>.</operator><name>Flush</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>POLAR_SET_PROMOTE_ALLOWED</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>
<comment type="block">/* POLAR end */</comment>

<comment type="block">/*
 * POLAR: return received LSN in DMA mode
 */</comment>
<function><type><name>XLogRecPtr</name></type> <name>polar_dma_get_received_lsn</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>XLogRecPtr</name></type>	<name>receivePtr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TimeLineID</name></type>	<name>receiveTLI</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>ConsensusGetXLogFlushedLSN</name><argument_list>(<argument><expr><operator>&amp;</operator><name>receivePtr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>receiveTLI</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>receivePtr</name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/* POLAR end */</comment>

</unit>
