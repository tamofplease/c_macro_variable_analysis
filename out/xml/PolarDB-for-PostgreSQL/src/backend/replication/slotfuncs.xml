<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/PolarDB-for-PostgreSQL/src/backend/replication/slotfuncs.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * slotfuncs.c
 *	   Support functions for replication slots
 *
 * Copyright (c) 2012-2018, PostgreSQL Global Development Group
 *
 * IDENTIFICATION
 *	  src/backend/replication/slotfuncs.c
 *
 *-------------------------------------------------------------------------
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"funcapi.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/htup_details.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"replication/decode.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"replication/slot.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"replication/logical.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"replication/logicalfuncs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/builtins.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/inval.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/pg_lsn.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/resowner.h"</cpp:file></cpp:include>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>check_permissions</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>superuser</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>has_rolreplication</name><argument_list>(<argument><expr><call><name>GetUserId</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INSUFFICIENT_PRIVILEGE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"must be superuser or replication role to use replication slots"</literal></expr></argument>)</argument_list></call><operator>)</operator><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * SQL function for creating a new physical (streaming replication)
 * replication slot.
 */</comment>
<function><type><name>Datum</name></type>
<name>pg_create_physical_replication_slot</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Name</name></type>		<name>name</name> <init>= <expr><call><name>PG_GETARG_NAME</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>immediately_reserve</name> <init>= <expr><call><name>PG_GETARG_BOOL</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>temporary</name> <init>= <expr><call><name>PG_GETARG_BOOL</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type>		<name><name>values</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name><name>nulls</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleDesc</name></type>	<name>tupdesc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type>		<name>result</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>MyReplicationSlot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>get_call_result_type</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tupdesc</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>TYPEFUNC_COMPOSITE</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"return type must be a row type"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>check_permissions</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>CheckSlotRequirements</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* acquire replication slot, this will check for conflicting names */</comment>
	<expr_stmt><expr><call><name>ReplicationSlotCreate</name><argument_list>(<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><operator>*</operator><name>name</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>false</name></expr></argument>,
						  <argument><expr><ternary><condition><expr><name>temporary</name></expr> ?</condition><then> <expr><name>RS_TEMPORARY</name></expr> </then><else>: <expr><name>RS_PERSISTENT</name></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>NameGetDatum</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>MyReplicationSlot</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>nulls</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>immediately_reserve</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Reserve WAL as the user asked for it */</comment>
		<expr_stmt><expr><call><name>ReplicationSlotReserveWal</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Write this slot to disk */</comment>
		<expr_stmt><expr><call><name>ReplicationSlotMarkDirty</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ReplicationSlotSave</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>LSNGetDatum</name><argument_list>(<argument><expr><name><name>MyReplicationSlot</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>restart_lsn</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>nulls</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name><name>nulls</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>heap_form_tuple</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><name>values</name></expr></argument>, <argument><expr><name>nulls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>HeapTupleGetDatum</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ReplicationSlotRelease</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_DATUM</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * SQL function for creating a new logical replication slot.
 */</comment>
<function><type><name>Datum</name></type>
<name>pg_create_logical_replication_slot</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Name</name></type>		<name>name</name> <init>= <expr><call><name>PG_GETARG_NAME</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Name</name></type>		<name>plugin</name> <init>= <expr><call><name>PG_GETARG_NAME</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>temporary</name> <init>= <expr><call><name>PG_GETARG_BOOL</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>LogicalDecodingContext</name> <modifier>*</modifier></type><name>ctx</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>TupleDesc</name></type>	<name>tupdesc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type>		<name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type>		<name><name>values</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name><name>nulls</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>MyReplicationSlot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>get_call_result_type</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tupdesc</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>TYPEFUNC_COMPOSITE</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"return type must be a row type"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>check_permissions</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>CheckLogicalDecodingRequirements</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Acquire a logical decoding slot, this will check for conflicting names.
	 * Initially create persistent slot as ephemeral - that allows us to
	 * nicely handle errors during initialization because it'll get dropped if
	 * this transaction fails. We'll make it persistent at the end. Temporary
	 * slots can be created as temporary from beginning as they get dropped on
	 * error as well.
	 */</comment>
	<expr_stmt><expr><call><name>ReplicationSlotCreate</name><argument_list>(<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><operator>*</operator><name>name</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>true</name></expr></argument>,
						  <argument><expr><ternary><condition><expr><name>temporary</name></expr> ?</condition><then> <expr><name>RS_TEMPORARY</name></expr> </then><else>: <expr><name>RS_EPHEMERAL</name></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Create logical decoding context, to build the initial snapshot.
	 */</comment>
	<expr_stmt><expr><name>ctx</name> <operator>=</operator> <call><name>CreateInitDecodingContext</name><argument_list>(<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><operator>*</operator><name>plugin</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>NIL</name></expr></argument>,
									<argument><expr><name>false</name></expr></argument>,	<comment type="block">/* do not build snapshot */</comment>
									<argument><expr><name>logical_read_local_xlog_page</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
									<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* build initial snapshot, might take a while */</comment>
	<expr_stmt><expr><call><name>DecodingContextFindStartpoint</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>CStringGetTextDatum</name><argument_list>(<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>MyReplicationSlot</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>LSNGetDatum</name><argument_list>(<argument><expr><name><name>MyReplicationSlot</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>confirmed_flush</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* don't need the decoding context anymore */</comment>
	<expr_stmt><expr><call><name>FreeDecodingContext</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>nulls</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>nulls</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>heap_form_tuple</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><name>values</name></expr></argument>, <argument><expr><name>nulls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>HeapTupleGetDatum</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* ok, slot is now fully created, mark it as persistent if needed */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>temporary</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ReplicationSlotPersist</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><call><name>ReplicationSlotRelease</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_DATUM</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * SQL function for dropping a replication slot.
 */</comment>
<function><type><name>Datum</name></type>
<name>pg_drop_replication_slot</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Name</name></type>		<name>name</name> <init>= <expr><call><name>PG_GETARG_NAME</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>check_permissions</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>CheckSlotRequirements</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ReplicationSlotDrop</name><argument_list>(<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><operator>*</operator><name>name</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_VOID</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * pg_get_replication_slots - SQL SRF showing active replication slots.
 */</comment>
<function><type><name>Datum</name></type>
<name>pg_get_replication_slots</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PG_GET_REPLICATION_SLOTS_COLS</name></cpp:macro> <cpp:value>11</cpp:value></cpp:define>
	<decl_stmt><decl><type><name>ReturnSetInfo</name> <modifier>*</modifier></type><name>rsinfo</name> <init>= <expr><operator>(</operator><name>ReturnSetInfo</name> <operator>*</operator><operator>)</operator> <name><name>fcinfo</name><operator>-&gt;</operator><name>resultinfo</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleDesc</name></type>	<name>tupdesc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Tuplestorestate</name> <modifier>*</modifier></type><name>tupstore</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>per_query_ctx</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcontext</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>slotno</name></decl>;</decl_stmt>

	<comment type="block">/* check to see if caller supports us returning a tuplestore */</comment>
	<if_stmt><if>if <condition>(<expr><name>rsinfo</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name>rsinfo</name></expr></argument>, <argument><expr><name>ReturnSetInfo</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"set-valued function called in context that cannot accept a set"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name><name>rsinfo</name><operator>-&gt;</operator><name>allowedModes</name></name> <operator>&amp;</operator> <name>SFRM_Materialize</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"materialize mode required, but it is not "</literal> \
						<literal type="string">"allowed in this context"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Build a tuple descriptor for our result type */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>get_call_result_type</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tupdesc</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>TYPEFUNC_COMPOSITE</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"return type must be a row type"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * We don't require any special permission to see this function's data
	 * because nothing should be sensitive. The most critical being the slot
	 * name, which shouldn't contain anything particularly sensitive.
	 */</comment>

	<expr_stmt><expr><name>per_query_ctx</name> <operator>=</operator> <name><name>rsinfo</name><operator>-&gt;</operator><name>econtext</name><operator>-&gt;</operator><name>ecxt_per_query_memory</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>oldcontext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>per_query_ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>tupstore</name> <operator>=</operator> <call><name>tuplestore_begin_heap</name><argument_list>(<argument><expr><name>true</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>work_mem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rsinfo</name><operator>-&gt;</operator><name>returnMode</name></name> <operator>=</operator> <name>SFRM_Materialize</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rsinfo</name><operator>-&gt;</operator><name>setResult</name></name> <operator>=</operator> <name>tupstore</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rsinfo</name><operator>-&gt;</operator><name>setDesc</name></name> <operator>=</operator> <name>tupdesc</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>ReplicationSlotControlLock</name></expr></argument>, <argument><expr><name>LW_SHARED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>slotno</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>slotno</name> <operator>&lt;</operator> <name>max_replication_slots</name></expr>;</condition> <incr><expr><name>slotno</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ReplicationSlot</name> <modifier>*</modifier></type><name>slot</name> <init>= <expr><operator>&amp;</operator><name><name>ReplicationSlotCtl</name><operator>-&gt;</operator><name>replication_slots</name><index>[<expr><name>slotno</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ReplicationSlot</name></type> <name>slot_contents</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Datum</name></type>		<name><name>values</name><index>[<expr><name>PG_GET_REPLICATION_SLOTS_COLS</name></expr>]</index></name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name><name>nulls</name><index>[<expr><name>PG_GET_REPLICATION_SLOTS_COLS</name></expr>]</index></name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>slot</name><operator>-&gt;</operator><name>in_use</name></name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<comment type="block">/* Copy slot contents while holding spinlock, then examine at leisure */</comment>
		<expr_stmt><expr><call><name>SpinLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>slot</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>slot_contents</name> <operator>=</operator> <operator>*</operator><name>slot</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>SpinLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>slot</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>values</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>values</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>nulls</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>nulls</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>values</name><index>[<expr><name>i</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <call><name>NameGetDatum</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>slot_contents</name><operator>.</operator><name>data</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>slot_contents</name><operator>.</operator><name>data</name><operator>.</operator><name>database</name></name> <operator>==</operator> <name>InvalidOid</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>nulls</name><index>[<expr><name>i</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>values</name><index>[<expr><name>i</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <call><name>NameGetDatum</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>slot_contents</name><operator>.</operator><name>data</name><operator>.</operator><name>plugin</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>slot_contents</name><operator>.</operator><name>data</name><operator>.</operator><name>database</name></name> <operator>==</operator> <name>InvalidOid</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>values</name><index>[<expr><name>i</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <call><name>CStringGetTextDatum</name><argument_list>(<argument><expr><literal type="string">"physical"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>values</name><index>[<expr><name>i</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <call><name>CStringGetTextDatum</name><argument_list>(<argument><expr><literal type="string">"logical"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>slot_contents</name><operator>.</operator><name>data</name><operator>.</operator><name>database</name></name> <operator>==</operator> <name>InvalidOid</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>nulls</name><index>[<expr><name>i</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>values</name><index>[<expr><name>i</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name><name>slot_contents</name><operator>.</operator><name>data</name><operator>.</operator><name>database</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<expr_stmt><expr><name><name>values</name><index>[<expr><name>i</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <call><name>BoolGetDatum</name><argument_list>(<argument><expr><name><name>slot_contents</name><operator>.</operator><name>data</name><operator>.</operator><name>persistency</name></name> <operator>==</operator> <name>RS_TEMPORARY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>values</name><index>[<expr><name>i</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <call><name>BoolGetDatum</name><argument_list>(<argument><expr><name><name>slot_contents</name><operator>.</operator><name>active_pid</name></name> <operator>!=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>slot_contents</name><operator>.</operator><name>active_pid</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>values</name><index>[<expr><name>i</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <call><name>Int32GetDatum</name><argument_list>(<argument><expr><name><name>slot_contents</name><operator>.</operator><name>active_pid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>nulls</name><index>[<expr><name>i</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>slot_contents</name><operator>.</operator><name>data</name><operator>.</operator><name>xmin</name></name> <operator>!=</operator> <name>InvalidTransactionId</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>values</name><index>[<expr><name>i</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <call><name>TransactionIdGetDatum</name><argument_list>(<argument><expr><name><name>slot_contents</name><operator>.</operator><name>data</name><operator>.</operator><name>xmin</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>nulls</name><index>[<expr><name>i</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>slot_contents</name><operator>.</operator><name>data</name><operator>.</operator><name>catalog_xmin</name></name> <operator>!=</operator> <name>InvalidTransactionId</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>values</name><index>[<expr><name>i</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <call><name>TransactionIdGetDatum</name><argument_list>(<argument><expr><name><name>slot_contents</name><operator>.</operator><name>data</name><operator>.</operator><name>catalog_xmin</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>nulls</name><index>[<expr><name>i</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>slot_contents</name><operator>.</operator><name>data</name><operator>.</operator><name>restart_lsn</name></name> <operator>!=</operator> <name>InvalidXLogRecPtr</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>values</name><index>[<expr><name>i</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <call><name>LSNGetDatum</name><argument_list>(<argument><expr><name><name>slot_contents</name><operator>.</operator><name>data</name><operator>.</operator><name>restart_lsn</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>nulls</name><index>[<expr><name>i</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>slot_contents</name><operator>.</operator><name>data</name><operator>.</operator><name>confirmed_flush</name></name> <operator>!=</operator> <name>InvalidXLogRecPtr</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>values</name><index>[<expr><name>i</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <call><name>LSNGetDatum</name><argument_list>(<argument><expr><name><name>slot_contents</name><operator>.</operator><name>data</name><operator>.</operator><name>confirmed_flush</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>nulls</name><index>[<expr><name>i</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>i</name> <operator>==</operator> <name>PG_GET_REPLICATION_SLOTS_COLS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>tuplestore_putvalues</name><argument_list>(<argument><expr><name>tupstore</name></expr></argument>, <argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><name>values</name></expr></argument>, <argument><expr><name>nulls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>ReplicationSlotControlLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>tuplestore_donestoring</name><argument_list>(<argument><expr><name>tupstore</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><operator>(</operator><name>Datum</name><operator>)</operator> <literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Helper function for advancing our physical replication slot forward.
 *
 * The LSN position to move to is compared simply to the slot's restart_lsn,
 * knowing that any position older than that would be removed by successive
 * checkpoints.
 */</comment>
<function><type><specifier>static</specifier> <name>XLogRecPtr</name></type>
<name>pg_physical_replication_slot_advance</name><parameter_list>(<parameter><decl><type><name>XLogRecPtr</name></type> <name>moveto</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>XLogRecPtr</name></type>	<name>startlsn</name> <init>= <expr><name><name>MyReplicationSlot</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>restart_lsn</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>XLogRecPtr</name></type>	<name>retlsn</name> <init>= <expr><name>startlsn</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>startlsn</name> <operator>&lt;</operator> <name>moveto</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>SpinLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>MyReplicationSlot</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>MyReplicationSlot</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>restart_lsn</name></name> <operator>=</operator> <name>moveto</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>SpinLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>MyReplicationSlot</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>retlsn</name> <operator>=</operator> <name>moveto</name></expr>;</expr_stmt>

		<comment type="block">/*
		 * Dirty the slot so as it is written out at the next checkpoint.
		 * Note that the LSN position advanced may still be lost in the
		 * event of a crash, but this makes the data consistent after a
		 * clean shutdown.
		 */</comment>
		<expr_stmt><expr><call><name>ReplicationSlotMarkDirty</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>retlsn</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Helper function for advancing our logical replication slot forward.
 *
 * The slot's restart_lsn is used as start point for reading records, while
 * confirmed_flush is used as base point for the decoding context.
 *
 * We cannot just do LogicalConfirmReceivedLocation to update confirmed_flush,
 * because we need to digest WAL to advance restart_lsn allowing to recycle
 * WAL and removal of old catalog tuples.  As decoding is done in fast_forward
 * mode, no changes are generated anyway.
 */</comment>
<function><type><specifier>static</specifier> <name>XLogRecPtr</name></type>
<name>pg_logical_replication_slot_advance</name><parameter_list>(<parameter><decl><type><name>XLogRecPtr</name></type> <name>moveto</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>LogicalDecodingContext</name> <modifier>*</modifier></type><name>ctx</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ResourceOwner</name></type> <name>old_resowner</name> <init>= <expr><name>CurrentResourceOwner</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>XLogRecPtr</name></type>	<name>startlsn</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>XLogRecPtr</name></type>	<name>retlsn</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>PG_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<block>{<block_content>
		<comment type="block">/*
		 * Create our decoding context in fast_forward mode, passing start_lsn
		 * as InvalidXLogRecPtr, so that we start processing from my slot's
		 * confirmed_flush.
		 */</comment>
		<expr_stmt><expr><name>ctx</name> <operator>=</operator> <call><name>CreateDecodingContext</name><argument_list>(<argument><expr><name>InvalidXLogRecPtr</name></expr></argument>,
									<argument><expr><name>NIL</name></expr></argument>,
									<argument><expr><name>true</name></expr></argument>,	<comment type="block">/* fast_forward */</comment>
									<argument><expr><name>logical_read_local_xlog_page</name></expr></argument>,
									<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Start reading at the slot's restart_lsn, which we know to point to
		 * a valid record.
		 */</comment>
		<expr_stmt><expr><name>startlsn</name> <operator>=</operator> <name><name>MyReplicationSlot</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>restart_lsn</name></name></expr>;</expr_stmt>

		<comment type="block">/* Initialize our return value in case we don't do anything */</comment>
		<expr_stmt><expr><name>retlsn</name> <operator>=</operator> <name><name>MyReplicationSlot</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>confirmed_flush</name></name></expr>;</expr_stmt>

		<comment type="block">/* invalidate non-timetravel entries */</comment>
		<expr_stmt><expr><call><name>InvalidateSystemCaches</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Decode at least one record, until we run out of records */</comment>
		<while>while <condition>(<expr><operator>(</operator><operator>!</operator><call><name>XLogRecPtrIsInvalid</name><argument_list>(<argument><expr><name>startlsn</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
				<name>startlsn</name> <operator>&lt;</operator> <name>moveto</name><operator>)</operator> <operator>||</operator>
			   <operator>(</operator><operator>!</operator><call><name>XLogRecPtrIsInvalid</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>reader</name><operator>-&gt;</operator><name>EndRecPtr</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
				<name><name>ctx</name><operator>-&gt;</operator><name>reader</name><operator>-&gt;</operator><name>EndRecPtr</name></name> <operator>&lt;</operator> <name>moveto</name><operator>)</operator></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>errm</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>XLogRecord</name> <modifier>*</modifier></type><name>record</name></decl>;</decl_stmt>

			<comment type="block">/*
			 * Read records.  No changes are generated in fast_forward mode,
			 * but snapbuilder/slot statuses are updated properly.
			 */</comment>
			<expr_stmt><expr><name>record</name> <operator>=</operator> <call><name>XLogReadRecord</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>reader</name></name></expr></argument>, <argument><expr><name>startlsn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>errm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>errm</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name>errm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<comment type="block">/* Read sequentially from now on */</comment>
			<expr_stmt><expr><name>startlsn</name> <operator>=</operator> <name>InvalidXLogRecPtr</name></expr>;</expr_stmt>

			<comment type="block">/*
			 * Process the record.  Storage-level changes are ignored in
			 * fast_forward mode, but other modules (such as snapbuilder)
			 * might still have critical updates to do.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name>record</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>LogicalDecodingProcessRecord</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>reader</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<comment type="block">/* Stop once the requested target has been reached */</comment>
			<if_stmt><if>if <condition>(<expr><name>moveto</name> <operator>&lt;=</operator> <name><name>ctx</name><operator>-&gt;</operator><name>reader</name><operator>-&gt;</operator><name>EndRecPtr</name></name></expr>)</condition><block type="pseudo"><block_content>
				<break>break;</break></block_content></block></if></if_stmt>

			<expr_stmt><expr><call><name>CHECK_FOR_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></while>

		<comment type="block">/*
		 * Logical decoding could have clobbered CurrentResourceOwner during
		 * transaction management, so restore the executor's value.  (This is
		 * a kluge, but it's not worth cleaning up right now.)
		 */</comment>
		<expr_stmt><expr><name>CurrentResourceOwner</name> <operator>=</operator> <name>old_resowner</name></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>ctx</name><operator>-&gt;</operator><name>reader</name><operator>-&gt;</operator><name>EndRecPtr</name></name> <operator>!=</operator> <name>InvalidXLogRecPtr</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>LogicalConfirmReceivedLocation</name><argument_list>(<argument><expr><name>moveto</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * If only the confirmed_flush LSN has changed the slot won't get
			 * marked as dirty by the above. Callers on the walsender
			 * interface are expected to keep track of their own progress and
			 * don't need it written out. But SQL-interface users cannot
			 * specify their own start positions and it's harder for them to
			 * keep track of their progress, so we should make more of an
			 * effort to save it for them.
			 *
			 * Dirty the slot so it is written out at the next checkpoint.
			 * The LSN position advanced to may still be lost on a crash
			 * but this makes the data consistent after a clean shutdown.
			 */</comment>
			<expr_stmt><expr><call><name>ReplicationSlotMarkDirty</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name>retlsn</name> <operator>=</operator> <name><name>MyReplicationSlot</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>confirmed_flush</name></name></expr>;</expr_stmt>

		<comment type="block">/* free context, call shutdown callback */</comment>
		<expr_stmt><expr><call><name>FreeDecodingContext</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>InvalidateSystemCaches</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
	<expr_stmt><expr><call><name>PG_CATCH</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<block>{<block_content>
		<comment type="block">/* clear all timetravel entries */</comment>
		<expr_stmt><expr><call><name>InvalidateSystemCaches</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>PG_RE_THROW</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
	<expr_stmt><expr><call><name>PG_END_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>retlsn</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * SQL function for moving the position in a replication slot.
 */</comment>
<function><type><name>Datum</name></type>
<name>pg_replication_slot_advance</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Name</name></type>		<name>slotname</name> <init>= <expr><call><name>PG_GETARG_NAME</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>XLogRecPtr</name></type>	<name>moveto</name> <init>= <expr><call><name>PG_GETARG_LSN</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>XLogRecPtr</name></type>	<name>endlsn</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>XLogRecPtr</name></type>	<name>minlsn</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleDesc</name></type>	<name>tupdesc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type>		<name><name>values</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name><name>nulls</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type>		<name>result</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>MyReplicationSlot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>check_permissions</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>XLogRecPtrIsInvalid</name><argument_list>(<argument><expr><name>moveto</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid target wal lsn"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Build a tuple descriptor for our result type */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>get_call_result_type</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tupdesc</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>TYPEFUNC_COMPOSITE</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"return type must be a row type"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * We can't move slot past what's been flushed/replayed so clamp the
	 * target position accordingly.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>RecoveryInProgress</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>moveto</name> <operator>=</operator> <call><name>Min</name><argument_list>(<argument><expr><name>moveto</name></expr></argument>, <argument><expr><call><name>GetFlushRecPtr</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>moveto</name> <operator>=</operator> <call><name>Min</name><argument_list>(<argument><expr><name>moveto</name></expr></argument>, <argument><expr><call><name>GetXLogReplayRecPtr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ThisTimeLineID</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/* Acquire the slot so we "own" it */</comment>
	<expr_stmt><expr><call><name>ReplicationSlotAcquire</name><argument_list>(<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><operator>*</operator><name>slotname</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* A slot whose restart_lsn has never been reserved cannot be advanced */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>XLogRecPtrIsInvalid</name><argument_list>(<argument><expr><name><name>MyReplicationSlot</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>restart_lsn</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"replication slot \"%s\" cannot be advanced"</literal></expr></argument>,
				 		<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><operator>*</operator><name>slotname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"This slot has never previously reserved WAL, or has been invalidated."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Check if the slot is not moving backwards.  Physical slots rely simply
	 * on restart_lsn as a minimum point, while logical slots have confirmed
	 * consumption up to confirmed_flush, meaning that in both cases data
	 * older than that is not available anymore.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>MyReplicationSlot</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>database</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>minlsn</name> <operator>=</operator> <name><name>MyReplicationSlot</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>confirmed_flush</name></name></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>minlsn</name> <operator>=</operator> <name><name>MyReplicationSlot</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>restart_lsn</name></name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>moveto</name> <operator>&lt;</operator> <name>minlsn</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot advance replication slot to %X/%X, minimum is %X/%X"</literal></expr></argument>,
						<argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <operator>(</operator><name>moveto</name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr></argument>, <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <name>moveto</name></expr></argument>,
						<argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <operator>(</operator><name>minlsn</name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr></argument>, <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <name>minlsn</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Do the actual slot update, depending on the slot type */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>MyReplicationSlot</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>database</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>endlsn</name> <operator>=</operator> <call><name>pg_logical_replication_slot_advance</name><argument_list>(<argument><expr><name>moveto</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>endlsn</name> <operator>=</operator> <call><name>pg_physical_replication_slot_advance</name><argument_list>(<argument><expr><name>moveto</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>NameGetDatum</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>MyReplicationSlot</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>nulls</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Recompute the minimum LSN and xmin across all slots to adjust with the
	 * advancing potentially done.
	 */</comment>
	<expr_stmt><expr><call><name>ReplicationSlotsComputeRequiredXmin</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ReplicationSlotsComputeRequiredLSN</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ReplicationSlotRelease</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Return the reached position. */</comment>
	<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>LSNGetDatum</name><argument_list>(<argument><expr><name>endlsn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>nulls</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>heap_form_tuple</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><name>values</name></expr></argument>, <argument><expr><name>nulls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>HeapTupleGetDatum</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_DATUM</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
</unit>
