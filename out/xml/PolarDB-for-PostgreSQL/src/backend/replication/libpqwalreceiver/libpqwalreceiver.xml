<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/PolarDB-for-PostgreSQL/src/backend/replication/libpqwalreceiver/libpqwalreceiver.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * libpqwalreceiver.c
 *
 * This file contains the libpq-specific parts of walreceiver. It's
 * loaded as a dynamic module to avoid linking the main server binary with
 * libpq.
 *
 * Portions Copyright (c) 2010-2018, PostgreSQL Global Development Group
 *
 *
 * IDENTIFICATION
 *	  src/backend/replication/libpqwalreceiver/libpqwalreceiver.c
 *
 *-------------------------------------------------------------------------
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;unistd.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/time.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"libpq-fe.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pqexpbuffer.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/xlog.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_type.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"common/connect.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"funcapi.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"mb/pg_wchar.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pgstat.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"replication/walreceiver.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/builtins.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/memutils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/pg_lsn.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/tuplestore.h"</cpp:file></cpp:include>

<expr_stmt><expr><name>PG_MODULE_MAGIC</name></expr>;</expr_stmt>

<function_decl><type><name>void</name></type>		<name>_PG_init</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>

<struct>struct <name>WalReceiverConn</name>
<block>{
	<comment type="block">/* Current connection to the primary, if any */</comment>
	<decl_stmt><decl><type><name>PGconn</name>	   <modifier>*</modifier></type><name>streamConn</name></decl>;</decl_stmt>
	<comment type="block">/* Used to remember if the connection is logical or physical */</comment>
	<decl_stmt><decl><type><name>bool</name></type>		<name>logical</name></decl>;</decl_stmt>
	<comment type="block">/* Buffer for currently read records */</comment>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>recvBuf</name></decl>;</decl_stmt>
}</block>;</struct>

<comment type="block">/* Prototypes for interface functions */</comment>
<function_decl><type><specifier>static</specifier> <name>WalReceiverConn</name> <modifier>*</modifier></type><name>libpqrcv_connect</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>conninfo</name></decl></parameter>,
				 <parameter><decl><type><name>bool</name></type> <name>logical</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>appname</name></decl></parameter>,
				 <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>err</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>libpqrcv_check_conninfo</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>conninfo</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>libpqrcv_get_conninfo</name><parameter_list>(<parameter><decl><type><name>WalReceiverConn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>libpqrcv_get_senderinfo</name><parameter_list>(<parameter><decl><type><name>WalReceiverConn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>,
						<parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>sender_host</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>sender_port</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>libpqrcv_identify_system</name><parameter_list>(<parameter><decl><type><name>WalReceiverConn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>,
						 <parameter><decl><type><name>TimeLineID</name> <modifier>*</modifier></type><name>primary_tli</name></decl></parameter>,
						 <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>server_version</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>libpqrcv_readtimelinehistoryfile</name><parameter_list>(<parameter><decl><type><name>WalReceiverConn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>,
								 <parameter><decl><type><name>TimeLineID</name></type> <name>tli</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>filename</name></decl></parameter>,
								 <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>content</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>len</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>libpqrcv_startstreaming</name><parameter_list>(<parameter><decl><type><name>WalReceiverConn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>,
						<parameter><decl><type><specifier>const</specifier> <name>WalRcvStreamOptions</name> <modifier>*</modifier></type><name>options</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>libpqrcv_endstreaming</name><parameter_list>(<parameter><decl><type><name>WalReceiverConn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>,
					  <parameter><decl><type><name>TimeLineID</name> <modifier>*</modifier></type><name>next_tli</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>libpqrcv_receive</name><parameter_list>(<parameter><decl><type><name>WalReceiverConn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>buffer</name></decl></parameter>,
				 <parameter><decl><type><name>pgsocket</name> <modifier>*</modifier></type><name>wait_fd</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>libpqrcv_send</name><parameter_list>(<parameter><decl><type><name>WalReceiverConn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>buffer</name></decl></parameter>,
			  <parameter><decl><type><name>int</name></type> <name>nbytes</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>libpqrcv_create_slot</name><parameter_list>(<parameter><decl><type><name>WalReceiverConn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>,
					 <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>slotname</name></decl></parameter>,
					 <parameter><decl><type><name>bool</name></type> <name>temporary</name></decl></parameter>,
					 <parameter><decl><type><name>CRSSnapshotAction</name></type> <name>snapshot_action</name></decl></parameter>,
					 <parameter><decl><type><name>XLogRecPtr</name> <modifier>*</modifier></type><name>lsn</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>WalRcvExecResult</name> <modifier>*</modifier></type><name>libpqrcv_exec</name><parameter_list>(<parameter><decl><type><name>WalReceiverConn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>,
			  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>query</name></decl></parameter>,
			  <parameter><decl><type><specifier>const</specifier> <name>int</name></type> <name>nRetTypes</name></decl></parameter>,
			  <parameter><decl><type><specifier>const</specifier> <name>Oid</name> <modifier>*</modifier></type><name>retTypes</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>libpqrcv_disconnect</name><parameter_list>(<parameter><decl><type><name>WalReceiverConn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>)</parameter_list>;</function_decl>

<decl_stmt><decl><type><specifier>static</specifier> <name>WalReceiverFunctionsType</name></type> <name>PQWalReceiverFunctions</name> <init>= <expr><block>{
	<expr><name>libpqrcv_connect</name></expr>,
	<expr><name>libpqrcv_check_conninfo</name></expr>,
	<expr><name>libpqrcv_get_conninfo</name></expr>,
	<expr><name>libpqrcv_get_senderinfo</name></expr>,
	<expr><name>libpqrcv_identify_system</name></expr>,
	<expr><name>libpqrcv_readtimelinehistoryfile</name></expr>,
	<expr><name>libpqrcv_startstreaming</name></expr>,
	<expr><name>libpqrcv_endstreaming</name></expr>,
	<expr><name>libpqrcv_receive</name></expr>,
	<expr><name>libpqrcv_send</name></expr>,
	<expr><name>libpqrcv_create_slot</name></expr>,
	<expr><name>libpqrcv_exec</name></expr>,
	<expr><name>libpqrcv_disconnect</name></expr>
}</block></expr></init></decl>;</decl_stmt>

<comment type="block">/* Prototypes for private functions */</comment>
<function_decl><type><specifier>static</specifier> <name>PGresult</name> <modifier>*</modifier></type><name>libpqrcv_PQexec</name><parameter_list>(<parameter><decl><type><name>PGconn</name> <modifier>*</modifier></type><name>streamConn</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>query</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>PGresult</name> <modifier>*</modifier></type><name>libpqrcv_PQgetResult</name><parameter_list>(<parameter><decl><type><name>PGconn</name> <modifier>*</modifier></type><name>streamConn</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>stringlist_to_identifierstr</name><parameter_list>(<parameter><decl><type><name>PGconn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>strings</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/*
 * Module initialization function
 */</comment>
<function><type><name>void</name></type>
<name>_PG_init</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>WalReceiverFunctions</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"libpqwalreceiver already loaded"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>WalReceiverFunctions</name> <operator>=</operator> <operator>&amp;</operator><name>PQWalReceiverFunctions</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Establish the connection to the primary server for XLOG streaming
 *
 * Returns NULL on error and fills the err with palloc'ed error message.
 */</comment>
<function><type><specifier>static</specifier> <name>WalReceiverConn</name> <modifier>*</modifier></type>
<name>libpqrcv_connect</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>conninfo</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>logical</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>appname</name></decl></parameter>,
				 <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>err</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>WalReceiverConn</name> <modifier>*</modifier></type><name>conn</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PostgresPollingStatusType</name></type> <name>status</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name><name>keys</name><index>[<expr><literal type="number">5</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name><name>vals</name><index>[<expr><literal type="number">5</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * We use the expand_dbname parameter to process the connection string (or
	 * URI), and pass some extra options.
	 */</comment>
	<expr_stmt><expr><name><name>keys</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <literal type="string">"dbname"</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>vals</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>conninfo</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>keys</name><index>[<expr><operator>++</operator><name>i</name></expr>]</index></name> <operator>=</operator> <literal type="string">"replication"</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>vals</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <ternary><condition><expr><name>logical</name></expr> ?</condition><then> <expr><literal type="string">"database"</literal></expr> </then><else>: <expr><literal type="string">"true"</literal></expr></else></ternary></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>logical</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * The database name is ignored by the server in replication mode, but
		 * specify "replication" for .pgpass lookup.
		 */</comment>
		<expr_stmt><expr><name><name>keys</name><index>[<expr><operator>++</operator><name>i</name></expr>]</index></name> <operator>=</operator> <literal type="string">"dbname"</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>vals</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <literal type="string">"replication"</literal></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name><name>keys</name><index>[<expr><operator>++</operator><name>i</name></expr>]</index></name> <operator>=</operator> <literal type="string">"fallback_application_name"</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>vals</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>appname</name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>logical</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>keys</name><index>[<expr><operator>++</operator><name>i</name></expr>]</index></name> <operator>=</operator> <literal type="string">"client_encoding"</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>vals</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>GetDatabaseEncodingName</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name><name>keys</name><index>[<expr><operator>++</operator><name>i</name></expr>]</index></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>vals</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>i</name> <operator>&lt;</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>keys</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>conn</name> <operator>=</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>WalReceiverConn</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>streamConn</name></name> <operator>=</operator> <call><name>PQconnectStartParams</name><argument_list>(<argument><expr><name>keys</name></expr></argument>, <argument><expr><name>vals</name></expr></argument>,
											 <comment type="block">/* expand_dbname = */</comment> <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>PQstatus</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>streamConn</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <name>CONNECTION_BAD</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><operator>*</operator><name>err</name> <operator>=</operator> <call><name>pchomp</name><argument_list>(<argument><expr><call><name>PQerrorMessage</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>streamConn</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Poll connection until we have OK or FAILED status.
	 *
	 * Per spec for PQconnectPoll, first wait till socket is write-ready.
	 */</comment>
	<expr_stmt><expr><name>status</name> <operator>=</operator> <name>PGRES_POLLING_WRITING</name></expr>;</expr_stmt>
	<do>do
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>io_flag</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>rc</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>status</name> <operator>==</operator> <name>PGRES_POLLING_READING</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>io_flag</name> <operator>=</operator> <name>WL_SOCKET_READABLE</name></expr>;</expr_stmt></block_content></block></if>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WIN32</name></cpp:ifdef>
		<comment type="block">/* Windows needs a different test while waiting for connection-made */</comment>
		<if type="elseif">else if <condition>(<expr><call><name>PQstatus</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>streamConn</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <name>CONNECTION_STARTED</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>io_flag</name> <operator>=</operator> <name>WL_SOCKET_CONNECTED</name></expr>;</expr_stmt></block_content></block></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>io_flag</name> <operator>=</operator> <name>WL_SOCKET_WRITEABLE</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>WaitLatchOrSocket</name><argument_list>(<argument><expr><name>MyLatch</name></expr></argument>,
							   <argument><expr><name>WL_POSTMASTER_DEATH</name> <operator>|</operator>
							   <name>WL_LATCH_SET</name> <operator>|</operator> <name>io_flag</name></expr></argument>,
							   <argument><expr><call><name>PQsocket</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>streamConn</name></name></expr></argument>)</argument_list></call></expr></argument>,
							   <argument><expr><literal type="number">0</literal></expr></argument>,
							   <argument><expr><name>WAIT_EVENT_LIBPQWALRECEIVER_CONNECT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Emergency bailout? */</comment>
		<if_stmt><if>if <condition>(<expr><name>rc</name> <operator>&amp;</operator> <name>WL_POSTMASTER_DEATH</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/* Interrupted? */</comment>
		<if_stmt><if>if <condition>(<expr><name>rc</name> <operator>&amp;</operator> <name>WL_LATCH_SET</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ResetLatch</name><argument_list>(<argument><expr><name>MyLatch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>ProcessWalRcvInterrupts</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* If socket is ready, advance the libpq state machine */</comment>
		<if_stmt><if>if <condition>(<expr><name>rc</name> <operator>&amp;</operator> <name>io_flag</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>status</name> <operator>=</operator> <call><name>PQconnectPoll</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>streamConn</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block> while <condition>(<expr><name>status</name> <operator>!=</operator> <name>PGRES_POLLING_OK</name> <operator>&amp;&amp;</operator> <name>status</name> <operator>!=</operator> <name>PGRES_POLLING_FAILED</name></expr>)</condition>;</do>

	<if_stmt><if>if <condition>(<expr><call><name>PQstatus</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>streamConn</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>CONNECTION_OK</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><operator>*</operator><name>err</name> <operator>=</operator> <call><name>pchomp</name><argument_list>(<argument><expr><call><name>PQerrorMessage</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>streamConn</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>logical</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>libpqrcv_PQexec</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>streamConn</name></name></expr></argument>,
							  <argument><expr><name>ALWAYS_SECURE_SEARCH_PATH_SQL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>PQresultStatus</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>PGRES_TUPLES_OK</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not clear search path: %s"</literal></expr></argument>,
							<argument><expr><call><name>pchomp</name><argument_list>(<argument><expr><call><name>PQerrorMessage</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>streamConn</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>logical</name></name> <operator>=</operator> <name>logical</name></expr>;</expr_stmt>

	<return>return <expr><name>conn</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Validate connection info string (just try to parse it)
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>libpqrcv_check_conninfo</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>conninfo</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PQconninfoOption</name> <modifier>*</modifier></type><name>opts</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>err</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>opts</name> <operator>=</operator> <call><name>PQconninfoParse</name><argument_list>(<argument><expr><name>conninfo</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>opts</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid connection string syntax: %s"</literal></expr></argument>, <argument><expr><name>err</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>PQconninfoFree</name><argument_list>(<argument><expr><name>opts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Return a user-displayable conninfo string.  Any security-sensitive fields
 * are obfuscated.
 */</comment>
<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type>
<name>libpqrcv_get_conninfo</name><parameter_list>(<parameter><decl><type><name>WalReceiverConn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PQconninfoOption</name> <modifier>*</modifier></type><name>conn_opts</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PQconninfoOption</name> <modifier>*</modifier></type><name>conn_opt</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PQExpBufferData</name></type> <name>buf</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>retval</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>streamConn</name></name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>initPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>conn_opts</name> <operator>=</operator> <call><name>PQconninfo</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>streamConn</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>conn_opts</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not parse connection string: %s"</literal></expr></argument>,
						<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"out of memory"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* build a clean connection string from pieces */</comment>
	<for>for <control>(<init><expr><name>conn_opt</name> <operator>=</operator> <name>conn_opts</name></expr>;</init> <condition><expr><name><name>conn_opt</name><operator>-&gt;</operator><name>keyword</name></name> <operator>!=</operator> <name>NULL</name></expr>;</condition> <incr><expr><name>conn_opt</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>bool</name></type>		<name>obfuscate</name></decl>;</decl_stmt>

		<comment type="block">/* Skip debug and empty options */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>strchr</name><argument_list>(<argument><expr><name><name>conn_opt</name><operator>-&gt;</operator><name>dispchar</name></name></expr></argument>, <argument><expr><literal type="char">'D'</literal></expr></argument>)</argument_list></call> <operator>||</operator>
			<name><name>conn_opt</name><operator>-&gt;</operator><name>val</name></name> <operator>==</operator> <name>NULL</name> <operator>||</operator>
			<name><name>conn_opt</name><operator>-&gt;</operator><name>val</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'\0'</literal></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<comment type="block">/* Obfuscate security-sensitive options */</comment>
		<expr_stmt><expr><name>obfuscate</name> <operator>=</operator> <call><name>strchr</name><argument_list>(<argument><expr><name><name>conn_opt</name><operator>-&gt;</operator><name>dispchar</name></name></expr></argument>, <argument><expr><literal type="char">'*'</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"%s%s=%s"</literal></expr></argument>,
						  <argument><expr><ternary><condition><expr><name><name>buf</name><operator>.</operator><name>len</name></name> <operator>==</operator> <literal type="number">0</literal></expr> ?</condition><then> <expr><literal type="string">""</literal></expr> </then><else>: <expr><literal type="string">" "</literal></expr></else></ternary></expr></argument>,
						  <argument><expr><name><name>conn_opt</name><operator>-&gt;</operator><name>keyword</name></name></expr></argument>,
						  <argument><expr><ternary><condition><expr><name>obfuscate</name></expr> ?</condition><then> <expr><literal type="string">"********"</literal></expr> </then><else>: <expr><name><name>conn_opt</name><operator>-&gt;</operator><name>val</name></name></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>PQconninfoFree</name><argument_list>(<argument><expr><name>conn_opts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>retval</name> <operator>=</operator> <ternary><condition><expr><call><name>PQExpBufferDataBroken</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><name>NULL</name></expr> </then><else>: <expr><call><name>pstrdup</name><argument_list>(<argument><expr><name><name>buf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr></else></ternary></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>termPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>retval</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Provides information of sender this WAL receiver is connected to.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>libpqrcv_get_senderinfo</name><parameter_list>(<parameter><decl><type><name>WalReceiverConn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>sender_host</name></decl></parameter>,
						<parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>sender_port</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>ret</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><operator>*</operator><name>sender_host</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>sender_port</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>streamConn</name></name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>PQhost</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>streamConn</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>&amp;&amp;</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>ret</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><operator>*</operator><name>sender_host</name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><name>ret</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>PQport</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>streamConn</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>&amp;&amp;</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>ret</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><operator>*</operator><name>sender_port</name> <operator>=</operator> <call><name>atoi</name><argument_list>(<argument><expr><name>ret</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Check that primary's system identifier matches ours, and fetch the current
 * timeline ID of the primary.
 */</comment>
<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type>
<name>libpqrcv_identify_system</name><parameter_list>(<parameter><decl><type><name>WalReceiverConn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>, <parameter><decl><type><name>TimeLineID</name> <modifier>*</modifier></type><name>primary_tli</name></decl></parameter>,
						 <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>server_version</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>primary_sysid</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Get the system identifier and timeline ID as a DataRow message from the
	 * primary server.
	 */</comment>
	<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>libpqrcv_PQexec</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>streamConn</name></name></expr></argument>, <argument><expr><literal type="string">"IDENTIFY_SYSTEM"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>PQresultStatus</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>PGRES_TUPLES_OK</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not receive database system identifier and timeline ID from "</literal>
						<literal type="string">"the primary server: %s"</literal></expr></argument>,
						<argument><expr><call><name>pchomp</name><argument_list>(<argument><expr><call><name>PQerrorMessage</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>streamConn</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>PQnfields</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">3</literal> <operator>||</operator> <call><name>PQntuples</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>ntuples</name> <init>= <expr><call><name>PQntuples</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>nfields</name> <init>= <expr><call><name>PQnfields</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid response from primary server"</literal></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Could not identify system: got %d rows and %d fields, expected %d rows and %d or more fields."</literal></expr></argument>,
						   <argument><expr><name>ntuples</name></expr></argument>, <argument><expr><name>nfields</name></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name>primary_sysid</name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>primary_tli</name> <operator>=</operator> <call><name>pg_atoi</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><operator>*</operator><name>server_version</name> <operator>=</operator> <call><name>PQserverVersion</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>streamConn</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>primary_sysid</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Start streaming WAL data from given streaming options.
 *
 * Returns true if we switched successfully to copy-both mode. False
 * means the server received the command and executed it successfully, but
 * didn't switch to copy-mode.  That means that there was no WAL on the
 * requested timeline and starting point, because the server switched to
 * another timeline at or before the requested starting point. On failure,
 * throws an ERROR.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>libpqrcv_startstreaming</name><parameter_list>(<parameter><decl><type><name>WalReceiverConn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>,
						<parameter><decl><type><specifier>const</specifier> <name>WalRcvStreamOptions</name> <modifier>*</modifier></type><name>options</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>StringInfoData</name></type> <name>cmd</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>options</name><operator>-&gt;</operator><name>logical</name></name> <operator>==</operator> <name><name>conn</name><operator>-&gt;</operator><name>logical</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>options</name><operator>-&gt;</operator><name>slotname</name></name> <operator>||</operator> <operator>!</operator><name><name>options</name><operator>-&gt;</operator><name>logical</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>initStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Build the command. */</comment>
	<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cmd</name></expr></argument>, <argument><expr><literal type="string">"START_REPLICATION"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>options</name><operator>-&gt;</operator><name>slotname</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cmd</name></expr></argument>, <argument><expr><literal type="string">" SLOT \"%s\""</literal></expr></argument>,
						 <argument><expr><name><name>options</name><operator>-&gt;</operator><name>slotname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>options</name><operator>-&gt;</operator><name>logical</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cmd</name></expr></argument>, <argument><expr><literal type="string">" LOGICAL"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cmd</name></expr></argument>, <argument><expr><literal type="string">" %X/%X"</literal></expr></argument>,
					 <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <operator>(</operator><name><name>options</name><operator>-&gt;</operator><name>startpoint</name></name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr></argument>,
					 <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <name><name>options</name><operator>-&gt;</operator><name>startpoint</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Additional options are different depending on if we are doing logical
	 * or physical replication.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>options</name><operator>-&gt;</operator><name>logical</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>pubnames_str</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>pubnames</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>pubnames_literal</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cmd</name></expr></argument>, <argument><expr><literal type="string">" ("</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cmd</name></expr></argument>, <argument><expr><literal type="string">"proto_version '%u'"</literal></expr></argument>,
						 <argument><expr><name><name>options</name><operator>-&gt;</operator><name>proto</name><operator>.</operator><name>logical</name><operator>.</operator><name>proto_version</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>pubnames</name> <operator>=</operator> <name><name>options</name><operator>-&gt;</operator><name>proto</name><operator>.</operator><name>logical</name><operator>.</operator><name>publication_names</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>pubnames_str</name> <operator>=</operator> <call><name>stringlist_to_identifierstr</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>streamConn</name></name></expr></argument>, <argument><expr><name>pubnames</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>pubnames_str</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not start WAL streaming: %s"</literal></expr></argument>,
							<argument><expr><call><name>pchomp</name><argument_list>(<argument><expr><call><name>PQerrorMessage</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>streamConn</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>pubnames_literal</name> <operator>=</operator> <call><name>PQescapeLiteral</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>streamConn</name></name></expr></argument>, <argument><expr><name>pubnames_str</name></expr></argument>,
										   <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>pubnames_str</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>pubnames_literal</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not start WAL streaming: %s"</literal></expr></argument>,
							<argument><expr><call><name>pchomp</name><argument_list>(<argument><expr><call><name>PQerrorMessage</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>streamConn</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cmd</name></expr></argument>, <argument><expr><literal type="string">", publication_names %s"</literal></expr></argument>, <argument><expr><name>pubnames_literal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>PQfreemem</name><argument_list>(<argument><expr><name>pubnames_literal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>pubnames_str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cmd</name></expr></argument>, <argument><expr><literal type="char">')'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cmd</name></expr></argument>, <argument><expr><literal type="string">" TIMELINE %u"</literal></expr></argument>,
						 <argument><expr><name><name>options</name><operator>-&gt;</operator><name>proto</name><operator>.</operator><name>physical</name><operator>.</operator><name>startpointTLI</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		 <comment type="block">/* 
		  * POLAR: Replication on polardb is like a attribute of physical replication.
		  * Howerver, onpolardb will not send the xlog in walsender,
		  * just send two xlog lsn contains consist lsn and flush lsn of primary.
		  */</comment>
		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cmd</name></expr></argument>, <argument><expr><literal type="string">" POLAR_VERSION %s"</literal></expr></argument>, <argument><expr><call><name>STR</name><argument_list>(<argument><expr><name>POLAR_STREAM_REPLICATION_VERSION</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	 	<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cmd</name></expr></argument>, <argument><expr><literal type="string">" POLAR_REPL_MODE \"%s\""</literal></expr></argument>, 
			 	<argument><expr><call><name>polar_replication_mode_str</name><argument_list>(<argument><expr><name><name>options</name><operator>-&gt;</operator><name>polar_repl_mode</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"start_replication cmd: %s"</literal></expr></argument>, <argument><expr><name><name>cmd</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Start streaming. */</comment>
	<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>libpqrcv_PQexec</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>streamConn</name></name></expr></argument>, <argument><expr><name><name>cmd</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>cmd</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>PQresultStatus</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>PGRES_COMMAND_OK</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>PQresultStatus</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>PGRES_COPY_BOTH</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not start WAL streaming: %s"</literal></expr></argument>,
						<argument><expr><call><name>pchomp</name><argument_list>(<argument><expr><call><name>PQerrorMessage</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>streamConn</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Stop streaming WAL data. Returns the next timeline's ID in *next_tli, as
 * reported by the server, or 0 if it did not report it.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>libpqrcv_endstreaming</name><parameter_list>(<parameter><decl><type><name>WalReceiverConn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>, <parameter><decl><type><name>TimeLineID</name> <modifier>*</modifier></type><name>next_tli</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Send copy-end message.  As in libpqrcv_PQexec, this could theoretically
	 * block, but the risk seems small.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>PQputCopyEnd</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>streamConn</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call> <operator>&lt;=</operator> <literal type="number">0</literal> <operator>||</operator>
		<call><name>PQflush</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>streamConn</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not send end-of-streaming message to primary: %s"</literal></expr></argument>,
						<argument><expr><call><name>pchomp</name><argument_list>(<argument><expr><call><name>PQerrorMessage</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>streamConn</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><operator>*</operator><name>next_tli</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<comment type="block">/*
	 * After COPY is finished, we should receive a result set indicating the
	 * next timeline's ID, or just CommandComplete if the server was shut
	 * down.
	 *
	 * If we had not yet received CopyDone from the backend, PGRES_COPY_OUT is
	 * also possible in case we aborted the copy in mid-stream.
	 */</comment>
	<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>libpqrcv_PQgetResult</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>streamConn</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>PQresultStatus</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>PGRES_TUPLES_OK</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Read the next timeline's ID. The server also sends the timeline's
		 * starting point, but it is ignored.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>PQnfields</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">2</literal> <operator>||</operator> <call><name>PQntuples</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"unexpected result set after end-of-streaming"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><operator>*</operator><name>next_tli</name> <operator>=</operator> <call><name>pg_atoi</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>uint32</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* the result set should be followed by CommandComplete */</comment>
		<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>libpqrcv_PQgetResult</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>streamConn</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>PQresultStatus</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>PGRES_COPY_OUT</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* End the copy */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>PQendcopy</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>streamConn</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"error while shutting down streaming COPY: %s"</literal></expr></argument>,
							<argument><expr><call><name>pchomp</name><argument_list>(<argument><expr><call><name>PQerrorMessage</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>streamConn</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/* CommandComplete should follow */</comment>
		<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>libpqrcv_PQgetResult</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>streamConn</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>PQresultStatus</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>PGRES_COMMAND_OK</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"error reading result of streaming command: %s"</literal></expr></argument>,
						<argument><expr><call><name>pchomp</name><argument_list>(<argument><expr><call><name>PQerrorMessage</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>streamConn</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Verify that there are no more results */</comment>
	<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>libpqrcv_PQgetResult</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>streamConn</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>res</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"unexpected result after CommandComplete: %s"</literal></expr></argument>,
						<argument><expr><call><name>pchomp</name><argument_list>(<argument><expr><call><name>PQerrorMessage</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>streamConn</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Fetch the timeline history file for 'tli' from primary.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>libpqrcv_readtimelinehistoryfile</name><parameter_list>(<parameter><decl><type><name>WalReceiverConn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>,
								 <parameter><decl><type><name>TimeLineID</name></type> <name>tli</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>filename</name></decl></parameter>,
								 <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>content</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>len</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>cmd</name><index>[<expr><literal type="number">64</literal></expr>]</index></name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name><name>conn</name><operator>-&gt;</operator><name>logical</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Request the primary to send over the history file for given timeline.
	 */</comment>
	<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>cmd</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>cmd</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"TIMELINE_HISTORY %u"</literal></expr></argument>, <argument><expr><name>tli</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>libpqrcv_PQexec</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>streamConn</name></name></expr></argument>, <argument><expr><name>cmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>PQresultStatus</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>PGRES_TUPLES_OK</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not receive timeline history file from "</literal>
						<literal type="string">"the primary server: %s"</literal></expr></argument>,
						<argument><expr><call><name>pchomp</name><argument_list>(<argument><expr><call><name>PQerrorMessage</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>streamConn</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>PQnfields</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">2</literal> <operator>||</operator> <call><name>PQntuples</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>ntuples</name> <init>= <expr><call><name>PQntuples</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>nfields</name> <init>= <expr><call><name>PQnfields</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid response from primary server"</literal></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Expected 1 tuple with 2 fields, got %d tuples with %d fields."</literal></expr></argument>,
						   <argument><expr><name>ntuples</name></expr></argument>, <argument><expr><name>nfields</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><operator>*</operator><name>filename</name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><operator>*</operator><name>len</name> <operator>=</operator> <call><name>PQgetlength</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>content</name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><operator>*</operator><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>*</operator><name>content</name></expr></argument>, <argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>*</operator><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Send a query and wait for the results by using the asynchronous libpq
 * functions and socket readiness events.
 *
 * We must not use the regular blocking libpq functions like PQexec()
 * since they are uninterruptible by signals on some platforms, such as
 * Windows.
 *
 * The function is modeled on PQexec() in libpq, but only implements
 * those parts that are in use in the walreceiver api.
 *
 * May return NULL, rather than an error result, on failure.
 */</comment>
<function><type><specifier>static</specifier> <name>PGresult</name> <modifier>*</modifier></type>
<name>libpqrcv_PQexec</name><parameter_list>(<parameter><decl><type><name>PGconn</name> <modifier>*</modifier></type><name>streamConn</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>query</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier></type><name>lastResult</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * PQexec() silently discards any prior query results on the connection.
	 * This is not required for this function as it's expected that the caller
	 * (which is this library in all cases) will behave correctly and we don't
	 * have to be backwards compatible with old libpq.
	 */</comment>

	<comment type="block">/*
	 * Submit the query.  Since we don't use non-blocking mode, this could
	 * theoretically block.  In practice, since we don't send very long query
	 * strings, the risk seems negligible.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>PQsendQuery</name><argument_list>(<argument><expr><name>streamConn</name></expr></argument>, <argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

	<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
	<block>{<block_content>
		<comment type="block">/* Wait for, and collect, the next PGresult. */</comment>
		<decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>libpqrcv_PQgetResult</name><argument_list>(<argument><expr><name>streamConn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>result</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>				<comment type="block">/* query is complete, or failure */</comment>

		<comment type="block">/*
		 * Emulate PQexec()'s behavior of returning the last result when there
		 * are many.  We are fine with returning just last error message.
		 */</comment>
		<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>lastResult</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>lastResult</name> <operator>=</operator> <name>result</name></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>PQresultStatus</name><argument_list>(<argument><expr><name>lastResult</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>PGRES_COPY_IN</name> <operator>||</operator>
			<call><name>PQresultStatus</name><argument_list>(<argument><expr><name>lastResult</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>PGRES_COPY_OUT</name> <operator>||</operator>
			<call><name>PQresultStatus</name><argument_list>(<argument><expr><name>lastResult</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>PGRES_COPY_BOTH</name> <operator>||</operator>
			<call><name>PQstatus</name><argument_list>(<argument><expr><name>streamConn</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>CONNECTION_BAD</name></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>
	</block_content>}</block></for>

	<return>return <expr><name>lastResult</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Perform the equivalent of PQgetResult(), but watch for interrupts.
 */</comment>
<function><type><specifier>static</specifier> <name>PGresult</name> <modifier>*</modifier></type>
<name>libpqrcv_PQgetResult</name><parameter_list>(<parameter><decl><type><name>PGconn</name> <modifier>*</modifier></type><name>streamConn</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * Collect data until PQgetResult is ready to get the result without
	 * blocking.
	 */</comment>
	<while>while <condition>(<expr><call><name>PQisBusy</name><argument_list>(<argument><expr><name>streamConn</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>rc</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * We don't need to break down the sleep into smaller increments,
		 * since we'll get interrupted by signals and can handle any
		 * interrupts here.
		 */</comment>
		<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>WaitLatchOrSocket</name><argument_list>(<argument><expr><name>MyLatch</name></expr></argument>,
							   <argument><expr><name>WL_POSTMASTER_DEATH</name> <operator>|</operator> <name>WL_SOCKET_READABLE</name> <operator>|</operator>
							   <name>WL_LATCH_SET</name></expr></argument>,
							   <argument><expr><call><name>PQsocket</name><argument_list>(<argument><expr><name>streamConn</name></expr></argument>)</argument_list></call></expr></argument>,
							   <argument><expr><literal type="number">0</literal></expr></argument>,
							   <argument><expr><name>WAIT_EVENT_LIBPQWALRECEIVER_RECEIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Emergency bailout? */</comment>
		<if_stmt><if>if <condition>(<expr><name>rc</name> <operator>&amp;</operator> <name>WL_POSTMASTER_DEATH</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/* Interrupted? */</comment>
		<if_stmt><if>if <condition>(<expr><name>rc</name> <operator>&amp;</operator> <name>WL_LATCH_SET</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ResetLatch</name><argument_list>(<argument><expr><name>MyLatch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>ProcessWalRcvInterrupts</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* Consume whatever data is available from the socket */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>PQconsumeInput</name><argument_list>(<argument><expr><name>streamConn</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* trouble; return NULL */</comment>
			<return>return <expr><name>NULL</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></while>

	<comment type="block">/* Now we can collect and return the next PGresult */</comment>
	<return>return <expr><call><name>PQgetResult</name><argument_list>(<argument><expr><name>streamConn</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Disconnect connection to primary, if any.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>libpqrcv_disconnect</name><parameter_list>(<parameter><decl><type><name>WalReceiverConn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>PQfinish</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>streamConn</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>recvBuf</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PQfreemem</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>recvBuf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Receive a message available from XLOG stream.
 *
 * Returns:
 *
 *	 If data was received, returns the length of the data. *buffer is set to
 *	 point to a buffer holding the received message. The buffer is only valid
 *	 until the next libpqrcv_* call.
 *
 *	 If no data was available immediately, returns 0, and *wait_fd is set to a
 *	 socket descriptor which can be waited on before trying again.
 *
 *	 -1 if the server ended the COPY.
 *
 * ereports on error.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>libpqrcv_receive</name><parameter_list>(<parameter><decl><type><name>WalReceiverConn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>buffer</name></decl></parameter>,
				 <parameter><decl><type><name>pgsocket</name> <modifier>*</modifier></type><name>wait_fd</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>rawlen</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>recvBuf</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PQfreemem</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>recvBuf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>recvBuf</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<comment type="block">/* Try to receive a CopyData message */</comment>
	<expr_stmt><expr><name>rawlen</name> <operator>=</operator> <call><name>PQgetCopyData</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>streamConn</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>conn</name><operator>-&gt;</operator><name>recvBuf</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>rawlen</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Try consuming some data. */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>PQconsumeInput</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>streamConn</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not receive data from WAL stream: %s"</literal></expr></argument>,
							<argument><expr><call><name>pchomp</name><argument_list>(<argument><expr><call><name>PQerrorMessage</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>streamConn</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/* Now that we've consumed some input, try again */</comment>
		<expr_stmt><expr><name>rawlen</name> <operator>=</operator> <call><name>PQgetCopyData</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>streamConn</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>conn</name><operator>-&gt;</operator><name>recvBuf</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>rawlen</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Tell caller to try again when our socket is ready. */</comment>
			<expr_stmt><expr><operator>*</operator><name>wait_fd</name> <operator>=</operator> <call><name>PQsocket</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>streamConn</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><literal type="number">0</literal></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>rawlen</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>			<comment type="block">/* end-of-streaming or error */</comment>
	<block>{<block_content>
		<decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>libpqrcv_PQgetResult</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>streamConn</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>PQresultStatus</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>PGRES_COMMAND_OK</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* Verify that there are no more results. */</comment>
			<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>libpqrcv_PQgetResult</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>streamConn</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>res</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/*
				 * If the other side closed the connection orderly (otherwise
				 * we'd seen an error, or PGRES_COPY_IN) don't report an error
				 * here, but let callers deal with it.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><call><name>PQstatus</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>streamConn</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <name>CONNECTION_BAD</name></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"unexpected result after CommandComplete: %s"</literal></expr></argument>,
								<argument><expr><call><name>PQerrorMessage</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>streamConn</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><call><name>PQresultStatus</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>PGRES_COPY_IN</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not receive data from WAL stream: %s"</literal></expr></argument>,
							<argument><expr><call><name>pchomp</name><argument_list>(<argument><expr><call><name>PQerrorMessage</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>streamConn</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>rawlen</name> <operator>&lt;</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not receive data from WAL stream: %s"</literal></expr></argument>,
						<argument><expr><call><name>pchomp</name><argument_list>(<argument><expr><call><name>PQerrorMessage</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>streamConn</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Return received messages to caller */</comment>
	<expr_stmt><expr><operator>*</operator><name>buffer</name> <operator>=</operator> <name><name>conn</name><operator>-&gt;</operator><name>recvBuf</name></name></expr>;</expr_stmt>
	<return>return <expr><name>rawlen</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Send a message to XLOG stream.
 *
 * ereports on error.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>libpqrcv_send</name><parameter_list>(<parameter><decl><type><name>WalReceiverConn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>buffer</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nbytes</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><call><name>PQputCopyData</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>streamConn</name></name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>nbytes</name></expr></argument>)</argument_list></call> <operator>&lt;=</operator> <literal type="number">0</literal> <operator>||</operator>
		<call><name>PQflush</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>streamConn</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not send data to WAL stream: %s"</literal></expr></argument>,
						<argument><expr><call><name>pchomp</name><argument_list>(<argument><expr><call><name>PQerrorMessage</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>streamConn</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Create new replication slot.
 * Returns the name of the exported snapshot for logical slot or NULL for
 * physical slot.
 */</comment>
<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type>
<name>libpqrcv_create_slot</name><parameter_list>(<parameter><decl><type><name>WalReceiverConn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>slotname</name></decl></parameter>,
					 <parameter><decl><type><name>bool</name></type> <name>temporary</name></decl></parameter>, <parameter><decl><type><name>CRSSnapshotAction</name></type> <name>snapshot_action</name></decl></parameter>,
					 <parameter><decl><type><name>XLogRecPtr</name> <modifier>*</modifier></type><name>lsn</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>StringInfoData</name></type> <name>cmd</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>snapshot</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>initStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cmd</name></expr></argument>, <argument><expr><literal type="string">"CREATE_REPLICATION_SLOT \"%s\""</literal></expr></argument>, <argument><expr><name>slotname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>temporary</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cmd</name></expr></argument>, <argument><expr><literal type="string">" TEMPORARY"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>logical</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cmd</name></expr></argument>, <argument><expr><literal type="string">" LOGICAL pgoutput"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<switch>switch <condition>(<expr><name>snapshot_action</name></expr>)</condition>
		<block>{<block_content>
			<case>case <expr><name>CRS_EXPORT_SNAPSHOT</name></expr>:</case>
				<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cmd</name></expr></argument>, <argument><expr><literal type="string">" EXPORT_SNAPSHOT"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>CRS_NOEXPORT_SNAPSHOT</name></expr>:</case>
				<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cmd</name></expr></argument>, <argument><expr><literal type="string">" NOEXPORT_SNAPSHOT"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>CRS_USE_SNAPSHOT</name></expr>:</case>
				<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cmd</name></expr></argument>, <argument><expr><literal type="string">" USE_SNAPSHOT"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
		</block_content>}</block></switch>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>libpqrcv_PQexec</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>streamConn</name></name></expr></argument>, <argument><expr><name><name>cmd</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>cmd</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>PQresultStatus</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>PGRES_TUPLES_OK</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not create replication slot \"%s\": %s"</literal></expr></argument>,
						<argument><expr><name>slotname</name></expr></argument>, <argument><expr><call><name>pchomp</name><argument_list>(<argument><expr><call><name>PQerrorMessage</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>streamConn</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><operator>*</operator><name>lsn</name> <operator>=</operator> <call><name>DatumGetLSN</name><argument_list>(<argument><expr><call><name>DirectFunctionCall1Coll</name><argument_list>(<argument><expr><name>pg_lsn_in</name></expr></argument>, <argument><expr><name>InvalidOid</name></expr></argument>,
											   <argument><expr><call><name>CStringGetDatum</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>PQgetisnull</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>snapshot</name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>snapshot</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>snapshot</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Convert tuple query result to tuplestore.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>libpqrcv_processTuples</name><parameter_list>(<parameter><decl><type><name>PGresult</name> <modifier>*</modifier></type><name>pgres</name></decl></parameter>, <parameter><decl><type><name>WalRcvExecResult</name> <modifier>*</modifier></type><name>walres</name></decl></parameter>,
					   <parameter><decl><type><specifier>const</specifier> <name>int</name></type> <name>nRetTypes</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>Oid</name> <modifier>*</modifier></type><name>retTypes</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>tupn</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>coln</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>nfields</name> <init>= <expr><call><name>PQnfields</name><argument_list>(<argument><expr><name>pgres</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AttInMetadata</name> <modifier>*</modifier></type><name>attinmeta</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>rowcontext</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcontext</name></decl>;</decl_stmt>

	<comment type="block">/* Make sure we got expected number of fields. */</comment>
	<if_stmt><if>if <condition>(<expr><name>nfields</name> <operator>!=</operator> <name>nRetTypes</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid query response"</literal></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Expected %d fields, got %d fields."</literal></expr></argument>,
						   <argument><expr><name>nRetTypes</name></expr></argument>, <argument><expr><name>nfields</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name><name>walres</name><operator>-&gt;</operator><name>tuplestore</name></name> <operator>=</operator> <call><name>tuplestore_begin_heap</name><argument_list>(<argument><expr><name>true</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>work_mem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Create tuple descriptor corresponding to expected result. */</comment>
	<expr_stmt><expr><name><name>walres</name><operator>-&gt;</operator><name>tupledesc</name></name> <operator>=</operator> <call><name>CreateTemplateTupleDesc</name><argument_list>(<argument><expr><name>nRetTypes</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>coln</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>coln</name> <operator>&lt;</operator> <name>nRetTypes</name></expr>;</condition> <incr><expr><name>coln</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>TupleDescInitEntry</name><argument_list>(<argument><expr><name><name>walres</name><operator>-&gt;</operator><name>tupledesc</name></name></expr></argument>, <argument><expr><operator>(</operator><name>AttrNumber</name><operator>)</operator> <name>coln</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>,
						   <argument><expr><call><name>PQfname</name><argument_list>(<argument><expr><name>pgres</name></expr></argument>, <argument><expr><name>coln</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>retTypes</name><index>[<expr><name>coln</name></expr>]</index></name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
	<expr_stmt><expr><name>attinmeta</name> <operator>=</operator> <call><name>TupleDescGetAttInMetadata</name><argument_list>(<argument><expr><name><name>walres</name><operator>-&gt;</operator><name>tupledesc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* No point in doing more here if there were no tuples returned. */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>PQntuples</name><argument_list>(<argument><expr><name>pgres</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/* Create temporary context for local allocations. */</comment>
	<expr_stmt><expr><name>rowcontext</name> <operator>=</operator> <call><name>AllocSetContextCreate</name><argument_list>(<argument><expr><name>CurrentMemoryContext</name></expr></argument>,
									   <argument><expr><literal type="string">"libpqrcv query result context"</literal></expr></argument>,
									   <argument><expr><name>ALLOCSET_DEFAULT_SIZES</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Process returned rows. */</comment>
	<for>for <control>(<init><expr><name>tupn</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>tupn</name> <operator>&lt;</operator> <call><name>PQntuples</name><argument_list>(<argument><expr><name>pgres</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>tupn</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name><name>cstrs</name><index>[<expr><name>MaxTupleAttributeNumber</name></expr>]</index></name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>ProcessWalRcvInterrupts</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Do the allocations in temporary context. */</comment>
		<expr_stmt><expr><name>oldcontext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>rowcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Fill cstrs with null-terminated strings of column values.
		 */</comment>
		<for>for <control>(<init><expr><name>coln</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>coln</name> <operator>&lt;</operator> <name>nfields</name></expr>;</condition> <incr><expr><name>coln</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><call><name>PQgetisnull</name><argument_list>(<argument><expr><name>pgres</name></expr></argument>, <argument><expr><name>tupn</name></expr></argument>, <argument><expr><name>coln</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>cstrs</name><index>[<expr><name>coln</name></expr>]</index></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>cstrs</name><index>[<expr><name>coln</name></expr>]</index></name> <operator>=</operator> <call><name>PQgetvalue</name><argument_list>(<argument><expr><name>pgres</name></expr></argument>, <argument><expr><name>tupn</name></expr></argument>, <argument><expr><name>coln</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
		</block_content>}</block></for>

		<comment type="block">/* Convert row to a tuple, and add it to the tuplestore */</comment>
		<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>BuildTupleFromCStrings</name><argument_list>(<argument><expr><name>attinmeta</name></expr></argument>, <argument><expr><name>cstrs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>tuplestore_puttuple</name><argument_list>(<argument><expr><name><name>walres</name><operator>-&gt;</operator><name>tuplestore</name></name></expr></argument>, <argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Clean up */</comment>
		<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>MemoryContextReset</name><argument_list>(<argument><expr><name>rowcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>MemoryContextDelete</name><argument_list>(<argument><expr><name>rowcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Public interface for sending generic queries (and commands).
 *
 * This can only be called from process connected to database.
 */</comment>
<function><type><specifier>static</specifier> <name>WalRcvExecResult</name> <modifier>*</modifier></type>
<name>libpqrcv_exec</name><parameter_list>(<parameter><decl><type><name>WalReceiverConn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>query</name></decl></parameter>,
			  <parameter><decl><type><specifier>const</specifier> <name>int</name></type> <name>nRetTypes</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>Oid</name> <modifier>*</modifier></type><name>retTypes</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier></type><name>pgres</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>WalRcvExecResult</name> <modifier>*</modifier></type><name>walres</name> <init>= <expr><call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>WalRcvExecResult</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>MyDatabaseId</name> <operator>==</operator> <name>InvalidOid</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"the query interface requires a database connection"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>pgres</name> <operator>=</operator> <call><name>libpqrcv_PQexec</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>streamConn</name></name></expr></argument>, <argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<switch>switch <condition>(<expr><call><name>PQresultStatus</name><argument_list>(<argument><expr><name>pgres</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>PGRES_SINGLE_TUPLE</name></expr>:</case>
		<case>case <expr><name>PGRES_TUPLES_OK</name></expr>:</case>
			<expr_stmt><expr><name><name>walres</name><operator>-&gt;</operator><name>status</name></name> <operator>=</operator> <name>WALRCV_OK_TUPLES</name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>libpqrcv_processTuples</name><argument_list>(<argument><expr><name>pgres</name></expr></argument>, <argument><expr><name>walres</name></expr></argument>, <argument><expr><name>nRetTypes</name></expr></argument>, <argument><expr><name>retTypes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>PGRES_COPY_IN</name></expr>:</case>
			<expr_stmt><expr><name><name>walres</name><operator>-&gt;</operator><name>status</name></name> <operator>=</operator> <name>WALRCV_OK_COPY_IN</name></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>PGRES_COPY_OUT</name></expr>:</case>
			<expr_stmt><expr><name><name>walres</name><operator>-&gt;</operator><name>status</name></name> <operator>=</operator> <name>WALRCV_OK_COPY_OUT</name></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>PGRES_COPY_BOTH</name></expr>:</case>
			<expr_stmt><expr><name><name>walres</name><operator>-&gt;</operator><name>status</name></name> <operator>=</operator> <name>WALRCV_OK_COPY_BOTH</name></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>PGRES_COMMAND_OK</name></expr>:</case>
			<expr_stmt><expr><name><name>walres</name><operator>-&gt;</operator><name>status</name></name> <operator>=</operator> <name>WALRCV_OK_COMMAND</name></expr>;</expr_stmt>
			<break>break;</break>

			<comment type="block">/* Empty query is considered error. */</comment>
		<case>case <expr><name>PGRES_EMPTY_QUERY</name></expr>:</case>
			<expr_stmt><expr><name><name>walres</name><operator>-&gt;</operator><name>status</name></name> <operator>=</operator> <name>WALRCV_ERROR</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>walres</name><operator>-&gt;</operator><name>err</name></name> <operator>=</operator> <call><name>_</name><argument_list>(<argument><expr><literal type="string">"empty query"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>PGRES_NONFATAL_ERROR</name></expr>:</case>
		<case>case <expr><name>PGRES_FATAL_ERROR</name></expr>:</case>
		<case>case <expr><name>PGRES_BAD_RESPONSE</name></expr>:</case>
			<expr_stmt><expr><name><name>walres</name><operator>-&gt;</operator><name>status</name></name> <operator>=</operator> <name>WALRCV_ERROR</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>walres</name><operator>-&gt;</operator><name>err</name></name> <operator>=</operator> <call><name>pchomp</name><argument_list>(<argument><expr><call><name>PQerrorMessage</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>streamConn</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
	</block_content>}</block></switch>

	<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>pgres</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>walres</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Given a List of strings, return it as single comma separated
 * string, quoting identifiers as needed.
 *
 * This is essentially the reverse of SplitIdentifierString.
 *
 * The caller should free the result.
 */</comment>
<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type>
<name>stringlist_to_identifierstr</name><parameter_list>(<parameter><decl><type><name>PGconn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>strings</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>StringInfoData</name></type> <name>res</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>first</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>initStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>strings</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>val</name> <init>= <expr><call><name>strVal</name><argument_list>(<argument><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>val_escaped</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>first</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>first</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><operator>&amp;</operator><name>res</name></expr></argument>, <argument><expr><literal type="char">','</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<expr_stmt><expr><name>val_escaped</name> <operator>=</operator> <call><name>PQescapeIdentifier</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>val</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>val_escaped</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>res</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>NULL</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>res</name></expr></argument>, <argument><expr><name>val_escaped</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>PQfreemem</name><argument_list>(<argument><expr><name>val_escaped</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<return>return <expr><name><name>res</name><operator>.</operator><name>data</name></name></expr>;</return>
</block_content>}</block></function>
</unit>
