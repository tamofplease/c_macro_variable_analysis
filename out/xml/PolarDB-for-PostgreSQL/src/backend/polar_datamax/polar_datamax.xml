<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/PolarDB-for-PostgreSQL/src/backend/polar_datamax/polar_datamax.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * polar_datamax.c
 * 
 *
 * Copyright (c) 2020, Alibaba Group Holding Limited
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * IDENTIFICATION
 *    src/backend/polar_datamax/polar_datamax.c
 *
 *-------------------------------------------------------------------------
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/timeline.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/xlog.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/xlog_internal.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/xlogreader.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pgstat.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"polar_datamax/polar_datamax.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postmaster/pgarch.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postmaster/startup.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"replication/slot.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"replication/walreceiver.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/fd.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/polar_fd.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/pmsignal.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/guc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/ps_status.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/timestamp.h"</cpp:file></cpp:include>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>POLAR_DATA_DIR</name></cpp:macro> <cpp:value>(POLAR_FILE_IN_SHARED_STORAGE() ? polar_datadir : DataDir)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RECOVERY_COMMAND_FILE</name></cpp:macro>   <cpp:value>"recovery.conf"</cpp:value></cpp:define>

<comment type="block">/* initial meta means just initilized meta */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DATAMAX_IS_INITIAL_META</name><parameter_list>(<parameter><type><name>meta</name></type></parameter>)</parameter_list></cpp:macro> \
	<cpp:value>((meta)-&gt;last_timeline_id == POLAR_INVALID_TIMELINE_ID &amp;&amp; \
	 XLogRecPtrIsInvalid((meta)-&gt;last_received_lsn))</cpp:value></cpp:define>

<comment type="block">/*
 * We use mechanism which depend on polar_vfs extension to maintain DataMax mode.
 * polar_vfs extension will initialize node type from recovery.conf while extension
 * initialization in polar_vfs_shmem_startup. So we relay on polar_vfs and its
 * startup function being executed while shared memory initialization.
 *
 * So the DataMax mode will be set before all other operations in DB, and its value
 * wil be kept while postmaster fork another sub-process. Eventually, all processes
 * know the DataMax mode.
 */</comment>
<decl_stmt><decl><type><name>bool</name></type> <name>polar_datamax_mode_requested</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>polar_is_datamax_mode</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>polar_datamax_ctl_t</name> <modifier>*</modifier></type><name>polar_datamax_ctl</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<comment type="block">/* POLAR: set true when received shutdown request */</comment>
<decl_stmt><decl><type><name>bool</name></type> <name>polar_datamax_shutdown_requested</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

<comment type="block">/* POLAR: polar datamax guc parameters */</comment>
<decl_stmt><decl><type><name>int</name></type> <name>polar_datamax_remove_archivedone_wal_timeout</name> <init>= <expr><literal type="number">60000</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>polar_datamax_archive_timeout</name> <init>= <expr><literal type="number">60000</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>polar_datamax_save_replication_slots_timeout</name> <init>= <expr><literal type="number">300000</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>polar_datamax_prealloc_walfile_timeout</name> <init>= <expr><literal type="number">30000</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>polar_datamax_prealloc_walfile_num</name> <init>= <expr><literal type="number">2</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>primary_conninfo</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>primary_slot_name</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type>  <name>polar_datamax_io_errno</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>polar_datamax_io_error_cause</name></type> <name>polar_datamax_io_errcause</name></decl>;</decl_stmt>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>polar_datamax_xlog_read</name><parameter_list>(<parameter><decl><type><name>TimeLineID</name></type> <name>tli</name></decl></parameter>, <parameter><decl><type><name>XLogRecPtr</name></type> <name>start_ptr</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><name>Size</name></type> <name>count</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>polar_datamax_xlog_read_page</name><parameter_list>(<parameter><decl><type><name>XLogReaderState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>XLogRecPtr</name></type> <name>target_page_ptr</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>req_len</name></decl></parameter>,
										<parameter><decl><type><name>XLogRecPtr</name></type> <name>target_ptr</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>read_buff</name></decl></parameter>, <parameter><decl><type><name>TimeLineID</name> <modifier>*</modifier></type><name>cur_file_tli</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/*
 * POLAR: func for test
 */</comment>
<function><type><name>char</name> <modifier>*</modifier></type>
<name>polar_datamax_get_primary_info</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><name>primary_conninfo</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>char</name> <modifier>*</modifier></type>
<name>polar_datamax_get_primary_slot_name</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><name>primary_slot_name</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * POLAR: datamax shared memory size.
 */</comment>
<function><type><name>Size</name></type>
<name>polar_datamax_shmem_size</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Size</name></type> <name>size</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<comment type="block">/* POLAR: use polar_local_node_type in case XlogCtl can't be accessed during reaper process */</comment>
	<if_stmt><if>if <condition>(<expr><name>polar_local_node_type</name> <operator>!=</operator> <name>POLAR_STANDALONE_DATAMAX</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>size</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>size</name> <operator>=</operator> <call><name>add_size</name><argument_list>(<argument><expr><name>size</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>polar_datamax_ctl_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>size</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * POLAR: datamax shared memory initialization.
 */</comment>
<function><type><name>void</name></type>
<name>polar_datamax_shmem_init</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type> <name>found</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>polar_is_datamax</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>polar_datamax_ctl</name> <operator>=</operator> <operator>(</operator><name>polar_datamax_ctl_t</name> <operator>*</operator><operator>)</operator>
						<call><name>ShmemInitStruct</name><argument_list>(<argument><expr><literal type="string">"Datamax control"</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>polar_datamax_ctl_t</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><operator>&amp;</operator><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>IsUnderPostmaster</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type> <name>lock_tranche</name> <init>= <expr><call><name>LWLockNewTrancheId</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>LWLockRegisterTranche</name><argument_list>(<argument><expr><name>lock_tranche</name></expr></argument>, <argument><expr><literal type="string">"datamax meta lock"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>LWLockInitialize</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>polar_datamax_ctl</name><operator>-&gt;</operator><name>meta_lock</name></name></expr></argument>, <argument><expr><name>lock_tranche</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>polar_datamax_init_meta</name><argument_list>(<argument><expr><name>POLAR_DATAMAX_META</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>SpinLockInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>polar_datamax_ctl</name><operator>-&gt;</operator><name>lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>polar_datamax_reset_clean_task</name><argument_list>(<argument><expr><name>polar_datamax_ctl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * POLAR: Read recovery.conf for DataMax node.
 *
 * We won't read all config options, just read options related to DataMax node.
 * Main logic is similar with readRecoveryCommandFile in Startup.
 */</comment>
<function><type><name>void</name></type>
<name>polar_datamax_read_recovery_conf</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>FILE</name>       <modifier>*</modifier></type><name>fd</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ConfigVariable</name> <modifier>*</modifier></type><name>item</name></decl>,
				   <decl><type ref="prev"><modifier>*</modifier></type><name>head</name> <init>= <expr><name>NULL</name></expr></init></decl>,
					<decl><type ref="prev"><modifier>*</modifier></type><name>tail</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>polar_is_datamax</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>fd</name> <operator>=</operator> <call><name>AllocateFile</name><argument_list>(<argument><expr><name>RECOVERY_COMMAND_FILE</name></expr></argument>, <argument><expr><literal type="string">"r"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>fd</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* POLAR: recovery.conf is necessary for DataMax node */</comment>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not open recovery command file \"%s\": %m"</literal></expr></argument>,
						<argument><expr><name>RECOVERY_COMMAND_FILE</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>ParseConfigFp</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name>RECOVERY_COMMAND_FILE</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>FATAL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>head</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tail</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>FreeFile</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>item</name> <operator>=</operator> <name>head</name></expr>;</init> <condition><expr><name>item</name></expr>;</condition> <incr><expr><name>item</name> <operator>=</operator> <name><name>item</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>POLAR_ENABLE_DMA</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <call><name>strcmp</name><argument_list>(<argument><expr><name><name>item</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><literal type="string">"primary_conninfo"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>primary_conninfo</name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><name><name>item</name><operator>-&gt;</operator><name>value</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>DEBUG2</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errmsg_internal</name><argument_list>(<argument><expr><literal type="string">"primary_conninfo = '%s'"</literal></expr></argument>,
									 <argument><expr><name>primary_conninfo</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>POLAR_ENABLE_DMA</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <call><name>strcmp</name><argument_list>(<argument><expr><name><name>item</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><literal type="string">"primary_slot_name"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ReplicationSlotValidateName</name><argument_list>(<argument><expr><name><name>item</name><operator>-&gt;</operator><name>value</name></name></expr></argument>, <argument><expr><name>ERROR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>primary_slot_name</name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><name><name>item</name><operator>-&gt;</operator><name>value</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>DEBUG2</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errmsg_internal</name><argument_list>(<argument><expr><literal type="string">"primary_slot_name = '%s'"</literal></expr></argument>,
									 <argument><expr><name>primary_slot_name</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>item</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><literal type="string">"polar_datamax_mode"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>item</name><operator>-&gt;</operator><name>value</name></name></expr></argument>, <argument><expr><literal type="string">"standalone"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>polar_datamax_mode_requested</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
								<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"parameter \"%s\" has unknown value: %s"</literal></expr></argument>,
									   <argument><expr><literal type="string">"polar_datamax_mode"</literal></expr></argument>, <argument><expr><name><name>item</name><operator>-&gt;</operator><name>value</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>POLAR_ENABLE_DMA</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <operator>(</operator><name>primary_conninfo</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name>primary_slot_name</name> <operator>==</operator> <name>NULL</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"recovery command file \"%s\" does't specified primary_conninfo or primary_slot_name"</literal></expr></argument>,
						<argument><expr><name>RECOVERY_COMMAND_FILE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"primary_conninfo and primary_slot_name is necessary for DataMax node, please specify them in %s"</literal></expr></argument>,
						 <argument><expr><name>RECOVERY_COMMAND_FILE</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * We don't support polar_datamax_mode in standalone backends; that requires
	 * other processes such as the WAL receiver to be alive.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>polar_datamax_mode_requested</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>IsUnderPostmaster</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"datamax mode is not supported by single-user servers"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>polar_datamax_mode_requested</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"datamax mode with polar_datamax_mode conf missing"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>FreeConfigVariables</name><argument_list>(<argument><expr><name>head</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * POLAR: Whether DataMax is a initial one or not.
 *
 * Return true if it's a initial DataMax node, otherwise false which means
 * it's not an initial DataMax node or not even a DataMax node.
 */</comment>
<function><type><name>bool</name></type>
<name>polar_datamax_is_initial</name><parameter_list>(<parameter><decl><type><name>polar_datamax_ctl_t</name> <modifier>*</modifier></type><name>ctl</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type> <name>ret</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>polar_is_datamax</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>ctl</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ctl</name><operator>-&gt;</operator><name>meta_lock</name></name></expr></argument>, <argument><expr><name>LW_SHARED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>DATAMAX_IS_INITIAL_META</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ctl</name><operator>-&gt;</operator><name>meta</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ctl</name><operator>-&gt;</operator><name>meta_lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>ret</name></expr>;</return>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * POLAR: Init datamax meta data info.
 *
 * If create is true, we initialize all variables with some initial value.
 * Otherwise, if not we set all variables 0.
 */</comment>
<function><type><name>void</name></type>
<name>polar_datamax_init_meta</name><parameter_list>(<parameter><decl><type><name>polar_datamax_meta_data_t</name> <modifier>*</modifier></type><name>meta</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>create</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>create</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>meta</name><operator>-&gt;</operator><name>magic</name></name>         <operator>=</operator> <name>POLAR_DATAMAX_MAGIC</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>meta</name><operator>-&gt;</operator><name>version</name></name>       <operator>=</operator> <name>POLAR_DATAMAX_VERSION</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name><name>meta</name><operator>-&gt;</operator><name>magic</name></name>         <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>meta</name><operator>-&gt;</operator><name>version</name></name>       <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><name><name>meta</name><operator>-&gt;</operator><name>min_timeline_id</name></name>   <operator>=</operator> <name>POLAR_INVALID_TIMELINE_ID</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>meta</name><operator>-&gt;</operator><name>min_received_lsn</name></name>  <operator>=</operator> <name>InvalidXLogRecPtr</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>meta</name><operator>-&gt;</operator><name>last_timeline_id</name></name>  <operator>=</operator> <name>POLAR_INVALID_TIMELINE_ID</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>meta</name><operator>-&gt;</operator><name>last_received_lsn</name></name> <operator>=</operator> <name>InvalidXLogRecPtr</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>meta</name><operator>-&gt;</operator><name>last_valid_received_lsn</name></name> <operator>=</operator> <name>InvalidXLogRecPtr</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>meta</name><operator>-&gt;</operator><name>upstream_last_removed_segno</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>meta</name><operator>-&gt;</operator><name>crc</name></name>       <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>meta</name><operator>-&gt;</operator><name>crc</name></name>       <operator>=</operator> <call><name>polar_datamax_calc_meta_crc</name><argument_list>(
						  <argument><expr><operator>(</operator><name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator><name>meta</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>polar_datamax_meta_data_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * POLAR: Load datamax meta info from storage.
 * We will check magic, version and crc of meta from data corruption.
 */</comment>
<function><type><name>void</name></type>
<name>polar_datamax_load_meta</name><parameter_list>(<parameter><decl><type><name>polar_datamax_ctl_t</name> <modifier>*</modifier></type><name>ctl</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name></type>        <name><name>meta_path</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>pg_crc32c</name></type>   <name>crc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>         <name>fd</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>         <name>ret</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Size</name></type>        <name>meta_size</name> <init>= <expr><sizeof>sizeof<argument_list>(<argument><expr><name>polar_datamax_meta_data_t</name></expr></argument>)</argument_list></sizeof></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>polar_datamax_meta_data_t</name> <modifier>*</modifier></type><name>meta</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>ctl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>meta</name> <operator>=</operator> <operator>&amp;</operator><name><name>ctl</name><operator>-&gt;</operator><name>meta</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>meta_path</name></expr></argument>, <argument><expr><name>MAXPGPATH</name></expr></argument>, <argument><expr><literal type="string">"%s/%s/%s"</literal></expr></argument>,
			 <argument><expr><name>POLAR_DATA_DIR</name></expr></argument>, <argument><expr><name>POLAR_DATAMAX_DIR</name></expr></argument>, <argument><expr><name>POLAR_DATAMAX_META_FILE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ctl</name><operator>-&gt;</operator><name>meta_lock</name></name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>fd</name> <operator>=</operator> <call><name>PathNameOpenFile</name><argument_list>(<argument><expr><name>meta_path</name></expr></argument>, <argument><expr><name>O_RDONLY</name> <operator>|</operator> <name>PG_BINARY</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>errno</name> <operator>==</operator> <name>ENOENT</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>, <argument><expr><literal type="string">"datamax meta file not exist, init memory one."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>polar_datamax_init_meta</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ctl</name><operator>-&gt;</operator><name>meta</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ctl</name><operator>-&gt;</operator><name>meta_lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return;</return>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ctl</name><operator>-&gt;</operator><name>meta_lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>, <argument><expr><literal type="string">"fail to open datamax meta file, errno: %d"</literal></expr></argument>, <argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>polar_file_pread</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>meta</name></expr></argument>, <argument><expr><name>meta_size</name></expr></argument>,
						   <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>WAIT_EVENT_DATAMAX_META_READ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>!=</operator> <name>meta_size</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type> <name>saved_errno</name> <init>= <expr><name>errno</name></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ctl</name><operator>-&gt;</operator><name>meta_lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>, <argument><expr><literal type="string">"fail to read whole datamax meta data, read %d of %lu, errno: %d"</literal></expr></argument>,
			 <argument><expr><name>ret</name></expr></argument>, <argument><expr><name>meta_size</name></expr></argument>, <argument><expr><name>saved_errno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>meta</name><operator>-&gt;</operator><name>magic</name></name> <operator>!=</operator> <name>POLAR_DATAMAX_MAGIC</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ctl</name><operator>-&gt;</operator><name>meta_lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>POLAR_LOG_DATAMAX_META_INFO</name><argument_list>(<argument><expr><name>meta</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>, <argument><expr><literal type="string">"invalid datamax meta magic, got %d, expect %d"</literal></expr></argument>,
			 <argument><expr><name><name>meta</name><operator>-&gt;</operator><name>magic</name></name></expr></argument>, <argument><expr><name>POLAR_DATAMAX_MAGIC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* version compatibility will be added if new version required */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>meta</name><operator>-&gt;</operator><name>version</name></name> <operator>!=</operator> <name>POLAR_DATAMAX_VERSION</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ctl</name><operator>-&gt;</operator><name>meta_lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>POLAR_LOG_DATAMAX_META_INFO</name><argument_list>(<argument><expr><name>meta</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>, <argument><expr><literal type="string">"datamax meta version is not compatible, got %d, expect %d"</literal></expr></argument>,
			 <argument><expr><name><name>meta</name><operator>-&gt;</operator><name>version</name></name></expr></argument>, <argument><expr><name>POLAR_DATAMAX_VERSION</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>crc</name> <operator>=</operator> <name><name>meta</name><operator>-&gt;</operator><name>crc</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>meta</name><operator>-&gt;</operator><name>crc</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>meta</name><operator>-&gt;</operator><name>crc</name></name> <operator>=</operator> <call><name>polar_datamax_calc_meta_crc</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator><name>meta</name></expr></argument>, <argument><expr><name>meta_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>crc</name> <operator>!=</operator> <name><name>meta</name><operator>-&gt;</operator><name>crc</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ctl</name><operator>-&gt;</operator><name>meta_lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>POLAR_LOG_DATAMAX_META_INFO</name><argument_list>(<argument><expr><name>meta</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>, <argument><expr><literal type="string">"invalid datamax meta crc, got %d, expect %d"</literal></expr></argument>, <argument><expr><name>crc</name></expr></argument>, <argument><expr><name><name>meta</name><operator>-&gt;</operator><name>crc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ctl</name><operator>-&gt;</operator><name>meta_lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * POLAR: Write datamax meta data to storage.
 *
 * This func can only be called in datamax process, so no need to get lock first.
 */</comment>
<function><type><name>void</name></type>
<name>polar_datamax_write_meta</name><parameter_list>(<parameter><decl><type><name>polar_datamax_ctl_t</name> <modifier>*</modifier></type><name>ctl</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>update</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>File</name></type>    <name>fd</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>    <name><name>meta_path</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>     <name>flag</name> <init>= <expr><name>O_RDWR</name> <operator>|</operator> <name>PG_BINARY</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Size</name></type>    <name>meta_size</name> <init>= <expr><sizeof>sizeof<argument_list>(<argument><expr><name>polar_datamax_meta_data_t</name></expr></argument>)</argument_list></sizeof></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>     <name>saved_errno</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>polar_datamax_meta_data_t</name> <modifier>*</modifier></type><name>meta</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>ctl</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>meta</name> <operator>=</operator> <operator>&amp;</operator><name><name>ctl</name><operator>-&gt;</operator><name>meta</name></name></expr>;</expr_stmt></block_content></block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>, <argument><expr><literal type="string">"fail to write datamax meta data, invalid datamax meta"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>meta_path</name></expr></argument>, <argument><expr><name>MAXPGPATH</name></expr></argument>, <argument><expr><literal type="string">"%s/%s/%s"</literal></expr></argument>, <argument><expr><name>POLAR_DATA_DIR</name></expr></argument>, <argument><expr><name>POLAR_DATAMAX_DIR</name></expr></argument>, <argument><expr><name>POLAR_DATAMAX_META_FILE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>update</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>flag</name> <operator>|=</operator> <name>O_CREAT</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ctl</name><operator>-&gt;</operator><name>meta_lock</name></name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>meta</name><operator>-&gt;</operator><name>magic</name></name> <operator>=</operator> <name>POLAR_DATAMAX_MAGIC</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>meta</name><operator>-&gt;</operator><name>version</name></name> <operator>=</operator> <name>POLAR_DATAMAX_VERSION</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>meta</name><operator>-&gt;</operator><name>crc</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>meta</name><operator>-&gt;</operator><name>crc</name></name> <operator>=</operator> <call><name>polar_datamax_calc_meta_crc</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator><name>meta</name></expr></argument>, <argument><expr><name>meta_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>fd</name> <operator>=</operator> <call><name>PathNameOpenFile</name><argument_list>(<argument><expr><name>meta_path</name></expr></argument>, <argument><expr><name>flag</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>saved_errno</name> <operator>=</operator> <name>errno</name></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ctl</name><operator>-&gt;</operator><name>meta_lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>POLAR_LOG_DATAMAX_META_INFO</name><argument_list>(<argument><expr><name>meta</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>, <argument><expr><literal type="string">"fail to open datamax meta file, errno: %d"</literal></expr></argument>, <argument><expr><name>saved_errno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>FileWrite</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>meta</name></expr></argument>, <argument><expr><name>meta_size</name></expr></argument>, <argument><expr><name>WAIT_EVENT_DATAMAX_META_WRITE</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>meta_size</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>saved_errno</name> <operator>=</operator> <name>errno</name></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ctl</name><operator>-&gt;</operator><name>meta_lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>POLAR_LOG_DATAMAX_META_INFO</name><argument_list>(<argument><expr><name>meta</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>, <argument><expr><literal type="string">"fail to write datamax meta data, errno: %d"</literal></expr></argument>, <argument><expr><name>saved_errno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>FileSync</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name>WAIT_EVENT_DATAMAX_META_WRITE</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>saved_errno</name> <operator>=</operator> <name>errno</name></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ctl</name><operator>-&gt;</operator><name>meta_lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>POLAR_LOG_DATAMAX_META_INFO</name><argument_list>(<argument><expr><name>meta</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>, <argument><expr><literal type="string">"fail to sync datamax meta data to storage, errno: %d"</literal></expr></argument>, <argument><expr><name>saved_errno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>FileClose</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ctl</name><operator>-&gt;</operator><name>meta_lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>polar_datamax_update_received_info</name><parameter_list>(<parameter><decl><type><name>polar_datamax_ctl_t</name> <modifier>*</modifier></type><name>ctl</name></decl></parameter>, <parameter><decl><type><name>TimeLineID</name></type> <name>tli</name></decl></parameter>, <parameter><decl><type><name>XLogRecPtr</name></type> <name>lsn</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>ctl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ctl</name><operator>-&gt;</operator><name>meta_lock</name></name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>tli</name> <operator>!=</operator> <name>POLAR_INVALID_TIMELINE_ID</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>ctl</name><operator>-&gt;</operator><name>meta</name><operator>.</operator><name>last_timeline_id</name></name> <operator>=</operator> <name>tli</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>XLogRecPtrIsInvalid</name><argument_list>(<argument><expr><name>lsn</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>ctl</name><operator>-&gt;</operator><name>meta</name><operator>.</operator><name>last_received_lsn</name></name> <operator>=</operator> <name>lsn</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ctl</name><operator>-&gt;</operator><name>meta_lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>polar_datamax_update_last_valid_received_lsn</name><parameter_list>(<parameter><decl><type><name>polar_datamax_ctl_t</name> <modifier>*</modifier></type><name>ctl</name></decl></parameter>, <parameter><decl><type><name>XLogRecPtr</name></type> <name>lsn</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>ctl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ctl</name><operator>-&gt;</operator><name>meta_lock</name></name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>XLogRecPtrIsInvalid</name><argument_list>(<argument><expr><name>lsn</name></expr></argument>)</argument_list></call> <operator>||</operator> <name>lsn</name> <operator>&lt;</operator> <name><name>ctl</name><operator>-&gt;</operator><name>meta</name><operator>.</operator><name>last_valid_received_lsn</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>, <argument><expr><literal type="string">"invalid lsn when update datamax meta, parameter lsn is expected not smaller than last_valid_lsn"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>lsn</name> <operator>!=</operator> <name><name>ctl</name><operator>-&gt;</operator><name>meta</name><operator>.</operator><name>last_valid_received_lsn</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>ctl</name><operator>-&gt;</operator><name>meta</name><operator>.</operator><name>last_valid_received_lsn</name></name> <operator>=</operator> <name>lsn</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ctl</name><operator>-&gt;</operator><name>meta_lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>polar_datamax_update_min_received_info</name><parameter_list>(<parameter><decl><type><name>polar_datamax_ctl_t</name> <modifier>*</modifier></type><name>ctl</name></decl></parameter>, <parameter><decl><type><name>TimeLineID</name></type> <name>tli</name></decl></parameter>, <parameter><decl><type><name>XLogRecPtr</name></type> <name>lsn</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>ctl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ctl</name><operator>-&gt;</operator><name>meta_lock</name></name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>tli</name> <operator>!=</operator> <name>POLAR_INVALID_TIMELINE_ID</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>ctl</name><operator>-&gt;</operator><name>meta</name><operator>.</operator><name>min_timeline_id</name></name> <operator>=</operator> <name>tli</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>XLogRecPtrIsInvalid</name><argument_list>(<argument><expr><name>lsn</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>ctl</name><operator>-&gt;</operator><name>meta</name><operator>.</operator><name>min_received_lsn</name></name> <operator>=</operator> <name>lsn</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ctl</name><operator>-&gt;</operator><name>meta_lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>polar_datamax_update_upstream_last_removed_segno</name><parameter_list>(<parameter><decl><type><name>polar_datamax_ctl_t</name> <modifier>*</modifier></type><name>ctl</name></decl></parameter>, <parameter><decl><type><name>XLogSegNo</name></type> <name>segno</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>ctl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ctl</name><operator>-&gt;</operator><name>meta_lock</name></name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * POLAR: parameter segno could be smaller than meta.upstream_last_removed_segno
	 * eg. it maybe 0 when primary restart and there is no wal file has been removed
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>segno</name> <operator>&gt;</operator> <name><name>ctl</name><operator>-&gt;</operator><name>meta</name><operator>.</operator><name>upstream_last_removed_segno</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>ctl</name><operator>-&gt;</operator><name>meta</name><operator>.</operator><name>upstream_last_removed_segno</name></name> <operator>=</operator> <name>segno</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ctl</name><operator>-&gt;</operator><name>meta_lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>XLogRecPtr</name></type>
<name>polar_datamax_get_min_received_lsn</name><parameter_list>(<parameter><decl><type><name>polar_datamax_ctl_t</name> <modifier>*</modifier></type><name>ctl</name></decl></parameter>, <parameter><decl><type><name>TimeLineID</name> <modifier>*</modifier></type><name>tli</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>XLogRecPtr</name></type> <name>min_received_lsn</name> <init>= <expr><name>InvalidXLogRecPtr</name></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>ctl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ctl</name><operator>-&gt;</operator><name>meta_lock</name></name></expr></argument>, <argument><expr><name>LW_SHARED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>tli</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><operator>*</operator><name>tli</name> <operator>=</operator> <name><name>ctl</name><operator>-&gt;</operator><name>meta</name><operator>.</operator><name>min_timeline_id</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>min_received_lsn</name> <operator>=</operator> <name><name>ctl</name><operator>-&gt;</operator><name>meta</name><operator>.</operator><name>min_received_lsn</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ctl</name><operator>-&gt;</operator><name>meta_lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>min_received_lsn</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>polar_datamax_get_last_received_info</name><parameter_list>(<parameter><decl><type><name>polar_datamax_ctl_t</name> <modifier>*</modifier></type><name>ctl</name></decl></parameter>, <parameter><decl><type><name>TimeLineID</name> <modifier>*</modifier></type><name>tli</name></decl></parameter>, <parameter><decl><type><name>XLogRecPtr</name> <modifier>*</modifier></type><name>lsn</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>ctl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ctl</name><operator>-&gt;</operator><name>meta_lock</name></name></expr></argument>, <argument><expr><name>LW_SHARED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>tli</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><operator>*</operator><name>tli</name> <operator>=</operator> <name><name>ctl</name><operator>-&gt;</operator><name>meta</name><operator>.</operator><name>last_timeline_id</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>lsn</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><operator>*</operator><name>lsn</name> <operator>=</operator> <name><name>ctl</name><operator>-&gt;</operator><name>meta</name><operator>.</operator><name>last_received_lsn</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ctl</name><operator>-&gt;</operator><name>meta_lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * POLAR: get last received lsn
 */</comment>
<function><type><name>XLogRecPtr</name></type>
<name>polar_datamax_get_last_received_lsn</name><parameter_list>(<parameter><decl><type><name>polar_datamax_ctl_t</name> <modifier>*</modifier></type><name>ctl</name></decl></parameter>, <parameter><decl><type><name>TimeLineID</name> <modifier>*</modifier></type><name>tli</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>XLogRecPtr</name></type> <name>last_received_lsn</name> <init>= <expr><name>InvalidXLogRecPtr</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>ctl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ctl</name><operator>-&gt;</operator><name>meta_lock</name></name></expr></argument>, <argument><expr><name>LW_SHARED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>tli</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><operator>*</operator><name>tli</name> <operator>=</operator> <name><name>ctl</name><operator>-&gt;</operator><name>meta</name><operator>.</operator><name>last_timeline_id</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>last_received_lsn</name> <operator>=</operator> <name><name>ctl</name><operator>-&gt;</operator><name>meta</name><operator>.</operator><name>last_received_lsn</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ctl</name><operator>-&gt;</operator><name>meta_lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>last_received_lsn</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * POLAR: get last valid received lsn
 */</comment>
<function><type><name>XLogRecPtr</name></type>
<name>polar_datamax_get_last_valid_received_lsn</name><parameter_list>(<parameter><decl><type><name>polar_datamax_ctl_t</name> <modifier>*</modifier></type><name>ctl</name></decl></parameter>, <parameter><decl><type><name>TimeLineID</name> <modifier>*</modifier></type><name>tli</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>XLogRecPtr</name></type> <name>last_valid_received_lsn</name> <init>= <expr><name>InvalidXLogRecPtr</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>ctl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ctl</name><operator>-&gt;</operator><name>meta_lock</name></name></expr></argument>, <argument><expr><name>LW_SHARED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>tli</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><operator>*</operator><name>tli</name> <operator>=</operator> <name><name>ctl</name><operator>-&gt;</operator><name>meta</name><operator>.</operator><name>last_timeline_id</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>last_valid_received_lsn</name> <operator>=</operator> <name><name>ctl</name><operator>-&gt;</operator><name>meta</name><operator>.</operator><name>last_valid_received_lsn</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ctl</name><operator>-&gt;</operator><name>meta_lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>last_valid_received_lsn</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * POLAR: get last removed segno of upstream
 */</comment>
<function><type><name>XLogSegNo</name></type>
<name>polar_datamax_get_upstream_last_removed_segno</name><parameter_list>(<parameter><decl><type><name>polar_datamax_ctl_t</name> <modifier>*</modifier></type><name>ctl</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>XLogRecPtr</name></type> <name>upstream_last_removed_segno</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>ctl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ctl</name><operator>-&gt;</operator><name>meta_lock</name></name></expr></argument>, <argument><expr><name>LW_SHARED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>upstream_last_removed_segno</name> <operator>=</operator> <name><name>ctl</name><operator>-&gt;</operator><name>meta</name><operator>.</operator><name>upstream_last_removed_segno</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ctl</name><operator>-&gt;</operator><name>meta_lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>upstream_last_removed_segno</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * POLAR: handle timeline switch.
 *
 * If replication is done because of end-of-timeline, we will fetch all timeline history
 * from primary. So we can read timeline history to locate which timeline we belong now.
 * If timeline switch, update meta timeline which will be used while next try to request
 * stream replication.
 */</comment>
<function><type><name>void</name></type>
<name>polar_datamax_handle_timeline_switch</name><parameter_list>(<parameter><decl><type><name>polar_datamax_ctl_t</name> <modifier>*</modifier></type><name>ctl</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>XLogRecPtr</name></type>  <name>cur_lsn</name> <init>= <expr><name>InvalidXLogRecPtr</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TimeLineID</name></type>  <name>cur_tli</name> <init>= <expr><name>POLAR_INVALID_TIMELINE_ID</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TimeLineID</name></type>  <name>latest_tli</name> <init>= <expr><name>POLAR_INVALID_TIMELINE_ID</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TimeLineID</name></type>  <name>next_tli</name> <init>= <expr><name>POLAR_INVALID_TIMELINE_ID</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>        <modifier>*</modifier></type><name>expectedTLEs</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>cur_lsn</name> <operator>=</operator> <call><name>polar_datamax_get_last_received_lsn</name><argument_list>(<argument><expr><name>ctl</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>cur_tli</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>polar_is_datamax_mode</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>latest_tli</name> <operator>=</operator> <call><name>findNewestTimeLine</name><argument_list>(<argument><expr><name>cur_tli</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>latest_tli</name> <operator>&gt;=</operator> <name>cur_tli</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"latest timeline is %d, current timeline is %d"</literal></expr></argument>, <argument><expr><name>latest_tli</name></expr></argument>, <argument><expr><name>cur_tli</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* POLAR: if current timeline is latest, no need to switch timeline */</comment>
	<if_stmt><if>if <condition>(<expr><name>latest_tli</name> <operator>==</operator> <name>cur_tli</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>expectedTLEs</name> <operator>=</operator> <call><name>readTimeLineHistory</name><argument_list>(<argument><expr><name>cur_tli</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>next_tli</name> <operator>=</operator> <call><name>tliOfPointInHistory</name><argument_list>(<argument><expr><name>cur_lsn</name></expr></argument>, <argument><expr><name>expectedTLEs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>next_tli</name> <operator>&gt;=</operator> <name>cur_tli</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* POLAR: if timeline switch happened, update timeline of meta */</comment>
	<if_stmt><if>if <condition>(<expr><name>next_tli</name> <operator>&gt;</operator> <name>cur_tli</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>polar_datamax_update_received_info</name><argument_list>(<argument><expr><name>ctl</name></expr></argument>, <argument><expr><name>next_tli</name></expr></argument>, <argument><expr><name>InvalidXLogRecPtr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>polar_datamax_write_meta</name><argument_list>(<argument><expr><name>ctl</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"find new timeline to switch, switch from timeline %d to timeline %d at lsn %lX"</literal></expr></argument>,
			 <argument><expr><name>cur_tli</name></expr></argument>, <argument><expr><name>next_tli</name></expr></argument>, <argument><expr><name>cur_lsn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * POLAR: try to remove old wal.
 *
 * lsn is not involved in removed segment.
 */</comment>
<function><type><name>void</name></type>
<name>polar_datamax_remove_old_wal</name><parameter_list>(<parameter><decl><type><name>XLogRecPtr</name></type> <name>reserved_lsn</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>force</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>DIR</name>         <modifier>*</modifier></type><name>xldir</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>dirent</name></name>   <modifier>*</modifier></type><name>xlde</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>        <name><name>path</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>        <name><name>last_seg</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>XLogRecPtr</name></type>  <name>min_lsn</name> <init>= <expr><name>InvalidXLogRecPtr</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>XLogSegNo</name></type>   <name>segno</name></decl>, <decl><type ref="prev"/><name>upstream_last_removed_segno</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TimeLineID</name></type>  <name>min_reserved_tli</name> <init>= <expr><name>POLAR_INVALID_TIMELINE_ID</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>XLogRecPtr</name></type>  <name>min_reserved_lsn</name> <init>= <expr><name>InvalidXLogRecPtr</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>polar_is_datamax</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/* parameter check */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>XLogRecPtrIsInvalid</name><argument_list>(<argument><expr><name>reserved_lsn</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/* calculate slot min lsn first */</comment>
	<expr_stmt><expr><call><name>ReplicationSlotsComputeRequiredLSN</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>min_lsn</name> <operator>=</operator> <call><name>XLogGetReplicationSlotMinimumLSN</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* use smaller one between reserved_lsn and slot min restart_lsn */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>XLogRecPtrIsInvalid</name><argument_list>(<argument><expr><name>min_lsn</name></expr></argument>)</argument_list></call> <operator>||</operator> <name>reserved_lsn</name> <operator>&lt;</operator> <name>min_lsn</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>min_lsn</name> <operator>=</operator> <name>reserved_lsn</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* calculate last removed segment number */</comment>
	<expr_stmt><expr><call><name>XLByteToSeg</name><argument_list>(<argument><expr><name>min_lsn</name></expr></argument>, <argument><expr><name>segno</name></expr></argument>, <argument><expr><name>wal_segment_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>segno</name><operator>--</operator></expr>;</expr_stmt>

	<comment type="block">/* calcute DMA purge lsn */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>polar_is_dma_logger_node</name><argument_list>()</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>XLogRecPtr</name></type> <name>consensus_keep</name>  <init>= <expr><call><name>ConsensusGetPurgeLSN</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><name>consensus_keep</name> <operator>!=</operator> <name>InvalidXLogRecPtr</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>XLogSegNo</name></type>	<name>slotSegNo</name></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>XLByteToSeg</name><argument_list>(<argument><expr><name>consensus_keep</name></expr></argument>, <argument><expr><name>slotSegNo</name></expr></argument>, <argument><expr><name>wal_segment_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name>slotSegNo</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>segno</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if>
			<if type="elseif">else if <condition>(<expr><name>slotSegNo</name> <operator>&lt;</operator> <name>segno</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>segno</name> <operator>=</operator> <name>slotSegNo</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"purged consensus all matched's segno: %lu"</literal></expr></argument>, <argument><expr><name>segno</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><name>segno</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* get last removed segno of upstream */</comment>
	<expr_stmt><expr><name>upstream_last_removed_segno</name> <operator>=</operator> <call><name>polar_datamax_get_upstream_last_removed_segno</name><argument_list>(<argument><expr><name>polar_datamax_ctl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* keep wal which haven't been removed in upstream node */</comment>
	<if_stmt><if>if <condition>(<expr><name>segno</name> <operator>&gt;</operator> <name>upstream_last_removed_segno</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>segno</name> <operator>=</operator> <name>upstream_last_removed_segno</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>polar_make_file_path_level2</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>POLAR_DATAMAX_WAL_DIR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>XLogFileName</name><argument_list>(<argument><expr><name>last_seg</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>segno</name></expr></argument>, <argument><expr><name>wal_segment_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"datamax attempting to remove WAL segment file older than log file %s"</literal></expr></argument>,
		 <argument><expr><name>last_seg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>xldir</name> <operator>=</operator> <call><name>polar_allocate_dir</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<while>while <condition>(<expr><operator>(</operator><name>xlde</name> <operator>=</operator> <call><name>ReadDir</name><argument_list>(<argument><expr><name>xldir</name></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>bool</name></type> <name>removed</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsXLogFileName</name><argument_list>(<argument><expr><name><name>xlde</name><operator>-&gt;</operator><name>d_name</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
				<operator>!</operator><call><name>IsPartialXLogFileName</name><argument_list>(<argument><expr><name><name>xlde</name><operator>-&gt;</operator><name>d_name</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * only compare segment name without timeline info, detail reason
		 * is described at RemoveOldXlogFiles.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>xlde</name><operator>-&gt;</operator><name>d_name</name></name> <operator>+</operator> <literal type="number">8</literal></expr></argument>, <argument><expr><name>last_seg</name> <operator>+</operator> <literal type="number">8</literal></expr></argument>)</argument_list></call> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* if force is true or WAL segment has been archived, we will remove it. */</comment>
			<if_stmt><if>if <condition>(<expr><name>force</name> <operator>||</operator> <call><name>XLogArchiveCheckDone</name><argument_list>(<argument><expr><name><name>xlde</name><operator>-&gt;</operator><name>d_name</name></name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><call><name>polar_datamax_remove_wal_file</name><argument_list>(<argument><expr><name><name>xlde</name><operator>-&gt;</operator><name>d_name</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>removed</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>removed</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>uint32</name></type>      <name>tmp_tli</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>XLogSegNo</name></type>   <name>tmp_segno</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>XLogRecPtr</name></type>  <name>tmp_seg_lsn</name></decl>;</decl_stmt>

			<comment type="block">/* try to find min received info */</comment>
			<expr_stmt><expr><call><name>XLogFromFileName</name><argument_list>(<argument><expr><name><name>xlde</name><operator>-&gt;</operator><name>d_name</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tmp_tli</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tmp_segno</name></expr></argument>, <argument><expr><name>wal_segment_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>XLogSegNoOffsetToRecPtr</name><argument_list>(<argument><expr><name>tmp_segno</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>wal_segment_size</name></expr></argument>, <argument><expr><name>tmp_seg_lsn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>XLogRecPtrIsInvalid</name><argument_list>(<argument><expr><name>min_reserved_lsn</name></expr></argument>)</argument_list></call> <operator>||</operator> <name>min_reserved_lsn</name> <operator>&gt;</operator> <name>tmp_seg_lsn</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>min_reserved_tli</name> <operator>=</operator> <name>tmp_tli</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>min_reserved_lsn</name> <operator>=</operator> <name>tmp_seg_lsn</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></while>

	<expr_stmt><expr><call><name>FreeDir</name><argument_list>(<argument><expr><name>xldir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>XLogRecPtrIsInvalid</name><argument_list>(<argument><expr><name>min_reserved_lsn</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
		   <name>min_reserved_tli</name> <operator>!=</operator> <name>POLAR_INVALID_TIMELINE_ID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* update min received info according to actual WAL file */</comment>
	<expr_stmt><expr><call><name>polar_datamax_update_min_received_info</name><argument_list>(<argument><expr><name>polar_datamax_ctl</name></expr></argument>, <argument><expr><name>min_reserved_tli</name></expr></argument>, <argument><expr><name>min_reserved_lsn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>polar_datamax_write_meta</name><argument_list>(<argument><expr><name>polar_datamax_ctl</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"remove useless WAL segment done, min_reserved_tli %d, min_received_lsn %lX"</literal></expr></argument>,
		 <argument><expr><name>min_reserved_tli</name></expr></argument>, <argument><expr><name>min_reserved_lsn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * POLAR: Remove one WAL segment file.
 *
 * We will also remove status file related with current segment.
 */</comment>
<function><type><name>int</name></type>
<name>polar_datamax_remove_wal_file</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>seg_name</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>     <name>rc</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>    <name><name>seg_path</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>polar_update_last_removed_ptr</name><argument_list>(<argument><expr><name>seg_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>polar_make_file_path_level3</name><argument_list>(<argument><expr><name>seg_path</name></expr></argument>, <argument><expr><name>POLAR_DATAMAX_WAL_DIR</name></expr></argument>, <argument><expr><name>seg_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"removing WAL segment file %s"</literal></expr></argument>, <argument><expr><name>seg_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>durable_unlink</name><argument_list>(<argument><expr><name>seg_path</name></expr></argument>, <argument><expr><name>LOG</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>rc</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* detail log was printed in durable_unlink */</comment>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>, <argument><expr><literal type="string">"remove WAL segment file failed."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>rc</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* remove status files */</comment>
	<expr_stmt><expr><call><name>XLogArchiveCleanup</name><argument_list>(<argument><expr><name>seg_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * POLAR: handle WAL clean task
 */</comment>
<function><type><name>void</name></type>
<name>polar_datamax_handle_clean_task</name><parameter_list>(<parameter><decl><type><name>polar_datamax_ctl_t</name> <modifier>*</modifier></type><name>ctl</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>polar_datamax_clean_task_t</name></type> <name>task</name> <init>= <expr><block>{<expr><name>InvalidXLogRecPtr</name></expr>, <expr><name>false</name></expr>}</block></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>ctl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SpinLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ctl</name><operator>-&gt;</operator><name>lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>POLAR_DATAMAX_IS_VALID_CLEAN_TASK</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ctl</name><operator>-&gt;</operator><name>clean_task</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>task</name> <operator>=</operator> <name><name>ctl</name><operator>-&gt;</operator><name>clean_task</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>SpinLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ctl</name><operator>-&gt;</operator><name>lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* no valid clean task, do nothing */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>POLAR_DATAMAX_IS_VALID_CLEAN_TASK</name><argument_list>(<argument><expr><operator>&amp;</operator><name>task</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/* do clean task */</comment>
	<expr_stmt><expr><call><name>polar_datamax_remove_old_wal</name><argument_list>(<argument><expr><name><name>task</name><operator>.</operator><name>reserved_lsn</name></name></expr></argument>, <argument><expr><name><name>task</name><operator>.</operator><name>force</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* reset clean task */</comment>
	<expr_stmt><expr><call><name>polar_datamax_reset_clean_task</name><argument_list>(<argument><expr><name>ctl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * POLAR: Set WAL clean task. Exposed to user as SQL interface.
 */</comment>
<function><type><name>bool</name></type>
<name>polar_datamax_set_clean_task</name><parameter_list>(<parameter><decl><type><name>XLogRecPtr</name></type> <name>reserved_lsn</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>force</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>polar_datamax_ctl_t</name> <modifier>*</modifier></type><name>ctl</name> <init>= <expr><name>polar_datamax_ctl</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>ctl</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>SpinLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ctl</name><operator>-&gt;</operator><name>lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>POLAR_DATAMAX_IS_VALID_CLEAN_TASK</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ctl</name><operator>-&gt;</operator><name>clean_task</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>SpinLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ctl</name><operator>-&gt;</operator><name>lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"there is datamax clean task ongoing."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name><name>ctl</name><operator>-&gt;</operator><name>clean_task</name><operator>.</operator><name>reserved_lsn</name></name> <operator>=</operator> <name>reserved_lsn</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ctl</name><operator>-&gt;</operator><name>clean_task</name><operator>.</operator><name>force</name></name> <operator>=</operator> <name>force</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>SpinLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ctl</name><operator>-&gt;</operator><name>lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * POLAR: reset clean task
 */</comment>
<function><type><name>void</name></type>
<name>polar_datamax_reset_clean_task</name><parameter_list>(<parameter><decl><type><name>polar_datamax_ctl_t</name> <modifier>*</modifier></type><name>ctl</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>ctl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SpinLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ctl</name><operator>-&gt;</operator><name>lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ctl</name><operator>-&gt;</operator><name>clean_task</name><operator>.</operator><name>reserved_lsn</name></name> <operator>=</operator> <name>InvalidXLogRecPtr</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ctl</name><operator>-&gt;</operator><name>clean_task</name><operator>.</operator><name>force</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SpinLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ctl</name><operator>-&gt;</operator><name>lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * POLAR: archive wal file, need archive_mode == always
 */</comment>
<function><type><name>void</name></type>
<name>polar_datamax_archive</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>static</specifier> <name>TimestampTz</name></type> <name>last_archive_time</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>unlikely</name><argument_list>(<argument><expr><name>last_archive_time</name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>last_archive_time</name> <operator>=</operator> <call><name>GetCurrentTimestamp</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>XLogArchivingAlways</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <call><name>polar_is_datamax</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <name>polar_datamax_archive_timeout</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>TimestampTz</name></type> <name>archive_now</name> <init>= <expr><call><name>GetCurrentTimestamp</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>TimestampDifferenceExceeds</name><argument_list>(<argument><expr><name>last_archive_time</name></expr></argument>, <argument><expr><name>archive_now</name></expr></argument>, <argument><expr><name>polar_datamax_archive_timeout</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>polar_datamax_ArchiverCopyLoop</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>last_archive_time</name> <operator>=</operator> <name>archive_now</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * POLAR: remove wal files whose archive status are .done
 * if archive_mode = off or archive_mode = on, the .done file will be created forcibly in walreceiver.c
 * if archive_mode &gt; on, the .done file will be created only when corresponding walfile has been archived
 * so there is no need to judge archive_mode value in this func
 */</comment>
<function><type><name>void</name></type>
<name>polar_datamax_remove_archivedone_wal</name><parameter_list>(<parameter><decl><type><name>polar_datamax_ctl_t</name> <modifier>*</modifier></type><name>ctl</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>static</specifier> <name>TimestampTz</name></type> <name>last_remove_archivedone_wal_time</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>unlikely</name><argument_list>(<argument><expr><name>last_remove_archivedone_wal_time</name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>last_remove_archivedone_wal_time</name> <operator>=</operator> <call><name>GetCurrentTimestamp</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* only remove when timeout is set valid and in datamax mode */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>polar_is_datamax</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <name>polar_datamax_remove_archivedone_wal_timeout</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>TimestampTz</name></type> <name>now</name> <init>= <expr><call><name>GetCurrentTimestamp</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>TimestampDifferenceExceeds</name><argument_list>(<argument><expr><name>last_remove_archivedone_wal_time</name></expr></argument>, <argument><expr><name>now</name></expr></argument>, <argument><expr><name>polar_datamax_remove_archivedone_wal_timeout</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>polar_datamax_handle_remove_archivedone_wal</name><argument_list>(<argument><expr><name>ctl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>last_remove_archivedone_wal_time</name> <operator>=</operator> <name>now</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * POLAR: handle remove wal files whose archive status are .done
 * besides, don't remove wal files those haven't been removed in upstream instance
 * in case we lose walfile which is needed by downstream after re-create datamax node
 * which will be judged in func polar_datamax_remove_old_wal
 */</comment>
<function><type><name>void</name></type>
<name>polar_datamax_handle_remove_archivedone_wal</name><parameter_list>(<parameter><decl><type><name>polar_datamax_ctl_t</name> <modifier>*</modifier></type><name>ctl</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>XLogRecPtr</name></type>  <name>last_rec_lsn</name> <init>= <expr><name>InvalidXLogRecPtr</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>XLogRecPtr</name></type>  <name>reserved_lsn</name> <init>= <expr><name>InvalidXLogRecPtr</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>XLogSegNo</name></type>   <name>segno</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>polar_is_datamax</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/* get last received lsn */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>polar_is_dma_logger_node</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>last_rec_lsn</name> <operator>=</operator> <call><name>polar_dma_get_received_lsn</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>last_rec_lsn</name> <operator>=</operator> <call><name>polar_datamax_get_last_received_lsn</name><argument_list>(<argument><expr><name>ctl</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/* return when received no wal */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>XLogRecPtrIsInvalid</name><argument_list>(<argument><expr><name>last_rec_lsn</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>XLByteToSeg</name><argument_list>(<argument><expr><name>last_rec_lsn</name></expr></argument>, <argument><expr><name>segno</name></expr></argument>, <argument><expr><name>wal_segment_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* compute limit for wal_keep_segments */</comment>
	<if_stmt><if>if <condition>(<expr><name>wal_keep_segments</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>segno</name> <operator>&lt;=</operator> <name>wal_keep_segments</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>segno</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>segno</name> <operator>=</operator> <name>segno</name> <operator>-</operator> <name>wal_keep_segments</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>XLogSegNoOffsetToRecPtr</name><argument_list>(<argument><expr><name>segno</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>wal_segment_size</name></expr></argument>, <argument><expr><name>reserved_lsn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>polar_datamax_remove_old_wal</name><argument_list>(<argument><expr><name>reserved_lsn</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * POLAR: Check DataMax directory, if directory is missing, we will create it.
 */</comment>
<function><type><name>void</name></type>
<name>polar_datamax_validate_dir</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name></type>    <name><name>path</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>     <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name><name>dirs</name><index>[]</index></name> <init>=
	<expr><block>{
		<expr><name>POLAR_DATAMAX_DIR</name></expr>,
		<expr><name>POLAR_DATAMAX_WAL_DIR</name></expr>,
		<expr><name>POLAR_DATAMAX_WAL_DIR</name> <literal type="string">"/archive_status"</literal></expr>
	}</block></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>polar_local_node_type</name> <operator>!=</operator> <name>POLAR_STANDALONE_DATAMAX</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>, <argument><expr><literal type="string">"Only validate datamax dir when in DataMax mode."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <call><name>lengthof</name><argument_list>(<argument><expr><name>dirs</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><call><name>polar_make_file_path_level2</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name><name>dirs</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* check and create dir */</comment>
		<expr_stmt><expr><call><name>polar_datamax_check_mkdir</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>FATAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>
</block_content>}</block></function>

<comment type="block">/*
 * POLAR: Utility to check dir existence, if not create one.
 *
 * parameter path should be an absolute path.
 */</comment>
<function><type><name>void</name></type>
<name>polar_datamax_check_mkdir</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>path</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>emode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name><name>struct</name> <name>stat</name></name></type> <name>stat_buf</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>polar_stat</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>stat_buf</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>S_ISDIR</name><argument_list>(<argument><expr><name><name>stat_buf</name><operator>.</operator><name>st_mode</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>emode</name></expr></argument>, <argument><expr><literal type="string">"path \"%s\" is not a directory"</literal></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"create missing directory \"%s\""</literal></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>polar_make_pg_directory</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>emode</name></expr></argument>, <argument><expr><literal type="string">"could not create directory \"%s\""</literal></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * POLAR: Return start pos of next WAL segment file after restart_lsn of slot.
 *
 * It is used while establishing initial replication from Datamax. Primary will
 * send WAL data as much as possible, and to avoid hole of WAL file in DataMax,
 * replication should begin at a start posistion of WAL file. That is why we
 * need this func.
 */</comment>
<function><type><name>XLogRecPtr</name></type>
<name>polar_datamax_replication_start_lsn</name><parameter_list>(<parameter><decl><type><name>ReplicationSlot</name> <modifier>*</modifier></type><name>slot</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>XLogRecPtr</name></type> <name>restart_lsn</name> <init>= <expr><name>InvalidXLogRecPtr</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SpinLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>slot</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>restart_lsn</name> <operator>=</operator> <name><name>slot</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>restart_lsn</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SpinLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>slot</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>XLogRecPtrIsInvalid</name><argument_list>(<argument><expr><name>restart_lsn</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>restart_lsn</name> <operator>-</operator> <call><name>XLogSegmentOffset</name><argument_list>(<argument><expr><name>restart_lsn</name></expr></argument>, <argument><expr><name>wal_segment_size</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * POLAR: iterate the waldir to get the lsn of smallest walfile
 * called when XLogGetLastRemovedSegno is 0
 */</comment>
<function><type><name>XLogRecPtr</name></type>
<name>polar_get_smallest_walfile_lsn</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>XLogRecPtr</name></type>	<name>smallest_lsn</name></decl>, <decl><type ref="prev"/><name>tmp_smallest_lsn</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>XLogSegNo</name></type> 	<name>segno</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type> 		<name><name>xlog_file</name><index>[<expr><name>MAXFNAMELEN</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>polar_waldir_path</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>DIR</name>			<modifier>*</modifier></type><name>polar_waldir</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>dirent</name></name> <modifier>*</modifier></type><name>polar_waldirent</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32</name></type>		<name>tli</name></decl>;</decl_stmt>

	<comment type="block">/* get the possibly smallest lsn */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>polar_is_datamax</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>smallest_lsn</name> <operator>=</operator> <call><name>GetRedoRecPtr</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>smallest_lsn</name> <operator>=</operator> <call><name>polar_datamax_get_min_received_lsn</name><argument_list>(<argument><expr><name>polar_datamax_ctl</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	
	<comment type="block">/* iterate the wal dir to get the smallest lsn */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>polar_is_datamax</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>polar_make_file_path_level2</name><argument_list>(<argument><expr><name>polar_waldir_path</name></expr></argument>, <argument><expr><name>XLOGDIR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>polar_make_file_path_level2</name><argument_list>(<argument><expr><name>polar_waldir_path</name></expr></argument>, <argument><expr><name>POLAR_DATAMAX_WAL_DIR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	
	<expr_stmt><expr><name>polar_waldir</name> <operator>=</operator> <call><name>polar_allocate_dir</name><argument_list>(<argument><expr><name>polar_waldir_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>XLByteToSeg</name><argument_list>(<argument><expr><name>smallest_lsn</name></expr></argument>, <argument><expr><name>segno</name></expr></argument>, <argument><expr><name>wal_segment_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>	
	<expr_stmt><expr><call><name>XLogFileName</name><argument_list>(<argument><expr><name>xlog_file</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>segno</name></expr></argument>, <argument><expr><name>wal_segment_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<while>while <condition>(<expr><operator>(</operator><name>polar_waldirent</name> <operator>=</operator> <call><name>ReadDir</name><argument_list>(<argument><expr><name>polar_waldir</name></expr></argument>, <argument><expr><name>polar_waldir_path</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsXLogFileName</name><argument_list>(<argument><expr><name><name>polar_waldirent</name><operator>-&gt;</operator><name>d_name</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
			<operator>!</operator><call><name>IsPartialXLogFileName</name><argument_list>(<argument><expr><name><name>polar_waldirent</name><operator>-&gt;</operator><name>d_name</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>polar_waldirent</name><operator>-&gt;</operator><name>d_name</name></name> <operator>+</operator> <literal type="number">8</literal></expr></argument>, <argument><expr><name>xlog_file</name> <operator>+</operator> <literal type="number">8</literal></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* found wal file smaller than xlog_file */</comment>
			<expr_stmt><expr><call><name>XLogFromFileName</name><argument_list>(<argument><expr><name><name>polar_waldirent</name><operator>-&gt;</operator><name>d_name</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tli</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>segno</name></expr></argument>, <argument><expr><name>wal_segment_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>XLogSegNoOffsetToRecPtr</name><argument_list>(<argument><expr><name>segno</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>wal_segment_size</name></expr></argument>, <argument><expr><name>tmp_smallest_lsn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* update restart_lsn when current wal file hasn't been removed */</comment>
			<if_stmt><if>if <condition>(<expr><name>tmp_smallest_lsn</name> <operator>&lt;</operator> <name>smallest_lsn</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>smallest_lsn</name> <operator>=</operator> <name>tmp_smallest_lsn</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></while>
	<expr_stmt><expr><call><name>FreeDir</name><argument_list>(<argument><expr><name>polar_waldir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>smallest_lsn</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * POLAR: save replication slots to pg_replslot
 * slots are saved by CreateCheckPoint/CreateRestartPoint when not in datamax mode
 * there is no checkpoint process in datamax mode
 * add this func to save replication slot in datamax mode
 */</comment>
<function><type><name>void</name></type>
<name>polar_datamax_save_replication_slots</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>static</specifier> <name>TimestampTz</name></type> <name>last_saveslots_time</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>unlikely</name><argument_list>(<argument><expr><name>last_saveslots_time</name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>last_saveslots_time</name> <operator>=</operator> <call><name>GetCurrentTimestamp</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>polar_is_datamax</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <name>polar_datamax_save_replication_slots_timeout</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>TimestampTz</name></type> <name>saveslots_now</name> <init>= <expr><call><name>GetCurrentTimestamp</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>TimestampDifferenceExceeds</name><argument_list>(<argument><expr><name>last_saveslots_time</name></expr></argument>, <argument><expr><name>saveslots_now</name></expr></argument>, <argument><expr><name>polar_datamax_save_replication_slots_timeout</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>CheckPointReplicationSlots</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>last_saveslots_time</name> <operator>=</operator> <name>saveslots_now</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * POLAR: WAL file path for datamax
 */</comment>
<function><type><name>void</name></type>
<name>polar_datamax_wal_file_path</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>path</name></decl></parameter>, <parameter><decl><type><name>TimeLineID</name></type> <name>tli</name></decl></parameter>, <parameter><decl><type><name>XLogSegNo</name></type> <name>logSegNo</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>wal_segsz_bytes</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><call><name>POLAR_FILE_IN_SHARED_STORAGE</name><argument_list>()</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>MAXPGPATH</name></expr></argument>, <argument><expr><literal type="string">"%s/"</literal> <name>POLAR_DATAMAX_WAL_DIR</name> <literal type="string">"/%08X%08X%08X"</literal></expr></argument>, <argument><expr><name>polar_datadir</name></expr></argument>, <argument><expr><name>tli</name></expr></argument>,
				 <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator><operator>(</operator><operator>(</operator><name>logSegNo</name><operator>)</operator> <operator>/</operator> <call><name>XLogSegmentsPerXLogId</name><argument_list>(<argument><expr><name>wal_segsz_bytes</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>,
				 <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator><operator>(</operator><operator>(</operator><name>logSegNo</name><operator>)</operator> <operator>%</operator> <call><name>XLogSegmentsPerXLogId</name><argument_list>(<argument><expr><name>wal_segsz_bytes</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>MAXPGPATH</name></expr></argument>, <argument><expr><name>POLAR_DATAMAX_WAL_DIR</name> <literal type="string">"/%08X%08X%08X"</literal></expr></argument>, <argument><expr><name>tli</name></expr></argument>,
				 <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator><operator>(</operator><operator>(</operator><name>logSegNo</name><operator>)</operator> <operator>/</operator> <call><name>XLogSegmentsPerXLogId</name><argument_list>(<argument><expr><name>wal_segsz_bytes</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>,
				 <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator><operator>(</operator><operator>(</operator><name>logSegNo</name><operator>)</operator> <operator>%</operator> <call><name>XLogSegmentsPerXLogId</name><argument_list>(<argument><expr><name>wal_segsz_bytes</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * POLAR: WAL status file path for DataMax
 */</comment>
<function><type><name>void</name></type>
<name>polar_datamax_status_file_path</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>path</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>xlog</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>suffix</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><call><name>POLAR_FILE_IN_SHARED_STORAGE</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>MAXPGPATH</name></expr></argument>, <argument><expr><literal type="string">"%s/"</literal> <name>POLAR_DATAMAX_WAL_DIR</name> <literal type="string">"/archive_status/%s%s"</literal></expr></argument>, <argument><expr><name>polar_datadir</name></expr></argument>, <argument><expr><name>xlog</name></expr></argument>, <argument><expr><name>suffix</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>MAXPGPATH</name></expr></argument>, <argument><expr><name>POLAR_DATAMAX_WAL_DIR</name> <literal type="string">"/archive_status/%s%s"</literal></expr></argument>, <argument><expr><name>xlog</name></expr></argument>, <argument><expr><name>suffix</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>polar_datamax_tl_history_file_path</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>path</name></decl></parameter>, <parameter><decl><type><name>TimeLineID</name></type> <name>tli</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><call><name>POLAR_FILE_IN_SHARED_STORAGE</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>MAXPGPATH</name></expr></argument>, <argument><expr><literal type="string">"%s/"</literal> <name>POLAR_DATAMAX_WAL_DIR</name> <literal type="string">"/%08X.history"</literal></expr></argument>, <argument><expr><name>polar_datadir</name></expr></argument>, <argument><expr><name>tli</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>MAXPGPATH</name></expr></argument>, <argument><expr><name>POLAR_DATAMAX_WAL_DIR</name> <literal type="string">"/%08X.history"</literal></expr></argument>, <argument><expr><name>tli</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * POLAR: prealloc wal file
 * this work is done by polar worker process when not in datamax mode
 * add this func so it's unnecessary to start polar worker process in datamax mode
 */</comment>
<function><type><name>void</name></type>
<name>polar_datamax_prealloc_wal_file</name><parameter_list>(<parameter><decl><type><name>polar_datamax_ctl_t</name> <modifier>*</modifier></type><name>ctl</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>static</specifier> <name>TimestampTz</name></type> <name>last_prealloc_walfile_time</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>unlikely</name><argument_list>(<argument><expr><name>last_prealloc_walfile_time</name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>last_prealloc_walfile_time</name> <operator>=</operator> <call><name>GetCurrentTimestamp</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>polar_is_datamax</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <call><name>WalRcvStreaming</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <name>polar_datamax_prealloc_walfile_timeout</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>TimestampTz</name></type> <name>prealloc_walfile_now</name> <init>= <expr><call><name>GetCurrentTimestamp</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>TimestampDifferenceExceeds</name><argument_list>(<argument><expr><name>last_prealloc_walfile_time</name></expr></argument>, <argument><expr><name>prealloc_walfile_now</name></expr></argument>, <argument><expr><name>polar_datamax_prealloc_walfile_timeout</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>polar_datamax_handle_prealloc_walfile</name><argument_list>(<argument><expr><name>ctl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>last_prealloc_walfile_time</name> <operator>=</operator> <name>prealloc_walfile_now</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * POLAR: handle prealloc wal file
 * need polar_is_datamax_mode = true when call this function alone,
 * which is used to find the correct pg_wal path in datamax mode
 */</comment>
<function><type><name>void</name></type>
<name>polar_datamax_handle_prealloc_walfile</name><parameter_list>(<parameter><decl><type><name>polar_datamax_ctl_t</name> <modifier>*</modifier></type><name>ctl</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>XLogRecPtr</name></type> <name>insert_ptr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>XLogSegNo</name></type>  <name>_log_seg_no</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>         <name>lf</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>        <name>use_existent</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>         <name>count</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>polar_is_dma_logger_node</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>insert_ptr</name> <operator>=</operator> <call><name>polar_dma_get_received_lsn</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>insert_ptr</name> <operator>=</operator> <call><name>polar_datamax_get_last_received_lsn</name><argument_list>(<argument><expr><name>ctl</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>XLogRecPtrIsInvalid</name><argument_list>(<argument><expr><name>insert_ptr</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>XLByteToPrevSeg</name><argument_list>(<argument><expr><name>insert_ptr</name></expr></argument>, <argument><expr><name>_log_seg_no</name></expr></argument>, <argument><expr><name>wal_segment_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<for>for <control>(<init><expr><name>count</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>count</name> <operator>&lt;</operator> <name>polar_datamax_prealloc_walfile_num</name></expr>;</condition> <incr><expr><name>count</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<expr_stmt><expr><name>use_existent</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>lf</name> <operator>=</operator> <call><name>XLogFileInit</name><argument_list>(<argument><expr><operator>++</operator><name>_log_seg_no</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>use_existent</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>polar_close</name><argument_list>(<argument><expr><name>lf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></for>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * POLAR: judge whether meta file exists
 * no meta file when it is an initial created datamax
 */</comment>
<function><type><name>bool</name></type>
<name>polar_datamax_meta_file_exist</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name></type>    <name><name>meta_path</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>stat</name></name></type> <name>stat_buf</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>meta_path</name></expr></argument>, <argument><expr><name>MAXPGPATH</name></expr></argument>, <argument><expr><literal type="string">"%s/%s/%s"</literal></expr></argument>, <argument><expr><name>POLAR_DATA_DIR</name></expr></argument>, <argument><expr><name>POLAR_DATAMAX_DIR</name></expr></argument>, <argument><expr><name>POLAR_DATAMAX_META_FILE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><operator>(</operator><call><name>polar_stat</name><argument_list>(<argument><expr><name>meta_path</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>stat_buf</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * POLAR: create and init polar_datamax_valid_lsn_list
 */</comment>
<function><type><name>polar_datamax_valid_lsn_list</name> <modifier>*</modifier></type>
<name>polar_datamax_create_valid_lsn_list</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>polar_datamax_valid_lsn_list</name> <modifier>*</modifier></type><name>list</name> <init>= <expr><call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>polar_datamax_valid_lsn_list</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>dlist_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>list</name><operator>-&gt;</operator><name>valid_lsn_lhead</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>list</name><operator>-&gt;</operator><name>list_length</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<return>return <expr><name>list</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * POLAR: append new received primary_last_valid_lsn to list
 */</comment>
<function><type><name>void</name></type>
<name>polar_datamax_insert_last_valid_lsn</name><parameter_list>(<parameter><decl><type><name>polar_datamax_valid_lsn_list</name> <modifier>*</modifier></type><name>list</name></decl></parameter>, <parameter><decl><type><name>XLogRecPtr</name></type> <name>primary_last_valid_lsn</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>POLAR_VALIDLSN_LIST_MAX_LENGTH</name></cpp:macro> <cpp:value>200</cpp:value></cpp:define>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* don't insert new node when reach the max length */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>list</name><operator>-&gt;</operator><name>list_length</name></name> <operator>==</operator> <name>POLAR_VALIDLSN_LIST_MAX_LENGTH</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if>
	<else>else
	<block>{<block_content>
		<decl_stmt><decl><type><name>polar_datamax_valid_lsn</name> <modifier>*</modifier></type><name>tail_valid_lsn</name></decl>;</decl_stmt>
		<expr_stmt><expr><name>tail_valid_lsn</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name><name>list</name><operator>-&gt;</operator><name>list_length</name></name> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr> ?</condition><then> <expr><name>NULL</name></expr> </then><else>: <expr><call><name>dlist_container</name><argument_list>(<argument><expr><name>polar_datamax_valid_lsn</name></expr></argument>, <argument><expr><name>valid_lsn_lnode</name></expr></argument>, <argument><expr><call><name>dlist_tail_node</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>list</name><operator>-&gt;</operator><name>valid_lsn_lhead</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></else></ternary></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>tail_valid_lsn</name> <operator>&amp;&amp;</operator> <name><name>tail_valid_lsn</name><operator>-&gt;</operator><name>primary_valid_lsn</name></name> <operator>&gt;</operator> <name>primary_last_valid_lsn</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>, <argument><expr><literal type="string">"invalid lsn when insert new node to datamax_valid_lsn_list"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<comment type="block">/* insert when list is empty or lsn is not duplicated */</comment>
		<if type="elseif">else if <condition>(<expr><name>tail_valid_lsn</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name><name>tail_valid_lsn</name><operator>-&gt;</operator><name>primary_valid_lsn</name></name> <operator>!=</operator> <name>primary_last_valid_lsn</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>polar_datamax_valid_lsn</name> <modifier>*</modifier></type><name>new_valid_lsn</name> <init>= <expr><call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>polar_datamax_valid_lsn</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><name><name>new_valid_lsn</name><operator>-&gt;</operator><name>primary_valid_lsn</name></name> <operator>=</operator> <name>primary_last_valid_lsn</name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>dlist_push_tail</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>list</name><operator>-&gt;</operator><name>valid_lsn_lhead</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>new_valid_lsn</name><operator>-&gt;</operator><name>valid_lsn_lnode</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>list</name><operator>-&gt;</operator><name>list_length</name></name><operator>++</operator></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * POLAR: update current last_valid_lsn when datamax received new wal
 * remove old valid lsn from list at the same time
 */</comment>
<function><type><name>void</name></type>
<name>polar_datamax_update_cur_valid_lsn</name><parameter_list>(<parameter><decl><type><name>polar_datamax_valid_lsn_list</name> <modifier>*</modifier></type><name>list</name></decl></parameter>, <parameter><decl><type><name>XLogRecPtr</name></type> <name>flush_lsn</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>XLogRecPtr</name></type> <name>cur_valid_lsn</name> <init>= <expr><name>InvalidXLogRecPtr</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>polar_datamax_valid_lsn</name> <modifier>*</modifier></type><name>valid_lsn</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>dlist_mutable_iter</name></type> <name>diter</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>list</name><operator>-&gt;</operator><name>list_length</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/* get current valid lsn, the list is sorted */</comment>
	<macro><name>dlist_foreach_modify</name><argument_list>(<argument>diter</argument>, <argument>&amp;list-&gt;valid_lsn_lhead</argument>)</argument_list></macro>
	<block>{<block_content>
		<expr_stmt><expr><name>valid_lsn</name> <operator>=</operator> <call><name>dlist_container</name><argument_list>(<argument><expr><name>polar_datamax_valid_lsn</name></expr></argument>, <argument><expr><name>valid_lsn_lnode</name></expr></argument>, <argument><expr><name><name>diter</name><operator>.</operator><name>cur</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>valid_lsn</name><operator>-&gt;</operator><name>primary_valid_lsn</name></name> <operator>&lt;=</operator> <name>flush_lsn</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>cur_valid_lsn</name> <operator>=</operator> <name><name>valid_lsn</name><operator>-&gt;</operator><name>primary_valid_lsn</name></name></expr>;</expr_stmt>
			<comment type="block">/* remove list node whose lsn is smaller than flush lsn */</comment>
			<expr_stmt><expr><call><name>dlist_delete</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>valid_lsn</name><operator>-&gt;</operator><name>valid_lsn_lnode</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>valid_lsn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>list</name><operator>-&gt;</operator><name>list_length</name></name><operator>--</operator></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else<block type="pseudo"><block_content>
			<break>break;</break></block_content></block></else></if_stmt>
	</block_content>}</block>

	<comment type="block">/* update current valid lsn to meta, cur_valid_lsn is invalid when flush_lsn is smaller than head_lsn */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>XLogRecPtrIsInvalid</name><argument_list>(<argument><expr><name>cur_valid_lsn</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>polar_datamax_update_last_valid_received_lsn</name><argument_list>(<argument><expr><name>polar_datamax_ctl</name></expr></argument>, <argument><expr><name>cur_valid_lsn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * POLAR: free memory of polar_datamax_received_valid_lsn_list
 * used as a before_shmem_exit handler
 */</comment>
<function><type><name>void</name></type>
<name>polar_datamax_free_valid_lsn_list</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>code</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>dlist_mutable_iter</name></type> <name>diter</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>polar_datamax_valid_lsn</name> <modifier>*</modifier></type><name>cur_valid_lsn</name></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>polar_datamax_valid_lsn_list</name> <modifier>*</modifier></type><name>list</name> <init>= <expr><operator>(</operator><name>polar_datamax_valid_lsn_list</name> <operator>*</operator><operator>)</operator> <call><name>DatumGetPointer</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>list</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if>
	<else>else
	<block>{<block_content>
		<macro><name>dlist_foreach_modify</name><argument_list>(<argument>diter</argument>, <argument>&amp;list-&gt;valid_lsn_lhead</argument>)</argument_list></macro>
		<block>{<block_content>
			<expr_stmt><expr><name>cur_valid_lsn</name> <operator>=</operator> <call><name>dlist_container</name><argument_list>(<argument><expr><name>polar_datamax_valid_lsn</name></expr></argument>, <argument><expr><name>valid_lsn_lnode</name></expr></argument>, <argument><expr><name><name>diter</name><operator>.</operator><name>cur</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>dlist_delete</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>cur_valid_lsn</name><operator>-&gt;</operator><name>valid_lsn_lnode</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>cur_valid_lsn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>list</name><operator>-&gt;</operator><name>list_length</name></name><operator>--</operator></expr>;</expr_stmt>
		</block_content>}</block>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/* check whether list-&gt;length is the same as the actual num of list members */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>list</name><operator>-&gt;</operator><name>list_length</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>, <argument><expr><literal type="string">"invalid datamax_valid_lsn_list, list-&gt;length is not the same as the actual num of list members\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * POLAR: read count bytes from a segment file, store the data in the passed buffer
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>polar_datamax_xlog_read</name><parameter_list>(<parameter><decl><type><name>TimeLineID</name></type> <name>tli</name></decl></parameter>, <parameter><decl><type><name>XLogRecPtr</name></type> <name>start_ptr</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><name>Size</name></type> <name>count</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>XLogRecPtr</name></type>  <name>recptr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Size</name></type>        <name>nbytes</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type> <name><name>path</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name></decl>;</decl_stmt>

	<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type>  <name>read_file</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>static</specifier> <name>XLogSegNo</name></type> <name>read_segNo</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>static</specifier> <name>uint32</name></type> <name>read_off</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>p</name> <operator>=</operator> <name>buf</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>recptr</name> <operator>=</operator> <name>start_ptr</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>nbytes</name> <operator>=</operator> <name>count</name></expr>;</expr_stmt>

	<while>while <condition>(<expr><name>nbytes</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>uint32</name></type>      <name>start_off</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>         <name>seg_bytes</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>         <name>read_bytes</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>start_off</name> <operator>=</operator> <call><name>XLogSegmentOffset</name><argument_list>(<argument><expr><name>recptr</name></expr></argument>, <argument><expr><name>wal_segment_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>read_file</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator> <operator>!</operator><call><name>XLByteInSeg</name><argument_list>(<argument><expr><name>recptr</name></expr></argument>, <argument><expr><name>read_segNo</name></expr></argument>, <argument><expr><name>wal_segment_size</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* switch to a new segment */</comment>
			<if_stmt><if>if <condition>(<expr><name>read_file</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>polar_close</name><argument_list>(<argument><expr><name>read_file</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<expr_stmt><expr><call><name>XLByteToSeg</name><argument_list>(<argument><expr><name>recptr</name></expr></argument>, <argument><expr><name>read_segNo</name></expr></argument>, <argument><expr><name>wal_segment_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* get the wal segment file path */</comment>
			<expr_stmt><expr><call><name>polar_datamax_wal_file_path</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>tli</name></expr></argument>, <argument><expr><name>read_segNo</name></expr></argument>, <argument><expr><name>wal_segment_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><operator>(</operator><name>read_file</name> <operator>=</operator> <call><name>polar_open</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>O_RDONLY</name> <operator>|</operator> <name>PG_BINARY</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* report error */</comment>
				<expr_stmt><expr><name>polar_datamax_io_errcause</name> <operator>=</operator> <name>POLAR_DATAMAX_OPEN_FAILED</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>polar_datamax_io_errno</name> <operator>=</operator> <name>errno</name></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>polar_datamax_report_io_error</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>FATAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<expr_stmt><expr><name>read_off</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* need to seek in the file */</comment>
		<if_stmt><if>if <condition>(<expr><name>read_off</name> <operator>!=</operator> <name>start_off</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><call><name>polar_lseek</name><argument_list>(<argument><expr><name>read_file</name></expr></argument>, <argument><expr><operator>(</operator><name>off_t</name><operator>)</operator> <name>start_off</name></expr></argument>, <argument><expr><name>SEEK_SET</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>polar_datamax_wal_file_path</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>tli</name></expr></argument>, <argument><expr><name>read_segNo</name></expr></argument>, <argument><expr><name>wal_segment_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<comment type="block">/* report error */</comment>
				<expr_stmt><expr><name>polar_datamax_io_errcause</name> <operator>=</operator> <name>POLAR_DATAMAX_SEEK_FAILED</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>polar_datamax_io_errno</name> <operator>=</operator> <name>errno</name></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>polar_datamax_report_io_error</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>FATAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<expr_stmt><expr><name>read_off</name> <operator>=</operator> <name>start_off</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* how many bytes are within this segment */</comment>
		<if_stmt><if>if <condition>(<expr><name>nbytes</name> <operator>&gt;</operator> <operator>(</operator><name>wal_segment_size</name> <operator>-</operator> <name>start_off</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>seg_bytes</name> <operator>=</operator> <name>wal_segment_size</name> <operator>-</operator> <name>start_off</name></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>seg_bytes</name> <operator>=</operator> <name>nbytes</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<expr_stmt><expr><name>read_bytes</name> <operator>=</operator> <call><name>polar_read</name><argument_list>(<argument><expr><name>read_file</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>seg_bytes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>read_bytes</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>polar_datamax_wal_file_path</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>tli</name></expr></argument>, <argument><expr><name>read_segNo</name></expr></argument>, <argument><expr><name>wal_segment_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* report error */</comment>
			<expr_stmt><expr><name>polar_datamax_io_errcause</name> <operator>=</operator> <name>POLAR_DATAMAX_READ_FAILED</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>polar_datamax_io_errno</name> <operator>=</operator> <name>errno</name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>polar_datamax_report_io_error</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>FATAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* update state for read */</comment>
		<expr_stmt><expr><name>recptr</name> <operator>+=</operator> <name>read_bytes</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>read_off</name> <operator>+=</operator> <name>read_bytes</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>nbytes</name> <operator>-=</operator> <name>read_bytes</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>p</name> <operator>+=</operator> <name>read_bytes</name></expr>;</expr_stmt>
	</block_content>}</block></while>
</block_content>}</block></function>

<comment type="block">/*
 * POLAR: XLogReader read_page callback
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>polar_datamax_xlog_read_page</name><parameter_list>(<parameter><decl><type><name>XLogReaderState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>XLogRecPtr</name></type> <name>target_page_ptr</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>req_len</name></decl></parameter>,
							 <parameter><decl><type><name>XLogRecPtr</name></type> <name>target_ptr</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>read_buff</name></decl></parameter>, <parameter><decl><type><name>TimeLineID</name> <modifier>*</modifier></type><name>cur_file_tli</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>polar_datamax_xlog_parse_private</name> <modifier>*</modifier></type><name>private</name> <init>= <expr><name><name>state</name><operator>-&gt;</operator><name>private_data</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>count</name> <init>= <expr><name>XLOG_BLCKSZ</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>target_page_ptr</name> <operator>+</operator> <name>XLOG_BLCKSZ</name> <operator>&lt;=</operator> <name><name>private</name><operator>-&gt;</operator><name>end_ptr</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>count</name> <operator>=</operator> <name>XLOG_BLCKSZ</name></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><name>target_page_ptr</name> <operator>+</operator> <name>req_len</name> <operator>&lt;=</operator> <name><name>private</name><operator>-&gt;</operator><name>end_ptr</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>count</name> <operator>=</operator> <name><name>private</name><operator>-&gt;</operator><name>end_ptr</name></name> <operator>-</operator> <name>target_page_ptr</name></expr>;</expr_stmt></block_content></block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name><name>private</name><operator>-&gt;</operator><name>reach_end_ptr</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><call><name>polar_datamax_xlog_read</name><argument_list>(<argument><expr><name><name>private</name><operator>-&gt;</operator><name>timeline</name></name></expr></argument>, <argument><expr><name>target_page_ptr</name></expr></argument>, <argument><expr><name>read_buff</name></expr></argument>, <argument><expr><name>count</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>count</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * POLAR: parse xlog from last_valid_received_lsn in order to start xlog streaming from a valid lsn
 * so that we can prevent xlog inconsistency between primary and datamax
 * when the primary's last lsn is invalid, which will be covered when primary restart
 * but it won't be covered in datamax if we start xlog streaming from the last_received_lsn rather than last_valid_received_lsn
 */</comment>
<function><type><name>void</name></type>
<name>polar_datamax_parse_xlog</name><parameter_list>(<parameter><decl><type><name>polar_datamax_ctl_t</name> <modifier>*</modifier></type><name>ctl</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>XLogReaderState</name> <modifier>*</modifier></type><name>xlogreader</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>polar_datamax_xlog_parse_private</name></type> <name>private</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TimeLineID</name></type> <name>tli</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>XLogRecPtr</name></type> <name>last_valid_received_lsn</name></decl>;</decl_stmt> <comment type="block">/* start lsn of parsing */</comment>
	<decl_stmt><decl><type><name>XLogRecPtr</name></type> <name>last_received_lsn</name></decl>;</decl_stmt> <comment type="block">/* end lsn of parsing */</comment>
	<decl_stmt><decl><type><name>XLogRecPtr</name></type> <name>lsn_read_from</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>XLogRecord</name> <modifier>*</modifier></type><name>record</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>errormsg</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>       <name>new_valid</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>polar_datamax_get_last_received_info</name><argument_list>(<argument><expr><name>ctl</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tli</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>last_received_lsn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>last_valid_received_lsn</name> <operator>=</operator> <call><name>polar_datamax_get_last_valid_received_lsn</name><argument_list>(<argument><expr><name>ctl</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"last_received_lsn:%X/%X, last_valid_received_lsn:%X/%X"</literal></expr></argument>,
		 <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator><operator>(</operator><name>last_received_lsn</name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr></argument>, <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <name>last_received_lsn</name></expr></argument>,
		 <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator><operator>(</operator><name>last_valid_received_lsn</name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr></argument>, <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <name>last_valid_received_lsn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * nothing to do when last_valid_received_lsn or last_received_lsn is invalid
	 * which indicates it's an initial datamax node
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>XLogRecPtrIsInvalid</name><argument_list>(<argument><expr><name>last_received_lsn</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>XLogRecPtrIsInvalid</name><argument_list>(<argument><expr><name>last_valid_received_lsn</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>last_received_lsn</name> <operator>&gt;=</operator> <name>last_valid_received_lsn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* set up xlog reader */</comment>
	<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><operator>&amp;</operator><name>private</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>polar_datamax_xlog_parse_private</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>xlogreader</name> <operator>=</operator> <call><name>XLogReaderAllocate</name><argument_list>(<argument><expr><name>wal_segment_size</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>polar_datamax_xlog_read_page</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>private</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>xlogreader</name></expr>)</condition><block type="pseudo"><block_content>
		<comment type="block">/*no cover begin*/</comment>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_OUT_OF_MEMORY</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"out of memory"</literal></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Failed while allocating a WAL reading processor."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*no cover end*/</comment>

	<expr_stmt><expr><name><name>private</name><operator>.</operator><name>start_ptr</name></name> <operator>=</operator> <name>last_valid_received_lsn</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>private</name><operator>.</operator><name>end_ptr</name></name> <operator>=</operator> <name>last_received_lsn</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>private</name><operator>.</operator><name>timeline</name></name> <operator>=</operator> <name>tli</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>private</name><operator>.</operator><name>reach_end_ptr</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * find a valid recptr to start from
	 * because the last_valid_received_lsn is the end of the last valid lsn of primary
	 * if the position is at a page boundary, it points to the beginning of the page,(ie. before page header)
	 * not to where the first xlog record on that page would go to
	 */</comment>
	<expr_stmt><expr><name>lsn_read_from</name> <operator>=</operator> <call><name>XLogFindNextRecord</name><argument_list>(<argument><expr><name>xlogreader</name></expr></argument>, <argument><expr><name><name>private</name><operator>.</operator><name>start_ptr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>lsn_read_from</name> <operator>==</operator> <name>InvalidXLogRecPtr</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"could not find a valid record after %X/%X, which is the last valid lsn"</literal></expr></argument>,
			 <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator><operator>(</operator><name><name>private</name><operator>.</operator><name>start_ptr</name></name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr></argument>,
			 <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator><name><name>private</name><operator>.</operator><name>start_ptr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"parse xlog record from:%X/%X"</literal></expr></argument>, <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator><operator>(</operator><name>lsn_read_from</name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr></argument>, <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <name>lsn_read_from</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* parse xlog */</comment>
	<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
	<block>{<block_content>
		<expr_stmt><expr><name>record</name> <operator>=</operator> <call><name>XLogReadRecord</name><argument_list>(<argument><expr><name>xlogreader</name></expr></argument>, <argument><expr><name>lsn_read_from</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>errormsg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* record is reach the end of valid xlog record */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>record</name> <operator>||</operator> <name><name>private</name><operator>.</operator><name>reach_end_ptr</name></name></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>

		<comment type="block">/* new valid xlog record, update last_valid_received_lsn */</comment>
		<expr_stmt><expr><name>last_valid_received_lsn</name> <operator>=</operator> <name><name>xlogreader</name><operator>-&gt;</operator><name>EndRecPtr</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>new_valid</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<comment type="block">/* after reading the first record, continue at next one */</comment>
		<expr_stmt><expr><name>lsn_read_from</name> <operator>=</operator> <name>InvalidXLogRecPtr</name></expr>;</expr_stmt>
	</block_content>}</block></for>

	<if_stmt><if>if <condition>(<expr><name>errormsg</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"error in WAl record at %X/%X: %s"</literal></expr></argument>,
			 <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator><operator>(</operator><name><name>xlogreader</name><operator>-&gt;</operator><name>ReadRecPtr</name></name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr></argument>,
			 <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <name><name>xlogreader</name><operator>-&gt;</operator><name>ReadRecPtr</name></name></expr></argument>, <argument><expr><name>errormsg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	
	<expr_stmt><expr><call><name>XLogReaderFree</name><argument_list>(<argument><expr><name>xlogreader</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* update last_valid_received_lsn when there is new valid record */</comment>
	<if_stmt><if>if <condition>(<expr><name>new_valid</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>polar_datamax_update_last_valid_received_lsn</name><argument_list>(<argument><expr><name>ctl</name></expr></argument>, <argument><expr><name>last_valid_received_lsn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>polar_datamax_write_meta</name><argument_list>(<argument><expr><name>ctl</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>		
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"last received valid record of primary is: %X/%X"</literal></expr></argument>,
		 <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator><operator>(</operator><name>last_valid_received_lsn</name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr></argument>,
		 <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator><name>last_valid_received_lsn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * POLAR: report io error when parse xlog
 */</comment>
<function><type><name>void</name></type>
<name>polar_datamax_report_io_error</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>path</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>log_level</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><name>errno</name> <operator>=</operator> <name>polar_datamax_io_errno</name></expr>;</expr_stmt>

	<switch>switch <condition>(<expr><name>polar_datamax_io_errcause</name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>POLAR_DATAMAX_OPEN_FAILED</name></expr>:</case>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>log_level</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not open wal file \"%s\" for reading: %m"</literal></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>POLAR_DATAMAX_SEEK_FAILED</name></expr>:</case>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>log_level</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not seek in wal file \"%s\" : %m"</literal></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>POLAR_DATAMAX_READ_FAILED</name></expr>:</case>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>log_level</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not read from wal file \"%s\" : %m"</literal></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<default>default:</default>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized polar datamax io error cause: %d"</literal></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name>polar_datamax_io_errcause</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
	</block_content>}</block></switch>
</block_content>}</block></function>

<comment type="block">/*
 * POLAR: Main entry of DataMax node.
 * It will take some operations of Startup, like revoking stream replication,
 * config read. Also, it will do some DataMax operations, like config maintainment,
 * meta data managment, etc.
 */</comment>
<function><type><name>void</name></type>
<name>polar_datamax_main</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TimestampTz</name></type> <name>last_handle_interrupts_time</name> <init>= <expr><call><name>GetCurrentTimestamp</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>        <name><name>activitymsg</name><index>[<expr><name>MAXFNAMELEN</name> <operator>+</operator> <literal type="number">16</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>XLogRecPtr</name></type> 	<name>consensusReceivedUpto</name> <init>= <expr><name>InvalidXLogRecPtr</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TimeLineID</name></type> 	<name>consensusReceivedTLI</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>		<modifier>*</modifier></type><name>consensusPrimaryConnInfo</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * validate datamax directory. for shared storage, we keep meta data
	 * info in local storage, for standalone storage, we keep meta and
	 * wal data all in same storage.
	 */</comment>
	<expr_stmt><expr><call><name>polar_datamax_validate_dir</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* read necessary config in recovery.conf */</comment>
	<expr_stmt><expr><call><name>polar_datamax_read_recovery_conf</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>polar_datamax_mode_requested</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"entering datamax mode"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"datamax mode is not correct, please check config file."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/* load datamax meta info */</comment>
	<expr_stmt><expr><call><name>polar_datamax_load_meta</name><argument_list>(<argument><expr><name>polar_datamax_ctl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* create meta file if it doesn't exist */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>polar_datamax_meta_file_exist</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>polar_datamax_write_meta</name><argument_list>(<argument><expr><name>polar_datamax_ctl</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* init latestCompletedXid which is necessary while GetSnapshotData  */</comment>
	<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>ProcArrayLock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ShmemVariableCache</name><operator>-&gt;</operator><name>latestCompletedXid</name></name> <operator>=</operator> <name><name>ShmemVariableCache</name><operator>-&gt;</operator><name>nextXid</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>TransactionIdRetreat</name><argument_list>(<argument><expr><name><name>ShmemVariableCache</name><operator>-&gt;</operator><name>latestCompletedXid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>ProcArrayLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* notify postmaster turn into DATAMAX status */</comment>
	<expr_stmt><expr><call><name>SendPostmasterSignal</name><argument_list>(<argument><expr><name>PGSIGNAL_BEGIN_DATAMAX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* update process title info */</comment>
	<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>activitymsg</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>activitymsg</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"polar_datamax"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>set_ps_display</name><argument_list>(<argument><expr><name>activitymsg</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* parse xlog and update last_valid_received_lsn, which is used to request xlog streaming */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>polar_is_dma_logger_node</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>polar_datamax_parse_xlog</name><argument_list>(<argument><expr><name>polar_datamax_ctl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Ready to go */</comment>
	<while>while <condition>(<expr><name>true</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>TimestampTz</name></type> <name>current_time</name> <init>= <expr><call><name>GetCurrentTimestamp</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>TimestampDifferenceExceeds</name><argument_list>(<argument><expr><name>last_handle_interrupts_time</name></expr></argument>, <argument><expr><name>current_time</name></expr></argument>, <argument><expr><literal type="number">5</literal></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* save replication slot info when shutdown */</comment>
			<if_stmt><if>if <condition>(<expr><name>polar_datamax_shutdown_requested</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>CheckPointReplicationSlots</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<comment type="block">/* Handle interrupt signals of startup process */</comment>
			<expr_stmt><expr><call><name>HandleStartupProcInterrupts</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* POLAR: every 5 ms call this */</comment>
			<expr_stmt><expr><name>last_handle_interrupts_time</name> <operator>=</operator> <name>current_time</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>polar_is_dma_logger_node</name><argument_list>()</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>TimeLineID</name></type>	<name>tli</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>bool</name></type> 		<name>next_tli</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt> 

			<expr_stmt><expr><name>polar_is_datamax_mode</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>polar_dma_check_logger_status</name><argument_list>(<argument><expr><operator>&amp;</operator><name>consensusPrimaryConnInfo</name></expr></argument>, 
						<argument><expr><operator>&amp;</operator><name>consensusReceivedUpto</name></expr></argument> , <argument><expr><operator>&amp;</operator><name>consensusReceivedTLI</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>next_tli</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name>next_tli</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>tli</name> <operator>=</operator> <name>consensusReceivedTLI</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><name>tli</name> <operator>=</operator> <name>consensusReceivedTLI</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"RequestXLogStreaming, PrimaryConnInfo: %s, TimeLineID: %d, LSN: \"%X/%X\""</literal></expr></argument>,
						<argument><expr><name>consensusPrimaryConnInfo</name></expr></argument>, <argument><expr><name>tli</name></expr></argument>,
						<argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <operator>(</operator><name>consensusReceivedUpto</name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr></argument>, <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <name>consensusReceivedUpto</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><call><name>RequestXLogStreaming</name><argument_list>(<argument><expr><name>tli</name></expr></argument>, <argument><expr><name>consensusReceivedUpto</name></expr></argument>, <argument><expr><name>consensusPrimaryConnInfo</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if>
		<comment type="block">/*
		 * Check whether walreceiver is streaming, if not, try to pull up
		 * walreceiver with suitable requested start position and timeline.
		 */</comment>
		<if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>WalRcvStreaming</name><argument_list>()</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* ensure walreceiver is stopped */</comment>
			<expr_stmt><expr><call><name>ShutdownWalRcv</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* POLAR: try to read timeline history of current timeline and
			 * compare endptr with current lsn. If current timeline is ended,
			 * we roll up current timeline and try to fetch wal from new timeline. */</comment>
			<expr_stmt><expr><call><name>polar_datamax_handle_timeline_switch</name><argument_list>(<argument><expr><name>polar_datamax_ctl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name>primary_conninfo</name> <operator>&amp;&amp;</operator> <name>primary_slot_name</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* try to pull up walreceiver, start streaming from last valid lsn */</comment>
				<expr_stmt><expr><call><name>RequestXLogStreaming</name><argument_list>(
					<argument><expr><name>POLAR_DATAMAX_STREAMING_TIMELINE</name></expr></argument>,
					<argument><expr><name>POLAR_DATAMAX_STREAMING_LSN</name></expr></argument>,
					<argument><expr><name>primary_conninfo</name></expr></argument>,
					<argument><expr><name>primary_slot_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			</block_content>}</block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>, <argument><expr><literal type="string">"primary connection info or primary slot name is lacking in datamax node."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>polar_datamax_handle_clean_task</name><argument_list>(<argument><expr><name>polar_datamax_ctl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* save replication slots */</comment>
		<expr_stmt><expr><call><name>polar_datamax_save_replication_slots</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* start archive */</comment>
		<expr_stmt><expr><call><name>polar_datamax_archive</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* remove archive done wal */</comment>
		<expr_stmt><expr><call><name>polar_datamax_remove_archivedone_wal</name><argument_list>(<argument><expr><name>polar_datamax_ctl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* prealloc wal file */</comment>
		<expr_stmt><expr><call><name>polar_datamax_prealloc_wal_file</name><argument_list>(<argument><expr><name>polar_datamax_ctl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>polar_wait_recovery_wakeup</name><argument_list>(<argument><expr><name>WL_LATCH_SET</name> <operator>|</operator> <name>WL_TIMEOUT</name> <operator>|</operator> <name>WL_POSTMASTER_DEATH</name></expr></argument>,
					   <argument><expr><literal type="number">1</literal> <operator>*</operator> <literal type="number">1000</literal></expr></argument> <comment type="block">/* ms */</comment>, <argument><expr><name>WAIT_EVENT_DATAMAX_MAIN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>rc</name> <operator>&amp;</operator> <name>WL_POSTMASTER_DEATH</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></while>
</block_content>}</block></function>


</unit>
