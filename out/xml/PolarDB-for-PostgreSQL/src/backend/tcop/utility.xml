<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/PolarDB-for-PostgreSQL/src/backend/tcop/utility.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * utility.c
 *	  Contains functions which control the execution of the POSTGRES utility
 *	  commands.  At one time acted as an interface between the Lisp and C
 *	  systems.
 *
 * Portions Copyright (c) 1996-2018, PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, Regents of the University of California
 *
 *
 * IDENTIFICATION
 *	  src/backend/tcop/utility.c
 *
 *-------------------------------------------------------------------------
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/htup_details.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/reloptions.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/twophase.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/xact.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/xlog.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/catalog.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/namespace.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_inherits.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/toasting.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/alter.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/async.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/cluster.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/comment.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/collationcmds.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/conversioncmds.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/copy.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/createas.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/dbcommands.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/defrem.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/discard.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/event_trigger.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/explain.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/extension.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/matview.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/lockcmds.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/policy.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/portalcmds.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/prepare.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/proclang.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/publicationcmds.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/schemacmds.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/seclabel.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/sequence.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/subscriptioncmds.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/tablecmds.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/tablespace.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/trigger.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/typecmds.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/user.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/vacuum.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/view.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parse_utilcmd.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postmaster/bgwriter.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"rewrite/rewriteDefine.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"rewrite/rewriteRemove.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/fd.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"tcop/pquery.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"tcop/utility.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/acl.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/guc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/lsyscache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/syscache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/rel.h"</cpp:file></cpp:include>

<comment type="block">/* POLAR */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/proc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"polar_dma/polar_dma.h"</cpp:file></cpp:include>

<comment type="block">/* POLAR px */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/px_btbuild.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"polar_flashback/polar_flashback_drop.h"</cpp:file></cpp:include>




<comment type="block">/* Hook for plugins to get control in ProcessUtility() */</comment>
<decl_stmt><decl><type><name>ProcessUtility_hook_type</name></type> <name>ProcessUtility_hook</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<comment type="block">/* local function declarations */</comment>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ProcessUtilitySlow</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>,
				   <parameter><decl><type><name>PlannedStmt</name> <modifier>*</modifier></type><name>pstmt</name></decl></parameter>,
				   <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>queryString</name></decl></parameter>,
				   <parameter><decl><type><name>ProcessUtilityContext</name></type> <name>context</name></decl></parameter>,
				   <parameter><decl><type><name>ParamListInfo</name></type> <name>params</name></decl></parameter>,
				   <parameter><decl><type><name>QueryEnvironment</name> <modifier>*</modifier></type><name>queryEnv</name></decl></parameter>,
				   <parameter><decl><type><name>DestReceiver</name> <modifier>*</modifier></type><name>dest</name></decl></parameter>,
				   <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>completionTag</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ExecDropStmt</name><parameter_list>(<parameter><decl><type><name>DropStmt</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>isTopLevel</name></decl></parameter>)</parameter_list>;</function_decl>


<comment type="block">/*
 * CommandIsReadOnly: is an executable query read-only?
 *
 * This is a much stricter test than we apply for XactReadOnly mode;
 * the query must be *in truth* read-only, because the caller wishes
 * not to do CommandCounterIncrement for it.
 *
 * Note: currently no need to support raw or analyzed queries here
 */</comment>
<function><type><name>bool</name></type>
<name>CommandIsReadOnly</name><parameter_list>(<parameter><decl><type><name>PlannedStmt</name> <modifier>*</modifier></type><name>pstmt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>IsA</name><argument_list>(<argument><expr><name>pstmt</name></expr></argument>, <argument><expr><name>PlannedStmt</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<switch>switch <condition>(<expr><name><name>pstmt</name><operator>-&gt;</operator><name>commandType</name></name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>CMD_SELECT</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><name><name>pstmt</name><operator>-&gt;</operator><name>rowMarks</name></name> <operator>!=</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>false</name></expr>;</return></block_content></block></if>	<comment type="block">/* SELECT FOR [KEY] UPDATE/SHARE */</comment>
			<if type="elseif">else if <condition>(<expr><name><name>pstmt</name><operator>-&gt;</operator><name>hasModifyingCTE</name></name></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>false</name></expr>;</return></block_content></block></if>	<comment type="block">/* data-modifying CTE */</comment>
			<else>else<block type="pseudo"><block_content>
				<return>return <expr><name>true</name></expr>;</return></block_content></block></else></if_stmt>
		<case>case <expr><name>CMD_UPDATE</name></expr>:</case>
		<case>case <expr><name>CMD_INSERT</name></expr>:</case>
		<case>case <expr><name>CMD_DELETE</name></expr>:</case>
			<return>return <expr><name>false</name></expr>;</return>
		<case>case <expr><name>CMD_UTILITY</name></expr>:</case>
			<comment type="block">/* For now, treat all utility commands as read/write */</comment>
			<return>return <expr><name>false</name></expr>;</return>
		<default>default:</default>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>, <argument><expr><literal type="string">"unrecognized commandType: %d"</literal></expr></argument>,
				 <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name><name>pstmt</name><operator>-&gt;</operator><name>commandType</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
	</block_content>}</block></switch>
	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier>  <name>bool</name></type>
<name>polar_is_allow_stmt_type</name><parameter_list>(<parameter><decl><type><name>NodeTag</name></type> <name>type</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<switch>switch<condition>(<expr><name>type</name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>T_AlterDatabaseStmt</name></expr>:</case>
		<case>case <expr><name>T_AlterDatabaseSetStmt</name></expr>:</case>
		<case>case <expr><name>T_AlterDomainStmt</name></expr>:</case>
		<case>case <expr><name>T_AlterFunctionStmt</name></expr>:</case>
		<case>case <expr><name>T_AlterRoleStmt</name></expr>:</case>
		<case>case <expr><name>T_AlterRoleSetStmt</name></expr>:</case>
		<case>case <expr><name>T_AlterObjectDependsStmt</name></expr>:</case>
		<case>case <expr><name>T_AlterObjectSchemaStmt</name></expr>:</case>
		<case>case <expr><name>T_AlterOwnerStmt</name></expr>:</case>
		<case>case <expr><name>T_AlterOperatorStmt</name></expr>:</case>
		<case>case <expr><name>T_AlterSeqStmt</name></expr>:</case>
		<case>case <expr><name>T_AlterTableMoveAllStmt</name></expr>:</case>
		<case>case <expr><name>T_AlterTableStmt</name></expr>:</case>
		<case>case <expr><name>T_RenameStmt</name></expr>:</case>
		<case>case <expr><name>T_CommentStmt</name></expr>:</case>
		<case>case <expr><name>T_DefineStmt</name></expr>:</case>
		<case>case <expr><name>T_CreateCastStmt</name></expr>:</case>
		<case>case <expr><name>T_CreateEventTrigStmt</name></expr>:</case>
		<case>case <expr><name>T_AlterEventTrigStmt</name></expr>:</case>
		<case>case <expr><name>T_CreateConversionStmt</name></expr>:</case>
		<case>case <expr><name>T_CreatedbStmt</name></expr>:</case>
		<case>case <expr><name>T_CreateDomainStmt</name></expr>:</case>
		<case>case <expr><name>T_CreateFunctionStmt</name></expr>:</case>
		<case>case <expr><name>T_CreateRoleStmt</name></expr>:</case>
		<case>case <expr><name>T_IndexStmt</name></expr>:</case>
		<case>case <expr><name>T_CreatePLangStmt</name></expr>:</case>
		<case>case <expr><name>T_CreateOpClassStmt</name></expr>:</case>
		<case>case <expr><name>T_CreateOpFamilyStmt</name></expr>:</case>
		<case>case <expr><name>T_AlterOpFamilyStmt</name></expr>:</case>
		<case>case <expr><name>T_RuleStmt</name></expr>:</case>
		<case>case <expr><name>T_CreateSchemaStmt</name></expr>:</case>
		<case>case <expr><name>T_CreateSeqStmt</name></expr>:</case>
		<case>case <expr><name>T_CreateStmt</name></expr>:</case>
		<case>case <expr><name>T_CreateTableAsStmt</name></expr>:</case>
		<case>case <expr><name>T_RefreshMatViewStmt</name></expr>:</case>
		<case>case <expr><name>T_CreateTableSpaceStmt</name></expr>:</case>
		<case>case <expr><name>T_CreateTransformStmt</name></expr>:</case>
		<case>case <expr><name>T_CreateTrigStmt</name></expr>:</case>
		<case>case <expr><name>T_CompositeTypeStmt</name></expr>:</case>
		<case>case <expr><name>T_CreateEnumStmt</name></expr>:</case>
		<case>case <expr><name>T_CreateRangeStmt</name></expr>:</case>
		<case>case <expr><name>T_AlterEnumStmt</name></expr>:</case>
		<case>case <expr><name>T_ViewStmt</name></expr>:</case>		
		<case>case <expr><name>T_AlterDefaultPrivilegesStmt</name></expr>:</case>	
		<case>case <expr><name>T_ReassignOwnedStmt</name></expr>:</case>
		<case>case <expr><name>T_AlterTSDictionaryStmt</name></expr>:</case>
		<case>case <expr><name>T_AlterTSConfigurationStmt</name></expr>:</case>
		<case>case <expr><name>T_CreateExtensionStmt</name></expr>:</case>
		<case>case <expr><name>T_AlterExtensionStmt</name></expr>:</case>
		<case>case <expr><name>T_AlterExtensionContentsStmt</name></expr>:</case>
		<case>case <expr><name>T_CreateFdwStmt</name></expr>:</case>
		<case>case <expr><name>T_AlterFdwStmt</name></expr>:</case>
		<case>case <expr><name>T_CreateForeignServerStmt</name></expr>:</case>
		<case>case <expr><name>T_AlterForeignServerStmt</name></expr>:</case>
		<case>case <expr><name>T_CreateUserMappingStmt</name></expr>:</case>
		<case>case <expr><name>T_AlterUserMappingStmt</name></expr>:</case>
		<case>case <expr><name>T_AlterTableSpaceOptionsStmt</name></expr>:</case>
		<case>case <expr><name>T_CreateForeignTableStmt</name></expr>:</case>
		<case>case <expr><name>T_ImportForeignSchemaStmt</name></expr>:</case>
		<case>case <expr><name>T_SecLabelStmt</name></expr>:</case>
		<case>case <expr><name>T_CreatePublicationStmt</name></expr>:</case>
		<case>case <expr><name>T_AlterPublicationStmt</name></expr>:</case>
		<case>case <expr><name>T_CreateSubscriptionStmt</name></expr>:</case>
		<case>case <expr><name>T_AlterSubscriptionStmt</name></expr>:</case>
			<return>return <expr><name>false</name></expr>;</return>
		
		<case>case <expr><name>T_DropStmt</name></expr>:</case>
		<case>case <expr><name>T_DropdbStmt</name></expr>:</case>
		<case>case <expr><name>T_DropTableSpaceStmt</name></expr>:</case>
		<case>case <expr><name>T_DropRoleStmt</name></expr>:</case>
		<case>case <expr><name>T_GrantStmt</name></expr>:</case>
		<case>case <expr><name>T_GrantRoleStmt</name></expr>:</case>
		<case>case <expr><name>T_TruncateStmt</name></expr>:</case>
		<case>case <expr><name>T_DropOwnedStmt</name></expr>:</case>
		<case>case <expr><name>T_DropUserMappingStmt</name></expr>:</case>		
		<case>case <expr><name>T_DropSubscriptionStmt</name></expr>:</case>
			<return>return <expr><name>true</name></expr>;</return>
		<default>default:</default>
			<return>return <expr><name>false</name></expr>;</return>			
	</block_content>}</block></switch>
</block_content>}</block></function>

<comment type="block">/*
 * check_xact_readonly: is a utility command read-only?
 *
 * Here we use the loose rules of XactReadOnly mode: no permanent effects
 * on the database are allowed.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>check_xact_readonly</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>parsetree</name></decl></parameter>)</parameter_list>
<block>{<block_content>

	<comment type="block">/* POLAR: don't limit superuser */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>MyProc</name><operator>-&gt;</operator><name>issuper</name></name> <operator>&amp;&amp;</operator> <name>polar_force_trans_ro_non_sup</name> <operator>&amp;&amp;</operator>
	    <call><name>polar_is_allow_stmt_type</name><argument_list>(<argument><expr><call><name>nodeTag</name><argument_list>(<argument><expr><name>parsetree</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>
	<comment type="block">/* POLAR end */</comment>
	
	<comment type="block">/* Only perform the check if we have a reason to do so. */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>XactReadOnly</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>IsInParallelMode</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Note: Commands that need to do more complicated checking are handled
	 * elsewhere, in particular COPY and plannable statements do their own
	 * checking.  However they should all call PreventCommandIfReadOnly or
	 * PreventCommandIfParallelMode to actually throw the error.
	 */</comment>

	<switch>switch <condition>(<expr><call><name>nodeTag</name><argument_list>(<argument><expr><name>parsetree</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>T_AlterDatabaseStmt</name></expr>:</case>
		<case>case <expr><name>T_AlterDatabaseSetStmt</name></expr>:</case>
		<case>case <expr><name>T_AlterDomainStmt</name></expr>:</case>
		<case>case <expr><name>T_AlterFunctionStmt</name></expr>:</case>
		<case>case <expr><name>T_AlterRoleStmt</name></expr>:</case>
		<case>case <expr><name>T_AlterRoleSetStmt</name></expr>:</case>
		<case>case <expr><name>T_AlterObjectDependsStmt</name></expr>:</case>
		<case>case <expr><name>T_AlterObjectSchemaStmt</name></expr>:</case>
		<case>case <expr><name>T_AlterOwnerStmt</name></expr>:</case>
		<case>case <expr><name>T_AlterOperatorStmt</name></expr>:</case>
		<case>case <expr><name>T_AlterSeqStmt</name></expr>:</case>
		<case>case <expr><name>T_AlterTableMoveAllStmt</name></expr>:</case>
		<case>case <expr><name>T_AlterTableStmt</name></expr>:</case>
		<case>case <expr><name>T_RenameStmt</name></expr>:</case>
		<case>case <expr><name>T_CommentStmt</name></expr>:</case>
		<case>case <expr><name>T_DefineStmt</name></expr>:</case>
		<case>case <expr><name>T_CreateCastStmt</name></expr>:</case>
		<case>case <expr><name>T_CreateEventTrigStmt</name></expr>:</case>
		<case>case <expr><name>T_AlterEventTrigStmt</name></expr>:</case>
		<case>case <expr><name>T_CreateConversionStmt</name></expr>:</case>
		<case>case <expr><name>T_CreatedbStmt</name></expr>:</case>
		<case>case <expr><name>T_CreateDomainStmt</name></expr>:</case>
		<case>case <expr><name>T_CreateFunctionStmt</name></expr>:</case>
		<case>case <expr><name>T_CreateRoleStmt</name></expr>:</case>
		<case>case <expr><name>T_IndexStmt</name></expr>:</case>
		<case>case <expr><name>T_CreatePLangStmt</name></expr>:</case>
		<case>case <expr><name>T_CreateOpClassStmt</name></expr>:</case>
		<case>case <expr><name>T_CreateOpFamilyStmt</name></expr>:</case>
		<case>case <expr><name>T_AlterOpFamilyStmt</name></expr>:</case>
		<case>case <expr><name>T_RuleStmt</name></expr>:</case>
		<case>case <expr><name>T_CreateSchemaStmt</name></expr>:</case>
		<case>case <expr><name>T_CreateSeqStmt</name></expr>:</case>
		<case>case <expr><name>T_CreateStmt</name></expr>:</case>
		<case>case <expr><name>T_CreateTableAsStmt</name></expr>:</case>
		<case>case <expr><name>T_RefreshMatViewStmt</name></expr>:</case>
		<case>case <expr><name>T_CreateTableSpaceStmt</name></expr>:</case>
		<case>case <expr><name>T_CreateTransformStmt</name></expr>:</case>
		<case>case <expr><name>T_CreateTrigStmt</name></expr>:</case>
		<case>case <expr><name>T_CompositeTypeStmt</name></expr>:</case>
		<case>case <expr><name>T_CreateEnumStmt</name></expr>:</case>
		<case>case <expr><name>T_CreateRangeStmt</name></expr>:</case>
		<case>case <expr><name>T_AlterEnumStmt</name></expr>:</case>
		<case>case <expr><name>T_ViewStmt</name></expr>:</case>
		<case>case <expr><name>T_DropStmt</name></expr>:</case>
		<case>case <expr><name>T_DropdbStmt</name></expr>:</case>
		<case>case <expr><name>T_DropTableSpaceStmt</name></expr>:</case>
		<case>case <expr><name>T_DropRoleStmt</name></expr>:</case>
		<case>case <expr><name>T_GrantStmt</name></expr>:</case>
		<case>case <expr><name>T_GrantRoleStmt</name></expr>:</case>
		<case>case <expr><name>T_AlterDefaultPrivilegesStmt</name></expr>:</case>
		<case>case <expr><name>T_TruncateStmt</name></expr>:</case>
		<case>case <expr><name>T_DropOwnedStmt</name></expr>:</case>
		<case>case <expr><name>T_ReassignOwnedStmt</name></expr>:</case>
		<case>case <expr><name>T_AlterTSDictionaryStmt</name></expr>:</case>
		<case>case <expr><name>T_AlterTSConfigurationStmt</name></expr>:</case>
		<case>case <expr><name>T_CreateExtensionStmt</name></expr>:</case>
		<case>case <expr><name>T_AlterExtensionStmt</name></expr>:</case>
		<case>case <expr><name>T_AlterExtensionContentsStmt</name></expr>:</case>
		<case>case <expr><name>T_CreateFdwStmt</name></expr>:</case>
		<case>case <expr><name>T_AlterFdwStmt</name></expr>:</case>
		<case>case <expr><name>T_CreateForeignServerStmt</name></expr>:</case>
		<case>case <expr><name>T_AlterForeignServerStmt</name></expr>:</case>
		<case>case <expr><name>T_CreateUserMappingStmt</name></expr>:</case>
		<case>case <expr><name>T_AlterUserMappingStmt</name></expr>:</case>
		<case>case <expr><name>T_DropUserMappingStmt</name></expr>:</case>
		<case>case <expr><name>T_AlterTableSpaceOptionsStmt</name></expr>:</case>
		<case>case <expr><name>T_CreateForeignTableStmt</name></expr>:</case>
		<case>case <expr><name>T_ImportForeignSchemaStmt</name></expr>:</case>
		<case>case <expr><name>T_SecLabelStmt</name></expr>:</case>
		<case>case <expr><name>T_CreatePublicationStmt</name></expr>:</case>
		<case>case <expr><name>T_AlterPublicationStmt</name></expr>:</case>
		<case>case <expr><name>T_CreateSubscriptionStmt</name></expr>:</case>
		<case>case <expr><name>T_AlterSubscriptionStmt</name></expr>:</case>
		<case>case <expr><name>T_DropSubscriptionStmt</name></expr>:</case>
			<expr_stmt><expr><call><name>PreventCommandIfReadOnly</name><argument_list>(<argument><expr><call><name>CreateCommandTag</name><argument_list>(<argument><expr><name>parsetree</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>PreventCommandIfParallelMode</name><argument_list>(<argument><expr><call><name>CreateCommandTag</name><argument_list>(<argument><expr><name>parsetree</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<default>default:</default>
			<comment type="block">/* do nothing */</comment>
			<break>break;</break>
	</block_content>}</block></switch>
</block_content>}</block></function>

<comment type="block">/*
 * PreventCommandIfReadOnly: throw error if XactReadOnly
 *
 * This is useful mainly to ensure consistency of the error message wording;
 * most callers have checked XactReadOnly for themselves.
 */</comment>
<function><type><name>void</name></type>
<name>PreventCommandIfReadOnly</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>cmdname</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* POLAR: check transaction read only */</comment>
	<if_stmt><if>if <condition>(<expr><name>XactReadOnly</name> <operator>||</operator> <operator>(</operator><operator>!</operator><name><name>MyProc</name><operator>-&gt;</operator><name>issuper</name></name> <operator>&amp;&amp;</operator> <name>polar_force_trans_ro_non_sup</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_READ_ONLY_SQL_TRANSACTION</name></expr></argument>)</argument_list></call><operator>,</operator>
		<comment type="block">/* translator: %s is name of a SQL command, eg CREATE */</comment>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot execute %s in a read-only transaction"</literal></expr></argument>,
						<argument><expr><name>cmdname</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * PreventCommandIfParallelMode: throw error if current (sub)transaction is
 * in parallel mode.
 *
 * This is useful mainly to ensure consistency of the error message wording;
 * most callers have checked IsInParallelMode() for themselves.
 */</comment>
<function><type><name>void</name></type>
<name>PreventCommandIfParallelMode</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>cmdname</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><call><name>IsInParallelMode</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_TRANSACTION_STATE</name></expr></argument>)</argument_list></call><operator>,</operator>
		<comment type="block">/* translator: %s is name of a SQL command, eg CREATE */</comment>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot execute %s during a parallel operation"</literal></expr></argument>,
						<argument><expr><name>cmdname</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * PreventCommandDuringRecovery: throw error if RecoveryInProgress
 *
 * The majority of operations that are unsafe in a Hot Standby
 * will be rejected by XactReadOnly tests.  However there are a few
 * commands that are allowed in "read-only" xacts but cannot be allowed
 * in Hot Standby mode.  Those commands should call this function.
 */</comment>
<function><type><name>void</name></type>
<name>PreventCommandDuringRecovery</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>cmdname</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><call><name>RecoveryInProgress</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_READ_ONLY_SQL_TRANSACTION</name></expr></argument>)</argument_list></call><operator>,</operator>
		<comment type="block">/* translator: %s is name of a SQL command, eg CREATE */</comment>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot execute %s during recovery"</literal></expr></argument>,
						<argument><expr><name>cmdname</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * CheckRestrictedOperation: throw error for hazardous command if we're
 * inside a security restriction context.
 *
 * This is needed to protect session-local state for which there is not any
 * better-defined protection mechanism, such as ownership.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>CheckRestrictedOperation</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>cmdname</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><call><name>InSecurityRestrictedOperation</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INSUFFICIENT_PRIVILEGE</name></expr></argument>)</argument_list></call><operator>,</operator>
		<comment type="block">/* translator: %s is name of a SQL command, eg PREPARE */</comment>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot execute %s within security-restricted operation"</literal></expr></argument>,
						<argument><expr><name>cmdname</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * ProcessUtility
 *		general utility function invoker
 *
 *	pstmt: PlannedStmt wrapper for the utility statement
 *	queryString: original source text of command
 *	context: identifies source of statement (toplevel client command,
 *		non-toplevel client command, subcommand of a larger utility command)
 *	params: parameters to use during execution
 *	queryEnv: environment for parse through execution (e.g., ephemeral named
 *		tables like trigger transition tables).  May be NULL.
 *	dest: where to send results
 *	completionTag: points to a buffer of size COMPLETION_TAG_BUFSIZE
 *		in which to store a command completion status string.
 *
 * Caller MUST supply a queryString; it is not allowed (anymore) to pass NULL.
 * If you really don't have source text, you can pass a constant string,
 * perhaps "(query not available)".
 *
 * completionTag is only set nonempty if we want to return a nondefault status.
 *
 * completionTag may be NULL if caller doesn't want a status string.
 *
 * Note for users of ProcessUtility_hook: the same queryString may be passed
 * to multiple invocations of ProcessUtility when processing a query string
 * containing multiple semicolon-separated statements.  One should use
 * pstmt-&gt;stmt_location and pstmt-&gt;stmt_len to identify the substring
 * containing the current statement.  Keep in mind also that some utility
 * statements (e.g., CREATE SCHEMA) will recurse to ProcessUtility to process
 * sub-statements, often passing down the same queryString, stmt_location,
 * and stmt_len that were given for the whole statement.
 */</comment>
<function><type><name>void</name></type>
<name>ProcessUtility</name><parameter_list>(<parameter><decl><type><name>PlannedStmt</name> <modifier>*</modifier></type><name>pstmt</name></decl></parameter>,
			   <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>queryString</name></decl></parameter>,
			   <parameter><decl><type><name>ProcessUtilityContext</name></type> <name>context</name></decl></parameter>,
			   <parameter><decl><type><name>ParamListInfo</name></type> <name>params</name></decl></parameter>,
			   <parameter><decl><type><name>QueryEnvironment</name> <modifier>*</modifier></type><name>queryEnv</name></decl></parameter>,
			   <parameter><decl><type><name>DestReceiver</name> <modifier>*</modifier></type><name>dest</name></decl></parameter>,
			   <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>completionTag</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>IsA</name><argument_list>(<argument><expr><name>pstmt</name></expr></argument>, <argument><expr><name>PlannedStmt</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>pstmt</name><operator>-&gt;</operator><name>commandType</name></name> <operator>==</operator> <name>CMD_UTILITY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>queryString</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>	<comment type="block">/* required as of 8.4 */</comment>

	<comment type="block">/*
	 * We provide a function hook variable that lets loadable plugins get
	 * control when ProcessUtility is called.  Such a plugin would normally
	 * call standard_ProcessUtility().
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>ProcessUtility_hook</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if<condition>(<expr><call><name>polar_flashback_drop_process_utility</name><argument_list>(<argument><expr><name>pstmt</name></expr></argument>, <argument><expr><name>queryString</name></expr></argument>, <argument><expr><name>context</name></expr></argument>, <argument><expr><name>params</name></expr></argument>, <argument><expr><name>queryEnv</name></expr></argument>, <argument><expr><name>dest</name></expr></argument>, <argument><expr><name>completionTag</name></expr></argument>,<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content/>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><call>(<modifier>*</modifier><name>ProcessUtility_hook</name>) <argument_list>(<argument><expr><name>pstmt</name></expr></argument>, <argument><expr><name>queryString</name></expr></argument>,
							<argument><expr><name>context</name></expr></argument>, <argument><expr><name>params</name></expr></argument>, <argument><expr><name>queryEnv</name></expr></argument>,
							<argument><expr><name>dest</name></expr></argument>, <argument><expr><name>completionTag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<if_stmt><if>if<condition>(<expr><call><name>polar_flashback_drop_process_utility</name><argument_list>(<argument><expr><name>pstmt</name></expr></argument>, <argument><expr><name>queryString</name></expr></argument>, <argument><expr><name>context</name></expr></argument>, <argument><expr><name>params</name></expr></argument>, <argument><expr><name>queryEnv</name></expr></argument>, <argument><expr><name>dest</name></expr></argument>, <argument><expr><name>completionTag</name></expr></argument>,<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content/>}</block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>standard_ProcessUtility</name><argument_list>(<argument><expr><name>pstmt</name></expr></argument>, <argument><expr><name>queryString</name></expr></argument>,
									<argument><expr><name>context</name></expr></argument>, <argument><expr><name>params</name></expr></argument>, <argument><expr><name>queryEnv</name></expr></argument>,
									<argument><expr><name>dest</name></expr></argument>, <argument><expr><name>completionTag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * standard_ProcessUtility itself deals only with utility commands for
 * which we do not provide event trigger support.  Commands that do have
 * such support are passed down to ProcessUtilitySlow, which contains the
 * necessary infrastructure for such triggers.
 *
 * This division is not just for performance: it's critical that the
 * event trigger code not be invoked when doing START TRANSACTION for
 * example, because we might need to refresh the event trigger cache,
 * which requires being in a valid transaction.
 */</comment>
<function><type><name>void</name></type>
<name>standard_ProcessUtility</name><parameter_list>(<parameter><decl><type><name>PlannedStmt</name> <modifier>*</modifier></type><name>pstmt</name></decl></parameter>,
						<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>queryString</name></decl></parameter>,
						<parameter><decl><type><name>ProcessUtilityContext</name></type> <name>context</name></decl></parameter>,
						<parameter><decl><type><name>ParamListInfo</name></type> <name>params</name></decl></parameter>,
						<parameter><decl><type><name>QueryEnvironment</name> <modifier>*</modifier></type><name>queryEnv</name></decl></parameter>,
						<parameter><decl><type><name>DestReceiver</name> <modifier>*</modifier></type><name>dest</name></decl></parameter>,
						<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>completionTag</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>parsetree</name> <init>= <expr><name><name>pstmt</name><operator>-&gt;</operator><name>utilityStmt</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>isTopLevel</name> <init>= <expr><operator>(</operator><name>context</name> <operator>==</operator> <name>PROCESS_UTILITY_TOPLEVEL</name><operator>)</operator></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>isAtomicContext</name> <init>= <expr><operator>(</operator><operator>!</operator><operator>(</operator><name>context</name> <operator>==</operator> <name>PROCESS_UTILITY_TOPLEVEL</name> <operator>||</operator> <name>context</name> <operator>==</operator> <name>PROCESS_UTILITY_QUERY_NONATOMIC</name><operator>)</operator> <operator>||</operator> <call><name>IsTransactionBlock</name><argument_list>()</argument_list></call><operator>)</operator></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl>;</decl_stmt>

	<comment type="block">/* This can recurse, so check for excessive recursion */</comment>
	<expr_stmt><expr><call><name>check_stack_depth</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>check_xact_readonly</name><argument_list>(<argument><expr><name>parsetree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>completionTag</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>completionTag</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>pstate</name> <operator>=</operator> <call><name>make_parsestate</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_sourcetext</name></name> <operator>=</operator> <name>queryString</name></expr>;</expr_stmt>

	<switch>switch <condition>(<expr><call><name>nodeTag</name><argument_list>(<argument><expr><name>parsetree</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
			<comment type="block">/*
			 * ******************** transactions ********************
			 */</comment>
		<case>case <expr><name>T_TransactionStmt</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>TransactionStmt</name> <modifier>*</modifier></type><name>stmt</name> <init>= <expr><operator>(</operator><name>TransactionStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></init></decl>;</decl_stmt>

				<switch>switch <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>kind</name></name></expr>)</condition>
				<block>{<block_content>
						<comment type="block">/*
						 * START TRANSACTION, as defined by SQL99: Identical
						 * to BEGIN.  Same code for both.
						 */</comment>
					<case>case <expr><name>TRANS_STMT_BEGIN</name></expr>:</case>
					<case>case <expr><name>TRANS_STMT_START</name></expr>:</case>
						<block>{<block_content>
							<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

							<expr_stmt><expr><call><name>BeginTransactionBlock</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
							<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>stmt-&gt;options</argument>)</argument_list></macro>
							<block>{<block_content>
								<decl_stmt><decl><type><name>DefElem</name>    <modifier>*</modifier></type><name>item</name> <init>= <expr><operator>(</operator><name>DefElem</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

								<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>item</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>, <argument><expr><literal type="string">"transaction_isolation"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
									<expr_stmt><expr><call><name>SetPGVariable</name><argument_list>(<argument><expr><literal type="string">"transaction_isolation"</literal></expr></argument>,
												  <argument><expr><call><name>list_make1</name><argument_list>(<argument><expr><name><name>item</name><operator>-&gt;</operator><name>arg</name></name></expr></argument>)</argument_list></call></expr></argument>,
												  <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
								<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>item</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>, <argument><expr><literal type="string">"transaction_read_only"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
									<expr_stmt><expr><call><name>SetPGVariable</name><argument_list>(<argument><expr><literal type="string">"transaction_read_only"</literal></expr></argument>,
												  <argument><expr><call><name>list_make1</name><argument_list>(<argument><expr><name><name>item</name><operator>-&gt;</operator><name>arg</name></name></expr></argument>)</argument_list></call></expr></argument>,
												  <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
								<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>item</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>, <argument><expr><literal type="string">"transaction_deferrable"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
									<expr_stmt><expr><call><name>SetPGVariable</name><argument_list>(<argument><expr><literal type="string">"transaction_deferrable"</literal></expr></argument>,
												  <argument><expr><call><name>list_make1</name><argument_list>(<argument><expr><name><name>item</name><operator>-&gt;</operator><name>arg</name></name></expr></argument>)</argument_list></call></expr></argument>,
												  <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
							</block_content>}</block>
						</block_content>}</block>
						<break>break;</break>

					<case>case <expr><name>TRANS_STMT_COMMIT</name></expr>:</case>
						<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>EndTransactionBlock</name><argument_list>()</argument_list></call></expr>)</condition>
						<block>{<block_content>
							<comment type="block">/* report unsuccessful commit in completionTag */</comment>
							<if_stmt><if>if <condition>(<expr><name>completionTag</name></expr>)</condition><block type="pseudo"><block_content>
								<expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>completionTag</name></expr></argument>, <argument><expr><literal type="string">"ROLLBACK"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
						</block_content>}</block></if></if_stmt>
						<break>break;</break>

					<case>case <expr><name>TRANS_STMT_PREPARE</name></expr>:</case>
						<expr_stmt><expr><call><name>PreventCommandDuringRecovery</name><argument_list>(<argument><expr><literal type="string">"PREPARE TRANSACTION"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>PrepareTransactionBlock</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>gid</name></name></expr></argument>)</argument_list></call></expr>)</condition>
						<block>{<block_content>
							<comment type="block">/* report unsuccessful commit in completionTag */</comment>
							<if_stmt><if>if <condition>(<expr><name>completionTag</name></expr>)</condition><block type="pseudo"><block_content>
								<expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>completionTag</name></expr></argument>, <argument><expr><literal type="string">"ROLLBACK"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
						</block_content>}</block></if></if_stmt>
						<break>break;</break>

					<case>case <expr><name>TRANS_STMT_COMMIT_PREPARED</name></expr>:</case>
						<expr_stmt><expr><call><name>PreventInTransactionBlock</name><argument_list>(<argument><expr><name>isTopLevel</name></expr></argument>, <argument><expr><literal type="string">"COMMIT PREPARED"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><call><name>PreventCommandDuringRecovery</name><argument_list>(<argument><expr><literal type="string">"COMMIT PREPARED"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><call><name>FinishPreparedTransaction</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>gid</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<break>break;</break>

					<case>case <expr><name>TRANS_STMT_ROLLBACK_PREPARED</name></expr>:</case>
						<expr_stmt><expr><call><name>PreventInTransactionBlock</name><argument_list>(<argument><expr><name>isTopLevel</name></expr></argument>, <argument><expr><literal type="string">"ROLLBACK PREPARED"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><call><name>PreventCommandDuringRecovery</name><argument_list>(<argument><expr><literal type="string">"ROLLBACK PREPARED"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><call><name>FinishPreparedTransaction</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>gid</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<break>break;</break>

					<case>case <expr><name>TRANS_STMT_ROLLBACK</name></expr>:</case>
						<expr_stmt><expr><call><name>UserAbortTransactionBlock</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
						<break>break;</break>

					<case>case <expr><name>TRANS_STMT_SAVEPOINT</name></expr>:</case>
						<expr_stmt><expr><call><name>RequireTransactionBlock</name><argument_list>(<argument><expr><name>isTopLevel</name></expr></argument>, <argument><expr><literal type="string">"SAVEPOINT"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><call><name>DefineSavepoint</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>savepoint_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<break>break;</break>

					<case>case <expr><name>TRANS_STMT_RELEASE</name></expr>:</case>
						<expr_stmt><expr><call><name>RequireTransactionBlock</name><argument_list>(<argument><expr><name>isTopLevel</name></expr></argument>, <argument><expr><literal type="string">"RELEASE SAVEPOINT"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><call><name>ReleaseSavepoint</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>savepoint_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<break>break;</break>

					<case>case <expr><name>TRANS_STMT_ROLLBACK_TO</name></expr>:</case>
						<expr_stmt><expr><call><name>RequireTransactionBlock</name><argument_list>(<argument><expr><name>isTopLevel</name></expr></argument>, <argument><expr><literal type="string">"ROLLBACK TO SAVEPOINT"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><call><name>RollbackToSavepoint</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>savepoint_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

						<comment type="block">/*
						 * CommitTransactionCommand is in charge of
						 * re-defining the savepoint again
						 */</comment>
						<break>break;</break>
				</block_content>}</block></switch>
			</block_content>}</block>
			<break>break;</break>

			<comment type="block">/*
			 * Portal (cursor) manipulation
			 */</comment>
		<case>case <expr><name>T_DeclareCursorStmt</name></expr>:</case>
			<expr_stmt><expr><call><name>PerformCursorOpen</name><argument_list>(<argument><expr><operator>(</operator><name>DeclareCursorStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></argument>, <argument><expr><name>params</name></expr></argument>,
							  <argument><expr><name>queryString</name></expr></argument>, <argument><expr><name>isTopLevel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_ClosePortalStmt</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>ClosePortalStmt</name> <modifier>*</modifier></type><name>stmt</name> <init>= <expr><operator>(</operator><name>ClosePortalStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>CheckRestrictedOperation</name><argument_list>(<argument><expr><literal type="string">"CLOSE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>PerformPortalClose</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>portalname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block>
			<break>break;</break>

		<case>case <expr><name>T_FetchStmt</name></expr>:</case>
			<expr_stmt><expr><call><name>PerformPortalFetch</name><argument_list>(<argument><expr><operator>(</operator><name>FetchStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></argument>, <argument><expr><name>dest</name></expr></argument>,
							   <argument><expr><name>completionTag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_DoStmt</name></expr>:</case>
			<expr_stmt><expr><call><name>ExecuteDoStmt</name><argument_list>(<argument><expr><operator>(</operator><name>DoStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></argument>, <argument><expr><name>isAtomicContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_CreateTableSpaceStmt</name></expr>:</case>
			<comment type="block">/* no event triggers for global objects */</comment>
			<expr_stmt><expr><call><name>PreventInTransactionBlock</name><argument_list>(<argument><expr><name>isTopLevel</name></expr></argument>, <argument><expr><literal type="string">"CREATE TABLESPACE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>CreateTableSpace</name><argument_list>(<argument><expr><operator>(</operator><name>CreateTableSpaceStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_DropTableSpaceStmt</name></expr>:</case>
			<comment type="block">/* no event triggers for global objects */</comment>
			<expr_stmt><expr><call><name>PreventInTransactionBlock</name><argument_list>(<argument><expr><name>isTopLevel</name></expr></argument>, <argument><expr><literal type="string">"DROP TABLESPACE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>DropTableSpace</name><argument_list>(<argument><expr><operator>(</operator><name>DropTableSpaceStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_AlterTableSpaceOptionsStmt</name></expr>:</case>
			<comment type="block">/* no event triggers for global objects */</comment>
			<expr_stmt><expr><call><name>AlterTableSpaceOptions</name><argument_list>(<argument><expr><operator>(</operator><name>AlterTableSpaceOptionsStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_TruncateStmt</name></expr>:</case>
			<expr_stmt><expr><call><name>ExecuteTruncate</name><argument_list>(<argument><expr><operator>(</operator><name>TruncateStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_CopyStmt</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>uint64</name></type>		<name>processed</name></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>DoCopy</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><operator>(</operator><name>CopyStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></argument>,
					   <argument><expr><name><name>pstmt</name><operator>-&gt;</operator><name>stmt_location</name></name></expr></argument>, <argument><expr><name><name>pstmt</name><operator>-&gt;</operator><name>stmt_len</name></name></expr></argument>,
					   <argument><expr><operator>&amp;</operator><name>processed</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name>completionTag</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>completionTag</name></expr></argument>, <argument><expr><name>COMPLETION_TAG_BUFSIZE</name></expr></argument>,
							 <argument><expr><literal type="string">"COPY "</literal> <name>UINT64_FORMAT</name></expr></argument>, <argument><expr><name>processed</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block>
			<break>break;</break>

		<case>case <expr><name>T_PrepareStmt</name></expr>:</case>
			<expr_stmt><expr><call><name>CheckRestrictedOperation</name><argument_list>(<argument><expr><literal type="string">"PREPARE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>PrepareQuery</name><argument_list>(<argument><expr><operator>(</operator><name>PrepareStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></argument>, <argument><expr><name>queryString</name></expr></argument>,
						 <argument><expr><name><name>pstmt</name><operator>-&gt;</operator><name>stmt_location</name></name></expr></argument>, <argument><expr><name><name>pstmt</name><operator>-&gt;</operator><name>stmt_len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_ExecuteStmt</name></expr>:</case>
			<expr_stmt><expr><call><name>ExecuteQuery</name><argument_list>(<argument><expr><operator>(</operator><name>ExecuteStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
						 <argument><expr><name>queryString</name></expr></argument>, <argument><expr><name>params</name></expr></argument>,
						 <argument><expr><name>dest</name></expr></argument>, <argument><expr><name>completionTag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_DeallocateStmt</name></expr>:</case>
			<expr_stmt><expr><call><name>CheckRestrictedOperation</name><argument_list>(<argument><expr><literal type="string">"DEALLOCATE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>DeallocateQuery</name><argument_list>(<argument><expr><operator>(</operator><name>DeallocateStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_GrantRoleStmt</name></expr>:</case>
			<comment type="block">/* no event triggers for global objects */</comment>
			<expr_stmt><expr><call><name>GrantRole</name><argument_list>(<argument><expr><operator>(</operator><name>GrantRoleStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_CreatedbStmt</name></expr>:</case>
			<comment type="block">/* no event triggers for global objects */</comment>
			<expr_stmt><expr><call><name>PreventInTransactionBlock</name><argument_list>(<argument><expr><name>isTopLevel</name></expr></argument>, <argument><expr><literal type="string">"CREATE DATABASE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>createdb</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><operator>(</operator><name>CreatedbStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_AlterDatabaseStmt</name></expr>:</case>
			<comment type="block">/* no event triggers for global objects */</comment>
			<expr_stmt><expr><call><name>AlterDatabase</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><operator>(</operator><name>AlterDatabaseStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></argument>, <argument><expr><name>isTopLevel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_AlterDatabaseSetStmt</name></expr>:</case>
			<comment type="block">/* no event triggers for global objects */</comment>
			<expr_stmt><expr><call><name>AlterDatabaseSet</name><argument_list>(<argument><expr><operator>(</operator><name>AlterDatabaseSetStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_DropdbStmt</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>DropdbStmt</name> <modifier>*</modifier></type><name>stmt</name> <init>= <expr><operator>(</operator><name>DropdbStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></init></decl>;</decl_stmt>

				<comment type="block">/* no event triggers for global objects */</comment>
				<expr_stmt><expr><call><name>PreventInTransactionBlock</name><argument_list>(<argument><expr><name>isTopLevel</name></expr></argument>, <argument><expr><literal type="string">"DROP DATABASE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>dropdb</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>dbname</name></name></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>missing_ok</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block>
			<break>break;</break>

			<comment type="block">/* Query-level asynchronous notification */</comment>
		<case>case <expr><name>T_NotifyStmt</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>NotifyStmt</name> <modifier>*</modifier></type><name>stmt</name> <init>= <expr><operator>(</operator><name>NotifyStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>PreventCommandDuringRecovery</name><argument_list>(<argument><expr><literal type="string">"NOTIFY"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>Async_Notify</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>conditionname</name></name></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>payload</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block>
			<break>break;</break>

		<case>case <expr><name>T_ListenStmt</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>ListenStmt</name> <modifier>*</modifier></type><name>stmt</name> <init>= <expr><operator>(</operator><name>ListenStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>PreventCommandDuringRecovery</name><argument_list>(<argument><expr><literal type="string">"LISTEN"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>CheckRestrictedOperation</name><argument_list>(<argument><expr><literal type="string">"LISTEN"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>Async_Listen</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>conditionname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block>
			<break>break;</break>

		<case>case <expr><name>T_UnlistenStmt</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>UnlistenStmt</name> <modifier>*</modifier></type><name>stmt</name> <init>= <expr><operator>(</operator><name>UnlistenStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></init></decl>;</decl_stmt>

				<comment type="block">/* we allow UNLISTEN during recovery, as it's a noop */</comment>
				<expr_stmt><expr><call><name>CheckRestrictedOperation</name><argument_list>(<argument><expr><literal type="string">"UNLISTEN"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>conditionname</name></name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>Async_Unlisten</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>conditionname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>Async_UnlistenAll</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
			</block_content>}</block>
			<break>break;</break>

		<case>case <expr><name>T_LoadStmt</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>LoadStmt</name>   <modifier>*</modifier></type><name>stmt</name> <init>= <expr><operator>(</operator><name>LoadStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>closeAllVfds</name><argument_list>()</argument_list></call></expr>;</expr_stmt> <comment type="block">/* probably not necessary... */</comment>
				<comment type="block">/* Allowed names are restricted if you're not superuser */</comment>
				<expr_stmt><expr><call><name>load_file</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>filename</name></name></expr></argument>, <argument><expr><operator>!</operator><call><name>superuser</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block>
			<break>break;</break>

		<case>case <expr><name>T_CallStmt</name></expr>:</case>
			<expr_stmt><expr><call><name>ExecuteCallStmt</name><argument_list>(<argument><expr><call><name>castNode</name><argument_list>(<argument><expr><name>CallStmt</name></expr></argument>, <argument><expr><name>parsetree</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>params</name></expr></argument>, <argument><expr><name>isAtomicContext</name></expr></argument>, <argument><expr><name>dest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_ClusterStmt</name></expr>:</case>
			<comment type="block">/* we choose to allow this during "read only" transactions */</comment>
			<expr_stmt><expr><call><name>PreventCommandDuringRecovery</name><argument_list>(<argument><expr><literal type="string">"CLUSTER"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* forbidden in parallel mode due to CommandIsReadOnly */</comment>
			<expr_stmt><expr><call><name>cluster</name><argument_list>(<argument><expr><operator>(</operator><name>ClusterStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></argument>, <argument><expr><name>isTopLevel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_VacuumStmt</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>VacuumStmt</name> <modifier>*</modifier></type><name>stmt</name> <init>= <expr><operator>(</operator><name>VacuumStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></init></decl>;</decl_stmt>

				<comment type="block">/* we choose to allow this during "read only" transactions */</comment>
				<expr_stmt><expr><call><name>PreventCommandDuringRecovery</name><argument_list>(<argument><expr><ternary><condition><expr><operator>(</operator><name><name>stmt</name><operator>-&gt;</operator><name>options</name></name> <operator>&amp;</operator> <name>VACOPT_VACUUM</name><operator>)</operator></expr> ?</condition><then>
											 <expr><literal type="string">"VACUUM"</literal></expr> </then><else>: <expr><literal type="string">"ANALYZE"</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<comment type="block">/* forbidden in parallel mode due to CommandIsReadOnly */</comment>
				<expr_stmt><expr><call><name>ExecVacuum</name><argument_list>(<argument><expr><name>stmt</name></expr></argument>, <argument><expr><name>isTopLevel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block>
			<break>break;</break>

		<case>case <expr><name>T_ExplainStmt</name></expr>:</case>
			<expr_stmt><expr><call><name>ExplainQuery</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><operator>(</operator><name>ExplainStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></argument>, <argument><expr><name>queryString</name></expr></argument>, <argument><expr><name>params</name></expr></argument>,
						 <argument><expr><name>queryEnv</name></expr></argument>, <argument><expr><name>dest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_AlterSystemStmt</name></expr>:</case>
			<expr_stmt><expr><call><name>PreventInTransactionBlock</name><argument_list>(<argument><expr><name>isTopLevel</name></expr></argument>, <argument><expr><literal type="string">"ALTER SYSTEM"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><operator>(</operator><operator>(</operator><name>AlterSystemStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name><operator>)</operator><operator>-&gt;</operator><name>setstmt</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>AlterSystemSetConfigFile</name><argument_list>(<argument><expr><operator>(</operator><name>AlterSystemStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if>
			<if type="elseif">else if <condition>(<expr><call><name>POLAR_ENABLE_DMA</name><argument_list>()</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>AlterSystemStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name><operator>)</operator><operator>-&gt;</operator><name>dma_stmt</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>PolarDMAUtility</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>AlterSystemStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name><operator>)</operator><operator>-&gt;</operator><name>dma_stmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			<break>break;</break>

		<case>case <expr><name>T_VariableSetStmt</name></expr>:</case>
			<expr_stmt><expr><call><name>ExecSetVariableStmt</name><argument_list>(<argument><expr><operator>(</operator><name>VariableSetStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></argument>, <argument><expr><name>isTopLevel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_VariableShowStmt</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>VariableShowStmt</name> <modifier>*</modifier></type><name>n</name> <init>= <expr><operator>(</operator><name>VariableShowStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>GetPGVariable</name><argument_list>(<argument><expr><name><name>n</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name>dest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block>
			<break>break;</break>

		<case>case <expr><name>T_DiscardStmt</name></expr>:</case>
			<comment type="block">/* should we allow DISCARD PLANS? */</comment>
			<expr_stmt><expr><call><name>CheckRestrictedOperation</name><argument_list>(<argument><expr><literal type="string">"DISCARD"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>DiscardCommand</name><argument_list>(<argument><expr><operator>(</operator><name>DiscardStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></argument>, <argument><expr><name>isTopLevel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_CreateEventTrigStmt</name></expr>:</case>
			<comment type="block">/* no event triggers on event triggers */</comment>
			<expr_stmt><expr><call><name>CreateEventTrigger</name><argument_list>(<argument><expr><operator>(</operator><name>CreateEventTrigStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_AlterEventTrigStmt</name></expr>:</case>
			<comment type="block">/* no event triggers on event triggers */</comment>
			<expr_stmt><expr><call><name>AlterEventTrigger</name><argument_list>(<argument><expr><operator>(</operator><name>AlterEventTrigStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

			<comment type="block">/*
			 * ******************************** ROLE statements ****
			 */</comment>
		<case>case <expr><name>T_CreateRoleStmt</name></expr>:</case>
			<comment type="block">/* no event triggers for global objects */</comment>
			<expr_stmt><expr><call><name>CreateRole</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><operator>(</operator><name>CreateRoleStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_AlterRoleStmt</name></expr>:</case>
			<comment type="block">/* no event triggers for global objects */</comment>
			<expr_stmt><expr><call><name>AlterRole</name><argument_list>(<argument><expr><operator>(</operator><name>AlterRoleStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_AlterRoleSetStmt</name></expr>:</case>
			<comment type="block">/* no event triggers for global objects */</comment>
			<expr_stmt><expr><call><name>AlterRoleSet</name><argument_list>(<argument><expr><operator>(</operator><name>AlterRoleSetStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_DropRoleStmt</name></expr>:</case>
			<comment type="block">/* no event triggers for global objects */</comment>
			<expr_stmt><expr><call><name>DropRole</name><argument_list>(<argument><expr><operator>(</operator><name>DropRoleStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_ReassignOwnedStmt</name></expr>:</case>
			<comment type="block">/* no event triggers for global objects */</comment>
			<expr_stmt><expr><call><name>ReassignOwnedObjects</name><argument_list>(<argument><expr><operator>(</operator><name>ReassignOwnedStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_LockStmt</name></expr>:</case>

			<comment type="block">/*
			 * Since the lock would just get dropped immediately, LOCK TABLE
			 * outside a transaction block is presumed to be user error.
			 */</comment>
			<expr_stmt><expr><call><name>RequireTransactionBlock</name><argument_list>(<argument><expr><name>isTopLevel</name></expr></argument>, <argument><expr><literal type="string">"LOCK TABLE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* forbidden in parallel mode due to CommandIsReadOnly */</comment>
			<expr_stmt><expr><call><name>LockTableCommand</name><argument_list>(<argument><expr><operator>(</operator><name>LockStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_ConstraintsSetStmt</name></expr>:</case>
			<expr_stmt><expr><call><name>WarnNoTransactionBlock</name><argument_list>(<argument><expr><name>isTopLevel</name></expr></argument>, <argument><expr><literal type="string">"SET CONSTRAINTS"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>AfterTriggerSetState</name><argument_list>(<argument><expr><operator>(</operator><name>ConstraintsSetStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_CheckPointStmt</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>superuser</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INSUFFICIENT_PRIVILEGE</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"must be superuser to do CHECKPOINT"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<comment type="block">/*
			 * You might think we should have a PreventCommandDuringRecovery()
			 * here, but we interpret a CHECKPOINT command during recovery as
			 * a request for a restartpoint instead. We allow this since it
			 * can be a useful way of reducing switchover time when using
			 * various forms of replication.
			 */</comment>
			<expr_stmt><expr><call><name>RequestCheckpoint</name><argument_list>(<argument><expr><name>CHECKPOINT_IMMEDIATE</name> <operator>|</operator> <name>CHECKPOINT_WAIT</name> <operator>|</operator>
							  <operator>(</operator><ternary><condition><expr><call><name>RecoveryInProgress</name><argument_list>()</argument_list></call></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><name>CHECKPOINT_FORCE</name></expr></else></ternary><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_ReindexStmt</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>ReindexStmt</name> <modifier>*</modifier></type><name>stmt</name> <init>= <expr><operator>(</operator><name>ReindexStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></init></decl>;</decl_stmt>

				<comment type="block">/* we choose to allow this during "read only" transactions */</comment>
				<expr_stmt><expr><call><name>PreventCommandDuringRecovery</name><argument_list>(<argument><expr><literal type="string">"REINDEX"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<comment type="block">/* forbidden in parallel mode due to CommandIsReadOnly */</comment>
				<switch>switch <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>kind</name></name></expr>)</condition>
				<block>{<block_content>
					<case>case <expr><name>REINDEX_OBJECT_INDEX</name></expr>:</case>
						<expr_stmt><expr><call><name>ReindexIndex</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>relation</name></name></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>options</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<break>break;</break>
					<case>case <expr><name>REINDEX_OBJECT_TABLE</name></expr>:</case>
						<expr_stmt><expr><call><name>ReindexTable</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>relation</name></name></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>options</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<break>break;</break>
					<case>case <expr><name>REINDEX_OBJECT_SCHEMA</name></expr>:</case>
					<case>case <expr><name>REINDEX_OBJECT_SYSTEM</name></expr>:</case>
					<case>case <expr><name>REINDEX_OBJECT_DATABASE</name></expr>:</case>

						<comment type="block">/*
						 * This cannot run inside a user transaction block; if
						 * we were inside a transaction, then its commit- and
						 * start-transaction-command calls would not have the
						 * intended effect!
						 */</comment>
						<expr_stmt><expr><call><name>PreventInTransactionBlock</name><argument_list>(<argument><expr><name>isTopLevel</name></expr></argument>,
												  <argument><expr><ternary><condition><expr><operator>(</operator><name><name>stmt</name><operator>-&gt;</operator><name>kind</name></name> <operator>==</operator> <name>REINDEX_OBJECT_SCHEMA</name><operator>)</operator></expr> ?</condition><then> <expr><literal type="string">"REINDEX SCHEMA"</literal></expr> </then><else>:
												  <expr><ternary><condition><expr><operator>(</operator><name><name>stmt</name><operator>-&gt;</operator><name>kind</name></name> <operator>==</operator> <name>REINDEX_OBJECT_SYSTEM</name><operator>)</operator></expr> ?</condition><then> <expr><literal type="string">"REINDEX SYSTEM"</literal></expr> </then><else>:
												  <expr><literal type="string">"REINDEX DATABASE"</literal></expr></else></ternary></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><call><name>ReindexMultipleTables</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>kind</name></name></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>options</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<break>break;</break>
					<default>default:</default>
						<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized object type: %d"</literal></expr></argument>,
							 <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name><name>stmt</name><operator>-&gt;</operator><name>kind</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<break>break;</break>
				</block_content>}</block></switch>
			</block_content>}</block>
			<break>break;</break>

			<comment type="block">/*
			 * The following statements are supported by Event Triggers only
			 * in some cases, so we "fast path" them in the other cases.
			 */</comment>

		<case>case <expr><name>T_GrantStmt</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>GrantStmt</name>  <modifier>*</modifier></type><name>stmt</name> <init>= <expr><operator>(</operator><name>GrantStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></init></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><call><name>EventTriggerSupportsObjectType</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>objtype</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ProcessUtilitySlow</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>pstmt</name></expr></argument>, <argument><expr><name>queryString</name></expr></argument>,
									   <argument><expr><name>context</name></expr></argument>, <argument><expr><name>params</name></expr></argument>, <argument><expr><name>queryEnv</name></expr></argument>,
									   <argument><expr><name>dest</name></expr></argument>, <argument><expr><name>completionTag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ExecuteGrantStmt</name><argument_list>(<argument><expr><name>stmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
			</block_content>}</block>
			<break>break;</break>

		<case>case <expr><name>T_DropStmt</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>DropStmt</name>   <modifier>*</modifier></type><name>stmt</name> <init>= <expr><operator>(</operator><name>DropStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></init></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><call><name>EventTriggerSupportsObjectType</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>removeType</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ProcessUtilitySlow</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>pstmt</name></expr></argument>, <argument><expr><name>queryString</name></expr></argument>,
									   <argument><expr><name>context</name></expr></argument>, <argument><expr><name>params</name></expr></argument>, <argument><expr><name>queryEnv</name></expr></argument>,
									   <argument><expr><name>dest</name></expr></argument>, <argument><expr><name>completionTag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ExecDropStmt</name><argument_list>(<argument><expr><name>stmt</name></expr></argument>, <argument><expr><name>isTopLevel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
			</block_content>}</block>
			<break>break;</break>

		<case>case <expr><name>T_RenameStmt</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>RenameStmt</name> <modifier>*</modifier></type><name>stmt</name> <init>= <expr><operator>(</operator><name>RenameStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></init></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><call><name>EventTriggerSupportsObjectType</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>renameType</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ProcessUtilitySlow</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>pstmt</name></expr></argument>, <argument><expr><name>queryString</name></expr></argument>,
									   <argument><expr><name>context</name></expr></argument>, <argument><expr><name>params</name></expr></argument>, <argument><expr><name>queryEnv</name></expr></argument>,
									   <argument><expr><name>dest</name></expr></argument>, <argument><expr><name>completionTag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ExecRenameStmt</name><argument_list>(<argument><expr><name>stmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
			</block_content>}</block>
			<break>break;</break>

		<case>case <expr><name>T_AlterObjectDependsStmt</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>AlterObjectDependsStmt</name> <modifier>*</modifier></type><name>stmt</name> <init>= <expr><operator>(</operator><name>AlterObjectDependsStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></init></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><call><name>EventTriggerSupportsObjectType</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>objectType</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ProcessUtilitySlow</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>pstmt</name></expr></argument>, <argument><expr><name>queryString</name></expr></argument>,
									   <argument><expr><name>context</name></expr></argument>, <argument><expr><name>params</name></expr></argument>, <argument><expr><name>queryEnv</name></expr></argument>,
									   <argument><expr><name>dest</name></expr></argument>, <argument><expr><name>completionTag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ExecAlterObjectDependsStmt</name><argument_list>(<argument><expr><name>stmt</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
			</block_content>}</block>
			<break>break;</break>

		<case>case <expr><name>T_AlterObjectSchemaStmt</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>AlterObjectSchemaStmt</name> <modifier>*</modifier></type><name>stmt</name> <init>= <expr><operator>(</operator><name>AlterObjectSchemaStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></init></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><call><name>EventTriggerSupportsObjectType</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>objectType</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ProcessUtilitySlow</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>pstmt</name></expr></argument>, <argument><expr><name>queryString</name></expr></argument>,
									   <argument><expr><name>context</name></expr></argument>, <argument><expr><name>params</name></expr></argument>, <argument><expr><name>queryEnv</name></expr></argument>,
									   <argument><expr><name>dest</name></expr></argument>, <argument><expr><name>completionTag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ExecAlterObjectSchemaStmt</name><argument_list>(<argument><expr><name>stmt</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
			</block_content>}</block>
			<break>break;</break>

		<case>case <expr><name>T_AlterOwnerStmt</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>AlterOwnerStmt</name> <modifier>*</modifier></type><name>stmt</name> <init>= <expr><operator>(</operator><name>AlterOwnerStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></init></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><call><name>EventTriggerSupportsObjectType</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>objectType</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ProcessUtilitySlow</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>pstmt</name></expr></argument>, <argument><expr><name>queryString</name></expr></argument>,
									   <argument><expr><name>context</name></expr></argument>, <argument><expr><name>params</name></expr></argument>, <argument><expr><name>queryEnv</name></expr></argument>,
									   <argument><expr><name>dest</name></expr></argument>, <argument><expr><name>completionTag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ExecAlterOwnerStmt</name><argument_list>(<argument><expr><name>stmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
			</block_content>}</block>
			<break>break;</break>

		<case>case <expr><name>T_CommentStmt</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>CommentStmt</name> <modifier>*</modifier></type><name>stmt</name> <init>= <expr><operator>(</operator><name>CommentStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></init></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><call><name>EventTriggerSupportsObjectType</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>objtype</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ProcessUtilitySlow</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>pstmt</name></expr></argument>, <argument><expr><name>queryString</name></expr></argument>,
									   <argument><expr><name>context</name></expr></argument>, <argument><expr><name>params</name></expr></argument>, <argument><expr><name>queryEnv</name></expr></argument>,
									   <argument><expr><name>dest</name></expr></argument>, <argument><expr><name>completionTag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>CommentObject</name><argument_list>(<argument><expr><name>stmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
				<break>break;</break>
			</block_content>}</block>

		<case>case <expr><name>T_SecLabelStmt</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>SecLabelStmt</name> <modifier>*</modifier></type><name>stmt</name> <init>= <expr><operator>(</operator><name>SecLabelStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></init></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><call><name>EventTriggerSupportsObjectType</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>objtype</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ProcessUtilitySlow</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>pstmt</name></expr></argument>, <argument><expr><name>queryString</name></expr></argument>,
									   <argument><expr><name>context</name></expr></argument>, <argument><expr><name>params</name></expr></argument>, <argument><expr><name>queryEnv</name></expr></argument>,
									   <argument><expr><name>dest</name></expr></argument>, <argument><expr><name>completionTag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ExecSecLabelStmt</name><argument_list>(<argument><expr><name>stmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
				<break>break;</break>
			</block_content>}</block>

		<default>default:</default>
			<comment type="block">/* All other statement types have event trigger support */</comment>
			<expr_stmt><expr><call><name>ProcessUtilitySlow</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>pstmt</name></expr></argument>, <argument><expr><name>queryString</name></expr></argument>,
							   <argument><expr><name>context</name></expr></argument>, <argument><expr><name>params</name></expr></argument>, <argument><expr><name>queryEnv</name></expr></argument>,
							   <argument><expr><name>dest</name></expr></argument>, <argument><expr><name>completionTag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
	</block_content>}</block></switch>

	<expr_stmt><expr><call><name>free_parsestate</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Make effects of commands visible, for instance so that
	 * PreCommit_on_commit_actions() can see them (see for example bug
	 * #15631).
	 */</comment>
	<expr_stmt><expr><call><name>CommandCounterIncrement</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * The "Slow" variant of ProcessUtility should only receive statements
 * supported by the event triggers facility.  Therefore, we always
 * perform the trigger support calls if the context allows it.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ProcessUtilitySlow</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>,
				   <parameter><decl><type><name>PlannedStmt</name> <modifier>*</modifier></type><name>pstmt</name></decl></parameter>,
				   <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>queryString</name></decl></parameter>,
				   <parameter><decl><type><name>ProcessUtilityContext</name></type> <name>context</name></decl></parameter>,
				   <parameter><decl><type><name>ParamListInfo</name></type> <name>params</name></decl></parameter>,
				   <parameter><decl><type><name>QueryEnvironment</name> <modifier>*</modifier></type><name>queryEnv</name></decl></parameter>,
				   <parameter><decl><type><name>DestReceiver</name> <modifier>*</modifier></type><name>dest</name></decl></parameter>,
				   <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>completionTag</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>parsetree</name> <init>= <expr><name><name>pstmt</name><operator>-&gt;</operator><name>utilityStmt</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>isTopLevel</name> <init>= <expr><operator>(</operator><name>context</name> <operator>==</operator> <name>PROCESS_UTILITY_TOPLEVEL</name><operator>)</operator></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>isCompleteQuery</name> <init>= <expr><operator>(</operator><name>context</name> <operator>&lt;=</operator> <name>PROCESS_UTILITY_QUERY</name><operator>)</operator></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>needCleanup</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>commandCollected</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ObjectAddress</name></type> <name>address</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ObjectAddress</name></type> <name>secondaryObject</name> <init>= <expr><name>InvalidObjectAddress</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* All event trigger calls are done only when isCompleteQuery is true */</comment>
	<expr_stmt><expr><name>needCleanup</name> <operator>=</operator> <name>isCompleteQuery</name> <operator>&amp;&amp;</operator> <call><name>EventTriggerBeginCompleteQuery</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* PG_TRY block is to ensure we call EventTriggerEndCompleteQuery */</comment>
	<expr_stmt><expr><call><name>PG_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>isCompleteQuery</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>EventTriggerDDLCommandStart</name><argument_list>(<argument><expr><name>parsetree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<switch>switch <condition>(<expr><call><name>nodeTag</name><argument_list>(<argument><expr><name>parsetree</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
				<comment type="block">/*
				 * relation and attribute manipulation
				 */</comment>
			<case>case <expr><name>T_CreateSchemaStmt</name></expr>:</case>
				<expr_stmt><expr><call><name>CreateSchemaCommand</name><argument_list>(<argument><expr><operator>(</operator><name>CreateSchemaStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></argument>,
									<argument><expr><name>queryString</name></expr></argument>,
									<argument><expr><name><name>pstmt</name><operator>-&gt;</operator><name>stmt_location</name></name></expr></argument>,
									<argument><expr><name><name>pstmt</name><operator>-&gt;</operator><name>stmt_len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/*
				 * EventTriggerCollectSimpleCommand called by
				 * CreateSchemaCommand
				 */</comment>
				<expr_stmt><expr><name>commandCollected</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><name>T_CreateStmt</name></expr>:</case>
			<case>case <expr><name>T_CreateForeignTableStmt</name></expr>:</case>
				<block>{<block_content>
					<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>stmts</name></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>

					<comment type="block">/* Run parse analysis ... */</comment>
					<expr_stmt><expr><name>stmts</name> <operator>=</operator> <call><name>transformCreateStmt</name><argument_list>(<argument><expr><operator>(</operator><name>CreateStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></argument>,
												<argument><expr><name>queryString</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<comment type="block">/* ... and do it */</comment>
					<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>stmts</argument>)</argument_list></macro>
					<block>{<block_content>
						<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>stmt</name> <init>= <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

						<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>stmt</name></expr></argument>, <argument><expr><name>CreateStmt</name></expr></argument>)</argument_list></call></expr>)</condition>
						<block>{<block_content>
							<decl_stmt><decl><type><name>Datum</name></type>		<name>toast_options</name></decl>;</decl_stmt>
							<decl_stmt><decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name><name>validnsps</name><index>[]</index></name> <init>= <expr><name>HEAP_RELOPT_NAMESPACES</name></expr></init></decl>;</decl_stmt>

							<comment type="block">/* Create the table itself */</comment>
							<expr_stmt><expr><name>address</name> <operator>=</operator> <call><name>DefineRelation</name><argument_list>(<argument><expr><operator>(</operator><name>CreateStmt</name> <operator>*</operator><operator>)</operator> <name>stmt</name></expr></argument>,
													 <argument><expr><name>RELKIND_RELATION</name></expr></argument>,
													 <argument><expr><name>InvalidOid</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
													 <argument><expr><name>queryString</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							<expr_stmt><expr><call><name>EventTriggerCollectSimpleCommand</name><argument_list>(<argument><expr><name>address</name></expr></argument>,
															 <argument><expr><name>secondaryObject</name></expr></argument>,
															 <argument><expr><name>stmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

							<comment type="block">/*
							 * Let NewRelationCreateToastTable decide if this
							 * one needs a secondary relation too.
							 */</comment>
							<expr_stmt><expr><call><name>CommandCounterIncrement</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

							<comment type="block">/*
							 * parse and validate reloptions for the toast
							 * table
							 */</comment>
							<expr_stmt><expr><name>toast_options</name> <operator>=</operator> <call><name>transformRelOptions</name><argument_list>(<argument><expr><operator>(</operator><name>Datum</name><operator>)</operator> <literal type="number">0</literal></expr></argument>,
																<argument><expr><operator>(</operator><operator>(</operator><name>CreateStmt</name> <operator>*</operator><operator>)</operator> <name>stmt</name><operator>)</operator><operator>-&gt;</operator><name>options</name></expr></argument>,
																<argument><expr><literal type="string">"toast"</literal></expr></argument>,
																<argument><expr><name>validnsps</name></expr></argument>,
																<argument><expr><name>true</name></expr></argument>,
																<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>heap_reloptions</name><argument_list>(<argument><expr><name>RELKIND_TOASTVALUE</name></expr></argument>,
												   <argument><expr><name>toast_options</name></expr></argument>,
												   <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

							<expr_stmt><expr><call><name>NewRelationCreateToastTable</name><argument_list>(<argument><expr><name><name>address</name><operator>.</operator><name>objectId</name></name></expr></argument>,
														<argument><expr><name>toast_options</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						</block_content>}</block></if>
						<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>stmt</name></expr></argument>, <argument><expr><name>CreateForeignTableStmt</name></expr></argument>)</argument_list></call></expr>)</condition>
						<block>{<block_content>
							<comment type="block">/* Create the table itself */</comment>
							<expr_stmt><expr><name>address</name> <operator>=</operator> <call><name>DefineRelation</name><argument_list>(<argument><expr><operator>(</operator><name>CreateStmt</name> <operator>*</operator><operator>)</operator> <name>stmt</name></expr></argument>,
													 <argument><expr><name>RELKIND_FOREIGN_TABLE</name></expr></argument>,
													 <argument><expr><name>InvalidOid</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
													 <argument><expr><name>queryString</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							<expr_stmt><expr><call><name>CreateForeignTable</name><argument_list>(<argument><expr><operator>(</operator><name>CreateForeignTableStmt</name> <operator>*</operator><operator>)</operator> <name>stmt</name></expr></argument>,
											   <argument><expr><name><name>address</name><operator>.</operator><name>objectId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							<expr_stmt><expr><call><name>EventTriggerCollectSimpleCommand</name><argument_list>(<argument><expr><name>address</name></expr></argument>,
															 <argument><expr><name>secondaryObject</name></expr></argument>,
															 <argument><expr><name>stmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						</block_content>}</block></if>
						<else>else
						<block>{<block_content>
							<comment type="block">/*
							 * Recurse for anything else.  Note the recursive
							 * call will stash the objects so created into our
							 * event trigger context.
							 */</comment>
							<decl_stmt><decl><type><name>PlannedStmt</name> <modifier>*</modifier></type><name>wrapper</name></decl>;</decl_stmt>

							<expr_stmt><expr><name>wrapper</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>PlannedStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							<expr_stmt><expr><name><name>wrapper</name><operator>-&gt;</operator><name>commandType</name></name> <operator>=</operator> <name>CMD_UTILITY</name></expr>;</expr_stmt>
							<expr_stmt><expr><name><name>wrapper</name><operator>-&gt;</operator><name>canSetTag</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
							<expr_stmt><expr><name><name>wrapper</name><operator>-&gt;</operator><name>utilityStmt</name></name> <operator>=</operator> <name>stmt</name></expr>;</expr_stmt>
							<expr_stmt><expr><name><name>wrapper</name><operator>-&gt;</operator><name>stmt_location</name></name> <operator>=</operator> <name><name>pstmt</name><operator>-&gt;</operator><name>stmt_location</name></name></expr>;</expr_stmt>
							<expr_stmt><expr><name><name>wrapper</name><operator>-&gt;</operator><name>stmt_len</name></name> <operator>=</operator> <name><name>pstmt</name><operator>-&gt;</operator><name>stmt_len</name></name></expr>;</expr_stmt>

							<expr_stmt><expr><call><name>ProcessUtility</name><argument_list>(<argument><expr><name>wrapper</name></expr></argument>,
										   <argument><expr><name>queryString</name></expr></argument>,
										   <argument><expr><name>PROCESS_UTILITY_SUBCOMMAND</name></expr></argument>,
										   <argument><expr><name>params</name></expr></argument>,
										   <argument><expr><name>NULL</name></expr></argument>,
										   <argument><expr><name>None_Receiver</name></expr></argument>,
										   <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						</block_content>}</block></else></if_stmt>

						<comment type="block">/* Need CCI between commands */</comment>
						<if_stmt><if>if <condition>(<expr><call><name>lnext</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
							<expr_stmt><expr><call><name>CommandCounterIncrement</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
					</block_content>}</block>

					<comment type="block">/*
					 * The multiple commands generated here are stashed
					 * individually, so disable collection below.
					 */</comment>
					<expr_stmt><expr><name>commandCollected</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				</block_content>}</block>
				<break>break;</break>

			<case>case <expr><name>T_AlterTableStmt</name></expr>:</case>
				<block>{<block_content>
					<decl_stmt><decl><type><name>AlterTableStmt</name> <modifier>*</modifier></type><name>atstmt</name> <init>= <expr><operator>(</operator><name>AlterTableStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></init></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>Oid</name></type>			<name>relid</name></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>stmts</name></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>LOCKMODE</name></type>	<name>lockmode</name></decl>;</decl_stmt>

					<comment type="block">/*
					 * Figure out lock mode, and acquire lock.  This also does
					 * basic permissions checks, so that we won't wait for a
					 * lock on (for example) a relation on which we have no
					 * permissions.
					 */</comment>
					<expr_stmt><expr><name>lockmode</name> <operator>=</operator> <call><name>AlterTableGetLockLevel</name><argument_list>(<argument><expr><name><name>atstmt</name><operator>-&gt;</operator><name>cmds</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>relid</name> <operator>=</operator> <call><name>AlterTableLookupRelation</name><argument_list>(<argument><expr><name>atstmt</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr>)</condition>
					<block>{<block_content>
						<comment type="block">/* Run parse analysis ... */</comment>
						<expr_stmt><expr><name>stmts</name> <operator>=</operator> <call><name>transformAlterTableStmt</name><argument_list>(<argument><expr><name>relid</name></expr></argument>, <argument><expr><name>atstmt</name></expr></argument>,
														<argument><expr><name>queryString</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

						<comment type="block">/* ... ensure we have an event trigger context ... */</comment>
						<expr_stmt><expr><call><name>EventTriggerAlterTableStart</name><argument_list>(<argument><expr><name>parsetree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><call><name>EventTriggerAlterTableRelid</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

						<comment type="block">/* ... and do it */</comment>
						<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>stmts</argument>)</argument_list></macro>
						<block>{<block_content>
							<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>stmt</name> <init>= <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

							<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>stmt</name></expr></argument>, <argument><expr><name>AlterTableStmt</name></expr></argument>)</argument_list></call></expr>)</condition>
							<block>{<block_content>
								<comment type="block">/* Do the table alteration proper */</comment>
								<expr_stmt><expr><call><name>AlterTable</name><argument_list>(<argument><expr><name>relid</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>,
										   <argument><expr><operator>(</operator><name>AlterTableStmt</name> <operator>*</operator><operator>)</operator> <name>stmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							</block_content>}</block></if>
							<else>else
							<block>{<block_content>
								<comment type="block">/*
								 * Recurse for anything else.  If we need to
								 * do so, "close" the current complex-command
								 * set, and start a new one at the bottom;
								 * this is needed to ensure the ordering of
								 * queued commands is consistent with the way
								 * they are executed here.
								 */</comment>
								<decl_stmt><decl><type><name>PlannedStmt</name> <modifier>*</modifier></type><name>wrapper</name></decl>;</decl_stmt>

								<expr_stmt><expr><call><name>EventTriggerAlterTableEnd</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
								<expr_stmt><expr><name>wrapper</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>PlannedStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
								<expr_stmt><expr><name><name>wrapper</name><operator>-&gt;</operator><name>commandType</name></name> <operator>=</operator> <name>CMD_UTILITY</name></expr>;</expr_stmt>
								<expr_stmt><expr><name><name>wrapper</name><operator>-&gt;</operator><name>canSetTag</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
								<expr_stmt><expr><name><name>wrapper</name><operator>-&gt;</operator><name>utilityStmt</name></name> <operator>=</operator> <name>stmt</name></expr>;</expr_stmt>
								<expr_stmt><expr><name><name>wrapper</name><operator>-&gt;</operator><name>stmt_location</name></name> <operator>=</operator> <name><name>pstmt</name><operator>-&gt;</operator><name>stmt_location</name></name></expr>;</expr_stmt>
								<expr_stmt><expr><name><name>wrapper</name><operator>-&gt;</operator><name>stmt_len</name></name> <operator>=</operator> <name><name>pstmt</name><operator>-&gt;</operator><name>stmt_len</name></name></expr>;</expr_stmt>
								<expr_stmt><expr><call><name>ProcessUtility</name><argument_list>(<argument><expr><name>wrapper</name></expr></argument>,
											   <argument><expr><name>queryString</name></expr></argument>,
											   <argument><expr><name>PROCESS_UTILITY_SUBCOMMAND</name></expr></argument>,
											   <argument><expr><name>params</name></expr></argument>,
											   <argument><expr><name>NULL</name></expr></argument>,
											   <argument><expr><name>None_Receiver</name></expr></argument>,
											   <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
								<expr_stmt><expr><call><name>EventTriggerAlterTableStart</name><argument_list>(<argument><expr><name>parsetree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
								<expr_stmt><expr><call><name>EventTriggerAlterTableRelid</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							</block_content>}</block></else></if_stmt>

							<comment type="block">/* Need CCI between commands */</comment>
							<if_stmt><if>if <condition>(<expr><call><name>lnext</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
								<expr_stmt><expr><call><name>CommandCounterIncrement</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
						</block_content>}</block>

						<comment type="block">/* done */</comment>
						<expr_stmt><expr><call><name>EventTriggerAlterTableEnd</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block></if>
					<else>else<block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>NOTICE</name></expr></argument>,
								<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"relation \"%s\" does not exist, skipping"</literal></expr></argument>,
										<argument><expr><name><name>atstmt</name><operator>-&gt;</operator><name>relation</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
				</block_content>}</block>

				<comment type="block">/* ALTER TABLE stashes commands internally */</comment>
				<expr_stmt><expr><name>commandCollected</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><name>T_AlterDomainStmt</name></expr>:</case>
				<block>{<block_content>
					<decl_stmt><decl><type><name>AlterDomainStmt</name> <modifier>*</modifier></type><name>stmt</name> <init>= <expr><operator>(</operator><name>AlterDomainStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></init></decl>;</decl_stmt>

					<comment type="block">/*
					 * Some or all of these functions are recursive to cover
					 * inherited things, so permission checks are done there.
					 */</comment>
					<switch>switch <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>subtype</name></name></expr>)</condition>
					<block>{<block_content>
						<case>case <expr><literal type="char">'T'</literal></expr>:</case>	<comment type="block">/* ALTER DOMAIN DEFAULT */</comment>

							<comment type="block">/*
							 * Recursively alter column default for table and,
							 * if requested, for descendants
							 */</comment>
							<expr_stmt><expr><name>address</name> <operator>=</operator>
								<call><name>AlterDomainDefault</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>typeName</name></name></expr></argument>,
												   <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>def</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							<break>break;</break>
						<case>case <expr><literal type="char">'N'</literal></expr>:</case>	<comment type="block">/* ALTER DOMAIN DROP NOT NULL */</comment>
							<expr_stmt><expr><name>address</name> <operator>=</operator>
								<call><name>AlterDomainNotNull</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>typeName</name></name></expr></argument>,
												   <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							<break>break;</break>
						<case>case <expr><literal type="char">'O'</literal></expr>:</case>	<comment type="block">/* ALTER DOMAIN SET NOT NULL */</comment>
							<expr_stmt><expr><name>address</name> <operator>=</operator>
								<call><name>AlterDomainNotNull</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>typeName</name></name></expr></argument>,
												   <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							<break>break;</break>
						<case>case <expr><literal type="char">'C'</literal></expr>:</case>	<comment type="block">/* ADD CONSTRAINT */</comment>
							<expr_stmt><expr><name>address</name> <operator>=</operator>
								<call><name>AlterDomainAddConstraint</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>typeName</name></name></expr></argument>,
														 <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>def</name></name></expr></argument>,
														 <argument><expr><operator>&amp;</operator><name>secondaryObject</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							<break>break;</break>
						<case>case <expr><literal type="char">'X'</literal></expr>:</case>	<comment type="block">/* DROP CONSTRAINT */</comment>
							<expr_stmt><expr><name>address</name> <operator>=</operator>
								<call><name>AlterDomainDropConstraint</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>typeName</name></name></expr></argument>,
														  <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>name</name></name></expr></argument>,
														  <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>behavior</name></name></expr></argument>,
														  <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>missing_ok</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							<break>break;</break>
						<case>case <expr><literal type="char">'V'</literal></expr>:</case>	<comment type="block">/* VALIDATE CONSTRAINT */</comment>
							<expr_stmt><expr><name>address</name> <operator>=</operator>
								<call><name>AlterDomainValidateConstraint</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>typeName</name></name></expr></argument>,
															  <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							<break>break;</break>
						<default>default:</default>	<comment type="block">/* oops */</comment>
							<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized alter domain type: %d"</literal></expr></argument>,
								 <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name><name>stmt</name><operator>-&gt;</operator><name>subtype</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							<break>break;</break>
					</block_content>}</block></switch>
				</block_content>}</block>
				<break>break;</break>

				<comment type="block">/*
				 * ************* object creation / destruction **************
				 */</comment>
			<case>case <expr><name>T_DefineStmt</name></expr>:</case>
				<block>{<block_content>
					<decl_stmt><decl><type><name>DefineStmt</name> <modifier>*</modifier></type><name>stmt</name> <init>= <expr><operator>(</operator><name>DefineStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></init></decl>;</decl_stmt>

					<switch>switch <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>kind</name></name></expr>)</condition>
					<block>{<block_content>
						<case>case <expr><name>OBJECT_AGGREGATE</name></expr>:</case>
							<expr_stmt><expr><name>address</name> <operator>=</operator>
								<call><name>DefineAggregate</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>defnames</name></name></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>args</name></name></expr></argument>,
												<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>oldstyle</name></name></expr></argument>,
												<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>definition</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							<break>break;</break>
						<case>case <expr><name>OBJECT_OPERATOR</name></expr>:</case>
							<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>args</name></name> <operator>==</operator> <name>NIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							<expr_stmt><expr><name>address</name> <operator>=</operator> <call><name>DefineOperator</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>defnames</name></name></expr></argument>,
													 <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>definition</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							<break>break;</break>
						<case>case <expr><name>OBJECT_TYPE</name></expr>:</case>
							<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>args</name></name> <operator>==</operator> <name>NIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							<expr_stmt><expr><name>address</name> <operator>=</operator> <call><name>DefineType</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>,
												 <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>defnames</name></name></expr></argument>,
												 <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>definition</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							<break>break;</break>
						<case>case <expr><name>OBJECT_TSPARSER</name></expr>:</case>
							<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>args</name></name> <operator>==</operator> <name>NIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							<expr_stmt><expr><name>address</name> <operator>=</operator> <call><name>DefineTSParser</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>defnames</name></name></expr></argument>,
													 <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>definition</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							<break>break;</break>
						<case>case <expr><name>OBJECT_TSDICTIONARY</name></expr>:</case>
							<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>args</name></name> <operator>==</operator> <name>NIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							<expr_stmt><expr><name>address</name> <operator>=</operator> <call><name>DefineTSDictionary</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>defnames</name></name></expr></argument>,
														 <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>definition</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							<break>break;</break>
						<case>case <expr><name>OBJECT_TSTEMPLATE</name></expr>:</case>
							<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>args</name></name> <operator>==</operator> <name>NIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							<expr_stmt><expr><name>address</name> <operator>=</operator> <call><name>DefineTSTemplate</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>defnames</name></name></expr></argument>,
													   <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>definition</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							<break>break;</break>
						<case>case <expr><name>OBJECT_TSCONFIGURATION</name></expr>:</case>
							<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>args</name></name> <operator>==</operator> <name>NIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							<expr_stmt><expr><name>address</name> <operator>=</operator> <call><name>DefineTSConfiguration</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>defnames</name></name></expr></argument>,
															<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>definition</name></name></expr></argument>,
															<argument><expr><operator>&amp;</operator><name>secondaryObject</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							<break>break;</break>
						<case>case <expr><name>OBJECT_COLLATION</name></expr>:</case>
							<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>args</name></name> <operator>==</operator> <name>NIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							<expr_stmt><expr><name>address</name> <operator>=</operator> <call><name>DefineCollation</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>,
													  <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>defnames</name></name></expr></argument>,
													  <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>definition</name></name></expr></argument>,
													  <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>if_not_exists</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							<break>break;</break>
						<default>default:</default>
							<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized define stmt type: %d"</literal></expr></argument>,
								 <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name><name>stmt</name><operator>-&gt;</operator><name>kind</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							<break>break;</break>
					</block_content>}</block></switch>
				</block_content>}</block>
				<break>break;</break>

			<case>case <expr><name>T_IndexStmt</name></expr>:</case>	<comment type="block">/* CREATE INDEX */</comment>
				<block>{<block_content>
					<decl_stmt><decl><type><name>IndexStmt</name>  <modifier>*</modifier></type><name>stmt</name> <init>= <expr><operator>(</operator><name>IndexStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></init></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>Oid</name></type>			<name>relid</name></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>LOCKMODE</name></type>	<name>lockmode</name></decl>;</decl_stmt>

					<if_stmt><if>if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>concurrent</name></name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>PreventInTransactionBlock</name><argument_list>(<argument><expr><name>isTopLevel</name></expr></argument>,
												  <argument><expr><literal type="string">"CREATE INDEX CONCURRENTLY"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

					<comment type="block">/* POLAR px */</comment>
					<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>polar_px_enable_btbuild_precheck</name><argument_list>(<argument><expr><name>isTopLevel</name></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>options</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<comment type="block">/*
					 * Look up the relation OID just once, right here at the
					 * beginning, so that we don't end up repeating the name
					 * lookup later and latching onto a different relation
					 * partway through.  To avoid lock upgrade hazards, it's
					 * important that we take the strongest lock that will
					 * eventually be needed here, so the lockmode calculation
					 * needs to match what DefineIndex() does.
					 */</comment>
					<expr_stmt><expr><name>lockmode</name> <operator>=</operator> <ternary><condition><expr><name><name>stmt</name><operator>-&gt;</operator><name>concurrent</name></name></expr> ?</condition><then> <expr><name>ShareUpdateExclusiveLock</name></expr>
						</then><else>: <expr><name>ShareLock</name></expr></else></ternary></expr>;</expr_stmt>
					<expr_stmt><expr><name>relid</name> <operator>=</operator>
						<call><name>RangeVarGetRelidExtended</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>relation</name></name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>,
												 <argument><expr><literal type="number">0</literal></expr></argument>,
												 <argument><expr><name>RangeVarCallbackOwnsRelation</name></expr></argument>,
												 <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<comment type="block">/*
					 * CREATE INDEX on partitioned tables (but not regular
					 * inherited tables) recurses to partitions, so we must
					 * acquire locks early to avoid deadlocks.
					 *
					 * We also take the opportunity to verify that all
					 * partitions are something we can put an index on, to
					 * avoid building some indexes only to fail later.
					 */</comment>
					<if_stmt><if>if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>relation</name><operator>-&gt;</operator><name>inh</name></name> <operator>&amp;&amp;</operator>
						<call><name>get_rel_relkind</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>RELKIND_PARTITIONED_TABLE</name></expr>)</condition>
					<block>{<block_content>
						<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
						<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>inheritors</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>

						<expr_stmt><expr><name>inheritors</name> <operator>=</operator> <call><name>find_all_inheritors</name><argument_list>(<argument><expr><name>relid</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>inheritors</argument>)</argument_list></macro>
						<block>{<block_content>
							<decl_stmt><decl><type><name>char</name></type>		<name>relkind</name> <init>= <expr><call><name>get_rel_relkind</name><argument_list>(<argument><expr><call><name>lfirst_oid</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

							<if_stmt><if>if <condition>(<expr><name>relkind</name> <operator>!=</operator> <name>RELKIND_RELATION</name> <operator>&amp;&amp;</operator>
								<name>relkind</name> <operator>!=</operator> <name>RELKIND_MATVIEW</name> <operator>&amp;&amp;</operator>
								<name>relkind</name> <operator>!=</operator> <name>RELKIND_PARTITIONED_TABLE</name> <operator>&amp;&amp;</operator>
								<name>relkind</name> <operator>!=</operator> <name>RELKIND_FOREIGN_TABLE</name></expr>)</condition><block type="pseudo"><block_content>
								<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unexpected relkind \"%c\" on partition \"%s\""</literal></expr></argument>,
									 <argument><expr><name>relkind</name></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>relation</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

							<if_stmt><if>if <condition>(<expr><name>relkind</name> <operator>==</operator> <name>RELKIND_FOREIGN_TABLE</name> <operator>&amp;&amp;</operator>
								<operator>(</operator><name><name>stmt</name><operator>-&gt;</operator><name>unique</name></name> <operator>||</operator> <name><name>stmt</name><operator>-&gt;</operator><name>primary</name></name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
								<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
										<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WRONG_OBJECT_TYPE</name></expr></argument>)</argument_list></call><operator>,</operator>
										 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot create unique index on partitioned table \"%s\""</literal></expr></argument>,
												<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>relation</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>)</argument_list></call><operator>,</operator>
										 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Table \"%s\" contains partitions that are foreign tables."</literal></expr></argument>,
												   <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>relation</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
						</block_content>}</block>
						<expr_stmt><expr><call><name>list_free</name><argument_list>(<argument><expr><name>inheritors</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block></if></if_stmt>

					<comment type="block">/* Run parse analysis ... */</comment>
					<expr_stmt><expr><name>stmt</name> <operator>=</operator> <call><name>transformIndexStmt</name><argument_list>(<argument><expr><name>relid</name></expr></argument>, <argument><expr><name>stmt</name></expr></argument>, <argument><expr><name>queryString</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<comment type="block">/* ... and do it */</comment>
					<expr_stmt><expr><call><name>EventTriggerAlterTableStart</name><argument_list>(<argument><expr><name>parsetree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>address</name> <operator>=</operator>
						<call><name>DefineIndex</name><argument_list>(<argument><expr><name>relid</name></expr></argument>,	<comment type="block">/* OID of heap relation */</comment>
									<argument><expr><name>stmt</name></expr></argument>,
									<argument><expr><name>InvalidOid</name></expr></argument>, <comment type="block">/* no predefined OID */</comment>
									<argument><expr><name>InvalidOid</name></expr></argument>, <comment type="block">/* no parent index */</comment>
									<argument><expr><name>InvalidOid</name></expr></argument>, <comment type="block">/* no parent constraint */</comment>
									<argument><expr><name>false</name></expr></argument>,	<comment type="block">/* is_alter_table */</comment>
									<argument><expr><name>true</name></expr></argument>,	<comment type="block">/* check_rights */</comment>
									<argument><expr><name>true</name></expr></argument>,	<comment type="block">/* check_not_in_use */</comment>
									<argument><expr><name>false</name></expr></argument>,	<comment type="block">/* skip_build */</comment>
									<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* quiet */</comment>

					<comment type="block">/*
					 * Add the CREATE INDEX node itself to stash right away;
					 * if there were any commands stashed in the ALTER TABLE
					 * code, we need them to appear after this one.
					 */</comment>
					<expr_stmt><expr><call><name>EventTriggerCollectSimpleCommand</name><argument_list>(<argument><expr><name>address</name></expr></argument>, <argument><expr><name>secondaryObject</name></expr></argument>,
													 <argument><expr><name>parsetree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>commandCollected</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>EventTriggerAlterTableEnd</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block>
				<break>break;</break>

			<case>case <expr><name>T_CreateExtensionStmt</name></expr>:</case>
				<expr_stmt><expr><name>address</name> <operator>=</operator> <call><name>CreateExtension</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><operator>(</operator><name>CreateExtensionStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><name>T_AlterExtensionStmt</name></expr>:</case>
				<expr_stmt><expr><name>address</name> <operator>=</operator> <call><name>ExecAlterExtensionStmt</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><operator>(</operator><name>AlterExtensionStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><name>T_AlterExtensionContentsStmt</name></expr>:</case>
				<expr_stmt><expr><name>address</name> <operator>=</operator> <call><name>ExecAlterExtensionContentsStmt</name><argument_list>(<argument><expr><operator>(</operator><name>AlterExtensionContentsStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></argument>,
														 <argument><expr><operator>&amp;</operator><name>secondaryObject</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><name>T_CreateFdwStmt</name></expr>:</case>
				<expr_stmt><expr><name>address</name> <operator>=</operator> <call><name>CreateForeignDataWrapper</name><argument_list>(<argument><expr><operator>(</operator><name>CreateFdwStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><name>T_AlterFdwStmt</name></expr>:</case>
				<expr_stmt><expr><name>address</name> <operator>=</operator> <call><name>AlterForeignDataWrapper</name><argument_list>(<argument><expr><operator>(</operator><name>AlterFdwStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><name>T_CreateForeignServerStmt</name></expr>:</case>
				<expr_stmt><expr><name>address</name> <operator>=</operator> <call><name>CreateForeignServer</name><argument_list>(<argument><expr><operator>(</operator><name>CreateForeignServerStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><name>T_AlterForeignServerStmt</name></expr>:</case>
				<expr_stmt><expr><name>address</name> <operator>=</operator> <call><name>AlterForeignServer</name><argument_list>(<argument><expr><operator>(</operator><name>AlterForeignServerStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><name>T_CreateUserMappingStmt</name></expr>:</case>
				<expr_stmt><expr><name>address</name> <operator>=</operator> <call><name>CreateUserMapping</name><argument_list>(<argument><expr><operator>(</operator><name>CreateUserMappingStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><name>T_AlterUserMappingStmt</name></expr>:</case>
				<expr_stmt><expr><name>address</name> <operator>=</operator> <call><name>AlterUserMapping</name><argument_list>(<argument><expr><operator>(</operator><name>AlterUserMappingStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><name>T_DropUserMappingStmt</name></expr>:</case>
				<expr_stmt><expr><call><name>RemoveUserMapping</name><argument_list>(<argument><expr><operator>(</operator><name>DropUserMappingStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<comment type="block">/* no commands stashed for DROP */</comment>
				<expr_stmt><expr><name>commandCollected</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><name>T_ImportForeignSchemaStmt</name></expr>:</case>
				<expr_stmt><expr><call><name>ImportForeignSchema</name><argument_list>(<argument><expr><operator>(</operator><name>ImportForeignSchemaStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<comment type="block">/* commands are stashed inside ImportForeignSchema */</comment>
				<expr_stmt><expr><name>commandCollected</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><name>T_CompositeTypeStmt</name></expr>:</case>	<comment type="block">/* CREATE TYPE (composite) */</comment>
				<block>{<block_content>
					<decl_stmt><decl><type><name>CompositeTypeStmt</name> <modifier>*</modifier></type><name>stmt</name> <init>= <expr><operator>(</operator><name>CompositeTypeStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></init></decl>;</decl_stmt>

					<expr_stmt><expr><name>address</name> <operator>=</operator> <call><name>DefineCompositeType</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>typevar</name></name></expr></argument>,
												  <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>coldeflist</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block>
				<break>break;</break>

			<case>case <expr><name>T_CreateEnumStmt</name></expr>:</case>	<comment type="block">/* CREATE TYPE AS ENUM */</comment>
				<expr_stmt><expr><name>address</name> <operator>=</operator> <call><name>DefineEnum</name><argument_list>(<argument><expr><operator>(</operator><name>CreateEnumStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><name>T_CreateRangeStmt</name></expr>:</case> <comment type="block">/* CREATE TYPE AS RANGE */</comment>
				<expr_stmt><expr><name>address</name> <operator>=</operator> <call><name>DefineRange</name><argument_list>(<argument><expr><operator>(</operator><name>CreateRangeStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><name>T_AlterEnumStmt</name></expr>:</case>	<comment type="block">/* ALTER TYPE (enum) */</comment>
				<expr_stmt><expr><name>address</name> <operator>=</operator> <call><name>AlterEnum</name><argument_list>(<argument><expr><operator>(</operator><name>AlterEnumStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></argument>, <argument><expr><name>isTopLevel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><name>T_ViewStmt</name></expr>:</case>	<comment type="block">/* CREATE VIEW */</comment>
				<expr_stmt><expr><call><name>EventTriggerAlterTableStart</name><argument_list>(<argument><expr><name>parsetree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>address</name> <operator>=</operator> <call><name>DefineView</name><argument_list>(<argument><expr><operator>(</operator><name>ViewStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></argument>, <argument><expr><name>queryString</name></expr></argument>,
									 <argument><expr><name><name>pstmt</name><operator>-&gt;</operator><name>stmt_location</name></name></expr></argument>, <argument><expr><name><name>pstmt</name><operator>-&gt;</operator><name>stmt_len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>EventTriggerCollectSimpleCommand</name><argument_list>(<argument><expr><name>address</name></expr></argument>, <argument><expr><name>secondaryObject</name></expr></argument>,
												 <argument><expr><name>parsetree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<comment type="block">/* stashed internally */</comment>
				<expr_stmt><expr><name>commandCollected</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>EventTriggerAlterTableEnd</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><name>T_CreateFunctionStmt</name></expr>:</case>	<comment type="block">/* CREATE FUNCTION */</comment>
				<expr_stmt><expr><name>address</name> <operator>=</operator> <call><name>CreateFunction</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><operator>(</operator><name>CreateFunctionStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><name>T_AlterFunctionStmt</name></expr>:</case>	<comment type="block">/* ALTER FUNCTION */</comment>
				<expr_stmt><expr><name>address</name> <operator>=</operator> <call><name>AlterFunction</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><operator>(</operator><name>AlterFunctionStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><name>T_RuleStmt</name></expr>:</case>	<comment type="block">/* CREATE RULE */</comment>
				<expr_stmt><expr><name>address</name> <operator>=</operator> <call><name>DefineRule</name><argument_list>(<argument><expr><operator>(</operator><name>RuleStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></argument>, <argument><expr><name>queryString</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><name>T_CreateSeqStmt</name></expr>:</case>
				<expr_stmt><expr><name>address</name> <operator>=</operator> <call><name>DefineSequence</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><operator>(</operator><name>CreateSeqStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><name>T_AlterSeqStmt</name></expr>:</case>
				<expr_stmt><expr><name>address</name> <operator>=</operator> <call><name>AlterSequence</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><operator>(</operator><name>AlterSeqStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><name>T_CreateTableAsStmt</name></expr>:</case>
				<expr_stmt><expr><name>address</name> <operator>=</operator> <call><name>ExecCreateTableAs</name><argument_list>(<argument><expr><operator>(</operator><name>CreateTableAsStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></argument>,
											<argument><expr><name>queryString</name></expr></argument>, <argument><expr><name>params</name></expr></argument>, <argument><expr><name>queryEnv</name></expr></argument>,
											<argument><expr><name>completionTag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><name>T_RefreshMatViewStmt</name></expr>:</case>

				<comment type="block">/*
				 * REFRESH CONCURRENTLY executes some DDL commands internally.
				 * Inhibit DDL command collection here to avoid those commands
				 * from showing up in the deparsed command queue.  The refresh
				 * command itself is queued, which is enough.
				 */</comment>
				<expr_stmt><expr><call><name>EventTriggerInhibitCommandCollection</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>PG_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<block>{<block_content>
					<expr_stmt><expr><name>address</name> <operator>=</operator> <call><name>ExecRefreshMatView</name><argument_list>(<argument><expr><operator>(</operator><name>RefreshMatViewStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></argument>,
												 <argument><expr><name>queryString</name></expr></argument>, <argument><expr><name>params</name></expr></argument>, <argument><expr><name>completionTag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block>
				<expr_stmt><expr><call><name>PG_CATCH</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<block>{<block_content>
					<expr_stmt><expr><call><name>EventTriggerUndoInhibitCommandCollection</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>PG_RE_THROW</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block>
				<expr_stmt><expr><call><name>PG_END_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>EventTriggerUndoInhibitCommandCollection</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><name>T_CreateTrigStmt</name></expr>:</case>
				<expr_stmt><expr><name>address</name> <operator>=</operator> <call><name>CreateTrigger</name><argument_list>(<argument><expr><operator>(</operator><name>CreateTrigStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></argument>,
										<argument><expr><name>queryString</name></expr></argument>, <argument><expr><name>InvalidOid</name></expr></argument>, <argument><expr><name>InvalidOid</name></expr></argument>,
										<argument><expr><name>InvalidOid</name></expr></argument>, <argument><expr><name>InvalidOid</name></expr></argument>, <argument><expr><name>InvalidOid</name></expr></argument>,
										<argument><expr><name>InvalidOid</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><name>T_CreatePLangStmt</name></expr>:</case>
				<expr_stmt><expr><name>address</name> <operator>=</operator> <call><name>CreateProceduralLanguage</name><argument_list>(<argument><expr><operator>(</operator><name>CreatePLangStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><name>T_CreateDomainStmt</name></expr>:</case>
				<expr_stmt><expr><name>address</name> <operator>=</operator> <call><name>DefineDomain</name><argument_list>(<argument><expr><operator>(</operator><name>CreateDomainStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><name>T_CreateConversionStmt</name></expr>:</case>
				<expr_stmt><expr><name>address</name> <operator>=</operator> <call><name>CreateConversionCommand</name><argument_list>(<argument><expr><operator>(</operator><name>CreateConversionStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><name>T_CreateCastStmt</name></expr>:</case>
				<expr_stmt><expr><name>address</name> <operator>=</operator> <call><name>CreateCast</name><argument_list>(<argument><expr><operator>(</operator><name>CreateCastStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><name>T_CreateOpClassStmt</name></expr>:</case>
				<expr_stmt><expr><call><name>DefineOpClass</name><argument_list>(<argument><expr><operator>(</operator><name>CreateOpClassStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<comment type="block">/* command is stashed in DefineOpClass */</comment>
				<expr_stmt><expr><name>commandCollected</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><name>T_CreateOpFamilyStmt</name></expr>:</case>
				<expr_stmt><expr><name>address</name> <operator>=</operator> <call><name>DefineOpFamily</name><argument_list>(<argument><expr><operator>(</operator><name>CreateOpFamilyStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><name>T_CreateTransformStmt</name></expr>:</case>
				<expr_stmt><expr><name>address</name> <operator>=</operator> <call><name>CreateTransform</name><argument_list>(<argument><expr><operator>(</operator><name>CreateTransformStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><name>T_AlterOpFamilyStmt</name></expr>:</case>
				<expr_stmt><expr><call><name>AlterOpFamily</name><argument_list>(<argument><expr><operator>(</operator><name>AlterOpFamilyStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<comment type="block">/* commands are stashed in AlterOpFamily */</comment>
				<expr_stmt><expr><name>commandCollected</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><name>T_AlterTSDictionaryStmt</name></expr>:</case>
				<expr_stmt><expr><name>address</name> <operator>=</operator> <call><name>AlterTSDictionary</name><argument_list>(<argument><expr><operator>(</operator><name>AlterTSDictionaryStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><name>T_AlterTSConfigurationStmt</name></expr>:</case>
				<expr_stmt><expr><call><name>AlterTSConfiguration</name><argument_list>(<argument><expr><operator>(</operator><name>AlterTSConfigurationStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/*
				 * Commands are stashed in MakeConfigurationMapping and
				 * DropConfigurationMapping, which are called from
				 * AlterTSConfiguration
				 */</comment>
				<expr_stmt><expr><name>commandCollected</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><name>T_AlterTableMoveAllStmt</name></expr>:</case>
				<expr_stmt><expr><call><name>AlterTableMoveAll</name><argument_list>(<argument><expr><operator>(</operator><name>AlterTableMoveAllStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<comment type="block">/* commands are stashed in AlterTableMoveAll */</comment>
				<expr_stmt><expr><name>commandCollected</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><name>T_DropStmt</name></expr>:</case>
				<expr_stmt><expr><call><name>ExecDropStmt</name><argument_list>(<argument><expr><operator>(</operator><name>DropStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></argument>, <argument><expr><name>isTopLevel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<comment type="block">/* no commands stashed for DROP */</comment>
				<expr_stmt><expr><name>commandCollected</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><name>T_RenameStmt</name></expr>:</case>
				<expr_stmt><expr><name>address</name> <operator>=</operator> <call><name>ExecRenameStmt</name><argument_list>(<argument><expr><operator>(</operator><name>RenameStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><name>T_AlterObjectDependsStmt</name></expr>:</case>
				<expr_stmt><expr><name>address</name> <operator>=</operator>
					<call><name>ExecAlterObjectDependsStmt</name><argument_list>(<argument><expr><operator>(</operator><name>AlterObjectDependsStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></argument>,
											   <argument><expr><operator>&amp;</operator><name>secondaryObject</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><name>T_AlterObjectSchemaStmt</name></expr>:</case>
				<expr_stmt><expr><name>address</name> <operator>=</operator>
					<call><name>ExecAlterObjectSchemaStmt</name><argument_list>(<argument><expr><operator>(</operator><name>AlterObjectSchemaStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></argument>,
											  <argument><expr><operator>&amp;</operator><name>secondaryObject</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><name>T_AlterOwnerStmt</name></expr>:</case>
				<expr_stmt><expr><name>address</name> <operator>=</operator> <call><name>ExecAlterOwnerStmt</name><argument_list>(<argument><expr><operator>(</operator><name>AlterOwnerStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><name>T_AlterOperatorStmt</name></expr>:</case>
				<expr_stmt><expr><name>address</name> <operator>=</operator> <call><name>AlterOperator</name><argument_list>(<argument><expr><operator>(</operator><name>AlterOperatorStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><name>T_CommentStmt</name></expr>:</case>
				<expr_stmt><expr><name>address</name> <operator>=</operator> <call><name>CommentObject</name><argument_list>(<argument><expr><operator>(</operator><name>CommentStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><name>T_GrantStmt</name></expr>:</case>
				<expr_stmt><expr><call><name>ExecuteGrantStmt</name><argument_list>(<argument><expr><operator>(</operator><name>GrantStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<comment type="block">/* commands are stashed in ExecGrantStmt_oids */</comment>
				<expr_stmt><expr><name>commandCollected</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><name>T_DropOwnedStmt</name></expr>:</case>
				<expr_stmt><expr><call><name>DropOwnedObjects</name><argument_list>(<argument><expr><operator>(</operator><name>DropOwnedStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<comment type="block">/* no commands stashed for DROP */</comment>
				<expr_stmt><expr><name>commandCollected</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><name>T_AlterDefaultPrivilegesStmt</name></expr>:</case>
				<expr_stmt><expr><call><name>ExecAlterDefaultPrivilegesStmt</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><operator>(</operator><name>AlterDefaultPrivilegesStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>EventTriggerCollectAlterDefPrivs</name><argument_list>(<argument><expr><operator>(</operator><name>AlterDefaultPrivilegesStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>commandCollected</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><name>T_CreatePolicyStmt</name></expr>:</case>	<comment type="block">/* CREATE POLICY */</comment>
				<expr_stmt><expr><name>address</name> <operator>=</operator> <call><name>CreatePolicy</name><argument_list>(<argument><expr><operator>(</operator><name>CreatePolicyStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><name>T_AlterPolicyStmt</name></expr>:</case> <comment type="block">/* ALTER POLICY */</comment>
				<expr_stmt><expr><name>address</name> <operator>=</operator> <call><name>AlterPolicy</name><argument_list>(<argument><expr><operator>(</operator><name>AlterPolicyStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><name>T_SecLabelStmt</name></expr>:</case>
				<expr_stmt><expr><name>address</name> <operator>=</operator> <call><name>ExecSecLabelStmt</name><argument_list>(<argument><expr><operator>(</operator><name>SecLabelStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><name>T_CreateAmStmt</name></expr>:</case>
				<expr_stmt><expr><name>address</name> <operator>=</operator> <call><name>CreateAccessMethod</name><argument_list>(<argument><expr><operator>(</operator><name>CreateAmStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><name>T_CreatePublicationStmt</name></expr>:</case>
				<expr_stmt><expr><name>address</name> <operator>=</operator> <call><name>CreatePublication</name><argument_list>(<argument><expr><operator>(</operator><name>CreatePublicationStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><name>T_AlterPublicationStmt</name></expr>:</case>
				<expr_stmt><expr><call><name>AlterPublication</name><argument_list>(<argument><expr><operator>(</operator><name>AlterPublicationStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/*
				 * AlterPublication calls EventTriggerCollectSimpleCommand
				 * directly
				 */</comment>
				<expr_stmt><expr><name>commandCollected</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><name>T_CreateSubscriptionStmt</name></expr>:</case>
				<expr_stmt><expr><name>address</name> <operator>=</operator> <call><name>CreateSubscription</name><argument_list>(<argument><expr><operator>(</operator><name>CreateSubscriptionStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></argument>,
											 <argument><expr><name>isTopLevel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><name>T_AlterSubscriptionStmt</name></expr>:</case>
				<expr_stmt><expr><name>address</name> <operator>=</operator> <call><name>AlterSubscription</name><argument_list>(<argument><expr><operator>(</operator><name>AlterSubscriptionStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><name>T_DropSubscriptionStmt</name></expr>:</case>
				<expr_stmt><expr><call><name>DropSubscription</name><argument_list>(<argument><expr><operator>(</operator><name>DropSubscriptionStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></argument>, <argument><expr><name>isTopLevel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<comment type="block">/* no commands stashed for DROP */</comment>
				<expr_stmt><expr><name>commandCollected</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><name>T_CreateStatsStmt</name></expr>:</case>
				<expr_stmt><expr><name>address</name> <operator>=</operator> <call><name>CreateStatistics</name><argument_list>(<argument><expr><operator>(</operator><name>CreateStatsStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><name>T_AlterCollationStmt</name></expr>:</case>
				<expr_stmt><expr><name>address</name> <operator>=</operator> <call><name>AlterCollation</name><argument_list>(<argument><expr><operator>(</operator><name>AlterCollationStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>

			<default>default:</default>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized node type: %d"</literal></expr></argument>,
					 <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <call><name>nodeTag</name><argument_list>(<argument><expr><name>parsetree</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
		</block_content>}</block></switch>

		<comment type="block">/*
		 * Remember the object so that ddl_command_end event triggers have
		 * access to it.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>commandCollected</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>EventTriggerCollectSimpleCommand</name><argument_list>(<argument><expr><name>address</name></expr></argument>, <argument><expr><name>secondaryObject</name></expr></argument>,
											 <argument><expr><name>parsetree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>isCompleteQuery</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>EventTriggerSQLDrop</name><argument_list>(<argument><expr><name>parsetree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>EventTriggerDDLCommandEnd</name><argument_list>(<argument><expr><name>parsetree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>
	<expr_stmt><expr><call><name>PG_CATCH</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>needCleanup</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>EventTriggerEndCompleteQuery</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>PG_RE_THROW</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
	<expr_stmt><expr><call><name>PG_END_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>needCleanup</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>EventTriggerEndCompleteQuery</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Dispatch function for DropStmt
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ExecDropStmt</name><parameter_list>(<parameter><decl><type><name>DropStmt</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>isTopLevel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<switch>switch <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>removeType</name></name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>OBJECT_INDEX</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>concurrent</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>PreventInTransactionBlock</name><argument_list>(<argument><expr><name>isTopLevel</name></expr></argument>,
										  <argument><expr><literal type="string">"DROP INDEX CONCURRENTLY"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<comment type="block">/* fall through */</comment>

		<case>case <expr><name>OBJECT_TABLE</name></expr>:</case>
		<case>case <expr><name>OBJECT_SEQUENCE</name></expr>:</case>
		<case>case <expr><name>OBJECT_VIEW</name></expr>:</case>
		<case>case <expr><name>OBJECT_MATVIEW</name></expr>:</case>
		<case>case <expr><name>OBJECT_FOREIGN_TABLE</name></expr>:</case>
			<expr_stmt><expr><call><name>RemoveRelations</name><argument_list>(<argument><expr><name>stmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<default>default:</default>
			<expr_stmt><expr><call><name>RemoveObjects</name><argument_list>(<argument><expr><name>stmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
	</block_content>}</block></switch>
</block_content>}</block></function>


<comment type="block">/*
 * UtilityReturnsTuples
 *		Return "true" if this utility statement will send output to the
 *		destination.
 *
 * Generally, there should be a case here for each case in ProcessUtility
 * where "dest" is passed on.
 */</comment>
<function><type><name>bool</name></type>
<name>UtilityReturnsTuples</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>parsetree</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<switch>switch <condition>(<expr><call><name>nodeTag</name><argument_list>(<argument><expr><name>parsetree</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>T_CallStmt</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>CallStmt</name>   <modifier>*</modifier></type><name>stmt</name> <init>= <expr><operator>(</operator><name>CallStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></init></decl>;</decl_stmt>

				<return>return <expr><operator>(</operator><name><name>stmt</name><operator>-&gt;</operator><name>funcexpr</name><operator>-&gt;</operator><name>funcresulttype</name></name> <operator>==</operator> <name>RECORDOID</name><operator>)</operator></expr>;</return>
			</block_content>}</block>
		<case>case <expr><name>T_FetchStmt</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>FetchStmt</name>  <modifier>*</modifier></type><name>stmt</name> <init>= <expr><operator>(</operator><name>FetchStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>Portal</name></type>		<name>portal</name></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>ismove</name></name></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
				<expr_stmt><expr><name>portal</name> <operator>=</operator> <call><name>GetPortalByName</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>portalname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>PortalIsValid</name><argument_list>(<argument><expr><name>portal</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>	<comment type="block">/* not our business to raise error */</comment>
				<return>return <expr><ternary><condition><expr><name><name>portal</name><operator>-&gt;</operator><name>tupDesc</name></name></expr> ?</condition><then> <expr><name>true</name></expr> </then><else>: <expr><name>false</name></expr></else></ternary></expr>;</return>
			</block_content>}</block>

		<case>case <expr><name>T_ExecuteStmt</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>ExecuteStmt</name> <modifier>*</modifier></type><name>stmt</name> <init>= <expr><operator>(</operator><name>ExecuteStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>PreparedStatement</name> <modifier>*</modifier></type><name>entry</name></decl>;</decl_stmt>

				<expr_stmt><expr><name>entry</name> <operator>=</operator> <call><name>FetchPreparedStatement</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><name>entry</name></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>	<comment type="block">/* not our business to raise error */</comment>
				<if_stmt><if>if <condition>(<expr><name><name>entry</name><operator>-&gt;</operator><name>plansource</name><operator>-&gt;</operator><name>resultDesc</name></name></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
				<return>return <expr><name>false</name></expr>;</return>
			</block_content>}</block>

		<case>case <expr><name>T_ExplainStmt</name></expr>:</case>
			<return>return <expr><name>true</name></expr>;</return>

		<case>case <expr><name>T_VariableShowStmt</name></expr>:</case>
			<return>return <expr><name>true</name></expr>;</return>

		<default>default:</default>
			<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></switch>
</block_content>}</block></function>

<comment type="block">/*
 * UtilityTupleDescriptor
 *		Fetch the actual output tuple descriptor for a utility statement
 *		for which UtilityReturnsTuples() previously returned "true".
 *
 * The returned descriptor is created in (or copied into) the current memory
 * context.
 */</comment>
<function><type><name>TupleDesc</name></type>
<name>UtilityTupleDescriptor</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>parsetree</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<switch>switch <condition>(<expr><call><name>nodeTag</name><argument_list>(<argument><expr><name>parsetree</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>T_CallStmt</name></expr>:</case>
			<return>return <expr><call><name>CallStmtResultDesc</name><argument_list>(<argument><expr><operator>(</operator><name>CallStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></argument>)</argument_list></call></expr>;</return>

		<case>case <expr><name>T_FetchStmt</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>FetchStmt</name>  <modifier>*</modifier></type><name>stmt</name> <init>= <expr><operator>(</operator><name>FetchStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>Portal</name></type>		<name>portal</name></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>ismove</name></name></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
				<expr_stmt><expr><name>portal</name> <operator>=</operator> <call><name>GetPortalByName</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>portalname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>PortalIsValid</name><argument_list>(<argument><expr><name>portal</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>	<comment type="block">/* not our business to raise error */</comment>
				<return>return <expr><call><name>CreateTupleDescCopy</name><argument_list>(<argument><expr><name><name>portal</name><operator>-&gt;</operator><name>tupDesc</name></name></expr></argument>)</argument_list></call></expr>;</return>
			</block_content>}</block>

		<case>case <expr><name>T_ExecuteStmt</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>ExecuteStmt</name> <modifier>*</modifier></type><name>stmt</name> <init>= <expr><operator>(</operator><name>ExecuteStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>PreparedStatement</name> <modifier>*</modifier></type><name>entry</name></decl>;</decl_stmt>

				<expr_stmt><expr><name>entry</name> <operator>=</operator> <call><name>FetchPreparedStatement</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><name>entry</name></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>	<comment type="block">/* not our business to raise error */</comment>
				<return>return <expr><call><name>FetchPreparedStatementResultDesc</name><argument_list>(<argument><expr><name>entry</name></expr></argument>)</argument_list></call></expr>;</return>
			</block_content>}</block>

		<case>case <expr><name>T_ExplainStmt</name></expr>:</case>
			<return>return <expr><call><name>ExplainResultDesc</name><argument_list>(<argument><expr><operator>(</operator><name>ExplainStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></argument>)</argument_list></call></expr>;</return>

		<case>case <expr><name>T_VariableShowStmt</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>VariableShowStmt</name> <modifier>*</modifier></type><name>n</name> <init>= <expr><operator>(</operator><name>VariableShowStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></init></decl>;</decl_stmt>

				<return>return <expr><call><name>GetPGVariableResultDesc</name><argument_list>(<argument><expr><name><name>n</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</return>
			</block_content>}</block>

		<default>default:</default>
			<return>return <expr><name>NULL</name></expr>;</return>
	</block_content>}</block></switch>
</block_content>}</block></function>


<comment type="block">/*
 * QueryReturnsTuples
 *		Return "true" if this Query will send output to the destination.
 */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>NOT_USED</name></cpp:ifdef>
<function><type><name>bool</name></type>
<name>QueryReturnsTuples</name><parameter_list>(<parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>parsetree</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<switch>switch <condition>(<expr><name><name>parsetree</name><operator>-&gt;</operator><name>commandType</name></name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>CMD_SELECT</name></expr>:</case>
			<comment type="block">/* returns tuples */</comment>
			<return>return <expr><name>true</name></expr>;</return>
		<case>case <expr><name>CMD_INSERT</name></expr>:</case>
		<case>case <expr><name>CMD_UPDATE</name></expr>:</case>
		<case>case <expr><name>CMD_DELETE</name></expr>:</case>
			<comment type="block">/* the forms with RETURNING return tuples */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>parsetree</name><operator>-&gt;</operator><name>returningList</name></name></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
			<break>break;</break>
		<case>case <expr><name>CMD_UTILITY</name></expr>:</case>
			<return>return <expr><call><name>UtilityReturnsTuples</name><argument_list>(<argument><expr><name><name>parsetree</name><operator>-&gt;</operator><name>utilityStmt</name></name></expr></argument>)</argument_list></call></expr>;</return>
		<case>case <expr><name>CMD_UNKNOWN</name></expr>:</case>
		<case>case <expr><name>CMD_NOTHING</name></expr>:</case>
			<comment type="block">/* probably shouldn't get here */</comment>
			<break>break;</break>
	</block_content>}</block></switch>
	<return>return <expr><name>false</name></expr>;</return>				<comment type="block">/* default */</comment>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>


<comment type="block">/*
 * UtilityContainsQuery
 *		Return the contained Query, or NULL if there is none
 *
 * Certain utility statements, such as EXPLAIN, contain a plannable Query.
 * This function encapsulates knowledge of exactly which ones do.
 * We assume it is invoked only on already-parse-analyzed statements
 * (else the contained parsetree isn't a Query yet).
 *
 * In some cases (currently, only EXPLAIN of CREATE TABLE AS/SELECT INTO and
 * CREATE MATERIALIZED VIEW), potentially Query-containing utility statements
 * can be nested.  This function will drill down to a non-utility Query, or
 * return NULL if none.
 */</comment>
<function><type><name>Query</name> <modifier>*</modifier></type>
<name>UtilityContainsQuery</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>parsetree</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Query</name>	   <modifier>*</modifier></type><name>qry</name></decl>;</decl_stmt>

	<switch>switch <condition>(<expr><call><name>nodeTag</name><argument_list>(<argument><expr><name>parsetree</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>T_DeclareCursorStmt</name></expr>:</case>
			<expr_stmt><expr><name>qry</name> <operator>=</operator> <call><name>castNode</name><argument_list>(<argument><expr><name>Query</name></expr></argument>, <argument><expr><operator>(</operator><operator>(</operator><name>DeclareCursorStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name><operator>)</operator><operator>-&gt;</operator><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>qry</name><operator>-&gt;</operator><name>commandType</name></name> <operator>==</operator> <name>CMD_UTILITY</name></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><call><name>UtilityContainsQuery</name><argument_list>(<argument><expr><name><name>qry</name><operator>-&gt;</operator><name>utilityStmt</name></name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
			<return>return <expr><name>qry</name></expr>;</return>

		<case>case <expr><name>T_ExplainStmt</name></expr>:</case>
			<expr_stmt><expr><name>qry</name> <operator>=</operator> <call><name>castNode</name><argument_list>(<argument><expr><name>Query</name></expr></argument>, <argument><expr><operator>(</operator><operator>(</operator><name>ExplainStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name><operator>)</operator><operator>-&gt;</operator><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>qry</name><operator>-&gt;</operator><name>commandType</name></name> <operator>==</operator> <name>CMD_UTILITY</name></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><call><name>UtilityContainsQuery</name><argument_list>(<argument><expr><name><name>qry</name><operator>-&gt;</operator><name>utilityStmt</name></name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
			<return>return <expr><name>qry</name></expr>;</return>

		<case>case <expr><name>T_CreateTableAsStmt</name></expr>:</case>
			<expr_stmt><expr><name>qry</name> <operator>=</operator> <call><name>castNode</name><argument_list>(<argument><expr><name>Query</name></expr></argument>, <argument><expr><operator>(</operator><operator>(</operator><name>CreateTableAsStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name><operator>)</operator><operator>-&gt;</operator><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>qry</name><operator>-&gt;</operator><name>commandType</name></name> <operator>==</operator> <name>CMD_UTILITY</name></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><call><name>UtilityContainsQuery</name><argument_list>(<argument><expr><name><name>qry</name><operator>-&gt;</operator><name>utilityStmt</name></name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
			<return>return <expr><name>qry</name></expr>;</return>

		<default>default:</default>
			<return>return <expr><name>NULL</name></expr>;</return>
	</block_content>}</block></switch>
</block_content>}</block></function>


<comment type="block">/*
 * AlterObjectTypeCommandTag
 *		helper function for CreateCommandTag
 *
 * This covers most cases where ALTER is used with an ObjectType enum.
 */</comment>
<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>
<name>AlterObjectTypeCommandTag</name><parameter_list>(<parameter><decl><type><name>ObjectType</name></type> <name>objtype</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>tag</name></decl>;</decl_stmt>

	<switch>switch <condition>(<expr><name>objtype</name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>OBJECT_AGGREGATE</name></expr>:</case>
			<expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"ALTER AGGREGATE"</literal></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>OBJECT_ATTRIBUTE</name></expr>:</case>
			<expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"ALTER TYPE"</literal></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>OBJECT_CAST</name></expr>:</case>
			<expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"ALTER CAST"</literal></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>OBJECT_COLLATION</name></expr>:</case>
			<expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"ALTER COLLATION"</literal></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>OBJECT_COLUMN</name></expr>:</case>
			<expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"ALTER TABLE"</literal></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>OBJECT_CONVERSION</name></expr>:</case>
			<expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"ALTER CONVERSION"</literal></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>OBJECT_DATABASE</name></expr>:</case>
			<expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"ALTER DATABASE"</literal></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>OBJECT_DOMAIN</name></expr>:</case>
		<case>case <expr><name>OBJECT_DOMCONSTRAINT</name></expr>:</case>
			<expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"ALTER DOMAIN"</literal></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>OBJECT_EXTENSION</name></expr>:</case>
			<expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"ALTER EXTENSION"</literal></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>OBJECT_FDW</name></expr>:</case>
			<expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"ALTER FOREIGN DATA WRAPPER"</literal></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>OBJECT_FOREIGN_SERVER</name></expr>:</case>
			<expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"ALTER SERVER"</literal></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>OBJECT_FOREIGN_TABLE</name></expr>:</case>
			<expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"ALTER FOREIGN TABLE"</literal></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>OBJECT_FUNCTION</name></expr>:</case>
			<expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"ALTER FUNCTION"</literal></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>OBJECT_INDEX</name></expr>:</case>
			<expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"ALTER INDEX"</literal></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>OBJECT_LANGUAGE</name></expr>:</case>
			<expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"ALTER LANGUAGE"</literal></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>OBJECT_LARGEOBJECT</name></expr>:</case>
			<expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"ALTER LARGE OBJECT"</literal></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>OBJECT_OPCLASS</name></expr>:</case>
			<expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"ALTER OPERATOR CLASS"</literal></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>OBJECT_OPERATOR</name></expr>:</case>
			<expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"ALTER OPERATOR"</literal></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>OBJECT_OPFAMILY</name></expr>:</case>
			<expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"ALTER OPERATOR FAMILY"</literal></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>OBJECT_POLICY</name></expr>:</case>
			<expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"ALTER POLICY"</literal></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>OBJECT_PROCEDURE</name></expr>:</case>
			<expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"ALTER PROCEDURE"</literal></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>OBJECT_ROLE</name></expr>:</case>
			<expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"ALTER ROLE"</literal></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>OBJECT_ROUTINE</name></expr>:</case>
			<expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"ALTER ROUTINE"</literal></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>OBJECT_RULE</name></expr>:</case>
			<expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"ALTER RULE"</literal></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>OBJECT_SCHEMA</name></expr>:</case>
			<expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"ALTER SCHEMA"</literal></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>OBJECT_SEQUENCE</name></expr>:</case>
			<expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"ALTER SEQUENCE"</literal></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>OBJECT_TABLE</name></expr>:</case>
		<case>case <expr><name>OBJECT_TABCONSTRAINT</name></expr>:</case>
			<expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"ALTER TABLE"</literal></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>OBJECT_TABLESPACE</name></expr>:</case>
			<expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"ALTER TABLESPACE"</literal></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>OBJECT_TRIGGER</name></expr>:</case>
			<expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"ALTER TRIGGER"</literal></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>OBJECT_EVENT_TRIGGER</name></expr>:</case>
			<expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"ALTER EVENT TRIGGER"</literal></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>OBJECT_TSCONFIGURATION</name></expr>:</case>
			<expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"ALTER TEXT SEARCH CONFIGURATION"</literal></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>OBJECT_TSDICTIONARY</name></expr>:</case>
			<expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"ALTER TEXT SEARCH DICTIONARY"</literal></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>OBJECT_TSPARSER</name></expr>:</case>
			<expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"ALTER TEXT SEARCH PARSER"</literal></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>OBJECT_TSTEMPLATE</name></expr>:</case>
			<expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"ALTER TEXT SEARCH TEMPLATE"</literal></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>OBJECT_TYPE</name></expr>:</case>
			<expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"ALTER TYPE"</literal></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>OBJECT_VIEW</name></expr>:</case>
			<expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"ALTER VIEW"</literal></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>OBJECT_MATVIEW</name></expr>:</case>
			<expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"ALTER MATERIALIZED VIEW"</literal></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>OBJECT_PUBLICATION</name></expr>:</case>
			<expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"ALTER PUBLICATION"</literal></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>OBJECT_SUBSCRIPTION</name></expr>:</case>
			<expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"ALTER SUBSCRIPTION"</literal></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>OBJECT_STATISTIC_EXT</name></expr>:</case>
			<expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"ALTER STATISTICS"</literal></expr>;</expr_stmt>
			<break>break;</break>
		<default>default:</default>
			<expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"???"</literal></expr>;</expr_stmt>
			<break>break;</break>
	</block_content>}</block></switch>

	<return>return <expr><name>tag</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * CreateCommandTag
 *		utility to get a string representation of the command operation,
 *		given either a raw (un-analyzed) parsetree, an analyzed Query,
 *		or a PlannedStmt.
 *
 * This must handle all command types, but since the vast majority
 * of 'em are utility commands, it seems sensible to keep it here.
 *
 * NB: all result strings must be shorter than COMPLETION_TAG_BUFSIZE.
 * Also, the result must point at a true constant (permanent storage).
 */</comment>
<function><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>
<name>CreateCommandTag</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>parsetree</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>tag</name></decl>;</decl_stmt>

	<switch>switch <condition>(<expr><call><name>nodeTag</name><argument_list>(<argument><expr><name>parsetree</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
			<comment type="block">/* recurse if we're given a RawStmt */</comment>
		<case>case <expr><name>T_RawStmt</name></expr>:</case>
			<expr_stmt><expr><name>tag</name> <operator>=</operator> <call><name>CreateCommandTag</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>RawStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name><operator>)</operator><operator>-&gt;</operator><name>stmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

			<comment type="block">/* raw plannable queries */</comment>
		<case>case <expr><name>T_InsertStmt</name></expr>:</case>
			<expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"INSERT"</literal></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_DeleteStmt</name></expr>:</case>
			<expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"DELETE"</literal></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_UpdateStmt</name></expr>:</case>
			<expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"UPDATE"</literal></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_SelectStmt</name></expr>:</case>
			<expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"SELECT"</literal></expr>;</expr_stmt>
			<break>break;</break>

			<comment type="block">/* utility statements --- same whether raw or cooked */</comment>
		<case>case <expr><name>T_TransactionStmt</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>TransactionStmt</name> <modifier>*</modifier></type><name>stmt</name> <init>= <expr><operator>(</operator><name>TransactionStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></init></decl>;</decl_stmt>

				<switch>switch <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>kind</name></name></expr>)</condition>
				<block>{<block_content>
					<case>case <expr><name>TRANS_STMT_BEGIN</name></expr>:</case>
						<expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"BEGIN"</literal></expr>;</expr_stmt>
						<break>break;</break>

					<case>case <expr><name>TRANS_STMT_START</name></expr>:</case>
						<expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"START TRANSACTION"</literal></expr>;</expr_stmt>
						<break>break;</break>

					<case>case <expr><name>TRANS_STMT_COMMIT</name></expr>:</case>
						<expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"COMMIT"</literal></expr>;</expr_stmt>
						<break>break;</break>

					<case>case <expr><name>TRANS_STMT_ROLLBACK</name></expr>:</case>
					<case>case <expr><name>TRANS_STMT_ROLLBACK_TO</name></expr>:</case>
						<expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"ROLLBACK"</literal></expr>;</expr_stmt>
						<break>break;</break>

					<case>case <expr><name>TRANS_STMT_SAVEPOINT</name></expr>:</case>
						<expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"SAVEPOINT"</literal></expr>;</expr_stmt>
						<break>break;</break>

					<case>case <expr><name>TRANS_STMT_RELEASE</name></expr>:</case>
						<expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"RELEASE"</literal></expr>;</expr_stmt>
						<break>break;</break>

					<case>case <expr><name>TRANS_STMT_PREPARE</name></expr>:</case>
						<expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"PREPARE TRANSACTION"</literal></expr>;</expr_stmt>
						<break>break;</break>

					<case>case <expr><name>TRANS_STMT_COMMIT_PREPARED</name></expr>:</case>
						<expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"COMMIT PREPARED"</literal></expr>;</expr_stmt>
						<break>break;</break>

					<case>case <expr><name>TRANS_STMT_ROLLBACK_PREPARED</name></expr>:</case>
						<expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"ROLLBACK PREPARED"</literal></expr>;</expr_stmt>
						<break>break;</break>

					<default>default:</default>
						<expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"???"</literal></expr>;</expr_stmt>
						<break>break;</break>
				</block_content>}</block></switch>
			</block_content>}</block>
			<break>break;</break>

		<case>case <expr><name>T_DeclareCursorStmt</name></expr>:</case>
			<expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"DECLARE CURSOR"</literal></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_ClosePortalStmt</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>ClosePortalStmt</name> <modifier>*</modifier></type><name>stmt</name> <init>= <expr><operator>(</operator><name>ClosePortalStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></init></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>portalname</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"CLOSE CURSOR ALL"</literal></expr>;</expr_stmt></block_content></block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"CLOSE CURSOR"</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>
			</block_content>}</block>
			<break>break;</break>

		<case>case <expr><name>T_FetchStmt</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>FetchStmt</name>  <modifier>*</modifier></type><name>stmt</name> <init>= <expr><operator>(</operator><name>FetchStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><name>tag</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name><name>stmt</name><operator>-&gt;</operator><name>ismove</name></name><operator>)</operator></expr> ?</condition><then> <expr><literal type="string">"MOVE"</literal></expr> </then><else>: <expr><literal type="string">"FETCH"</literal></expr></else></ternary></expr>;</expr_stmt>
			</block_content>}</block>
			<break>break;</break>

		<case>case <expr><name>T_CreateDomainStmt</name></expr>:</case>
			<expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"CREATE DOMAIN"</literal></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_CreateSchemaStmt</name></expr>:</case>
			<expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"CREATE SCHEMA"</literal></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_CreateStmt</name></expr>:</case>
			<expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"CREATE TABLE"</literal></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_CreateTableSpaceStmt</name></expr>:</case>
			<expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"CREATE TABLESPACE"</literal></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_DropTableSpaceStmt</name></expr>:</case>
			<expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"DROP TABLESPACE"</literal></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_AlterTableSpaceOptionsStmt</name></expr>:</case>
			<expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"ALTER TABLESPACE"</literal></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_CreateExtensionStmt</name></expr>:</case>
			<expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"CREATE EXTENSION"</literal></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_AlterExtensionStmt</name></expr>:</case>
			<expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"ALTER EXTENSION"</literal></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_AlterExtensionContentsStmt</name></expr>:</case>
			<expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"ALTER EXTENSION"</literal></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_CreateFdwStmt</name></expr>:</case>
			<expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"CREATE FOREIGN DATA WRAPPER"</literal></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_AlterFdwStmt</name></expr>:</case>
			<expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"ALTER FOREIGN DATA WRAPPER"</literal></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_CreateForeignServerStmt</name></expr>:</case>
			<expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"CREATE SERVER"</literal></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_AlterForeignServerStmt</name></expr>:</case>
			<expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"ALTER SERVER"</literal></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_CreateUserMappingStmt</name></expr>:</case>
			<expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"CREATE USER MAPPING"</literal></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_AlterUserMappingStmt</name></expr>:</case>
			<expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"ALTER USER MAPPING"</literal></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_DropUserMappingStmt</name></expr>:</case>
			<expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"DROP USER MAPPING"</literal></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_CreateForeignTableStmt</name></expr>:</case>
			<expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"CREATE FOREIGN TABLE"</literal></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_ImportForeignSchemaStmt</name></expr>:</case>
			<expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"IMPORT FOREIGN SCHEMA"</literal></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_DropStmt</name></expr>:</case>
			<switch>switch <condition>(<expr><operator>(</operator><operator>(</operator><name>DropStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name><operator>)</operator><operator>-&gt;</operator><name>removeType</name></expr>)</condition>
			<block>{<block_content>
				<case>case <expr><name>OBJECT_TABLE</name></expr>:</case>
					<expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"DROP TABLE"</literal></expr>;</expr_stmt>
					<break>break;</break>
				<case>case <expr><name>OBJECT_SEQUENCE</name></expr>:</case>
					<expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"DROP SEQUENCE"</literal></expr>;</expr_stmt>
					<break>break;</break>
				<case>case <expr><name>OBJECT_VIEW</name></expr>:</case>
					<expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"DROP VIEW"</literal></expr>;</expr_stmt>
					<break>break;</break>
				<case>case <expr><name>OBJECT_MATVIEW</name></expr>:</case>
					<expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"DROP MATERIALIZED VIEW"</literal></expr>;</expr_stmt>
					<break>break;</break>
				<case>case <expr><name>OBJECT_INDEX</name></expr>:</case>
					<expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"DROP INDEX"</literal></expr>;</expr_stmt>
					<break>break;</break>
				<case>case <expr><name>OBJECT_TYPE</name></expr>:</case>
					<expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"DROP TYPE"</literal></expr>;</expr_stmt>
					<break>break;</break>
				<case>case <expr><name>OBJECT_DOMAIN</name></expr>:</case>
					<expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"DROP DOMAIN"</literal></expr>;</expr_stmt>
					<break>break;</break>
				<case>case <expr><name>OBJECT_COLLATION</name></expr>:</case>
					<expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"DROP COLLATION"</literal></expr>;</expr_stmt>
					<break>break;</break>
				<case>case <expr><name>OBJECT_CONVERSION</name></expr>:</case>
					<expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"DROP CONVERSION"</literal></expr>;</expr_stmt>
					<break>break;</break>
				<case>case <expr><name>OBJECT_SCHEMA</name></expr>:</case>
					<expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"DROP SCHEMA"</literal></expr>;</expr_stmt>
					<break>break;</break>
				<case>case <expr><name>OBJECT_TSPARSER</name></expr>:</case>
					<expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"DROP TEXT SEARCH PARSER"</literal></expr>;</expr_stmt>
					<break>break;</break>
				<case>case <expr><name>OBJECT_TSDICTIONARY</name></expr>:</case>
					<expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"DROP TEXT SEARCH DICTIONARY"</literal></expr>;</expr_stmt>
					<break>break;</break>
				<case>case <expr><name>OBJECT_TSTEMPLATE</name></expr>:</case>
					<expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"DROP TEXT SEARCH TEMPLATE"</literal></expr>;</expr_stmt>
					<break>break;</break>
				<case>case <expr><name>OBJECT_TSCONFIGURATION</name></expr>:</case>
					<expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"DROP TEXT SEARCH CONFIGURATION"</literal></expr>;</expr_stmt>
					<break>break;</break>
				<case>case <expr><name>OBJECT_FOREIGN_TABLE</name></expr>:</case>
					<expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"DROP FOREIGN TABLE"</literal></expr>;</expr_stmt>
					<break>break;</break>
				<case>case <expr><name>OBJECT_EXTENSION</name></expr>:</case>
					<expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"DROP EXTENSION"</literal></expr>;</expr_stmt>
					<break>break;</break>
				<case>case <expr><name>OBJECT_FUNCTION</name></expr>:</case>
					<expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"DROP FUNCTION"</literal></expr>;</expr_stmt>
					<break>break;</break>
				<case>case <expr><name>OBJECT_PROCEDURE</name></expr>:</case>
					<expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"DROP PROCEDURE"</literal></expr>;</expr_stmt>
					<break>break;</break>
				<case>case <expr><name>OBJECT_ROUTINE</name></expr>:</case>
					<expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"DROP ROUTINE"</literal></expr>;</expr_stmt>
					<break>break;</break>
				<case>case <expr><name>OBJECT_AGGREGATE</name></expr>:</case>
					<expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"DROP AGGREGATE"</literal></expr>;</expr_stmt>
					<break>break;</break>
				<case>case <expr><name>OBJECT_OPERATOR</name></expr>:</case>
					<expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"DROP OPERATOR"</literal></expr>;</expr_stmt>
					<break>break;</break>
				<case>case <expr><name>OBJECT_LANGUAGE</name></expr>:</case>
					<expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"DROP LANGUAGE"</literal></expr>;</expr_stmt>
					<break>break;</break>
				<case>case <expr><name>OBJECT_CAST</name></expr>:</case>
					<expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"DROP CAST"</literal></expr>;</expr_stmt>
					<break>break;</break>
				<case>case <expr><name>OBJECT_TRIGGER</name></expr>:</case>
					<expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"DROP TRIGGER"</literal></expr>;</expr_stmt>
					<break>break;</break>
				<case>case <expr><name>OBJECT_EVENT_TRIGGER</name></expr>:</case>
					<expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"DROP EVENT TRIGGER"</literal></expr>;</expr_stmt>
					<break>break;</break>
				<case>case <expr><name>OBJECT_RULE</name></expr>:</case>
					<expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"DROP RULE"</literal></expr>;</expr_stmt>
					<break>break;</break>
				<case>case <expr><name>OBJECT_FDW</name></expr>:</case>
					<expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"DROP FOREIGN DATA WRAPPER"</literal></expr>;</expr_stmt>
					<break>break;</break>
				<case>case <expr><name>OBJECT_FOREIGN_SERVER</name></expr>:</case>
					<expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"DROP SERVER"</literal></expr>;</expr_stmt>
					<break>break;</break>
				<case>case <expr><name>OBJECT_OPCLASS</name></expr>:</case>
					<expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"DROP OPERATOR CLASS"</literal></expr>;</expr_stmt>
					<break>break;</break>
				<case>case <expr><name>OBJECT_OPFAMILY</name></expr>:</case>
					<expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"DROP OPERATOR FAMILY"</literal></expr>;</expr_stmt>
					<break>break;</break>
				<case>case <expr><name>OBJECT_POLICY</name></expr>:</case>
					<expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"DROP POLICY"</literal></expr>;</expr_stmt>
					<break>break;</break>
				<case>case <expr><name>OBJECT_TRANSFORM</name></expr>:</case>
					<expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"DROP TRANSFORM"</literal></expr>;</expr_stmt>
					<break>break;</break>
				<case>case <expr><name>OBJECT_ACCESS_METHOD</name></expr>:</case>
					<expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"DROP ACCESS METHOD"</literal></expr>;</expr_stmt>
					<break>break;</break>
				<case>case <expr><name>OBJECT_PUBLICATION</name></expr>:</case>
					<expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"DROP PUBLICATION"</literal></expr>;</expr_stmt>
					<break>break;</break>
				<case>case <expr><name>OBJECT_STATISTIC_EXT</name></expr>:</case>
					<expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"DROP STATISTICS"</literal></expr>;</expr_stmt>
					<break>break;</break>
				<default>default:</default>
					<expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"???"</literal></expr>;</expr_stmt>
			</block_content>}</block></switch>
			<break>break;</break>

		<case>case <expr><name>T_TruncateStmt</name></expr>:</case>
			<expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"TRUNCATE TABLE"</literal></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_CommentStmt</name></expr>:</case>
			<expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"COMMENT"</literal></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_SecLabelStmt</name></expr>:</case>
			<expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"SECURITY LABEL"</literal></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_CopyStmt</name></expr>:</case>
			<expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"COPY"</literal></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_RenameStmt</name></expr>:</case>
			<expr_stmt><expr><name>tag</name> <operator>=</operator> <call><name>AlterObjectTypeCommandTag</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>RenameStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name><operator>)</operator><operator>-&gt;</operator><name>renameType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_AlterObjectDependsStmt</name></expr>:</case>
			<expr_stmt><expr><name>tag</name> <operator>=</operator> <call><name>AlterObjectTypeCommandTag</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>AlterObjectDependsStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name><operator>)</operator><operator>-&gt;</operator><name>objectType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_AlterObjectSchemaStmt</name></expr>:</case>
			<if_stmt><if>if<condition>(<expr><operator>(</operator><operator>(</operator><name>AlterObjectSchemaStmt</name><operator>*</operator><operator>)</operator> <name>parsetree</name><operator>)</operator><operator>-&gt;</operator><name>is_flashback</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"FLASHBACK COMPLETE"</literal></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name>tag</name> <operator>=</operator> <call><name>AlterObjectTypeCommandTag</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>AlterObjectSchemaStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name><operator>)</operator><operator>-&gt;</operator><name>objectType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
			<break>break;</break>

		<case>case <expr><name>T_AlterOwnerStmt</name></expr>:</case>
			<expr_stmt><expr><name>tag</name> <operator>=</operator> <call><name>AlterObjectTypeCommandTag</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>AlterOwnerStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name><operator>)</operator><operator>-&gt;</operator><name>objectType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_AlterTableMoveAllStmt</name></expr>:</case>
			<expr_stmt><expr><name>tag</name> <operator>=</operator> <call><name>AlterObjectTypeCommandTag</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>AlterTableMoveAllStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name><operator>)</operator><operator>-&gt;</operator><name>objtype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_AlterTableStmt</name></expr>:</case>
			<expr_stmt><expr><name>tag</name> <operator>=</operator> <call><name>AlterObjectTypeCommandTag</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>AlterTableStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name><operator>)</operator><operator>-&gt;</operator><name>relkind</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_AlterDomainStmt</name></expr>:</case>
			<expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"ALTER DOMAIN"</literal></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_AlterFunctionStmt</name></expr>:</case>
			<switch>switch <condition>(<expr><operator>(</operator><operator>(</operator><name>AlterFunctionStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name><operator>)</operator><operator>-&gt;</operator><name>objtype</name></expr>)</condition>
			<block>{<block_content>
				<case>case <expr><name>OBJECT_FUNCTION</name></expr>:</case>
					<expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"ALTER FUNCTION"</literal></expr>;</expr_stmt>
					<break>break;</break>
				<case>case <expr><name>OBJECT_PROCEDURE</name></expr>:</case>
					<expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"ALTER PROCEDURE"</literal></expr>;</expr_stmt>
					<break>break;</break>
				<case>case <expr><name>OBJECT_ROUTINE</name></expr>:</case>
					<expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"ALTER ROUTINE"</literal></expr>;</expr_stmt>
					<break>break;</break>
				<default>default:</default>
					<expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"???"</literal></expr>;</expr_stmt>
			</block_content>}</block></switch>
			<break>break;</break>

		<case>case <expr><name>T_GrantStmt</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>GrantStmt</name>  <modifier>*</modifier></type><name>stmt</name> <init>= <expr><operator>(</operator><name>GrantStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><name>tag</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name><name>stmt</name><operator>-&gt;</operator><name>is_grant</name></name><operator>)</operator></expr> ?</condition><then> <expr><literal type="string">"GRANT"</literal></expr> </then><else>: <expr><literal type="string">"REVOKE"</literal></expr></else></ternary></expr>;</expr_stmt>
			</block_content>}</block>
			<break>break;</break>

		<case>case <expr><name>T_GrantRoleStmt</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>GrantRoleStmt</name> <modifier>*</modifier></type><name>stmt</name> <init>= <expr><operator>(</operator><name>GrantRoleStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><name>tag</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name><name>stmt</name><operator>-&gt;</operator><name>is_grant</name></name><operator>)</operator></expr> ?</condition><then> <expr><literal type="string">"GRANT ROLE"</literal></expr> </then><else>: <expr><literal type="string">"REVOKE ROLE"</literal></expr></else></ternary></expr>;</expr_stmt>
			</block_content>}</block>
			<break>break;</break>

		<case>case <expr><name>T_AlterDefaultPrivilegesStmt</name></expr>:</case>
			<expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"ALTER DEFAULT PRIVILEGES"</literal></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_DefineStmt</name></expr>:</case>
			<switch>switch <condition>(<expr><operator>(</operator><operator>(</operator><name>DefineStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name><operator>)</operator><operator>-&gt;</operator><name>kind</name></expr>)</condition>
			<block>{<block_content>
				<case>case <expr><name>OBJECT_AGGREGATE</name></expr>:</case>
					<expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"CREATE AGGREGATE"</literal></expr>;</expr_stmt>
					<break>break;</break>
				<case>case <expr><name>OBJECT_OPERATOR</name></expr>:</case>
					<expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"CREATE OPERATOR"</literal></expr>;</expr_stmt>
					<break>break;</break>
				<case>case <expr><name>OBJECT_TYPE</name></expr>:</case>
					<expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"CREATE TYPE"</literal></expr>;</expr_stmt>
					<break>break;</break>
				<case>case <expr><name>OBJECT_TSPARSER</name></expr>:</case>
					<expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"CREATE TEXT SEARCH PARSER"</literal></expr>;</expr_stmt>
					<break>break;</break>
				<case>case <expr><name>OBJECT_TSDICTIONARY</name></expr>:</case>
					<expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"CREATE TEXT SEARCH DICTIONARY"</literal></expr>;</expr_stmt>
					<break>break;</break>
				<case>case <expr><name>OBJECT_TSTEMPLATE</name></expr>:</case>
					<expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"CREATE TEXT SEARCH TEMPLATE"</literal></expr>;</expr_stmt>
					<break>break;</break>
				<case>case <expr><name>OBJECT_TSCONFIGURATION</name></expr>:</case>
					<expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"CREATE TEXT SEARCH CONFIGURATION"</literal></expr>;</expr_stmt>
					<break>break;</break>
				<case>case <expr><name>OBJECT_COLLATION</name></expr>:</case>
					<expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"CREATE COLLATION"</literal></expr>;</expr_stmt>
					<break>break;</break>
				<case>case <expr><name>OBJECT_ACCESS_METHOD</name></expr>:</case>
					<expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"CREATE ACCESS METHOD"</literal></expr>;</expr_stmt>
					<break>break;</break>
				<default>default:</default>
					<expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"???"</literal></expr>;</expr_stmt>
			</block_content>}</block></switch>
			<break>break;</break>

		<case>case <expr><name>T_CompositeTypeStmt</name></expr>:</case>
			<expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"CREATE TYPE"</literal></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_CreateEnumStmt</name></expr>:</case>
			<expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"CREATE TYPE"</literal></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_CreateRangeStmt</name></expr>:</case>
			<expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"CREATE TYPE"</literal></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_AlterEnumStmt</name></expr>:</case>
			<expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"ALTER TYPE"</literal></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_ViewStmt</name></expr>:</case>
			<expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"CREATE VIEW"</literal></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_CreateFunctionStmt</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><operator>(</operator><operator>(</operator><name>CreateFunctionStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name><operator>)</operator><operator>-&gt;</operator><name>is_procedure</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"CREATE PROCEDURE"</literal></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"CREATE FUNCTION"</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>
			<break>break;</break>

		<case>case <expr><name>T_IndexStmt</name></expr>:</case>
			<expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"CREATE INDEX"</literal></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_RuleStmt</name></expr>:</case>
			<expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"CREATE RULE"</literal></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_CreateSeqStmt</name></expr>:</case>
			<expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"CREATE SEQUENCE"</literal></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_AlterSeqStmt</name></expr>:</case>
			<expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"ALTER SEQUENCE"</literal></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_DoStmt</name></expr>:</case>
			<expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"DO"</literal></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_CreatedbStmt</name></expr>:</case>
			<expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"CREATE DATABASE"</literal></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_AlterDatabaseStmt</name></expr>:</case>
			<expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"ALTER DATABASE"</literal></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_AlterDatabaseSetStmt</name></expr>:</case>
			<expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"ALTER DATABASE"</literal></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_DropdbStmt</name></expr>:</case>
			<expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"DROP DATABASE"</literal></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_NotifyStmt</name></expr>:</case>
			<expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"NOTIFY"</literal></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_ListenStmt</name></expr>:</case>
			<expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"LISTEN"</literal></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_UnlistenStmt</name></expr>:</case>
			<expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"UNLISTEN"</literal></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_LoadStmt</name></expr>:</case>
			<expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"LOAD"</literal></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_CallStmt</name></expr>:</case>
			<expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"CALL"</literal></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_ClusterStmt</name></expr>:</case>
			<expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"CLUSTER"</literal></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_VacuumStmt</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><operator>(</operator><operator>(</operator><name>VacuumStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name><operator>)</operator><operator>-&gt;</operator><name>options</name> <operator>&amp;</operator> <name>VACOPT_VACUUM</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"VACUUM"</literal></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"ANALYZE"</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>
			<break>break;</break>

		<case>case <expr><name>T_ExplainStmt</name></expr>:</case>
			<expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"EXPLAIN"</literal></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_CreateTableAsStmt</name></expr>:</case>
			<switch>switch <condition>(<expr><operator>(</operator><operator>(</operator><name>CreateTableAsStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name><operator>)</operator><operator>-&gt;</operator><name>relkind</name></expr>)</condition>
			<block>{<block_content>
				<case>case <expr><name>OBJECT_TABLE</name></expr>:</case>
					<if_stmt><if>if <condition>(<expr><operator>(</operator><operator>(</operator><name>CreateTableAsStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name><operator>)</operator><operator>-&gt;</operator><name>is_select_into</name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"SELECT INTO"</literal></expr>;</expr_stmt></block_content></block></if>
					<else>else<block type="pseudo"><block_content>
						<expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"CREATE TABLE AS"</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>
					<break>break;</break>
				<case>case <expr><name>OBJECT_MATVIEW</name></expr>:</case>
					<expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"CREATE MATERIALIZED VIEW"</literal></expr>;</expr_stmt>
					<break>break;</break>
				<default>default:</default>
					<expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"???"</literal></expr>;</expr_stmt>
			</block_content>}</block></switch>
			<break>break;</break>

		<case>case <expr><name>T_RefreshMatViewStmt</name></expr>:</case>
			<expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"REFRESH MATERIALIZED VIEW"</literal></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_AlterSystemStmt</name></expr>:</case>
			<expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"ALTER SYSTEM"</literal></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_VariableSetStmt</name></expr>:</case>
			<switch>switch <condition>(<expr><operator>(</operator><operator>(</operator><name>VariableSetStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name><operator>)</operator><operator>-&gt;</operator><name>kind</name></expr>)</condition>
			<block>{<block_content>
				<case>case <expr><name>VAR_SET_VALUE</name></expr>:</case>
				<case>case <expr><name>VAR_SET_CURRENT</name></expr>:</case>
				<case>case <expr><name>VAR_SET_DEFAULT</name></expr>:</case>
				<case>case <expr><name>VAR_SET_MULTI</name></expr>:</case>
					<expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"SET"</literal></expr>;</expr_stmt>
					<break>break;</break>
				<case>case <expr><name>VAR_RESET</name></expr>:</case>
				<case>case <expr><name>VAR_RESET_ALL</name></expr>:</case>
					<expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"RESET"</literal></expr>;</expr_stmt>
					<break>break;</break>
				<default>default:</default>
					<expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"???"</literal></expr>;</expr_stmt>
			</block_content>}</block></switch>
			<break>break;</break>

		<case>case <expr><name>T_VariableShowStmt</name></expr>:</case>
			<expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"SHOW"</literal></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_DiscardStmt</name></expr>:</case>
			<switch>switch <condition>(<expr><operator>(</operator><operator>(</operator><name>DiscardStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name><operator>)</operator><operator>-&gt;</operator><name>target</name></expr>)</condition>
			<block>{<block_content>
				<case>case <expr><name>DISCARD_ALL</name></expr>:</case>
					<expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"DISCARD ALL"</literal></expr>;</expr_stmt>
					<break>break;</break>
				<case>case <expr><name>DISCARD_PLANS</name></expr>:</case>
					<expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"DISCARD PLANS"</literal></expr>;</expr_stmt>
					<break>break;</break>
				<case>case <expr><name>DISCARD_TEMP</name></expr>:</case>
					<expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"DISCARD TEMP"</literal></expr>;</expr_stmt>
					<break>break;</break>
				<case>case <expr><name>DISCARD_SEQUENCES</name></expr>:</case>
					<expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"DISCARD SEQUENCES"</literal></expr>;</expr_stmt>
					<break>break;</break>
				<default>default:</default>
					<expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"???"</literal></expr>;</expr_stmt>
			</block_content>}</block></switch>
			<break>break;</break>

		<case>case <expr><name>T_CreateTransformStmt</name></expr>:</case>
			<expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"CREATE TRANSFORM"</literal></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_CreateTrigStmt</name></expr>:</case>
			<expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"CREATE TRIGGER"</literal></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_CreateEventTrigStmt</name></expr>:</case>
			<expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"CREATE EVENT TRIGGER"</literal></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_AlterEventTrigStmt</name></expr>:</case>
			<expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"ALTER EVENT TRIGGER"</literal></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_CreatePLangStmt</name></expr>:</case>
			<expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"CREATE LANGUAGE"</literal></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_CreateRoleStmt</name></expr>:</case>
			<expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"CREATE ROLE"</literal></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_AlterRoleStmt</name></expr>:</case>
			<expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"ALTER ROLE"</literal></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_AlterRoleSetStmt</name></expr>:</case>
			<expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"ALTER ROLE"</literal></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_DropRoleStmt</name></expr>:</case>
			<expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"DROP ROLE"</literal></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_DropOwnedStmt</name></expr>:</case>
			<expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"DROP OWNED"</literal></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_ReassignOwnedStmt</name></expr>:</case>
			<expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"REASSIGN OWNED"</literal></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_LockStmt</name></expr>:</case>
			<expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"LOCK TABLE"</literal></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_ConstraintsSetStmt</name></expr>:</case>
			<expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"SET CONSTRAINTS"</literal></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_CheckPointStmt</name></expr>:</case>
			<expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"CHECKPOINT"</literal></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_ReindexStmt</name></expr>:</case>
			<expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"REINDEX"</literal></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_CreateConversionStmt</name></expr>:</case>
			<expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"CREATE CONVERSION"</literal></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_CreateCastStmt</name></expr>:</case>
			<expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"CREATE CAST"</literal></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_CreateOpClassStmt</name></expr>:</case>
			<expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"CREATE OPERATOR CLASS"</literal></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_CreateOpFamilyStmt</name></expr>:</case>
			<expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"CREATE OPERATOR FAMILY"</literal></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_AlterOpFamilyStmt</name></expr>:</case>
			<expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"ALTER OPERATOR FAMILY"</literal></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_AlterOperatorStmt</name></expr>:</case>
			<expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"ALTER OPERATOR"</literal></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_AlterTSDictionaryStmt</name></expr>:</case>
			<expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"ALTER TEXT SEARCH DICTIONARY"</literal></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_AlterTSConfigurationStmt</name></expr>:</case>
			<expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"ALTER TEXT SEARCH CONFIGURATION"</literal></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_CreatePolicyStmt</name></expr>:</case>
			<expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"CREATE POLICY"</literal></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_AlterPolicyStmt</name></expr>:</case>
			<expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"ALTER POLICY"</literal></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_CreateAmStmt</name></expr>:</case>
			<expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"CREATE ACCESS METHOD"</literal></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_CreatePublicationStmt</name></expr>:</case>
			<expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"CREATE PUBLICATION"</literal></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_AlterPublicationStmt</name></expr>:</case>
			<expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"ALTER PUBLICATION"</literal></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_CreateSubscriptionStmt</name></expr>:</case>
			<expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"CREATE SUBSCRIPTION"</literal></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_AlterSubscriptionStmt</name></expr>:</case>
			<expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"ALTER SUBSCRIPTION"</literal></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_DropSubscriptionStmt</name></expr>:</case>
			<expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"DROP SUBSCRIPTION"</literal></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_AlterCollationStmt</name></expr>:</case>
			<expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"ALTER COLLATION"</literal></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_PrepareStmt</name></expr>:</case>
			<expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"PREPARE"</literal></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_ExecuteStmt</name></expr>:</case>
			<expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"EXECUTE"</literal></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_CreateStatsStmt</name></expr>:</case>
			<expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"CREATE STATISTICS"</literal></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_DeallocateStmt</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>DeallocateStmt</name> <modifier>*</modifier></type><name>stmt</name> <init>= <expr><operator>(</operator><name>DeallocateStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></init></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>name</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"DEALLOCATE ALL"</literal></expr>;</expr_stmt></block_content></block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"DEALLOCATE"</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>
			</block_content>}</block>
			<break>break;</break>

			<comment type="block">/* already-planned queries */</comment>
		<case>case <expr><name>T_PlannedStmt</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>PlannedStmt</name> <modifier>*</modifier></type><name>stmt</name> <init>= <expr><operator>(</operator><name>PlannedStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></init></decl>;</decl_stmt>

				<switch>switch <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>commandType</name></name></expr>)</condition>
				<block>{<block_content>
					<case>case <expr><name>CMD_SELECT</name></expr>:</case>

						<comment type="block">/*
						 * We take a little extra care here so that the result
						 * will be useful for complaints about read-only
						 * statements
						 */</comment>
						<if_stmt><if>if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>rowMarks</name></name> <operator>!=</operator> <name>NIL</name></expr>)</condition>
						<block>{<block_content>
							<comment type="block">/* not 100% but probably close enough */</comment>
							<switch>switch <condition>(<expr><operator>(</operator><operator>(</operator><name>PlanRowMark</name> <operator>*</operator><operator>)</operator> <call><name>linitial</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>rowMarks</name></name></expr></argument>)</argument_list></call><operator>)</operator><operator>-&gt;</operator><name>strength</name></expr>)</condition>
							<block>{<block_content>
								<case>case <expr><name>LCS_FORKEYSHARE</name></expr>:</case>
									<expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"SELECT FOR KEY SHARE"</literal></expr>;</expr_stmt>
									<break>break;</break>
								<case>case <expr><name>LCS_FORSHARE</name></expr>:</case>
									<expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"SELECT FOR SHARE"</literal></expr>;</expr_stmt>
									<break>break;</break>
								<case>case <expr><name>LCS_FORNOKEYUPDATE</name></expr>:</case>
									<expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"SELECT FOR NO KEY UPDATE"</literal></expr>;</expr_stmt>
									<break>break;</break>
								<case>case <expr><name>LCS_FORUPDATE</name></expr>:</case>
									<expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"SELECT FOR UPDATE"</literal></expr>;</expr_stmt>
									<break>break;</break>
								<default>default:</default>
									<expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"SELECT"</literal></expr>;</expr_stmt>
									<break>break;</break>
							</block_content>}</block></switch>
						</block_content>}</block></if>
						<else>else<block type="pseudo"><block_content>
							<expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"SELECT"</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>
						<break>break;</break>
					<case>case <expr><name>CMD_UPDATE</name></expr>:</case>
						<expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"UPDATE"</literal></expr>;</expr_stmt>
						<break>break;</break>
					<case>case <expr><name>CMD_INSERT</name></expr>:</case>
						<expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"INSERT"</literal></expr>;</expr_stmt>
						<break>break;</break>
					<case>case <expr><name>CMD_DELETE</name></expr>:</case>
						<expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"DELETE"</literal></expr>;</expr_stmt>
						<break>break;</break>
					<case>case <expr><name>CMD_UTILITY</name></expr>:</case>
						<expr_stmt><expr><name>tag</name> <operator>=</operator> <call><name>CreateCommandTag</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>utilityStmt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<break>break;</break>
					<default>default:</default>
						<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>, <argument><expr><literal type="string">"unrecognized commandType: %d"</literal></expr></argument>,
							 <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name><name>stmt</name><operator>-&gt;</operator><name>commandType</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"???"</literal></expr>;</expr_stmt>
						<break>break;</break>
				</block_content>}</block></switch>
			</block_content>}</block>
			<break>break;</break>

			<comment type="block">/* parsed-and-rewritten-but-not-planned queries */</comment>
		<case>case <expr><name>T_Query</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>Query</name>	   <modifier>*</modifier></type><name>stmt</name> <init>= <expr><operator>(</operator><name>Query</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></init></decl>;</decl_stmt>

				<switch>switch <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>commandType</name></name></expr>)</condition>
				<block>{<block_content>
					<case>case <expr><name>CMD_SELECT</name></expr>:</case>

						<comment type="block">/*
						 * We take a little extra care here so that the result
						 * will be useful for complaints about read-only
						 * statements
						 */</comment>
						<if_stmt><if>if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>rowMarks</name></name> <operator>!=</operator> <name>NIL</name></expr>)</condition>
						<block>{<block_content>
							<comment type="block">/* not 100% but probably close enough */</comment>
							<switch>switch <condition>(<expr><operator>(</operator><operator>(</operator><name>RowMarkClause</name> <operator>*</operator><operator>)</operator> <call><name>linitial</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>rowMarks</name></name></expr></argument>)</argument_list></call><operator>)</operator><operator>-&gt;</operator><name>strength</name></expr>)</condition>
							<block>{<block_content>
								<case>case <expr><name>LCS_FORKEYSHARE</name></expr>:</case>
									<expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"SELECT FOR KEY SHARE"</literal></expr>;</expr_stmt>
									<break>break;</break>
								<case>case <expr><name>LCS_FORSHARE</name></expr>:</case>
									<expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"SELECT FOR SHARE"</literal></expr>;</expr_stmt>
									<break>break;</break>
								<case>case <expr><name>LCS_FORNOKEYUPDATE</name></expr>:</case>
									<expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"SELECT FOR NO KEY UPDATE"</literal></expr>;</expr_stmt>
									<break>break;</break>
								<case>case <expr><name>LCS_FORUPDATE</name></expr>:</case>
									<expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"SELECT FOR UPDATE"</literal></expr>;</expr_stmt>
									<break>break;</break>
								<default>default:</default>
									<expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"???"</literal></expr>;</expr_stmt>
									<break>break;</break>
							</block_content>}</block></switch>
						</block_content>}</block></if>
						<else>else<block type="pseudo"><block_content>
							<expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"SELECT"</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>
						<break>break;</break>
					<case>case <expr><name>CMD_UPDATE</name></expr>:</case>
						<expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"UPDATE"</literal></expr>;</expr_stmt>
						<break>break;</break>
					<case>case <expr><name>CMD_INSERT</name></expr>:</case>
						<expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"INSERT"</literal></expr>;</expr_stmt>
						<break>break;</break>
					<case>case <expr><name>CMD_DELETE</name></expr>:</case>
						<expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"DELETE"</literal></expr>;</expr_stmt>
						<break>break;</break>
					<case>case <expr><name>CMD_UTILITY</name></expr>:</case>
						<expr_stmt><expr><name>tag</name> <operator>=</operator> <call><name>CreateCommandTag</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>utilityStmt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<break>break;</break>
					<default>default:</default>
						<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>, <argument><expr><literal type="string">"unrecognized commandType: %d"</literal></expr></argument>,
							 <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name><name>stmt</name><operator>-&gt;</operator><name>commandType</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"???"</literal></expr>;</expr_stmt>
						<break>break;</break>
				</block_content>}</block></switch>
			</block_content>}</block>
			<break>break;</break>

		<default>default:</default>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>, <argument><expr><literal type="string">"unrecognized node type: %d"</literal></expr></argument>,
				 <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <call><name>nodeTag</name><argument_list>(<argument><expr><name>parsetree</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"???"</literal></expr>;</expr_stmt>
			<break>break;</break>
	</block_content>}</block></switch>

	<return>return <expr><name>tag</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * GetCommandLogLevel
 *		utility to get the minimum log_statement level for a command,
 *		given either a raw (un-analyzed) parsetree, an analyzed Query,
 *		or a PlannedStmt.
 *
 * This must handle all command types, but since the vast majority
 * of 'em are utility commands, it seems sensible to keep it here.
 */</comment>
<function><type><name>LogStmtLevel</name></type>
<name>GetCommandLogLevel</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>parsetree</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>LogStmtLevel</name></type> <name>lev</name></decl>;</decl_stmt>

	<switch>switch <condition>(<expr><call><name>nodeTag</name><argument_list>(<argument><expr><name>parsetree</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
			<comment type="block">/* recurse if we're given a RawStmt */</comment>
		<case>case <expr><name>T_RawStmt</name></expr>:</case>
			<expr_stmt><expr><name>lev</name> <operator>=</operator> <call><name>GetCommandLogLevel</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>RawStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name><operator>)</operator><operator>-&gt;</operator><name>stmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

			<comment type="block">/* raw plannable queries */</comment>
		<case>case <expr><name>T_InsertStmt</name></expr>:</case>
		<case>case <expr><name>T_DeleteStmt</name></expr>:</case>
		<case>case <expr><name>T_UpdateStmt</name></expr>:</case>
			<expr_stmt><expr><name>lev</name> <operator>=</operator> <name>LOGSTMT_MOD</name></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_SelectStmt</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><operator>(</operator><operator>(</operator><name>SelectStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name><operator>)</operator><operator>-&gt;</operator><name>intoClause</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>lev</name> <operator>=</operator> <name>LOGSTMT_DDL</name></expr>;</expr_stmt></block_content></block></if>	<comment type="block">/* SELECT INTO */</comment>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name>lev</name> <operator>=</operator> <name>LOGSTMT_ALL</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
			<break>break;</break>

			<comment type="block">/* utility statements --- same whether raw or cooked */</comment>
		<case>case <expr><name>T_TransactionStmt</name></expr>:</case>
			<expr_stmt><expr><name>lev</name> <operator>=</operator> <name>LOGSTMT_ALL</name></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_DeclareCursorStmt</name></expr>:</case>
			<expr_stmt><expr><name>lev</name> <operator>=</operator> <name>LOGSTMT_ALL</name></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_ClosePortalStmt</name></expr>:</case>
			<expr_stmt><expr><name>lev</name> <operator>=</operator> <name>LOGSTMT_ALL</name></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_FetchStmt</name></expr>:</case>
			<expr_stmt><expr><name>lev</name> <operator>=</operator> <name>LOGSTMT_ALL</name></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_CreateSchemaStmt</name></expr>:</case>
			<expr_stmt><expr><name>lev</name> <operator>=</operator> <name>LOGSTMT_DDL</name></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_CreateStmt</name></expr>:</case>
		<case>case <expr><name>T_CreateForeignTableStmt</name></expr>:</case>
			<expr_stmt><expr><name>lev</name> <operator>=</operator> <name>LOGSTMT_DDL</name></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_CreateTableSpaceStmt</name></expr>:</case>
		<case>case <expr><name>T_DropTableSpaceStmt</name></expr>:</case>
		<case>case <expr><name>T_AlterTableSpaceOptionsStmt</name></expr>:</case>
			<expr_stmt><expr><name>lev</name> <operator>=</operator> <name>LOGSTMT_DDL</name></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_CreateExtensionStmt</name></expr>:</case>
		<case>case <expr><name>T_AlterExtensionStmt</name></expr>:</case>
		<case>case <expr><name>T_AlterExtensionContentsStmt</name></expr>:</case>
			<expr_stmt><expr><name>lev</name> <operator>=</operator> <name>LOGSTMT_DDL</name></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_CreateFdwStmt</name></expr>:</case>
		<case>case <expr><name>T_AlterFdwStmt</name></expr>:</case>
		<case>case <expr><name>T_CreateForeignServerStmt</name></expr>:</case>
		<case>case <expr><name>T_AlterForeignServerStmt</name></expr>:</case>
		<case>case <expr><name>T_CreateUserMappingStmt</name></expr>:</case>
		<case>case <expr><name>T_AlterUserMappingStmt</name></expr>:</case>
		<case>case <expr><name>T_DropUserMappingStmt</name></expr>:</case>
		<case>case <expr><name>T_ImportForeignSchemaStmt</name></expr>:</case>
			<expr_stmt><expr><name>lev</name> <operator>=</operator> <name>LOGSTMT_DDL</name></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_DropStmt</name></expr>:</case>
			<expr_stmt><expr><name>lev</name> <operator>=</operator> <name>LOGSTMT_DDL</name></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_TruncateStmt</name></expr>:</case>
			<expr_stmt><expr><name>lev</name> <operator>=</operator> <name>LOGSTMT_MOD</name></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_CommentStmt</name></expr>:</case>
			<expr_stmt><expr><name>lev</name> <operator>=</operator> <name>LOGSTMT_DDL</name></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_SecLabelStmt</name></expr>:</case>
			<expr_stmt><expr><name>lev</name> <operator>=</operator> <name>LOGSTMT_DDL</name></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_CopyStmt</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><operator>(</operator><operator>(</operator><name>CopyStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name><operator>)</operator><operator>-&gt;</operator><name>is_from</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>lev</name> <operator>=</operator> <name>LOGSTMT_MOD</name></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name>lev</name> <operator>=</operator> <name>LOGSTMT_ALL</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
			<break>break;</break>

		<case>case <expr><name>T_PrepareStmt</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>PrepareStmt</name> <modifier>*</modifier></type><name>stmt</name> <init>= <expr><operator>(</operator><name>PrepareStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></init></decl>;</decl_stmt>

				<comment type="block">/* Look through a PREPARE to the contained stmt */</comment>
				<expr_stmt><expr><name>lev</name> <operator>=</operator> <call><name>GetCommandLogLevel</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>query</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block>
			<break>break;</break>

		<case>case <expr><name>T_ExecuteStmt</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>ExecuteStmt</name> <modifier>*</modifier></type><name>stmt</name> <init>= <expr><operator>(</operator><name>ExecuteStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>PreparedStatement</name> <modifier>*</modifier></type><name>ps</name></decl>;</decl_stmt>

				<comment type="block">/* Look through an EXECUTE to the referenced stmt */</comment>
				<expr_stmt><expr><name>ps</name> <operator>=</operator> <call><name>FetchPreparedStatement</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name>ps</name> <operator>&amp;&amp;</operator> <name><name>ps</name><operator>-&gt;</operator><name>plansource</name><operator>-&gt;</operator><name>raw_parse_tree</name></name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>lev</name> <operator>=</operator> <call><name>GetCommandLogLevel</name><argument_list>(<argument><expr><name><name>ps</name><operator>-&gt;</operator><name>plansource</name><operator>-&gt;</operator><name>raw_parse_tree</name><operator>-&gt;</operator><name>stmt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><name>lev</name> <operator>=</operator> <name>LOGSTMT_ALL</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
			</block_content>}</block>
			<break>break;</break>

		<case>case <expr><name>T_DeallocateStmt</name></expr>:</case>
			<expr_stmt><expr><name>lev</name> <operator>=</operator> <name>LOGSTMT_ALL</name></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_RenameStmt</name></expr>:</case>
			<expr_stmt><expr><name>lev</name> <operator>=</operator> <name>LOGSTMT_DDL</name></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_AlterObjectDependsStmt</name></expr>:</case>
			<expr_stmt><expr><name>lev</name> <operator>=</operator> <name>LOGSTMT_DDL</name></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_AlterObjectSchemaStmt</name></expr>:</case>
			<expr_stmt><expr><name>lev</name> <operator>=</operator> <name>LOGSTMT_DDL</name></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_AlterOwnerStmt</name></expr>:</case>
			<expr_stmt><expr><name>lev</name> <operator>=</operator> <name>LOGSTMT_DDL</name></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_AlterOperatorStmt</name></expr>:</case>
			<expr_stmt><expr><name>lev</name> <operator>=</operator> <name>LOGSTMT_DDL</name></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_AlterTableMoveAllStmt</name></expr>:</case>
		<case>case <expr><name>T_AlterTableStmt</name></expr>:</case>
			<expr_stmt><expr><name>lev</name> <operator>=</operator> <name>LOGSTMT_DDL</name></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_AlterDomainStmt</name></expr>:</case>
			<expr_stmt><expr><name>lev</name> <operator>=</operator> <name>LOGSTMT_DDL</name></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_GrantStmt</name></expr>:</case>
			<expr_stmt><expr><name>lev</name> <operator>=</operator> <name>LOGSTMT_DDL</name></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_GrantRoleStmt</name></expr>:</case>
			<expr_stmt><expr><name>lev</name> <operator>=</operator> <name>LOGSTMT_DDL</name></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_AlterDefaultPrivilegesStmt</name></expr>:</case>
			<expr_stmt><expr><name>lev</name> <operator>=</operator> <name>LOGSTMT_DDL</name></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_DefineStmt</name></expr>:</case>
			<expr_stmt><expr><name>lev</name> <operator>=</operator> <name>LOGSTMT_DDL</name></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_CompositeTypeStmt</name></expr>:</case>
			<expr_stmt><expr><name>lev</name> <operator>=</operator> <name>LOGSTMT_DDL</name></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_CreateEnumStmt</name></expr>:</case>
			<expr_stmt><expr><name>lev</name> <operator>=</operator> <name>LOGSTMT_DDL</name></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_CreateRangeStmt</name></expr>:</case>
			<expr_stmt><expr><name>lev</name> <operator>=</operator> <name>LOGSTMT_DDL</name></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_AlterEnumStmt</name></expr>:</case>
			<expr_stmt><expr><name>lev</name> <operator>=</operator> <name>LOGSTMT_DDL</name></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_ViewStmt</name></expr>:</case>
			<expr_stmt><expr><name>lev</name> <operator>=</operator> <name>LOGSTMT_DDL</name></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_CreateFunctionStmt</name></expr>:</case>
			<expr_stmt><expr><name>lev</name> <operator>=</operator> <name>LOGSTMT_DDL</name></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_AlterFunctionStmt</name></expr>:</case>
			<expr_stmt><expr><name>lev</name> <operator>=</operator> <name>LOGSTMT_DDL</name></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_IndexStmt</name></expr>:</case>
			<expr_stmt><expr><name>lev</name> <operator>=</operator> <name>LOGSTMT_DDL</name></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_RuleStmt</name></expr>:</case>
			<expr_stmt><expr><name>lev</name> <operator>=</operator> <name>LOGSTMT_DDL</name></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_CreateSeqStmt</name></expr>:</case>
			<expr_stmt><expr><name>lev</name> <operator>=</operator> <name>LOGSTMT_DDL</name></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_AlterSeqStmt</name></expr>:</case>
			<expr_stmt><expr><name>lev</name> <operator>=</operator> <name>LOGSTMT_DDL</name></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_DoStmt</name></expr>:</case>
			<expr_stmt><expr><name>lev</name> <operator>=</operator> <name>LOGSTMT_ALL</name></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_CreatedbStmt</name></expr>:</case>
			<expr_stmt><expr><name>lev</name> <operator>=</operator> <name>LOGSTMT_DDL</name></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_AlterDatabaseStmt</name></expr>:</case>
			<expr_stmt><expr><name>lev</name> <operator>=</operator> <name>LOGSTMT_DDL</name></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_AlterDatabaseSetStmt</name></expr>:</case>
			<expr_stmt><expr><name>lev</name> <operator>=</operator> <name>LOGSTMT_DDL</name></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_DropdbStmt</name></expr>:</case>
			<expr_stmt><expr><name>lev</name> <operator>=</operator> <name>LOGSTMT_DDL</name></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_NotifyStmt</name></expr>:</case>
			<expr_stmt><expr><name>lev</name> <operator>=</operator> <name>LOGSTMT_ALL</name></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_ListenStmt</name></expr>:</case>
			<expr_stmt><expr><name>lev</name> <operator>=</operator> <name>LOGSTMT_ALL</name></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_UnlistenStmt</name></expr>:</case>
			<expr_stmt><expr><name>lev</name> <operator>=</operator> <name>LOGSTMT_ALL</name></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_LoadStmt</name></expr>:</case>
			<expr_stmt><expr><name>lev</name> <operator>=</operator> <name>LOGSTMT_ALL</name></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_CallStmt</name></expr>:</case>
			<expr_stmt><expr><name>lev</name> <operator>=</operator> <name>LOGSTMT_ALL</name></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_ClusterStmt</name></expr>:</case>
			<expr_stmt><expr><name>lev</name> <operator>=</operator> <name>LOGSTMT_DDL</name></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_VacuumStmt</name></expr>:</case>
			<expr_stmt><expr><name>lev</name> <operator>=</operator> <name>LOGSTMT_ALL</name></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_ExplainStmt</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>ExplainStmt</name> <modifier>*</modifier></type><name>stmt</name> <init>= <expr><operator>(</operator><name>ExplainStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>bool</name></type>		<name>analyze</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

				<comment type="block">/* Look through an EXPLAIN ANALYZE to the contained stmt */</comment>
				<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>stmt-&gt;options</argument>)</argument_list></macro>
				<block>{<block_content>
					<decl_stmt><decl><type><name>DefElem</name>    <modifier>*</modifier></type><name>opt</name> <init>= <expr><operator>(</operator><name>DefElem</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

					<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>opt</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>, <argument><expr><literal type="string">"analyze"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><name>analyze</name> <operator>=</operator> <call><name>defGetBoolean</name><argument_list>(<argument><expr><name>opt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
					<comment type="block">/* don't "break", as explain.c will use the last value */</comment>
				</block_content>}</block>
				<if_stmt><if>if <condition>(<expr><name>analyze</name></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><call><name>GetCommandLogLevel</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>query</name></name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

				<comment type="block">/* Plain EXPLAIN isn't so interesting */</comment>
				<expr_stmt><expr><name>lev</name> <operator>=</operator> <name>LOGSTMT_ALL</name></expr>;</expr_stmt>
			</block_content>}</block>
			<break>break;</break>

		<case>case <expr><name>T_CreateTableAsStmt</name></expr>:</case>
			<expr_stmt><expr><name>lev</name> <operator>=</operator> <name>LOGSTMT_DDL</name></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_RefreshMatViewStmt</name></expr>:</case>
			<expr_stmt><expr><name>lev</name> <operator>=</operator> <name>LOGSTMT_DDL</name></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_AlterSystemStmt</name></expr>:</case>
			<expr_stmt><expr><name>lev</name> <operator>=</operator> <name>LOGSTMT_DDL</name></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_VariableSetStmt</name></expr>:</case>
			<expr_stmt><expr><name>lev</name> <operator>=</operator> <name>LOGSTMT_ALL</name></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_VariableShowStmt</name></expr>:</case>
			<expr_stmt><expr><name>lev</name> <operator>=</operator> <name>LOGSTMT_ALL</name></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_DiscardStmt</name></expr>:</case>
			<expr_stmt><expr><name>lev</name> <operator>=</operator> <name>LOGSTMT_ALL</name></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_CreateTrigStmt</name></expr>:</case>
			<expr_stmt><expr><name>lev</name> <operator>=</operator> <name>LOGSTMT_DDL</name></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_CreateEventTrigStmt</name></expr>:</case>
			<expr_stmt><expr><name>lev</name> <operator>=</operator> <name>LOGSTMT_DDL</name></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_AlterEventTrigStmt</name></expr>:</case>
			<expr_stmt><expr><name>lev</name> <operator>=</operator> <name>LOGSTMT_DDL</name></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_CreatePLangStmt</name></expr>:</case>
			<expr_stmt><expr><name>lev</name> <operator>=</operator> <name>LOGSTMT_DDL</name></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_CreateDomainStmt</name></expr>:</case>
			<expr_stmt><expr><name>lev</name> <operator>=</operator> <name>LOGSTMT_DDL</name></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_CreateRoleStmt</name></expr>:</case>
			<expr_stmt><expr><name>lev</name> <operator>=</operator> <name>LOGSTMT_DDL</name></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_AlterRoleStmt</name></expr>:</case>
			<expr_stmt><expr><name>lev</name> <operator>=</operator> <name>LOGSTMT_DDL</name></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_AlterRoleSetStmt</name></expr>:</case>
			<expr_stmt><expr><name>lev</name> <operator>=</operator> <name>LOGSTMT_DDL</name></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_DropRoleStmt</name></expr>:</case>
			<expr_stmt><expr><name>lev</name> <operator>=</operator> <name>LOGSTMT_DDL</name></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_DropOwnedStmt</name></expr>:</case>
			<expr_stmt><expr><name>lev</name> <operator>=</operator> <name>LOGSTMT_DDL</name></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_ReassignOwnedStmt</name></expr>:</case>
			<expr_stmt><expr><name>lev</name> <operator>=</operator> <name>LOGSTMT_DDL</name></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_LockStmt</name></expr>:</case>
			<expr_stmt><expr><name>lev</name> <operator>=</operator> <name>LOGSTMT_ALL</name></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_ConstraintsSetStmt</name></expr>:</case>
			<expr_stmt><expr><name>lev</name> <operator>=</operator> <name>LOGSTMT_ALL</name></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_CheckPointStmt</name></expr>:</case>
			<expr_stmt><expr><name>lev</name> <operator>=</operator> <name>LOGSTMT_ALL</name></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_ReindexStmt</name></expr>:</case>
			<expr_stmt><expr><name>lev</name> <operator>=</operator> <name>LOGSTMT_ALL</name></expr>;</expr_stmt>	<comment type="block">/* should this be DDL? */</comment>
			<break>break;</break>

		<case>case <expr><name>T_CreateConversionStmt</name></expr>:</case>
			<expr_stmt><expr><name>lev</name> <operator>=</operator> <name>LOGSTMT_DDL</name></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_CreateCastStmt</name></expr>:</case>
			<expr_stmt><expr><name>lev</name> <operator>=</operator> <name>LOGSTMT_DDL</name></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_CreateOpClassStmt</name></expr>:</case>
			<expr_stmt><expr><name>lev</name> <operator>=</operator> <name>LOGSTMT_DDL</name></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_CreateOpFamilyStmt</name></expr>:</case>
			<expr_stmt><expr><name>lev</name> <operator>=</operator> <name>LOGSTMT_DDL</name></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_CreateTransformStmt</name></expr>:</case>
			<expr_stmt><expr><name>lev</name> <operator>=</operator> <name>LOGSTMT_DDL</name></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_AlterOpFamilyStmt</name></expr>:</case>
			<expr_stmt><expr><name>lev</name> <operator>=</operator> <name>LOGSTMT_DDL</name></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_CreatePolicyStmt</name></expr>:</case>
			<expr_stmt><expr><name>lev</name> <operator>=</operator> <name>LOGSTMT_DDL</name></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_AlterPolicyStmt</name></expr>:</case>
			<expr_stmt><expr><name>lev</name> <operator>=</operator> <name>LOGSTMT_DDL</name></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_AlterTSDictionaryStmt</name></expr>:</case>
			<expr_stmt><expr><name>lev</name> <operator>=</operator> <name>LOGSTMT_DDL</name></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_AlterTSConfigurationStmt</name></expr>:</case>
			<expr_stmt><expr><name>lev</name> <operator>=</operator> <name>LOGSTMT_DDL</name></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_CreateAmStmt</name></expr>:</case>
			<expr_stmt><expr><name>lev</name> <operator>=</operator> <name>LOGSTMT_DDL</name></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_CreatePublicationStmt</name></expr>:</case>
			<expr_stmt><expr><name>lev</name> <operator>=</operator> <name>LOGSTMT_DDL</name></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_AlterPublicationStmt</name></expr>:</case>
			<expr_stmt><expr><name>lev</name> <operator>=</operator> <name>LOGSTMT_DDL</name></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_CreateSubscriptionStmt</name></expr>:</case>
			<expr_stmt><expr><name>lev</name> <operator>=</operator> <name>LOGSTMT_DDL</name></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_AlterSubscriptionStmt</name></expr>:</case>
			<expr_stmt><expr><name>lev</name> <operator>=</operator> <name>LOGSTMT_DDL</name></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_DropSubscriptionStmt</name></expr>:</case>
			<expr_stmt><expr><name>lev</name> <operator>=</operator> <name>LOGSTMT_DDL</name></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_CreateStatsStmt</name></expr>:</case>
			<expr_stmt><expr><name>lev</name> <operator>=</operator> <name>LOGSTMT_DDL</name></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_AlterCollationStmt</name></expr>:</case>
			<expr_stmt><expr><name>lev</name> <operator>=</operator> <name>LOGSTMT_DDL</name></expr>;</expr_stmt>
			<break>break;</break>

			<comment type="block">/* already-planned queries */</comment>
		<case>case <expr><name>T_PlannedStmt</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>PlannedStmt</name> <modifier>*</modifier></type><name>stmt</name> <init>= <expr><operator>(</operator><name>PlannedStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></init></decl>;</decl_stmt>

				<switch>switch <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>commandType</name></name></expr>)</condition>
				<block>{<block_content>
					<case>case <expr><name>CMD_SELECT</name></expr>:</case>
						<expr_stmt><expr><name>lev</name> <operator>=</operator> <name>LOGSTMT_ALL</name></expr>;</expr_stmt>
						<break>break;</break>

					<case>case <expr><name>CMD_UPDATE</name></expr>:</case>
					<case>case <expr><name>CMD_INSERT</name></expr>:</case>
					<case>case <expr><name>CMD_DELETE</name></expr>:</case>
						<expr_stmt><expr><name>lev</name> <operator>=</operator> <name>LOGSTMT_MOD</name></expr>;</expr_stmt>
						<break>break;</break>

					<case>case <expr><name>CMD_UTILITY</name></expr>:</case>
						<expr_stmt><expr><name>lev</name> <operator>=</operator> <call><name>GetCommandLogLevel</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>utilityStmt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<break>break;</break>

					<default>default:</default>
						<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>, <argument><expr><literal type="string">"unrecognized commandType: %d"</literal></expr></argument>,
							 <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name><name>stmt</name><operator>-&gt;</operator><name>commandType</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><name>lev</name> <operator>=</operator> <name>LOGSTMT_ALL</name></expr>;</expr_stmt>
						<break>break;</break>
				</block_content>}</block></switch>
			</block_content>}</block>
			<break>break;</break>

			<comment type="block">/* parsed-and-rewritten-but-not-planned queries */</comment>
		<case>case <expr><name>T_Query</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>Query</name>	   <modifier>*</modifier></type><name>stmt</name> <init>= <expr><operator>(</operator><name>Query</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></init></decl>;</decl_stmt>

				<switch>switch <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>commandType</name></name></expr>)</condition>
				<block>{<block_content>
					<case>case <expr><name>CMD_SELECT</name></expr>:</case>
						<expr_stmt><expr><name>lev</name> <operator>=</operator> <name>LOGSTMT_ALL</name></expr>;</expr_stmt>
						<break>break;</break>

					<case>case <expr><name>CMD_UPDATE</name></expr>:</case>
					<case>case <expr><name>CMD_INSERT</name></expr>:</case>
					<case>case <expr><name>CMD_DELETE</name></expr>:</case>
						<expr_stmt><expr><name>lev</name> <operator>=</operator> <name>LOGSTMT_MOD</name></expr>;</expr_stmt>
						<break>break;</break>

					<case>case <expr><name>CMD_UTILITY</name></expr>:</case>
						<expr_stmt><expr><name>lev</name> <operator>=</operator> <call><name>GetCommandLogLevel</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>utilityStmt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<break>break;</break>

					<default>default:</default>
						<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>, <argument><expr><literal type="string">"unrecognized commandType: %d"</literal></expr></argument>,
							 <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name><name>stmt</name><operator>-&gt;</operator><name>commandType</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><name>lev</name> <operator>=</operator> <name>LOGSTMT_ALL</name></expr>;</expr_stmt>
						<break>break;</break>
				</block_content>}</block></switch>

			</block_content>}</block>
			<break>break;</break>

		<default>default:</default>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>, <argument><expr><literal type="string">"unrecognized node type: %d"</literal></expr></argument>,
				 <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <call><name>nodeTag</name><argument_list>(<argument><expr><name>parsetree</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>lev</name> <operator>=</operator> <name>LOGSTMT_ALL</name></expr>;</expr_stmt>
			<break>break;</break>
	</block_content>}</block></switch>

	<return>return <expr><name>lev</name></expr>;</return>
</block_content>}</block></function>
</unit>
