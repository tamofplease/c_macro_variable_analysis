<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" revision="1.0.0" language="C" filename="/cloned_projects/PolarDB-for-PostgreSQL/src/backend/tcop/postgres_px.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * postgres_px.c
 *
 * Copyright (c) 2020, Alibaba Group Holding Limited
 * 
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * IDENTIFICATION
 *	  src/backend/tcop/postgres_px.c
 *
 *-------------------------------------------------------------------------
 */</comment>

<comment type="block">/* POLAR px */</comment>

<comment type="block">/*
 * exec_px_query
 *
 * Called in a qExec process to read and execute a query plan sent by PxDispatchPlan().
 *
 * query_string -- optional query text (C string).
 * serializedQuerytree[len]  -- Query node or (NULL,0) if plan provided.
 * serializedPlantree[len] -- PlannedStmt node, or (NULL,0) if query provided.
 * serializedParams[len] -- optional parameters
 * serializedQueryDispatchDesc[len] -- QueryDispatchDesc node, or (NULL,0) if query provided.
 *
 * Caller may supply either a Query (representing utility command) or
 * a PlannedStmt (representing a planned DML command), but not both.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>exec_px_query</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>query_string</name></decl></parameter>,
			   <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type> <name>serializedQuerytree</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>serializedQuerytreelen</name></decl></parameter>,
			   <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type> <name>serializedPlantree</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>serializedPlantreelen</name></decl></parameter>,
			   <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type> <name>serializedParams</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>serializedParamslen</name></decl></parameter>,
			   <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type> <name>serializedQueryDispatchDesc</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>serializedQueryDispatchDesclen</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>CommandDest</name></type> <name>dest</name> <init>= <expr><name>whereToSendOutput</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcontext</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>save_log_statement_stats</name> <init>= <expr><name>log_statement_stats</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>was_logged</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>msec_str</name><index>[<expr><literal type="number">32</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Node</name>		   <modifier>*</modifier></type><name>utilityStmt</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PlannedStmt</name>	   <modifier>*</modifier></type><name>plan</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>QueryDispatchDesc</name> <modifier>*</modifier></type><name>ddesc</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CmdType</name></type>		<name>commandType</name> <init>= <expr><name>CMD_UNKNOWN</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SliceTable</name> <modifier>*</modifier></type><name>sliceTable</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ExecSlice</name>  <modifier>*</modifier></type><name>slice</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ParamListInfo</name></type> <name>paramLI</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>px_role</name> <operator>==</operator> <name>PX_ROLE_PX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If we didn't get passed a query string, dummy something up for ps display and pg_stat_activity
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>query_string</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>query_string</name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>query_string</name> <operator>=</operator> <literal type="string">"polarpx"</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Report query to various monitoring facilities.
	 */</comment>

	<expr_stmt><expr><name>debug_query_string</name> <operator>=</operator> <name>query_string</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>pgstat_report_activity</name><argument_list>(<argument><expr><name>STATE_RUNNING</name></expr></argument>, <argument><expr><name>query_string</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * We use save_log_statement_stats so ShowUsage doesn't report incorrect
	 * results because ResetUsage wasn't called.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>save_log_statement_stats</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ResetUsage</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Start up a transaction command.	All queries generated by the
	 * query_string will be in this same command block, *unless* we find a
	 * BEGIN/COMMIT/ABORT statement; we have to force a new xact command after
	 * one of those, else bad things will happen in xact.c. (Note that this
	 * will normally change current memory context.)
	 */</comment>
	<expr_stmt><expr><call><name>start_xact_command</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Zap any pre-existing unnamed statement.	(While not strictly necessary,
	 * it seems best to define simple-Query mode as if it used the unnamed
	 * statement and portal; this ensures we recover any storage used by prior
	 * unnamed operations.)
	 */</comment>
	<expr_stmt><expr><call><name>drop_unnamed_stmt</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Switch to appropriate context for constructing parsetrees.
	 */</comment>
	<expr_stmt><expr><name>oldcontext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>MessageContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Deserialize the Query node, if there is one.  If this is a planned stmt, then
	 * there isn't one, but there must be a PlannedStmt later on.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>serializedQuerytree</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name>serializedQuerytreelen</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Query</name> <modifier>*</modifier></type><name>query</name> <init>= <expr><operator>(</operator><name>Query</name> <operator>*</operator><operator>)</operator> <call><name>deserializeNode</name><argument_list>(<argument><expr><name>serializedQuerytree</name></expr></argument>,<argument><expr><name>serializedQuerytreelen</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>( <expr><operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><name>Query</name></expr></argument>)</argument_list></call> <operator>||</operator> <name><name>query</name><operator>-&gt;</operator><name>commandType</name></name> <operator>!=</operator> <name>CMD_UTILITY</name></expr> )</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"POLARPX: received non-utility Query node."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>utilityStmt</name> <operator>=</operator> <name><name>query</name><operator>-&gt;</operator><name>utilityStmt</name></name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

 	<comment type="block">/*
     * Deserialize the query execution plan (a PlannedStmt node), if there is one.
     */</comment>
	<if_stmt><if>if <condition>(<expr><name>serializedPlantree</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name>serializedPlantreelen</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>plan</name> <operator>=</operator> <operator>(</operator><name>PlannedStmt</name> <operator>*</operator><operator>)</operator> <call><name>deserializeNode</name><argument_list>(<argument><expr><name>serializedPlantree</name></expr></argument>,<argument><expr><name>serializedPlantreelen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>plan</name> <operator>||</operator> <operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name>plan</name></expr></argument>, <argument><expr><name>PlannedStmt</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"POLARPX: receive invalid planned statement"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

	<comment type="block">/*
     * Deserialize the extra execution information (a QueryDispatchDesc node), if there is one.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>serializedQueryDispatchDesc</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name>serializedQueryDispatchDesclen</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
		<expr_stmt><expr><name>ddesc</name> <operator>=</operator> <operator>(</operator><name>QueryDispatchDesc</name> <operator>*</operator><operator>)</operator> <call><name>deserializeNode</name><argument_list>(<argument><expr><name>serializedQueryDispatchDesc</name></expr></argument>,<argument><expr><name>serializedQueryDispatchDesclen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>ddesc</name> <operator>||</operator> <operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name>ddesc</name></expr></argument>, <argument><expr><name>QueryDispatchDesc</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"POLARPX: received invalid QueryDispatchDesc with planned statement"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <expr_stmt><expr><name>sliceTable</name> <operator>=</operator> <name><name>ddesc</name><operator>-&gt;</operator><name>sliceTable</name></name></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>sliceTable</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name>sliceTable</name></expr></argument>, <argument><expr><name>SliceTable</name></expr></argument>)</argument_list></call> <operator>||</operator>
				<name><name>sliceTable</name><operator>-&gt;</operator><name>localSlice</name></name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator>
				<name><name>sliceTable</name><operator>-&gt;</operator><name>localSlice</name></name> <operator>&gt;=</operator> <name><name>sliceTable</name><operator>-&gt;</operator><name>numSlices</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"POLARPX: received invalid slice table: %d"</literal></expr></argument>, <argument><expr><name><name>sliceTable</name><operator>-&gt;</operator><name>localSlice</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<comment type="block">/* Identify slice to execute */</comment>
			<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>sliceTable</name><operator>-&gt;</operator><name>numSlices</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
			<block>{<block_content>
				<expr_stmt><expr><name>slice</name> <operator>=</operator> <operator>&amp;</operator><name><name>sliceTable</name><operator>-&gt;</operator><name>slices</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>

				<if_stmt><if>if <condition>(<expr><call><name>bms_is_member</name><argument_list>(<argument><expr><name>px_identifier</name></expr></argument>, <argument><expr><name><name>slice</name><operator>-&gt;</operator><name>processesMap</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<break>break;</break></block_content></block></if></if_stmt>
			</block_content>}</block></for>
			<if_stmt><if>if <condition>(<expr><name>i</name> <operator>==</operator> <name><name>sliceTable</name><operator>-&gt;</operator><name>numSlices</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"could not find PX identifier in process map"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><name><name>sliceTable</name><operator>-&gt;</operator><name>localSlice</name></name> <operator>=</operator> <name><name>slice</name><operator>-&gt;</operator><name>sliceIndex</name></name></expr>;</expr_stmt>

			<comment type="block">/* Set global sliceid variable for elog. */</comment>
			<expr_stmt><expr><name>currentSliceId</name> <operator>=</operator> <name><name>sliceTable</name><operator>-&gt;</operator><name>localSlice</name></name></expr>;</expr_stmt>

			<comment type="block">/* px_log_querydesc(ddesc); */</comment>

			<expr_stmt><expr><call><name>get_worker_info_by_identifier</name><argument_list>(<argument><expr><name>slice</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>px_logical_worker_idx</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>px_logical_total_workers</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>ic_htab_size</name> <operator>=</operator> <name>px_logical_total_workers</name> <operator>*</operator> <literal type="number">5</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>PxIdentity</name><operator>.</operator><name>workerid</name></name> <operator>=</operator> <name>px_logical_worker_idx</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>PxIdentity</name><operator>.</operator><name>dbid</name></name> <operator>=</operator> <name>px_logical_worker_idx</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><operator>(</operator><ternary><condition><expr><name>px_enable_print</name></expr> ?</condition><then> <expr><name>LOG</name></expr> </then><else>: <expr><name>DEBUG1</name></expr></else></ternary><operator>)</operator></expr></argument>,
		<argument><expr><literal type="string">"begin exec px query on node: local address %s, listen port %d, sessid %d, trace_id %ld, px_worker_id %d"</literal></expr></argument>, 
		<argument><expr><name>ListenAddresses</name></expr></argument>, <argument><expr><name>PostPortNumber</name></expr></argument>, <argument><expr><name>px_session_id</name></expr></argument>, <argument><expr><name><name>sql_trace_id</name><operator>.</operator><name>uval</name></name></expr></argument>, 
		<argument><expr><name>px_logical_worker_idx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Choose the command type from either the Query or the PlannedStmt.
	 */</comment>
    <if_stmt><if>if <condition>( <expr><name>utilityStmt</name></expr> )</condition><block type="pseudo"><block_content>
    	<expr_stmt><expr><name>commandType</name> <operator>=</operator> <name>CMD_UTILITY</name></expr>;</expr_stmt></block_content></block></if>
    <else>else
	<comment type="block">/*
	 * Get (possibly 0) parameters.
	 */</comment>
    <block>{<block_content>
    	<if_stmt><if>if <condition>( <expr><operator>!</operator><name>plan</name></expr> )</condition><block type="pseudo"><block_content>
    		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"POLARPX: received neither Query nor Plan"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    	<comment type="block">/* This must be a planned statement. */</comment>
	    <if_stmt><if>if <condition>(<expr><name><name>plan</name><operator>-&gt;</operator><name>commandType</name></name> <operator>!=</operator> <name>CMD_SELECT</name> <operator>&amp;&amp;</operator>
        	<name><name>plan</name><operator>-&gt;</operator><name>commandType</name></name> <operator>!=</operator> <name>CMD_INSERT</name> <operator>&amp;&amp;</operator>
        	<name><name>plan</name><operator>-&gt;</operator><name>commandType</name></name> <operator>!=</operator> <name>CMD_UPDATE</name> <operator>&amp;&amp;</operator>
        	<name><name>plan</name><operator>-&gt;</operator><name>commandType</name></name> <operator>!=</operator> <name>CMD_DELETE</name></expr>)</condition><block type="pseudo"><block_content>
        	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"POLARPX: received non-DML Plan"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <expr_stmt><expr><name>commandType</name> <operator>=</operator> <name><name>plan</name><operator>-&gt;</operator><name>commandType</name></name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
	<if_stmt><if>if <condition>( <expr><name>slice</name></expr> )</condition>
	<block>{<block_content>
		<comment type="block">/* Non root slices don't need update privileges. */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>sliceTable</name><operator>-&gt;</operator><name>localSlice</name></name> <operator>!=</operator> <name><name>slice</name><operator>-&gt;</operator><name>rootIndex</name></name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>ListCell</name>       <modifier>*</modifier></type><name>rtcell</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>RangeTblEntry</name>  <modifier>*</modifier></type><name>rte</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>AclMode</name></type>         <name>removeperms</name> <init>= <expr><name>ACL_INSERT</name> <operator>|</operator> <name>ACL_UPDATE</name> <operator>|</operator> <name>ACL_DELETE</name> <operator>|</operator> <name>ACL_SELECT_FOR_UPDATE</name></expr></init></decl>;</decl_stmt>

			<comment type="block">/* Just reading, so don't check INS/DEL/UPD permissions. */</comment>
			<macro><name>foreach</name><argument_list>(<argument>rtcell</argument>, <argument>plan-&gt;rtable</argument>)</argument_list></macro>
			<block>{<block_content>
				<expr_stmt><expr><name>rte</name> <operator>=</operator> <operator>(</operator><name>RangeTblEntry</name> <operator>*</operator><operator>)</operator><call><name>lfirst</name><argument_list>(<argument><expr><name>rtcell</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name><name>rte</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>==</operator> <name>RTE_RELATION</name> <operator>&amp;&amp;</operator>
					<literal type="number">0</literal> <operator>!=</operator> <operator>(</operator><name><name>rte</name><operator>-&gt;</operator><name>requiredPerms</name></name> <operator>&amp;</operator> <name>removeperms</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name><name>rte</name><operator>-&gt;</operator><name>requiredPerms</name></name> <operator>&amp;=</operator> <operator>~</operator><name>removeperms</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>


	<if_stmt><if>if <condition>(<expr><name>log_statement</name> <operator>!=</operator> <name>LOGSTMT_NONE</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * TODO need to log SELECT INTO as DDL
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>log_statement</name> <operator>==</operator> <name>LOGSTMT_ALL</name> <operator>||</operator>
			<operator>(</operator><name>utilityStmt</name> <operator>&amp;&amp;</operator> <name>log_statement</name> <operator>==</operator> <name>LOGSTMT_DDL</name><operator>)</operator> <operator>||</operator>
			<operator>(</operator><name>plan</name> <operator>&amp;&amp;</operator> <name>log_statement</name> <operator>&gt;=</operator> <name>LOGSTMT_MOD</name><operator>)</operator></expr>)</condition>

		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"statement: %s"</literal></expr></argument>, <argument><expr><name>query_string</name></expr></argument>)</argument_list></call>
						   <operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>was_logged</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Get (possibly 0) parameters.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>serializedParams</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name>serializedParamslen</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>paramLI</name> <operator>=</operator> <call><name>deserializeParamListInfo</name><argument_list>(<argument><expr><name>serializedParams</name></expr></argument>, <argument><expr><name>serializedParamslen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>paramLI</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/*
	 * Switch back to transaction context to enter the loop.
	 */</comment>
	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * All unpacked and checked.  Process the command.
	 */</comment>
	<block>{<block_content>
		<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>commandTag</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name></type>		<name><name>completionTag</name><index>[<expr><name>COMPLETION_TAG_BUFSIZE</name></expr>]</index></name></decl>;</decl_stmt>

		<decl_stmt><decl><type><name>Portal</name></type>		<name>portal</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>DestReceiver</name> <modifier>*</modifier></type><name>receiver</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int16</name></type>		<name>format</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Snapshot</name></type>	<name>snapshot</name> <init>= <expr><name>InvalidSnapshot</name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>pxsn_get_serialized_snapshot_data</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>snapshot</name> <operator>=</operator> <call><name>RestoreSnapshot</name><argument_list>(<argument><expr><call><name>pxsn_get_serialized_snapshot_data</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * Get the command name for use in status display (it also becomes the
		 * default completion tag, down inside PortalRun).	Set ps_status and
		 * do any special start-of-SQL-command processing needed by the
		 * destination.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>commandType</name> <operator>==</operator> <name>CMD_UTILITY</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>commandTag</name> <operator>=</operator> <literal type="string">"POLARPX UTILITY"</literal></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><name>commandType</name> <operator>==</operator> <name>CMD_SELECT</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>commandTag</name> <operator>=</operator> <literal type="string">"POLARPX SELECT"</literal></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><name>commandType</name> <operator>==</operator> <name>CMD_INSERT</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>commandTag</name> <operator>=</operator> <literal type="string">"POLARPX INSERT"</literal></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><name>commandType</name> <operator>==</operator> <name>CMD_UPDATE</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>commandTag</name> <operator>=</operator> <literal type="string">"POLARPX UPDATE"</literal></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><name>commandType</name> <operator>==</operator> <name>CMD_DELETE</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>commandTag</name> <operator>=</operator> <literal type="string">"POLARPX DELETE"</literal></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>commandTag</name> <operator>=</operator> <literal type="string">"POLARPX"</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>


		<expr_stmt><expr><call><name>set_ps_display</name><argument_list>(<argument><expr><name>commandTag</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>BeginCommand</name><argument_list>(<argument><expr><name>commandTag</name></expr></argument>, <argument><expr><name>dest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * If we are in an aborted transaction, reject all commands except
		 * COMMIT/ABORT.  It is important that this test occur before we try
		 * to do parse analysis, rewrite, or planning, since all those phases
		 * try to do database accesses, which may fail in abort state. (It
		 * might be safe to allow some additional utility commands in this
		 * state, but not many...)
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>IsAbortedTransactionBlockState</name><argument_list>()</argument_list></call></expr> <comment type="block">/*&amp;&amp;*/</comment>
			<comment type="block" format="doxygen">/*!IsTransactionExitStmt(parsetree)*/</comment>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_IN_FAILED_SQL_TRANSACTION</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"current transaction is aborted, "</literal>
							<literal type="string">"commands ignored until end of transaction block"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/* Make sure we are in a transaction command */</comment>
		<expr_stmt><expr><call><name>start_xact_command</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* If we got a cancel signal in parsing or prior command, quit */</comment>
		<expr_stmt><expr><call><name>CHECK_FOR_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * OK to analyze, rewrite, and plan this query.
		 *
		 * Switch to appropriate context for constructing querytrees (again,
		 * these must outlive the execution context).
		 */</comment>
		<expr_stmt><expr><name>oldcontext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>MessageContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* If we got a cancel signal in analysis or planning, quit */</comment>
		<expr_stmt><expr><call><name>CHECK_FOR_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Create unnamed portal to run the query or queries in. If there
		 * already is one, silently drop it.
		 */</comment>
		<expr_stmt><expr><name>portal</name> <operator>=</operator> <call><name>CreatePortal</name><argument_list>(<argument><expr><literal type="string">""</literal></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* Don't display the portal in pg_cursors */</comment>
		<expr_stmt><expr><name><name>portal</name><operator>-&gt;</operator><name>visible</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

		<comment type="block">/*
		 * We don't have to copy anything into the portal, because everything
		 * we are passing here is in MessageContext, which will outlive the
		 * portal anyway.
		 */</comment>
		<expr_stmt><expr><call><name>PortalDefineQuery</name><argument_list>(<argument><expr><name>portal</name></expr></argument>,
						  <argument><expr><name>NULL</name></expr></argument>,
						  <argument><expr><name>query_string</name></expr></argument>,
						  <argument><expr><name>T_Query</name></expr></argument>, <comment type="block">/* not a parsed statement, so not T_SelectStmt */</comment>
						  <argument><expr><name>commandTag</name></expr></argument>,
						  <argument><expr><call><name>list_make1</name><argument_list>(<argument><expr><ternary><condition><expr><name>plan</name></expr> ?</condition><then> <expr><operator>(</operator><name>Node</name><operator>*</operator><operator>)</operator><name>plan</name></expr> </then><else>: <expr><operator>(</operator><name>Node</name><operator>*</operator><operator>)</operator><name>utilityStmt</name></expr></else></ternary></expr></argument>)</argument_list></call></expr></argument>,
						  <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Start the portal.
		 */</comment>
		<expr_stmt><expr><call><name>PortalStart</name><argument_list>(<argument><expr><name>portal</name></expr></argument>, 
					<argument><expr><name>paramLI</name></expr></argument>, 
					<argument><expr><literal type="number">0</literal></expr></argument>, 
					<argument><expr><name>snapshot</name></expr></argument>, 
					<argument><expr><name>ddesc</name></expr></argument><comment type="block">/* POALR px */</comment>
					)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Select text output format, the default.
		 */</comment>
		<expr_stmt><expr><name>format</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>PortalSetResultFormat</name><argument_list>(<argument><expr><name>portal</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>format</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Now we can create the destination receiver object.
		 */</comment>
		<expr_stmt><expr><name>receiver</name> <operator>=</operator> <call><name>CreateDestReceiver</name><argument_list>(<argument><expr><name>dest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>dest</name> <operator>==</operator> <name>DestRemote</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>SetRemoteDestReceiverParams</name><argument_list>(<argument><expr><name>receiver</name></expr></argument>, <argument><expr><name>portal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * Switch back to transaction context for execution.
		 */</comment>
		<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Run the portal to completion, and then drop it (and the receiver).
		 */</comment>
		<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>PortalRun</name><argument_list>(<argument><expr><name>portal</name></expr></argument>,
						 <argument><expr><name>FETCH_ALL</name></expr></argument>,
						 <argument><expr><name>true</name></expr></argument>, <comment type="block">/* Effectively always top level. */</comment>
						 <argument><expr><name>true</name></expr></argument>,
						 <argument><expr><name>receiver</name></expr></argument>,
						 <argument><expr><name>receiver</name></expr></argument>,
						 <argument><expr><name>completionTag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call>(<modifier>*</modifier><name><name>receiver</name><operator>-&gt;</operator><name>rDestroy</name></name>) <argument_list>(<argument><expr><name>receiver</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>PortalDrop</name><argument_list>(<argument><expr><name>portal</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Close down transaction statement before reporting command-complete.
		 * This is so that any end-of-transaction errors are reported before
		 * the command-complete message is issued, to avoid confusing
		 * clients who will expect either a command-complete message or an
		 * error, not one and then the other.
		 */</comment>
		<expr_stmt><expr><call><name>finish_xact_command</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Tell client that we're done with this query.  Note we emit exactly
		 * one EndCommand report for each raw parsetree, thus one for each SQL
		 * command the client sent, regardless of rewriting. (But a command
		 * aborted by error will not send an EndCommand report at all.)
		 */</comment>
		<expr_stmt><expr><call><name>EndCommand</name><argument_list>(<argument><expr><name>completionTag</name></expr></argument>, <argument><expr><name>dest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>							<comment type="block">/* end loop over parsetrees */</comment>

	<comment type="block">/*
	 * Close down transaction statement, if one is open.
	 */</comment>
	<expr_stmt><expr><call><name>finish_xact_command</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Emit duration logging if appropriate.
	 */</comment>
	<switch>switch <condition>(<expr><call><name>check_log_duration</name><argument_list>(<argument><expr><name>msec_str</name></expr></argument>, <argument><expr><name>was_logged</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><literal type="number">1</literal></expr>:</case>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"duration: %s ms"</literal></expr></argument>, <argument><expr><name>msec_str</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errhidestmt</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><literal type="number">2</literal></expr>:</case>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"duration: %s ms  statement: %s"</literal></expr></argument>,
							<argument><expr><name>msec_str</name></expr></argument>, <argument><expr><name>query_string</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errhidestmt</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
	</block_content>}</block></switch>

	<if_stmt><if>if <condition>(<expr><name>save_log_statement_stats</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ShowUsage</name><argument_list>(<argument><expr><literal type="string">"QUERY STATISTICS"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>debug_query_string</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
</block_content>}</block></function>
</unit>
