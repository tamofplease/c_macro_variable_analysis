<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/PolarDB-for-PostgreSQL/src/backend/tcop/postgres.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * postgres.c
 *	  POSTGRES C Backend Interface
 *
 * Portions Copyright (c) 1996-2018, PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, Regents of the University of California
 *
 *
 * IDENTIFICATION
 *	  src/backend/tcop/postgres.c
 *
 * NOTES
 *	  this is the "main" module of the postgres backend and
 *	  hence the main module of the "traffic cop".
 *
 *-------------------------------------------------------------------------
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;fcntl.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;limits.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;signal.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;unistd.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/socket.h&gt;</cpp:file></cpp:include>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_SYS_SELECT_H</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/select.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_SYS_RESOURCE_H</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/time.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/resource.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>HAVE_GETRUSAGE</name></cpp:ifndef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"rusagestub.h"</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/parallel.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/printtup.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/xact.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_type.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/async.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/prepare.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"common/file_perm.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/spi.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jit/jit.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"libpq/libpq.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"libpq/pqformat.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"libpq/pqsignal.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/print.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/planner.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pgstat.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pg_trace.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/analyze.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parser.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pg_getopt.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postmaster/autovacuum.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postmaster/postmaster.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postmaster/syslogger.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"replication/logicallauncher.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"replication/logicalworker.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"replication/slot.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"replication/walsender.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"rewrite/rewriteHandler.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/bufmgr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/fd.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/ipc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/kmgr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/proc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/procsignal.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/sinval.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"tcop/fastpath.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"tcop/pquery.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"tcop/tcopprot.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"tcop/utility.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/lsyscache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/memutils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/polar_coredump.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/ps_status.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/snapmgr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/timeout.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/timestamp.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"mb/pg_wchar.h"</cpp:file></cpp:include>

<comment type="block">/* POLAR */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/polar_logindex.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/xlog_internal.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"libpq/polar_network_stats.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parse_param.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/polar_fd.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/polar_sql_time_stat.h"</cpp:file></cpp:include>

<comment type="block">/* POLAR px */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"px/px_disp_query.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"px/px_gang.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"px/px_snapshot.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"px/px_srlz.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"px/px_vars.h"</cpp:file></cpp:include>

<comment type="block">/* ----------------
 *		global variables
 * ----------------
 */</comment>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>debug_query_string</name></decl>;</decl_stmt> <comment type="block">/* client-supplied query string */</comment>

<comment type="block">/* POLAR: point to audit log */</comment>
<decl_stmt><decl><type><name>Pg_audit_log</name></type> <name>polar_audit_log</name></decl>;</decl_stmt>

<comment type="block">/* Note: whereToSendOutput is initialized for the bootstrap/standalone case */</comment>
<decl_stmt><decl><type><name>CommandDest</name></type> <name>whereToSendOutput</name> <init>= <expr><name>DestDebug</name></expr></init></decl>;</decl_stmt>

<comment type="block">/* flag for logging end of session */</comment>
<decl_stmt><decl><type><name>bool</name></type>		<name>Log_disconnections</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type>			<name>log_statement</name> <init>= <expr><name>LOGSTMT_NONE</name></expr></init></decl>;</decl_stmt>

<comment type="block">/* GUC variable for maximum stack depth (measured in kilobytes) */</comment>
<decl_stmt><decl><type><name>int</name></type>			<name>max_stack_depth</name> <init>= <expr><literal type="number">100</literal></expr></init></decl>;</decl_stmt>

<comment type="block">/* wait N seconds to allow attach from a debugger */</comment>
<decl_stmt><decl><type><name>int</name></type>			<name>PostAuthDelay</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>


<comment type="block">/* POALR */</comment>
<decl_stmt><decl><type><name>TimestampTz</name></type> <name>polar_last_audit_log_flush_time</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<comment type="block">/* POALR: end */</comment>

<comment type="block">/* ----------------
 *		private variables
 * ----------------
 */</comment>

<comment type="block">/* max_stack_depth converted to bytes for speed of checking */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>long</name></type> <name>max_stack_depth_bytes</name> <init>= <expr><literal type="number">100</literal> <operator>*</operator> <literal type="number">1024L</literal></expr></init></decl>;</decl_stmt>

<comment type="block">/*
 * Stack base pointer -- initialized by PostmasterMain and inherited by
 * subprocesses. This is not static because old versions of PL/Java modify
 * it directly. Newer versions use set_stack_base(), but we want to stay
 * binary-compatible for the time being.
 */</comment>
<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>stack_base_ptr</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<comment type="block">/*
 * On IA64 we also have to remember the register stack base.
 */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__ia64__</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>__ia64</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>register_stack_base_ptr</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
 * Flag to keep track of whether we have started a transaction.
 * For extended query protocol this has to be remembered across messages.
 */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type> <name>xact_started</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

<comment type="block">/*
 * Flag to indicate that we are doing the outer loop's read-from-client,
 * as opposed to any random read from client that might happen within
 * commands like COPY FROM STDIN.
 */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type> <name>DoingCommandRead</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

<comment type="block">/*
 * Flags to implement skip-till-Sync-after-error behavior for messages of
 * the extended query protocol.
 */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type> <name>doing_extended_query_message</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type> <name>ignore_till_sync</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

<comment type="block">/*
 * Flag to keep track of whether statement timeout timer is active.
 */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type> <name>stmt_timeout_active</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

<comment type="block">/*
 * If an unnamed prepared statement exists, it's stored here.
 * We keep it separate from the hashtable kept by commands/prepare.c
 * in order to reduce overhead for short-lived queries.
 */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>CachedPlanSource</name> <modifier>*</modifier></type><name>unnamed_stmt_psrc</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<comment type="block">/* assorted command-line switches */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>userDoption</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>	<comment type="block">/* -D switch */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type> <name>EchoQuery</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>	<comment type="block">/* -E switch */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type> <name>UseSemiNewlineNewline</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>	<comment type="block">/* -j switch */</comment>

<comment type="block">/* whether or not, and why, we were canceled by conflict with recovery */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type> <name>RecoveryConflictPending</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type> <name>RecoveryConflictRetryable</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>ProcSignalReason</name></type> <name>RecoveryConflictReason</name></decl>;</decl_stmt>

<comment type="block">/* reused buffer to pass to SendRowDescriptionMessage() */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>MemoryContext</name></type> <name>row_description_context</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>StringInfoData</name></type> <name>row_description_buf</name></decl>;</decl_stmt>

<comment type="block">/*
 * POLAR: Flag to mark OOM cancel query signal.When OOM cancel signal comes,
 * it will be true
 */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type> <name>got_oom_cancel_signal</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

<comment type="block">/*
 * POLAR: use this flag to check interrupt when px initialize,
 * like DoingCommandRead
 */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type> <name>px_check_interrupt</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

<comment type="block">/* ----------------------------------------------------------------
 *		decls for routines only used in this file
 * ----------------------------------------------------------------
 */</comment>
<function_decl><type><specifier>static</specifier> <name>int</name></type>	<name>InteractiveBackend</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>inBuf</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type>	<name>interactive_getc</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type>	<name>SocketBackend</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>inBuf</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type>	<name>ReadCommand</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>inBuf</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>forbidden_in_wal_sender</name><parameter_list>(<parameter><decl><type><name>char</name></type> <name>firstchar</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type><name>pg_rewrite_query</name><parameter_list>(<parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>query</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>check_log_statement</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>stmt_list</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type>	<name>errdetail_execute</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>raw_parsetree_list</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type>	<name>errdetail_abort</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type>	<name>errdetail_recovery_conflict</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>start_xact_command</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>finish_xact_command</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>IsTransactionExitStmt</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>parsetree</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>IsTransactionExitStmtList</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>pstmts</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>IsTransactionStmtList</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>pstmts</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>drop_unnamed_stmt</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>log_disconnections</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>code</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>arg</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>enable_statement_timeout</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>disable_statement_timeout</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/* POLAR: for oom handle */</comment>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>SigCancelQueryHandler</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>polar_procsignal_sigusr2_handler</name><parameter_list>(<parameter><decl><type><name>SIGNAL_ARGS</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>polar_stmt_type_needs_mask</name><parameter_list>(<parameter><decl><type><name>NodeTag</name></type> <name>tag</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>char</name>	<modifier>*</modifier></type><name>polar_get_errmsg_params</name><parameter_list>(<parameter><decl><type><name>ParamListInfo</name></type> <name>params</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>polar_save_stack_info</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>polar_bind_sql_with_parameter</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type> <name>stmt_name</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>ParamListInfo</name></type> <name>params</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>sourceText</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/* POLAR: for flush audit log, return buffer status */</comment>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>polar_audit_log_flush_callback</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>code</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>arg</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>extern</specifier> <name>bool</name></type> <name>polar_audit_log_buffer_is_null</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/* POLAR px */</comment>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>exec_px_query</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>query_string</name></decl></parameter>,
			   <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type> <name>serializedQuerytree</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>serializedQuerytreelen</name></decl></parameter>,
			   <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type> <name>serializedPlantree</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>serializedPlantreelen</name></decl></parameter>,
			   <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type> <name>serializedParams</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>serializedParamslen</name></decl></parameter>,
			   <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type> <name>serializedQueryDispatchDesc</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>serializedQueryDispatchDesclen</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/* POLAR: handle cancel query interrupt during client read/write */</comment>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>polar_process_client_readwrite_cancel_interrupt</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/* ----------------------------------------------------------------
 *		routines to obtain user input
 * ----------------------------------------------------------------
 */</comment>

<comment type="block">/* ----------------
 *	InteractiveBackend() is called for user interactive connections
 *
 *	the string entered by the user is placed in its parameter inBuf,
 *	and we act like a Q message was received.
 *
 *	EOF is returned if end-of-file input is seen; time to shut down.
 * ----------------
 */</comment>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>InteractiveBackend</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>inBuf</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>c</name></decl>;</decl_stmt>				<comment type="block">/* character read from getc() */</comment>

	<comment type="block">/*
	 * display a prompt and obtain input from the user
	 */</comment>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"backend&gt; "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>fflush</name><argument_list>(<argument><expr><name>stdout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>resetStringInfo</name><argument_list>(<argument><expr><name>inBuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Read characters until EOF or the appropriate delimiter is seen.
	 */</comment>
	<while>while <condition>(<expr><operator>(</operator><name>c</name> <operator>=</operator> <call><name>interactive_getc</name><argument_list>()</argument_list></call><operator>)</operator> <operator>!=</operator> <name>EOF</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>c</name> <operator>==</operator> <literal type="char">'\n'</literal></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>UseSemiNewlineNewline</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/*
				 * In -j mode, semicolon followed by two newlines ends the
				 * command; otherwise treat newline as regular character.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><name><name>inBuf</name><operator>-&gt;</operator><name>len</name></name> <operator>&gt;</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator>
					<name><name>inBuf</name><operator>-&gt;</operator><name>data</name><index>[<expr><name><name>inBuf</name><operator>-&gt;</operator><name>len</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'\n'</literal> <operator>&amp;&amp;</operator>
					<name><name>inBuf</name><operator>-&gt;</operator><name>data</name><index>[<expr><name><name>inBuf</name><operator>-&gt;</operator><name>len</name></name> <operator>-</operator> <literal type="number">2</literal></expr>]</index></name> <operator>==</operator> <literal type="char">';'</literal></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/* might as well drop the second newline */</comment>
					<break>break;</break>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<comment type="block">/*
				 * In plain mode, newline ends the command unless preceded by
				 * backslash.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><name><name>inBuf</name><operator>-&gt;</operator><name>len</name></name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
					<name><name>inBuf</name><operator>-&gt;</operator><name>data</name><index>[<expr><name><name>inBuf</name><operator>-&gt;</operator><name>len</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'\\'</literal></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/* discard backslash from inBuf */</comment>
					<expr_stmt><expr><name><name>inBuf</name><operator>-&gt;</operator><name>data</name><index>[<expr><operator>--</operator><name><name>inBuf</name><operator>-&gt;</operator><name>len</name></name></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
					<comment type="block">/* discard newline too */</comment>
					<continue>continue;</continue>
				</block_content>}</block></if>
				<else>else
				<block>{<block_content>
					<comment type="block">/* keep the newline character, but end the command */</comment>
					<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>inBuf</name></expr></argument>, <argument><expr><literal type="char">'\n'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<break>break;</break>
				</block_content>}</block></else></if_stmt>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* Not newline, or newline treated as regular character */</comment>
		<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>inBuf</name></expr></argument>, <argument><expr><operator>(</operator><name>char</name><operator>)</operator> <name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></while>

	<comment type="block">/* No input before EOF signal means time to quit. */</comment>
	<if_stmt><if>if <condition>(<expr><name>c</name> <operator>==</operator> <name>EOF</name> <operator>&amp;&amp;</operator> <name><name>inBuf</name><operator>-&gt;</operator><name>len</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>EOF</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * otherwise we have a user query so process it.
	 */</comment>

	<comment type="block">/* Add '\0' to make it look the same as message case. */</comment>
	<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>inBuf</name></expr></argument>, <argument><expr><operator>(</operator><name>char</name><operator>)</operator> <literal type="char">'\0'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * if the query echo flag was given, print the query..
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>EchoQuery</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"statement: %s\n"</literal></expr></argument>, <argument><expr><name><name>inBuf</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><call><name>fflush</name><argument_list>(<argument><expr><name>stdout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><literal type="char">'Q'</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * interactive_getc -- collect one character from stdin
 *
 * Even though we are not reading from a "client" process, we still want to
 * respond to signals, particularly SIGTERM/SIGQUIT.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>interactive_getc</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>c</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * This will not process catchup interrupts or notifications while
	 * reading. But those can't really be relevant for a standalone backend
	 * anyway. To properly handle SIGTERM there's a hack in die() that
	 * directly processes interrupts at this stage...
	 */</comment>
	<expr_stmt><expr><call><name>CHECK_FOR_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>c</name> <operator>=</operator> <call><name>getc</name><argument_list>(<argument><expr><name>stdin</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ProcessClientReadInterrupt</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>c</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* ----------------
 *	SocketBackend()		Is called for frontend-backend connections
 *
 *	Returns the message type code, and loads message body data into inBuf.
 *
 *	EOF is returned if the connection is lost.
 * ----------------
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>SocketBackend</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>inBuf</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>qtype</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Get message type code from the frontend.
	 */</comment>
	<expr_stmt><expr><call><name>HOLD_CANCEL_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pq_startmsgread</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>qtype</name> <operator>=</operator> <call><name>pq_getbyte</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>qtype</name> <operator>==</operator> <name>EOF</name></expr>)</condition>			<comment type="block">/* frontend disconnected */</comment>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>IsTransactionState</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>COMMERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_CONNECTION_FAILURE</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"unexpected EOF on client connection with an open transaction"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/*
			 * Can't send DEBUG log messages to client at this point. Since
			 * we're disconnecting right away, we don't need to restore
			 * whereToSendOutput.
			 */</comment>
			<expr_stmt><expr><name>whereToSendOutput</name> <operator>=</operator> <name>DestNone</name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_CONNECTION_DOES_NOT_EXIST</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"unexpected EOF on client connection"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
		<return>return <expr><name>qtype</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Validate message type code before trying to read body; if we have lost
	 * sync, better to say "command unknown" than to run out of memory because
	 * we used garbage as a length word.
	 *
	 * This also gives us a place to set the doing_extended_query_message flag
	 * as soon as possible.
	 */</comment>
	<switch>switch <condition>(<expr><name>qtype</name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><literal type="char">'Q'</literal></expr>:</case>				<comment type="block">/* simple query */</comment>
			<expr_stmt><expr><name>doing_extended_query_message</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><call><name>PG_PROTOCOL_MAJOR</name><argument_list>(<argument><expr><name>FrontendProtocol</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">3</literal></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* old style without length word; convert */</comment>
				<if_stmt><if>if <condition>(<expr><call><name>pq_getstring</name><argument_list>(<argument><expr><name>inBuf</name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<if_stmt><if>if <condition>(<expr><call><name>IsTransactionState</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>COMMERROR</name></expr></argument>,
								<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_CONNECTION_FAILURE</name></expr></argument>)</argument_list></call><operator>,</operator>
								 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"unexpected EOF on client connection with an open transaction"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
					<else>else
					<block>{<block_content>
						<comment type="block">/*
						 * Can't send DEBUG log messages to client at this
						 * point. Since we're disconnecting right away, we
						 * don't need to restore whereToSendOutput.
						 */</comment>
						<expr_stmt><expr><name>whereToSendOutput</name> <operator>=</operator> <name>DestNone</name></expr>;</expr_stmt>
						<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>,
								<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_CONNECTION_DOES_NOT_EXIST</name></expr></argument>)</argument_list></call><operator>,</operator>
								 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"unexpected EOF on client connection"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block></else></if_stmt>
					<return>return <expr><name>EOF</name></expr>;</return>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></if></if_stmt>
			<break>break;</break>
		<comment type="block">/* POLAR px: dispatched statement from QC */</comment>
		<case>case <expr><literal type="char">'M'</literal></expr>:</case>
			<expr_stmt><expr><name>doing_extended_query_message</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<comment type="block">/* don't support old protocols with this. */</comment>
			<if_stmt><if>if<condition>( <expr><call><name>PG_PROTOCOL_MAJOR</name><argument_list>(<argument><expr><name>FrontendProtocol</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">3</literal></expr> )</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>COMMERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_PROTOCOL_VIOLATION</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"dispatch unsupported for old FrontendProtocols"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<break>break;</break>

		<case>case <expr><literal type="char">'F'</literal></expr>:</case>				<comment type="block">/* fastpath function call */</comment>
			<expr_stmt><expr><name>doing_extended_query_message</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><call><name>PG_PROTOCOL_MAJOR</name><argument_list>(<argument><expr><name>FrontendProtocol</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">3</literal></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><call><name>GetOldFunctionMessage</name><argument_list>(<argument><expr><name>inBuf</name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<if_stmt><if>if <condition>(<expr><call><name>IsTransactionState</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>COMMERROR</name></expr></argument>,
								<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_CONNECTION_FAILURE</name></expr></argument>)</argument_list></call><operator>,</operator>
								 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"unexpected EOF on client connection with an open transaction"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
					<else>else
					<block>{<block_content>
						<comment type="block">/*
						 * Can't send DEBUG log messages to client at this
						 * point. Since we're disconnecting right away, we
						 * don't need to restore whereToSendOutput.
						 */</comment>
						<expr_stmt><expr><name>whereToSendOutput</name> <operator>=</operator> <name>DestNone</name></expr>;</expr_stmt>
						<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>,
								<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_CONNECTION_DOES_NOT_EXIST</name></expr></argument>)</argument_list></call><operator>,</operator>
								 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"unexpected EOF on client connection"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block></else></if_stmt>
					<return>return <expr><name>EOF</name></expr>;</return>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></if></if_stmt>
			<break>break;</break>

		<case>case <expr><literal type="char">'X'</literal></expr>:</case>				<comment type="block">/* terminate */</comment>
			<expr_stmt><expr><name>doing_extended_query_message</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>ignore_till_sync</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><literal type="char">'B'</literal></expr>:</case>				<comment type="block">/* bind */</comment>
		<case>case <expr><literal type="char">'C'</literal></expr>:</case>				<comment type="block">/* close */</comment>
		<case>case <expr><literal type="char">'D'</literal></expr>:</case>				<comment type="block">/* describe */</comment>
		<case>case <expr><literal type="char">'E'</literal></expr>:</case>				<comment type="block">/* execute */</comment>
		<case>case <expr><literal type="char">'H'</literal></expr>:</case>				<comment type="block">/* flush */</comment>
		<case>case <expr><literal type="char">'P'</literal></expr>:</case>				<comment type="block">/* parse */</comment>
			<expr_stmt><expr><name>doing_extended_query_message</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<comment type="block">/* these are only legal in protocol 3 */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>PG_PROTOCOL_MAJOR</name><argument_list>(<argument><expr><name>FrontendProtocol</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">3</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_PROTOCOL_VIOLATION</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid frontend message type %d"</literal></expr></argument>, <argument><expr><name>qtype</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<break>break;</break>

		<case>case <expr><literal type="char">'S'</literal></expr>:</case>				<comment type="block">/* sync */</comment>
			<comment type="block">/* stop any active skip-till-Sync */</comment>
			<expr_stmt><expr><name>ignore_till_sync</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<comment type="block">/* mark not-extended, so that a new error doesn't begin skip */</comment>
			<expr_stmt><expr><name>doing_extended_query_message</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<comment type="block">/* only legal in protocol 3 */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>PG_PROTOCOL_MAJOR</name><argument_list>(<argument><expr><name>FrontendProtocol</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">3</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_PROTOCOL_VIOLATION</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid frontend message type %d"</literal></expr></argument>, <argument><expr><name>qtype</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<break>break;</break>

		<case>case <expr><literal type="char">'d'</literal></expr>:</case>				<comment type="block">/* copy data */</comment>
		<case>case <expr><literal type="char">'c'</literal></expr>:</case>				<comment type="block">/* copy done */</comment>
		<case>case <expr><literal type="char">'f'</literal></expr>:</case>				<comment type="block">/* copy fail */</comment>
			<expr_stmt><expr><name>doing_extended_query_message</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<comment type="block">/* these are only legal in protocol 3 */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>PG_PROTOCOL_MAJOR</name><argument_list>(<argument><expr><name>FrontendProtocol</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">3</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_PROTOCOL_VIOLATION</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid frontend message type %d"</literal></expr></argument>, <argument><expr><name>qtype</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<break>break;</break>

		<default>default:</default>

			<comment type="block">/*
			 * Otherwise we got garbage from the frontend.  We treat this as
			 * fatal because we have probably lost message boundary sync, and
			 * there's no good way to recover.
			 */</comment>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_PROTOCOL_VIOLATION</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid frontend message type %d"</literal></expr></argument>, <argument><expr><name>qtype</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
	</block_content>}</block></switch>

	<comment type="block">/*
	 * In protocol version 3, all frontend messages have a length word next
	 * after the type code; we can read the message contents independently of
	 * the type.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>PG_PROTOCOL_MAJOR</name><argument_list>(<argument><expr><name>FrontendProtocol</name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <literal type="number">3</literal></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>pq_getmessage</name><argument_list>(<argument><expr><name>inBuf</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>EOF</name></expr>;</return></block_content></block></if></if_stmt>			<comment type="block">/* suitable message already logged */</comment>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>pq_endmsgread</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	<expr_stmt><expr><call><name>RESUME_CANCEL_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>qtype</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* ----------------
 *		ReadCommand reads a command from either the frontend or
 *		standard input, places it in inBuf, and returns the
 *		message type code (first byte of the message).
 *		EOF is returned if end of file.
 * ----------------
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>ReadCommand</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>inBuf</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>result</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>whereToSendOutput</name> <operator>==</operator> <name>DestRemote</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>SocketBackend</name><argument_list>(<argument><expr><name>inBuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>InteractiveBackend</name><argument_list>(<argument><expr><name>inBuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * ProcessClientReadInterrupt() - Process interrupts specific to client reads
 *
 * This is called just before and after low-level reads.
 * 'blocked' is true if no data was available to read and we plan to retry,
 * false if about to read or done reading.
 *
 * Must preserve errno!
 */</comment>
<function><type><name>void</name></type>
<name>ProcessClientReadInterrupt</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>blocked</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>save_errno</name> <init>= <expr><name>errno</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* POLAR: add process about cancel query request */</comment>
	<expr_stmt><expr><call><name>polar_process_client_readwrite_cancel_interrupt</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* POLAR end */</comment>

	<if_stmt><if>if <condition>(<expr><name>DoingCommandRead</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Check for general interrupts that arrived before/while reading */</comment>
		<expr_stmt><expr><call><name>CHECK_FOR_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Process sinval catchup interrupts, if any */</comment>
		<if_stmt><if>if <condition>(<expr><name>catchupInterruptPending</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ProcessCatchupInterrupt</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/* Process notify interrupts, if any */</comment>
		<if_stmt><if>if <condition>(<expr><name>notifyInterruptPending</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ProcessNotifyInterrupt</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>ProcDiePending</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * We're dying.  If there is no data available to read, then it's safe
		 * (and sane) to handle that now.  If we haven't tried to read yet,
		 * make sure the process latch is set, so that if there is no data
		 * then we'll come back here and die.  If we're done reading, also
		 * make sure the process latch is set, as we might've undesirably
		 * cleared it while reading.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>blocked</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>CHECK_FOR_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>SetLatch</name><argument_list>(<argument><expr><name>MyLatch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>errno</name> <operator>=</operator> <name>save_errno</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * ProcessClientWriteInterrupt() - Process interrupts specific to client writes
 *
 * This is called just before and after low-level writes.
 * 'blocked' is true if no data could be written and we plan to retry,
 * false if about to write or done writing.
 *
 * Must preserve errno!
 */</comment>
<function><type><name>void</name></type>
<name>ProcessClientWriteInterrupt</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>blocked</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>save_errno</name> <init>= <expr><name>errno</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* POLAR: add process about cancel query request */</comment>
	<expr_stmt><expr><call><name>polar_process_client_readwrite_cancel_interrupt</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* POLAR end */</comment>

	<if_stmt><if>if <condition>(<expr><name>ProcDiePending</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * We're dying.  If it's not possible to write, then we should handle
		 * that immediately, else a stuck client could indefinitely delay our
		 * response to the signal.  If we haven't tried to write yet, make
		 * sure the process latch is set, so that if the write would block
		 * then we'll come back here and die.  If we're done writing, also
		 * make sure the process latch is set, as we might've undesirably
		 * cleared it while writing.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>blocked</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * Don't mess with whereToSendOutput if ProcessInterrupts wouldn't
			 * do anything.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name>InterruptHoldoffCount</name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>CritSectionCount</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/*
				 * We don't want to send the client the error message, as a)
				 * that would possibly block again, and b) it would likely
				 * lead to loss of protocol sync because we may have already
				 * sent a partial protocol message.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><name>whereToSendOutput</name> <operator>==</operator> <name>DestRemote</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>whereToSendOutput</name> <operator>=</operator> <name>DestNone</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

				<expr_stmt><expr><call><name>CHECK_FOR_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>SetLatch</name><argument_list>(<argument><expr><name>MyLatch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>errno</name> <operator>=</operator> <name>save_errno</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Do raw parsing (only).
 *
 * A list of parsetrees (RawStmt nodes) is returned, since there might be
 * multiple commands in the given string.
 *
 * NOTE: for interactive queries, it is important to keep this routine
 * separate from the analysis &amp; rewrite stages.  Analysis and rewriting
 * cannot be done in an aborted transaction, since they require access to
 * database tables.  So, we rely on the raw parser to determine whether
 * we've seen a COMMIT or ABORT command; when we are in abort state, other
 * commands are not processed any further than the raw parse stage.
 */</comment>
<function><type><name>List</name> <modifier>*</modifier></type>
<name>pg_parse_query</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>query_string</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>raw_parsetree_list</name></decl>;</decl_stmt>

	<comment type="block">/* POLAR */</comment>
	<expr_stmt><expr><call><name>polar_sql_stat_set_time</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>TRACE_POSTGRESQL_QUERY_PARSE_START</name><argument_list>(<argument><expr><name>query_string</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>log_parser_stats</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ResetUsage</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>raw_parsetree_list</name> <operator>=</operator> <call><name>raw_parser</name><argument_list>(<argument><expr><name>query_string</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>log_parser_stats</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ShowUsage</name><argument_list>(<argument><expr><literal type="string">"PARSER STATISTICS"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>COPY_PARSE_PLAN_TREES</name></cpp:ifdef>
	<comment type="block">/* Optional debugging check: pass raw parsetrees through copyObject() */</comment>
	<block>{<block_content>
		<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>new_list</name> <init>= <expr><call><name>copyObject</name><argument_list>(<argument><expr><name>raw_parsetree_list</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/* This checks both copyObject() and the equal() routines... */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>equal</name><argument_list>(<argument><expr><name>new_list</name></expr></argument>, <argument><expr><name>raw_parsetree_list</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>, <argument><expr><literal type="string">"copyObject() failed to produce an equal raw parse tree"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>raw_parsetree_list</name> <operator>=</operator> <name>new_list</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<expr_stmt><expr><call><name>TRACE_POSTGRESQL_QUERY_PARSE_DONE</name><argument_list>(<argument><expr><name>query_string</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* POLAR */</comment>
	<expr_stmt><expr><call><name>polar_sql_stat_record_time</name><argument_list>(<argument><expr><name>SQL_PARSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>raw_parsetree_list</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Given a raw parsetree (gram.y output), and optionally information about
 * types of parameter symbols ($n), perform parse analysis and rule rewriting.
 *
 * A list of Query nodes is returned, since either the analyzer or the
 * rewriter might expand one query to several.
 *
 * NOTE: for reasons mentioned above, this must be separate from raw parsing.
 */</comment>
<function><type><name>List</name> <modifier>*</modifier></type>
<name>pg_analyze_and_rewrite</name><parameter_list>(<parameter><decl><type><name>RawStmt</name> <modifier>*</modifier></type><name>parsetree</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>query_string</name></decl></parameter>,
					   <parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>paramTypes</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>numParams</name></decl></parameter>,
					   <parameter><decl><type><name>QueryEnvironment</name> <modifier>*</modifier></type><name>queryEnv</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Query</name>	   <modifier>*</modifier></type><name>query</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>querytree_list</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>TRACE_POSTGRESQL_QUERY_REWRITE_START</name><argument_list>(<argument><expr><name>query_string</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * (1) Perform parse analysis.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>log_parser_stats</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ResetUsage</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>query</name> <operator>=</operator> <call><name>parse_analyze</name><argument_list>(<argument><expr><name>parsetree</name></expr></argument>, <argument><expr><name>query_string</name></expr></argument>, <argument><expr><name>paramTypes</name></expr></argument>, <argument><expr><name>numParams</name></expr></argument>,
						  <argument><expr><name>queryEnv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>log_parser_stats</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ShowUsage</name><argument_list>(<argument><expr><literal type="string">"PARSE ANALYSIS STATISTICS"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * (2) Rewrite the queries, as necessary
	 */</comment>
	<expr_stmt><expr><name>querytree_list</name> <operator>=</operator> <call><name>pg_rewrite_query</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>TRACE_POSTGRESQL_QUERY_REWRITE_DONE</name><argument_list>(<argument><expr><name>query_string</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>querytree_list</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Do parse analysis and rewriting.  This is the same as pg_analyze_and_rewrite
 * except that external-parameter resolution is determined by parser callback
 * hooks instead of a fixed list of parameter datatypes.
 */</comment>
<function><type><name>List</name> <modifier>*</modifier></type>
<name>pg_analyze_and_rewrite_params</name><parameter_list>(<parameter><decl><type><name>RawStmt</name> <modifier>*</modifier></type><name>parsetree</name></decl></parameter>,
							  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>query_string</name></decl></parameter>,
							  <parameter><decl><type><name>ParserSetupHook</name></type> <name>parserSetup</name></decl></parameter>,
							  <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>parserSetupArg</name></decl></parameter>,
							  <parameter><decl><type><name>QueryEnvironment</name> <modifier>*</modifier></type><name>queryEnv</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Query</name>	   <modifier>*</modifier></type><name>query</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>querytree_list</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>query_string</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>	<comment type="block">/* required as of 8.4 */</comment>

	<expr_stmt><expr><call><name>TRACE_POSTGRESQL_QUERY_REWRITE_START</name><argument_list>(<argument><expr><name>query_string</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * (1) Perform parse analysis.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>log_parser_stats</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ResetUsage</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>pstate</name> <operator>=</operator> <call><name>make_parsestate</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_sourcetext</name></name> <operator>=</operator> <name>query_string</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_queryEnv</name></name> <operator>=</operator> <name>queryEnv</name></expr>;</expr_stmt>
	<expr_stmt><expr><call>(<modifier>*</modifier><name>parserSetup</name>) <argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>parserSetupArg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>query</name> <operator>=</operator> <call><name>transformTopLevelStmt</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>parsetree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>post_parse_analyze_hook</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call>(<modifier>*</modifier><name>post_parse_analyze_hook</name>) <argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>free_parsestate</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>log_parser_stats</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ShowUsage</name><argument_list>(<argument><expr><literal type="string">"PARSE ANALYSIS STATISTICS"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * (2) Rewrite the queries, as necessary
	 */</comment>
	<expr_stmt><expr><name>querytree_list</name> <operator>=</operator> <call><name>pg_rewrite_query</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>TRACE_POSTGRESQL_QUERY_REWRITE_DONE</name><argument_list>(<argument><expr><name>query_string</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>querytree_list</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Perform rewriting of a query produced by parse analysis.
 *
 * Note: query must just have come from the parser, because we do not do
 * AcquireRewriteLocks() on it.
 */</comment>
<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>pg_rewrite_query</name><parameter_list>(<parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>query</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>querytree_list</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>Debug_print_parse</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog_node_display</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"parse tree"</literal></expr></argument>, <argument><expr><name>query</name></expr></argument>,
						  <argument><expr><name>Debug_pretty_print</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>log_parser_stats</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ResetUsage</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>query</name><operator>-&gt;</operator><name>commandType</name></name> <operator>==</operator> <name>CMD_UTILITY</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* don't rewrite utilities, just dump 'em into result list */</comment>
		<expr_stmt><expr><name>querytree_list</name> <operator>=</operator> <call><name>list_make1</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* rewrite regular queries */</comment>
		<expr_stmt><expr><name>querytree_list</name> <operator>=</operator> <call><name>QueryRewrite</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>log_parser_stats</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ShowUsage</name><argument_list>(<argument><expr><literal type="string">"REWRITER STATISTICS"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>COPY_PARSE_PLAN_TREES</name></cpp:ifdef>
	<comment type="block">/* Optional debugging check: pass querytree output through copyObject() */</comment>
	<block>{<block_content>
		<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>new_list</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>new_list</name> <operator>=</operator> <call><name>copyObject</name><argument_list>(<argument><expr><name>querytree_list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* This checks both copyObject() and the equal() routines... */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>equal</name><argument_list>(<argument><expr><name>new_list</name></expr></argument>, <argument><expr><name>querytree_list</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>, <argument><expr><literal type="string">"copyObject() failed to produce equal parse tree"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>querytree_list</name> <operator>=</operator> <name>new_list</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<if_stmt><if>if <condition>(<expr><name>Debug_print_rewritten</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog_node_display</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"rewritten parse tree"</literal></expr></argument>, <argument><expr><name>querytree_list</name></expr></argument>,
						  <argument><expr><name>Debug_pretty_print</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>querytree_list</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * Generate a plan for a single already-rewritten query.
 * This is a thin wrapper around planner() and takes the same parameters.
 */</comment>
<function><type><name>PlannedStmt</name> <modifier>*</modifier></type>
<name>pg_plan_query</name><parameter_list>(<parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>querytree</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>cursorOptions</name></decl></parameter>, <parameter><decl><type><name>ParamListInfo</name></type> <name>boundParams</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PlannedStmt</name> <modifier>*</modifier></type><name>plan</name></decl>;</decl_stmt>

	<comment type="block">/* Utility commands have no plans. */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>querytree</name><operator>-&gt;</operator><name>commandType</name></name> <operator>==</operator> <name>CMD_UTILITY</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* Planner must have a snapshot in case it calls user-defined functions. */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>ActiveSnapshotSet</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* POLAR */</comment>
	<expr_stmt><expr><call><name>polar_sql_stat_set_time</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	
	<expr_stmt><expr><call><name>TRACE_POSTGRESQL_QUERY_PLAN_START</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>log_planner_stats</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ResetUsage</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* call the optimizer */</comment>
	<expr_stmt><expr><name>plan</name> <operator>=</operator> <call><name>planner</name><argument_list>(<argument><expr><name>querytree</name></expr></argument>, <argument><expr><name>cursorOptions</name></expr></argument>, <argument><expr><name>boundParams</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>log_planner_stats</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ShowUsage</name><argument_list>(<argument><expr><literal type="string">"PLANNER STATISTICS"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>COPY_PARSE_PLAN_TREES</name></cpp:ifdef>
	<comment type="block">/* Optional debugging check: pass plan output through copyObject() */</comment>
	<block>{<block_content>
		<decl_stmt><decl><type><name>PlannedStmt</name> <modifier>*</modifier></type><name>new_plan</name> <init>= <expr><call><name>copyObject</name><argument_list>(<argument><expr><name>plan</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/*
		 * equal() currently does not have routines to compare Plan nodes, so
		 * don't try to test equality here.  Perhaps fix someday?
		 */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>NOT_USED</name></cpp:ifdef>
		<comment type="block">/* This checks both copyObject() and the equal() routines... */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>equal</name><argument_list>(<argument><expr><name>new_plan</name></expr></argument>, <argument><expr><name>plan</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>, <argument><expr><literal type="string">"copyObject() failed to produce an equal plan tree"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
			<expr_stmt><expr><name>plan</name> <operator>=</operator> <name>new_plan</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<comment type="block">/*
	 * Print plan if debugging.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>Debug_print_plan</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog_node_display</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"plan"</literal></expr></argument>, <argument><expr><name>plan</name></expr></argument>, <argument><expr><name>Debug_pretty_print</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>TRACE_POSTGRESQL_QUERY_PLAN_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* POLAR */</comment>
	<expr_stmt><expr><call><name>polar_sql_stat_record_time</name><argument_list>(<argument><expr><name>SQL_PLAN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>plan</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Generate plans for a list of already-rewritten queries.
 *
 * For normal optimizable statements, invoke the planner.  For utility
 * statements, just make a wrapper PlannedStmt node.
 *
 * The result is a list of PlannedStmt nodes.
 */</comment>
<function><type><name>List</name> <modifier>*</modifier></type>
<name>pg_plan_queries</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>querytrees</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>cursorOptions</name></decl></parameter>, <parameter><decl><type><name>ParamListInfo</name></type> <name>boundParams</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>stmt_list</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>query_list</name></decl>;</decl_stmt>

	<macro><name>foreach</name><argument_list>(<argument>query_list</argument>, <argument>querytrees</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Query</name>	   <modifier>*</modifier></type><name>query</name> <init>= <expr><call><name>lfirst_node</name><argument_list>(<argument><expr><name>Query</name></expr></argument>, <argument><expr><name>query_list</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>PlannedStmt</name> <modifier>*</modifier></type><name>stmt</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>query</name><operator>-&gt;</operator><name>commandType</name></name> <operator>==</operator> <name>CMD_UTILITY</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Utility commands require no planning. */</comment>
			<expr_stmt><expr><name>stmt</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>PlannedStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>stmt</name><operator>-&gt;</operator><name>commandType</name></name> <operator>=</operator> <name>CMD_UTILITY</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>stmt</name><operator>-&gt;</operator><name>canSetTag</name></name> <operator>=</operator> <name><name>query</name><operator>-&gt;</operator><name>canSetTag</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>stmt</name><operator>-&gt;</operator><name>utilityStmt</name></name> <operator>=</operator> <name><name>query</name><operator>-&gt;</operator><name>utilityStmt</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>stmt</name><operator>-&gt;</operator><name>stmt_location</name></name> <operator>=</operator> <name><name>query</name><operator>-&gt;</operator><name>stmt_location</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>stmt</name><operator>-&gt;</operator><name>stmt_len</name></name> <operator>=</operator> <name><name>query</name><operator>-&gt;</operator><name>stmt_len</name></name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><name>stmt</name> <operator>=</operator> <call><name>pg_plan_query</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><name>cursorOptions</name></expr></argument>, <argument><expr><name>boundParams</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<expr_stmt><expr><name>stmt_list</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>stmt_list</name></expr></argument>, <argument><expr><name>stmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<return>return <expr><name>stmt_list</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * exec_simple_query
 *
 * Execute a "simple Query" protocol message.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>exec_simple_query</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>query_string</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>CommandDest</name></type> <name>dest</name> <init>= <expr><name>whereToSendOutput</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcontext</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>parsetree_list</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>parsetree_item</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>save_log_statement_stats</name> <init>= <expr><name>log_statement_stats</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>was_logged</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>use_implicit_block</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>msec_str</name><index>[<expr><literal type="number">32</literal></expr>]</index></name></decl>;</decl_stmt>

	<comment type="block">/* POLAR */</comment>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>stmt_item</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>needs_mask</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>		<name>log_mode</name></decl>;</decl_stmt>
	<comment type="block">/*
	 * Report query to various monitoring facilities.
	 */</comment>
	<expr_stmt><expr><name>debug_query_string</name> <operator>=</operator> <name>query_string</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>pgstat_report_activity</name><argument_list>(<argument><expr><name>STATE_RUNNING</name></expr></argument>, <argument><expr><name>query_string</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>TRACE_POSTGRESQL_QUERY_START</name><argument_list>(<argument><expr><name>query_string</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * We use save_log_statement_stats so ShowUsage doesn't report incorrect
	 * results because ResetUsage wasn't called.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>save_log_statement_stats</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ResetUsage</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Start up a transaction command.  All queries generated by the
	 * query_string will be in this same command block, *unless* we find a
	 * BEGIN/COMMIT/ABORT statement; we have to force a new xact command after
	 * one of those, else bad things will happen in xact.c. (Note that this
	 * will normally change current memory context.)
	 */</comment>
	<expr_stmt><expr><call><name>start_xact_command</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Zap any pre-existing unnamed statement.  (While not strictly necessary,
	 * it seems best to define simple-Query mode as if it used the unnamed
	 * statement and portal; this ensures we recover any storage used by prior
	 * unnamed operations.)
	 */</comment>
	<expr_stmt><expr><call><name>drop_unnamed_stmt</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Switch to appropriate context for constructing parsetrees.
	 */</comment>
	<expr_stmt><expr><name>oldcontext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>MessageContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Do basic parsing of the query or queries (this should be safe even if
	 * we are in aborted transaction state!)
	 */</comment>
	<expr_stmt><expr><name>parsetree_list</name> <operator>=</operator> <call><name>pg_parse_query</name><argument_list>(<argument><expr><name>query_string</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Switch back to transaction context to enter the loop.
	 */</comment>
	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * For historical reasons, if multiple SQL statements are given in a
	 * single "simple Query" message, we execute them as a single transaction,
	 * unless explicit transaction control commands are included to make
	 * portions of the list be separate transactions.  To represent this
	 * behavior properly in the transaction machinery, we use an "implicit"
	 * transaction block.
	 */</comment>
	<expr_stmt><expr><name>use_implicit_block</name> <operator>=</operator> <operator>(</operator><call><name>list_length</name><argument_list>(<argument><expr><name>parsetree_list</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>

	<comment type="block">/*
	 * Run through the raw parsetree(s) and process each one.
	 */</comment>
	<macro><name>foreach</name><argument_list>(<argument>parsetree_item</argument>, <argument>parsetree_list</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>RawStmt</name>    <modifier>*</modifier></type><name>parsetree</name> <init>= <expr><call><name>lfirst_node</name><argument_list>(<argument><expr><name>RawStmt</name></expr></argument>, <argument><expr><name>parsetree_item</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>snapshot_set</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>commandTag</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name></type>		<name><name>completionTag</name><index>[<expr><name>COMPLETION_TAG_BUFSIZE</name></expr>]</index></name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>querytree_list</name></decl>,
				   <decl><type ref="prev"><modifier>*</modifier></type><name>plantree_list</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Portal</name></type>		<name>portal</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>DestReceiver</name> <modifier>*</modifier></type><name>receiver</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int16</name></type>		<name>format</name></decl>;</decl_stmt>

		<comment type="block">/* POLAR px: begin */</comment>
		<comment type="block">/* reset false every time*/</comment>
		<expr_stmt><expr><name>px_use_global_function</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>px_is_planning</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>px_is_executing</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>px_adaptive_paging</name> <operator>=</operator> <name>px_enable_adaptive_scan</name></expr>;</expr_stmt>

		<comment type="block">/*
		 * Get the command name for use in status display (it also becomes the
		 * default completion tag, down inside PortalRun).  Set ps_status and
		 * do any special start-of-SQL-command processing needed by the
		 * destination.
		 */</comment>
		<expr_stmt><expr><name>commandTag</name> <operator>=</operator> <call><name>CreateCommandTag</name><argument_list>(<argument><expr><name><name>parsetree</name><operator>-&gt;</operator><name>stmt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>set_ps_display</name><argument_list>(<argument><expr><name>commandTag</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>BeginCommand</name><argument_list>(<argument><expr><name>commandTag</name></expr></argument>, <argument><expr><name>dest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * If we are in an aborted transaction, reject all commands except
		 * COMMIT/ABORT.  It is important that this test occur before we try
		 * to do parse analysis, rewrite, or planning, since all those phases
		 * try to do database accesses, which may fail in abort state. (It
		 * might be safe to allow some additional utility commands in this
		 * state, but not many...)
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>IsAbortedTransactionBlockState</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator>
			<operator>!</operator><call><name>IsTransactionExitStmt</name><argument_list>(<argument><expr><name><name>parsetree</name><operator>-&gt;</operator><name>stmt</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_IN_FAILED_SQL_TRANSACTION</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"current transaction is aborted, "</literal>
							<literal type="string">"commands ignored until end of transaction block"</literal></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errdetail_abort</name><argument_list>()</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/* Make sure we are in a transaction command */</comment>
		<expr_stmt><expr><call><name>start_xact_command</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * If using an implicit transaction block, and we're not already in a
		 * transaction block, start an implicit block to force this statement
		 * to be grouped together with any following ones.  (We must do this
		 * each time through the loop; otherwise, a COMMIT/ROLLBACK in the
		 * list would cause later statements to not be grouped.)
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>use_implicit_block</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>BeginImplicitTransactionBlock</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/* If we got a cancel signal in parsing or prior command, quit */</comment>
		<expr_stmt><expr><call><name>CHECK_FOR_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Set up a snapshot if parse analysis/planning will need one.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>analyze_requires_snapshot</name><argument_list>(<argument><expr><name>parsetree</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>PushActiveSnapshot</name><argument_list>(<argument><expr><call><name>GetTransactionSnapshot</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>snapshot_set</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * OK to analyze, rewrite, and plan this query.
		 *
		 * Switch to appropriate context for constructing querytrees (again,
		 * these must outlive the execution context).
		 */</comment>
		<expr_stmt><expr><name>oldcontext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>MessageContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>querytree_list</name> <operator>=</operator> <call><name>pg_analyze_and_rewrite</name><argument_list>(<argument><expr><name>parsetree</name></expr></argument>, <argument><expr><name>query_string</name></expr></argument>,
												<argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>plantree_list</name> <operator>=</operator> <call><name>pg_plan_queries</name><argument_list>(<argument><expr><name>querytree_list</name></expr></argument>,
										<argument><expr><name>CURSOR_OPT_PARALLEL_OK</name> <operator>|</operator> <name>CURSOR_OPT_PX_OK</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Done with the snapshot used for parsing/planning */</comment>
		<if_stmt><if>if <condition>(<expr><name>snapshot_set</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>PopActiveSnapshot</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/* If we got a cancel signal in analysis or planning, quit */</comment>
		<expr_stmt><expr><call><name>CHECK_FOR_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Create unnamed portal to run the query or queries in. If there
		 * already is one, silently drop it.
		 */</comment>
		<expr_stmt><expr><name>portal</name> <operator>=</operator> <call><name>CreatePortal</name><argument_list>(<argument><expr><literal type="string">""</literal></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* Don't display the portal in pg_cursors */</comment>
		<expr_stmt><expr><name><name>portal</name><operator>-&gt;</operator><name>visible</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

		<comment type="block">/*
		 * We don't have to copy anything into the portal, because everything
		 * we are passing here is in MessageContext, which will outlive the
		 * portal anyway.
		 */</comment>
		<expr_stmt><expr><call><name>PortalDefineQuery</name><argument_list>(<argument><expr><name>portal</name></expr></argument>,
						  <argument><expr><name>NULL</name></expr></argument>,
						  <argument><expr><name>query_string</name></expr></argument>,
						  <argument><expr><name>T_Invalid</name></expr></argument>,<comment type="block">/* POLAR px */</comment>
						  <argument><expr><name>commandTag</name></expr></argument>,
						  <argument><expr><name>plantree_list</name></expr></argument>,
						  <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Start the portal.  No parameters here.
		 */</comment>
		<expr_stmt><expr><call><name>PortalStart</name><argument_list>(<argument><expr><name>portal</name></expr></argument>,
					<argument><expr><name>NULL</name></expr></argument>,
					<argument><expr><literal type="number">0</literal></expr></argument>,
					<argument><expr><name>InvalidSnapshot</name></expr></argument>,
					<argument><expr><name>NULL</name></expr></argument><comment type="block">/* POALR px */</comment>
					)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Select the appropriate output format: text unless we are doing a
		 * FETCH from a binary cursor.  (Pretty grotty to have to do this here
		 * --- but it avoids grottiness in other places.  Ah, the joys of
		 * backward compatibility...)
		 */</comment>
		<expr_stmt><expr><name>format</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>				<comment type="block">/* TEXT is default */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name><name>parsetree</name><operator>-&gt;</operator><name>stmt</name></name></expr></argument>, <argument><expr><name>FetchStmt</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>FetchStmt</name>  <modifier>*</modifier></type><name>stmt</name> <init>= <expr><operator>(</operator><name>FetchStmt</name> <operator>*</operator><operator>)</operator> <name><name>parsetree</name><operator>-&gt;</operator><name>stmt</name></name></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>stmt</name><operator>-&gt;</operator><name>ismove</name></name></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>Portal</name></type>		<name>fportal</name> <init>= <expr><call><name>GetPortalByName</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>portalname</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><call><name>PortalIsValid</name><argument_list>(<argument><expr><name>fportal</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
					<operator>(</operator><name><name>fportal</name><operator>-&gt;</operator><name>cursorOptions</name></name> <operator>&amp;</operator> <name>CURSOR_OPT_BINARY</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>format</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt> <comment type="block">/* BINARY */</comment>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><call><name>PortalSetResultFormat</name><argument_list>(<argument><expr><name>portal</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>format</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Now we can create the destination receiver object.
		 */</comment>
		<expr_stmt><expr><name>receiver</name> <operator>=</operator> <call><name>CreateDestReceiver</name><argument_list>(<argument><expr><name>dest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>dest</name> <operator>==</operator> <name>DestRemote</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>SetRemoteDestReceiverParams</name><argument_list>(<argument><expr><name>receiver</name></expr></argument>, <argument><expr><name>portal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * Switch back to transaction context for execution.
		 */</comment>
		<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Run the portal to completion, and then drop it (and the receiver).
		 */</comment>
		<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>PortalRun</name><argument_list>(<argument><expr><name>portal</name></expr></argument>,
						 <argument><expr><name>FETCH_ALL</name></expr></argument>,
						 <argument><expr><name>true</name></expr></argument>,	<comment type="block">/* always top level */</comment>
						 <argument><expr><name>true</name></expr></argument>,
						 <argument><expr><name>receiver</name></expr></argument>,
						 <argument><expr><name>receiver</name></expr></argument>,
						 <argument><expr><name>completionTag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name><name>receiver</name><operator>-&gt;</operator><name>rDestroy</name></name><argument_list>(<argument><expr><name>receiver</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>PortalDrop</name><argument_list>(<argument><expr><name>portal</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>lnext</name><argument_list>(<argument><expr><name>parsetree_item</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * If this is the last parsetree of the query string, close down
			 * transaction statement before reporting command-complete.  This
			 * is so that any end-of-transaction errors are reported before
			 * the command-complete message is issued, to avoid confusing
			 * clients who will expect either a command-complete message or an
			 * error, not one and then the other.  Also, if we're using an
			 * implicit transaction block, we must close that out first.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name>use_implicit_block</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>EndImplicitTransactionBlock</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><call><name>finish_xact_command</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name><name>parsetree</name><operator>-&gt;</operator><name>stmt</name></name></expr></argument>, <argument><expr><name>TransactionStmt</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * If this was a transaction control statement, commit it. We will
			 * start a new xact command for the next command.
			 */</comment>
			<expr_stmt><expr><call><name>finish_xact_command</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/*
			 * We need a CommandCounterIncrement after every query, except
			 * those that start or end a transaction block.
			 */</comment>
			<expr_stmt><expr><call><name>CommandCounterIncrement</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<comment type="block">/*
		 * Tell client that we're done with this query.  Note we emit exactly
		 * one EndCommand report for each raw parsetree, thus one for each SQL
		 * command the client sent, regardless of rewriting. (But a command
		 * aborted by error will not send an EndCommand report at all.)
		 */</comment>
		<expr_stmt><expr><call><name>EndCommand</name><argument_list>(<argument><expr><name>completionTag</name></expr></argument>, <argument><expr><name>dest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>							<comment type="block">/* end loop over parsetrees */</comment>

	<comment type="block">/*
	 * Close down transaction statement, if one is open.  (This will only do
	 * something if the parsetree list was empty; otherwise the last loop
	 * iteration already did it.)
	 */</comment>
	<expr_stmt><expr><call><name>finish_xact_command</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If there were no parsetrees, return EmptyQueryResponse message.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>parsetree_list</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>NullCommand</name><argument_list>(<argument><expr><name>dest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* POLAR: else we have to inspect the statement(s) to see whether to log */</comment>
	<macro><name>foreach</name><argument_list>(<argument>stmt_item</argument>, <argument>parsetree_list</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Node</name>       <modifier>*</modifier></type><name>stmt</name> <init>= <expr><operator>(</operator><operator>(</operator><name>RawStmt</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>stmt_item</name></expr></argument>)</argument_list></call><operator>)</operator><operator>-&gt;</operator><name>stmt</name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>polar_stmt_type_needs_mask</name><argument_list>(<argument><expr><call><name>nodeTag</name><argument_list>(<argument><expr><name>stmt</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>needs_mask</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>

	<comment type="block">/*
	 * if parse sucess and need log, record audit log, else polar_audit_log is
	 * NULL
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>check_log_statement</name><argument_list>(<argument><expr><name>parsetree_list</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><operator>(</operator><name>needs_mask</name> <operator>&amp;&amp;</operator> <name><name>MyProc</name><operator>-&gt;</operator><name>issuper</name></name><operator>)</operator></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>polar_audit_log</name><operator>.</operator><name>query_string</name></name> <operator>=</operator> <name>query_string</name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>polar_enable_multi_syslogger</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>ErrorData</name></type> <name>edata</name></decl>;</decl_stmt>
			<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><operator>&amp;</operator><name>edata</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ErrorData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>edata</name><operator>.</operator><name>elevel</name></name> <operator>=</operator> <name>LOG</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>edata</name><operator>.</operator><name>is_audit_log</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>edata</name><operator>.</operator><name>hide_stmt</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>edata</name><operator>.</operator><name>output_to_server</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>edata</name><operator>.</operator><name>message</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>edata</name><operator>.</operator><name>needs_mask</name></name> <operator>=</operator> <name>needs_mask</name></expr>;</expr_stmt>

 			<expr_stmt><expr><call><name>polar_write_audit_log</name><argument_list>(<argument><expr><operator>&amp;</operator><name>edata</name></expr></argument>, <argument><expr><literal type="string">"statement: %s"</literal></expr></argument>, <argument><expr><name>query_string</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"statement: %s"</literal></expr></argument>, <argument><expr><name>query_string</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errhidestmt</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>polar_mark_audit_log</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>polar_mark_needs_mask</name><argument_list>(<argument><expr><name>needs_mask</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errdetail_execute</name><argument_list>(<argument><expr><name>parsetree_list</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
		<expr_stmt><expr><name>was_logged</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* POLAR end */</comment>

	<comment type="block">/*
	 * Emit duration logging if appropriate.
	 */</comment>
	<expr_stmt><expr><name>log_mode</name> <operator>=</operator> <call><name>check_log_duration</name><argument_list>(<argument><expr><name>msec_str</name></expr></argument>, <argument><expr><name>was_logged</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>log_mode</name> <operator>==</operator> <literal type="number">2</literal><operator>)</operator> <operator>&amp;&amp;</operator> <name>needs_mask</name> <operator>&amp;&amp;</operator> <name><name>MyProc</name><operator>-&gt;</operator><name>issuper</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>log_mode</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
	
	<switch>switch <condition>(<expr><name>log_mode</name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><literal type="number">1</literal></expr>:</case>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"duration: %s ms"</literal></expr></argument>, <argument><expr><name>msec_str</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>polar_mark_slow_log</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call><operator>,</operator>   <comment type="block">/* POLAR */</comment>
					 <call><name>errhidestmt</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><literal type="number">2</literal></expr>:</case>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"duration: %s ms  statement: %s"</literal></expr></argument>,
							<argument><expr><name>msec_str</name></expr></argument>, <argument><expr><name>query_string</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errhidestmt</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>polar_mark_slow_log</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call><operator>,</operator>   <comment type="block">/* POLAR */</comment>
					 <call><name>polar_mark_needs_mask</name><argument_list>(<argument><expr><name>needs_mask</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errdetail_execute</name><argument_list>(<argument><expr><name>parsetree_list</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
	</block_content>}</block></switch>

	<if_stmt><if>if <condition>(<expr><name>save_log_statement_stats</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ShowUsage</name><argument_list>(<argument><expr><literal type="string">"QUERY STATISTICS"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>TRACE_POSTGRESQL_QUERY_DONE</name><argument_list>(<argument><expr><name>query_string</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>debug_query_string</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * exec_parse_message
 *
 * Execute a "Parse" protocol message.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>exec_parse_message</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>query_string</name></decl></parameter>,	<comment type="block">/* string to execute */</comment>
				   <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>stmt_name</name></decl></parameter>,	<comment type="block">/* name for prepared stmt */</comment>
				   <parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>paramTypes</name></decl></parameter>, <comment type="block">/* parameter types */</comment>
				   <parameter><decl><type><name>int</name></type> <name>numParams</name></decl></parameter>)</parameter_list>	<comment type="block">/* number of parameters */</comment>
<block>{<block_content>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>unnamed_stmt_context</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcontext</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>parsetree_list</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RawStmt</name>    <modifier>*</modifier></type><name>raw_parse_tree</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>commandTag</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>querytree_list</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CachedPlanSource</name> <modifier>*</modifier></type><name>psrc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>is_named</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>save_log_statement_stats</name> <init>= <expr><name>log_statement_stats</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>msec_str</name><index>[<expr><literal type="number">32</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name>		   <modifier>*</modifier></type><name>paramLocation</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt> <comment type="block">/* POLAR: parameter location */</comment>

	<comment type="block">/*
	 * Report query to various monitoring facilities.
	 */</comment>
	<expr_stmt><expr><name>debug_query_string</name> <operator>=</operator> <name>query_string</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>pgstat_report_activity</name><argument_list>(<argument><expr><name>STATE_RUNNING</name></expr></argument>, <argument><expr><name>query_string</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>set_ps_display</name><argument_list>(<argument><expr><literal type="string">"PARSE"</literal></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>save_log_statement_stats</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ResetUsage</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>DEBUG2</name></expr></argument>,
			<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"parse %s: %s"</literal></expr></argument>,
					<argument><expr><ternary><condition><expr><operator>*</operator><name>stmt_name</name></expr> ?</condition><then> <expr><name>stmt_name</name></expr> </then><else>: <expr><literal type="string">"&lt;unnamed&gt;"</literal></expr></else></ternary></expr></argument>,
					<argument><expr><name>query_string</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Start up a transaction command so we can run parse analysis etc. (Note
	 * that this will normally change current memory context.) Nothing happens
	 * if we are already in one.  This also arms the statement timeout if
	 * necessary.
	 */</comment>
	<expr_stmt><expr><call><name>start_xact_command</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Switch to appropriate context for constructing parsetrees.
	 *
	 * We have two strategies depending on whether the prepared statement is
	 * named or not.  For a named prepared statement, we do parsing in
	 * MessageContext and copy the finished trees into the prepared
	 * statement's plancache entry; then the reset of MessageContext releases
	 * temporary space used by parsing and rewriting. For an unnamed prepared
	 * statement, we assume the statement isn't going to hang around long, so
	 * getting rid of temp space quickly is probably not worth the costs of
	 * copying parse trees.  So in this case, we create the plancache entry's
	 * query_context here, and do all the parsing work therein.
	 */</comment>
	<expr_stmt><expr><name>is_named</name> <operator>=</operator> <operator>(</operator><name><name>stmt_name</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'\0'</literal><operator>)</operator></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>is_named</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Named prepared statement --- parse in MessageContext */</comment>
		<expr_stmt><expr><name>oldcontext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>MessageContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* Unnamed prepared statement --- release any prior unnamed stmt */</comment>
		<expr_stmt><expr><call><name>drop_unnamed_stmt</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* Create context for parsing */</comment>
		<expr_stmt><expr><name>unnamed_stmt_context</name> <operator>=</operator>
			<call><name>AllocSetContextCreate</name><argument_list>(<argument><expr><name>MessageContext</name></expr></argument>,
								  <argument><expr><literal type="string">"unnamed prepared statement"</literal></expr></argument>,
								  <argument><expr><name>ALLOCSET_DEFAULT_SIZES</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>oldcontext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>unnamed_stmt_context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/*
	 * Do basic parsing of the query or queries (this should be safe even if
	 * we are in aborted transaction state!)
	 */</comment>
	<expr_stmt><expr><name>parsetree_list</name> <operator>=</operator> <call><name>pg_parse_query</name><argument_list>(<argument><expr><name>query_string</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * We only allow a single user statement in a prepared statement. This is
	 * mainly to keep the protocol simple --- otherwise we'd need to worry
	 * about multiple result tupdescs and things like that.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name>parsetree_list</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot insert multiple commands into a prepared statement"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>parsetree_list</name> <operator>!=</operator> <name>NIL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Query</name>	   <modifier>*</modifier></type><name>query</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>snapshot_set</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>raw_parse_tree</name> <operator>=</operator> <call><name>linitial_node</name><argument_list>(<argument><expr><name>RawStmt</name></expr></argument>, <argument><expr><name>parsetree_list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Get the command name for possible use in status display.
		 */</comment>
		<expr_stmt><expr><name>commandTag</name> <operator>=</operator> <call><name>CreateCommandTag</name><argument_list>(<argument><expr><name><name>raw_parse_tree</name><operator>-&gt;</operator><name>stmt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * If we are in an aborted transaction, reject all commands except
		 * COMMIT/ROLLBACK.  It is important that this test occur before we
		 * try to do parse analysis, rewrite, or planning, since all those
		 * phases try to do database accesses, which may fail in abort state.
		 * (It might be safe to allow some additional utility commands in this
		 * state, but not many...)
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>IsAbortedTransactionBlockState</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator>
			<operator>!</operator><call><name>IsTransactionExitStmt</name><argument_list>(<argument><expr><name><name>raw_parse_tree</name><operator>-&gt;</operator><name>stmt</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_IN_FAILED_SQL_TRANSACTION</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"current transaction is aborted, "</literal>
							<literal type="string">"commands ignored until end of transaction block"</literal></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errdetail_abort</name><argument_list>()</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * Create the CachedPlanSource before we do parse analysis, since it
		 * needs to see the unmodified raw parse tree.
		 */</comment>
		<expr_stmt><expr><name>psrc</name> <operator>=</operator> <call><name>CreateCachedPlan</name><argument_list>(<argument><expr><name>raw_parse_tree</name></expr></argument>, <argument><expr><name>query_string</name></expr></argument>, <argument><expr><name>commandTag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Set up a snapshot if parse analysis will need one.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>analyze_requires_snapshot</name><argument_list>(<argument><expr><name>raw_parse_tree</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>PushActiveSnapshot</name><argument_list>(<argument><expr><call><name>GetTransactionSnapshot</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>snapshot_set</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * Analyze and rewrite the query.  Note that the originally specified
		 * parameter set is not required to be complete, so we have to use
		 * parse_analyze_varparams().
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>log_parser_stats</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ResetUsage</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/* POLAR: parameter location */</comment>
		<if_stmt><if>if <condition>(<expr><name>polar_enable_audit_log_bind_sql_parameter_new</name> <operator>&amp;&amp;</operator> <name>numParams</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* POLAR: alloc memory for parameter location */</comment>
			<expr_stmt><expr><name>paramLocation</name> <operator>=</operator> <operator>(</operator><name>int</name> <operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><name>numParams</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name>query</name> <operator>=</operator> <call><name>parse_analyze_varparams</name><argument_list>(<argument><expr><name>raw_parse_tree</name></expr></argument>,
										<argument><expr><name>query_string</name></expr></argument>,
										<argument><expr><operator>&amp;</operator><name>paramTypes</name></expr></argument>,
										<argument><expr><operator>&amp;</operator><name>paramLocation</name></expr></argument>, <comment type="block">/* POLAR: param location */</comment>
										<argument><expr><operator>&amp;</operator><name>numParams</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Check all parameter types got determined.
		 */</comment>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>numParams</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Oid</name></type>			<name>ptype</name> <init>= <expr><name><name>paramTypes</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name>ptype</name> <operator>==</operator> <name>InvalidOid</name> <operator>||</operator> <name>ptype</name> <operator>==</operator> <name>UNKNOWNOID</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INDETERMINATE_DATATYPE</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not determine data type of parameter $%d"</literal></expr></argument>,
								<argument><expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></for>

		<if_stmt><if>if <condition>(<expr><name>log_parser_stats</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ShowUsage</name><argument_list>(<argument><expr><literal type="string">"PARSE ANALYSIS STATISTICS"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>querytree_list</name> <operator>=</operator> <call><name>pg_rewrite_query</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Done with the snapshot used for parsing */</comment>
		<if_stmt><if>if <condition>(<expr><name>snapshot_set</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>PopActiveSnapshot</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* Empty input string.  This is legal. */</comment>
		<expr_stmt><expr><name>raw_parse_tree</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>commandTag</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>psrc</name> <operator>=</operator> <call><name>CreateCachedPlan</name><argument_list>(<argument><expr><name>raw_parse_tree</name></expr></argument>, <argument><expr><name>query_string</name></expr></argument>, <argument><expr><name>commandTag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>querytree_list</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/*
	 * CachedPlanSource must be a direct child of MessageContext before we
	 * reparent unnamed_stmt_context under it, else we have a disconnected
	 * circular subgraph.  Klugy, but less so than flipping contexts even more
	 * above.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>unnamed_stmt_context</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>MemoryContextSetParent</name><argument_list>(<argument><expr><name><name>psrc</name><operator>-&gt;</operator><name>context</name></name></expr></argument>, <argument><expr><name>MessageContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Finish filling in the CachedPlanSource */</comment>
	<expr_stmt><expr><call><name>CompleteCachedPlan</name><argument_list>(<argument><expr><name>psrc</name></expr></argument>,
					   <argument><expr><name>querytree_list</name></expr></argument>,
					   <argument><expr><name>unnamed_stmt_context</name></expr></argument>,
					   <argument><expr><name>paramTypes</name></expr></argument>,
					   <argument><expr><name>paramLocation</name></expr></argument>, <comment type="block">/* POLAR: parameter location */</comment>
					   <argument><expr><name>numParams</name></expr></argument>,
					   <argument><expr><name>NULL</name></expr></argument>,
					   <argument><expr><name>NULL</name></expr></argument>,
					   <argument><expr><name>CURSOR_OPT_PARALLEL_OK</name></expr></argument>,	<comment type="block">/* allow parallel mode */</comment>
					   <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>	<comment type="block">/* fixed result */</comment>

	<comment type="block">/* If we got a cancel signal during analysis, quit */</comment>
	<expr_stmt><expr><call><name>CHECK_FOR_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>is_named</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Store the query as a prepared statement.
		 */</comment>
		<expr_stmt><expr><call><name>StorePreparedStatement</name><argument_list>(<argument><expr><name>stmt_name</name></expr></argument>, <argument><expr><name>psrc</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/*
		 * We just save the CachedPlanSource into unnamed_stmt_psrc.
		 */</comment>
		<expr_stmt><expr><call><name>SaveCachedPlan</name><argument_list>(<argument><expr><name>psrc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>unnamed_stmt_psrc</name> <operator>=</operator> <name>psrc</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * We do NOT close the open transaction command here; that only happens
	 * when the client sends Sync.  Instead, do CommandCounterIncrement just
	 * in case something happened during parse/plan.
	 */</comment>
	<expr_stmt><expr><call><name>CommandCounterIncrement</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Send ParseComplete.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>whereToSendOutput</name> <operator>==</operator> <name>DestRemote</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>pq_putemptymessage</name><argument_list>(<argument><expr><literal type="char">'1'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Emit duration logging if appropriate.
	 */</comment>
	<switch>switch <condition>(<expr><call><name>check_log_duration</name><argument_list>(<argument><expr><name>msec_str</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><literal type="number">1</literal></expr>:</case>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"duration: %s ms"</literal></expr></argument>, <argument><expr><name>msec_str</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>polar_mark_slow_log</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call><operator>,</operator>   <comment type="block">/* POLAR */</comment>
					 <call><name>errhidestmt</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><literal type="number">2</literal></expr>:</case>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"duration: %s ms  parse %s: %s"</literal></expr></argument>,
							<argument><expr><name>msec_str</name></expr></argument>,
							<argument><expr><ternary><condition><expr><operator>*</operator><name>stmt_name</name></expr> ?</condition><then> <expr><name>stmt_name</name></expr> </then><else>: <expr><literal type="string">"&lt;unnamed&gt;"</literal></expr></else></ternary></expr></argument>,
							<argument><expr><name>query_string</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>polar_mark_slow_log</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call><operator>,</operator>   <comment type="block">/* POLAR */</comment>
					 <call><name>errhidestmt</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
	</block_content>}</block></switch>

	<if_stmt><if>if <condition>(<expr><name>save_log_statement_stats</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ShowUsage</name><argument_list>(<argument><expr><literal type="string">"PARSE MESSAGE STATISTICS"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>debug_query_string</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * exec_bind_message
 *
 * Process a "Bind" message to create a portal from a prepared statement
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>exec_bind_message</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>input_message</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>portal_name</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>stmt_name</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>numPFormats</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int16</name>	   <modifier>*</modifier></type><name>pformats</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>numParams</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>numRFormats</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int16</name>	   <modifier>*</modifier></type><name>rformats</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CachedPlanSource</name> <modifier>*</modifier></type><name>psrc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CachedPlan</name> <modifier>*</modifier></type><name>cplan</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Portal</name></type>		<name>portal</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>query_string</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>saved_stmt_name</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ParamListInfo</name></type> <name>params</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldContext</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>save_log_statement_stats</name> <init>= <expr><name>log_statement_stats</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>snapshot_set</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>msec_str</name><index>[<expr><literal type="number">32</literal></expr>]</index></name></decl>;</decl_stmt>

	<comment type="block">/* POLAR */</comment>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>params_string</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* Get the fixed part of the message */</comment>
	<expr_stmt><expr><name>portal_name</name> <operator>=</operator> <call><name>pq_getmsgstring</name><argument_list>(<argument><expr><name>input_message</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>stmt_name</name> <operator>=</operator> <call><name>pq_getmsgstring</name><argument_list>(<argument><expr><name>input_message</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>DEBUG2</name></expr></argument>,
			<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"bind %s to %s"</literal></expr></argument>,
					<argument><expr><ternary><condition><expr><operator>*</operator><name>portal_name</name></expr> ?</condition><then> <expr><name>portal_name</name></expr> </then><else>: <expr><literal type="string">"&lt;unnamed&gt;"</literal></expr></else></ternary></expr></argument>,
					<argument><expr><ternary><condition><expr><operator>*</operator><name>stmt_name</name></expr> ?</condition><then> <expr><name>stmt_name</name></expr> </then><else>: <expr><literal type="string">"&lt;unnamed&gt;"</literal></expr></else></ternary></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Find prepared statement */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>stmt_name</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'\0'</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>PreparedStatement</name> <modifier>*</modifier></type><name>pstmt</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>pstmt</name> <operator>=</operator> <call><name>FetchPreparedStatement</name><argument_list>(<argument><expr><name>stmt_name</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>psrc</name> <operator>=</operator> <name><name>pstmt</name><operator>-&gt;</operator><name>plansource</name></name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* special-case the unnamed statement */</comment>
		<expr_stmt><expr><name>psrc</name> <operator>=</operator> <name>unnamed_stmt_psrc</name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>psrc</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_PSTATEMENT</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"unnamed prepared statement does not exist"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/*
	 * Report query to various monitoring facilities.
	 */</comment>
	<expr_stmt><expr><name>debug_query_string</name> <operator>=</operator> <name><name>psrc</name><operator>-&gt;</operator><name>query_string</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>pgstat_report_activity</name><argument_list>(<argument><expr><name>STATE_RUNNING</name></expr></argument>, <argument><expr><name><name>psrc</name><operator>-&gt;</operator><name>query_string</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>set_ps_display</name><argument_list>(<argument><expr><literal type="string">"BIND"</literal></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>save_log_statement_stats</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ResetUsage</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Start up a transaction command so we can call functions etc. (Note that
	 * this will normally change current memory context.) Nothing happens if
	 * we are already in one.  This also arms the statement timeout if
	 * necessary.
	 */</comment>
	<expr_stmt><expr><call><name>start_xact_command</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Switch back to message context */</comment>
	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>MessageContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Get the parameter format codes */</comment>
	<expr_stmt><expr><name>numPFormats</name> <operator>=</operator> <call><name>pq_getmsgint</name><argument_list>(<argument><expr><name>input_message</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>numPFormats</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>pformats</name> <operator>=</operator> <operator>(</operator><name>int16</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>numPFormats</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int16</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>numPFormats</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>pformats</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>pq_getmsgint</name><argument_list>(<argument><expr><name>input_message</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Get the parameter value count */</comment>
	<expr_stmt><expr><name>numParams</name> <operator>=</operator> <call><name>pq_getmsgint</name><argument_list>(<argument><expr><name>input_message</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>numPFormats</name> <operator>&gt;</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <name>numPFormats</name> <operator>!=</operator> <name>numParams</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_PROTOCOL_VIOLATION</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"bind message has %d parameter formats but %d parameters"</literal></expr></argument>,
						<argument><expr><name>numPFormats</name></expr></argument>, <argument><expr><name>numParams</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>numParams</name> <operator>!=</operator> <name><name>psrc</name><operator>-&gt;</operator><name>num_params</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_PROTOCOL_VIOLATION</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"bind message supplies %d parameters, but prepared statement \"%s\" requires %d"</literal></expr></argument>,
						<argument><expr><name>numParams</name></expr></argument>, <argument><expr><name>stmt_name</name></expr></argument>, <argument><expr><name><name>psrc</name><operator>-&gt;</operator><name>num_params</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * If we are in aborted transaction state, the only portals we can
	 * actually run are those containing COMMIT or ROLLBACK commands. We
	 * disallow binding anything else to avoid problems with infrastructure
	 * that expects to run inside a valid transaction.  We also disallow
	 * binding any parameters, since we can't risk calling user-defined I/O
	 * functions.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>IsAbortedTransactionBlockState</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator>
		<operator>(</operator><operator>!</operator><operator>(</operator><name><name>psrc</name><operator>-&gt;</operator><name>raw_parse_tree</name></name> <operator>&amp;&amp;</operator>
		   <call><name>IsTransactionExitStmt</name><argument_list>(<argument><expr><name><name>psrc</name><operator>-&gt;</operator><name>raw_parse_tree</name><operator>-&gt;</operator><name>stmt</name></name></expr></argument>)</argument_list></call><operator>)</operator> <operator>||</operator>
		 <name>numParams</name> <operator>!=</operator> <literal type="number">0</literal><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_IN_FAILED_SQL_TRANSACTION</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"current transaction is aborted, "</literal>
						<literal type="string">"commands ignored until end of transaction block"</literal></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errdetail_abort</name><argument_list>()</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Create the portal.  Allow silent replacement of an existing portal only
	 * if the unnamed portal is specified.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>portal_name</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'\0'</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>portal</name> <operator>=</operator> <call><name>CreatePortal</name><argument_list>(<argument><expr><name>portal_name</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>portal</name> <operator>=</operator> <call><name>CreatePortal</name><argument_list>(<argument><expr><name>portal_name</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/* POLAR px */</comment>
	<expr_stmt><expr><name><name>portal</name><operator>-&gt;</operator><name>is_extended_query</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Prepare to copy stuff into the portal's memory context.  We do all this
	 * copying first, because it could possibly fail (out-of-memory) and we
	 * don't want a failure to occur between GetCachedPlan and
	 * PortalDefineQuery; that would result in leaking our plancache refcount.
	 */</comment>
	<expr_stmt><expr><name>oldContext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>portal</name><operator>-&gt;</operator><name>portalContext</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Copy the plan's query string into the portal */</comment>
	<expr_stmt><expr><name>query_string</name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><name><name>psrc</name><operator>-&gt;</operator><name>query_string</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Likewise make a copy of the statement name, unless it's unnamed */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>stmt_name</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>saved_stmt_name</name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><name>stmt_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>saved_stmt_name</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/*
	 * Set a snapshot if we have parameters to fetch (since the input
	 * functions might need it) or the query isn't a utility command (and
	 * hence could require redoing parse analysis and planning).  We keep the
	 * snapshot active till we're done, so that plancache.c doesn't have to
	 * take new ones.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>numParams</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>||</operator>
		<operator>(</operator><name><name>psrc</name><operator>-&gt;</operator><name>raw_parse_tree</name></name> <operator>&amp;&amp;</operator>
		 <call><name>analyze_requires_snapshot</name><argument_list>(<argument><expr><name><name>psrc</name><operator>-&gt;</operator><name>raw_parse_tree</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>PushActiveSnapshot</name><argument_list>(<argument><expr><call><name>GetTransactionSnapshot</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>snapshot_set</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Fetch parameters, if any, and store in the portal's memory context.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>numParams</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>paramno</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>params</name> <operator>=</operator> <operator>(</operator><name>ParamListInfo</name><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><call><name>offsetof</name><argument_list>(<argument><expr><name>ParamListInfoData</name></expr></argument>, <argument><expr><name>params</name></expr></argument>)</argument_list></call> <operator>+</operator>
										<name>numParams</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ParamExternData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* we have static list of params, so no hooks needed */</comment>
		<expr_stmt><expr><name><name>params</name><operator>-&gt;</operator><name>paramFetch</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>params</name><operator>-&gt;</operator><name>paramFetchArg</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>params</name><operator>-&gt;</operator><name>paramCompile</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>params</name><operator>-&gt;</operator><name>paramCompileArg</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>params</name><operator>-&gt;</operator><name>parserSetup</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>params</name><operator>-&gt;</operator><name>parserSetupArg</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>params</name><operator>-&gt;</operator><name>numParams</name></name> <operator>=</operator> <name>numParams</name></expr>;</expr_stmt>

		<for>for <control>(<init><expr><name>paramno</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>paramno</name> <operator>&lt;</operator> <name>numParams</name></expr>;</condition> <incr><expr><name>paramno</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Oid</name></type>			<name>ptype</name> <init>= <expr><name><name>psrc</name><operator>-&gt;</operator><name>param_types</name><index>[<expr><name>paramno</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int32</name></type>		<name>plength</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Datum</name></type>		<name>pval</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>bool</name></type>		<name>isNull</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>StringInfoData</name></type> <name>pbuf</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>char</name></type>		<name>csave</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int16</name></type>		<name>pformat</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>plength</name> <operator>=</operator> <call><name>pq_getmsgint</name><argument_list>(<argument><expr><name>input_message</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>isNull</name> <operator>=</operator> <operator>(</operator><name>plength</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>isNull</name></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>pvalue</name> <init>= <expr><call><name>pq_getmsgbytes</name><argument_list>(<argument><expr><name>input_message</name></expr></argument>, <argument><expr><name>plength</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

				<comment type="block">/*
				 * Rather than copying data around, we just set up a phony
				 * StringInfo pointing to the correct portion of the message
				 * buffer.  We assume we can scribble on the message buffer so
				 * as to maintain the convention that StringInfos have a
				 * trailing null.  This is grotty but is a big win when
				 * dealing with very large parameter strings.
				 */</comment>
				<expr_stmt><expr><name><name>pbuf</name><operator>.</operator><name>data</name></name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>pvalue</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>pbuf</name><operator>.</operator><name>maxlen</name></name> <operator>=</operator> <name>plength</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>pbuf</name><operator>.</operator><name>len</name></name> <operator>=</operator> <name>plength</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>pbuf</name><operator>.</operator><name>cursor</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

				<expr_stmt><expr><name>csave</name> <operator>=</operator> <name><name>pbuf</name><operator>.</operator><name>data</name><index>[<expr><name>plength</name></expr>]</index></name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>pbuf</name><operator>.</operator><name>data</name><index>[<expr><name>plength</name></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<expr_stmt><expr><name><name>pbuf</name><operator>.</operator><name>data</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>	<comment type="block">/* keep compiler quiet */</comment>
				<expr_stmt><expr><name>csave</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>

			<if_stmt><if>if <condition>(<expr><name>numPFormats</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>pformat</name> <operator>=</operator> <name><name>pformats</name><index>[<expr><name>paramno</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></if>
			<if type="elseif">else if <condition>(<expr><name>numPFormats</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>pformat</name> <operator>=</operator> <name><name>pformats</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name>pformat</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>	<comment type="block">/* default = text */</comment>

			<if_stmt><if>if <condition>(<expr><name>pformat</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>	<comment type="block">/* text mode */</comment>
			<block>{<block_content>
				<decl_stmt><decl><type><name>Oid</name></type>			<name>typinput</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>Oid</name></type>			<name>typioparam</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>pstring</name></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>getTypeInputInfo</name><argument_list>(<argument><expr><name>ptype</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>typinput</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>typioparam</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/*
				 * We have to do encoding conversion before calling the
				 * typinput routine.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><name>isNull</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>pstring</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><name>pstring</name> <operator>=</operator> <call><name>pg_client_to_server</name><argument_list>(<argument><expr><name><name>pbuf</name><operator>.</operator><name>data</name></name></expr></argument>, <argument><expr><name>plength</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

				<expr_stmt><expr><name>pval</name> <operator>=</operator> <call><name>OidInputFunctionCall</name><argument_list>(<argument><expr><name>typinput</name></expr></argument>, <argument><expr><name>pstring</name></expr></argument>, <argument><expr><name>typioparam</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/* Free result of encoding conversion, if any */</comment>
				<if_stmt><if>if <condition>(<expr><name>pstring</name> <operator>&amp;&amp;</operator> <name>pstring</name> <operator>!=</operator> <name><name>pbuf</name><operator>.</operator><name>data</name></name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>pstring</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block></if>
			<if type="elseif">else if <condition>(<expr><name>pformat</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition>	<comment type="block">/* binary mode */</comment>
			<block>{<block_content>
				<decl_stmt><decl><type><name>Oid</name></type>			<name>typreceive</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>Oid</name></type>			<name>typioparam</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>StringInfo</name></type>	<name>bufptr</name></decl>;</decl_stmt>

				<comment type="block">/*
				 * Call the parameter type's binary input converter
				 */</comment>
				<expr_stmt><expr><call><name>getTypeBinaryInputInfo</name><argument_list>(<argument><expr><name>ptype</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>typreceive</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>typioparam</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<if_stmt><if>if <condition>(<expr><name>isNull</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>bufptr</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><name>bufptr</name> <operator>=</operator> <operator>&amp;</operator><name>pbuf</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

				<expr_stmt><expr><name>pval</name> <operator>=</operator> <call><name>OidReceiveFunctionCall</name><argument_list>(<argument><expr><name>typreceive</name></expr></argument>, <argument><expr><name>bufptr</name></expr></argument>, <argument><expr><name>typioparam</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/* Trouble if it didn't eat the whole buffer */</comment>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><name>isNull</name> <operator>&amp;&amp;</operator> <name><name>pbuf</name><operator>.</operator><name>cursor</name></name> <operator>!=</operator> <name><name>pbuf</name><operator>.</operator><name>len</name></name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_BINARY_REPRESENTATION</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"incorrect binary data format in bind parameter %d"</literal></expr></argument>,
									<argument><expr><name>paramno</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"unsupported format code: %d"</literal></expr></argument>,
								<argument><expr><name>pformat</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>pval</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>		<comment type="block">/* keep compiler quiet */</comment>
			</block_content>}</block></else></if_stmt>

			<comment type="block">/* Restore message buffer contents */</comment>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>isNull</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>pbuf</name><operator>.</operator><name>data</name><index>[<expr><name>plength</name></expr>]</index></name> <operator>=</operator> <name>csave</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<expr_stmt><expr><name><name>params</name><operator>-&gt;</operator><name>params</name><index>[<expr><name>paramno</name></expr>]</index></name><operator>.</operator><name>value</name> <operator>=</operator> <name>pval</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>params</name><operator>-&gt;</operator><name>params</name><index>[<expr><name>paramno</name></expr>]</index></name><operator>.</operator><name>isnull</name> <operator>=</operator> <name>isNull</name></expr>;</expr_stmt>

			<comment type="block">/*
			 * We mark the params as CONST.  This ensures that any custom plan
			 * makes full use of the parameter values.
			 */</comment>
			<expr_stmt><expr><name><name>params</name><operator>-&gt;</operator><name>params</name><index>[<expr><name>paramno</name></expr>]</index></name><operator>.</operator><name>pflags</name> <operator>=</operator> <name>PARAM_FLAG_CONST</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>params</name><operator>-&gt;</operator><name>params</name><index>[<expr><name>paramno</name></expr>]</index></name><operator>.</operator><name>ptype</name> <operator>=</operator> <name>ptype</name></expr>;</expr_stmt>
		</block_content>}</block></for>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>params</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/* Done storing stuff in portal's context */</comment>
	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Get the result format codes */</comment>
	<expr_stmt><expr><name>numRFormats</name> <operator>=</operator> <call><name>pq_getmsgint</name><argument_list>(<argument><expr><name>input_message</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>numRFormats</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>rformats</name> <operator>=</operator> <operator>(</operator><name>int16</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>numRFormats</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int16</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>numRFormats</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>rformats</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>pq_getmsgint</name><argument_list>(<argument><expr><name>input_message</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>pq_getmsgend</name><argument_list>(<argument><expr><name>input_message</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* POLAR px */</comment>
	<if_stmt><if>if <condition>(<expr><name>px_enable_prepare_statement</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>psrc</name><operator>-&gt;</operator><name>cursor_options</name></name> <operator>|=</operator> <name>CURSOR_OPT_PX_OK</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<comment type="block">/*
	 * Obtain a plan from the CachedPlanSource.  Any cruft from (re)planning
	 * will be generated in MessageContext.  The plan refcount will be
	 * assigned to the Portal, so it will be released at portal destruction.
	 */</comment>
	<expr_stmt><expr><name>cplan</name> <operator>=</operator> <call><name>GetCachedPlan</name><argument_list>(<argument><expr><name>psrc</name></expr></argument>, <argument><expr><name>params</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Now we can define the portal.
	 *
	 * DO NOT put any code that could possibly throw an error between the
	 * above GetCachedPlan call and here.
	 */</comment>
	<expr_stmt><expr><call><name>PortalDefineQuery</name><argument_list>(<argument><expr><name>portal</name></expr></argument>,
					  <argument><expr><name>saved_stmt_name</name></expr></argument>,
					  <argument><expr><name>query_string</name></expr></argument>,
					  <argument><expr><name>T_Invalid</name></expr></argument>,<comment type="block">/* POLAR px */</comment>
					  <argument><expr><name><name>psrc</name><operator>-&gt;</operator><name>commandTag</name></name></expr></argument>,
					  <argument><expr><name><name>cplan</name><operator>-&gt;</operator><name>stmt_list</name></name></expr></argument>,
					  <argument><expr><name>cplan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Done with the snapshot used for parameter I/O and parsing/planning */</comment>
	<if_stmt><if>if <condition>(<expr><name>snapshot_set</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PopActiveSnapshot</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * And we're ready to start portal execution.
	 */</comment>
	<expr_stmt><expr><call><name>PortalStart</name><argument_list>(<argument><expr><name>portal</name></expr></argument>,
				<argument><expr><name>params</name></expr></argument>,
				<argument><expr><literal type="number">0</literal></expr></argument>,
				<argument><expr><name>InvalidSnapshot</name></expr></argument>,
				<argument><expr><name>NULL</name></expr></argument><comment type="block">/* POALR px */</comment>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Apply the result format requests to the portal.
	 */</comment>
	<expr_stmt><expr><call><name>PortalSetResultFormat</name><argument_list>(<argument><expr><name>portal</name></expr></argument>, <argument><expr><name>numRFormats</name></expr></argument>, <argument><expr><name>rformats</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Send BindComplete.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>whereToSendOutput</name> <operator>==</operator> <name>DestRemote</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>pq_putemptymessage</name><argument_list>(<argument><expr><literal type="char">'2'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* POLAR: get errmsg params string, we must free it in the last */</comment>
	<expr_stmt><expr><name>params_string</name> <operator>=</operator> <call><name>polar_get_errmsg_params</name><argument_list>(<argument><expr><name>params</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* POLAR end */</comment>

	<comment type="block">/*
	 * Emit duration logging if appropriate.
	 */</comment>
	<switch>switch <condition>(<expr><call><name>check_log_duration</name><argument_list>(<argument><expr><name>msec_str</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><literal type="number">1</literal></expr>:</case>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"duration: %s ms"</literal></expr></argument>, <argument><expr><name>msec_str</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>polar_mark_slow_log</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call><operator>,</operator>    <comment type="block">/* POLAR */</comment>
					 <call><name>errhidestmt</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><literal type="number">2</literal></expr>:</case>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"duration: %s ms  bind %s%s%s: %s\nparams: %s"</literal></expr></argument>,
							<argument><expr><name>msec_str</name></expr></argument>,
							<argument><expr><ternary><condition><expr><operator>*</operator><name>stmt_name</name></expr> ?</condition><then> <expr><name>stmt_name</name></expr> </then><else>: <expr><literal type="string">"&lt;unnamed&gt;"</literal></expr></else></ternary></expr></argument>,
							<argument><expr><ternary><condition><expr><operator>*</operator><name>portal_name</name></expr> ?</condition><then> <expr><literal type="string">"/"</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>,
							<argument><expr><ternary><condition><expr><operator>*</operator><name>portal_name</name></expr> ?</condition><then> <expr><name>portal_name</name></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>,
							<argument><expr><name><name>psrc</name><operator>-&gt;</operator><name>query_string</name></name></expr></argument>,
							<argument><expr><ternary><condition><expr><name>params_string</name></expr> ?</condition><then> <expr><name>params_string</name></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>polar_mark_slow_log</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call><operator>,</operator>    <comment type="block">/* POLAR */</comment>
					 <call><name>errhidestmt</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
	</block_content>}</block></switch>

	<comment type="block">/* POLAR: free params_string */</comment>
	<if_stmt><if>if <condition>(<expr><name>params_string</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>params_string</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<comment type="block">/* POLAR end */</comment>

	<if_stmt><if>if <condition>(<expr><name>save_log_statement_stats</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ShowUsage</name><argument_list>(<argument><expr><literal type="string">"BIND MESSAGE STATISTICS"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>debug_query_string</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * exec_execute_message
 *
 * Process an "Execute" message for a portal
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>exec_execute_message</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>portal_name</name></decl></parameter>, <parameter><decl><type><name>long</name></type> <name>max_rows</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>CommandDest</name></type> <name>dest</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>DestReceiver</name> <modifier>*</modifier></type><name>receiver</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Portal</name></type>		<name>portal</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>completed</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>completionTag</name><index>[<expr><name>COMPLETION_TAG_BUFSIZE</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>sourceText</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>prepStmtName</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ParamListInfo</name></type> <name>portalParams</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>save_log_statement_stats</name> <init>= <expr><name>log_statement_stats</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>is_xact_command</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>execute_is_fetch</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>was_logged</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>msec_str</name><index>[<expr><literal type="number">32</literal></expr>]</index></name></decl>;</decl_stmt>

	<comment type="block">/* POLAR */</comment>
	<decl_stmt><decl><type><name>ListCell</name>	<modifier>*</modifier></type><name>stmt_item</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>needs_mask</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>to_log</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>		<name>log_mode</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>params_string</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* Adjust destination to tell printtup.c what to do */</comment>
	<expr_stmt><expr><name>dest</name> <operator>=</operator> <name>whereToSendOutput</name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>dest</name> <operator>==</operator> <name>DestRemote</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>dest</name> <operator>=</operator> <name>DestRemoteExecute</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>portal</name> <operator>=</operator> <call><name>GetPortalByName</name><argument_list>(<argument><expr><name>portal_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>PortalIsValid</name><argument_list>(<argument><expr><name>portal</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_CURSOR</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"portal \"%s\" does not exist"</literal></expr></argument>, <argument><expr><name>portal_name</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * If the original query was a null string, just return
	 * EmptyQueryResponse.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>portal</name><operator>-&gt;</operator><name>commandTag</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>portal</name><operator>-&gt;</operator><name>stmts</name></name> <operator>==</operator> <name>NIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>NullCommand</name><argument_list>(<argument><expr><name>dest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Does the portal contain a transaction command? */</comment>
	<expr_stmt><expr><name>is_xact_command</name> <operator>=</operator> <call><name>IsTransactionStmtList</name><argument_list>(<argument><expr><name><name>portal</name><operator>-&gt;</operator><name>stmts</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * We must copy the sourceText and prepStmtName into MessageContext in
	 * case the portal is destroyed during finish_xact_command. Can avoid the
	 * copy if it's not an xact command, though.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>is_xact_command</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>sourceText</name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><name><name>portal</name><operator>-&gt;</operator><name>sourceText</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>portal</name><operator>-&gt;</operator><name>prepStmtName</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>prepStmtName</name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><name><name>portal</name><operator>-&gt;</operator><name>prepStmtName</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>prepStmtName</name> <operator>=</operator> <literal type="string">"&lt;unnamed&gt;"</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<comment type="block">/*
		 * An xact command shouldn't have any parameters, which is a good
		 * thing because they wouldn't be around after finish_xact_command.
		 */</comment>
		<expr_stmt><expr><name>portalParams</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name>sourceText</name> <operator>=</operator> <name><name>portal</name><operator>-&gt;</operator><name>sourceText</name></name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>portal</name><operator>-&gt;</operator><name>prepStmtName</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>prepStmtName</name> <operator>=</operator> <name><name>portal</name><operator>-&gt;</operator><name>prepStmtName</name></name></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>prepStmtName</name> <operator>=</operator> <literal type="string">"&lt;unnamed&gt;"</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>
		<expr_stmt><expr><name>portalParams</name> <operator>=</operator> <name><name>portal</name><operator>-&gt;</operator><name>portalParams</name></name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/*
	 * Report query to various monitoring facilities.
	 */</comment>
	<expr_stmt><expr><name>debug_query_string</name> <operator>=</operator> <name>sourceText</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>pgstat_report_activity</name><argument_list>(<argument><expr><name>STATE_RUNNING</name></expr></argument>, <argument><expr><name>sourceText</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>set_ps_display</name><argument_list>(<argument><expr><name><name>portal</name><operator>-&gt;</operator><name>commandTag</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>save_log_statement_stats</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ResetUsage</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>BeginCommand</name><argument_list>(<argument><expr><name><name>portal</name><operator>-&gt;</operator><name>commandTag</name></name></expr></argument>, <argument><expr><name>dest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Create dest receiver in MessageContext (we don't want it in transaction
	 * context, because that may get deleted if portal contains VACUUM).
	 */</comment>
	<expr_stmt><expr><name>receiver</name> <operator>=</operator> <call><name>CreateDestReceiver</name><argument_list>(<argument><expr><name>dest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>dest</name> <operator>==</operator> <name>DestRemoteExecute</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>SetRemoteDestReceiverParams</name><argument_list>(<argument><expr><name>receiver</name></expr></argument>, <argument><expr><name>portal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Ensure we are in a transaction command (this should normally be the
	 * case already due to prior BIND).
	 */</comment>
	<expr_stmt><expr><call><name>start_xact_command</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If we re-issue an Execute protocol request against an existing portal,
	 * then we are only fetching more rows rather than completely re-executing
	 * the query from the start. atStart is never reset for a v3 portal, so we
	 * are safe to use this check.
	 */</comment>
	<expr_stmt><expr><name>execute_is_fetch</name> <operator>=</operator> <operator>!</operator><name><name>portal</name><operator>-&gt;</operator><name>atStart</name></name></expr>;</expr_stmt>

	<comment type="block">/* POLAR: else we have to inspect the statement(s) to see whether to log */</comment>
	<macro><name>foreach</name><argument_list>(<argument>stmt_item</argument>, <argument>portal-&gt;stmts</argument>)</argument_list></macro>
	<block>{<block_content>
		 <decl_stmt><decl><type><name>Node</name>       <modifier>*</modifier></type><name>stmt</name> <init>= <expr><operator>(</operator><operator>(</operator><name>PlannedStmt</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>stmt_item</name></expr></argument>)</argument_list></call><operator>)</operator><operator>-&gt;</operator><name>utilityStmt</name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>stmt</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <call><name>polar_stmt_type_needs_mask</name><argument_list>(<argument><expr><call><name>nodeTag</name><argument_list>(<argument><expr><name>stmt</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>needs_mask</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>

	<comment type="block">/* Log immediately if dictated by log_statement */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>check_log_statement</name><argument_list>(<argument><expr><name><name>portal</name><operator>-&gt;</operator><name>stmts</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><operator>(</operator><name>needs_mask</name> <operator>&amp;&amp;</operator> <name><name>MyProc</name><operator>-&gt;</operator><name>issuper</name></name><operator>)</operator></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>polar_audit_log</name><operator>.</operator><name>query_string</name></name> <operator>=</operator> <name>sourceText</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>to_log</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* POLAR end */</comment>

	<comment type="block">/*
	 * If we are in aborted transaction state, the only portals we can
	 * actually run are those containing COMMIT or ROLLBACK commands.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>IsAbortedTransactionBlockState</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator>
		<operator>!</operator><call><name>IsTransactionExitStmtList</name><argument_list>(<argument><expr><name><name>portal</name><operator>-&gt;</operator><name>stmts</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_IN_FAILED_SQL_TRANSACTION</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"current transaction is aborted, "</literal>
						<literal type="string">"commands ignored until end of transaction block"</literal></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errdetail_abort</name><argument_list>()</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Check for cancel signal before we start execution */</comment>
	<expr_stmt><expr><call><name>CHECK_FOR_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Okay to run the portal.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>max_rows</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>max_rows</name> <operator>=</operator> <name>FETCH_ALL</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>completed</name> <operator>=</operator> <call><name>PortalRun</name><argument_list>(<argument><expr><name>portal</name></expr></argument>,
						  <argument><expr><name>max_rows</name></expr></argument>,
						  <argument><expr><name>true</name></expr></argument>, <comment type="block">/* always top level */</comment>
						  <argument><expr><operator>!</operator><name>execute_is_fetch</name> <operator>&amp;&amp;</operator> <name>max_rows</name> <operator>==</operator> <name>FETCH_ALL</name></expr></argument>,
						  <argument><expr><name>receiver</name></expr></argument>,
						  <argument><expr><name>receiver</name></expr></argument>,
						  <argument><expr><name>completionTag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name><name>receiver</name><operator>-&gt;</operator><name>rDestroy</name></name><argument_list>(<argument><expr><name>receiver</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>completed</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>is_xact_command</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * If this was a transaction control statement, commit it.  We
			 * will start a new xact command for the next command (if any).
			 */</comment>
			<expr_stmt><expr><call><name>finish_xact_command</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/*
			 * We need a CommandCounterIncrement after every query, except
			 * those that start or end a transaction block.
			 */</comment>
			<expr_stmt><expr><call><name>CommandCounterIncrement</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* full command has been executed, reset timeout */</comment>
			<expr_stmt><expr><call><name>disable_statement_timeout</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<comment type="block">/* Send appropriate CommandComplete to client */</comment>
		<expr_stmt><expr><call><name>EndCommand</name><argument_list>(<argument><expr><name>completionTag</name></expr></argument>, <argument><expr><name>dest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* Portal run not complete, so send PortalSuspended */</comment>
		<if_stmt><if>if <condition>(<expr><name>whereToSendOutput</name> <operator>==</operator> <name>DestRemote</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>pq_putemptymessage</name><argument_list>(<argument><expr><literal type="char">'s'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>to_log</name></expr>)</condition>
	<block>{<block_content>
	    <comment type="block">/* POLAR: get errmsg params string, we must free it in the last */</comment>
		<comment type="line">// It needs to malloc and free twice, not so efficiency.</comment>
	    <expr_stmt><expr><name>params_string</name> <operator>=</operator> <call><name>polar_get_errmsg_params</name><argument_list>(<argument><expr><name>portalParams</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>polar_enable_multi_syslogger</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>ErrorData</name></type> <name>edata</name></decl>;</decl_stmt>
			<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><operator>&amp;</operator><name>edata</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ErrorData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>edata</name><operator>.</operator><name>elevel</name></name> <operator>=</operator> <name>LOG</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>edata</name><operator>.</operator><name>is_audit_log</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>edata</name><operator>.</operator><name>hide_stmt</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>edata</name><operator>.</operator><name>output_to_server</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>edata</name><operator>.</operator><name>message</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>edata</name><operator>.</operator><name>needs_mask</name></name> <operator>=</operator> <name>needs_mask</name></expr>;</expr_stmt>

			<comment type="block">/* POLAR: if portalParams exsits, print audit log sql with bind parameters */</comment>
			<if_stmt><if>if <condition>(<expr><name>polar_enable_audit_log_bind_sql_parameter_new</name></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>char</name>	<modifier>*</modifier></type><name>audit_sql_log</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

				<comment type="block">/* get the bind statement when param exists*/</comment>
				<expr_stmt><expr><name>audit_sql_log</name> <operator>=</operator> <call><name>polar_bind_sql_with_parameter</name><argument_list>(<argument><expr><name>prepStmtName</name></expr></argument>, <argument><expr><name>portalParams</name></expr></argument>, <argument><expr><name>sourceText</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/* POLAR: print audit log*/</comment>
				<expr_stmt><expr><call><name>polar_write_audit_log</name><argument_list>(<argument><expr><operator>&amp;</operator><name>edata</name></expr></argument>,
								<argument><expr><literal type="string">"%s %s%s%s: %s"</literal></expr></argument>,
								<argument><expr><ternary><condition><expr><name>execute_is_fetch</name></expr> ?</condition><then>
								<expr><literal type="string">"execute fetch from"</literal></expr> </then><else>:
								<expr><literal type="string">"execute"</literal></expr></else></ternary></expr></argument>,
								<argument><expr><name>prepStmtName</name></expr></argument>,
								<argument><expr><ternary><condition><expr><operator>*</operator><name>portal_name</name></expr> ?</condition><then> <expr><literal type="string">"/"</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>,
								<argument><expr><ternary><condition><expr><operator>*</operator><name>portal_name</name></expr> ?</condition><then> <expr><name>portal_name</name></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>,
								<argument><expr><ternary><condition><expr><name>audit_sql_log</name></expr> ?</condition><then> <expr><name>audit_sql_log</name></expr> </then><else>: <expr><name>sourceText</name></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/* POLAR: free audit_sql_log */</comment>
				<if_stmt><if>if <condition>(<expr><name>audit_sql_log</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>audit_sql_log</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<expr_stmt><expr><call><name>polar_write_audit_log</name><argument_list>(<argument><expr><operator>&amp;</operator><name>edata</name></expr></argument>,
								<argument><expr><literal type="string">"%s %s%s%s: %s\nparams: %s"</literal></expr></argument>,
								<argument><expr><ternary><condition><expr><name>execute_is_fetch</name></expr> ?</condition><then>
								<expr><literal type="string">"execute fetch from"</literal></expr> </then><else>:
								<expr><literal type="string">"execute"</literal></expr></else></ternary></expr></argument>,
								<argument><expr><name>prepStmtName</name></expr></argument>,
								<argument><expr><ternary><condition><expr><operator>*</operator><name>portal_name</name></expr> ?</condition><then> <expr><literal type="string">"/"</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>,
								<argument><expr><ternary><condition><expr><operator>*</operator><name>portal_name</name></expr> ?</condition><then> <expr><name>portal_name</name></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>,
								<argument><expr><name>sourceText</name></expr></argument>,
								<argument><expr><ternary><condition><expr><name>params_string</name></expr> ?</condition><then> <expr><name>params_string</name></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"%s %s%s%s: %s\nparams: %s"</literal></expr></argument>,
							<argument><expr><ternary><condition><expr><name>execute_is_fetch</name></expr> ?</condition><then>
							<expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"execute fetch from"</literal></expr></argument>)</argument_list></call></expr> </then><else>:
							<expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"execute"</literal></expr></argument>)</argument_list></call></expr></else></ternary></expr></argument>,
							<argument><expr><name>prepStmtName</name></expr></argument>,
							<argument><expr><ternary><condition><expr><operator>*</operator><name>portal_name</name></expr> ?</condition><then> <expr><literal type="string">"/"</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>,
							<argument><expr><ternary><condition><expr><operator>*</operator><name>portal_name</name></expr> ?</condition><then> <expr><name>portal_name</name></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>,
							<argument><expr><name>sourceText</name></expr></argument>,
							<argument><expr><ternary><condition><expr><name>params_string</name></expr> ?</condition><then> <expr><name>params_string</name></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errhidestmt</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>polar_mark_audit_log</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>polar_mark_needs_mask</name><argument_list>(<argument><expr><name>needs_mask</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	    <comment type="block">/* POLAR end */</comment>

		<expr_stmt><expr><name>was_logged</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Emit duration logging if appropriate.
	 */</comment>
  	<expr_stmt><expr><name>log_mode</name> <operator>=</operator> <call><name>check_log_duration</name><argument_list>(<argument><expr><name>msec_str</name></expr></argument>, <argument><expr><name>was_logged</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
 
  	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>log_mode</name> <operator>==</operator> <literal type="number">2</literal><operator>)</operator> <operator>&amp;&amp;</operator> <name>needs_mask</name> <operator>&amp;&amp;</operator> <name><name>MyProc</name><operator>-&gt;</operator><name>issuper</name></name></expr>)</condition><block type="pseudo"><block_content>
  		<expr_stmt><expr><name>log_mode</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
  	
  	<switch>switch <condition>(<expr><name>log_mode</name></expr>)</condition>
  	<block>{<block_content>
  		<case>case <expr><literal type="number">1</literal></expr>:</case>
  			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
  					<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"duration: %s ms"</literal></expr></argument>, <argument><expr><name>msec_str</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>polar_mark_slow_log</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call><operator>,</operator>    <comment type="block">/* POLAR */</comment>
  					 <call><name>errhidestmt</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  			<break>break;</break>
  		<case>case <expr><literal type="number">2</literal></expr>:</case>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"duration: %s ms  %s %s%s%s: %s\nparams: %s"</literal></expr></argument>,
							<argument><expr><name>msec_str</name></expr></argument>,
							<argument><expr><ternary><condition><expr><name>execute_is_fetch</name></expr> ?</condition><then>
							<expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"execute fetch from"</literal></expr></argument>)</argument_list></call></expr> </then><else>:
							<expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"execute"</literal></expr></argument>)</argument_list></call></expr></else></ternary></expr></argument>,
							<argument><expr><name>prepStmtName</name></expr></argument>,
							<argument><expr><ternary><condition><expr><operator>*</operator><name>portal_name</name></expr> ?</condition><then> <expr><literal type="string">"/"</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>,
							<argument><expr><ternary><condition><expr><operator>*</operator><name>portal_name</name></expr> ?</condition><then> <expr><name>portal_name</name></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>,
							<argument><expr><name>sourceText</name></expr></argument>,
							<argument><expr><ternary><condition><expr><name>params_string</name></expr> ?</condition><then> <expr><name>params_string</name></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>)</argument_list></call><operator>,</operator>
					<call><name>errhidestmt</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call><operator>,</operator>
					<call><name>polar_mark_slow_log</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call><operator>,</operator>   <comment type="block">/* POLAR */</comment>
					<call><name>polar_mark_needs_mask</name><argument_list>(<argument><expr><name>needs_mask</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  			<break>break;</break>
  	</block_content>}</block></switch>
 
  	<comment type="block">/* POLAR: free params_string */</comment>
  	<if_stmt><if>if <condition>(<expr><name>params_string</name></expr>)</condition><block type="pseudo"><block_content>
  		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>params_string</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  	<comment type="block">/* POLAR end */</comment>

  	<if_stmt><if>if <condition>(<expr><name>save_log_statement_stats</name></expr>)</condition><block type="pseudo"><block_content>
  		<expr_stmt><expr><call><name>ShowUsage</name><argument_list>(<argument><expr><literal type="string">"EXECUTE MESSAGE STATISTICS"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
 
	<expr_stmt><expr><name>debug_query_string</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * check_log_statement
 *		Determine whether command should be logged because of log_statement
 *
 * stmt_list can be either raw grammar output or a list of planned
 * statements
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>check_log_statement</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>stmt_list</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>stmt_item</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>log_statement</name> <operator>==</operator> <name>LOGSTMT_NONE</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>log_statement</name> <operator>==</operator> <name>LOGSTMT_ALL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* Else we have to inspect the statement(s) to see whether to log */</comment>
	<macro><name>foreach</name><argument_list>(<argument>stmt_item</argument>, <argument>stmt_list</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>stmt</name> <init>= <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>stmt_item</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>GetCommandLogLevel</name><argument_list>(<argument><expr><name>stmt</name></expr></argument>)</argument_list></call> <operator>&lt;=</operator> <name>log_statement</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block>

	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * check_log_duration
 *		Determine whether current command's duration should be logged
 *
 * Returns:
 *		0 if no logging is needed
 *		1 if just the duration should be logged
 *		2 if duration and query details should be logged
 *
 * If logging is needed, the duration in msec is formatted into msec_str[],
 * which must be a 32-byte buffer.
 *
 * was_logged should be true if caller already logged query details (this
 * essentially prevents 2 from being returned).
 */</comment>
<function><type><name>int</name></type>
<name>check_log_duration</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>msec_str</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>was_logged</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>log_duration</name> <operator>||</operator> <name>log_min_duration_statement</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>long</name></type>		<name>secs</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>usecs</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>msecs</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>exceeded</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>TimestampDifference</name><argument_list>(<argument><expr><call><name>GetCurrentStatementStartTimestamp</name><argument_list>()</argument_list></call></expr></argument>,
							<argument><expr><call><name>GetCurrentTimestamp</name><argument_list>()</argument_list></call></expr></argument>,
							<argument><expr><operator>&amp;</operator><name>secs</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>usecs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>msecs</name> <operator>=</operator> <name>usecs</name> <operator>/</operator> <literal type="number">1000</literal></expr>;</expr_stmt>

		<comment type="block">/*
		 * This odd-looking test for log_min_duration_statement being exceeded
		 * is designed to avoid integer overflow with very long durations:
		 * don't compute secs * 1000 until we've verified it will fit in int.
		 */</comment>
		<expr_stmt><expr><name>exceeded</name> <operator>=</operator> <operator>(</operator><name>log_min_duration_statement</name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
					<operator>(</operator><name>log_min_duration_statement</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
					 <operator>(</operator><name>secs</name> <operator>&gt;</operator> <name>log_min_duration_statement</name> <operator>/</operator> <literal type="number">1000</literal> <operator>||</operator>
					  <name>secs</name> <operator>*</operator> <literal type="number">1000</literal> <operator>+</operator> <name>msecs</name> <operator>&gt;=</operator> <name>log_min_duration_statement</name><operator>)</operator><operator>)</operator><operator>)</operator></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>exceeded</name> <operator>||</operator> <name>log_duration</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>msec_str</name></expr></argument>, <argument><expr><literal type="number">32</literal></expr></argument>, <argument><expr><literal type="string">"%ld.%03d"</literal></expr></argument>,
					 <argument><expr><name>secs</name> <operator>*</operator> <literal type="number">1000</literal> <operator>+</operator> <name>msecs</name></expr></argument>, <argument><expr><name>usecs</name> <operator>%</operator> <literal type="number">1000</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>exceeded</name> <operator>&amp;&amp;</operator> <operator>(</operator><operator>!</operator><name>was_logged</name> <operator>||</operator> <name>polar_log_statement_with_duration</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><literal type="number">2</literal></expr>;</return></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></else></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * errdetail_execute
 *
 * Add an errdetail() line showing the query referenced by an EXECUTE, if any.
 * The argument is the raw parsetree list.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>errdetail_execute</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>raw_parsetree_list</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>parsetree_item</name></decl>;</decl_stmt>

	<macro><name>foreach</name><argument_list>(<argument>parsetree_item</argument>, <argument>raw_parsetree_list</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>RawStmt</name>    <modifier>*</modifier></type><name>parsetree</name> <init>= <expr><call><name>lfirst_node</name><argument_list>(<argument><expr><name>RawStmt</name></expr></argument>, <argument><expr><name>parsetree_item</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name><name>parsetree</name><operator>-&gt;</operator><name>stmt</name></name></expr></argument>, <argument><expr><name>ExecuteStmt</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>ExecuteStmt</name> <modifier>*</modifier></type><name>stmt</name> <init>= <expr><operator>(</operator><name>ExecuteStmt</name> <operator>*</operator><operator>)</operator> <name><name>parsetree</name><operator>-&gt;</operator><name>stmt</name></name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>PreparedStatement</name> <modifier>*</modifier></type><name>pstmt</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>pstmt</name> <operator>=</operator> <call><name>FetchPreparedStatement</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>pstmt</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"prepare: %s"</literal></expr></argument>, <argument><expr><name><name>pstmt</name><operator>-&gt;</operator><name>plansource</name><operator>-&gt;</operator><name>query_string</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr><literal type="number">0</literal></expr>;</return>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>

	<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * errdetail_abort
 *
 * Add an errdetail() line showing abort reason, if any.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>errdetail_abort</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name><name>MyProc</name><operator>-&gt;</operator><name>recoveryConflictPending</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"abort reason: recovery conflict"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * errdetail_recovery_conflict
 *
 * Add an errdetail() line showing conflict source.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>errdetail_recovery_conflict</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<switch>switch <condition>(<expr><name>RecoveryConflictReason</name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>PROCSIG_RECOVERY_CONFLICT_BUFFERPIN</name></expr>:</case>
			<expr_stmt><expr><call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"User was holding shared buffer pin for too long."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>PROCSIG_RECOVERY_CONFLICT_LOCK</name></expr>:</case>
			<expr_stmt><expr><call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"User was holding a relation lock for too long."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>PROCSIG_RECOVERY_CONFLICT_TABLESPACE</name></expr>:</case>
			<expr_stmt><expr><call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"User was or might have been using tablespace that must be dropped."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>PROCSIG_RECOVERY_CONFLICT_SNAPSHOT</name></expr>:</case>
			<expr_stmt><expr><call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"User query might have needed to see row versions that must be removed."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>PROCSIG_RECOVERY_CONFLICT_STARTUP_DEADLOCK</name></expr>:</case>
			<expr_stmt><expr><call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"User transaction caused buffer deadlock with recovery."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>PROCSIG_RECOVERY_CONFLICT_DATABASE</name></expr>:</case>
			<expr_stmt><expr><call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"User was connected to a database that must be dropped."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<default>default:</default>
			<break>break;</break>
			<comment type="block">/* no errdetail */</comment>
	</block_content>}</block></switch>

	<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * exec_describe_statement_message
 *
 * Process a "Describe" message for a prepared statement
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>exec_describe_statement_message</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>stmt_name</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>CachedPlanSource</name> <modifier>*</modifier></type><name>psrc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Start up a transaction command. (Note that this will normally change
	 * current memory context.) Nothing happens if we are already in one.
	 */</comment>
	<expr_stmt><expr><call><name>start_xact_command</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Switch back to message context */</comment>
	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>MessageContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Find prepared statement */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>stmt_name</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'\0'</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>PreparedStatement</name> <modifier>*</modifier></type><name>pstmt</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>pstmt</name> <operator>=</operator> <call><name>FetchPreparedStatement</name><argument_list>(<argument><expr><name>stmt_name</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>psrc</name> <operator>=</operator> <name><name>pstmt</name><operator>-&gt;</operator><name>plansource</name></name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* special-case the unnamed statement */</comment>
		<expr_stmt><expr><name>psrc</name> <operator>=</operator> <name>unnamed_stmt_psrc</name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>psrc</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_PSTATEMENT</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"unnamed prepared statement does not exist"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/* Prepared statements shouldn't have changeable result descs */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>psrc</name><operator>-&gt;</operator><name>fixed_result</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If we are in aborted transaction state, we can't run
	 * SendRowDescriptionMessage(), because that needs catalog accesses.
	 * Hence, refuse to Describe statements that return data.  (We shouldn't
	 * just refuse all Describes, since that might break the ability of some
	 * clients to issue COMMIT or ROLLBACK commands, if they use code that
	 * blindly Describes whatever it does.)  We can Describe parameters
	 * without doing anything dangerous, so we don't restrict that.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>IsAbortedTransactionBlockState</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator>
		<name><name>psrc</name><operator>-&gt;</operator><name>resultDesc</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_IN_FAILED_SQL_TRANSACTION</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"current transaction is aborted, "</literal>
						<literal type="string">"commands ignored until end of transaction block"</literal></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errdetail_abort</name><argument_list>()</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>whereToSendOutput</name> <operator>!=</operator> <name>DestRemote</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>					<comment type="block">/* can't actually do anything... */</comment>

	<comment type="block">/*
	 * First describe the parameters...
	 */</comment>
	<expr_stmt><expr><call><name>pq_beginmessage_reuse</name><argument_list>(<argument><expr><operator>&amp;</operator><name>row_description_buf</name></expr></argument>, <argument><expr><literal type="char">'t'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>	<comment type="block">/* parameter description
														 * message type */</comment>
	<expr_stmt><expr><call><name>pq_sendint16</name><argument_list>(<argument><expr><operator>&amp;</operator><name>row_description_buf</name></expr></argument>, <argument><expr><name><name>psrc</name><operator>-&gt;</operator><name>num_params</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>psrc</name><operator>-&gt;</operator><name>num_params</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>ptype</name> <init>= <expr><name><name>psrc</name><operator>-&gt;</operator><name>param_types</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>pq_sendint32</name><argument_list>(<argument><expr><operator>&amp;</operator><name>row_description_buf</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name>ptype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>
	<expr_stmt><expr><call><name>pq_endmessage_reuse</name><argument_list>(<argument><expr><operator>&amp;</operator><name>row_description_buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Next send RowDescription or NoData to describe the result...
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>psrc</name><operator>-&gt;</operator><name>resultDesc</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>tlist</name></decl>;</decl_stmt>

		<comment type="block">/* Get the plan's primary targetlist */</comment>
		<expr_stmt><expr><name>tlist</name> <operator>=</operator> <call><name>CachedPlanGetTargetList</name><argument_list>(<argument><expr><name>psrc</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>SendRowDescriptionMessage</name><argument_list>(<argument><expr><operator>&amp;</operator><name>row_description_buf</name></expr></argument>,
								  <argument><expr><name><name>psrc</name><operator>-&gt;</operator><name>resultDesc</name></name></expr></argument>,
								  <argument><expr><name>tlist</name></expr></argument>,
								  <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>pq_putemptymessage</name><argument_list>(<argument><expr><literal type="char">'n'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>	<comment type="block">/* NoData */</comment>

</block_content>}</block></function>

<comment type="block">/*
 * exec_describe_portal_message
 *
 * Process a "Describe" message for a portal
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>exec_describe_portal_message</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>portal_name</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Portal</name></type>		<name>portal</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Start up a transaction command. (Note that this will normally change
	 * current memory context.) Nothing happens if we are already in one.
	 */</comment>
	<expr_stmt><expr><call><name>start_xact_command</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Switch back to message context */</comment>
	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>MessageContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>portal</name> <operator>=</operator> <call><name>GetPortalByName</name><argument_list>(<argument><expr><name>portal_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>PortalIsValid</name><argument_list>(<argument><expr><name>portal</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_CURSOR</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"portal \"%s\" does not exist"</literal></expr></argument>, <argument><expr><name>portal_name</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * If we are in aborted transaction state, we can't run
	 * SendRowDescriptionMessage(), because that needs catalog accesses.
	 * Hence, refuse to Describe portals that return data.  (We shouldn't just
	 * refuse all Describes, since that might break the ability of some
	 * clients to issue COMMIT or ROLLBACK commands, if they use code that
	 * blindly Describes whatever it does.)
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>IsAbortedTransactionBlockState</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator>
		<name><name>portal</name><operator>-&gt;</operator><name>tupDesc</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_IN_FAILED_SQL_TRANSACTION</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"current transaction is aborted, "</literal>
						<literal type="string">"commands ignored until end of transaction block"</literal></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errdetail_abort</name><argument_list>()</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>whereToSendOutput</name> <operator>!=</operator> <name>DestRemote</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>					<comment type="block">/* can't actually do anything... */</comment>

	<if_stmt><if>if <condition>(<expr><name><name>portal</name><operator>-&gt;</operator><name>tupDesc</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>SendRowDescriptionMessage</name><argument_list>(<argument><expr><operator>&amp;</operator><name>row_description_buf</name></expr></argument>,
								  <argument><expr><name><name>portal</name><operator>-&gt;</operator><name>tupDesc</name></name></expr></argument>,
								  <argument><expr><call><name>FetchPortalTargetList</name><argument_list>(<argument><expr><name>portal</name></expr></argument>)</argument_list></call></expr></argument>,
								  <argument><expr><name><name>portal</name><operator>-&gt;</operator><name>formats</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>pq_putemptymessage</name><argument_list>(<argument><expr><literal type="char">'n'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>	<comment type="block">/* NoData */</comment>
</block_content>}</block></function>


<comment type="block">/*
 * Convenience routines for starting/committing a single command.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>start_xact_command</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>xact_started</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>StartTransactionCommand</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>xact_started</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>polar_in_replica_mode</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>polar_xact_split_refresh_xact_state</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Start statement timeout if necessary.  Note that this'll intentionally
	 * not reset the clock on an already started timeout, to avoid the timing
	 * overhead when start_xact_command() is invoked repeatedly, without an
	 * interceding finish_xact_command() (e.g. parse/bind/execute).  If that's
	 * not desired, the timeout has to be disabled explicitly.
	 */</comment>
	<expr_stmt><expr><call><name>enable_statement_timeout</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>finish_xact_command</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* cancel active statement timeout after each command */</comment>
	<expr_stmt><expr><call><name>disable_statement_timeout</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>xact_started</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>CommitTransactionCommand</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>MEMORY_CONTEXT_CHECKING</name></cpp:ifdef>
		<comment type="block">/* Check all memory contexts that weren't freed during commit */</comment>
		<comment type="block">/* (those that were, were checked before being deleted) */</comment>
		<expr_stmt><expr><call><name>MemoryContextCheck</name><argument_list>(<argument><expr><name>TopMemoryContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SHOW_MEMORY_STATS</name></cpp:ifdef>
		<comment type="block">/* Print mem stats after each commit for leak tracking */</comment>
		<expr_stmt><expr><call><name>MemoryContextStats</name><argument_list>(<argument><expr><name>TopMemoryContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

		<expr_stmt><expr><name>xact_started</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * Convenience routines for checking whether a statement is one of the
 * ones that we allow in transaction-aborted state.
 */</comment>

<comment type="block">/* Test a bare parsetree */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>IsTransactionExitStmt</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>parsetree</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>parsetree</name> <operator>&amp;&amp;</operator> <call><name>IsA</name><argument_list>(<argument><expr><name>parsetree</name></expr></argument>, <argument><expr><name>TransactionStmt</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>TransactionStmt</name> <modifier>*</modifier></type><name>stmt</name> <init>= <expr><operator>(</operator><name>TransactionStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>kind</name></name> <operator>==</operator> <name>TRANS_STMT_COMMIT</name> <operator>||</operator>
			<name><name>stmt</name><operator>-&gt;</operator><name>kind</name></name> <operator>==</operator> <name>TRANS_STMT_PREPARE</name> <operator>||</operator>
			<name><name>stmt</name><operator>-&gt;</operator><name>kind</name></name> <operator>==</operator> <name>TRANS_STMT_ROLLBACK</name> <operator>||</operator>
			<name><name>stmt</name><operator>-&gt;</operator><name>kind</name></name> <operator>==</operator> <name>TRANS_STMT_ROLLBACK_TO</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Test a list that contains PlannedStmt nodes */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>IsTransactionExitStmtList</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>pstmts</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name>pstmts</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>PlannedStmt</name> <modifier>*</modifier></type><name>pstmt</name> <init>= <expr><call><name>linitial_node</name><argument_list>(<argument><expr><name>PlannedStmt</name></expr></argument>, <argument><expr><name>pstmts</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>pstmt</name><operator>-&gt;</operator><name>commandType</name></name> <operator>==</operator> <name>CMD_UTILITY</name> <operator>&amp;&amp;</operator>
			<call><name>IsTransactionExitStmt</name><argument_list>(<argument><expr><name><name>pstmt</name><operator>-&gt;</operator><name>utilityStmt</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Test a list that contains PlannedStmt nodes */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>IsTransactionStmtList</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>pstmts</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name>pstmts</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>PlannedStmt</name> <modifier>*</modifier></type><name>pstmt</name> <init>= <expr><call><name>linitial_node</name><argument_list>(<argument><expr><name>PlannedStmt</name></expr></argument>, <argument><expr><name>pstmts</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>pstmt</name><operator>-&gt;</operator><name>commandType</name></name> <operator>==</operator> <name>CMD_UTILITY</name> <operator>&amp;&amp;</operator>
			<call><name>IsA</name><argument_list>(<argument><expr><name><name>pstmt</name><operator>-&gt;</operator><name>utilityStmt</name></name></expr></argument>, <argument><expr><name>TransactionStmt</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Release any existing unnamed prepared statement */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>drop_unnamed_stmt</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* paranoia to avoid a dangling pointer in case of error */</comment>
	<if_stmt><if>if <condition>(<expr><name>unnamed_stmt_psrc</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>CachedPlanSource</name> <modifier>*</modifier></type><name>psrc</name> <init>= <expr><name>unnamed_stmt_psrc</name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>unnamed_stmt_psrc</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>DropCachedPlan</name><argument_list>(<argument><expr><name>psrc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>


<comment type="block">/* --------------------------------
 *		signal handler routines used in PostgresMain()
 * --------------------------------
 */</comment>

<comment type="block">/*
 * quickdie() occurs when signalled SIGQUIT by the postmaster.
 *
 * Some backend has bought the farm,
 * so we need to stop what we're doing and exit.
 */</comment>
<function><type><name>void</name></type>
<name>quickdie</name><parameter_list>(<parameter><decl><type><name>SIGNAL_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>sigaddset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>BlockSig</name></expr></argument>, <argument><expr><name>SIGQUIT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>	<comment type="block">/* prevent nested calls */</comment>
	<expr_stmt><expr><call><name>PG_SETMASK</name><argument_list>(<argument><expr><operator>&amp;</operator><name>BlockSig</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Prevent interrupts while exiting; though we just blocked signals that
	 * would queue new interrupts, one may have been pending.  We don't want a
	 * quickdie() downgraded to a mere query cancel.
	 */</comment>
	<expr_stmt><expr><call><name>HOLD_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If we're aborting out of client auth, don't risk trying to send
	 * anything to the client; we will likely violate the protocol, not to
	 * mention that we may have interrupted the guts of OpenSSL or some
	 * authentication library.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>ClientAuthInProgress</name> <operator>&amp;&amp;</operator> <name>whereToSendOutput</name> <operator>==</operator> <name>DestRemote</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>whereToSendOutput</name> <operator>=</operator> <name>DestNone</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Notify the client before exiting, to give a clue on what happened.
	 *
	 * It's dubious to call ereport() from a signal handler.  It is certainly
	 * not async-signal safe.  But it seems better to try, than to disconnect
	 * abruptly and leave the client wondering what happened.  It's remotely
	 * possible that we crash or hang while trying to send the message, but
	 * receiving a SIGQUIT is a sign that something has already gone badly
	 * wrong, so there's not much to lose.  Assuming the postmaster is still
	 * running, it will SIGKILL us soon if we get stuck for some reason.
	 *
	 * Ideally this should be ereport(FATAL), but then we'd not get control
	 * back...
	 */</comment>
	<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>,
			<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_CRASH_SHUTDOWN</name></expr></argument>)</argument_list></call><operator>,</operator>
			 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"terminating connection because of crash of another server process"</literal></expr></argument>)</argument_list></call><operator>,</operator>
			 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"The postmaster has commanded this server process to roll back"</literal>
					   <literal type="string">" the current transaction and exit, because another"</literal>
					   <literal type="string">" server process exited abnormally and possibly corrupted"</literal>
					   <literal type="string">" shared memory."</literal></expr></argument>)</argument_list></call><operator>,</operator>
			 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"In a moment you should be able to reconnect to the"</literal>
					 <literal type="string">" database and repeat your command."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * We DO NOT want to run proc_exit() or atexit() callbacks -- we're here
	 * because shared memory may be corrupted, so we don't want to try to
	 * clean up our transaction.  Just nail the windows shut and get out of
	 * town.  The callbacks wouldn't be safe to run from a signal handler,
	 * anyway.
	 *
	 * Note we do _exit(2) not _exit(0).  This is to force the postmaster into
	 * a system reset cycle if someone sends a manual SIGQUIT to a random
	 * backend.  This is necessary precisely because we don't clean up our
	 * shared memory state.  (The "dead man switch" mechanism in pmsignal.c
	 * should ensure the postmaster sees this as a crash, too, but no harm in
	 * being doubly sure.)
	 */</comment>
	<expr_stmt><expr><call><name>_exit</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Shutdown signal from postmaster: abort transaction and exit
 * at soonest convenient time
 */</comment>
<function><type><name>void</name></type>
<name>die</name><parameter_list>(<parameter><decl><type><name>SIGNAL_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>save_errno</name> <init>= <expr><name>errno</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* Don't joggle the elbow of proc_exit */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>proc_exit_inprogress</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>InterruptPending</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>ProcDiePending</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* If we're still here, waken anything waiting on the process latch */</comment>
	<expr_stmt><expr><call><name>SetLatch</name><argument_list>(<argument><expr><name>MyLatch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If we're in single user mode, we want to quit immediately - we can't
	 * rely on latches as they wouldn't work when stdin/stdout is a file.
	 * Rather ugly, but it's unlikely to be worthwhile to invest much more
	 * effort just for the benefit of single user mode.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>DoingCommandRead</name> <operator>&amp;&amp;</operator> <name>whereToSendOutput</name> <operator>!=</operator> <name>DestRemote</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ProcessInterrupts</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<comment type="block">/* POLAR: check interrupt for px initialize state */</comment>
	<if type="elseif">else if <condition>(<expr><name>px_check_interrupt</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ProcessInterrupts</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>errno</name> <operator>=</operator> <name>save_errno</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Query-cancel signal from postmaster: abort current transaction
 * at soonest convenient time
 * POLAR: Because polar_procsignal_sigusr2_handler and StatementCancelHandler
 * have many same codes, so we merge them to CancelQueryHandler
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>SigCancelQueryHandler</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>save_errno</name> <init>= <expr><name>errno</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * Don't joggle the elbow of proc_exit
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>proc_exit_inprogress</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>InterruptPending</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>QueryCancelPending</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* If we're still here, waken anything waiting on the process latch */</comment>
	<expr_stmt><expr><call><name>SetLatch</name><argument_list>(<argument><expr><name>MyLatch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>errno</name> <operator>=</operator> <name>save_errno</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * POLAR: Query-cancel signal from postmaster: abort current transaction
 * at soonest convenient time
 */</comment>
<function><type><name>void</name></type>
<name>StatementCancelHandler</name><parameter_list>(<parameter><decl><type><name>SIGNAL_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>SigCancelQueryHandler</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* signal handler for floating point exception */</comment>
<function><type><name>void</name></type>
<name>FloatExceptionHandler</name><parameter_list>(<parameter><decl><type><name>SIGNAL_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* We're not returning, so no need to save errno */</comment>
	<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
			<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FLOATING_POINT_EXCEPTION</name></expr></argument>)</argument_list></call><operator>,</operator>
			 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"floating-point exception"</literal></expr></argument>)</argument_list></call><operator>,</operator>
			 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"An invalid floating-point operation was signaled. "</literal>
					   <literal type="string">"This probably means an out-of-range result or an "</literal>
					   <literal type="string">"invalid operation, such as division by zero."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * SIGHUP: set flag to re-read config file at next convenient time.
 *
 * Sets the ConfigReloadPending flag, which should be checked at convenient
 * places inside main loops. (Better than doing the reading in the signal
 * handler, ey?)
 */</comment>
<function><type><name>void</name></type>
<name>PostgresSigHupHandler</name><parameter_list>(<parameter><decl><type><name>SIGNAL_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>save_errno</name> <init>= <expr><name>errno</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>ConfigReloadPending</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SetLatch</name><argument_list>(<argument><expr><name>MyLatch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>errno</name> <operator>=</operator> <name>save_errno</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * RecoveryConflictInterrupt: out-of-line portion of recovery conflict
 * handling following receipt of SIGUSR1. Designed to be similar to die()
 * and StatementCancelHandler(). Called only by a normal user backend
 * that begins a transaction during recovery.
 */</comment>
<function><type><name>void</name></type>
<name>RecoveryConflictInterrupt</name><parameter_list>(<parameter><decl><type><name>ProcSignalReason</name></type> <name>reason</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>save_errno</name> <init>= <expr><name>errno</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * Don't joggle the elbow of proc_exit
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>proc_exit_inprogress</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>RecoveryConflictReason</name> <operator>=</operator> <name>reason</name></expr>;</expr_stmt>
		<switch>switch <condition>(<expr><name>reason</name></expr>)</condition>
		<block>{<block_content>
			<case>case <expr><name>PROCSIG_RECOVERY_CONFLICT_STARTUP_DEADLOCK</name></expr>:</case>

				<comment type="block">/*
				 * If we aren't waiting for a lock we can never deadlock.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsWaitingForLock</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<return>return;</return></block_content></block></if></if_stmt>

				<comment type="block">/* Intentional fall through to check wait for pin */</comment>
				<comment type="block">/* FALLTHROUGH */</comment>

			<case>case <expr><name>PROCSIG_RECOVERY_CONFLICT_BUFFERPIN</name></expr>:</case>

				<comment type="block">/*
				 * If we aren't blocking the Startup process there is nothing
				 * more to do.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HoldingBufferPinThatDelaysRecovery</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<return>return;</return></block_content></block></if></if_stmt>

				<expr_stmt><expr><name><name>MyProc</name><operator>-&gt;</operator><name>recoveryConflictPending</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

				<comment type="block">/* Intentional fall through to error handling */</comment>
				<comment type="block">/* FALLTHROUGH */</comment>

			<case>case <expr><name>PROCSIG_RECOVERY_CONFLICT_LOCK</name></expr>:</case>
			<case>case <expr><name>PROCSIG_RECOVERY_CONFLICT_TABLESPACE</name></expr>:</case>
			<case>case <expr><name>PROCSIG_RECOVERY_CONFLICT_SNAPSHOT</name></expr>:</case>

				<comment type="block">/*
				 * If we aren't in a transaction any longer then ignore.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsTransactionOrTransactionBlock</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<return>return;</return></block_content></block></if></if_stmt>

				<comment type="block">/*
				 * If we can abort just the current subtransaction then we are
				 * OK to throw an ERROR to resolve the conflict. Otherwise
				 * drop through to the FATAL case.
				 *
				 * XXX other times that we can throw just an ERROR *may* be
				 * PROCSIG_RECOVERY_CONFLICT_LOCK if no locks are held in
				 * parent transactions
				 *
				 * PROCSIG_RECOVERY_CONFLICT_SNAPSHOT if no snapshots are held
				 * by parent transactions and the transaction is not
				 * transaction-snapshot mode
				 *
				 * PROCSIG_RECOVERY_CONFLICT_TABLESPACE if no temp files or
				 * cursors open in parent transactions
				 */</comment>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsSubTransaction</name><argument_list>()</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/*
					 * If we already aborted then we no longer need to cancel.
					 * We do this here since we do not wish to ignore aborted
					 * subtransactions, which must cause FATAL, currently.
					 */</comment>
					<if_stmt><if>if <condition>(<expr><call><name>IsAbortedTransactionBlockState</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
						<return>return;</return></block_content></block></if></if_stmt>

					<expr_stmt><expr><name>RecoveryConflictPending</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
					<expr_stmt><expr><name>QueryCancelPending</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
					<expr_stmt><expr><name>InterruptPending</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
					<break>break;</break>
				</block_content>}</block></if></if_stmt>

				<comment type="block">/* Intentional fall through to session cancel */</comment>
				<comment type="block">/* FALLTHROUGH */</comment>

			<case>case <expr><name>PROCSIG_RECOVERY_CONFLICT_DATABASE</name></expr>:</case>
				<expr_stmt><expr><name>RecoveryConflictPending</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>ProcDiePending</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>InterruptPending</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<break>break;</break>

			<default>default:</default>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>, <argument><expr><literal type="string">"unrecognized conflict mode: %d"</literal></expr></argument>,
					 <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name>reason</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></switch>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>RecoveryConflictPending</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>QueryCancelPending</name> <operator>||</operator> <name>ProcDiePending</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * All conflicts apart from database cause dynamic errors where the
		 * command or transaction can be retried at a later point with some
		 * potential for success. No need to reset this, since non-retryable
		 * conflict errors are currently FATAL.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>reason</name> <operator>==</operator> <name>PROCSIG_RECOVERY_CONFLICT_DATABASE</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>RecoveryConflictRetryable</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Set the process latch. This function essentially emulates signal
	 * handlers like die() and StatementCancelHandler() and it seems prudent
	 * to behave similarly as they do.
	 */</comment>
	<expr_stmt><expr><call><name>SetLatch</name><argument_list>(<argument><expr><name>MyLatch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>errno</name> <operator>=</operator> <name>save_errno</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * ProcessInterrupts: out-of-line portion of CHECK_FOR_INTERRUPTS() macro
 *
 * If an interrupt condition is pending, and it's safe to service it,
 * then clear the flag and accept the interrupt.  Called only when
 * InterruptPending is true.
 */</comment>
<function><type><name>void</name></type>
<name>ProcessInterrupts</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * POLAR: we use tmp variable to replace got_oom_cancel_signal, we can reset
	 * got_oom_cancel_signal to false, if not, we have reset it before
	 * every ERROR log level
	 */</comment>
	<decl_stmt><decl><type><name>bool</name></type> <name>tmp_got_oom_cancel_signal</name> <init>= <expr><name>got_oom_cancel_signal</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* OK to accept any interrupts now? */</comment>
	<if_stmt><if>if <condition>(<expr><name>InterruptHoldoffCount</name> <operator>!=</operator> <literal type="number">0</literal> <operator>||</operator> <name>CritSectionCount</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>InterruptPending</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>ProcDiePending</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>ProcDiePending</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>QueryCancelPending</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt> <comment type="block">/* ProcDie trumps QueryCancel */</comment>
		<expr_stmt><expr><call><name>LockErrorCleanup</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* As in quickdie, don't risk sending to client during auth */</comment>
		<if_stmt><if>if <condition>(<expr><name>ClientAuthInProgress</name> <operator>&amp;&amp;</operator> <name>whereToSendOutput</name> <operator>==</operator> <name>DestRemote</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>whereToSendOutput</name> <operator>=</operator> <name>DestNone</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name>ClientAuthInProgress</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_QUERY_CANCELED</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"canceling authentication due to timeout"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><call><name>IsAutoVacuumWorkerProcess</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_ADMIN_SHUTDOWN</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"terminating autovacuum process due to administrator command"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><call><name>IsLogicalWorker</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_ADMIN_SHUTDOWN</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"terminating logical replication worker due to administrator command"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><call><name>IsLogicalLauncher</name><argument_list>()</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"logical replication launcher shutting down"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * The logical replication launcher can be stopped at any time.
			 * Use exit status 1 so the background worker is restarted.
			 */</comment>
			<expr_stmt><expr><call><name>proc_exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name>RecoveryConflictPending</name> <operator>&amp;&amp;</operator> <name>RecoveryConflictRetryable</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>pgstat_report_recovery_conflict</name><argument_list>(<argument><expr><name>RecoveryConflictReason</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_T_R_SERIALIZATION_FAILURE</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"terminating connection due to conflict with recovery"</literal></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errdetail_recovery_conflict</name><argument_list>()</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name>RecoveryConflictPending</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Currently there is only one non-retryable recovery conflict */</comment>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>RecoveryConflictReason</name> <operator>==</operator> <name>PROCSIG_RECOVERY_CONFLICT_DATABASE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>pgstat_report_recovery_conflict</name><argument_list>(<argument><expr><name>RecoveryConflictReason</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATABASE_DROPPED</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"terminating connection due to conflict with recovery"</literal></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errdetail_recovery_conflict</name><argument_list>()</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_ADMIN_SHUTDOWN</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"terminating connection due to administrator command"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>ClientConnectionLost</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>QueryCancelPending</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt> <comment type="block">/* lost connection trumps QueryCancel */</comment>
		<expr_stmt><expr><call><name>LockErrorCleanup</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* don't send to client, we already know the connection to be dead. */</comment>
		<expr_stmt><expr><name>whereToSendOutput</name> <operator>=</operator> <name>DestNone</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_CONNECTION_FAILURE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"connection to client lost"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * If a recovery conflict happens while we are waiting for input from the
	 * client, the client is presumably just sitting idle in a transaction,
	 * preventing recovery from making progress.  Terminate the connection to
	 * dislodge it.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>RecoveryConflictPending</name> <operator>&amp;&amp;</operator> <name>DoingCommandRead</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>QueryCancelPending</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt> <comment type="block">/* this trumps QueryCancel */</comment>
		<expr_stmt><expr><name>RecoveryConflictPending</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>LockErrorCleanup</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pgstat_report_recovery_conflict</name><argument_list>(<argument><expr><name>RecoveryConflictReason</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_T_R_SERIALIZATION_FAILURE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"terminating connection due to conflict with recovery"</literal></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errdetail_recovery_conflict</name><argument_list>()</argument_list></call><operator>,</operator>
				 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"In a moment you should be able to reconnect to the"</literal>
						 <literal type="string">" database and repeat your command."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Don't allow query cancel interrupts while reading input from the
	 * client, because we might lose sync in the FE/BE protocol.  (Die
	 * interrupts are OK, because we won't read any further messages from the
	 * client in that case.)
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>QueryCancelPending</name> <operator>&amp;&amp;</operator> <name>QueryCancelHoldoffCount</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Re-arm InterruptPending so that we process the cancel request as
		 * soon as we're done reading the message.
		 */</comment>
		<expr_stmt><expr><name>InterruptPending</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>QueryCancelPending</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>bool</name></type>		<name>lock_timeout_occurred</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>stmt_timeout_occurred</name></decl>;</decl_stmt>

		<comment type="block">/* POLAR: we place it here, now we will deal signal */</comment>
		<expr_stmt><expr><name>got_oom_cancel_signal</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>QueryCancelPending</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

		<comment type="block">/*
		 * If LOCK_TIMEOUT and STATEMENT_TIMEOUT indicators are both set, we
		 * need to clear both, so always fetch both.
		 */</comment>
		<expr_stmt><expr><name>lock_timeout_occurred</name> <operator>=</operator> <call><name>get_timeout_indicator</name><argument_list>(<argument><expr><name>LOCK_TIMEOUT</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>stmt_timeout_occurred</name> <operator>=</operator> <call><name>get_timeout_indicator</name><argument_list>(<argument><expr><name>STATEMENT_TIMEOUT</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * If both were set, we want to report whichever timeout completed
		 * earlier; this ensures consistent behavior if the machine is slow
		 * enough that the second timeout triggers before we get here.  A tie
		 * is arbitrarily broken in favor of reporting a lock timeout.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>lock_timeout_occurred</name> <operator>&amp;&amp;</operator> <name>stmt_timeout_occurred</name> <operator>&amp;&amp;</operator>
			<call><name>get_timeout_finish_time</name><argument_list>(<argument><expr><name>STATEMENT_TIMEOUT</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <call><name>get_timeout_finish_time</name><argument_list>(<argument><expr><name>LOCK_TIMEOUT</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>lock_timeout_occurred</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></if></if_stmt>	<comment type="block">/* report stmt timeout */</comment>

		<if_stmt><if>if <condition>(<expr><name>lock_timeout_occurred</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>LockErrorCleanup</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_LOCK_NOT_AVAILABLE</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"canceling statement due to lock timeout"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name>stmt_timeout_occurred</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>LockErrorCleanup</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_QUERY_CANCELED</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"canceling statement due to statement timeout"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>IsAutoVacuumWorkerProcess</name><argument_list>()</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>LockErrorCleanup</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_QUERY_CANCELED</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"canceling autovacuum task"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name>RecoveryConflictPending</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>RecoveryConflictPending</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>LockErrorCleanup</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>pgstat_report_recovery_conflict</name><argument_list>(<argument><expr><name>RecoveryConflictReason</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_T_R_SERIALIZATION_FAILURE</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"canceling statement due to conflict with recovery"</literal></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errdetail_recovery_conflict</name><argument_list>()</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* POLAR: for oom signal error message */</comment>
		<if_stmt><if>if <condition>(<expr><name>tmp_got_oom_cancel_signal</name> <operator>==</operator> <name>true</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>LockErrorCleanup</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_OUT_OF_MEMORY</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"out of memory, statement may not be run successfully"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<comment type="block">/* POLAR end */</comment>

		<comment type="block">/*
		 * If we are reading a command from the client, just ignore the cancel
		 * request --- sending an extra error message won't accomplish
		 * anything.  Otherwise, go ahead and throw the error.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>DoingCommandRead</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>LockErrorCleanup</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_QUERY_CANCELED</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"canceling statement due to user request"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>IdleInTransactionSessionTimeoutPending</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Has the timeout setting changed since last we looked? */</comment>
		<if_stmt><if>if <condition>(<expr><name>IdleInTransactionSessionTimeout</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_IDLE_IN_TRANSACTION_SESSION_TIMEOUT</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"terminating connection due to idle-in-transaction timeout"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>IdleInTransactionSessionTimeoutPending</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>ParallelMessagePending</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>HandleParallelMessages</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* POLAR: check for ready to get memory context view */</comment>
	<if_stmt><if>if <condition>(<expr><name>MemoryContextDumpPending</name> <operator>&amp;&amp;</operator> <name>polar_monitor_hook</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>MemoryContextDumpPending</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>polar_monitor_hook</name><argument_list>(<argument><expr><name>POLAR_CHECK_SIGNAL_MCTX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
 
 	<if_stmt><if>if <condition>(<expr><name>polar_enable_track_network_stat</name></expr>)</condition><block type="pseudo"><block_content>
 		<expr_stmt><expr><call><name>polar_local_network_stat</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		
	<if_stmt><if>if <condition>(<expr><name>LogCurrentPlanPending</name> <operator>&amp;&amp;</operator> <name>polar_monitor_hook</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>polar_monitor_hook</name><argument_list>(<argument><expr><name>POLAR_CHECK_LOGGING_PLAN_OF_RUNNING_QUERY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * IA64-specific code to fetch the AR.BSP register for stack depth checks.
 *
 * We currently support gcc, icc, and HP-UX's native compiler here.
 *
 * Note: while icc accepts gcc asm blocks on x86[_64], this is not true on
 * ia64 (at least not in icc versions before 12.x).  So we have to carry a
 * separate implementation for it.
 */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__ia64__</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>__ia64</name></expr></argument>)</argument_list></call></expr></cpp:if>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__hpux</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>__GNUC__</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>__INTEL_COMPILER</name></expr></argument>)</argument_list></call></expr></cpp:if>
<comment type="block">/* Assume it's HP-UX native compiler */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;ia64/sys/inline.h&gt;</cpp:file></cpp:include>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ia64_get_bsp</name><parameter_list>()</parameter_list></cpp:macro> <cpp:value>((char *) (_Asm_mov_from_ar(_AREG_BSP, _NO_FENCE)))</cpp:value></cpp:define>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__INTEL_COMPILER</name></expr></argument>)</argument_list></call></expr></cpp:elif>
<comment type="block">/* icc */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;asm/ia64regs.h&gt;</cpp:file></cpp:include>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ia64_get_bsp</name><parameter_list>()</parameter_list></cpp:macro> <cpp:value>((char *) __getReg(_IA64_REG_AR_BSP))</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<comment type="block">/* gcc */</comment>
<function><type><specifier>static</specifier> <name>__inline__</name> <name>char</name> <modifier>*</modifier></type>
<name>ia64_get_bsp</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>ret</name></decl>;</decl_stmt>

	<comment type="block">/* the ;; is a "stop", seems to be required before fetching BSP */</comment>
	<asm>__asm__ <specifier>__volatile__</specifier>(
						 ";;\n"
						 "	mov	%0=ar.bsp	\n"
:						 "=r"(ret));</asm>

	<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>							<comment type="block">/* IA64 */</comment>


<comment type="block">/*
 * set_stack_base: set up reference point for stack depth checking
 *
 * Returns the old reference point, if any.
 */</comment>
<function><type><name>pg_stack_base_t</name></type>
<name>set_stack_base</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name></type>		<name>stack_base</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>pg_stack_base_t</name></type> <name>old</name></decl>;</decl_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__ia64__</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>__ia64</name></expr></argument>)</argument_list></call></expr></cpp:if>
	<expr_stmt><expr><name><name>old</name><operator>.</operator><name>stack_base_ptr</name></name> <operator>=</operator> <name>stack_base_ptr</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>old</name><operator>.</operator><name>register_stack_base_ptr</name></name> <operator>=</operator> <name>register_stack_base_ptr</name></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	<expr_stmt><expr><name>old</name> <operator>=</operator> <name>stack_base_ptr</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<comment type="block">/* Set up reference point for stack depth checking */</comment>
	<expr_stmt><expr><name>stack_base_ptr</name> <operator>=</operator> <operator>&amp;</operator><name>stack_base</name></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__ia64__</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>__ia64</name></expr></argument>)</argument_list></call></expr></cpp:if>
	<expr_stmt><expr><name>register_stack_base_ptr</name> <operator>=</operator> <call><name>ia64_get_bsp</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<return>return <expr><name>old</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * restore_stack_base: restore reference point for stack depth checking
 *
 * This can be used after set_stack_base() to restore the old value. This
 * is currently only used in PL/Java. When PL/Java calls a backend function
 * from different thread, the thread's stack is at a different location than
 * the main thread's stack, so it sets the base pointer before the call, and
 * restores it afterwards.
 */</comment>
<function><type><name>void</name></type>
<name>restore_stack_base</name><parameter_list>(<parameter><decl><type><name>pg_stack_base_t</name></type> <name>base</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__ia64__</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>__ia64</name></expr></argument>)</argument_list></call></expr></cpp:if>
	<expr_stmt><expr><name>stack_base_ptr</name> <operator>=</operator> <name><name>base</name><operator>.</operator><name>stack_base_ptr</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>register_stack_base_ptr</name> <operator>=</operator> <name><name>base</name><operator>.</operator><name>register_stack_base_ptr</name></name></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	<expr_stmt><expr><name>stack_base_ptr</name> <operator>=</operator> <name>base</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>

<comment type="block">/*
 * check_stack_depth/stack_is_too_deep: check for excessively deep recursion
 *
 * This should be called someplace in any recursive routine that might possibly
 * recurse deep enough to overflow the stack.  Most Unixen treat stack
 * overflow as an unrecoverable SIGSEGV, so we want to error out ourselves
 * before hitting the hardware limit.
 *
 * check_stack_depth() just throws an error summarily.  stack_is_too_deep()
 * can be used by code that wants to handle the error condition itself.
 */</comment>
<function><type><name>void</name></type>
<name>check_stack_depth</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><call><name>stack_is_too_deep</name><argument_list>()</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_STATEMENT_TOO_COMPLEX</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"stack depth limit exceeded"</literal></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Increase the configuration parameter \"max_stack_depth\" (currently %dkB), "</literal>
						 <literal type="string">"after ensuring the platform's stack depth limit is adequate."</literal></expr></argument>,
						 <argument><expr><name>max_stack_depth</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><name>bool</name></type>
<name>stack_is_too_deep</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name></type>		<name>stack_top_loc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>long</name></type>		<name>stack_depth</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Compute distance from reference point to my local variables
	 */</comment>
	<expr_stmt><expr><name>stack_depth</name> <operator>=</operator> <operator>(</operator><name>long</name><operator>)</operator> <operator>(</operator><name>stack_base_ptr</name> <operator>-</operator> <operator>&amp;</operator><name>stack_top_loc</name><operator>)</operator></expr>;</expr_stmt>

	<comment type="block">/*
	 * Take abs value, since stacks grow up on some machines, down on others
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>stack_depth</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>stack_depth</name> <operator>=</operator> <operator>-</operator><name>stack_depth</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Trouble?
	 *
	 * The test on stack_base_ptr prevents us from erroring out if called
	 * during process setup or in a non-backend process.  Logically it should
	 * be done first, but putting it here avoids wasting cycles during normal
	 * cases.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>stack_depth</name> <operator>&gt;</operator> <name>max_stack_depth_bytes</name> <operator>&amp;&amp;</operator>
		<name>stack_base_ptr</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * On IA64 there is a separate "register" stack that requires its own
	 * independent check.  For this, we have to measure the change in the
	 * "BSP" pointer from PostgresMain to here.  Logic is just as above,
	 * except that we know IA64's register stack grows up.
	 *
	 * Note we assume that the same max_stack_depth applies to both stacks.
	 */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__ia64__</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>__ia64</name></expr></argument>)</argument_list></call></expr></cpp:if>
	<expr_stmt><expr><name>stack_depth</name> <operator>=</operator> <operator>(</operator><name>long</name><operator>)</operator> <operator>(</operator><call><name>ia64_get_bsp</name><argument_list>()</argument_list></call> <operator>-</operator> <name>register_stack_base_ptr</name><operator>)</operator></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>stack_depth</name> <operator>&gt;</operator> <name>max_stack_depth_bytes</name> <operator>&amp;&amp;</operator>
		<name>register_stack_base_ptr</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>							<comment type="block">/* IA64 */</comment>

	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* GUC check hook for max_stack_depth */</comment>
<function><type><name>bool</name></type>
<name>check_max_stack_depth</name><parameter_list>(<parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>newval</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier><modifier>*</modifier></type><name>extra</name></decl></parameter>, <parameter><decl><type><name>GucSource</name></type> <name>source</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>long</name></type>		<name>newval_bytes</name> <init>= <expr><operator>*</operator><name>newval</name> <operator>*</operator> <literal type="number">1024L</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>long</name></type>		<name>stack_rlimit</name> <init>= <expr><call><name>get_stack_depth_rlimit</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>stack_rlimit</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>newval_bytes</name> <operator>&gt;</operator> <name>stack_rlimit</name> <operator>-</operator> <name>STACK_DEPTH_SLOP</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>GUC_check_errdetail</name><argument_list>(<argument><expr><literal type="string">"\"max_stack_depth\" must not exceed %ldkB."</literal></expr></argument>,
							<argument><expr><operator>(</operator><name>stack_rlimit</name> <operator>-</operator> <name>STACK_DEPTH_SLOP</name><operator>)</operator> <operator>/</operator> <literal type="number">1024L</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>GUC_check_errhint</name><argument_list>(<argument><expr><literal type="string">"Increase the platform's stack depth limit via \"ulimit -s\" or local equivalent."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* GUC assign hook for max_stack_depth */</comment>
<function><type><name>void</name></type>
<name>assign_max_stack_depth</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>newval</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>extra</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>long</name></type>		<name>newval_bytes</name> <init>= <expr><name>newval</name> <operator>*</operator> <literal type="number">1024L</literal></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>max_stack_depth_bytes</name> <operator>=</operator> <name>newval_bytes</name></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * set_debug_options --- apply "-d N" command line option
 *
 * -d is not quite the same as setting log_min_messages because it enables
 * other output options.
 */</comment>
<function><type><name>void</name></type>
<name>set_debug_options</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>debug_flag</name></decl></parameter>, <parameter><decl><type><name>GucContext</name></type> <name>context</name></decl></parameter>, <parameter><decl><type><name>GucSource</name></type> <name>source</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>debug_flag</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name></type>		<name><name>debugstr</name><index>[<expr><literal type="number">64</literal></expr>]</index></name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>debugstr</name></expr></argument>, <argument><expr><literal type="string">"debug%d"</literal></expr></argument>, <argument><expr><name>debug_flag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>SetConfigOption</name><argument_list>(<argument><expr><literal type="string">"log_min_messages"</literal></expr></argument>, <argument><expr><name>debugstr</name></expr></argument>, <argument><expr><name>context</name></expr></argument>, <argument><expr><name>source</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>SetConfigOption</name><argument_list>(<argument><expr><literal type="string">"log_min_messages"</literal></expr></argument>, <argument><expr><literal type="string">"notice"</literal></expr></argument>, <argument><expr><name>context</name></expr></argument>, <argument><expr><name>source</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>debug_flag</name> <operator>&gt;=</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <name>context</name> <operator>==</operator> <name>PGC_POSTMASTER</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>SetConfigOption</name><argument_list>(<argument><expr><literal type="string">"log_connections"</literal></expr></argument>, <argument><expr><literal type="string">"true"</literal></expr></argument>, <argument><expr><name>context</name></expr></argument>, <argument><expr><name>source</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>SetConfigOption</name><argument_list>(<argument><expr><literal type="string">"log_disconnections"</literal></expr></argument>, <argument><expr><literal type="string">"true"</literal></expr></argument>, <argument><expr><name>context</name></expr></argument>, <argument><expr><name>source</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>debug_flag</name> <operator>&gt;=</operator> <literal type="number">2</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>SetConfigOption</name><argument_list>(<argument><expr><literal type="string">"log_statement"</literal></expr></argument>, <argument><expr><literal type="string">"all"</literal></expr></argument>, <argument><expr><name>context</name></expr></argument>, <argument><expr><name>source</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>debug_flag</name> <operator>&gt;=</operator> <literal type="number">3</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>SetConfigOption</name><argument_list>(<argument><expr><literal type="string">"debug_print_parse"</literal></expr></argument>, <argument><expr><literal type="string">"true"</literal></expr></argument>, <argument><expr><name>context</name></expr></argument>, <argument><expr><name>source</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>debug_flag</name> <operator>&gt;=</operator> <literal type="number">4</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>SetConfigOption</name><argument_list>(<argument><expr><literal type="string">"debug_print_plan"</literal></expr></argument>, <argument><expr><literal type="string">"true"</literal></expr></argument>, <argument><expr><name>context</name></expr></argument>, <argument><expr><name>source</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>debug_flag</name> <operator>&gt;=</operator> <literal type="number">5</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>SetConfigOption</name><argument_list>(<argument><expr><literal type="string">"debug_print_rewritten"</literal></expr></argument>, <argument><expr><literal type="string">"true"</literal></expr></argument>, <argument><expr><name>context</name></expr></argument>, <argument><expr><name>source</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>


<function><type><name>bool</name></type>
<name>set_plan_disabling_options</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>, <parameter><decl><type><name>GucContext</name></type> <name>context</name></decl></parameter>, <parameter><decl><type><name>GucSource</name></type> <name>source</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>tmp</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<switch>switch <condition>(<expr><name><name>arg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><literal type="char">'s'</literal></expr>:</case>				<comment type="block">/* seqscan */</comment>
			<expr_stmt><expr><name>tmp</name> <operator>=</operator> <literal type="string">"enable_seqscan"</literal></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><literal type="char">'i'</literal></expr>:</case>				<comment type="block">/* indexscan */</comment>
			<expr_stmt><expr><name>tmp</name> <operator>=</operator> <literal type="string">"enable_indexscan"</literal></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><literal type="char">'o'</literal></expr>:</case>				<comment type="block">/* indexonlyscan */</comment>
			<expr_stmt><expr><name>tmp</name> <operator>=</operator> <literal type="string">"enable_indexonlyscan"</literal></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><literal type="char">'b'</literal></expr>:</case>				<comment type="block">/* bitmapscan */</comment>
			<expr_stmt><expr><name>tmp</name> <operator>=</operator> <literal type="string">"enable_bitmapscan"</literal></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><literal type="char">'t'</literal></expr>:</case>				<comment type="block">/* tidscan */</comment>
			<expr_stmt><expr><name>tmp</name> <operator>=</operator> <literal type="string">"enable_tidscan"</literal></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><literal type="char">'n'</literal></expr>:</case>				<comment type="block">/* nestloop */</comment>
			<expr_stmt><expr><name>tmp</name> <operator>=</operator> <literal type="string">"enable_nestloop"</literal></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><literal type="char">'m'</literal></expr>:</case>				<comment type="block">/* mergejoin */</comment>
			<expr_stmt><expr><name>tmp</name> <operator>=</operator> <literal type="string">"enable_mergejoin"</literal></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><literal type="char">'h'</literal></expr>:</case>				<comment type="block">/* hashjoin */</comment>
			<expr_stmt><expr><name>tmp</name> <operator>=</operator> <literal type="string">"enable_hashjoin"</literal></expr>;</expr_stmt>
			<break>break;</break>
	</block_content>}</block></switch>
	<if_stmt><if>if <condition>(<expr><name>tmp</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>SetConfigOption</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>, <argument><expr><literal type="string">"false"</literal></expr></argument>, <argument><expr><name>context</name></expr></argument>, <argument><expr><name>source</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>


<function><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>
<name>get_stats_option_name</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<switch>switch <condition>(<expr><name><name>arg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><literal type="char">'p'</literal></expr>:</case>
			<if_stmt><if>if <condition>(<expr><name><name>optarg</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'a'</literal></expr>)</condition><block type="pseudo"><block_content>	<comment type="block">/* "parser" */</comment>
				<return>return <expr><literal type="string">"log_parser_stats"</literal></expr>;</return></block_content></block></if>
			<if type="elseif">else if <condition>(<expr><name><name>optarg</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'l'</literal></expr>)</condition><block type="pseudo"><block_content>	<comment type="block">/* "planner" */</comment>
				<return>return <expr><literal type="string">"log_planner_stats"</literal></expr>;</return></block_content></block></if></if_stmt>
			<break>break;</break>

		<case>case <expr><literal type="char">'e'</literal></expr>:</case>				<comment type="block">/* "executor" */</comment>
			<return>return <expr><literal type="string">"log_executor_stats"</literal></expr>;</return>
			<break>break;</break>
	</block_content>}</block></switch>

	<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/* ----------------------------------------------------------------
 * process_postgres_switches
 *	   Parse command line arguments for PostgresMain
 *
 * This is called twice, once for the "secure" options coming from the
 * postmaster or command line, and once for the "insecure" options coming
 * from the client's startup packet.  The latter have the same syntax but
 * may be restricted in what they can do.
 *
 * argv[0] is ignored in either case (it's assumed to be the program name).
 *
 * ctx is PGC_POSTMASTER for secure options, PGC_BACKEND for insecure options
 * coming from the client, or PGC_SU_BACKEND for insecure options coming from
 * a superuser client.
 *
 * If a database name is present in the command line arguments, it's
 * returned into *dbname (this is allowed only if *dbname is initially NULL).
 * ----------------------------------------------------------------
 */</comment>
<function><type><name>void</name></type>
<name>process_postgres_switches</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name><name>argv</name><index>[]</index></name></decl></parameter>, <parameter><decl><type><name>GucContext</name></type> <name>ctx</name></decl></parameter>,
						  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>dbname</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type>		<name>secure</name> <init>= <expr><operator>(</operator><name>ctx</name> <operator>==</operator> <name>PGC_POSTMASTER</name><operator>)</operator></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>errs</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>GucSource</name></type>	<name>gucsource</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>flag</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>secure</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>gucsource</name> <operator>=</operator> <name>PGC_S_ARGV</name></expr>;</expr_stmt> <comment type="block">/* switches came from command line */</comment>

		<comment type="block">/* Ignore the initial --single argument, if present */</comment>
		<if_stmt><if>if <condition>(<expr><name>argc</name> <operator>&gt;</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <call><name>strcmp</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"--single"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>argv</name><operator>++</operator></expr>;</expr_stmt>
			<expr_stmt><expr><name>argc</name><operator>--</operator></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name>gucsource</name> <operator>=</operator> <name>PGC_S_CLIENT</name></expr>;</expr_stmt>	<comment type="block">/* switches came from client */</comment>
	</block_content>}</block></else></if_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_INT_OPTERR</name></cpp:ifdef>

	<comment type="block">/*
	 * Turn this off because it's either printed to stderr and not the log
	 * where we'd want it, or argv[0] is now "--single", which would make for
	 * a weird error message.  We print our own error message below.
	 */</comment>
	<expr_stmt><expr><name>opterr</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<comment type="block">/*
	 * Parse command-line options.  CAUTION: keep this in sync with
	 * postmaster/postmaster.c (the option sets should not conflict) and with
	 * the common help() function in main/main.c.
	 */</comment>
	<while>while <condition>(<expr><operator>(</operator><name>flag</name> <operator>=</operator> <call><name>getopt</name><argument_list>(<argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>, <argument><expr><literal type="string">"B:bc:C:D:d:EeFf:h:ijk:lN:nOo:Pp:r:S:sTt:v:W:-:"</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<switch>switch <condition>(<expr><name>flag</name></expr>)</condition>
		<block>{<block_content>
			<case>case <expr><literal type="char">'B'</literal></expr>:</case>
				<expr_stmt><expr><call><name>SetConfigOption</name><argument_list>(<argument><expr><literal type="string">"shared_buffers"</literal></expr></argument>, <argument><expr><name>optarg</name></expr></argument>, <argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>gucsource</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><literal type="char">'b'</literal></expr>:</case>
				<comment type="block">/* Undocumented flag used for binary upgrades */</comment>
				<if_stmt><if>if <condition>(<expr><name>secure</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>IsBinaryUpgrade</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<break>break;</break>

			<case>case <expr><literal type="char">'C'</literal></expr>:</case>
				<comment type="block">/* ignored for consistency with the postmaster */</comment>
				<break>break;</break>

			<case>case <expr><literal type="char">'D'</literal></expr>:</case>
				<if_stmt><if>if <condition>(<expr><name>secure</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>userDoption</name> <operator>=</operator> <call><name>strdup</name><argument_list>(<argument><expr><name>optarg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<break>break;</break>

			<case>case <expr><literal type="char">'d'</literal></expr>:</case>
				<expr_stmt><expr><call><name>set_debug_options</name><argument_list>(<argument><expr><call><name>atoi</name><argument_list>(<argument><expr><name>optarg</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>gucsource</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><literal type="char">'E'</literal></expr>:</case>
				<if_stmt><if>if <condition>(<expr><name>secure</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>EchoQuery</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<break>break;</break>

			<case>case <expr><literal type="char">'e'</literal></expr>:</case>
				<expr_stmt><expr><call><name>SetConfigOption</name><argument_list>(<argument><expr><literal type="string">"datestyle"</literal></expr></argument>, <argument><expr><literal type="string">"euro"</literal></expr></argument>, <argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>gucsource</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><literal type="char">'F'</literal></expr>:</case>
				<expr_stmt><expr><call><name>SetConfigOption</name><argument_list>(<argument><expr><literal type="string">"fsync"</literal></expr></argument>, <argument><expr><literal type="string">"false"</literal></expr></argument>, <argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>gucsource</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><literal type="char">'f'</literal></expr>:</case>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>set_plan_disabling_options</name><argument_list>(<argument><expr><name>optarg</name></expr></argument>, <argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>gucsource</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>errs</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<break>break;</break>

			<case>case <expr><literal type="char">'h'</literal></expr>:</case>
				<expr_stmt><expr><call><name>SetConfigOption</name><argument_list>(<argument><expr><literal type="string">"listen_addresses"</literal></expr></argument>, <argument><expr><name>optarg</name></expr></argument>, <argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>gucsource</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><literal type="char">'i'</literal></expr>:</case>
				<expr_stmt><expr><call><name>SetConfigOption</name><argument_list>(<argument><expr><literal type="string">"listen_addresses"</literal></expr></argument>, <argument><expr><literal type="string">"*"</literal></expr></argument>, <argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>gucsource</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><literal type="char">'j'</literal></expr>:</case>
				<if_stmt><if>if <condition>(<expr><name>secure</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>UseSemiNewlineNewline</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<break>break;</break>

			<case>case <expr><literal type="char">'k'</literal></expr>:</case>
				<expr_stmt><expr><call><name>SetConfigOption</name><argument_list>(<argument><expr><literal type="string">"unix_socket_directories"</literal></expr></argument>, <argument><expr><name>optarg</name></expr></argument>, <argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>gucsource</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><literal type="char">'l'</literal></expr>:</case>
				<expr_stmt><expr><call><name>SetConfigOption</name><argument_list>(<argument><expr><literal type="string">"ssl"</literal></expr></argument>, <argument><expr><literal type="string">"true"</literal></expr></argument>, <argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>gucsource</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><literal type="char">'N'</literal></expr>:</case>
				<expr_stmt><expr><call><name>SetConfigOption</name><argument_list>(<argument><expr><literal type="string">"max_connections"</literal></expr></argument>, <argument><expr><name>optarg</name></expr></argument>, <argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>gucsource</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><literal type="char">'n'</literal></expr>:</case>
				<comment type="block">/* ignored for consistency with postmaster */</comment>
				<break>break;</break>

			<case>case <expr><literal type="char">'O'</literal></expr>:</case>
				<expr_stmt><expr><call><name>SetConfigOption</name><argument_list>(<argument><expr><literal type="string">"allow_system_table_mods"</literal></expr></argument>, <argument><expr><literal type="string">"true"</literal></expr></argument>, <argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>gucsource</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><literal type="char">'o'</literal></expr>:</case>
				<expr_stmt><expr><name>errs</name><operator>++</operator></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><literal type="char">'P'</literal></expr>:</case>
				<expr_stmt><expr><call><name>SetConfigOption</name><argument_list>(<argument><expr><literal type="string">"ignore_system_indexes"</literal></expr></argument>, <argument><expr><literal type="string">"true"</literal></expr></argument>, <argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>gucsource</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><literal type="char">'p'</literal></expr>:</case>
				<expr_stmt><expr><call><name>SetConfigOption</name><argument_list>(<argument><expr><literal type="string">"port"</literal></expr></argument>, <argument><expr><name>optarg</name></expr></argument>, <argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>gucsource</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><literal type="char">'r'</literal></expr>:</case>
				<comment type="block">/* send output (stdout and stderr) to the given file */</comment>
				<if_stmt><if>if <condition>(<expr><name>secure</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>strlcpy</name><argument_list>(<argument><expr><name>OutputFileName</name></expr></argument>, <argument><expr><name>optarg</name></expr></argument>, <argument><expr><name>MAXPGPATH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<break>break;</break>

			<case>case <expr><literal type="char">'S'</literal></expr>:</case>
				<expr_stmt><expr><call><name>SetConfigOption</name><argument_list>(<argument><expr><literal type="string">"work_mem"</literal></expr></argument>, <argument><expr><name>optarg</name></expr></argument>, <argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>gucsource</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><literal type="char">'s'</literal></expr>:</case>
				<expr_stmt><expr><call><name>SetConfigOption</name><argument_list>(<argument><expr><literal type="string">"log_statement_stats"</literal></expr></argument>, <argument><expr><literal type="string">"true"</literal></expr></argument>, <argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>gucsource</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><literal type="char">'T'</literal></expr>:</case>
				<comment type="block">/* ignored for consistency with the postmaster */</comment>
				<break>break;</break>

			<case>case <expr><literal type="char">'t'</literal></expr>:</case>
				<block>{<block_content>
					<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>tmp</name> <init>= <expr><call><name>get_stats_option_name</name><argument_list>(<argument><expr><name>optarg</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

					<if_stmt><if>if <condition>(<expr><name>tmp</name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>SetConfigOption</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>, <argument><expr><literal type="string">"true"</literal></expr></argument>, <argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>gucsource</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
					<else>else<block type="pseudo"><block_content>
						<expr_stmt><expr><name>errs</name><operator>++</operator></expr>;</expr_stmt></block_content></block></else></if_stmt>
					<break>break;</break>
				</block_content>}</block>

			<case>case <expr><literal type="char">'v'</literal></expr>:</case>

				<comment type="block">/*
				 * -v is no longer used in normal operation, since
				 * FrontendProtocol is already set before we get here. We keep
				 * the switch only for possible use in standalone operation,
				 * in case we ever support using normal FE/BE protocol with a
				 * standalone backend.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><name>secure</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>FrontendProtocol</name> <operator>=</operator> <operator>(</operator><name>ProtocolVersion</name><operator>)</operator> <call><name>atoi</name><argument_list>(<argument><expr><name>optarg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<break>break;</break>

			<case>case <expr><literal type="char">'W'</literal></expr>:</case>
				<expr_stmt><expr><call><name>SetConfigOption</name><argument_list>(<argument><expr><literal type="string">"post_auth_delay"</literal></expr></argument>, <argument><expr><name>optarg</name></expr></argument>, <argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>gucsource</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><literal type="char">'c'</literal></expr>:</case>
			<case>case <expr><literal type="char">'-'</literal></expr>:</case>
				<block>{<block_content>
					<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>name</name></decl>,
							   <decl><type ref="prev"><modifier>*</modifier></type><name>value</name></decl>;</decl_stmt>

					<expr_stmt><expr><call><name>ParseLongOption</name><argument_list>(<argument><expr><name>optarg</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>name</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<if_stmt><if>if <condition>(<expr><operator>!</operator><name>value</name></expr>)</condition>
					<block>{<block_content>
						<if_stmt><if>if <condition>(<expr><name>flag</name> <operator>==</operator> <literal type="char">'-'</literal></expr>)</condition><block type="pseudo"><block_content>
							<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
									<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
									 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"--%s requires a value"</literal></expr></argument>,
											<argument><expr><name>optarg</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
						<else>else<block type="pseudo"><block_content>
							<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
									<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
									 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"-c %s requires a value"</literal></expr></argument>,
											<argument><expr><name>optarg</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
					</block_content>}</block></if></if_stmt>
					<expr_stmt><expr><call><name>SetConfigOption</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>value</name></expr></argument>, <argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>gucsource</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<if_stmt><if>if <condition>(<expr><name>value</name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
					<break>break;</break>
				</block_content>}</block>

			<default>default:</default>
				<expr_stmt><expr><name>errs</name><operator>++</operator></expr>;</expr_stmt>
				<break>break;</break>
		</block_content>}</block></switch>

		<if_stmt><if>if <condition>(<expr><name>errs</name></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>
	</block_content>}</block></while>

	<comment type="block">/*
	 * Optional database name should be there only if *dbname is NULL.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>errs</name> <operator>&amp;&amp;</operator> <name>dbname</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>dbname</name> <operator>==</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name>argc</name> <operator>-</operator> <name>optind</name> <operator>&gt;=</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><operator>*</operator><name>dbname</name> <operator>=</operator> <call><name>strdup</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><name>optind</name><operator>++</operator></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>errs</name> <operator>||</operator> <name>argc</name> <operator>!=</operator> <name>optind</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>errs</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>optind</name><operator>--</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>			<comment type="block">/* complain about the previous argument */</comment>

		<comment type="block">/* spell the error message a bit differently depending on context */</comment>
		<if_stmt><if>if <condition>(<expr><name>IsUnderPostmaster</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid command-line argument for server process: %s"</literal></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><name>optind</name></expr>]</index></name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Try \"%s --help\" for more information."</literal></expr></argument>, <argument><expr><name>progname</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"%s: invalid command-line argument: %s"</literal></expr></argument>,
							<argument><expr><name>progname</name></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><name>optind</name></expr>]</index></name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Try \"%s --help\" for more information."</literal></expr></argument>, <argument><expr><name>progname</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Reset getopt(3) library so that it will work correctly in subprocesses
	 * or when this function is called a second time with another array.
	 */</comment>
	<expr_stmt><expr><name>optind</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_INT_OPTRESET</name></cpp:ifdef>
	<expr_stmt><expr><name>optreset</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>				<comment type="block">/* some systems need this too */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>


<comment type="block">/* ----------------------------------------------------------------
 * PostgresMain
 *	   postgres main loop -- all backends, interactive or otherwise start here
 *
 * argc/argv are the command line arguments to be used.  (When being forked
 * by the postmaster, these are not the original argv array of the process.)
 * dbname is the name of the database to connect to, or NULL if the database
 * name should be extracted from the command line arguments or defaulted.
 * username is the PostgreSQL user name to be used for the session.
 * ----------------------------------------------------------------
 */</comment>
<function><type><name>void</name></type>
<name>PostgresMain</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name><name>argv</name><index>[]</index></name></decl></parameter>,
			 <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>dbname</name></decl></parameter>,
			 <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>username</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>firstchar</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>StringInfoData</name></type> <name>input_message</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>sigjmp_buf</name></type>	<name>local_sigjmp_buf</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>volatile</specifier> <name>bool</name></type> <name>send_ready_for_query</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>disable_idle_in_transaction_timeout</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* POLAR */</comment>
	<decl_stmt><decl><type><name>int</name></type>		<name>rmid</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TimestampTz</name></type>	<name>current_time</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>long</name></type> <name>secs</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>microsecs</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<comment type="block">/* POLAR px */</comment>
	<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>px_workers_num</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<comment type="block">/* Initialize startup process environment if necessary. */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>IsUnderPostmaster</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>InitStandaloneProcess</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>SetProcessingMode</name><argument_list>(<argument><expr><name>InitProcessing</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Set default values for command-line options.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>IsUnderPostmaster</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>InitializeGUCOptions</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Parse command-line options.
	 */</comment>
	<expr_stmt><expr><call><name>process_postgres_switches</name><argument_list>(<argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>, <argument><expr><name>PGC_POSTMASTER</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>dbname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Must have gotten a database name, or have a default (the username) */</comment>
	<if_stmt><if>if <condition>(<expr><name>dbname</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>dbname</name> <operator>=</operator> <name>username</name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>dbname</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"%s: no database nor user name specified"</literal></expr></argument>,
							<argument><expr><name>progname</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Acquire configuration parameters, unless inherited from postmaster */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>IsUnderPostmaster</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>SelectConfigFiles</name><argument_list>(<argument><expr><name>userDoption</name></expr></argument>, <argument><expr><name>progname</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>proc_exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Set up signal handlers and masks.
	 *
	 * Note that postmaster blocked all signals before forking child process,
	 * so there is no race condition whereby we might receive a signal before
	 * we have set up the handler.
	 *
	 * Also note: it's best not to use any signals that are SIG_IGNored in the
	 * postmaster.  If such a signal arrives before we are able to change the
	 * handler to non-SIG_IGN, it'll get dropped.  Instead, make a dummy
	 * handler in the postmaster to reserve the signal. (Of course, this isn't
	 * an issue for signals that are locally generated, such as SIGALRM and
	 * SIGPIPE.)
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>am_walsender</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>WalSndSignals</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>pqsignal</name><argument_list>(<argument><expr><name>SIGHUP</name></expr></argument>, <argument><expr><name>PostgresSigHupHandler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>	<comment type="block">/* set flag to read config
													 * file */</comment>
		<expr_stmt><expr><call><name>pqsignal</name><argument_list>(<argument><expr><name>SIGINT</name></expr></argument>, <argument><expr><name>StatementCancelHandler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>	<comment type="block">/* cancel current query */</comment>
		<expr_stmt><expr><call><name>pqsignal</name><argument_list>(<argument><expr><name>SIGTERM</name></expr></argument>, <argument><expr><name>die</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* cancel current query and exit */</comment>

		<comment type="block">/*
		 * In a standalone backend, SIGQUIT can be generated from the keyboard
		 * easily, while SIGTERM cannot, so we make both signals do die()
		 * rather than quickdie().
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>IsUnderPostmaster</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>pqsignal</name><argument_list>(<argument><expr><name>SIGQUIT</name></expr></argument>, <argument><expr><name>quickdie</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>	<comment type="block">/* hard crash time */</comment>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>pqsignal</name><argument_list>(<argument><expr><name>SIGQUIT</name></expr></argument>, <argument><expr><name>die</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt> <comment type="block">/* cancel current query and exit */</comment>
		<expr_stmt><expr><call><name>InitializeTimeouts</name><argument_list>()</argument_list></call></expr>;</expr_stmt>	<comment type="block">/* establishes SIGALRM handler */</comment>

		<comment type="block">/*
		 * Ignore failure to write to frontend. Note: if frontend closes
		 * connection, we will notice it and exit cleanly when control next
		 * returns to outer loop.  This seems safer than forcing exit in the
		 * midst of output during who-knows-what operation...
		 */</comment>
		<expr_stmt><expr><call><name>pqsignal</name><argument_list>(<argument><expr><name>SIGPIPE</name></expr></argument>, <argument><expr><name>SIG_IGN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pqsignal</name><argument_list>(<argument><expr><name>SIGUSR1</name></expr></argument>, <argument><expr><name>procsignal_sigusr1_handler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* POLAR: oom cancel query signal */</comment>
		<expr_stmt><expr><call><name>pqsignal</name><argument_list>(<argument><expr><name>SIGUSR2</name></expr></argument>, <argument><expr><name>polar_procsignal_sigusr2_handler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* POLAR end */</comment>
		<expr_stmt><expr><call><name>pqsignal</name><argument_list>(<argument><expr><name>SIGFPE</name></expr></argument>, <argument><expr><name>FloatExceptionHandler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Reset some signals that are accepted by postmaster but not by
		 * backend
		 */</comment>
		<expr_stmt><expr><call><name>pqsignal</name><argument_list>(<argument><expr><name>SIGCHLD</name></expr></argument>, <argument><expr><name>SIG_DFL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* system() requires this on some
									 * platforms */</comment>

		 <comment type="block">/* POLAR : register for coredump print */</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>_WIN32</name></cpp:ifndef>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SIGILL</name></cpp:ifdef>
		<expr_stmt><expr><call><name>pqsignal</name><argument_list>(<argument><expr><name>SIGILL</name></expr></argument>, <argument><expr><name>polar_program_error_handler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SIGSEGV</name></cpp:ifdef>
		<expr_stmt><expr><call><name>pqsignal</name><argument_list>(<argument><expr><name>SIGSEGV</name></expr></argument>, <argument><expr><name>polar_program_error_handler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SIGBUS</name></cpp:ifdef>
		<expr_stmt><expr><call><name>pqsignal</name><argument_list>(<argument><expr><name>SIGBUS</name></expr></argument>, <argument><expr><name>polar_program_error_handler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>	<comment type="block">/* _WIN32 */</comment>
		 <comment type="block">/* POLAR: end */</comment>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><call><name>pqinitmask</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>IsUnderPostmaster</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* We allow SIGQUIT (quickdie) at all times */</comment>
		<expr_stmt><expr><call><name>sigdelset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>BlockSig</name></expr></argument>, <argument><expr><name>SIGQUIT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>PG_SETMASK</name><argument_list>(<argument><expr><operator>&amp;</operator><name>BlockSig</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>		<comment type="block">/* block everything except SIGQUIT */</comment>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>IsUnderPostmaster</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Validate we have been given a reasonable-looking DataDir (if under
		 * postmaster, assume postmaster did this already).
		 */</comment>
		<expr_stmt><expr><call><name>checkDataDir</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Change into DataDir (if under postmaster, was done already) */</comment>
		<expr_stmt><expr><call><name>ChangeToDataDir</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Create lockfile for data directory.
		 */</comment>
		<expr_stmt><expr><call><name>CreateDataDirLockFile</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* read control file (error checking and contains config ) */</comment>
		<expr_stmt><expr><call><name>LocalProcessControlFile</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Initialize MaxBackends (if under postmaster, was done already) */</comment>
		<expr_stmt><expr><call><name>InitializeMaxBackends</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Early initialization */</comment>
	<expr_stmt><expr><call><name>BaseInit</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Initialize kmgr for cluster encryption. Since kmgr needs to attach to
	 * shared memory the initialization must be called after BaseInit().
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>IsUnderPostmaster</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>InitializeKmgr</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Create a per-backend PGPROC struct in shared memory, except in the
	 * EXEC_BACKEND case where this was done in SubPostmasterMain. We must do
	 * this before we can use LWLocks (and in the EXEC_BACKEND case we already
	 * had to do some stuff with LWLocks).
	 */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>EXEC_BACKEND</name></cpp:ifdef>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>IsUnderPostmaster</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>InitProcess</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	<expr_stmt><expr><call><name>InitProcess</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<comment type="block">/* We need to allow SIGINT, etc during the initial transaction */</comment>
	<expr_stmt><expr><call><name>PG_SETMASK</name><argument_list>(<argument><expr><operator>&amp;</operator><name>UnBlockSig</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * General initialization.
	 *
	 * NOTE: if you are tempted to add code in this vicinity, consider putting
	 * it inside InitPostgres() instead.  In particular, anything that
	 * involves database access should be there, not here.
	 */</comment>
	<expr_stmt><expr><call><name>InitPostgres</name><argument_list>(<argument><expr><name>dbname</name></expr></argument>, <argument><expr><name>InvalidOid</name></expr></argument>, <argument><expr><name>username</name></expr></argument>, <argument><expr><name>InvalidOid</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If the PostmasterContext is still around, recycle the space; we don't
	 * need it anymore after InitPostgres completes.  Note this does not trash
	 * *MyProcPort, because ConnCreate() allocated that space with malloc()
	 * ... else we'd need to copy the Port data first.  Also, subsidiary data
	 * such as the username isn't lost either; see ProcessStartupPacket().
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>PostmasterContext</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>MemoryContextDelete</name><argument_list>(<argument><expr><name>PostmasterContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>PostmasterContext</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>SetProcessingMode</name><argument_list>(<argument><expr><name>NormalProcessing</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Now all GUC states are fully set up.  Report them to client if
	 * appropriate.
	 */</comment>
	<expr_stmt><expr><call><name>BeginReportingGUCOptions</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Also set up handler to log session end; we have to wait till now to be
	 * sure Log_disconnections has its final value.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>IsUnderPostmaster</name> <operator>&amp;&amp;</operator> <name>Log_disconnections</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* 
		 * POLAR: We may log disconnections into audit log and writing audit log must hold LWLock in shmem.
		 * 	  After shmem_exit, we cannot use shmem any more, and on_proc_exit is after shmem_exit,
		 * 	  so we need to use before_shmem_exit hook instead of on_proc_exit hook here.
		 */</comment>
		<expr_stmt><expr><call><name>before_shmem_exit</name><argument_list>(<argument><expr><name>log_disconnections</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * POLAR: audit log flush callback.
	 * flush audit log will use MyProc in LWLock, so use before_shmem_exit 
	 * instead of on_proc_exit
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>IsUnderPostmaster</name> <operator>&amp;&amp;</operator> <name>polar_audit_log_flush_timeout</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>before_shmem_exit</name><argument_list>(<argument><expr><name>polar_audit_log_flush_callback</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Perform initialization specific to a WAL sender process. */</comment>
	<if_stmt><if>if <condition>(<expr><name>am_walsender</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>InitWalSender</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * process any libraries that should be preloaded at backend start (this
	 * likewise can't be done until GUC settings are complete)
	 */</comment>
	<expr_stmt><expr><call><name>process_session_preload_libraries</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Send this backend's cancellation info to the frontend.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>whereToSendOutput</name> <operator>==</operator> <name>DestRemote</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>StringInfoData</name></type> <name>buf</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>pq_beginmessage</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="char">'K'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pq_sendint32</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><operator>(</operator><name>int32</name><operator>)</operator> <call><name>polar_pgstat_get_virtual_pid</name><argument_list>(<argument><expr><name>MyProcPid</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pq_sendint32</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><operator>(</operator><name>int32</name><operator>)</operator> <name>MyCancelKey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pq_endmessage</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* Need not flush since ReadyForQuery will do it. */</comment>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Welcome banner for standalone case */</comment>
	<if_stmt><if>if <condition>(<expr><name>whereToSendOutput</name> <operator>==</operator> <name>DestDebug</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"\nPostgreSQL stand-alone backend %s\n"</literal></expr></argument>, <argument><expr><name>PG_VERSION</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Create the memory context we will use in the main loop.
	 *
	 * MessageContext is reset once per iteration of the main loop, ie, upon
	 * completion of processing of each command message from the client.
	 */</comment>
	<expr_stmt><expr><name>MessageContext</name> <operator>=</operator> <call><name>AllocSetContextCreate</name><argument_list>(<argument><expr><name>TopMemoryContext</name></expr></argument>,
										   <argument><expr><literal type="string">"MessageContext"</literal></expr></argument>,
										   <argument><expr><name>ALLOCSET_DEFAULT_SIZES</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Create memory context and buffer used for RowDescription messages. As
	 * SendRowDescriptionMessage(), via exec_describe_statement_message(), is
	 * frequently executed for ever single statement, we don't want to
	 * allocate a separate buffer every time.
	 */</comment>
	<expr_stmt><expr><name>row_description_context</name> <operator>=</operator> <call><name>AllocSetContextCreate</name><argument_list>(<argument><expr><name>TopMemoryContext</name></expr></argument>,
													<argument><expr><literal type="string">"RowDescriptionContext"</literal></expr></argument>,
													<argument><expr><name>ALLOCSET_DEFAULT_SIZES</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>row_description_context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>initStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>row_description_buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>TopMemoryContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Remember stand-alone backend startup time
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>IsUnderPostmaster</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>PgStartTime</name> <operator>=</operator> <call><name>GetCurrentTimestamp</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>


	<comment type="block">/*
	 * POSTGRES main processing loop begins here
	 *
	 * If an exception is encountered, processing resumes here so we abort the
	 * current transaction and start a new one.
	 *
	 * You might wonder why this isn't coded as an infinite loop around a
	 * PG_TRY construct.  The reason is that this is the bottom of the
	 * exception stack, and so with PG_TRY there would be no exception handler
	 * in force at all during the CATCH part.  By leaving the outermost setjmp
	 * always active, we have at least some chance of recovering from an error
	 * during error recovery.  (If we get into an infinite loop thereby, it
	 * will soon be stopped by overflow of elog.c's internal state stack.)
	 *
	 * Note that we use sigsetjmp(..., 1), so that this function's signal mask
	 * (to wit, UnBlockSig) will be restored when longjmp'ing to here.  This
	 * is essential in case we longjmp'd out of a signal handler on a platform
	 * where that leaves the signal blocked.  It's not redundant with the
	 * unblock in AbortTransaction() because the latter is only called if we
	 * were inside a transaction.
	 */</comment>

	<if_stmt><if>if <condition>(<expr><call><name>sigsetjmp</name><argument_list>(<argument><expr><name>local_sigjmp_buf</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * NOTE: if you are tempted to add more code in this if-block,
		 * consider the high probability that it should be in
		 * AbortTransaction() instead.  The only stuff done directly here
		 * should be stuff that is guaranteed to apply *only* for outer-level
		 * error recovery, such as adjusting the FE/BE protocol status.
		 */</comment>

		<comment type="block">/* Since not using PG_TRY, must reset error stack by hand */</comment>
		<expr_stmt><expr><name>error_context_stack</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

		<comment type="block">/* Prevent interrupts while cleaning up */</comment>
		<expr_stmt><expr><call><name>HOLD_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Forget any pending QueryCancel request, since we're returning to
		 * the idle loop anyway, and cancel any active timeout requests.  (In
		 * future we might want to allow some timeout requests to survive, but
		 * at minimum it'd be necessary to do reschedule_timeouts(), in case
		 * we got here because of a query cancel interrupting the SIGALRM
		 * interrupt handler.)	Note in particular that we must clear the
		 * statement and lock timeout indicators, to prevent any future plain
		 * query cancels from being misreported as timeouts in case we're
		 * forgetting a timeout cancel.
		 */</comment>
		<expr_stmt><expr><call><name>disable_all_timeouts</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>QueryCancelPending</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt> <comment type="block">/* second to avoid race condition */</comment>
		<expr_stmt><expr><name>stmt_timeout_active</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

		<comment type="block">/* Not reading from the client anymore. */</comment>
		<expr_stmt><expr><name>DoingCommandRead</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

		<comment type="block">/* Make sure libpq is in a good state */</comment>
		<expr_stmt><expr><call><name>pq_comm_reset</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Report the error to the client and/or server log */</comment>
		<expr_stmt><expr><call><name>EmitErrorReport</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Make sure debug_query_string gets reset before we possibly clobber
		 * the storage it points at.
		 */</comment>
		<expr_stmt><expr><name>debug_query_string</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

		<comment type="block">/*
		 * Abort the current transaction in order to recover.
		 */</comment>
		<expr_stmt><expr><call><name>AbortCurrentTransaction</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>am_walsender</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>WalSndErrorCleanup</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>PortalErrorCleanup</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>SPICleanup</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * We can't release replication slots inside AbortTransaction() as we
		 * need to be able to start and abort transactions while having a slot
		 * acquired. But we never need to hold them across top level errors,
		 * so releasing here is fine. There's another cleanup in ProcKill()
		 * ensuring we'll correctly cleanup on FATAL errors as well.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>MyReplicationSlot</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ReplicationSlotRelease</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/* We also want to cleanup temporary slots on error. */</comment>
		<expr_stmt><expr><call><name>ReplicationSlotCleanup</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>jit_reset_after_error</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Now return to normal top-level context and clear ErrorContext for
		 * next time.
		 */</comment>
		<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>TopMemoryContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>FlushErrorState</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * If we were handling an extended-query-protocol message, initiate
		 * skip till next Sync.  This also causes us not to issue
		 * ReadyForQuery (until we get Sync).
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>doing_extended_query_message</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>ignore_till_sync</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/* We don't have a transaction command open anymore */</comment>
		<expr_stmt><expr><name>xact_started</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

		<comment type="block">/*
		 * If an error occurred while we were reading a message from the
		 * client, we have potentially lost track of where the previous
		 * message ends and the next one begins.  Even though we have
		 * otherwise recovered from the error, we cannot safely read any more
		 * messages from the client, so there isn't much we can do with the
		 * connection anymore.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>pq_is_reading_msg</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_PROTOCOL_VIOLATION</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"terminating connection because protocol synchronization was lost"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>polar_xact_split_mark_unsplittable</name><argument_list>(<argument><expr><name>POLAR_UNSPLITTABLE_FOR_ERROR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Now we can allow interrupts again */</comment>
		<expr_stmt><expr><call><name>RESUME_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* We can now handle ereport(ERROR) */</comment>
	<expr_stmt><expr><name>PG_exception_stack</name> <operator>=</operator> <operator>&amp;</operator><name>local_sigjmp_buf</name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>ignore_till_sync</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>send_ready_for_query</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>	<comment type="block">/* initially, or after error */</comment>

	<comment type="block">/* POLAR px */</comment>
	<comment type="block">/* Also send PX-backend startup info (motion listener, version). */</comment>
	<if_stmt><if>if <condition>(<expr><name>px_role</name> <operator>==</operator> <name>PX_ROLE_PX</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>px_check_interrupt</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IS_PX_SETUP_DONE</name><argument_list>()</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>px_setup</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>on_proc_exit</name><argument_list>(<argument><expr><name>px_cleanup</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* after px_setup, a new socket is ready to use between QC and PX, so make pxWorkerCounter++ */</comment>
			<if_stmt><if>if <condition>(<expr><name>px_max_workers_number</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
				<operator>(</operator><name>px_workers_num</name> <operator>=</operator> <call><name>pg_atomic_add_fetch_u32</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ProcGlobal</name><operator>-&gt;</operator><name>pxWorkerCounter</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>&gt;=</operator> <name>px_max_workers_number</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"over px max workers, already %u workers, max %d workers"</literal></expr></argument>,
								<argument><expr><name>px_workers_num</name></expr></argument>, <argument><expr><name>px_max_workers_number</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><call><name>sendPXDetails</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>px_check_interrupt</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Non-error queries loop here.
	 */</comment>

	<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
	<block>{<block_content>
		<comment type="block">/*
		 * At top of loop, reset extended-query-message flag, so that any
		 * errors encountered in "idle" state don't provoke skip.
		 */</comment>
		<expr_stmt><expr><name>doing_extended_query_message</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

		<comment type="block">/*
		 * Release storage left over from prior query cycle, and create a new
		 * query input buffer in the cleared MessageContext.
		 */</comment>
		<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>MessageContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>MemoryContextResetAndDeleteChildren</name><argument_list>(<argument><expr><name>MessageContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* POLAR: initialize resource managers for polar buffer redo */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>polar_in_replica_mode</name><argument_list>()</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<for>for <control>(<init><expr><name>rmid</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>rmid</name> <operator>&lt;=</operator> <name>RM_MAX_ID</name></expr>;</condition> <incr><expr><name>rmid</name><operator>++</operator></expr></incr>)</control>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name><name>RmgrTable</name><index>[<expr><name>rmid</name></expr>]</index></name><operator>.</operator><name>rm_startup</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name><name>RmgrTable</name><index>[<expr><name>rmid</name></expr>]</index></name><operator>.</operator><call><name>rm_startup</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block></for>
		</block_content>}</block></if></if_stmt>
		<comment type="block">/* POLAR end */</comment>
	
		<expr_stmt><expr><call><name>initStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>input_message</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Also consider releasing our catalog snapshot if any, so that it's
		 * not preventing advance of global xmin while we wait for the client.
		 */</comment>
		<expr_stmt><expr><call><name>InvalidateCatalogSnapshotConditionally</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * (1) If we've reached idle state, tell the frontend we're ready for
		 * a new query.
		 *
		 * Note: this includes fflush()'ing the last of the prior output.
		 *
		 * This is also a good time to send collected statistics to the
		 * collector, and to update the PS stats display.  We avoid doing
		 * those every time through the message loop because it'd slow down
		 * processing of batched messages, and because we don't want to report
		 * uncommitted updates (that confuses autovacuum).  The notification
		 * processor wants a call too, if we are not in a transaction block.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>send_ready_for_query</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><call><name>IsAbortedTransactionBlockState</name><argument_list>()</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>set_ps_display</name><argument_list>(<argument><expr><literal type="string">"idle in transaction (aborted)"</literal></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>pgstat_report_activity</name><argument_list>(<argument><expr><name>STATE_IDLEINTRANSACTION_ABORTED</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/* Start the idle-in-transaction timer */</comment>
				<if_stmt><if>if <condition>(<expr><name>IdleInTransactionSessionTimeout</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name>disable_idle_in_transaction_timeout</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>enable_timeout_after</name><argument_list>(<argument><expr><name>IDLE_IN_TRANSACTION_SESSION_TIMEOUT</name></expr></argument>,
										 <argument><expr><name>IdleInTransactionSessionTimeout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></if>
			<if type="elseif">else if <condition>(<expr><call><name>IsTransactionOrTransactionBlock</name><argument_list>()</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>set_ps_display</name><argument_list>(<argument><expr><literal type="string">"idle in transaction"</literal></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>pgstat_report_activity</name><argument_list>(<argument><expr><name>STATE_IDLEINTRANSACTION</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/* Start the idle-in-transaction timer */</comment>
				<if_stmt><if>if <condition>(<expr><name>IdleInTransactionSessionTimeout</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name>disable_idle_in_transaction_timeout</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>enable_timeout_after</name><argument_list>(<argument><expr><name>IDLE_IN_TRANSACTION_SESSION_TIMEOUT</name></expr></argument>,
										 <argument><expr><name>IdleInTransactionSessionTimeout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<comment type="block">/* Send out notify signals and transmit self-notifies */</comment>
				<expr_stmt><expr><call><name>ProcessCompletedNotifies</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/*
				 * Also process incoming notifies, if any.  This is mostly to
				 * ensure stable behavior in tests: if any notifies were
				 * received during the just-finished transaction, they'll be
				 * seen by the client before ReadyForQuery is.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><name>notifyInterruptPending</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ProcessNotifyInterrupt</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

				<expr_stmt><expr><call><name>pgstat_report_stat</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><call><name>set_ps_display</name><argument_list>(<argument><expr><literal type="string">"idle"</literal></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>pgstat_report_activity</name><argument_list>(<argument><expr><name>STATE_IDLE</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>

			<expr_stmt><expr><call><name>ReadyForQuery</name><argument_list>(<argument><expr><name>whereToSendOutput</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>send_ready_for_query</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * (2) Allow asynchronous signals to be executed immediately if they
		 * come in while we are waiting for client input. (This must be
		 * conditional since we don't want, say, reads on behalf of COPY FROM
		 * STDIN doing the same thing.)
		 */</comment>
		<expr_stmt><expr><name>DoingCommandRead</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

		<comment type="block">/*
		 * (3) read a command (loop blocks here)
		 */</comment>
		<expr_stmt><expr><name>firstchar</name> <operator>=</operator> <call><name>ReadCommand</name><argument_list>(<argument><expr><operator>&amp;</operator><name>input_message</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * (4) disable async signal conditions again.
		 *
		 * Query cancel is supposed to be a no-op when there is no query in
		 * progress, so if a query cancel arrived while we were idle, just
		 * reset QueryCancelPending. ProcessInterrupts() has that effect when
		 * it's called when DoingCommandRead is set, so check for interrupts
		 * before resetting DoingCommandRead.
		 */</comment>
		<expr_stmt><expr><call><name>CHECK_FOR_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>DoingCommandRead</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

		<comment type="block">/*
		 * (5) turn off the idle-in-transaction timeout
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>disable_idle_in_transaction_timeout</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>disable_timeout</name><argument_list>(<argument><expr><name>IDLE_IN_TRANSACTION_SESSION_TIMEOUT</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>disable_idle_in_transaction_timeout</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * (6) check for any other interesting events that happened while we
		 * slept.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>ConfigReloadPending</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>ConfigReloadPending</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>ProcessConfigFile</name><argument_list>(<argument><expr><name>PGC_SIGHUP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * (7) process the command.  But ignore it if we're skipping till
		 * Sync.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>ignore_till_sync</name> <operator>&amp;&amp;</operator> <name>firstchar</name> <operator>!=</operator> <name>EOF</name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<switch>switch <condition>(<expr><name>firstchar</name></expr>)</condition>
		<block>{<block_content>
			<case>case <expr><literal type="char">'Q'</literal></expr>:</case>			<comment type="block">/* simple query */</comment>
				<block>{<block_content>
					<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>query_string</name></decl>;</decl_stmt>

					<if_stmt><if>if <condition>(<expr><name>MyProcPort</name> <operator>&amp;&amp;</operator> <name><name>MyProcPort</name><operator>-&gt;</operator><name>polar_proxy</name></name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><name>polar_stat_need_update_proxy_info</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

					<comment type="block">/* Set statement_timestamp() */</comment>
					<expr_stmt><expr><call><name>SetCurrentStatementStartTimestamp</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

					<expr_stmt><expr><name>query_string</name> <operator>=</operator> <call><name>pq_getmsgstring</name><argument_list>(<argument><expr><operator>&amp;</operator><name>input_message</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>pq_getmsgend</name><argument_list>(<argument><expr><operator>&amp;</operator><name>input_message</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<if_stmt><if>if <condition>(<expr><name>am_walsender</name></expr>)</condition>
					<block>{<block_content>
						<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>exec_replication_command</name><argument_list>(<argument><expr><name>query_string</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
							<expr_stmt><expr><call><name>exec_simple_query</name><argument_list>(<argument><expr><name>query_string</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
					</block_content>}</block></if>
					<else>else<block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>exec_simple_query</name><argument_list>(<argument><expr><name>query_string</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

					<expr_stmt><expr><name>send_ready_for_query</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				</block_content>}</block>
				<break>break;</break>
			<comment type="block">/* POLAR px: dispatched statement from QC */</comment>
        	<case>case <expr><literal type="char">'M'</literal></expr>:</case>
				<block>{<block_content>
					<comment type="block">/*
					 * This is exactly like 'Q' above except we peel off and
					 * set the snapshot information right away.
					 *
					 * Since PortalDefineQuery() does not take NULL query string,
					 * we initialize it with a constant empty string.
					 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>INT32_DECODE</name><parameter_list>(<parameter><type><name>value</name></type></parameter>)</parameter_list></cpp:macro>\
	<cpp:value>value = pq_getmsgint(&amp;input_message, 4);</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>UINT64_DECODE</name><parameter_list>(<parameter><type><name>value</name></type></parameter>)</parameter_list></cpp:macro>\
	<cpp:value>value = pq_getmsgint64(&amp;input_message);</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>STR_DECODE</name><parameter_list>(<parameter><type><name>len</name></type></parameter>, <parameter><type><name>str</name></type></parameter>)</parameter_list></cpp:macro>\
	<cpp:value>len = pq_getmsgint(&amp;input_message, 4);\
	str = len &gt; 0 ? pq_getmsgbytes(&amp;input_message, len) : NULL;</cpp:value></cpp:define>

					<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>queryString</name> <init>= <expr><call><name>pstrdup</name><argument_list>(<argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
					<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>serializedQuerytree</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
					<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>serializedPlantree</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
					<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>serializedParams</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
					<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>serializedQueryDispatchDesc</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
					<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>serializedSnapshot</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

					<decl_stmt><decl><type><name>int</name></type> <name>recv_px_serialize_version</name></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>TimestampTz</name></type> <name>statementStart</name></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>int</name></type> <name>suid</name></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>Oid</name></type> <name>ouid</name></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>Oid</name></type> <name>cuid</name></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>int</name></type> <name>queryStringlen</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>int</name></type> <name>serializedQuerytreelen</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>int</name></type> <name>serializedPlantreelen</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>int</name></type> <name>serializedParamslen</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>int</name></type> <name>serializedQueryDispatchDesclen</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>int</name></type> <name>serializedSnapshotlen</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

					<if_stmt><if>if <condition>(<expr><name>px_role</name> <operator>!=</operator> <name>PX_ROLE_PX</name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
								<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_PROTOCOL_VIOLATION</name></expr></argument>)</argument_list></call><operator>,</operator>
								 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"PX protocol messages are only supported in QC - PX connections"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

					<comment type="block">/* Set statement_timestamp() */</comment>
 					<expr_stmt><expr><call><name>SetCurrentStatementStartTimestamp</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

					<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>, <argument><expr><literal type="string">"Message type %c received by from libpq, len = %d"</literal></expr></argument>, <argument><expr><name>firstchar</name></expr></argument>, <argument><expr><name><name>input_message</name><operator>.</operator><name>len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<expr_stmt><expr><call><name>INT32_DECODE</name><argument_list>(<argument><expr><name>recv_px_serialize_version</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<if_stmt><if>if <condition>(<expr><name>recv_px_serialize_version</name> <operator>!=</operator> <name>px_serialize_version</name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"missmatch px_serialize_version, expected=%d, recv=%d"</literal></expr></argument>, <argument><expr><name>px_serialize_version</name></expr></argument>, <argument><expr><name>recv_px_serialize_version</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

					<expr_stmt><expr><call><name>INT32_DECODE</name><argument_list>(<argument><expr><name>suid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>INT32_DECODE</name><argument_list>(<argument><expr><name>ouid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>INT32_DECODE</name><argument_list>(<argument><expr><name>cuid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<expr_stmt><expr><call><name>UINT64_DECODE</name><argument_list>(<argument><expr><name>statementStart</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>UINT64_DECODE</name><argument_list>(<argument><expr><name><name>sql_trace_id</name><operator>.</operator><name>uval</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<expr_stmt><expr><call><name>STR_DECODE</name><argument_list>(<argument><expr><name>queryStringlen</name></expr></argument>, <argument><expr><name>queryString</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>STR_DECODE</name><argument_list>(<argument><expr><name>serializedQuerytreelen</name></expr></argument>, <argument><expr><name>serializedQuerytree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>STR_DECODE</name><argument_list>(<argument><expr><name>serializedPlantreelen</name></expr></argument>, <argument><expr><name>serializedPlantree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>STR_DECODE</name><argument_list>(<argument><expr><name>serializedParamslen</name></expr></argument>, <argument><expr><name>serializedParams</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>STR_DECODE</name><argument_list>(<argument><expr><name>serializedQueryDispatchDesclen</name></expr></argument>, <argument><expr><name>serializedQueryDispatchDesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>STR_DECODE</name><argument_list>(<argument><expr><name>serializedSnapshotlen</name></expr></argument>, <argument><expr><name>serializedSnapshot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<comment type="block">/*
					 * GUC "is_supersuer" only provide value for SHOW to display,
					 * so it's useless on segments. SessionUserIsSuperuser is
					 * also designed to determine the value of is_superuser, so
					 * setting it to false on segments is fine.
					 */</comment>
					<if_stmt><if>if <condition>(<expr><name>suid</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>SetSessionUserId</name><argument_list>(<argument><expr><name>suid</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt> <comment type="block">/* Set the session UserId */</comment>

					<if_stmt><if>if <condition>(<expr><name>ouid</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>ouid</name> <operator>!=</operator> <call><name>GetSessionUserId</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>SetCurrentRoleId</name><argument_list>(<argument><expr><name>ouid</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt> <comment type="block">/* Set the outer UserId */</comment>

					<if_stmt><if>if <condition>(<expr><name>cuid</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>SetUserIdAndContext</name><argument_list>(<argument><expr><name>cuid</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt> <comment type="block">/* Set current userid */</comment>

					<if_stmt><if>if <condition>(<expr><name>serializedSnapshotlen</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>pxsn_set_serialized_snapshot</name><argument_list>(<argument><expr><name>serializedSnapshot</name></expr></argument>, <argument><expr><name>serializedSnapshotlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

					<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><operator>(</operator><ternary><condition><expr><name>px_enable_print</name></expr> ?</condition><then> <expr><name>LOG</name></expr> </then><else>: <expr><name>DEBUG5</name></expr></else></ternary><operator>)</operator></expr></argument>, 
						<argument><expr><literal type="string">"px dispatched stmt from QC: %s. sendTime:%ld,recvTime:%ld"</literal></expr></argument>,
						<argument><expr><name>queryString</name></expr></argument>, <argument><expr><name>statementStart</name></expr></argument>, 
						<argument><expr><call><name>GetCurrentStatementStartTimestamp</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<if_stmt><if>if <condition>(<expr><literal type="number">0</literal> <operator>==</operator> <name>serializedQuerytreelen</name> <operator>&amp;&amp;</operator> 
						<literal type="number">0</literal> <operator>==</operator> <name>serializedPlantreelen</name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>exec_simple_query</name><argument_list>(<argument><expr><name>queryString</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
					<else>else<block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>exec_px_query</name><argument_list>(<argument><expr><name>queryString</name></expr></argument>,
									   <argument><expr><name>serializedQuerytree</name></expr></argument>, <argument><expr><name>serializedQuerytreelen</name></expr></argument>,
									   <argument><expr><name>serializedPlantree</name></expr></argument>, <argument><expr><name>serializedPlantreelen</name></expr></argument>,
									   <argument><expr><name>serializedParams</name></expr></argument>, <argument><expr><name>serializedParamslen</name></expr></argument>,
									   <argument><expr><name>serializedQueryDispatchDesc</name></expr></argument>, <argument><expr><name>serializedQueryDispatchDesclen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

					<expr_stmt><expr><call><name>SetUserIdAndContext</name><argument_list>(<argument><expr><call><name>GetOuterUserId</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<expr_stmt><expr><name>send_ready_for_query</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				</block_content>}</block>
				<break>break;</break>

			<case>case <expr><literal type="char">'P'</literal></expr>:</case>			<comment type="block">/* parse */</comment>
				<block>{<block_content>
					<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>stmt_name</name></decl>;</decl_stmt>
					<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>query_string</name></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>int</name></type>			<name>numParams</name></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>Oid</name>		   <modifier>*</modifier></type><name>paramTypes</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

					<if_stmt><if>if <condition>(<expr><name>MyProcPort</name> <operator>&amp;&amp;</operator> <name><name>MyProcPort</name><operator>-&gt;</operator><name>polar_proxy</name></name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><name>polar_stat_need_update_proxy_info</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

					<expr_stmt><expr><call><name>forbidden_in_wal_sender</name><argument_list>(<argument><expr><name>firstchar</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<comment type="block">/* Set statement_timestamp() */</comment>
					<expr_stmt><expr><call><name>SetCurrentStatementStartTimestamp</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

					<expr_stmt><expr><name>stmt_name</name> <operator>=</operator> <call><name>pq_getmsgstring</name><argument_list>(<argument><expr><operator>&amp;</operator><name>input_message</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>query_string</name> <operator>=</operator> <call><name>pq_getmsgstring</name><argument_list>(<argument><expr><operator>&amp;</operator><name>input_message</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>numParams</name> <operator>=</operator> <call><name>pq_getmsgint</name><argument_list>(<argument><expr><operator>&amp;</operator><name>input_message</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<if_stmt><if>if <condition>(<expr><name>numParams</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
					<block>{<block_content>
						<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

						<expr_stmt><expr><name>paramTypes</name> <operator>=</operator> <operator>(</operator><name>Oid</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>numParams</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>numParams</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
							<expr_stmt><expr><name><name>paramTypes</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>pq_getmsgint</name><argument_list>(<argument><expr><operator>&amp;</operator><name>input_message</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
					</block_content>}</block></if></if_stmt>
					<expr_stmt><expr><call><name>pq_getmsgend</name><argument_list>(<argument><expr><operator>&amp;</operator><name>input_message</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<expr_stmt><expr><call><name>exec_parse_message</name><argument_list>(<argument><expr><name>query_string</name></expr></argument>, <argument><expr><name>stmt_name</name></expr></argument>,
									   <argument><expr><name>paramTypes</name></expr></argument>, <argument><expr><name>numParams</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block>
				<break>break;</break>

			<case>case <expr><literal type="char">'B'</literal></expr>:</case>			<comment type="block">/* bind */</comment>
				<expr_stmt><expr><call><name>forbidden_in_wal_sender</name><argument_list>(<argument><expr><name>firstchar</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/* Set statement_timestamp() */</comment>
				<expr_stmt><expr><call><name>SetCurrentStatementStartTimestamp</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/*
				 * this message is complex enough that it seems best to put
				 * the field extraction out-of-line
				 */</comment>
				<expr_stmt><expr><call><name>exec_bind_message</name><argument_list>(<argument><expr><operator>&amp;</operator><name>input_message</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><literal type="char">'E'</literal></expr>:</case>			<comment type="block">/* execute */</comment>
				<block>{<block_content>
					<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>portal_name</name></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>int</name></type>			<name>max_rows</name></decl>;</decl_stmt>

					<expr_stmt><expr><call><name>forbidden_in_wal_sender</name><argument_list>(<argument><expr><name>firstchar</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<comment type="block">/* Set statement_timestamp() */</comment>
					<expr_stmt><expr><call><name>SetCurrentStatementStartTimestamp</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

					<expr_stmt><expr><name>portal_name</name> <operator>=</operator> <call><name>pq_getmsgstring</name><argument_list>(<argument><expr><operator>&amp;</operator><name>input_message</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>max_rows</name> <operator>=</operator> <call><name>pq_getmsgint</name><argument_list>(<argument><expr><operator>&amp;</operator><name>input_message</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>pq_getmsgend</name><argument_list>(<argument><expr><operator>&amp;</operator><name>input_message</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<expr_stmt><expr><call><name>exec_execute_message</name><argument_list>(<argument><expr><name>portal_name</name></expr></argument>, <argument><expr><name>max_rows</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block>
				<break>break;</break>

			<case>case <expr><literal type="char">'F'</literal></expr>:</case>			<comment type="block">/* fastpath function call */</comment>
				<expr_stmt><expr><call><name>forbidden_in_wal_sender</name><argument_list>(<argument><expr><name>firstchar</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/* Set statement_timestamp() */</comment>
				<expr_stmt><expr><call><name>SetCurrentStatementStartTimestamp</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/* Report query to various monitoring facilities. */</comment>
				<expr_stmt><expr><call><name>pgstat_report_activity</name><argument_list>(<argument><expr><name>STATE_FASTPATH</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>set_ps_display</name><argument_list>(<argument><expr><literal type="string">"&lt;FASTPATH&gt;"</literal></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/* start an xact for this function invocation */</comment>
				<expr_stmt><expr><call><name>start_xact_command</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/*
				 * Note: we may at this point be inside an aborted
				 * transaction.  We can't throw error for that until we've
				 * finished reading the function-call message, so
				 * HandleFunctionRequest() must check for it after doing so.
				 * Be careful not to do anything that assumes we're inside a
				 * valid transaction here.
				 */</comment>

				<comment type="block">/* switch back to message context */</comment>
				<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>MessageContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><call><name>HandleFunctionRequest</name><argument_list>(<argument><expr><operator>&amp;</operator><name>input_message</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/* commit the function-invocation transaction */</comment>
				<expr_stmt><expr><call><name>finish_xact_command</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><name>send_ready_for_query</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><literal type="char">'C'</literal></expr>:</case>			<comment type="block">/* close */</comment>
				<block>{<block_content>
					<decl_stmt><decl><type><name>int</name></type>			<name>close_type</name></decl>;</decl_stmt>
					<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>close_target</name></decl>;</decl_stmt>

					<expr_stmt><expr><call><name>forbidden_in_wal_sender</name><argument_list>(<argument><expr><name>firstchar</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<expr_stmt><expr><name>close_type</name> <operator>=</operator> <call><name>pq_getmsgbyte</name><argument_list>(<argument><expr><operator>&amp;</operator><name>input_message</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>close_target</name> <operator>=</operator> <call><name>pq_getmsgstring</name><argument_list>(<argument><expr><operator>&amp;</operator><name>input_message</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>pq_getmsgend</name><argument_list>(<argument><expr><operator>&amp;</operator><name>input_message</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<switch>switch <condition>(<expr><name>close_type</name></expr>)</condition>
					<block>{<block_content>
						<case>case <expr><literal type="char">'S'</literal></expr>:</case>
							<if_stmt><if>if <condition>(<expr><name><name>close_target</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'\0'</literal></expr>)</condition><block type="pseudo"><block_content>
								<expr_stmt><expr><call><name>DropPreparedStatement</name><argument_list>(<argument><expr><name>close_target</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
							<else>else
							<block>{<block_content>
								<comment type="block">/* special-case the unnamed statement */</comment>
								<expr_stmt><expr><call><name>drop_unnamed_stmt</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
							</block_content>}</block></else></if_stmt>
							<break>break;</break>
						<case>case <expr><literal type="char">'P'</literal></expr>:</case>
							<block>{<block_content>
								<decl_stmt><decl><type><name>Portal</name></type>		<name>portal</name></decl>;</decl_stmt>

								<expr_stmt><expr><name>portal</name> <operator>=</operator> <call><name>GetPortalByName</name><argument_list>(<argument><expr><name>close_target</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
								<if_stmt><if>if <condition>(<expr><call><name>PortalIsValid</name><argument_list>(<argument><expr><name>portal</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
									<expr_stmt><expr><call><name>PortalDrop</name><argument_list>(<argument><expr><name>portal</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
							</block_content>}</block>
							<break>break;</break>
						<default>default:</default>
							<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
									<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_PROTOCOL_VIOLATION</name></expr></argument>)</argument_list></call><operator>,</operator>
									 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid CLOSE message subtype %d"</literal></expr></argument>,
											<argument><expr><name>close_type</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							<break>break;</break>
					</block_content>}</block></switch>

					<if_stmt><if>if <condition>(<expr><name>whereToSendOutput</name> <operator>==</operator> <name>DestRemote</name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>pq_putemptymessage</name><argument_list>(<argument><expr><literal type="char">'3'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>	<comment type="block">/* CloseComplete */</comment>
				</block_content>}</block>
				<break>break;</break>

			<case>case <expr><literal type="char">'D'</literal></expr>:</case>			<comment type="block">/* describe */</comment>
				<block>{<block_content>
					<decl_stmt><decl><type><name>int</name></type>			<name>describe_type</name></decl>;</decl_stmt>
					<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>describe_target</name></decl>;</decl_stmt>

					<expr_stmt><expr><call><name>forbidden_in_wal_sender</name><argument_list>(<argument><expr><name>firstchar</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<comment type="block">/* Set statement_timestamp() (needed for xact) */</comment>
					<expr_stmt><expr><call><name>SetCurrentStatementStartTimestamp</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

					<expr_stmt><expr><name>describe_type</name> <operator>=</operator> <call><name>pq_getmsgbyte</name><argument_list>(<argument><expr><operator>&amp;</operator><name>input_message</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>describe_target</name> <operator>=</operator> <call><name>pq_getmsgstring</name><argument_list>(<argument><expr><operator>&amp;</operator><name>input_message</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>pq_getmsgend</name><argument_list>(<argument><expr><operator>&amp;</operator><name>input_message</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<switch>switch <condition>(<expr><name>describe_type</name></expr>)</condition>
					<block>{<block_content>
						<case>case <expr><literal type="char">'S'</literal></expr>:</case>
							<expr_stmt><expr><call><name>exec_describe_statement_message</name><argument_list>(<argument><expr><name>describe_target</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							<break>break;</break>
						<case>case <expr><literal type="char">'P'</literal></expr>:</case>
							<expr_stmt><expr><call><name>exec_describe_portal_message</name><argument_list>(<argument><expr><name>describe_target</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							<break>break;</break>
						<default>default:</default>
							<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
									<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_PROTOCOL_VIOLATION</name></expr></argument>)</argument_list></call><operator>,</operator>
									 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid DESCRIBE message subtype %d"</literal></expr></argument>,
											<argument><expr><name>describe_type</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							<break>break;</break>
					</block_content>}</block></switch>
				</block_content>}</block>
				<break>break;</break>

			<case>case <expr><literal type="char">'H'</literal></expr>:</case>			<comment type="block">/* flush */</comment>
				<expr_stmt><expr><call><name>pq_getmsgend</name><argument_list>(<argument><expr><operator>&amp;</operator><name>input_message</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name>whereToSendOutput</name> <operator>==</operator> <name>DestRemote</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>pq_flush</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<break>break;</break>

			<case>case <expr><literal type="char">'S'</literal></expr>:</case>			<comment type="block">/* sync */</comment>
				<expr_stmt><expr><call><name>pq_getmsgend</name><argument_list>(<argument><expr><operator>&amp;</operator><name>input_message</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>finish_xact_command</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>send_ready_for_query</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<break>break;</break>

				<comment type="block">/*
				 * 'X' means that the frontend is closing down the socket. EOF
				 * means unexpected loss of frontend connection. Either way,
				 * perform normal shutdown.
				 */</comment>
			<case>case <expr><literal type="char">'X'</literal></expr>:</case>
			<case>case <expr><name>EOF</name></expr>:</case>

				<comment type="block">/*
				 * Reset whereToSendOutput to prevent ereport from attempting
				 * to send any more messages to client.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><name>whereToSendOutput</name> <operator>==</operator> <name>DestRemote</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>whereToSendOutput</name> <operator>=</operator> <name>DestNone</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

				<comment type="block">/*
				 * NOTE: if you are tempted to add more code here, DON'T!
				 * Whatever you had in mind to do should be set up as an
				 * on_proc_exit or on_shmem_exit callback, instead. Otherwise
				 * it will fail to be called during other backend-shutdown
				 * scenarios.
				 */</comment>
				<expr_stmt><expr><call><name>proc_exit</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<case>case <expr><literal type="char">'d'</literal></expr>:</case>			<comment type="block">/* copy data */</comment>
			<case>case <expr><literal type="char">'c'</literal></expr>:</case>			<comment type="block">/* copy done */</comment>
			<case>case <expr><literal type="char">'f'</literal></expr>:</case>			<comment type="block">/* copy fail */</comment>

				<comment type="block">/*
				 * Accept but ignore these messages, per protocol spec; we
				 * probably got here because a COPY failed, and the frontend
				 * is still sending data.
				 */</comment>
				<break>break;</break>

			<default>default:</default>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_PROTOCOL_VIOLATION</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid frontend message type %d"</literal></expr></argument>,
								<argument><expr><name>firstchar</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></switch>
		<comment type="block">/*
		 * POLAR: initialize polar_last_audit_log_flush_time if it is not set.
		 * flush audit log over the audit log time threshold.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>polar_audit_log_buffer_is_null</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <name>polar_audit_log_flush_timeout</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>current_time</name> <operator>=</operator> <call><name>GetCurrentTimestamp</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>TimestampDifference</name><argument_list>(<argument><expr><name>polar_last_audit_log_flush_time</name></expr></argument>, <argument><expr><name>current_time</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>secs</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>microsecs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>polar_last_audit_log_flush_time</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>polar_last_audit_log_flush_time</name> <operator>=</operator> <name>current_time</name></expr>;</expr_stmt></block_content></block></if>
			<else>else
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name>secs</name> <operator>*</operator> <literal type="number">1000</literal> <operator>+</operator> <name>microsecs</name> <operator>/</operator> <literal type="number">1000</literal> <operator>&gt;</operator> <name>polar_audit_log_flush_timeout</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>polar_audit_log_flush</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>polar_last_audit_log_flush_time</name> <operator>=</operator> <name>current_time</name></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>							<comment type="block">/* end of input-reading loop */</comment>
</block_content>}</block></function>

<comment type="block">/*
 * Throw an error if we're a WAL sender process.
 *
 * This is used to forbid anything else than simple query protocol messages
 * in a WAL sender process.  'firstchar' specifies what kind of a forbidden
 * message was received, and is used to construct the error message.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>forbidden_in_wal_sender</name><parameter_list>(<parameter><decl><type><name>char</name></type> <name>firstchar</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>am_walsender</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>firstchar</name> <operator>==</operator> <literal type="char">'F'</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_PROTOCOL_VIOLATION</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"fastpath function calls not supported in a replication connection"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_PROTOCOL_VIOLATION</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"extended query protocol not supported in a replication connection"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * Obtain platform stack depth limit (in bytes)
 *
 * Return -1 if unknown
 */</comment>
<function><type><name>long</name></type>
<name>get_stack_depth_rlimit</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_GETRLIMIT</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>defined</name><argument_list>(<argument><expr><name>RLIMIT_STACK</name></expr></argument>)</argument_list></call></expr></cpp:if>
	<decl_stmt><decl><type><specifier>static</specifier> <name>long</name></type> <name>val</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<comment type="block">/* This won't change after process launch, so check just once */</comment>
	<if_stmt><if>if <condition>(<expr><name>val</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name><name>struct</name> <name>rlimit</name></name></type> <name>rlim</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>getrlimit</name><argument_list>(<argument><expr><name>RLIMIT_STACK</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rlim</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>val</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><name><name>rlim</name><operator>.</operator><name>rlim_cur</name></name> <operator>==</operator> <name>RLIM_INFINITY</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>val</name> <operator>=</operator> <name>LONG_MAX</name></expr>;</expr_stmt></block_content></block></if>
		<comment type="block">/* rlim_cur is probably of an unsigned type, so check for overflow */</comment>
		<if type="elseif">else if <condition>(<expr><name><name>rlim</name><operator>.</operator><name>rlim_cur</name></name> <operator>&gt;=</operator> <name>LONG_MAX</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>val</name> <operator>=</operator> <name>LONG_MAX</name></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>val</name> <operator>=</operator> <name><name>rlim</name><operator>.</operator><name>rlim_cur</name></name></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><name>val</name></expr>;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>							<comment type="block">/* no getrlimit */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>WIN32</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>__CYGWIN__</name></expr></argument>)</argument_list></call></expr></cpp:if>
	<comment type="block">/* On Windows we set the backend stack size in src/backend/Makefile */</comment>
	<return>return <expr><name>WIN32_STACK_RLIMIT</name></expr>;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>							<comment type="block">/* not windows ... give up */</comment>
	<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>


<decl_stmt><decl><type><specifier>static</specifier> <name><name>struct</name> <name>rusage</name></name></type> <name>Save_r</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name><name>struct</name> <name>timeval</name></name></type> <name>Save_t</name></decl>;</decl_stmt>

<function><type><name>void</name></type>
<name>ResetUsage</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>getrusage</name><argument_list>(<argument><expr><name>RUSAGE_SELF</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>Save_r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>gettimeofday</name><argument_list>(<argument><expr><operator>&amp;</operator><name>Save_t</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>ShowUsage</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>title</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>StringInfoData</name></type> <name>str</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>timeval</name></name></type> <name>user</name></decl>,
				<decl><type ref="prev"/><name>sys</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>timeval</name></name></type> <name>elapse_t</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>rusage</name></name></type> <name>r</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>getrusage</name><argument_list>(<argument><expr><name>RUSAGE_SELF</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>gettimeofday</name><argument_list>(<argument><expr><operator>&amp;</operator><name>elapse_t</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>user</name></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name><name>r</name><operator>.</operator><name>ru_utime</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>user</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>sys</name></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name><name>r</name><operator>.</operator><name>ru_stime</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>sys</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>elapse_t</name><operator>.</operator><name>tv_usec</name></name> <operator>&lt;</operator> <name><name>Save_t</name><operator>.</operator><name>tv_usec</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>elapse_t</name><operator>.</operator><name>tv_sec</name></name><operator>--</operator></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>elapse_t</name><operator>.</operator><name>tv_usec</name></name> <operator>+=</operator> <literal type="number">1000000</literal></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>r</name><operator>.</operator><name>ru_utime</name><operator>.</operator><name>tv_usec</name></name> <operator>&lt;</operator> <name><name>Save_r</name><operator>.</operator><name>ru_utime</name><operator>.</operator><name>tv_usec</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>r</name><operator>.</operator><name>ru_utime</name><operator>.</operator><name>tv_sec</name></name><operator>--</operator></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>r</name><operator>.</operator><name>ru_utime</name><operator>.</operator><name>tv_usec</name></name> <operator>+=</operator> <literal type="number">1000000</literal></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>r</name><operator>.</operator><name>ru_stime</name><operator>.</operator><name>tv_usec</name></name> <operator>&lt;</operator> <name><name>Save_r</name><operator>.</operator><name>ru_stime</name><operator>.</operator><name>tv_usec</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>r</name><operator>.</operator><name>ru_stime</name><operator>.</operator><name>tv_sec</name></name><operator>--</operator></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>r</name><operator>.</operator><name>ru_stime</name><operator>.</operator><name>tv_usec</name></name> <operator>+=</operator> <literal type="number">1000000</literal></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * The only stats we don't show here are ixrss, idrss, isrss.  It takes
	 * some work to interpret them, and most platforms don't fill them in.
	 */</comment>
	<expr_stmt><expr><call><name>initStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>str</name></expr></argument>, <argument><expr><literal type="string">"! system usage stats:\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>str</name></expr></argument>,
					 <argument><expr><literal type="string">"!\t%ld.%06ld s user, %ld.%06ld s system, %ld.%06ld s elapsed\n"</literal></expr></argument>,
					 <argument><expr><operator>(</operator><name>long</name><operator>)</operator> <operator>(</operator><name><name>r</name><operator>.</operator><name>ru_utime</name><operator>.</operator><name>tv_sec</name></name> <operator>-</operator> <name><name>Save_r</name><operator>.</operator><name>ru_utime</name><operator>.</operator><name>tv_sec</name></name><operator>)</operator></expr></argument>,
					 <argument><expr><operator>(</operator><name>long</name><operator>)</operator> <operator>(</operator><name><name>r</name><operator>.</operator><name>ru_utime</name><operator>.</operator><name>tv_usec</name></name> <operator>-</operator> <name><name>Save_r</name><operator>.</operator><name>ru_utime</name><operator>.</operator><name>tv_usec</name></name><operator>)</operator></expr></argument>,
					 <argument><expr><operator>(</operator><name>long</name><operator>)</operator> <operator>(</operator><name><name>r</name><operator>.</operator><name>ru_stime</name><operator>.</operator><name>tv_sec</name></name> <operator>-</operator> <name><name>Save_r</name><operator>.</operator><name>ru_stime</name><operator>.</operator><name>tv_sec</name></name><operator>)</operator></expr></argument>,
					 <argument><expr><operator>(</operator><name>long</name><operator>)</operator> <operator>(</operator><name><name>r</name><operator>.</operator><name>ru_stime</name><operator>.</operator><name>tv_usec</name></name> <operator>-</operator> <name><name>Save_r</name><operator>.</operator><name>ru_stime</name><operator>.</operator><name>tv_usec</name></name><operator>)</operator></expr></argument>,
					 <argument><expr><operator>(</operator><name>long</name><operator>)</operator> <operator>(</operator><name><name>elapse_t</name><operator>.</operator><name>tv_sec</name></name> <operator>-</operator> <name><name>Save_t</name><operator>.</operator><name>tv_sec</name></name><operator>)</operator></expr></argument>,
					 <argument><expr><operator>(</operator><name>long</name><operator>)</operator> <operator>(</operator><name><name>elapse_t</name><operator>.</operator><name>tv_usec</name></name> <operator>-</operator> <name><name>Save_t</name><operator>.</operator><name>tv_usec</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>str</name></expr></argument>,
					 <argument><expr><literal type="string">"!\t[%ld.%06ld s user, %ld.%06ld s system total]\n"</literal></expr></argument>,
					 <argument><expr><operator>(</operator><name>long</name><operator>)</operator> <name><name>user</name><operator>.</operator><name>tv_sec</name></name></expr></argument>,
					 <argument><expr><operator>(</operator><name>long</name><operator>)</operator> <name><name>user</name><operator>.</operator><name>tv_usec</name></name></expr></argument>,
					 <argument><expr><operator>(</operator><name>long</name><operator>)</operator> <name><name>sys</name><operator>.</operator><name>tv_sec</name></name></expr></argument>,
					 <argument><expr><operator>(</operator><name>long</name><operator>)</operator> <name><name>sys</name><operator>.</operator><name>tv_usec</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_GETRUSAGE</name></expr></argument>)</argument_list></call></expr></cpp:if>
	<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>str</name></expr></argument>,
					 <argument><expr><literal type="string">"!\t%ld kB max resident size\n"</literal></expr></argument>,
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__darwin__</name></expr></argument>)</argument_list></call></expr></cpp:if>
	<comment type="block">/* in bytes on macOS */</comment>
					 <argument><expr><name><name>r</name><operator>.</operator><name>ru_maxrss</name></name> <operator>/</operator> <literal type="number">1024</literal>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	<comment type="block">/* in kilobytes on most other platforms */</comment>
					 <name><name>r</name><operator>.</operator><name>ru_maxrss</name></name></expr></argument>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
		)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>str</name></expr></argument>,
					 <argument><expr><literal type="string">"!\t%ld/%ld [%ld/%ld] filesystem blocks in/out\n"</literal></expr></argument>,
					 <argument><expr><name><name>r</name><operator>.</operator><name>ru_inblock</name></name> <operator>-</operator> <name><name>Save_r</name><operator>.</operator><name>ru_inblock</name></name></expr></argument>,
	<comment type="block">/* they only drink coffee at dec */</comment>
					 <argument><expr><name><name>r</name><operator>.</operator><name>ru_oublock</name></name> <operator>-</operator> <name><name>Save_r</name><operator>.</operator><name>ru_oublock</name></name></expr></argument>,
					 <argument><expr><name><name>r</name><operator>.</operator><name>ru_inblock</name></name></expr></argument>, <argument><expr><name><name>r</name><operator>.</operator><name>ru_oublock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>str</name></expr></argument>,
					 <argument><expr><literal type="string">"!\t%ld/%ld [%ld/%ld] page faults/reclaims, %ld [%ld] swaps\n"</literal></expr></argument>,
					 <argument><expr><name><name>r</name><operator>.</operator><name>ru_majflt</name></name> <operator>-</operator> <name><name>Save_r</name><operator>.</operator><name>ru_majflt</name></name></expr></argument>,
					 <argument><expr><name><name>r</name><operator>.</operator><name>ru_minflt</name></name> <operator>-</operator> <name><name>Save_r</name><operator>.</operator><name>ru_minflt</name></name></expr></argument>,
					 <argument><expr><name><name>r</name><operator>.</operator><name>ru_majflt</name></name></expr></argument>, <argument><expr><name><name>r</name><operator>.</operator><name>ru_minflt</name></name></expr></argument>,
					 <argument><expr><name><name>r</name><operator>.</operator><name>ru_nswap</name></name> <operator>-</operator> <name><name>Save_r</name><operator>.</operator><name>ru_nswap</name></name></expr></argument>,
					 <argument><expr><name><name>r</name><operator>.</operator><name>ru_nswap</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>str</name></expr></argument>,
					 <argument><expr><literal type="string">"!\t%ld [%ld] signals rcvd, %ld/%ld [%ld/%ld] messages rcvd/sent\n"</literal></expr></argument>,
					 <argument><expr><name><name>r</name><operator>.</operator><name>ru_nsignals</name></name> <operator>-</operator> <name><name>Save_r</name><operator>.</operator><name>ru_nsignals</name></name></expr></argument>,
					 <argument><expr><name><name>r</name><operator>.</operator><name>ru_nsignals</name></name></expr></argument>,
					 <argument><expr><name><name>r</name><operator>.</operator><name>ru_msgrcv</name></name> <operator>-</operator> <name><name>Save_r</name><operator>.</operator><name>ru_msgrcv</name></name></expr></argument>,
					 <argument><expr><name><name>r</name><operator>.</operator><name>ru_msgsnd</name></name> <operator>-</operator> <name><name>Save_r</name><operator>.</operator><name>ru_msgsnd</name></name></expr></argument>,
					 <argument><expr><name><name>r</name><operator>.</operator><name>ru_msgrcv</name></name></expr></argument>, <argument><expr><name><name>r</name><operator>.</operator><name>ru_msgsnd</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>str</name></expr></argument>,
					 <argument><expr><literal type="string">"!\t%ld/%ld [%ld/%ld] voluntary/involuntary context switches\n"</literal></expr></argument>,
					 <argument><expr><name><name>r</name><operator>.</operator><name>ru_nvcsw</name></name> <operator>-</operator> <name><name>Save_r</name><operator>.</operator><name>ru_nvcsw</name></name></expr></argument>,
					 <argument><expr><name><name>r</name><operator>.</operator><name>ru_nivcsw</name></name> <operator>-</operator> <name><name>Save_r</name><operator>.</operator><name>ru_nivcsw</name></name></expr></argument>,
					 <argument><expr><name><name>r</name><operator>.</operator><name>ru_nvcsw</name></name></expr></argument>, <argument><expr><name><name>r</name><operator>.</operator><name>ru_nivcsw</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>							<comment type="block">/* HAVE_GETRUSAGE */</comment>

	<comment type="block">/* remove trailing newline */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>str</name><operator>.</operator><name>data</name><index>[<expr><name><name>str</name><operator>.</operator><name>len</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'\n'</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>str</name><operator>.</operator><name>data</name><index>[<expr><operator>--</operator><name><name>str</name><operator>.</operator><name>len</name></name></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
			<argument><expr><operator>(</operator><call><name>errmsg_internal</name><argument_list>(<argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name>title</name></expr></argument>)</argument_list></call><operator>,</operator>
			 <call><name>errdetail_internal</name><argument_list>(<argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name><name>str</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>str</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * on_proc_exit handler to log end of session
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>log_disconnections</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>code</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Port</name>	   <modifier>*</modifier></type><name>port</name> <init>= <expr><name>MyProcPort</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>long</name></type>		<name>secs</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>usecs</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>msecs</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>hours</name></decl>,
				<decl><type ref="prev"/><name>minutes</name></decl>,
				<decl><type ref="prev"/><name>seconds</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>TimestampDifference</name><argument_list>(<argument><expr><name><name>port</name><operator>-&gt;</operator><name>SessionStartTime</name></name></expr></argument>,
						<argument><expr><call><name>GetCurrentTimestamp</name><argument_list>()</argument_list></call></expr></argument>,
						<argument><expr><operator>&amp;</operator><name>secs</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>usecs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>msecs</name> <operator>=</operator> <name>usecs</name> <operator>/</operator> <literal type="number">1000</literal></expr>;</expr_stmt>

	<expr_stmt><expr><name>hours</name> <operator>=</operator> <name>secs</name> <operator>/</operator> <name>SECS_PER_HOUR</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>secs</name> <operator>%=</operator> <name>SECS_PER_HOUR</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>minutes</name> <operator>=</operator> <name>secs</name> <operator>/</operator> <name>SECS_PER_MINUTE</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>seconds</name> <operator>=</operator> <name>secs</name> <operator>%</operator> <name>SECS_PER_MINUTE</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
			<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"disconnection: session time: %d:%02d:%02d.%03d "</literal>
					<literal type="string">"user=%s database=%s host=%s%s%s"</literal></expr></argument>,
					<argument><expr><name>hours</name></expr></argument>, <argument><expr><name>minutes</name></expr></argument>, <argument><expr><name>seconds</name></expr></argument>, <argument><expr><name>msecs</name></expr></argument>,
					<argument><expr><name><name>port</name><operator>-&gt;</operator><name>user_name</name></name></expr></argument>, <argument><expr><name><name>port</name><operator>-&gt;</operator><name>database_name</name></name></expr></argument>, <argument><expr><name><name>port</name><operator>-&gt;</operator><name>remote_host</name></name></expr></argument>,
					<argument><expr><ternary><condition><expr><name><name>port</name><operator>-&gt;</operator><name>remote_port</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr> ?</condition><then> <expr><literal type="string">" port="</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>, <argument><expr><name><name>port</name><operator>-&gt;</operator><name>remote_port</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>polar_enable_multi_syslogger</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ErrorData</name></type> <name>edata</name></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>POLAR_ERROR_DATA_INIT_FOR_AUDITLOG</name><argument_list>(<argument><expr><name>edata</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>polar_write_audit_log</name><argument_list>(<argument><expr><operator>&amp;</operator><name>edata</name></expr></argument>,
			<argument><expr><literal type="string">"disconnection: session time: %d:%02d:%02d.%03d "</literal>
					<literal type="string">"user=%s database=%s host=%s%s%s"</literal></expr></argument>,
					<argument><expr><name>hours</name></expr></argument>, <argument><expr><name>minutes</name></expr></argument>, <argument><expr><name>seconds</name></expr></argument>, <argument><expr><name>msecs</name></expr></argument>,
					<argument><expr><name><name>port</name><operator>-&gt;</operator><name>user_name</name></name></expr></argument>, <argument><expr><name><name>port</name><operator>-&gt;</operator><name>database_name</name></name></expr></argument>, <argument><expr><name><name>port</name><operator>-&gt;</operator><name>remote_host</name></name></expr></argument>,
					<argument><expr><ternary><condition><expr><name><name>port</name><operator>-&gt;</operator><name>remote_port</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr> ?</condition><then> <expr><literal type="string">" port="</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>, <argument><expr><name><name>port</name><operator>-&gt;</operator><name>remote_port</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Start statement timeout timer, if enabled.
 *
 * If there's already a timeout running, don't restart the timer.  That
 * enables compromises between accuracy of timeouts and cost of starting a
 * timeout.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>enable_statement_timeout</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* must be within an xact */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>xact_started</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>StatementTimeout</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>stmt_timeout_active</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>enable_timeout_after</name><argument_list>(<argument><expr><name>STATEMENT_TIMEOUT</name></expr></argument>, <argument><expr><name>StatementTimeout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>stmt_timeout_active</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>disable_timeout</name><argument_list>(<argument><expr><name>STATEMENT_TIMEOUT</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Disable statement timeout, if active.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>disable_statement_timeout</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>stmt_timeout_active</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>disable_timeout</name><argument_list>(<argument><expr><name>STATEMENT_TIMEOUT</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>stmt_timeout_active</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>polar_stmt_type_needs_mask</name><parameter_list>(<parameter><decl><type><name>NodeTag</name></type> <name>tag</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<switch>switch <condition>(<expr><name>tag</name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>T_CreateRoleStmt</name></expr>:</case>
		<case>case <expr><name>T_AlterRoleStmt</name></expr>:</case>
		<case>case <expr><name>T_AlterRoleSetStmt</name></expr>:</case>
		<case>case <expr><name>T_CreateForeignServerStmt</name></expr>:</case>
		<case>case <expr><name>T_AlterForeignServerStmt</name></expr>:</case>
		<case>case <expr><name>T_CreateUserMappingStmt</name></expr>:</case>
		<case>case <expr><name>T_AlterUserMappingStmt</name></expr>:</case>
			<return>return <expr><name>true</name></expr>;</return>
		<default>default:</default>
			<break>break;</break>
	</block_content>}</block></switch>

	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * polar_get_errmsg_params
 *
 * get errmsg params in error log and audit log.
 */</comment>
<function><type><specifier>static</specifier> <name>char</name><modifier>*</modifier></type>
<name>polar_get_errmsg_params</name><parameter_list>(<parameter><decl><type><name>ParamListInfo</name></type> <name>params</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* We mustn't call user-defined I/O functions when in an aborted xact */</comment>
	<if_stmt><if>if <condition>(<expr><name>params</name> <operator>&amp;&amp;</operator> <name><name>params</name><operator>-&gt;</operator><name>numParams</name></name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>IsAbortedTransactionBlockState</name><argument_list>()</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>StringInfoData</name></type> <name>param_str</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>paramno</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>initStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>param_str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<for>for <control>(<init><expr><name>paramno</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>paramno</name> <operator>&lt;</operator> <name><name>params</name><operator>-&gt;</operator><name>numParams</name></name></expr>;</condition> <incr><expr><name>paramno</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>ParamExternData</name> <modifier>*</modifier></type><name>prm</name> <init>= <expr><operator>&amp;</operator><name><name>params</name><operator>-&gt;</operator><name>params</name><index>[<expr><name>paramno</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Oid</name></type>			<name>typoutput</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>bool</name></type>		<name>typisvarlena</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>pstring</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>param_str</name></expr></argument>, <argument><expr><literal type="string">"%s$%d = "</literal></expr></argument>,
							 <argument><expr><ternary><condition><expr><name>paramno</name> <operator>&gt;</operator> <literal type="number">0</literal></expr> ?</condition><then> <expr><literal type="string">", "</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>,
							 <argument><expr><name>paramno</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>prm</name><operator>-&gt;</operator><name>isnull</name></name> <operator>||</operator> <operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>prm</name><operator>-&gt;</operator><name>ptype</name></name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>param_str</name></expr></argument>, <argument><expr><literal type="string">"NULL"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<continue>continue;</continue>
			</block_content>}</block></if></if_stmt>

			<expr_stmt><expr><call><name>getTypeOutputInfo</name><argument_list>(<argument><expr><name><name>prm</name><operator>-&gt;</operator><name>ptype</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>typoutput</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>typisvarlena</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name>pstring</name> <operator>=</operator> <call><name>OidOutputFunctionCall</name><argument_list>(<argument><expr><name>typoutput</name></expr></argument>, <argument><expr><name><name>prm</name><operator>-&gt;</operator><name>value</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>appendStringInfoCharMacro</name><argument_list>(<argument><expr><operator>&amp;</operator><name>param_str</name></expr></argument>, <argument><expr><literal type="char">'\''</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<for>for <control>(<init><expr><name>p</name> <operator>=</operator> <name>pstring</name></expr>;</init> <condition><expr><operator>*</operator><name>p</name></expr>;</condition> <incr><expr><name>p</name><operator>++</operator></expr></incr>)</control>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><operator>*</operator><name>p</name> <operator>==</operator> <literal type="char">'\''</literal></expr>)</condition><block type="pseudo"><block_content> <comment type="block">/* double single quotes */</comment>
					<expr_stmt><expr><call><name>appendStringInfoCharMacro</name><argument_list>(<argument><expr><operator>&amp;</operator><name>param_str</name></expr></argument>, <argument><expr><operator>*</operator><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<expr_stmt><expr><call><name>appendStringInfoCharMacro</name><argument_list>(<argument><expr><operator>&amp;</operator><name>param_str</name></expr></argument>, <argument><expr><operator>*</operator><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></for>
			<expr_stmt><expr><call><name>appendStringInfoCharMacro</name><argument_list>(<argument><expr><operator>&amp;</operator><name>param_str</name></expr></argument>, <argument><expr><literal type="char">'\''</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>pstring</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></for>

		<return>return <expr><name><name>param_str</name><operator>.</operator><name>data</name></name></expr>;</return>

	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * POlAR: cancel signal from rds OOM cancel signal,abort transaction
 * and exit at soonest convenient time
 * when process is out of memory, we will send sigusr2 signal
 * to cancel-query this process
 */</comment>
<function><type><name>void</name></type>
<name>polar_procsignal_sigusr2_handler</name><parameter_list>(<parameter><decl><type><name>SIGNAL_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><name>got_oom_cancel_signal</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SigCancelQueryHandler</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* polar: Signal handler for program errors */</comment>
<function><type><name>void</name></type>
<name>polar_program_error_handler</name><parameter_list>(<parameter><decl><type><name>SIGNAL_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>PG_SETMASK</name><argument_list>(<argument><expr><operator>&amp;</operator><name>BlockSig</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Unblock SEGV/BUS/ILL signals, and set them to their default settings. */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SIGILL</name></cpp:ifdef>
	<expr_stmt><expr><call><name>pqsignal</name><argument_list>(<argument><expr><name>SIGILL</name></expr></argument>, <argument><expr><name>SIG_DFL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SIGSEGV</name></cpp:ifdef>
	<expr_stmt><expr><call><name>pqsignal</name><argument_list>(<argument><expr><name>SIGSEGV</name></expr></argument>, <argument><expr><name>SIG_DFL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SIGBUS</name></cpp:ifdef>
	<expr_stmt><expr><call><name>pqsignal</name><argument_list>(<argument><expr><name>SIGBUS</name></expr></argument>, <argument><expr><name>SIG_DFL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<comment type="block">/* enable coredump clear */</comment>
	<if_stmt><if>if <condition>(<expr><name>polar_enable_coredump_handler</name> <operator>&amp;</operator> <name>CORE_DUMP_PRINT_MASK</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>polar_save_stack_info</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* normal coredump */</comment>
	<expr_stmt><expr><call><name>raise</name><argument_list>(<argument><expr><name>postgres_signal_arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<comment type="block">/* polar: end */</comment>

<comment type="block">/*
 * POLAR: signal handler for coredump signals (SEGV/BUS/ILL)
 * 1. save stack info to core-tmp file
 * After that, generate system core file.
 */</comment>

<comment type="block">/* POLAR: save stack info to core-tmp file */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>polar_save_stack_info</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>StackInfoOnDisk</name></type> <name>stack_info</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name><name>stack_traces</name><index>[<expr><name>POLAR_MAX_STACK_FRAMES</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type> <name><name>polar_core_file</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name> <init>= <expr><block>{<expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>fd</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>trace_size</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<comment type="block">/* get stack info */</comment>
	<expr_stmt><expr><name>trace_size</name> <operator>=</operator> <call><name>backtrace</name><argument_list>(<argument><expr><name>stack_traces</name></expr></argument>, <argument><expr><name>POLAR_MAX_STACK_FRAMES</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>stack_info</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>stack_info</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>stack_info</name><operator>.</operator><name>stack_size</name></name> <operator>=</operator> <name>trace_size</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>stack_info</name><operator>.</operator><name>magic_number</name></name> <operator>=</operator> <name>POLAR_CORE_MAGIC_NUMBER</name></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>trace_size</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><name><name>stack_info</name><operator>.</operator><name>stack_traces</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>stack_traces</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
	</block_content>}</block></for>

	<comment type="block">/* write info to disk */</comment>
	<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>polar_core_file</name></expr></argument>, <argument><expr><name>MAXPGPATH</name></expr></argument>, <argument><expr><literal type="string">"%s_%d.tmp"</literal></expr></argument>, <argument><expr><name>POLAR_CORE_DUMP_FILE_SUFFIX</name></expr></argument>, <argument><expr><name>MyProcPid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>fd</name> <operator>=</operator> <call><name>open</name><argument_list>(<argument><expr><name>polar_core_file</name></expr></argument>, <argument><expr><name>O_CREAT</name> <operator>|</operator> <name>O_WRONLY</name> <operator>|</operator> <name>PG_BINARY</name></expr></argument>, <argument><expr><name>pg_file_create_mode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>fd</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><call><name>write</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>stack_info</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>stack_info</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>stack_info</name></expr></argument>)</argument_list></sizeof></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return ;</return>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* POLAR: audit log flush callback */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>polar_audit_log_flush_callback</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>code</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>polar_audit_log_buffer_is_null</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>polar_audit_log_flush</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<return>return ;</return>
</block_content>}</block></function>

<comment type="block">/* POLAR: wait for replay in dml */</comment>
<function><type><name>void</name></type>
<name>polar_delay_dml_wait</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>polar_enable_shared_storage_mode</name> <operator>&amp;&amp;</operator>
	    <operator>!</operator><name>polar_mount_pfs_readonly_mode</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>InRecovery</name> <operator>&amp;&amp;</operator>
	    <name>polar_primary_dml_delay</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>polar_delay_dml_lsn_lag_threshold</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
	    <call><name>polar_get_diff_consistent_oldest_lsn</name><argument_list>()</argument_list></call> <operator>/</operator> <literal type="number">1024</literal> <operator>&gt;</operator> <name>polar_delay_dml_lsn_lag_threshold</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>polar_update_delay_dml_count</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>WaitLatch</name><argument_list>(<argument><expr><name>MyLatch</name></expr></argument>, <argument><expr><name>WL_LATCH_SET</name> <operator>|</operator> <name>WL_TIMEOUT</name> <operator>|</operator> <name>WL_POSTMASTER_DEATH</name></expr></argument>,
			<argument><expr><name>polar_primary_dml_delay</name></expr></argument> <comment type="block">/* ms */</comment>, <argument><expr><name>WAIT_EVENT_DELAY_DML</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * POLAR: get runable_log from soureText and paramList.
 */</comment>
<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type>
<name>polar_bind_sql_with_parameter</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type> <name>stmt_name</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>ParamListInfo</name></type> <name>params</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>sourceText</name></decl></parameter>)</parameter_list> 
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>pos</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>	<name>paramno</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PreparedStatement</name> <modifier>*</modifier></type><name>pstmt</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CachedPlanSource</name>  <modifier>*</modifier></type><name>psrc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>StringInfoData</name></type> <name>result</name></decl>;</decl_stmt>

	<comment type="block">/* Assert params is not NULL */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>params</name> <operator>||</operator> <name><name>params</name><operator>-&gt;</operator><name>numParams</name></name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <call><name>IsAbortedTransactionBlockState</name><argument_list>()</argument_list></call> <operator>||</operator> <name>sourceText</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
		<return>return <expr><name>NULL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Find prepared statement */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>stmt_name</name></expr></argument>, <argument><expr><literal type="string">"&lt;unnamed&gt;"</literal></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>pstmt</name> <operator>=</operator> <call><name>FetchPreparedStatement</name><argument_list>(<argument><expr><name>stmt_name</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Assert pstmt is not NULL */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>pstmt</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>psrc</name> <operator>=</operator> <name><name>pstmt</name><operator>-&gt;</operator><name>plansource</name></name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* special-case the unnamed statement */</comment>
		<expr_stmt><expr><name>psrc</name> <operator>=</operator> <name>unnamed_stmt_psrc</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/* 
     * Assert plansource not empty 
	 * Assert param_location is valid
	 * Assert num_param is equal in plansource and paramlistinfo
	 */</comment> 
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>psrc</name> <operator>||</operator> <operator>!</operator><name><name>psrc</name><operator>-&gt;</operator><name>param_location</name></name><operator>||</operator> <name><name>psrc</name><operator>-&gt;</operator><name>num_params</name></name> <operator>!=</operator> <name><name>params</name><operator>-&gt;</operator><name>numParams</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* initialize result and pattern string */</comment>
	<expr_stmt><expr><call><name>initStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* add each parameter for SQL */</comment>
	<for>for <control>(<init><expr><name>paramno</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>paramno</name> <operator>&lt;</operator> <name><name>params</name><operator>-&gt;</operator><name>numParams</name></name></expr>;</condition> <incr><expr><name>paramno</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>	<name>offset</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type> <name>param_truth</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type> <name>param_length</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>symbol_length</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type>	<name>typoutput</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name>	<modifier>*</modifier></type><name>pstring</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>	<name>typisvarlena</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

		<comment type="block">/* find parameter like $1, $2 ... etc. */</comment>
		<decl_stmt><decl><type><name>ParamExternData</name> <modifier>*</modifier></type><name>prm</name> <init>= <expr><operator>&amp;</operator><name><name>params</name><operator>-&gt;</operator><name>params</name><index>[<expr><name>paramno</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

		<comment type="block">/* merge soureText and paraText into result text */</comment>
		<expr_stmt><expr><name>offset</name> <operator>=</operator> <name><name>psrc</name><operator>-&gt;</operator><name>param_location</name><index>[<expr><name>paramno</name></expr>]</index></name> <operator>-</operator> <name>pos</name></expr>;</expr_stmt>

		<comment type="block">/* Assert last postion is always large than prior position */</comment>
		<if_stmt><if>if<condition>(<expr><name>offset</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

		<comment type="block">/* pass the statement clause */</comment>
		<expr_stmt><expr><call><name>appendBinaryStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>result</name></expr></argument>, <argument><expr><name>sourceText</name> <operator>+</operator> <name>pos</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* pass the parameter clause */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>prm</name><operator>-&gt;</operator><name>isnull</name></name> <operator>&amp;&amp;</operator> <call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>prm</name><operator>-&gt;</operator><name>ptype</name></name></expr></argument>)</argument_list></call></expr>)</condition> 
		<block>{<block_content>
			<decl_stmt><decl><type><name>char</name><modifier>*</modifier></type> <name>cover_pattern</name> <init>= <expr><literal type="string">"\'"</literal></expr></init></decl>;</decl_stmt>
			<switch>switch <condition>(<expr><name><name>prm</name><operator>-&gt;</operator><name>ptype</name></name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* common case cover with \' */</comment>
				<case>case <expr><name>BOOLOID</name></expr>:</case>
				<case>case <expr><name>BYTEAOID</name></expr>:</case>
				<case>case <expr><name>CHAROID</name></expr>:</case>
				<case>case <expr><name>NAMEOID</name></expr>:</case>
				<case>case <expr><name>INT8OID</name></expr>:</case>
				<case>case <expr><name>INT2OID</name></expr>:</case>
				<case>case <expr><name>INT4OID</name></expr>:</case>
				<case>case <expr><name>TEXTOID</name></expr>:</case>
				<case>case <expr><name>OIDOID</name></expr>:</case>
				<case>case <expr><name>FLOAT4OID</name></expr>:</case>
				<case>case <expr><name>FLOAT8OID</name></expr>:</case>
				<case>case <expr><name>BPCHAROID</name></expr>:</case>
				<case>case <expr><name>VARCHAROID</name></expr>:</case>
				<case>case <expr><name>DATEOID</name></expr>:</case>
				<case>case <expr><name>TIMEOID</name></expr>:</case>
				<case>case <expr><name>TIMETZOID</name></expr>:</case>
				<case>case <expr><name>NUMERICOID</name></expr>:</case>
				<case>case <expr><name>CIDROID</name></expr>:</case>
				<case>case <expr><name>INETOID</name></expr>:</case>
				<case>case <expr><name>MACADDROID</name></expr>:</case>
				<case>case <expr><name>TIMESTAMPOID</name></expr>:</case>
				<case>case <expr><name>TIMESTAMPTZOID</name></expr>:</case>
				<case>case <expr><name>INTERVALOID</name></expr>:</case>
				<case>case <expr><name>POINTOID</name></expr>:</case>
				<case>case <expr><name>LSEGOID</name></expr>:</case>
				<case>case <expr><name>BOXOID</name></expr>:</case>
				<case>case <expr><name>PATHOID</name></expr>:</case>
				<case>case <expr><name>POLYGONOID</name></expr>:</case>
				<case>case <expr><name>CIRCLEOID</name></expr>:</case>
				<case>case <expr><name>BITOID</name></expr>:</case>
				<case>case <expr><name>VARBITOID</name></expr>:</case>
				<case>case <expr><name>UUIDOID</name></expr>:</case>
				<case>case <expr><name>CASHOID</name></expr>:</case>
					<break>break;</break>
				<comment type="block">/* unkown case cover with $$ */</comment>
				<default>default:</default>
					<expr_stmt><expr><name>cover_pattern</name> <operator>=</operator> <literal type="string">"$$"</literal></expr>;</expr_stmt>
					<break>break;</break>
			</block_content>}</block></switch>
			<expr_stmt><expr><call><name>getTypeOutputInfo</name><argument_list>(<argument><expr><name><name>prm</name><operator>-&gt;</operator><name>ptype</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>typoutput</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>typisvarlena</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>pstring</name> <operator>=</operator> <call><name>OidOutputFunctionCall</name><argument_list>(<argument><expr><name>typoutput</name></expr></argument>, <argument><expr><name><name>prm</name><operator>-&gt;</operator><name>value</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>result</name></expr></argument>, <argument><expr><name>cover_pattern</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>result</name></expr></argument>, <argument><expr><name>pstring</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>result</name></expr></argument>, <argument><expr><name>cover_pattern</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>pstring</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if> <else>else <block>{<block_content>
			<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>result</name></expr></argument>, <argument><expr><literal type="string">"NULL"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<comment type="block">/* get the legnth of $num */</comment>
		<expr_stmt><expr><name>param_truth</name> <operator>=</operator> <name>paramno</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>param_truth</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>param_truth</name> <operator>&lt;</operator> <literal type="number">10</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>param_length</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><name>param_truth</name> <operator>&gt;=</operator> <literal type="number">10</literal> <operator>&amp;&amp;</operator> <name>param_truth</name> <operator>&lt;</operator> <literal type="number">100</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>param_length</name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><name>param_truth</name> <operator>&gt;=</operator> <literal type="number">100</literal> <operator>&amp;&amp;</operator> <name>param_truth</name> <operator>&lt;</operator> <literal type="number">1000</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>param_length</name> <operator>=</operator> <literal type="number">3</literal></expr>;</expr_stmt></block_content></block></if>
		<else>else 
		<block>{<block_content>
			<while>while <condition>(<expr><name>param_truth</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>param_truth</name> <operator>/=</operator> <literal type="number">10</literal></expr>;</expr_stmt>
				<expr_stmt><expr><name>param_length</name><operator>++</operator></expr>;</expr_stmt>
			</block_content>}</block></while>
		</block_content>}</block></else></if_stmt>

		<comment type="block">/* get the next copy start position */</comment>
		<expr_stmt><expr><name>pos</name> <operator>=</operator> <name><name>psrc</name><operator>-&gt;</operator><name>param_location</name><index>[<expr><name>paramno</name></expr>]</index></name> <operator>+</operator> <name>param_length</name> <operator>+</operator> <name>symbol_length</name></expr>;</expr_stmt>
	</block_content>}</block></for>

	<comment type="block">/* merge the last part of sourceText */</comment>
	<if_stmt><if>if<condition>(<expr><name>pos</name> <operator>&lt;=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>sourceText</name></expr></argument>)</argument_list></call> <operator>-</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content> 
		<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>result</name></expr></argument>, <argument><expr><name>sourceText</name> <operator>+</operator> <name>pos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name><name>result</name><operator>.</operator><name>data</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * POLAR px
 * exec_px_query
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres_px.c"</cpp:file></cpp:include>

<comment type="block">/* 
 * POLAR: process cancel query request during client read/write
 * in original way, cancel query requests are all ignored during client read/write,
 * which is not appropriate. for example, if a query which generated recovery conflict 
 * can't be canceled when it is reading from/writing to client, the recovery process of 
 * startup will be delay infinitely by a stuck client. Improve it in this way:
 * 1) if cancel query request is from db itself, then we handle it right now, and cancel request
 * is treated as a terminate request, connection will be terminated;
 * 2) if cancel query request is from client, then we ignore it as original way, client needs
 * to send a termiante request to cancel it truly.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>polar_process_client_readwrite_cancel_interrupt</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type>		<name>handle_cancel_request</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>stmt_timeout_occurred</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>stmt_timeout_occurred</name> <operator>=</operator> <call><name>get_timeout_indicator</name><argument_list>(<argument><expr><name>STATEMENT_TIMEOUT</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	
	<comment type="block">/* cancel request need to be handled */</comment>
	<if_stmt><if>if <condition>(<expr><name>stmt_timeout_occurred</name> <operator>||</operator> <name>RecoveryConflictPending</name> <operator>||</operator> <name>got_oom_cancel_signal</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>handle_cancel_request</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* treat cancel request as terminate request */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>ProcDiePending</name> <operator>&amp;&amp;</operator> <name>QueryCancelPending</name> <operator>&amp;&amp;</operator> <name>handle_cancel_request</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>ProcDiePending</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>
<comment type="block">/* POLAR end */</comment></unit>
