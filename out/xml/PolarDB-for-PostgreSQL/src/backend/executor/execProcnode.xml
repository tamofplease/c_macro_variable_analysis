<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/PolarDB-for-PostgreSQL/src/backend/executor/execProcnode.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * execProcnode.c
 *	 contains dispatch functions which call the appropriate "initialize",
 *	 "get a tuple", and "cleanup" routines for the given node type.
 *	 If the node has children, then it will presumably call ExecInitNode,
 *	 ExecProcNode, or ExecEndNode on its subnodes and do the appropriate
 *	 processing.
 *
 * Portions Copyright (c) 1996-2018, PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, Regents of the University of California
 *
 *
 * IDENTIFICATION
 *	  src/backend/executor/execProcnode.c
 *
 *-------------------------------------------------------------------------
 */</comment>
<comment type="block">/*
 *	 NOTES
 *		This used to be three files.  It is now all combined into
 *		one file so that it is easier to keep the dispatch routines
 *		in sync when new nodes are added.
 *
 *	 EXAMPLE
 *		Suppose we want the age of the manager of the shoe department and
 *		the number of employees in that department.  So we have the query:
 *
 *				select DEPT.no_emps, EMP.age
 *				from DEPT, EMP
 *				where EMP.name = DEPT.mgr and
 *					  DEPT.name = "shoe"
 *
 *		Suppose the planner gives us the following plan:
 *
 *						Nest Loop (DEPT.mgr = EMP.name)
 *						/		\
 *					   /		 \
 *				   Seq Scan		Seq Scan
 *					DEPT		  EMP
 *				(name = "shoe")
 *
 *		ExecutorStart() is called first.
 *		It calls InitPlan() which calls ExecInitNode() on
 *		the root of the plan -- the nest loop node.
 *
 *	  * ExecInitNode() notices that it is looking at a nest loop and
 *		as the code below demonstrates, it calls ExecInitNestLoop().
 *		Eventually this calls ExecInitNode() on the right and left subplans
 *		and so forth until the entire plan is initialized.  The result
 *		of ExecInitNode() is a plan state tree built with the same structure
 *		as the underlying plan tree.
 *
 *	  * Then when ExecutorRun() is called, it calls ExecutePlan() which calls
 *		ExecProcNode() repeatedly on the top node of the plan state tree.
 *		Each time this happens, ExecProcNode() will end up calling
 *		ExecNestLoop(), which calls ExecProcNode() on its subplans.
 *		Each of these subplans is a sequential scan so ExecSeqScan() is
 *		called.  The slots returned by ExecSeqScan() may contain
 *		tuples which contain the attributes ExecNestLoop() uses to
 *		form the tuples it returns.
 *
 *	  * Eventually ExecSeqScan() stops returning tuples and the nest
 *		loop join ends.  Lastly, ExecutorEnd() calls ExecEndNode() which
 *		calls ExecEndNestLoop() which in turn calls ExecEndNode() on
 *		its subplans which result in ExecEndSeqScan().
 *
 *		This should show how the executor works by having
 *		ExecInitNode(), ExecProcNode() and ExecEndNode() dispatch
 *		their work to the appropriate node support routines which may
 *		in turn call these routines themselves on their subplans.
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/executor.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/nodeAgg.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/nodeAppend.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/nodeBitmapAnd.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/nodeBitmapHeapscan.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/nodeBitmapIndexscan.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/nodeBitmapOr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/nodeCtescan.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/nodeCustom.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/nodeForeignscan.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/nodeFunctionscan.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/nodeGather.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/nodeGatherMerge.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/nodeGroup.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/nodeHash.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/nodeHashjoin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/nodeIndexonlyscan.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/nodeIndexscan.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/nodeLimit.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/nodeLockRows.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/nodeMaterial.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/nodeMergeAppend.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/nodeMergejoin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/nodeModifyTable.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/nodeNamedtuplestorescan.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/nodeNestloop.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/nodeProjectSet.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/nodeRecursiveunion.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/nodeResult.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/nodeSamplescan.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/nodeSeqscan.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/nodeSetOp.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/nodeSort.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/nodeSubplan.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/nodeSubqueryscan.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/nodeTableFuncscan.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/nodeTidscan.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/nodeUnique.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/nodeValuesscan.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/nodeWindowAgg.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/nodeWorktablescan.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/nodeFuncs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>
<comment type="block">/* POLAR: include the head file */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/polar_exec_procnode.h"</cpp:file></cpp:include>
<comment type="block">/* POLAR px */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/nodeAssertOp.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/nodeMotion_px.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/nodeSequence.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/nodeShareInputScan.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/nodePartitionSelector.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/nodeSplitUpdate.h"</cpp:file></cpp:include>

<function_decl><type><specifier>static</specifier> <name>TupleTableSlot</name> <modifier>*</modifier></type><name>ExecProcNodeFirst</name><parameter_list>(<parameter><decl><type><name>PlanState</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>TupleTableSlot</name> <modifier>*</modifier></type><name>ExecProcNodeInstr</name><parameter_list>(<parameter><decl><type><name>PlanState</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>;</function_decl>


<comment type="block">/* ------------------------------------------------------------------------
 *		ExecInitNode
 *
 *		Recursively initializes all the nodes in the plan tree rooted
 *		at 'node'.
 *
 *		Inputs:
 *		  'node' is the current node of the plan produced by the query planner
 *		  'estate' is the shared execution state for the plan tree
 *		  'eflags' is a bitwise OR of flag bits described in executor.h
 *
 *		Returns a PlanState node corresponding to the given Plan node.
 * ------------------------------------------------------------------------
 */</comment>
<function><type><name>PlanState</name> <modifier>*</modifier></type>
<name>ExecInitNode</name><parameter_list>(<parameter><decl><type><name>Plan</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>EState</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>eflags</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PlanState</name>  <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>subps</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * do nothing when we get to the end of a leaf on tree.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>node</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Make sure there's enough stack available. Need to check here, in
	 * addition to ExecProcNode() (via ExecProcNodeFirst()), to ensure the
	 * stack isn't overrun while initializing the node tree.
	 */</comment>
	<expr_stmt><expr><call><name>check_stack_depth</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<switch>switch <condition>(<expr><call><name>nodeTag</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
			<comment type="block">/*
			 * control nodes
			 */</comment>
		<case>case <expr><name>T_Result</name></expr>:</case>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>PlanState</name> <operator>*</operator><operator>)</operator> <call><name>ExecInitResult</name><argument_list>(<argument><expr><operator>(</operator><name>Result</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>,
												  <argument><expr><name>estate</name></expr></argument>, <argument><expr><name>eflags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_ProjectSet</name></expr>:</case>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>PlanState</name> <operator>*</operator><operator>)</operator> <call><name>ExecInitProjectSet</name><argument_list>(<argument><expr><operator>(</operator><name>ProjectSet</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>,
													  <argument><expr><name>estate</name></expr></argument>, <argument><expr><name>eflags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_ModifyTable</name></expr>:</case>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>PlanState</name> <operator>*</operator><operator>)</operator> <call><name>ExecInitModifyTable</name><argument_list>(<argument><expr><operator>(</operator><name>ModifyTable</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>,
													   <argument><expr><name>estate</name></expr></argument>, <argument><expr><name>eflags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_Append</name></expr>:</case>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>PlanState</name> <operator>*</operator><operator>)</operator> <call><name>ExecInitAppend</name><argument_list>(<argument><expr><operator>(</operator><name>Append</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>,
												  <argument><expr><name>estate</name></expr></argument>, <argument><expr><name>eflags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<comment type="block">/* POLAR px */</comment>
		<case>case <expr><name>T_Sequence</name></expr>:</case>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>PlanState</name> <operator>*</operator><operator>)</operator> <call><name>ExecInitSequence</name><argument_list>(<argument><expr><operator>(</operator><name>Sequence</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>,
													<argument><expr><name>estate</name></expr></argument>, <argument><expr><name>eflags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_MergeAppend</name></expr>:</case>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>PlanState</name> <operator>*</operator><operator>)</operator> <call><name>ExecInitMergeAppend</name><argument_list>(<argument><expr><operator>(</operator><name>MergeAppend</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>,
													   <argument><expr><name>estate</name></expr></argument>, <argument><expr><name>eflags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_RecursiveUnion</name></expr>:</case>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>PlanState</name> <operator>*</operator><operator>)</operator> <call><name>ExecInitRecursiveUnion</name><argument_list>(<argument><expr><operator>(</operator><name>RecursiveUnion</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>,
														  <argument><expr><name>estate</name></expr></argument>, <argument><expr><name>eflags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_BitmapAnd</name></expr>:</case>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>PlanState</name> <operator>*</operator><operator>)</operator> <call><name>ExecInitBitmapAnd</name><argument_list>(<argument><expr><operator>(</operator><name>BitmapAnd</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>,
													 <argument><expr><name>estate</name></expr></argument>, <argument><expr><name>eflags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_BitmapOr</name></expr>:</case>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>PlanState</name> <operator>*</operator><operator>)</operator> <call><name>ExecInitBitmapOr</name><argument_list>(<argument><expr><operator>(</operator><name>BitmapOr</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>,
													<argument><expr><name>estate</name></expr></argument>, <argument><expr><name>eflags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

			<comment type="block">/*
			 * scan nodes
			 */</comment>
		<case>case <expr><name>T_SeqScan</name></expr>:</case>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>PlanState</name> <operator>*</operator><operator>)</operator> <call><name>ExecInitSeqScan</name><argument_list>(<argument><expr><operator>(</operator><name>SeqScan</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>,
												   <argument><expr><name>estate</name></expr></argument>, <argument><expr><name>eflags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_SampleScan</name></expr>:</case>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>PlanState</name> <operator>*</operator><operator>)</operator> <call><name>ExecInitSampleScan</name><argument_list>(<argument><expr><operator>(</operator><name>SampleScan</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>,
													  <argument><expr><name>estate</name></expr></argument>, <argument><expr><name>eflags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_IndexScan</name></expr>:</case>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>PlanState</name> <operator>*</operator><operator>)</operator> <call><name>ExecInitIndexScan</name><argument_list>(<argument><expr><operator>(</operator><name>IndexScan</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>,
													 <argument><expr><name>estate</name></expr></argument>, <argument><expr><name>eflags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_IndexOnlyScan</name></expr>:</case>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>PlanState</name> <operator>*</operator><operator>)</operator> <call><name>ExecInitIndexOnlyScan</name><argument_list>(<argument><expr><operator>(</operator><name>IndexOnlyScan</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>,
														 <argument><expr><name>estate</name></expr></argument>, <argument><expr><name>eflags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_BitmapIndexScan</name></expr>:</case>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>PlanState</name> <operator>*</operator><operator>)</operator> <call><name>ExecInitBitmapIndexScan</name><argument_list>(<argument><expr><operator>(</operator><name>BitmapIndexScan</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>,
														   <argument><expr><name>estate</name></expr></argument>, <argument><expr><name>eflags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_BitmapHeapScan</name></expr>:</case>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>PlanState</name> <operator>*</operator><operator>)</operator> <call><name>ExecInitBitmapHeapScan</name><argument_list>(<argument><expr><operator>(</operator><name>BitmapHeapScan</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>,
														  <argument><expr><name>estate</name></expr></argument>, <argument><expr><name>eflags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_TidScan</name></expr>:</case>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>PlanState</name> <operator>*</operator><operator>)</operator> <call><name>ExecInitTidScan</name><argument_list>(<argument><expr><operator>(</operator><name>TidScan</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>,
												   <argument><expr><name>estate</name></expr></argument>, <argument><expr><name>eflags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_SubqueryScan</name></expr>:</case>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>PlanState</name> <operator>*</operator><operator>)</operator> <call><name>ExecInitSubqueryScan</name><argument_list>(<argument><expr><operator>(</operator><name>SubqueryScan</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>,
														<argument><expr><name>estate</name></expr></argument>, <argument><expr><name>eflags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_FunctionScan</name></expr>:</case>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>PlanState</name> <operator>*</operator><operator>)</operator> <call><name>ExecInitFunctionScan</name><argument_list>(<argument><expr><operator>(</operator><name>FunctionScan</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>,
														<argument><expr><name>estate</name></expr></argument>, <argument><expr><name>eflags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_TableFuncScan</name></expr>:</case>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>PlanState</name> <operator>*</operator><operator>)</operator> <call><name>ExecInitTableFuncScan</name><argument_list>(<argument><expr><operator>(</operator><name>TableFuncScan</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>,
														 <argument><expr><name>estate</name></expr></argument>, <argument><expr><name>eflags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_ValuesScan</name></expr>:</case>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>PlanState</name> <operator>*</operator><operator>)</operator> <call><name>ExecInitValuesScan</name><argument_list>(<argument><expr><operator>(</operator><name>ValuesScan</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>,
													  <argument><expr><name>estate</name></expr></argument>, <argument><expr><name>eflags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_CteScan</name></expr>:</case>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>PlanState</name> <operator>*</operator><operator>)</operator> <call><name>ExecInitCteScan</name><argument_list>(<argument><expr><operator>(</operator><name>CteScan</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>,
												   <argument><expr><name>estate</name></expr></argument>, <argument><expr><name>eflags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_NamedTuplestoreScan</name></expr>:</case>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>PlanState</name> <operator>*</operator><operator>)</operator> <call><name>ExecInitNamedTuplestoreScan</name><argument_list>(<argument><expr><operator>(</operator><name>NamedTuplestoreScan</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>,
															   <argument><expr><name>estate</name></expr></argument>, <argument><expr><name>eflags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_WorkTableScan</name></expr>:</case>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>PlanState</name> <operator>*</operator><operator>)</operator> <call><name>ExecInitWorkTableScan</name><argument_list>(<argument><expr><operator>(</operator><name>WorkTableScan</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>,
														 <argument><expr><name>estate</name></expr></argument>, <argument><expr><name>eflags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_ForeignScan</name></expr>:</case>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>PlanState</name> <operator>*</operator><operator>)</operator> <call><name>ExecInitForeignScan</name><argument_list>(<argument><expr><operator>(</operator><name>ForeignScan</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>,
													   <argument><expr><name>estate</name></expr></argument>, <argument><expr><name>eflags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_CustomScan</name></expr>:</case>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>PlanState</name> <operator>*</operator><operator>)</operator> <call><name>ExecInitCustomScan</name><argument_list>(<argument><expr><operator>(</operator><name>CustomScan</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>,
													  <argument><expr><name>estate</name></expr></argument>, <argument><expr><name>eflags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

			<comment type="block">/*
			 * join nodes
			 */</comment>
		<case>case <expr><name>T_NestLoop</name></expr>:</case>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>PlanState</name> <operator>*</operator><operator>)</operator> <call><name>ExecInitNestLoop</name><argument_list>(<argument><expr><operator>(</operator><name>NestLoop</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>,
													<argument><expr><name>estate</name></expr></argument>, <argument><expr><name>eflags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_MergeJoin</name></expr>:</case>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>PlanState</name> <operator>*</operator><operator>)</operator> <call><name>ExecInitMergeJoin</name><argument_list>(<argument><expr><operator>(</operator><name>MergeJoin</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>,
													 <argument><expr><name>estate</name></expr></argument>, <argument><expr><name>eflags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_HashJoin</name></expr>:</case>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>PlanState</name> <operator>*</operator><operator>)</operator> <call><name>ExecInitHashJoin</name><argument_list>(<argument><expr><operator>(</operator><name>HashJoin</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>,
													<argument><expr><name>estate</name></expr></argument>, <argument><expr><name>eflags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<comment type="block">/* POLAR px */</comment>
		<case>case <expr><name>T_ShareInputScan</name></expr>:</case>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>PlanState</name> <operator>*</operator><operator>)</operator> <call><name>ExecInitShareInputScan</name><argument_list>(<argument><expr><operator>(</operator><name>ShareInputScan</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>, <argument><expr><name>estate</name></expr></argument>, <argument><expr><name>eflags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

			<comment type="block">/*
			 * materialization nodes
			 */</comment>
		<case>case <expr><name>T_Material</name></expr>:</case>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>PlanState</name> <operator>*</operator><operator>)</operator> <call><name>ExecInitMaterial</name><argument_list>(<argument><expr><operator>(</operator><name>Material</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>,
													<argument><expr><name>estate</name></expr></argument>, <argument><expr><name>eflags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_Sort</name></expr>:</case>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>PlanState</name> <operator>*</operator><operator>)</operator> <call><name>ExecInitSort</name><argument_list>(<argument><expr><operator>(</operator><name>Sort</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>,
												<argument><expr><name>estate</name></expr></argument>, <argument><expr><name>eflags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_Group</name></expr>:</case>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>PlanState</name> <operator>*</operator><operator>)</operator> <call><name>ExecInitGroup</name><argument_list>(<argument><expr><operator>(</operator><name>Group</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>,
												 <argument><expr><name>estate</name></expr></argument>, <argument><expr><name>eflags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_Agg</name></expr>:</case>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>PlanState</name> <operator>*</operator><operator>)</operator> <call><name>ExecInitAgg</name><argument_list>(<argument><expr><operator>(</operator><name>Agg</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>,
											   <argument><expr><name>estate</name></expr></argument>, <argument><expr><name>eflags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_WindowAgg</name></expr>:</case>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>PlanState</name> <operator>*</operator><operator>)</operator> <call><name>ExecInitWindowAgg</name><argument_list>(<argument><expr><operator>(</operator><name>WindowAgg</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>,
													 <argument><expr><name>estate</name></expr></argument>, <argument><expr><name>eflags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_Unique</name></expr>:</case>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>PlanState</name> <operator>*</operator><operator>)</operator> <call><name>ExecInitUnique</name><argument_list>(<argument><expr><operator>(</operator><name>Unique</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>,
												  <argument><expr><name>estate</name></expr></argument>, <argument><expr><name>eflags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_Gather</name></expr>:</case>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>PlanState</name> <operator>*</operator><operator>)</operator> <call><name>ExecInitGather</name><argument_list>(<argument><expr><operator>(</operator><name>Gather</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>,
												  <argument><expr><name>estate</name></expr></argument>, <argument><expr><name>eflags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_GatherMerge</name></expr>:</case>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>PlanState</name> <operator>*</operator><operator>)</operator> <call><name>ExecInitGatherMerge</name><argument_list>(<argument><expr><operator>(</operator><name>GatherMerge</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>,
													   <argument><expr><name>estate</name></expr></argument>, <argument><expr><name>eflags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_Hash</name></expr>:</case>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>PlanState</name> <operator>*</operator><operator>)</operator> <call><name>ExecInitHash</name><argument_list>(<argument><expr><operator>(</operator><name>Hash</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>,
												<argument><expr><name>estate</name></expr></argument>, <argument><expr><name>eflags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_SetOp</name></expr>:</case>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>PlanState</name> <operator>*</operator><operator>)</operator> <call><name>ExecInitSetOp</name><argument_list>(<argument><expr><operator>(</operator><name>SetOp</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>,
												 <argument><expr><name>estate</name></expr></argument>, <argument><expr><name>eflags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_LockRows</name></expr>:</case>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>PlanState</name> <operator>*</operator><operator>)</operator> <call><name>ExecInitLockRows</name><argument_list>(<argument><expr><operator>(</operator><name>LockRows</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>,
													<argument><expr><name>estate</name></expr></argument>, <argument><expr><name>eflags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_Limit</name></expr>:</case>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>PlanState</name> <operator>*</operator><operator>)</operator> <call><name>ExecInitLimit</name><argument_list>(<argument><expr><operator>(</operator><name>Limit</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>,
												 <argument><expr><name>estate</name></expr></argument>, <argument><expr><name>eflags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<comment type="block">/* POLAR px */</comment>
		<case>case <expr><name>T_Motion</name></expr>:</case>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>PlanState</name> <operator>*</operator><operator>)</operator> <call><name>ExecInitMotion</name><argument_list>(<argument><expr><operator>(</operator><name>Motion</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>,
												  <argument><expr><name>estate</name></expr></argument>, <argument><expr><name>eflags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<comment type="block">/* POLAR px */</comment>
		<case>case <expr><name>T_SplitUpdate</name></expr>:</case>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>PlanState</name> <operator>*</operator><operator>)</operator> <call><name>ExecInitSplitUpdate</name><argument_list>(<argument><expr><operator>(</operator><name>SplitUpdate</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>,
												  <argument><expr><name>estate</name></expr></argument>, <argument><expr><name>eflags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<comment type="block">/* POLAR px */</comment>
		<case>case <expr><name>T_PartitionSelector</name></expr>:</case>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>PlanState</name> <operator>*</operator><operator>)</operator> <call><name>ExecInitPartitionSelector</name><argument_list>(<argument><expr><operator>(</operator><name>PartitionSelector</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>,
															 <argument><expr><name>estate</name></expr></argument>, <argument><expr><name>eflags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<comment type="block">/* POLAR px */</comment>
		<case>case <expr><name>T_AssertOp</name></expr>:</case>
 			<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>PlanState</name> <operator>*</operator><operator>)</operator> <call><name>ExecInitAssertOp</name><argument_list>(<argument><expr><operator>(</operator><name>AssertOp</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>,
 													<argument><expr><name>estate</name></expr></argument>, <argument><expr><name>eflags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<default>default:</default>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized node type: %d"</literal></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <call><name>nodeTag</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>		<comment type="block">/* keep compiler quiet */</comment>
			<break>break;</break>
	</block_content>}</block></switch>

	<expr_stmt><expr><call><name>ExecSetExecProcNode</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name><name>result</name><operator>-&gt;</operator><name>ExecProcNode</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Initialize any initPlans present in this node.  The planner put them in
	 * a separate list for us.
	 */</comment>
	<expr_stmt><expr><name>subps</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>node-&gt;initPlan</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>SubPlan</name>    <modifier>*</modifier></type><name>subplan</name> <init>= <expr><operator>(</operator><name>SubPlan</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>SubPlanState</name> <modifier>*</modifier></type><name>sstate</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>save_currentSliceId</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>save_currentSliceId</name> <operator>=</operator> <name><name>estate</name><operator>-&gt;</operator><name>currentSliceId</name></name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>estate</name><operator>-&gt;</operator><name>currentSliceId</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>currentSliceId</name></name> <operator>=</operator> <name><name>estate</name><operator>-&gt;</operator><name>es_plannedstmt</name><operator>-&gt;</operator><name>subplan_sliceIds</name><index>[<expr><name><name>subplan</name><operator>-&gt;</operator><name>plan_id</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>IsA</name><argument_list>(<argument><expr><name>subplan</name></expr></argument>, <argument><expr><name>SubPlan</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>sstate</name> <operator>=</operator> <call><name>ExecInitSubPlan</name><argument_list>(<argument><expr><name>subplan</name></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>subps</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>subps</name></expr></argument>, <argument><expr><name>sstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>currentSliceId</name></name> <operator>=</operator> <name>save_currentSliceId</name></expr>;</expr_stmt>
	</block_content>}</block>
	<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>initPlan</name></name> <operator>=</operator> <name>subps</name></expr>;</expr_stmt>

	<comment type="block">/* POALR px */</comment>
	<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>plan_line_id</name></name> <operator>=</operator> <operator>++</operator><name><name>estate</name><operator>-&gt;</operator><name>max_plan_line_id</name></name></expr>;</expr_stmt>

	<comment type="block">/* Set up instrumentation for this node if requested */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>estate</name><operator>-&gt;</operator><name>es_instrument</name></name> <operator>&amp;&amp;</operator> <call><name>polar_check_instrument_option</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>instrument</name></name> <operator>=</operator> <call><name>InstrAlloc</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name><name>estate</name><operator>-&gt;</operator><name>es_instrument</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * If a node wants to change its ExecProcNode function after ExecInitNode()
 * has finished, it should do so with this function.  That way any wrapper
 * functions can be reinstalled, without the node having to know how that
 * works.
 */</comment>
<function><type><name>void</name></type>
<name>ExecSetExecProcNode</name><parameter_list>(<parameter><decl><type><name>PlanState</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>ExecProcNodeMtd</name></type> <name>function</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * Add a wrapper around the ExecProcNode callback that checks stack depth
	 * during the first execution and maybe adds an instrumentation wrapper.
	 * When the callback is changed after execution has already begun that
	 * means we'll superfluously execute ExecProcNodeFirst, but that seems ok.
	 */</comment>
	<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>ExecProcNodeReal</name></name> <operator>=</operator> <name>function</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>ExecProcNode</name></name> <operator>=</operator> <name>ExecProcNodeFirst</name></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * ExecProcNode wrapper that performs some one-time checks, before calling
 * the relevant node method (possibly via an instrumentation wrapper).
 */</comment>
<function><type><specifier>static</specifier> <name>TupleTableSlot</name> <modifier>*</modifier></type>
<name>ExecProcNodeFirst</name><parameter_list>(<parameter><decl><type><name>PlanState</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * Perform stack depth check during the first execution of the node.  We
	 * only do so the first time round because it turns out to not be cheap on
	 * some common architectures (eg. x86).  This relies on the assumption
	 * that ExecProcNode calls for a given plan node will always be made at
	 * roughly the same stack depth.
	 */</comment>
	<expr_stmt><expr><call><name>check_stack_depth</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If instrumentation is required, change the wrapper to one that just
	 * does instrumentation.  Otherwise we can dispense with all wrappers and
	 * have ExecProcNode() directly call the relevant function from now on.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>instrument</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>ExecProcNode</name></name> <operator>=</operator> <name>ExecProcNodeInstr</name></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>ExecProcNode</name></name> <operator>=</operator> <name><name>node</name><operator>-&gt;</operator><name>ExecProcNodeReal</name></name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/* POALR px */</comment>
	<if_stmt><if>if <condition>(<expr><name>ExecProcNode_hook</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><call>(<modifier>*</modifier><name>ExecProcNode_hook</name>)<argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<return>return <expr><call><name><name>node</name><operator>-&gt;</operator><name>ExecProcNode</name></name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * ExecProcNode wrapper that performs instrumentation calls.  By keeping
 * this a separate function, we avoid overhead in the normal case where
 * no instrumentation is wanted.
 */</comment>
<function><type><specifier>static</specifier> <name>TupleTableSlot</name> <modifier>*</modifier></type>
<name>ExecProcNodeInstr</name><parameter_list>(<parameter><decl><type><name>PlanState</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>InstrStartNode</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>instrument</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name><name>node</name><operator>-&gt;</operator><name>ExecProcNodeReal</name></name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>InstrStopNode</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>instrument</name></name></expr></argument>, <argument><expr><ternary><condition><expr><call><name>TupIsNull</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><literal type="number">0.0</literal></expr> </then><else>: <expr><literal type="number">1.0</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/* ----------------------------------------------------------------
 *		MultiExecProcNode
 *
 *		Execute a node that doesn't return individual tuples
 *		(it might return a hashtable, bitmap, etc).  Caller should
 *		check it got back the expected kind of Node.
 *
 * This has essentially the same responsibilities as ExecProcNode,
 * but it does not do InstrStartNode/InstrStopNode (mainly because
 * it can't tell how many returned tuples to count).  Each per-node
 * function must provide its own instrumentation support.
 * ----------------------------------------------------------------
 */</comment>
<function><type><name>Node</name> <modifier>*</modifier></type>
<name>MultiExecProcNode</name><parameter_list>(<parameter><decl><type><name>PlanState</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>check_stack_depth</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>CHECK_FOR_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>chgParam</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <comment type="block">/* something changed */</comment>
		<expr_stmt><expr><call><name>ExecReScan</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>		<comment type="block">/* let ReScan handle this */</comment>

	<switch>switch <condition>(<expr><call><name>nodeTag</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
			<comment type="block">/*
			 * Only node types that actually support multiexec will be listed
			 */</comment>

		<case>case <expr><name>T_HashState</name></expr>:</case>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>MultiExecHash</name><argument_list>(<argument><expr><operator>(</operator><name>HashState</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_BitmapIndexScanState</name></expr>:</case>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>MultiExecBitmapIndexScan</name><argument_list>(<argument><expr><operator>(</operator><name>BitmapIndexScanState</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_BitmapAndState</name></expr>:</case>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>MultiExecBitmapAnd</name><argument_list>(<argument><expr><operator>(</operator><name>BitmapAndState</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_BitmapOrState</name></expr>:</case>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>MultiExecBitmapOr</name><argument_list>(<argument><expr><operator>(</operator><name>BitmapOrState</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<default>default:</default>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized node type: %d"</literal></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <call><name>nodeTag</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
			<break>break;</break>
	</block_content>}</block></switch>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/* ----------------------------------------------------------------
 *		ExecEndNode
 *
 *		Recursively cleans up all the nodes in the plan rooted
 *		at 'node'.
 *
 *		After this operation, the query plan will not be able to be
 *		processed any further.  This should be called only after
 *		the query plan has been fully executed.
 * ----------------------------------------------------------------
 */</comment>
<function><type><name>void</name></type>
<name>ExecEndNode</name><parameter_list>(<parameter><decl><type><name>PlanState</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>ExecEndNode_hook</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call>(<modifier>*</modifier><name>ExecEndNode_hook</name>)<argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>standard_ExecEndNode</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/* POALR px */</comment>
<function><type><name>void</name></type>
<name>standard_ExecEndNode</name><parameter_list>(<parameter><decl><type><name>PlanState</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * do nothing when we get to the end of a leaf on tree.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>node</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Make sure there's enough stack available. Need to check here, in
	 * addition to ExecProcNode() (via ExecProcNodeFirst()), because it's not
	 * guaranteed that ExecProcNode() is reached for all nodes.
	 */</comment>
	<expr_stmt><expr><call><name>check_stack_depth</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>chgParam</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>bms_free</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>chgParam</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>chgParam</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<switch>switch <condition>(<expr><call><name>nodeTag</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
			<comment type="block">/*
			 * control nodes
			 */</comment>
		<case>case <expr><name>T_ResultState</name></expr>:</case>
			<expr_stmt><expr><call><name>ExecEndResult</name><argument_list>(<argument><expr><operator>(</operator><name>ResultState</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_ProjectSetState</name></expr>:</case>
			<expr_stmt><expr><call><name>ExecEndProjectSet</name><argument_list>(<argument><expr><operator>(</operator><name>ProjectSetState</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_ModifyTableState</name></expr>:</case>
			<expr_stmt><expr><call><name>ExecEndModifyTable</name><argument_list>(<argument><expr><operator>(</operator><name>ModifyTableState</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_AppendState</name></expr>:</case>
			<expr_stmt><expr><call><name>ExecEndAppend</name><argument_list>(<argument><expr><operator>(</operator><name>AppendState</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_MergeAppendState</name></expr>:</case>
			<expr_stmt><expr><call><name>ExecEndMergeAppend</name><argument_list>(<argument><expr><operator>(</operator><name>MergeAppendState</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_RecursiveUnionState</name></expr>:</case>
			<expr_stmt><expr><call><name>ExecEndRecursiveUnion</name><argument_list>(<argument><expr><operator>(</operator><name>RecursiveUnionState</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<comment type="block">/* POLAR px */</comment>
		<case>case <expr><name>T_SequenceState</name></expr>:</case>
			<expr_stmt><expr><call><name>ExecEndSequence</name><argument_list>(<argument><expr><operator>(</operator><name>SequenceState</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_BitmapAndState</name></expr>:</case>
			<expr_stmt><expr><call><name>ExecEndBitmapAnd</name><argument_list>(<argument><expr><operator>(</operator><name>BitmapAndState</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_BitmapOrState</name></expr>:</case>
			<expr_stmt><expr><call><name>ExecEndBitmapOr</name><argument_list>(<argument><expr><operator>(</operator><name>BitmapOrState</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

			<comment type="block">/*
			 * scan nodes
			 */</comment>
		<case>case <expr><name>T_SeqScanState</name></expr>:</case>
			<expr_stmt><expr><call><name>ExecEndSeqScan</name><argument_list>(<argument><expr><operator>(</operator><name>SeqScanState</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_SampleScanState</name></expr>:</case>
			<expr_stmt><expr><call><name>ExecEndSampleScan</name><argument_list>(<argument><expr><operator>(</operator><name>SampleScanState</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_GatherState</name></expr>:</case>
			<expr_stmt><expr><call><name>ExecEndGather</name><argument_list>(<argument><expr><operator>(</operator><name>GatherState</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_GatherMergeState</name></expr>:</case>
			<expr_stmt><expr><call><name>ExecEndGatherMerge</name><argument_list>(<argument><expr><operator>(</operator><name>GatherMergeState</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_IndexScanState</name></expr>:</case>
			<expr_stmt><expr><call><name>ExecEndIndexScan</name><argument_list>(<argument><expr><operator>(</operator><name>IndexScanState</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_IndexOnlyScanState</name></expr>:</case>
			<expr_stmt><expr><call><name>ExecEndIndexOnlyScan</name><argument_list>(<argument><expr><operator>(</operator><name>IndexOnlyScanState</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_BitmapIndexScanState</name></expr>:</case>
			<expr_stmt><expr><call><name>ExecEndBitmapIndexScan</name><argument_list>(<argument><expr><operator>(</operator><name>BitmapIndexScanState</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_BitmapHeapScanState</name></expr>:</case>
			<expr_stmt><expr><call><name>ExecEndBitmapHeapScan</name><argument_list>(<argument><expr><operator>(</operator><name>BitmapHeapScanState</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_TidScanState</name></expr>:</case>
			<expr_stmt><expr><call><name>ExecEndTidScan</name><argument_list>(<argument><expr><operator>(</operator><name>TidScanState</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_SubqueryScanState</name></expr>:</case>
			<expr_stmt><expr><call><name>ExecEndSubqueryScan</name><argument_list>(<argument><expr><operator>(</operator><name>SubqueryScanState</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_FunctionScanState</name></expr>:</case>
			<expr_stmt><expr><call><name>ExecEndFunctionScan</name><argument_list>(<argument><expr><operator>(</operator><name>FunctionScanState</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_TableFuncScanState</name></expr>:</case>
			<expr_stmt><expr><call><name>ExecEndTableFuncScan</name><argument_list>(<argument><expr><operator>(</operator><name>TableFuncScanState</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_ValuesScanState</name></expr>:</case>
			<expr_stmt><expr><call><name>ExecEndValuesScan</name><argument_list>(<argument><expr><operator>(</operator><name>ValuesScanState</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_CteScanState</name></expr>:</case>
			<expr_stmt><expr><call><name>ExecEndCteScan</name><argument_list>(<argument><expr><operator>(</operator><name>CteScanState</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_NamedTuplestoreScanState</name></expr>:</case>
			<expr_stmt><expr><call><name>ExecEndNamedTuplestoreScan</name><argument_list>(<argument><expr><operator>(</operator><name>NamedTuplestoreScanState</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_WorkTableScanState</name></expr>:</case>
			<expr_stmt><expr><call><name>ExecEndWorkTableScan</name><argument_list>(<argument><expr><operator>(</operator><name>WorkTableScanState</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_ForeignScanState</name></expr>:</case>
			<expr_stmt><expr><call><name>ExecEndForeignScan</name><argument_list>(<argument><expr><operator>(</operator><name>ForeignScanState</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_CustomScanState</name></expr>:</case>
			<expr_stmt><expr><call><name>ExecEndCustomScan</name><argument_list>(<argument><expr><operator>(</operator><name>CustomScanState</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

			<comment type="block">/*
			 * join nodes
			 */</comment>
		<case>case <expr><name>T_NestLoopState</name></expr>:</case>
			<expr_stmt><expr><call><name>ExecEndNestLoop</name><argument_list>(<argument><expr><operator>(</operator><name>NestLoopState</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_MergeJoinState</name></expr>:</case>
			<expr_stmt><expr><call><name>ExecEndMergeJoin</name><argument_list>(<argument><expr><operator>(</operator><name>MergeJoinState</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_HashJoinState</name></expr>:</case>
			<expr_stmt><expr><call><name>ExecEndHashJoin</name><argument_list>(<argument><expr><operator>(</operator><name>HashJoinState</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<comment type="block">/* POLAR px */</comment>
		<case>case <expr><name>T_ShareInputScanState</name></expr>:</case>
			<expr_stmt><expr><call><name>ExecEndShareInputScan</name><argument_list>(<argument><expr><operator>(</operator><name>ShareInputScanState</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

			<comment type="block">/*
			 * materialization nodes
			 */</comment>
		<case>case <expr><name>T_MaterialState</name></expr>:</case>
			<expr_stmt><expr><call><name>ExecEndMaterial</name><argument_list>(<argument><expr><operator>(</operator><name>MaterialState</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_SortState</name></expr>:</case>
			<expr_stmt><expr><call><name>ExecEndSort</name><argument_list>(<argument><expr><operator>(</operator><name>SortState</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_GroupState</name></expr>:</case>
			<expr_stmt><expr><call><name>ExecEndGroup</name><argument_list>(<argument><expr><operator>(</operator><name>GroupState</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_AggState</name></expr>:</case>
			<expr_stmt><expr><call><name>ExecEndAgg</name><argument_list>(<argument><expr><operator>(</operator><name>AggState</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_WindowAggState</name></expr>:</case>
			<expr_stmt><expr><call><name>ExecEndWindowAgg</name><argument_list>(<argument><expr><operator>(</operator><name>WindowAggState</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_UniqueState</name></expr>:</case>
			<expr_stmt><expr><call><name>ExecEndUnique</name><argument_list>(<argument><expr><operator>(</operator><name>UniqueState</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_HashState</name></expr>:</case>
			<expr_stmt><expr><call><name>ExecEndHash</name><argument_list>(<argument><expr><operator>(</operator><name>HashState</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_SetOpState</name></expr>:</case>
			<expr_stmt><expr><call><name>ExecEndSetOp</name><argument_list>(<argument><expr><operator>(</operator><name>SetOpState</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_LockRowsState</name></expr>:</case>
			<expr_stmt><expr><call><name>ExecEndLockRows</name><argument_list>(<argument><expr><operator>(</operator><name>LockRowsState</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_LimitState</name></expr>:</case>
			<expr_stmt><expr><call><name>ExecEndLimit</name><argument_list>(<argument><expr><operator>(</operator><name>LimitState</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<comment type="block">/* POLAR px */</comment>
		<case>case <expr><name>T_MotionState</name></expr>:</case>
			<expr_stmt><expr><call><name>ExecEndMotion</name><argument_list>(<argument><expr><operator>(</operator><name>MotionState</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<comment type="block">/* POLAR px */</comment>
		<case>case <expr><name>T_PartitionSelectorState</name></expr>:</case>
			<expr_stmt><expr><call><name>ExecEndPartitionSelector</name><argument_list>(<argument><expr><operator>(</operator><name>PartitionSelectorState</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_AssertOpState</name></expr>:</case>
			<expr_stmt><expr><call><name>ExecEndAssertOp</name><argument_list>(<argument><expr><operator>(</operator><name>AssertOpState</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_SplitUpdateState</name></expr>:</case>
			<expr_stmt><expr><call><name>ExecEndSplitUpdate</name><argument_list>(<argument><expr><operator>(</operator><name>SplitUpdateState</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<comment type="block">/* POLAR end */</comment>

		<default>default:</default>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized node type: %d"</literal></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <call><name>nodeTag</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
	</block_content>}</block></switch>
</block_content>}</block></function>

<comment type="block">/*
 * ExecShutdownNode
 *
 * Give execution nodes a chance to stop asynchronous resource consumption
 * and release any resources still held.
 */</comment>
<function><type><name>bool</name></type>
<name>ExecShutdownNode</name><parameter_list>(<parameter><decl><type><name>PlanState</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>node</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>check_stack_depth</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Treat the node as running while we shut it down, but only if it's run
	 * at least once already.  We don't expect much CPU consumption during
	 * node shutdown, but in the case of Gather or Gather Merge, we may shut
	 * down workers at this stage.  If so, their buffer usage will get
	 * propagated into pgBufferUsage at this point, and we want to make sure
	 * that it gets associated with the Gather node.  We skip this if the node
	 * has never been executed, so as to avoid incorrectly making it appear
	 * that it has.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>instrument</name></name> <operator>&amp;&amp;</operator> <name><name>node</name><operator>-&gt;</operator><name>instrument</name><operator>-&gt;</operator><name>running</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>InstrStartNode</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>instrument</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>planstate_tree_walker</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>ExecShutdownNode</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<switch>switch <condition>(<expr><call><name>nodeTag</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>T_GatherState</name></expr>:</case>
			<expr_stmt><expr><call><name>ExecShutdownGather</name><argument_list>(<argument><expr><operator>(</operator><name>GatherState</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_ForeignScanState</name></expr>:</case>
			<expr_stmt><expr><call><name>ExecShutdownForeignScan</name><argument_list>(<argument><expr><operator>(</operator><name>ForeignScanState</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_CustomScanState</name></expr>:</case>
			<expr_stmt><expr><call><name>ExecShutdownCustomScan</name><argument_list>(<argument><expr><operator>(</operator><name>CustomScanState</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_GatherMergeState</name></expr>:</case>
			<expr_stmt><expr><call><name>ExecShutdownGatherMerge</name><argument_list>(<argument><expr><operator>(</operator><name>GatherMergeState</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_HashState</name></expr>:</case>
			<expr_stmt><expr><call><name>ExecShutdownHash</name><argument_list>(<argument><expr><operator>(</operator><name>HashState</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_HashJoinState</name></expr>:</case>
			<expr_stmt><expr><call><name>ExecShutdownHashJoin</name><argument_list>(<argument><expr><operator>(</operator><name>HashJoinState</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<default>default:</default>
			<break>break;</break>
	</block_content>}</block></switch>

	<comment type="block">/* Stop the node if we started it above, reporting 0 tuples. */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>instrument</name></name> <operator>&amp;&amp;</operator> <name><name>node</name><operator>-&gt;</operator><name>instrument</name><operator>-&gt;</operator><name>running</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>InstrStopNode</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>instrument</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * ExecSetTupleBound
 *
 * Set a tuple bound for a planstate node.  This lets child plan nodes
 * optimize based on the knowledge that the maximum number of tuples that
 * their parent will demand is limited.  The tuple bound for a node may
 * only be changed between scans (i.e., after node initialization or just
 * before an ExecReScan call).
 *
 * Any negative tuples_needed value means "no limit", which should be the
 * default assumption when this is not called at all for a particular node.
 *
 * Note: if this is called repeatedly on a plan tree, the exact same set
 * of nodes must be updated with the new limit each time; be careful that
 * only unchanging conditions are tested here.
 */</comment>
<function><type><name>void</name></type>
<name>ExecSetTupleBound</name><parameter_list>(<parameter><decl><type><name>int64</name></type> <name>tuples_needed</name></decl></parameter>, <parameter><decl><type><name>PlanState</name> <modifier>*</modifier></type><name>child_node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * Since this function recurses, in principle we should check stack depth
	 * here.  In practice, it's probably pointless since the earlier node
	 * initialization tree traversal would surely have consumed more stack.
	 */</comment>

	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>child_node</name></expr></argument>, <argument><expr><name>SortState</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * If it is a Sort node, notify it that it can use bounded sort.
		 *
		 * Note: it is the responsibility of nodeSort.c to react properly to
		 * changes of these parameters.  If we ever redesign this, it'd be a
		 * good idea to integrate this signaling with the parameter-change
		 * mechanism.
		 */</comment>
		<decl_stmt><decl><type><name>SortState</name>  <modifier>*</modifier></type><name>sortState</name> <init>= <expr><operator>(</operator><name>SortState</name> <operator>*</operator><operator>)</operator> <name>child_node</name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>tuples_needed</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* make sure flag gets reset if needed upon rescan */</comment>
			<expr_stmt><expr><name><name>sortState</name><operator>-&gt;</operator><name>bounded</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><name><name>sortState</name><operator>-&gt;</operator><name>bounded</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>sortState</name><operator>-&gt;</operator><name>bound</name></name> <operator>=</operator> <name>tuples_needed</name></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>child_node</name></expr></argument>, <argument><expr><name>MergeAppendState</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * If it is a MergeAppend, we can apply the bound to any nodes that
		 * are children of the MergeAppend, since the MergeAppend surely need
		 * read no more than that many tuples from any one input.
		 */</comment>
		<decl_stmt><decl><type><name>MergeAppendState</name> <modifier>*</modifier></type><name>maState</name> <init>= <expr><operator>(</operator><name>MergeAppendState</name> <operator>*</operator><operator>)</operator> <name>child_node</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>maState</name><operator>-&gt;</operator><name>ms_nplans</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ExecSetTupleBound</name><argument_list>(<argument><expr><name>tuples_needed</name></expr></argument>, <argument><expr><name><name>maState</name><operator>-&gt;</operator><name>mergeplans</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>child_node</name></expr></argument>, <argument><expr><name>ResultState</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Similarly, for a projecting Result, we can apply the bound to its
		 * child node.
		 *
		 * If Result supported qual checking, we'd have to punt on seeing a
		 * qual.  Note that having a resconstantqual is not a showstopper: if
		 * that condition succeeds it affects nothing, while if it fails, no
		 * rows will be demanded from the Result child anyway.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>outerPlanState</name><argument_list>(<argument><expr><name>child_node</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ExecSetTupleBound</name><argument_list>(<argument><expr><name>tuples_needed</name></expr></argument>, <argument><expr><call><name>outerPlanState</name><argument_list>(<argument><expr><name>child_node</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>child_node</name></expr></argument>, <argument><expr><name>SubqueryScanState</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * We can also descend through SubqueryScan, but only if it has no
		 * qual (otherwise it might discard rows).
		 */</comment>
		<decl_stmt><decl><type><name>SubqueryScanState</name> <modifier>*</modifier></type><name>subqueryState</name> <init>= <expr><operator>(</operator><name>SubqueryScanState</name> <operator>*</operator><operator>)</operator> <name>child_node</name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>subqueryState</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ps</name><operator>.</operator><name>qual</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ExecSetTupleBound</name><argument_list>(<argument><expr><name>tuples_needed</name></expr></argument>, <argument><expr><name><name>subqueryState</name><operator>-&gt;</operator><name>subplan</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>child_node</name></expr></argument>, <argument><expr><name>GatherState</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * A Gather node can propagate the bound to its workers.  As with
		 * MergeAppend, no one worker could possibly need to return more
		 * tuples than the Gather itself needs to.
		 *
		 * Note: As with Sort, the Gather node is responsible for reacting
		 * properly to changes to this parameter.
		 */</comment>
		<decl_stmt><decl><type><name>GatherState</name> <modifier>*</modifier></type><name>gstate</name> <init>= <expr><operator>(</operator><name>GatherState</name> <operator>*</operator><operator>)</operator> <name>child_node</name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>gstate</name><operator>-&gt;</operator><name>tuples_needed</name></name> <operator>=</operator> <name>tuples_needed</name></expr>;</expr_stmt>

		<comment type="block">/* Also pass down the bound to our own copy of the child plan */</comment>
		<expr_stmt><expr><call><name>ExecSetTupleBound</name><argument_list>(<argument><expr><name>tuples_needed</name></expr></argument>, <argument><expr><call><name>outerPlanState</name><argument_list>(<argument><expr><name>child_node</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>child_node</name></expr></argument>, <argument><expr><name>GatherMergeState</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Same comments as for Gather */</comment>
		<decl_stmt><decl><type><name>GatherMergeState</name> <modifier>*</modifier></type><name>gstate</name> <init>= <expr><operator>(</operator><name>GatherMergeState</name> <operator>*</operator><operator>)</operator> <name>child_node</name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>gstate</name><operator>-&gt;</operator><name>tuples_needed</name></name> <operator>=</operator> <name>tuples_needed</name></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>ExecSetTupleBound</name><argument_list>(<argument><expr><name>tuples_needed</name></expr></argument>, <argument><expr><call><name>outerPlanState</name><argument_list>(<argument><expr><name>child_node</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * In principle we could descend through any plan node type that is
	 * certain not to discard or combine input rows; but on seeing a node that
	 * can do that, we can't propagate the bound any further.  For the moment
	 * it's unclear that any other cases are worth checking here.
	 */</comment>
</block_content>}</block></function>
</unit>
