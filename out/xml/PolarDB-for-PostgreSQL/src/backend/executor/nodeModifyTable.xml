<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/PolarDB-for-PostgreSQL/src/backend/executor/nodeModifyTable.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * nodeModifyTable.c
 *	  routines to handle ModifyTable nodes.
 *
 * Portions Copyright (c) 1996-2018, PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, Regents of the University of California
 *
 *
 * IDENTIFICATION
 *	  src/backend/executor/nodeModifyTable.c
 *
 *-------------------------------------------------------------------------
 */</comment>
<comment type="block">/* INTERFACE ROUTINES
 *		ExecInitModifyTable - initialize the ModifyTable node
 *		ExecModifyTable		- retrieve the next tuple from the node
 *		ExecEndModifyTable	- shut down the ModifyTable node
 *		ExecReScanModifyTable - rescan the ModifyTable node
 *
 *	 NOTES
 *		Each ModifyTable node contains a list of one or more subplans,
 *		much like an Append node.  There is one subplan per result relation.
 *		The key reason for this is that in an inherited UPDATE command, each
 *		result relation could have a different schema (more or different
 *		columns) requiring a different plan tree to produce it.  In an
 *		inherited DELETE, all the subplans should produce the same output
 *		rowtype, but we might still find that different plans are appropriate
 *		for different child relations.
 *
 *		If the query specifies RETURNING, then the ModifyTable returns a
 *		RETURNING tuple after completing each row insert, update, or delete.
 *		It must be called again to continue the operation.  Without RETURNING,
 *		we just loop within the node until all the work is done, then
 *		return NULL.  This avoids useless call/return overhead.
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/htup_details.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/xact.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/trigger.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/execPartition.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/executor.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/nodeModifyTable.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"foreign/fdwapi.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/nodeFuncs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/bufmgr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/lmgr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/builtins.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/memutils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/rel.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/tqual.h"</cpp:file></cpp:include>

<comment type="block">/* POLAR */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/guc.h"</cpp:file></cpp:include>

<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>ExecOnConflictUpdate</name><parameter_list>(<parameter><decl><type><name>ModifyTableState</name> <modifier>*</modifier></type><name>mtstate</name></decl></parameter>,
					 <parameter><decl><type><name>ResultRelInfo</name> <modifier>*</modifier></type><name>resultRelInfo</name></decl></parameter>,
					 <parameter><decl><type><name>ItemPointer</name></type> <name>conflictTid</name></decl></parameter>,
					 <parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>planSlot</name></decl></parameter>,
					 <parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>excludedSlot</name></decl></parameter>,
					 <parameter><decl><type><name>EState</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>,
					 <parameter><decl><type><name>bool</name></type> <name>canSetTag</name></decl></parameter>,
					 <parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier><modifier>*</modifier></type><name>returning</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>TupleTableSlot</name> <modifier>*</modifier></type><name>ExecPrepareTupleRouting</name><parameter_list>(<parameter><decl><type><name>ModifyTableState</name> <modifier>*</modifier></type><name>mtstate</name></decl></parameter>,
						<parameter><decl><type><name>EState</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>,
						<parameter><decl><type><name>PartitionTupleRouting</name> <modifier>*</modifier></type><name>proute</name></decl></parameter>,
						<parameter><decl><type><name>ResultRelInfo</name> <modifier>*</modifier></type><name>targetRelInfo</name></decl></parameter>,
						<parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>ResultRelInfo</name> <modifier>*</modifier></type><name>getTargetResultRelInfo</name><parameter_list>(<parameter><decl><type><name>ModifyTableState</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ExecSetupChildParentMapForTcs</name><parameter_list>(<parameter><decl><type><name>ModifyTableState</name> <modifier>*</modifier></type><name>mtstate</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ExecSetupChildParentMapForSubplan</name><parameter_list>(<parameter><decl><type><name>ModifyTableState</name> <modifier>*</modifier></type><name>mtstate</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>TupleConversionMap</name> <modifier>*</modifier></type><name>tupconv_map_for_subplan</name><parameter_list>(<parameter><decl><type><name>ModifyTableState</name> <modifier>*</modifier></type><name>node</name></decl></parameter>,
						<parameter><decl><type><name>int</name></type> <name>whichplan</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/*
 * Verify that the tuples to be produced by INSERT or UPDATE match the
 * target relation's rowtype
 *
 * We do this to guard against stale plans.  If plan invalidation is
 * functioning properly then we should never get a failure here, but better
 * safe than sorry.  Note that this is called after we have obtained lock
 * on the target rel, so the rowtype can't change underneath us.
 *
 * The plan output is represented by its targetlist, because that makes
 * handling the dropped-column case easier.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ExecCheckPlanOutput</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>resultRel</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>targetList</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TupleDesc</name></type>	<name>resultDesc</name> <init>= <expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>resultRel</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>attno</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>targetList</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>tle</name> <init>= <expr><operator>(</operator><name>TargetEntry</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>attr</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>tle</name><operator>-&gt;</operator><name>resjunk</name></name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>			<comment type="block">/* ignore junk tlist items */</comment>

		<if_stmt><if>if <condition>(<expr><name>attno</name> <operator>&gt;=</operator> <name><name>resultDesc</name><operator>-&gt;</operator><name>natts</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATATYPE_MISMATCH</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"table row type and query-specified row type do not match"</literal></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Query has too many columns."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>attr</name> <operator>=</operator> <call><name>TupleDescAttr</name><argument_list>(<argument><expr><name>resultDesc</name></expr></argument>, <argument><expr><name>attno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>attno</name><operator>++</operator></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>attr</name><operator>-&gt;</operator><name>attisdropped</name></name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Normal case: demand type match */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>exprType</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>tle</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <name><name>attr</name><operator>-&gt;</operator><name>atttypid</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATATYPE_MISMATCH</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"table row type and query-specified row type do not match"</literal></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Table has type %s at ordinal position %d, but query expects %s."</literal></expr></argument>,
								   <argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><name><name>attr</name><operator>-&gt;</operator><name>atttypid</name></name></expr></argument>)</argument_list></call></expr></argument>,
								   <argument><expr><name>attno</name></expr></argument>,
								   <argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><call><name>exprType</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>tle</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/*
			 * For a dropped column, we can't check atttypid (it's likely 0).
			 * In any case the planner has most likely inserted an INT4 null.
			 * What we insist on is just *some* NULL constant.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name><name>tle</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>, <argument><expr><name>Const</name></expr></argument>)</argument_list></call> <operator>||</operator>
				<operator>!</operator><operator>(</operator><operator>(</operator><name>Const</name> <operator>*</operator><operator>)</operator> <name><name>tle</name><operator>-&gt;</operator><name>expr</name></name><operator>)</operator><operator>-&gt;</operator><name>constisnull</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATATYPE_MISMATCH</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"table row type and query-specified row type do not match"</literal></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Query provides a value for a dropped column at ordinal position %d."</literal></expr></argument>,
								   <argument><expr><name>attno</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block>
	<if_stmt><if>if <condition>(<expr><name>attno</name> <operator>!=</operator> <name><name>resultDesc</name><operator>-&gt;</operator><name>natts</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATATYPE_MISMATCH</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"table row type and query-specified row type do not match"</literal></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Query has too few columns."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * ExecProcessReturning --- evaluate a RETURNING list
 *
 * projectReturning: the projection to evaluate
 * resultRelOid: result relation's OID
 * tupleSlot: slot holding tuple actually inserted/updated/deleted
 * planSlot: slot holding tuple returned by top subplan node
 *
 * In cross-partition UPDATE cases, projectReturning and planSlot are as
 * for the source partition, and tupleSlot must conform to that.  But
 * resultRelOid is for the destination partition.
 *
 * Note: If tupleSlot is NULL, the FDW should have already provided econtext's
 * scan tuple.
 *
 * Returns a slot holding the result tuple
 */</comment>
<function><type><specifier>static</specifier> <name>TupleTableSlot</name> <modifier>*</modifier></type>
<name>ExecProcessReturning</name><parameter_list>(<parameter><decl><type><name>ProjectionInfo</name> <modifier>*</modifier></type><name>projectReturning</name></decl></parameter>,
					 <parameter><decl><type><name>Oid</name></type> <name>resultRelOid</name></decl></parameter>,
					 <parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>tupleSlot</name></decl></parameter>,
					 <parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>planSlot</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ExprContext</name> <modifier>*</modifier></type><name>econtext</name> <init>= <expr><name><name>projectReturning</name><operator>-&gt;</operator><name>pi_exprContext</name></name></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * Reset per-tuple memory context to free any expression evaluation
	 * storage allocated in the previous cycle.
	 */</comment>
	<expr_stmt><expr><call><name>ResetExprContext</name><argument_list>(<argument><expr><name>econtext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Make tuple and any needed join variables available to ExecProject */</comment>
	<if_stmt><if>if <condition>(<expr><name>tupleSlot</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>econtext</name><operator>-&gt;</operator><name>ecxt_scantuple</name></name> <operator>=</operator> <name>tupleSlot</name></expr>;</expr_stmt></block_content></block></if>
	<else>else
	<block>{<block_content>
		<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tuple</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * RETURNING expressions might reference the tableoid column, so be
		 * sure we expose the desired OID, ie that of the real target
		 * relation.
		 */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>TupIsNull</name><argument_list>(<argument><expr><name><name>econtext</name><operator>-&gt;</operator><name>ecxt_scantuple</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>ExecMaterializeSlot</name><argument_list>(<argument><expr><name><name>econtext</name><operator>-&gt;</operator><name>ecxt_scantuple</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>tuple</name><operator>-&gt;</operator><name>t_tableOid</name></name> <operator>=</operator> <name>resultRelOid</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
	<expr_stmt><expr><name><name>econtext</name><operator>-&gt;</operator><name>ecxt_outertuple</name></name> <operator>=</operator> <name>planSlot</name></expr>;</expr_stmt>

	<comment type="block">/* Compute the RETURNING expressions */</comment>
	<return>return <expr><call><name>ExecProject</name><argument_list>(<argument><expr><name>projectReturning</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * ExecCheckHeapTupleVisible -- verify heap tuple is visible
 *
 * It would not be consistent with guarantees of the higher isolation levels to
 * proceed with avoiding insertion (taking speculative insertion's alternative
 * path) on the basis of another tuple that is not visible to MVCC snapshot.
 * Check for the need to raise a serialization failure, and do so as necessary.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ExecCheckHeapTupleVisible</name><parameter_list>(<parameter><decl><type><name>EState</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>,
						  <parameter><decl><type><name>HeapTuple</name></type> <name>tuple</name></decl></parameter>,
						  <parameter><decl><type><name>Buffer</name></type> <name>buffer</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsolationUsesXactSnapshot</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * We need buffer pin and lock to call HeapTupleSatisfiesVisibility.
	 * Caller should be holding pin, but not lock.
	 */</comment>
	<expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>BUFFER_LOCK_SHARE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleSatisfiesVisibility</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>, <argument><expr><name><name>estate</name><operator>-&gt;</operator><name>es_snapshot</name></name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * We should not raise a serialization failure if the conflict is
		 * against a tuple inserted by our own transaction, even if it's not
		 * visible to our snapshot.  (This would happen, for example, if
		 * conflicting keys are proposed for insertion in a single command.)
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>TransactionIdIsCurrentTransactionId</name><argument_list>(<argument><expr><call><name>HeapTupleHeaderGetXmin</name><argument_list>(<argument><expr><name><name>tuple</name><operator>-&gt;</operator><name>t_data</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_T_R_SERIALIZATION_FAILURE</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not serialize access due to concurrent update"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>BUFFER_LOCK_UNLOCK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * ExecCheckTIDVisible -- convenience variant of ExecCheckHeapTupleVisible()
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ExecCheckTIDVisible</name><parameter_list>(<parameter><decl><type><name>EState</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>,
					<parameter><decl><type><name>ResultRelInfo</name> <modifier>*</modifier></type><name>relinfo</name></decl></parameter>,
					<parameter><decl><type><name>ItemPointer</name></type> <name>tid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>rel</name> <init>= <expr><name><name>relinfo</name><operator>-&gt;</operator><name>ri_RelationDesc</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Buffer</name></type>		<name>buffer</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTupleData</name></type> <name>tuple</name></decl>;</decl_stmt>

	<comment type="block">/* Redundantly check isolation level */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsolationUsesXactSnapshot</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name><name>tuple</name><operator>.</operator><name>t_self</name></name> <operator>=</operator> <operator>*</operator><name>tid</name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>heap_fetch</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>SnapshotAny</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tuple</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"failed to fetch conflicting tuple for ON CONFLICT"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><call><name>ExecCheckHeapTupleVisible</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tuple</name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ReleaseBuffer</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* ----------------------------------------------------------------
 *		ExecInsert
 *
 *		For INSERT, we have to insert the tuple into the target relation
 *		and insert appropriate tuples into the index relations.
 *
 *		slot contains the new tuple value to be stored.
 *		planSlot is the output of the ModifyTable's subplan; we use it
 *		to access "junk" columns that are not going to be stored.
 *		In a cross-partition UPDATE, srcSlot is the slot that held the
 *		updated tuple for the source relation; otherwise it's NULL.
 *
 *		returningRelInfo is the resultRelInfo for the source relation of a
 *		cross-partition UPDATE; otherwise it's the current result relation.
 *		We use it to process RETURNING lists, for reasons explained below.
 *
 *		Returns RETURNING result if any, otherwise NULL.
 * ----------------------------------------------------------------
 */</comment>
<function><type><specifier>static</specifier> <name>TupleTableSlot</name> <modifier>*</modifier></type>
<name>ExecInsert</name><parameter_list>(<parameter><decl><type><name>ModifyTableState</name> <modifier>*</modifier></type><name>mtstate</name></decl></parameter>,
		   <parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl></parameter>,
		   <parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>planSlot</name></decl></parameter>,
		   <parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>srcSlot</name></decl></parameter>,
		   <parameter><decl><type><name>ResultRelInfo</name> <modifier>*</modifier></type><name>returningRelInfo</name></decl></parameter>,
		   <parameter><decl><type><name>EState</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>,
		   <parameter><decl><type><name>bool</name></type> <name>canSetTag</name></decl></parameter>,
		   <parameter><decl><type><name>bool</name></type> <name>splitUpdate</name></decl></parameter> <comment type="block">/* POLAR px */</comment>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ResultRelInfo</name> <modifier>*</modifier></type><name>resultRelInfo</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>resultRelationDesc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>newId</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>recheckIndexes</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>result</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TransitionCaptureState</name> <modifier>*</modifier></type><name>ar_insert_trig_tcs</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ModifyTable</name> <modifier>*</modifier></type><name>node</name> <init>= <expr><operator>(</operator><name>ModifyTable</name> <operator>*</operator><operator>)</operator> <name><name>mtstate</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>plan</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OnConflictAction</name></type> <name>onconflict</name> <init>= <expr><name><name>node</name><operator>-&gt;</operator><name>onConflictAction</name></name></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * get the heap tuple out of the tuple table slot, making sure we have a
	 * writable copy
	 */</comment>
	<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>ExecMaterializeSlot</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * get information on the (current) result relation
	 */</comment>
	<expr_stmt><expr><name>resultRelInfo</name> <operator>=</operator> <name><name>estate</name><operator>-&gt;</operator><name>es_result_relation_info</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>resultRelationDesc</name> <operator>=</operator> <name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_RelationDesc</name></name></expr>;</expr_stmt>

	<comment type="block">/*
	 * If the result relation has OIDs, force the tuple's OID to zero so that
	 * heap_insert will assign a fresh OID.  Usually the OID already will be
	 * zero at this point, but there are corner cases where the plan tree can
	 * return a tuple extracted literally from some table with the same
	 * rowtype.
	 *
	 * XXX if we ever wanted to allow users to assign their own OIDs to new
	 * rows, this'd be the place to do it.  For the moment, we make a point of
	 * doing this before calling triggers, so that a user-supplied trigger
	 * could hack the OID if desired.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>resultRelationDesc</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relhasoids</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>HeapTupleSetOid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>, <argument><expr><name>InvalidOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * BEFORE ROW INSERT Triggers.
	 *
	 * Note: We fire BEFORE ROW TRIGGERS for every attempted insertion in an
	 * INSERT ... ON CONFLICT statement.  We cannot check for constraint
	 * violations before firing these triggers, because they can change the
	 * values to insert.  Also, they can run arbitrary user-defined code with
	 * side-effects that we can't cancel by just not inserting the tuple.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_TrigDesc</name></name> <operator>&amp;&amp;</operator>
		<name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_TrigDesc</name><operator>-&gt;</operator><name>trig_insert_before_row</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>slot</name> <operator>=</operator> <call><name>ExecBRInsertTriggers</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name>resultRelInfo</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>slot</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>		<comment type="block">/* "do nothing" */</comment>
			<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

		<comment type="block">/* trigger might have changed tuple */</comment>
		<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>ExecMaterializeSlot</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* INSTEAD OF ROW INSERT Triggers */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_TrigDesc</name></name> <operator>&amp;&amp;</operator>
		<name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_TrigDesc</name><operator>-&gt;</operator><name>trig_insert_instead_row</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>slot</name> <operator>=</operator> <call><name>ExecIRInsertTriggers</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name>resultRelInfo</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>slot</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>		<comment type="block">/* "do nothing" */</comment>
			<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

		<comment type="block">/* trigger might have changed tuple */</comment>
		<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>ExecMaterializeSlot</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>newId</name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_FdwRoutine</name></name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * insert into foreign table: let the FDW do it
		 */</comment>
		<expr_stmt><expr><name>slot</name> <operator>=</operator> <call><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_FdwRoutine</name><operator>-&gt;</operator><name>ExecForeignInsert</name></name><argument_list>(<argument><expr><name>estate</name></expr></argument>,
															   <argument><expr><name>resultRelInfo</name></expr></argument>,
															   <argument><expr><name>slot</name></expr></argument>,
															   <argument><expr><name>planSlot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>slot</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>		<comment type="block">/* "do nothing" */</comment>
			<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

		<comment type="block">/* FDW might have changed tuple */</comment>
		<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>ExecMaterializeSlot</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * AFTER ROW Triggers or RETURNING expressions might reference the
		 * tableoid column, so initialize t_tableOid before evaluating them.
		 */</comment>
		<expr_stmt><expr><name><name>tuple</name><operator>-&gt;</operator><name>t_tableOid</name></name> <operator>=</operator> <call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>resultRelationDesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>newId</name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<decl_stmt><decl><type><name>WCOKind</name></type>		<name>wco_kind</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * Constraints might reference the tableoid column, so initialize
		 * t_tableOid before evaluating them.
		 */</comment>
		<expr_stmt><expr><name><name>tuple</name><operator>-&gt;</operator><name>t_tableOid</name></name> <operator>=</operator> <call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>resultRelationDesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Check any RLS WITH CHECK policies.
		 *
		 * Normally we should check INSERT policies. But if the insert is the
		 * result of a partition key update that moved the tuple to a new
		 * partition, we should instead check UPDATE policies, because we are
		 * executing policies defined on the target table, and not those
		 * defined on the child partitions.
		 */</comment>
		<expr_stmt><expr><name>wco_kind</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name><name>mtstate</name><operator>-&gt;</operator><name>operation</name></name> <operator>==</operator> <name>CMD_UPDATE</name><operator>)</operator></expr> ?</condition><then>
			<expr><name>WCO_RLS_UPDATE_CHECK</name></expr> </then><else>: <expr><name>WCO_RLS_INSERT_CHECK</name></expr></else></ternary></expr>;</expr_stmt>

		<comment type="block">/*
		 * ExecWithCheckOptions() will skip any WCOs which are not of the kind
		 * we are looking for at this point.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_WithCheckOptions</name></name> <operator>!=</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ExecWithCheckOptions</name><argument_list>(<argument><expr><name>wco_kind</name></expr></argument>, <argument><expr><name>resultRelInfo</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>, <argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * Check the constraints of the tuple.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>resultRelationDesc</name><operator>-&gt;</operator><name>rd_att</name><operator>-&gt;</operator><name>constr</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ExecConstraints</name><argument_list>(<argument><expr><name>resultRelInfo</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>, <argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * Also check the tuple against the partition constraint, if there is
		 * one; except that if we got here via tuple-routing, we don't need to
		 * if there's no BR trigger defined on the partition.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_PartitionCheck</name></name> <operator>&amp;&amp;</operator>
			<operator>(</operator><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_PartitionRoot</name></name> <operator>==</operator> <name>NULL</name> <operator>||</operator>
			 <operator>(</operator><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_TrigDesc</name></name> <operator>&amp;&amp;</operator>
			  <name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_TrigDesc</name><operator>-&gt;</operator><name>trig_insert_before_row</name></name><operator>)</operator><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ExecPartitionCheck</name><argument_list>(<argument><expr><name>resultRelInfo</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>, <argument><expr><name>estate</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>onconflict</name> <operator>!=</operator> <name>ONCONFLICT_NONE</name> <operator>&amp;&amp;</operator> <name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_NumIndices</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Perform a speculative insertion. */</comment>
			<decl_stmt><decl><type><name>uint32</name></type>		<name>specToken</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>ItemPointerData</name></type> <name>conflictTid</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>bool</name></type>		<name>specConflict</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>arbiterIndexes</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>arbiterIndexes</name> <operator>=</operator> <name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_onConflictArbiterIndexes</name></name></expr>;</expr_stmt>

			<comment type="block">/*
			 * Do a non-conclusive check for conflicts first.
			 *
			 * We're not holding any locks yet, so this doesn't guarantee that
			 * the later insert won't conflict.  But it avoids leaving behind
			 * a lot of canceled speculative insertions, if you run a lot of
			 * INSERT ON CONFLICT statements that do conflict.
			 *
			 * We loop back here if we find a conflict below, either during
			 * the pre-check, or when we re-check after inserting the tuple
			 * speculatively.
			 */</comment>
	<label><name>vlock</name>:</label>
			<expr_stmt><expr><name>specConflict</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ExecCheckIndexConstraints</name><argument_list>(<argument><expr><name>slot</name></expr></argument>, <argument><expr><name>estate</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>conflictTid</name></expr></argument>,
										   <argument><expr><name>arbiterIndexes</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* committed conflict tuple found */</comment>
				<if_stmt><if>if <condition>(<expr><name>onconflict</name> <operator>==</operator> <name>ONCONFLICT_UPDATE</name></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/*
					 * In case of ON CONFLICT DO UPDATE, execute the UPDATE
					 * part.  Be prepared to retry if the UPDATE fails because
					 * of another concurrent UPDATE/DELETE to the conflict
					 * tuple.
					 */</comment>
					<decl_stmt><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>returning</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

					<if_stmt><if>if <condition>(<expr><call><name>ExecOnConflictUpdate</name><argument_list>(<argument><expr><name>mtstate</name></expr></argument>, <argument><expr><name>resultRelInfo</name></expr></argument>,
											 <argument><expr><operator>&amp;</operator><name>conflictTid</name></expr></argument>, <argument><expr><name>planSlot</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>,
											 <argument><expr><name>estate</name></expr></argument>, <argument><expr><name>canSetTag</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>returning</name></expr></argument>)</argument_list></call></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><call><name>InstrCountTuples2</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>mtstate</name><operator>-&gt;</operator><name>ps</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<return>return <expr><name>returning</name></expr>;</return>
					</block_content>}</block></if>
					<else>else<block type="pseudo"><block_content>
						<goto>goto <name>vlock</name>;</goto></block_content></block></else></if_stmt>
				</block_content>}</block></if>
				<else>else
				<block>{<block_content>
					<comment type="block">/*
					 * In case of ON CONFLICT DO NOTHING, do nothing. However,
					 * verify that the tuple is visible to the executor's MVCC
					 * snapshot at higher isolation levels.
					 */</comment>
					<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>onconflict</name> <operator>==</operator> <name>ONCONFLICT_NOTHING</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>ExecCheckTIDVisible</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name>resultRelInfo</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>conflictTid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>InstrCountTuples2</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>mtstate</name><operator>-&gt;</operator><name>ps</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<return>return <expr><name>NULL</name></expr>;</return>
				</block_content>}</block></else></if_stmt>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/*
			 * Before we start insertion proper, acquire our "speculative
			 * insertion lock".  Others can use that to wait for us to decide
			 * if we're going to go ahead with the insertion, instead of
			 * waiting for the whole transaction to complete.
			 */</comment>
			<expr_stmt><expr><name>specToken</name> <operator>=</operator> <call><name>SpeculativeInsertionLockAcquire</name><argument_list>(<argument><expr><call><name>GetCurrentTransactionId</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>HeapTupleHeaderSetSpeculativeToken</name><argument_list>(<argument><expr><name><name>tuple</name><operator>-&gt;</operator><name>t_data</name></name></expr></argument>, <argument><expr><name>specToken</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* insert the tuple, with the speculative token */</comment>
			<expr_stmt><expr><name>newId</name> <operator>=</operator> <call><name>heap_insert</name><argument_list>(<argument><expr><name>resultRelationDesc</name></expr></argument>, <argument><expr><name>tuple</name></expr></argument>,
								<argument><expr><name><name>estate</name><operator>-&gt;</operator><name>es_output_cid</name></name></expr></argument>,
								<argument><expr><name>HEAP_INSERT_SPECULATIVE</name></expr></argument>,
								<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* insert index entries for tuple */</comment>
			<expr_stmt><expr><name>recheckIndexes</name> <operator>=</operator> <call><name>ExecInsertIndexTuples</name><argument_list>(<argument><expr><name>slot</name></expr></argument>, <argument><expr><operator>&amp;</operator><operator>(</operator><name><name>tuple</name><operator>-&gt;</operator><name>t_self</name></name><operator>)</operator></expr></argument>,
												   <argument><expr><name>estate</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>specConflict</name></expr></argument>,
												   <argument><expr><name>arbiterIndexes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* adjust the tuple's state accordingly */</comment>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>specConflict</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>heap_finish_speculative</name><argument_list>(<argument><expr><name>resultRelationDesc</name></expr></argument>, <argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>heap_abort_speculative</name><argument_list>(<argument><expr><name>resultRelationDesc</name></expr></argument>, <argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

			<comment type="block">/*
			 * Wake up anyone waiting for our decision.  They will re-check
			 * the tuple, see that it's no longer speculative, and wait on our
			 * XID as if this was a regularly inserted tuple all along.  Or if
			 * we killed the tuple, they will see it's dead, and proceed as if
			 * the tuple never existed.
			 */</comment>
			<expr_stmt><expr><call><name>SpeculativeInsertionLockRelease</name><argument_list>(<argument><expr><call><name>GetCurrentTransactionId</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * If there was a conflict, start from the beginning.  We'll do
			 * the pre-check again, which will now find the conflicting tuple
			 * (unless it aborts before we get there).
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name>specConflict</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>list_free</name><argument_list>(<argument><expr><name>recheckIndexes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<goto>goto <name>vlock</name>;</goto>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/* Since there was no insertion conflict, we're done */</comment>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/*
			 * insert the tuple normally.
			 *
			 * Note: heap_insert returns the tid (location) of the new tuple
			 * in the t_self field.
			 */</comment>
			<expr_stmt><expr><name>newId</name> <operator>=</operator> <call><name>heap_insert</name><argument_list>(<argument><expr><name>resultRelationDesc</name></expr></argument>, <argument><expr><name>tuple</name></expr></argument>,
								<argument><expr><name><name>estate</name><operator>-&gt;</operator><name>es_output_cid</name></name></expr></argument>,
								<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* insert index entries for tuple */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_NumIndices</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>recheckIndexes</name> <operator>=</operator> <call><name>ExecInsertIndexTuples</name><argument_list>(<argument><expr><name>slot</name></expr></argument>, <argument><expr><operator>&amp;</operator><operator>(</operator><name><name>tuple</name><operator>-&gt;</operator><name>t_self</name></name><operator>)</operator></expr></argument>,
													   <argument><expr><name>estate</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
													   <argument><expr><name>NIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>canSetTag</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><operator>(</operator><name><name>estate</name><operator>-&gt;</operator><name>es_processed</name></name><operator>)</operator><operator>++</operator></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>es_lastoid</name></name> <operator>=</operator> <name>newId</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>setLastTid</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>tuple</name><operator>-&gt;</operator><name>t_self</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * If this insert is the result of a partition key update that moved the
	 * tuple to a new partition, put this row into the transition NEW TABLE,
	 * if there is one. We need to do this separately for DELETE and INSERT
	 * because they happen on different tables.
	 */</comment>
	<expr_stmt><expr><name>ar_insert_trig_tcs</name> <operator>=</operator> <name><name>mtstate</name><operator>-&gt;</operator><name>mt_transition_capture</name></name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>mtstate</name><operator>-&gt;</operator><name>operation</name></name> <operator>==</operator> <name>CMD_UPDATE</name> <operator>&amp;&amp;</operator> <name><name>mtstate</name><operator>-&gt;</operator><name>mt_transition_capture</name></name>
		<operator>&amp;&amp;</operator> <name><name>mtstate</name><operator>-&gt;</operator><name>mt_transition_capture</name><operator>-&gt;</operator><name>tcs_update_new_table</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ExecARUpdateTriggers</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name>resultRelInfo</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
							 <argument><expr><name>NULL</name></expr></argument>,
							 <argument><expr><name>tuple</name></expr></argument>,
							 <argument><expr><name>NULL</name></expr></argument>,
							 <argument><expr><name><name>mtstate</name><operator>-&gt;</operator><name>mt_transition_capture</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * We've already captured the NEW TABLE row, so make sure any AR
		 * INSERT trigger fired below doesn't capture it again.
		 */</comment>
		<expr_stmt><expr><name>ar_insert_trig_tcs</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* AFTER ROW INSERT Triggers */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>splitUpdate</name></expr> <comment type="block">/* POLAR px */</comment>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ExecARInsertTriggers</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name>resultRelInfo</name></expr></argument>, <argument><expr><name>tuple</name></expr></argument>, <argument><expr><name>recheckIndexes</name></expr></argument>,
							 <argument><expr><name>ar_insert_trig_tcs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>list_free</name><argument_list>(<argument><expr><name>recheckIndexes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Check any WITH CHECK OPTION constraints from parent views.  We are
	 * required to do this after testing all constraints and uniqueness
	 * violations per the SQL spec, so we do it after actually inserting the
	 * record into the heap and all indexes.
	 *
	 * ExecWithCheckOptions will elog(ERROR) if a violation is found, so the
	 * tuple will never be seen, if it violates the WITH CHECK OPTION.
	 *
	 * ExecWithCheckOptions() will skip any WCOs which are not of the kind we
	 * are looking for at this point.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_WithCheckOptions</name></name> <operator>!=</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ExecWithCheckOptions</name><argument_list>(<argument><expr><name>WCO_VIEW_CHECK</name></expr></argument>, <argument><expr><name>resultRelInfo</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>, <argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Process RETURNING if present */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>returningRelInfo</name><operator>-&gt;</operator><name>ri_projectReturning</name></name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * In a cross-partition UPDATE with RETURNING, we have to use the
		 * source partition's RETURNING list, because that matches the output
		 * of the planSlot, while the destination partition might have
		 * different resjunk columns.  This means we have to map the
		 * destination tuple back to the source's format so we can apply that
		 * RETURNING list.  This is expensive, but it should be an uncommon
		 * corner case, so we won't spend much effort on making it fast.
		 *
		 * We assume that we can use srcSlot to hold the re-converted tuple.
		 * Note that in the common case where the child partitions both match
		 * the root's format, previous optimizations will have resulted in
		 * slot and srcSlot being identical, cueing us that there's nothing to
		 * do here.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>returningRelInfo</name> <operator>!=</operator> <name>resultRelInfo</name> <operator>&amp;&amp;</operator> <name>slot</name> <operator>!=</operator> <name>srcSlot</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Relation</name></type>	<name>srcRelationDesc</name> <init>= <expr><name><name>returningRelInfo</name><operator>-&gt;</operator><name>ri_RelationDesc</name></name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>TupleConversionMap</name> <modifier>*</modifier></type><name>map</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>map</name> <operator>=</operator> <call><name>convert_tuples_by_name</name><argument_list>(<argument><expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>resultRelationDesc</name></expr></argument>)</argument_list></call></expr></argument>,
										 <argument><expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>srcRelationDesc</name></expr></argument>)</argument_list></call></expr></argument>,
										 <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"could not convert row type"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>map</name></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>origTuple</name> <init>= <expr><call><name>ExecMaterializeSlot</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>newTuple</name></decl>;</decl_stmt>

				<expr_stmt><expr><name>newTuple</name> <operator>=</operator> <call><name>do_convert_tuple</name><argument_list>(<argument><expr><name>origTuple</name></expr></argument>, <argument><expr><name>map</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/* do_convert_tuple doesn't copy system columns, so do that */</comment>
				<expr_stmt><expr><name><name>newTuple</name><operator>-&gt;</operator><name>t_self</name></name> <operator>=</operator> <name><name>newTuple</name><operator>-&gt;</operator><name>t_data</name><operator>-&gt;</operator><name>t_ctid</name></name> <operator>=</operator>
					<name><name>origTuple</name><operator>-&gt;</operator><name>t_self</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>newTuple</name><operator>-&gt;</operator><name>t_tableOid</name></name> <operator>=</operator> <name><name>origTuple</name><operator>-&gt;</operator><name>t_tableOid</name></name></expr>;</expr_stmt>

				<expr_stmt><expr><call><name>HeapTupleHeaderSetXmin</name><argument_list>(<argument><expr><name><name>newTuple</name><operator>-&gt;</operator><name>t_data</name></name></expr></argument>,
									   <argument><expr><call><name>HeapTupleHeaderGetRawXmin</name><argument_list>(<argument><expr><name><name>origTuple</name><operator>-&gt;</operator><name>t_data</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>HeapTupleHeaderSetCmin</name><argument_list>(<argument><expr><name><name>newTuple</name><operator>-&gt;</operator><name>t_data</name></name></expr></argument>,
									   <argument><expr><call><name>HeapTupleHeaderGetRawCommandId</name><argument_list>(<argument><expr><name><name>origTuple</name><operator>-&gt;</operator><name>t_data</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>HeapTupleHeaderSetXmax</name><argument_list>(<argument><expr><name><name>newTuple</name><operator>-&gt;</operator><name>t_data</name></name></expr></argument>,
									   <argument><expr><name>InvalidTransactionId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<if_stmt><if>if <condition>(<expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>resultRelationDesc</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>tdhasoid</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>srcRelationDesc</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>tdhasoid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>HeapTupleSetOid</name><argument_list>(<argument><expr><name>newTuple</name></expr></argument>, <argument><expr><call><name>HeapTupleGetOid</name><argument_list>(<argument><expr><name>origTuple</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>

				<expr_stmt><expr><name>slot</name> <operator>=</operator> <call><name>ExecStoreTuple</name><argument_list>(<argument><expr><name>newTuple</name></expr></argument>, <argument><expr><name>srcSlot</name></expr></argument>, <argument><expr><name>InvalidBuffer</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><call><name>free_conversion_map</name><argument_list>(<argument><expr><name>map</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>ExecProcessReturning</name><argument_list>(<argument><expr><name><name>returningRelInfo</name><operator>-&gt;</operator><name>ri_projectReturning</name></name></expr></argument>,
									  <argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>resultRelationDesc</name></expr></argument>)</argument_list></call></expr></argument>,
									  <argument><expr><name>slot</name></expr></argument>, <argument><expr><name>planSlot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* ----------------------------------------------------------------
 *		ExecDelete
 *
 *		DELETE is like UPDATE, except that we delete the tuple and no
 *		index modifications are needed.
 *
 *		When deleting from a table, tupleid identifies the tuple to
 *		delete and oldtuple is NULL.  When deleting from a view,
 *		oldtuple is passed to the INSTEAD OF triggers and identifies
 *		what to delete, and tupleid is invalid.  When deleting from a
 *		foreign table, tupleid is invalid; the FDW has to figure out
 *		which row to delete using data from the planSlot.  oldtuple is
 *		passed to foreign table triggers; it is NULL when the foreign
 *		table has no relevant triggers.  We use tupleDeleted to indicate
 *		whether the tuple is actually deleted, callers can use it to
 *		decide whether to continue the operation.  When this DELETE is a
 *		part of an UPDATE of partition-key, then the slot returned by
 *		EvalPlanQual() is passed back using output parameter epqslot.
 *
 *		Returns RETURNING result if any, otherwise NULL.
 * ----------------------------------------------------------------
 */</comment>
<function><type><specifier>static</specifier> <name>TupleTableSlot</name> <modifier>*</modifier></type>
<name>ExecDelete</name><parameter_list>(<parameter><decl><type><name>ModifyTableState</name> <modifier>*</modifier></type><name>mtstate</name></decl></parameter>,
		   <parameter><decl><type><name>ItemPointer</name></type> <name>tupleid</name></decl></parameter>,
		   <parameter><decl><type><name>HeapTuple</name></type> <name>oldtuple</name></decl></parameter>,
		   <parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>planSlot</name></decl></parameter>,
		   <parameter><decl><type><name>EPQState</name> <modifier>*</modifier></type><name>epqstate</name></decl></parameter>,
		   <parameter><decl><type><name>EState</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>,
		   <parameter><decl><type><name>bool</name></type> <name>processReturning</name></decl></parameter>,
		   <parameter><decl><type><name>bool</name></type> <name>canSetTag</name></decl></parameter>,
		   <parameter><decl><type><name>bool</name></type> <name>changingPart</name></decl></parameter>,
		   <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>tupleDeleted</name></decl></parameter>,
		   <parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier><modifier>*</modifier></type><name>epqslot</name></decl></parameter>,
		   <parameter><decl><type><name>bool</name></type> <name>splitUpdate</name></decl></parameter> <comment type="block">/* POLAR px */</comment>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ResultRelInfo</name> <modifier>*</modifier></type><name>resultRelInfo</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>resultRelationDesc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HTSU_Result</name></type> <name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapUpdateFailureData</name></type> <name>hufd</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TransitionCaptureState</name> <modifier>*</modifier></type><name>ar_delete_trig_tcs</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>tupleDeleted</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><operator>*</operator><name>tupleDeleted</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * get information on the (current) result relation
	 */</comment>
	<expr_stmt><expr><name>resultRelInfo</name> <operator>=</operator> <name><name>estate</name><operator>-&gt;</operator><name>es_result_relation_info</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>resultRelationDesc</name> <operator>=</operator> <name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_RelationDesc</name></name></expr>;</expr_stmt>

	<comment type="block">/* BEFORE ROW DELETE Triggers */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_TrigDesc</name></name> <operator>&amp;&amp;</operator>
		<name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_TrigDesc</name><operator>-&gt;</operator><name>trig_delete_before_row</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>bool</name></type>		<name>dodelete</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>dodelete</name> <operator>=</operator> <call><name>ExecBRDeleteTriggers</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name>epqstate</name></expr></argument>, <argument><expr><name>resultRelInfo</name></expr></argument>,
										<argument><expr><name>tupleid</name></expr></argument>, <argument><expr><name>oldtuple</name></expr></argument>, <argument><expr><name>epqslot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>dodelete</name></expr>)</condition><block type="pseudo"><block_content>			<comment type="block">/* "do nothing" */</comment>
			<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* INSTEAD OF ROW DELETE Triggers */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_TrigDesc</name></name> <operator>&amp;&amp;</operator>
		<name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_TrigDesc</name><operator>-&gt;</operator><name>trig_delete_instead_row</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>bool</name></type>		<name>dodelete</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>oldtuple</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>dodelete</name> <operator>=</operator> <call><name>ExecIRDeleteTriggers</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name>resultRelInfo</name></expr></argument>, <argument><expr><name>oldtuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>dodelete</name></expr>)</condition><block type="pseudo"><block_content>			<comment type="block">/* "do nothing" */</comment>
			<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_FdwRoutine</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tuple</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * delete from foreign table: let the FDW do it
		 *
		 * We offer the trigger tuple slot as a place to store RETURNING data,
		 * although the FDW can return some other slot if it wants.  Set up
		 * the slot's tupdesc so the FDW doesn't need to do that for itself.
		 */</comment>
		<expr_stmt><expr><name>slot</name> <operator>=</operator> <name><name>estate</name><operator>-&gt;</operator><name>es_trig_tuple_slot</name></name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>slot</name><operator>-&gt;</operator><name>tts_tupleDescriptor</name></name> <operator>!=</operator> <call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>resultRelationDesc</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ExecSetSlotDescriptor</name><argument_list>(<argument><expr><name>slot</name></expr></argument>, <argument><expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>resultRelationDesc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>slot</name> <operator>=</operator> <call><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_FdwRoutine</name><operator>-&gt;</operator><name>ExecForeignDelete</name></name><argument_list>(<argument><expr><name>estate</name></expr></argument>,
															   <argument><expr><name>resultRelInfo</name></expr></argument>,
															   <argument><expr><name>slot</name></expr></argument>,
															   <argument><expr><name>planSlot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>slot</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>		<comment type="block">/* "do nothing" */</comment>
			<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * RETURNING expressions might reference the tableoid column, so
		 * initialize t_tableOid before evaluating them.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>slot</name><operator>-&gt;</operator><name>tts_isempty</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ExecStoreAllNullTuple</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>ExecMaterializeSlot</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>tuple</name><operator>-&gt;</operator><name>t_tableOid</name></name> <operator>=</operator> <call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>resultRelationDesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/*
		 * delete the tuple
		 *
		 * Note: if es_crosscheck_snapshot isn't InvalidSnapshot, we check
		 * that the row to be deleted is visible to that snapshot, and throw a
		 * can't-serialize error if not. This is a special-case behavior
		 * needed for referential integrity updates in transaction-snapshot
		 * mode transactions.
		 */</comment>
<label><name>ldelete</name>:</label><empty_stmt>;</empty_stmt>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>heap_delete</name><argument_list>(<argument><expr><name>resultRelationDesc</name></expr></argument>, <argument><expr><name>tupleid</name></expr></argument>,
							 <argument><expr><name><name>estate</name><operator>-&gt;</operator><name>es_output_cid</name></name></expr></argument>,
							 <argument><expr><name><name>estate</name><operator>-&gt;</operator><name>es_crosscheck_snapshot</name></name></expr></argument>,
							 <argument><expr><name>true</name></expr></argument> <comment type="block">/* wait for commit */</comment> ,
							 <argument><expr><operator>&amp;</operator><name>hufd</name></expr></argument>,
							 <argument><expr><name>changingPart</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<switch>switch <condition>(<expr><name>result</name></expr>)</condition>
		<block>{<block_content>
			<case>case <expr><name>HeapTupleSelfUpdated</name></expr>:</case>

				<comment type="block">/*
				 * The target tuple was already updated or deleted by the
				 * current command, or by a later command in the current
				 * transaction.  The former case is possible in a join DELETE
				 * where multiple tuples join to the same target tuple. This
				 * is somewhat questionable, but Postgres has always allowed
				 * it: we just ignore additional deletion attempts.
				 *
				 * The latter case arises if the tuple is modified by a
				 * command in a BEFORE trigger, or perhaps by a command in a
				 * volatile function used in the query.  In such situations we
				 * should not ignore the deletion, but it is equally unsafe to
				 * proceed.  We don't want to discard the original DELETE
				 * while keeping the triggered actions based on its deletion;
				 * and it would be no better to allow the original DELETE
				 * while discarding updates that it triggered.  The row update
				 * carries some information that might be important according
				 * to business rules; so throwing an error is the only safe
				 * course.
				 *
				 * If a trigger actually intends this type of interaction, it
				 * can re-execute the DELETE and then return NULL to cancel
				 * the outer delete.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><name><name>hufd</name><operator>.</operator><name>cmax</name></name> <operator>!=</operator> <name><name>estate</name><operator>-&gt;</operator><name>es_output_cid</name></name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_TRIGGERED_DATA_CHANGE_VIOLATION</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"tuple to be updated was already modified by an operation triggered by the current command"</literal></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Consider using an AFTER trigger instead of a BEFORE trigger to propagate changes to other rows."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

				<comment type="block">/* Else, already deleted by self; nothing to do */</comment>

				<comment type="block">/* POLAR px */</comment>
				<comment type="block">/*-------
				 * In an scenario in which R(a,b) and S(a,b) have
				 *        R               S
				 *    ________         ________
				 *     (1, 1)           (1, 2)
				 *                      (1, 7)
				 *
				 *  An update query such as:
				 *   UPDATE R SET a = S.b  FROM S WHERE R.b = S.a;
				 *
				 *  will have an non-deterministic output. The tuple in R
				 * can be updated to (2,1) or (7,1).
				 * Since the introduction of SplitUpdate, these queries will
				 * send multiple requests to delete the same tuple. One of them
				 * will pass, but others will not. But there will also be
				 * multiple requests to insert a new version of the tuple, and
				 * we cannot cancel out those if the Delete cannot be
				 * performed. An error is reported in such scenario; otherwise
				 * you end up with multiple copies of the same row.
				 *-------
				 */</comment>
				<if_stmt><if>if <condition>(<expr><name>splitUpdate</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_IN_FAILED_SQL_TRANSACTION</name></expr></argument> )</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"multiple updates to a row by the same query is not allowed"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
				<comment type="block">/* POLAR end */</comment>
				<return>return <expr><name>NULL</name></expr>;</return>

			<case>case <expr><name>HeapTupleMayBeUpdated</name></expr>:</case>
				<break>break;</break>

			<case>case <expr><name>HeapTupleUpdated</name></expr>:</case>
				<if_stmt><if>if <condition>(<expr><call><name>IsolationUsesXactSnapshot</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_T_R_SERIALIZATION_FAILURE</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not serialize access due to concurrent update"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<if_stmt><if>if <condition>(<expr><call><name>ItemPointerIndicatesMovedPartitions</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>hufd</name><operator>.</operator><name>ctid</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_T_R_SERIALIZATION_FAILURE</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"tuple to be deleted was already moved to another partition due to concurrent update"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

				<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ItemPointerEquals</name><argument_list>(<argument><expr><name>tupleid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>hufd</name><operator>.</operator><name>ctid</name></name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<decl_stmt><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>my_epqslot</name></decl>;</decl_stmt>

					<expr_stmt><expr><name>my_epqslot</name> <operator>=</operator> <call><name>EvalPlanQual</name><argument_list>(<argument><expr><name>estate</name></expr></argument>,
											  <argument><expr><name>epqstate</name></expr></argument>,
											  <argument><expr><name>resultRelationDesc</name></expr></argument>,
											  <argument><expr><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_RangeTableIndex</name></name></expr></argument>,
											  <argument><expr><name>LockTupleExclusive</name></expr></argument>,
											  <argument><expr><operator>&amp;</operator><name><name>hufd</name><operator>.</operator><name>ctid</name></name></expr></argument>,
											  <argument><expr><name><name>hufd</name><operator>.</operator><name>xmax</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>TupIsNull</name><argument_list>(<argument><expr><name>my_epqslot</name></expr></argument>)</argument_list></call></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><operator>*</operator><name>tupleid</name> <operator>=</operator> <name><name>hufd</name><operator>.</operator><name>ctid</name></name></expr>;</expr_stmt>

						<comment type="block">/*
						 * If requested, skip delete and pass back the updated
						 * row.
						 */</comment>
						<if_stmt><if>if <condition>(<expr><name>epqslot</name></expr>)</condition>
						<block>{<block_content>
							<expr_stmt><expr><operator>*</operator><name>epqslot</name> <operator>=</operator> <name>my_epqslot</name></expr>;</expr_stmt>
							<return>return <expr><name>NULL</name></expr>;</return>
						</block_content>}</block></if>
						<else>else<block type="pseudo"><block_content>
							<goto>goto <name>ldelete</name>;</goto></block_content></block></else></if_stmt>
					</block_content>}</block></if></if_stmt>
				</block_content>}</block></if></if_stmt>
				<comment type="block">/* tuple already deleted; nothing to do */</comment>
				<return>return <expr><name>NULL</name></expr>;</return>

			<default>default:</default>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized heap_delete status: %u"</literal></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr><name>NULL</name></expr>;</return>
		</block_content>}</block></switch>

		<comment type="block">/*
		 * Note: Normally one would think that we have to delete index tuples
		 * associated with the heap tuple now...
		 *
		 * ... but in POSTGRES, we have no need to do this because VACUUM will
		 * take care of it later.  We can't delete index tuples immediately
		 * anyway, since the tuple is still visible to other transactions.
		 */</comment>
	</block_content>}</block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>canSetTag</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><operator>(</operator><name><name>estate</name><operator>-&gt;</operator><name>es_processed</name></name><operator>)</operator><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Tell caller that the delete actually happened. */</comment>
	<if_stmt><if>if <condition>(<expr><name>tupleDeleted</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><operator>*</operator><name>tupleDeleted</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * If this delete is the result of a partition key update that moved the
	 * tuple to a new partition, put this row into the transition OLD TABLE,
	 * if there is one. We need to do this separately for DELETE and INSERT
	 * because they happen on different tables.
	 */</comment>
	<expr_stmt><expr><name>ar_delete_trig_tcs</name> <operator>=</operator> <name><name>mtstate</name><operator>-&gt;</operator><name>mt_transition_capture</name></name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>mtstate</name><operator>-&gt;</operator><name>operation</name></name> <operator>==</operator> <name>CMD_UPDATE</name> <operator>&amp;&amp;</operator> <name><name>mtstate</name><operator>-&gt;</operator><name>mt_transition_capture</name></name>
		<operator>&amp;&amp;</operator> <name><name>mtstate</name><operator>-&gt;</operator><name>mt_transition_capture</name><operator>-&gt;</operator><name>tcs_update_old_table</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ExecARUpdateTriggers</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name>resultRelInfo</name></expr></argument>,
							 <argument><expr><name>tupleid</name></expr></argument>,
							 <argument><expr><name>oldtuple</name></expr></argument>,
							 <argument><expr><name>NULL</name></expr></argument>,
							 <argument><expr><name>NULL</name></expr></argument>,
							 <argument><expr><name><name>mtstate</name><operator>-&gt;</operator><name>mt_transition_capture</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * We've already captured the NEW TABLE row, so make sure any AR
		 * DELETE trigger fired below doesn't capture it again.
		 */</comment>
		<expr_stmt><expr><name>ar_delete_trig_tcs</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* AFTER ROW DELETE Triggers */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>splitUpdate</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ExecARDeleteTriggers</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name>resultRelInfo</name></expr></argument>, <argument><expr><name>tupleid</name></expr></argument>, <argument><expr><name>oldtuple</name></expr></argument>,
							 <argument><expr><name>ar_delete_trig_tcs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Process RETURNING if present and if requested */</comment>
	<if_stmt><if>if <condition>(<expr><name>processReturning</name> <operator>&amp;&amp;</operator> <name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_projectReturning</name></name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * We have to put the target tuple into a slot, which means first we
		 * gotta fetch it.  We can use the trigger tuple slot.
		 */</comment>
		<decl_stmt><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>rslot</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>HeapTupleData</name></type> <name>deltuple</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Buffer</name></type>		<name>delbuffer</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_FdwRoutine</name></name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* FDW must have provided a slot containing the deleted row */</comment>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>TupIsNull</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>delbuffer</name> <operator>=</operator> <name>InvalidBuffer</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><name>slot</name> <operator>=</operator> <name><name>estate</name><operator>-&gt;</operator><name>es_trig_tuple_slot</name></name></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>oldtuple</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>deltuple</name> <operator>=</operator> <operator>*</operator><name>oldtuple</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>delbuffer</name> <operator>=</operator> <name>InvalidBuffer</name></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<expr_stmt><expr><name><name>deltuple</name><operator>.</operator><name>t_self</name></name> <operator>=</operator> <operator>*</operator><name>tupleid</name></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>heap_fetch</name><argument_list>(<argument><expr><name>resultRelationDesc</name></expr></argument>, <argument><expr><name>SnapshotAny</name></expr></argument>,
								<argument><expr><operator>&amp;</operator><name>deltuple</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>delbuffer</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"failed to fetch deleted tuple for DELETE RETURNING"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block></else></if_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>slot</name><operator>-&gt;</operator><name>tts_tupleDescriptor</name></name> <operator>!=</operator> <call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>resultRelationDesc</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ExecSetSlotDescriptor</name><argument_list>(<argument><expr><name>slot</name></expr></argument>, <argument><expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>resultRelationDesc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><call><name>ExecStoreTuple</name><argument_list>(<argument><expr><operator>&amp;</operator><name>deltuple</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>, <argument><expr><name>InvalidBuffer</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<expr_stmt><expr><name>rslot</name> <operator>=</operator> <call><name>ExecProcessReturning</name><argument_list>(<argument><expr><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_projectReturning</name></name></expr></argument>,
									 <argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>resultRelationDesc</name></expr></argument>)</argument_list></call></expr></argument>,
									 <argument><expr><name>slot</name></expr></argument>, <argument><expr><name>planSlot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Before releasing the target tuple again, make sure rslot has a
		 * local copy of any pass-by-reference values.
		 */</comment>
		<expr_stmt><expr><call><name>ExecMaterializeSlot</name><argument_list>(<argument><expr><name>rslot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>ExecClearTuple</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>BufferIsValid</name><argument_list>(<argument><expr><name>delbuffer</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ReleaseBuffer</name><argument_list>(<argument><expr><name>delbuffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<return>return <expr><name>rslot</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* ----------------------------------------------------------------
 *		ExecUpdate
 *
 *		note: we can't run UPDATE queries with transactions
 *		off because UPDATEs are actually INSERTs and our
 *		scan will mistakenly loop forever, updating the tuple
 *		it just inserted..  This should be fixed but until it
 *		is, we don't want to get stuck in an infinite loop
 *		which corrupts your database..
 *
 *		When updating a table, tupleid identifies the tuple to
 *		update and oldtuple is NULL.  When updating a view, oldtuple
 *		is passed to the INSTEAD OF triggers and identifies what to
 *		update, and tupleid is invalid.  When updating a foreign table,
 *		tupleid is invalid; the FDW has to figure out which row to
 *		update using data from the planSlot.  oldtuple is passed to
 *		foreign table triggers; it is NULL when the foreign table has
 *		no relevant triggers.
 *
 *		Returns RETURNING result if any, otherwise NULL.
 * ----------------------------------------------------------------
 */</comment>
<function><type><specifier>static</specifier> <name>TupleTableSlot</name> <modifier>*</modifier></type>
<name>ExecUpdate</name><parameter_list>(<parameter><decl><type><name>ModifyTableState</name> <modifier>*</modifier></type><name>mtstate</name></decl></parameter>,
		   <parameter><decl><type><name>ItemPointer</name></type> <name>tupleid</name></decl></parameter>,
		   <parameter><decl><type><name>HeapTuple</name></type> <name>oldtuple</name></decl></parameter>,
		   <parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl></parameter>,
		   <parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>planSlot</name></decl></parameter>,
		   <parameter><decl><type><name>EPQState</name> <modifier>*</modifier></type><name>epqstate</name></decl></parameter>,
		   <parameter><decl><type><name>EState</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>,
		   <parameter><decl><type><name>bool</name></type> <name>canSetTag</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ResultRelInfo</name> <modifier>*</modifier></type><name>resultRelInfo</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>resultRelationDesc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HTSU_Result</name></type> <name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapUpdateFailureData</name></type> <name>hufd</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>recheckIndexes</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleConversionMap</name> <modifier>*</modifier></type><name>saved_tcs_map</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * abort the operation if not running transactions
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>IsBootstrapProcessingMode</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cannot UPDATE during bootstrap"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * get the heap tuple out of the tuple table slot, making sure we have a
	 * writable copy
	 */</comment>
	<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>ExecMaterializeSlot</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * get information on the (current) result relation
	 */</comment>
	<expr_stmt><expr><name>resultRelInfo</name> <operator>=</operator> <name><name>estate</name><operator>-&gt;</operator><name>es_result_relation_info</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>resultRelationDesc</name> <operator>=</operator> <name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_RelationDesc</name></name></expr>;</expr_stmt>

	<comment type="block">/* BEFORE ROW UPDATE Triggers */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_TrigDesc</name></name> <operator>&amp;&amp;</operator>
		<name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_TrigDesc</name><operator>-&gt;</operator><name>trig_update_before_row</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>slot</name> <operator>=</operator> <call><name>ExecBRUpdateTriggers</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name>epqstate</name></expr></argument>, <argument><expr><name>resultRelInfo</name></expr></argument>,
									<argument><expr><name>tupleid</name></expr></argument>, <argument><expr><name>oldtuple</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>slot</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>		<comment type="block">/* "do nothing" */</comment>
			<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

		<comment type="block">/* trigger might have changed tuple */</comment>
		<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>ExecMaterializeSlot</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* INSTEAD OF ROW UPDATE Triggers */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_TrigDesc</name></name> <operator>&amp;&amp;</operator>
		<name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_TrigDesc</name><operator>-&gt;</operator><name>trig_update_instead_row</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>slot</name> <operator>=</operator> <call><name>ExecIRUpdateTriggers</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name>resultRelInfo</name></expr></argument>,
									<argument><expr><name>oldtuple</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>slot</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>		<comment type="block">/* "do nothing" */</comment>
			<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

		<comment type="block">/* trigger might have changed tuple */</comment>
		<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>ExecMaterializeSlot</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_FdwRoutine</name></name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * update in foreign table: let the FDW do it
		 */</comment>
		<expr_stmt><expr><name>slot</name> <operator>=</operator> <call><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_FdwRoutine</name><operator>-&gt;</operator><name>ExecForeignUpdate</name></name><argument_list>(<argument><expr><name>estate</name></expr></argument>,
															   <argument><expr><name>resultRelInfo</name></expr></argument>,
															   <argument><expr><name>slot</name></expr></argument>,
															   <argument><expr><name>planSlot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>slot</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>		<comment type="block">/* "do nothing" */</comment>
			<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

		<comment type="block">/* FDW might have changed tuple */</comment>
		<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>ExecMaterializeSlot</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * AFTER ROW Triggers or RETURNING expressions might reference the
		 * tableoid column, so initialize t_tableOid before evaluating them.
		 */</comment>
		<expr_stmt><expr><name><name>tuple</name><operator>-&gt;</operator><name>t_tableOid</name></name> <operator>=</operator> <call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>resultRelationDesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<decl_stmt><decl><type><name>LockTupleMode</name></type> <name>lockmode</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>partition_constraint_failed</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * Constraints might reference the tableoid column, so initialize
		 * t_tableOid before evaluating them.
		 */</comment>
		<expr_stmt><expr><name><name>tuple</name><operator>-&gt;</operator><name>t_tableOid</name></name> <operator>=</operator> <call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>resultRelationDesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Check any RLS UPDATE WITH CHECK policies
		 *
		 * If we generate a new candidate tuple after EvalPlanQual testing, we
		 * must loop back here and recheck any RLS policies and constraints.
		 * (We don't need to redo triggers, however.  If there are any BEFORE
		 * triggers then trigger.c will have done heap_lock_tuple to lock the
		 * correct tuple, so there's no need to do them again.)
		 */</comment>
<label><name>lreplace</name>:</label><empty_stmt>;</empty_stmt>

		<comment type="block">/*
		 * If partition constraint fails, this row might get moved to another
		 * partition, in which case we should check the RLS CHECK policy just
		 * before inserting into the new partition, rather than doing it here.
		 * This is because a trigger on that partition might again change the
		 * row.  So skip the WCO checks if the partition constraint fails.
		 */</comment>
		<expr_stmt><expr><name>partition_constraint_failed</name> <operator>=</operator>
			<name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_PartitionCheck</name></name> <operator>&amp;&amp;</operator>
			<operator>!</operator><call><name>ExecPartitionCheck</name><argument_list>(<argument><expr><name>resultRelInfo</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>, <argument><expr><name>estate</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>partition_constraint_failed</name> <operator>&amp;&amp;</operator>
			<name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_WithCheckOptions</name></name> <operator>!=</operator> <name>NIL</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * ExecWithCheckOptions() will skip any WCOs which are not of the
			 * kind we are looking for at this point.
			 */</comment>
			<expr_stmt><expr><call><name>ExecWithCheckOptions</name><argument_list>(<argument><expr><name>WCO_RLS_UPDATE_CHECK</name></expr></argument>,
								 <argument><expr><name>resultRelInfo</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>, <argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * If a partition check failed, try to move the row into the right
		 * partition.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>partition_constraint_failed</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>bool</name></type>		<name>tuple_deleted</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>ret_slot</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>orig_slot</name> <init>= <expr><name>slot</name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>epqslot</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>PartitionTupleRouting</name> <modifier>*</modifier></type><name>proute</name> <init>= <expr><name><name>mtstate</name><operator>-&gt;</operator><name>mt_partition_tuple_routing</name></name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int</name></type>			<name>map_index</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>TupleConversionMap</name> <modifier>*</modifier></type><name>tupconv_map</name></decl>;</decl_stmt>

			<comment type="block">/*
			 * Disallow an INSERT ON CONFLICT DO UPDATE that causes the
			 * original row to migrate to a different partition.  Maybe this
			 * can be implemented some day, but it seems a fringe feature with
			 * little redeeming value.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><operator>(</operator><operator>(</operator><name>ModifyTable</name> <operator>*</operator><operator>)</operator> <name><name>mtstate</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>plan</name></name><operator>)</operator><operator>-&gt;</operator><name>onConflictAction</name> <operator>==</operator> <name>ONCONFLICT_UPDATE</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid ON UPDATE specification"</literal></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"The result tuple would appear in a different partition than the original tuple."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<comment type="block">/*
			 * When an UPDATE is run on a leaf partition, we will not have
			 * partition tuple routing set up. In that case, fail with
			 * partition constraint violation error.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name>proute</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ExecPartitionCheckEmitError</name><argument_list>(<argument><expr><name>resultRelInfo</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>, <argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<comment type="block">/*
			 * Row movement, part 1.  Delete the tuple, but skip RETURNING
			 * processing. We want to return rows from INSERT.
			 */</comment>
			<expr_stmt><expr><call><name>ExecDelete</name><argument_list>(<argument><expr><name>mtstate</name></expr></argument>, <argument><expr><name>tupleid</name></expr></argument>, <argument><expr><name>oldtuple</name></expr></argument>, <argument><expr><name>planSlot</name></expr></argument>, <argument><expr><name>epqstate</name></expr></argument>,
					   <argument><expr><name>estate</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument> <comment type="block">/* canSetTag */</comment> ,
					   <argument><expr><name>true</name></expr></argument> <comment type="block">/* changingPart */</comment> , <argument><expr><operator>&amp;</operator><name>tuple_deleted</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>epqslot</name></expr></argument>, <argument><expr><name>false</name></expr></argument> <comment type="block">/* SplitUpdate */</comment>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * For some reason if DELETE didn't happen (e.g. trigger prevented
			 * it, or it was already deleted by self, or it was concurrently
			 * deleted by another transaction), then we should skip the insert
			 * as well; otherwise, an UPDATE could cause an increase in the
			 * total number of rows across all partitions, which is clearly
			 * wrong.
			 *
			 * For a normal UPDATE, the case where the tuple has been the
			 * subject of a concurrent UPDATE or DELETE would be handled by
			 * the EvalPlanQual machinery, but for an UPDATE that we've
			 * translated into a DELETE from this partition and an INSERT into
			 * some other partition, that's not available, because CTID chains
			 * can't span relation boundaries.  We mimic the semantics to a
			 * limited extent by skipping the INSERT if the DELETE fails to
			 * find a tuple. This ensures that two concurrent attempts to
			 * UPDATE the same tuple at the same time can't turn one tuple
			 * into two, and that an UPDATE of a just-deleted tuple can't
			 * resurrect it.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>tuple_deleted</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/*
				 * epqslot will be typically NULL.  But when ExecDelete()
				 * finds that another transaction has concurrently updated the
				 * same row, it re-fetches the row, skips the delete, and
				 * epqslot is set to the re-fetched tuple slot. In that case,
				 * we need to do all the checks again.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><call><name>TupIsNull</name><argument_list>(<argument><expr><name>epqslot</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if>
				<else>else
				<block>{<block_content>
					<expr_stmt><expr><name>slot</name> <operator>=</operator> <call><name>ExecFilterJunk</name><argument_list>(<argument><expr><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_junkFilter</name></name></expr></argument>, <argument><expr><name>epqslot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>ExecMaterializeSlot</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<goto>goto <name>lreplace</name>;</goto>
				</block_content>}</block></else></if_stmt>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/*
			 * Updates set the transition capture map only when a new subplan
			 * is chosen.  But for inserts, it is set for each row. So after
			 * INSERT, we need to revert back to the map created for UPDATE;
			 * otherwise the next UPDATE will incorrectly use the one created
			 * for INSERT.  So first save the one created for UPDATE.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>mtstate</name><operator>-&gt;</operator><name>mt_transition_capture</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>saved_tcs_map</name> <operator>=</operator> <name><name>mtstate</name><operator>-&gt;</operator><name>mt_transition_capture</name><operator>-&gt;</operator><name>tcs_map</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<comment type="block">/*
			 * resultRelInfo is one of the per-subplan resultRelInfos.  So we
			 * should convert the tuple into root's tuple descriptor, since
			 * ExecInsert() starts the search from root.  The tuple conversion
			 * map list is in the order of mtstate-&gt;resultRelInfo[], so to
			 * retrieve the one for this resultRel, we need to know the
			 * position of the resultRel in mtstate-&gt;resultRelInfo[].
			 */</comment>
			<expr_stmt><expr><name>map_index</name> <operator>=</operator> <name>resultRelInfo</name> <operator>-</operator> <name><name>mtstate</name><operator>-&gt;</operator><name>resultRelInfo</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>map_index</name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>map_index</name> <operator>&lt;</operator> <name><name>mtstate</name><operator>-&gt;</operator><name>mt_nplans</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>tupconv_map</name> <operator>=</operator> <call><name>tupconv_map_for_subplan</name><argument_list>(<argument><expr><name>mtstate</name></expr></argument>, <argument><expr><name>map_index</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>ConvertPartitionTupleSlot</name><argument_list>(<argument><expr><name>tupconv_map</name></expr></argument>,
											  <argument><expr><name>tuple</name></expr></argument>,
											  <argument><expr><name><name>proute</name><operator>-&gt;</operator><name>root_tuple_slot</name></name></expr></argument>,
											  <argument><expr><operator>&amp;</operator><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * Prepare for tuple routing, making it look like we're inserting
			 * into the root.
			 */</comment>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>mtstate</name><operator>-&gt;</operator><name>rootResultRelInfo</name></name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>slot</name> <operator>=</operator> <call><name>ExecPrepareTupleRouting</name><argument_list>(<argument><expr><name>mtstate</name></expr></argument>, <argument><expr><name>estate</name></expr></argument>, <argument><expr><name>proute</name></expr></argument>,
										   <argument><expr><name><name>mtstate</name><operator>-&gt;</operator><name>rootResultRelInfo</name></name></expr></argument>, <argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name>ret_slot</name> <operator>=</operator> <call><name>ExecInsert</name><argument_list>(<argument><expr><name>mtstate</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>, <argument><expr><name>planSlot</name></expr></argument>,
								  <argument><expr><name>orig_slot</name></expr></argument>, <argument><expr><name>resultRelInfo</name></expr></argument>,
								  <argument><expr><name>estate</name></expr></argument>, <argument><expr><name>canSetTag</name></expr></argument>, <argument><expr><name>false</name></expr></argument> <comment type="block">/* POLAR px */</comment>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* Revert ExecPrepareTupleRouting's node change. */</comment>
			<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>es_result_relation_info</name></name> <operator>=</operator> <name>resultRelInfo</name></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>mtstate</name><operator>-&gt;</operator><name>mt_transition_capture</name></name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name><name>mtstate</name><operator>-&gt;</operator><name>mt_transition_capture</name><operator>-&gt;</operator><name>tcs_original_insert_tuple</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>mtstate</name><operator>-&gt;</operator><name>mt_transition_capture</name><operator>-&gt;</operator><name>tcs_map</name></name> <operator>=</operator> <name>saved_tcs_map</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<return>return <expr><name>ret_slot</name></expr>;</return>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * Check the constraints of the tuple.  We've already checked the
		 * partition constraint above; however, we must still ensure the tuple
		 * passes all other constraints, so we will call ExecConstraints() and
		 * have it validate all remaining checks.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>resultRelationDesc</name><operator>-&gt;</operator><name>rd_att</name><operator>-&gt;</operator><name>constr</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ExecConstraints</name><argument_list>(<argument><expr><name>resultRelInfo</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>, <argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * replace the heap tuple
		 *
		 * Note: if es_crosscheck_snapshot isn't InvalidSnapshot, we check
		 * that the row to be updated is visible to that snapshot, and throw a
		 * can't-serialize error if not. This is a special-case behavior
		 * needed for referential integrity updates in transaction-snapshot
		 * mode transactions.
		 */</comment>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>heap_update</name><argument_list>(<argument><expr><name>resultRelationDesc</name></expr></argument>, <argument><expr><name>tupleid</name></expr></argument>, <argument><expr><name>tuple</name></expr></argument>,
							 <argument><expr><name><name>estate</name><operator>-&gt;</operator><name>es_output_cid</name></name></expr></argument>,
							 <argument><expr><name><name>estate</name><operator>-&gt;</operator><name>es_crosscheck_snapshot</name></name></expr></argument>,
							 <argument><expr><name>true</name></expr></argument> <comment type="block">/* wait for commit */</comment> ,
							 <argument><expr><operator>&amp;</operator><name>hufd</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<switch>switch <condition>(<expr><name>result</name></expr>)</condition>
		<block>{<block_content>
			<case>case <expr><name>HeapTupleSelfUpdated</name></expr>:</case>

				<comment type="block">/*
				 * The target tuple was already updated or deleted by the
				 * current command, or by a later command in the current
				 * transaction.  The former case is possible in a join UPDATE
				 * where multiple tuples join to the same target tuple. This
				 * is pretty questionable, but Postgres has always allowed it:
				 * we just execute the first update action and ignore
				 * additional update attempts.
				 *
				 * The latter case arises if the tuple is modified by a
				 * command in a BEFORE trigger, or perhaps by a command in a
				 * volatile function used in the query.  In such situations we
				 * should not ignore the update, but it is equally unsafe to
				 * proceed.  We don't want to discard the original UPDATE
				 * while keeping the triggered actions based on it; and we
				 * have no principled way to merge this update with the
				 * previous ones.  So throwing an error is the only safe
				 * course.
				 *
				 * If a trigger actually intends this type of interaction, it
				 * can re-execute the UPDATE (assuming it can figure out how)
				 * and then return NULL to cancel the outer update.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><name><name>hufd</name><operator>.</operator><name>cmax</name></name> <operator>!=</operator> <name><name>estate</name><operator>-&gt;</operator><name>es_output_cid</name></name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_TRIGGERED_DATA_CHANGE_VIOLATION</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"tuple to be updated was already modified by an operation triggered by the current command"</literal></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Consider using an AFTER trigger instead of a BEFORE trigger to propagate changes to other rows."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

				<comment type="block">/* Else, already updated by self; nothing to do */</comment>
				<return>return <expr><name>NULL</name></expr>;</return>

			<case>case <expr><name>HeapTupleMayBeUpdated</name></expr>:</case>
				<break>break;</break>

			<case>case <expr><name>HeapTupleUpdated</name></expr>:</case>
				<if_stmt><if>if <condition>(<expr><call><name>IsolationUsesXactSnapshot</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_T_R_SERIALIZATION_FAILURE</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not serialize access due to concurrent update"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<if_stmt><if>if <condition>(<expr><call><name>ItemPointerIndicatesMovedPartitions</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>hufd</name><operator>.</operator><name>ctid</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_T_R_SERIALIZATION_FAILURE</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"tuple to be updated was already moved to another partition due to concurrent update"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

				<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ItemPointerEquals</name><argument_list>(<argument><expr><name>tupleid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>hufd</name><operator>.</operator><name>ctid</name></name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<decl_stmt><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>epqslot</name></decl>;</decl_stmt>

					<expr_stmt><expr><name>epqslot</name> <operator>=</operator> <call><name>EvalPlanQual</name><argument_list>(<argument><expr><name>estate</name></expr></argument>,
										   <argument><expr><name>epqstate</name></expr></argument>,
										   <argument><expr><name>resultRelationDesc</name></expr></argument>,
										   <argument><expr><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_RangeTableIndex</name></name></expr></argument>,
										   <argument><expr><name>lockmode</name></expr></argument>,
										   <argument><expr><operator>&amp;</operator><name><name>hufd</name><operator>.</operator><name>ctid</name></name></expr></argument>,
										   <argument><expr><name><name>hufd</name><operator>.</operator><name>xmax</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>TupIsNull</name><argument_list>(<argument><expr><name>epqslot</name></expr></argument>)</argument_list></call></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><operator>*</operator><name>tupleid</name> <operator>=</operator> <name><name>hufd</name><operator>.</operator><name>ctid</name></name></expr>;</expr_stmt>
						<expr_stmt><expr><name>slot</name> <operator>=</operator> <call><name>ExecFilterJunk</name><argument_list>(<argument><expr><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_junkFilter</name></name></expr></argument>, <argument><expr><name>epqslot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>ExecMaterializeSlot</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<goto>goto <name>lreplace</name>;</goto>
					</block_content>}</block></if></if_stmt>
				</block_content>}</block></if></if_stmt>
				<comment type="block">/* tuple already deleted; nothing to do */</comment>
				<return>return <expr><name>NULL</name></expr>;</return>

			<default>default:</default>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized heap_update status: %u"</literal></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr><name>NULL</name></expr>;</return>
		</block_content>}</block></switch>

		<comment type="block">/*
		 * Note: instead of having to update the old index tuples associated
		 * with the heap tuple, all we do is form and insert new index tuples.
		 * This is because UPDATEs are actually DELETEs and INSERTs, and index
		 * tuple deletion is done later by VACUUM (see notes in ExecDelete).
		 * All we do here is insert new index tuples.  -cim 9/27/89
		 */</comment>

		<comment type="block">/*
		 * insert index entries for tuple
		 *
		 * Note: heap_update returns the tid (location) of the new tuple in
		 * the t_self field.
		 *
		 * If it's a HOT update, we mustn't insert new index entries.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_NumIndices</name></name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>HeapTupleIsHeapOnly</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>recheckIndexes</name> <operator>=</operator> <call><name>ExecInsertIndexTuples</name><argument_list>(<argument><expr><name>slot</name></expr></argument>, <argument><expr><operator>&amp;</operator><operator>(</operator><name><name>tuple</name><operator>-&gt;</operator><name>t_self</name></name><operator>)</operator></expr></argument>,
												   <argument><expr><name>estate</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>canSetTag</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><operator>(</operator><name><name>estate</name><operator>-&gt;</operator><name>es_processed</name></name><operator>)</operator><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* AFTER ROW UPDATE Triggers */</comment>
	<expr_stmt><expr><call><name>ExecARUpdateTriggers</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name>resultRelInfo</name></expr></argument>, <argument><expr><name>tupleid</name></expr></argument>, <argument><expr><name>oldtuple</name></expr></argument>, <argument><expr><name>tuple</name></expr></argument>,
						 <argument><expr><name>recheckIndexes</name></expr></argument>,
						 <argument><expr><ternary><condition><expr><name><name>mtstate</name><operator>-&gt;</operator><name>operation</name></name> <operator>==</operator> <name>CMD_INSERT</name></expr> ?</condition><then>
						 <expr><name><name>mtstate</name><operator>-&gt;</operator><name>mt_oc_transition_capture</name></name></expr> </then><else>:
						 <expr><name><name>mtstate</name><operator>-&gt;</operator><name>mt_transition_capture</name></name></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>list_free</name><argument_list>(<argument><expr><name>recheckIndexes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Check any WITH CHECK OPTION constraints from parent views.  We are
	 * required to do this after testing all constraints and uniqueness
	 * violations per the SQL spec, so we do it after actually updating the
	 * record in the heap and all indexes.
	 *
	 * ExecWithCheckOptions() will skip any WCOs which are not of the kind we
	 * are looking for at this point.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_WithCheckOptions</name></name> <operator>!=</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ExecWithCheckOptions</name><argument_list>(<argument><expr><name>WCO_VIEW_CHECK</name></expr></argument>, <argument><expr><name>resultRelInfo</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>, <argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Process RETURNING if present */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_projectReturning</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><call><name>ExecProcessReturning</name><argument_list>(<argument><expr><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_projectReturning</name></name></expr></argument>,
									<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>resultRelationDesc</name></expr></argument>)</argument_list></call></expr></argument>,
									<argument><expr><name>slot</name></expr></argument>, <argument><expr><name>planSlot</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

	<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * ExecOnConflictUpdate --- execute UPDATE of INSERT ON CONFLICT DO UPDATE
 *
 * Try to lock tuple for update as part of speculative insertion.  If
 * a qual originating from ON CONFLICT DO UPDATE is satisfied, update
 * (but still lock row, even though it may not satisfy estate's
 * snapshot).
 *
 * Returns true if we're done (with or without an update), or false if
 * the caller must retry the INSERT from scratch.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>ExecOnConflictUpdate</name><parameter_list>(<parameter><decl><type><name>ModifyTableState</name> <modifier>*</modifier></type><name>mtstate</name></decl></parameter>,
					 <parameter><decl><type><name>ResultRelInfo</name> <modifier>*</modifier></type><name>resultRelInfo</name></decl></parameter>,
					 <parameter><decl><type><name>ItemPointer</name></type> <name>conflictTid</name></decl></parameter>,
					 <parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>planSlot</name></decl></parameter>,
					 <parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>excludedSlot</name></decl></parameter>,
					 <parameter><decl><type><name>EState</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>,
					 <parameter><decl><type><name>bool</name></type> <name>canSetTag</name></decl></parameter>,
					 <parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier><modifier>*</modifier></type><name>returning</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ExprContext</name> <modifier>*</modifier></type><name>econtext</name> <init>= <expr><name><name>mtstate</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>ps_ExprContext</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>relation</name> <init>= <expr><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_RelationDesc</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ExprState</name>  <modifier>*</modifier></type><name>onConflictSetWhere</name> <init>= <expr><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_onConflict</name><operator>-&gt;</operator><name>oc_WhereClause</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTupleData</name></type> <name>tuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapUpdateFailureData</name></type> <name>hufd</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>LockTupleMode</name></type> <name>lockmode</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HTSU_Result</name></type> <name>test</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Buffer</name></type>		<name>buffer</name></decl>;</decl_stmt>

	<comment type="block">/* Determine lock mode to use */</comment>
	<expr_stmt><expr><name>lockmode</name> <operator>=</operator> <call><name>ExecUpdateLockMode</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name>resultRelInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Lock tuple for update.  Don't follow updates when tuple cannot be
	 * locked without doing so.  A row locking conflict here means our
	 * previous conclusion that the tuple is conclusively committed is not
	 * true anymore.
	 */</comment>
	<expr_stmt><expr><name><name>tuple</name><operator>.</operator><name>t_self</name></name> <operator>=</operator> <operator>*</operator><name>conflictTid</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>test</name> <operator>=</operator> <call><name>heap_lock_tuple</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tuple</name></expr></argument>, <argument><expr><name><name>estate</name><operator>-&gt;</operator><name>es_output_cid</name></name></expr></argument>,
						   <argument><expr><name>lockmode</name></expr></argument>, <argument><expr><name>LockWaitBlock</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>,
						   <argument><expr><operator>&amp;</operator><name>hufd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<switch>switch <condition>(<expr><name>test</name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>HeapTupleMayBeUpdated</name></expr>:</case>
			<comment type="block">/* success! */</comment>
			<break>break;</break>

		<case>case <expr><name>HeapTupleInvisible</name></expr>:</case>

			<comment type="block">/*
			 * This can occur when a just inserted tuple is updated again in
			 * the same command. E.g. because multiple rows with the same
			 * conflicting key values are inserted.
			 *
			 * This is somewhat similar to the ExecUpdate()
			 * HeapTupleSelfUpdated case.  We do not want to proceed because
			 * it would lead to the same row being updated a second time in
			 * some unspecified order, and in contrast to plain UPDATEs
			 * there's no historical behavior to break.
			 *
			 * It is the user's responsibility to prevent this situation from
			 * occurring.  These problems are why SQL-2003 similarly specifies
			 * that for SQL MERGE, an exception must be raised in the event of
			 * an attempt to update the same row twice.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>TransactionIdIsCurrentTransactionId</name><argument_list>(<argument><expr><call><name>HeapTupleHeaderGetXmin</name><argument_list>(<argument><expr><name><name>tuple</name><operator>.</operator><name>t_data</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_CARDINALITY_VIOLATION</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"ON CONFLICT DO UPDATE command cannot affect row a second time"</literal></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Ensure that no rows proposed for insertion within the same command have duplicate constrained values."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<comment type="block">/* This shouldn't happen */</comment>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"attempted to lock invisible tuple"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>HeapTupleSelfUpdated</name></expr>:</case>

			<comment type="block">/*
			 * This state should never be reached. As a dirty snapshot is used
			 * to find conflicting tuples, speculative insertion wouldn't have
			 * seen this row to conflict with.
			 */</comment>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unexpected self-updated tuple"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>HeapTupleUpdated</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><call><name>IsolationUsesXactSnapshot</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_T_R_SERIALIZATION_FAILURE</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not serialize access due to concurrent update"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<comment type="block">/*
			 * As long as we don't support an UPDATE of INSERT ON CONFLICT for
			 * a partitioned table we shouldn't reach to a case where tuple to
			 * be lock is moved to another partition due to concurrent update
			 * of the partition key.
			 */</comment>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>ItemPointerIndicatesMovedPartitions</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>hufd</name><operator>.</operator><name>ctid</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * Tell caller to try again from the very start.
			 *
			 * It does not make sense to use the usual EvalPlanQual() style
			 * loop here, as the new version of the row might not conflict
			 * anymore, or the conflicting tuple has actually been deleted.
			 */</comment>
			<expr_stmt><expr><call><name>ReleaseBuffer</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>false</name></expr>;</return>

		<default>default:</default>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized heap_lock_tuple status: %u"</literal></expr></argument>, <argument><expr><name>test</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></switch>

	<comment type="block">/*
	 * Success, the tuple is locked.
	 *
	 * Reset per-tuple memory context to free any expression evaluation
	 * storage allocated in the previous cycle.
	 */</comment>
	<expr_stmt><expr><call><name>ResetExprContext</name><argument_list>(<argument><expr><name>econtext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Verify that the tuple is visible to our MVCC snapshot if the current
	 * isolation level mandates that.
	 *
	 * It's not sufficient to rely on the check within ExecUpdate() as e.g.
	 * CONFLICT ... WHERE clause may prevent us from reaching that.
	 *
	 * This means we only ever continue when a new command in the current
	 * transaction could see the row, even though in READ COMMITTED mode the
	 * tuple will not be visible according to the current statement's
	 * snapshot.  This is in line with the way UPDATE deals with newer tuple
	 * versions.
	 */</comment>
	<expr_stmt><expr><call><name>ExecCheckHeapTupleVisible</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tuple</name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Store target's existing tuple in the state's dedicated slot */</comment>
	<expr_stmt><expr><call><name>ExecStoreTuple</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tuple</name></expr></argument>, <argument><expr><name><name>mtstate</name><operator>-&gt;</operator><name>mt_existing</name></name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Make tuple and any needed join variables available to ExecQual and
	 * ExecProject.  The EXCLUDED tuple is installed in ecxt_innertuple, while
	 * the target's existing tuple is installed in the scantuple.  EXCLUDED
	 * has been made to reference INNER_VAR in setrefs.c, but there is no
	 * other redirection.
	 */</comment>
	<expr_stmt><expr><name><name>econtext</name><operator>-&gt;</operator><name>ecxt_scantuple</name></name> <operator>=</operator> <name><name>mtstate</name><operator>-&gt;</operator><name>mt_existing</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>econtext</name><operator>-&gt;</operator><name>ecxt_innertuple</name></name> <operator>=</operator> <name>excludedSlot</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>econtext</name><operator>-&gt;</operator><name>ecxt_outertuple</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ExecQual</name><argument_list>(<argument><expr><name>onConflictSetWhere</name></expr></argument>, <argument><expr><name>econtext</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ReleaseBuffer</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>InstrCountFiltered1</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>mtstate</name><operator>-&gt;</operator><name>ps</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>true</name></expr>;</return>			<comment type="block">/* done with the tuple */</comment>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_WithCheckOptions</name></name> <operator>!=</operator> <name>NIL</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Check target's existing tuple against UPDATE-applicable USING
		 * security barrier quals (if any), enforced here as RLS checks/WCOs.
		 *
		 * The rewriter creates UPDATE RLS checks/WCOs for UPDATE security
		 * quals, and stores them as WCOs of "kind" WCO_RLS_CONFLICT_CHECK,
		 * but that's almost the extent of its special handling for ON
		 * CONFLICT DO UPDATE.
		 *
		 * The rewriter will also have associated UPDATE applicable straight
		 * RLS checks/WCOs for the benefit of the ExecUpdate() call that
		 * follows.  INSERTs and UPDATEs naturally have mutually exclusive WCO
		 * kinds, so there is no danger of spurious over-enforcement in the
		 * INSERT or UPDATE path.
		 */</comment>
		<expr_stmt><expr><call><name>ExecWithCheckOptions</name><argument_list>(<argument><expr><name>WCO_RLS_CONFLICT_CHECK</name></expr></argument>, <argument><expr><name>resultRelInfo</name></expr></argument>,
							 <argument><expr><name><name>mtstate</name><operator>-&gt;</operator><name>mt_existing</name></name></expr></argument>,
							 <argument><expr><name><name>mtstate</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>state</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Project the new tuple version */</comment>
	<expr_stmt><expr><call><name>ExecProject</name><argument_list>(<argument><expr><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_onConflict</name><operator>-&gt;</operator><name>oc_ProjInfo</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Note that it is possible that the target tuple has been modified in
	 * this session, after the above heap_lock_tuple. We choose to not error
	 * out in that case, in line with ExecUpdate's treatment of similar cases.
	 * This can happen if an UPDATE is triggered from within ExecQual(),
	 * ExecWithCheckOptions() or ExecProject() above, e.g. by selecting from a
	 * wCTE in the ON CONFLICT's SET.
	 */</comment>

	<comment type="block">/* Execute UPDATE with projection */</comment>
	<expr_stmt><expr><operator>*</operator><name>returning</name> <operator>=</operator> <call><name>ExecUpdate</name><argument_list>(<argument><expr><name>mtstate</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>tuple</name><operator>.</operator><name>t_self</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
							<argument><expr><name><name>mtstate</name><operator>-&gt;</operator><name>mt_conflproj</name></name></expr></argument>, <argument><expr><name>planSlot</name></expr></argument>,
							<argument><expr><operator>&amp;</operator><name><name>mtstate</name><operator>-&gt;</operator><name>mt_epqstate</name></name></expr></argument>, <argument><expr><name><name>mtstate</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>state</name></name></expr></argument>,
							<argument><expr><name>canSetTag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ReleaseBuffer</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * Process BEFORE EACH STATEMENT triggers
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>fireBSTriggers</name><parameter_list>(<parameter><decl><type><name>ModifyTableState</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ModifyTable</name> <modifier>*</modifier></type><name>plan</name> <init>= <expr><operator>(</operator><name>ModifyTable</name> <operator>*</operator><operator>)</operator> <name><name>node</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>plan</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ResultRelInfo</name> <modifier>*</modifier></type><name>resultRelInfo</name> <init>= <expr><name><name>node</name><operator>-&gt;</operator><name>resultRelInfo</name></name></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * If the node modifies a partitioned table, we must fire its triggers.
	 * Note that in that case, node-&gt;resultRelInfo points to the first leaf
	 * partition, not the root table.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>rootResultRelInfo</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>resultRelInfo</name> <operator>=</operator> <name><name>node</name><operator>-&gt;</operator><name>rootResultRelInfo</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<switch>switch <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>operation</name></name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>CMD_INSERT</name></expr>:</case>
			<expr_stmt><expr><call><name>ExecBSInsertTriggers</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>state</name></name></expr></argument>, <argument><expr><name>resultRelInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>plan</name><operator>-&gt;</operator><name>onConflictAction</name></name> <operator>==</operator> <name>ONCONFLICT_UPDATE</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ExecBSUpdateTriggers</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>state</name></name></expr></argument>,
									 <argument><expr><name>resultRelInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<break>break;</break>
		<case>case <expr><name>CMD_UPDATE</name></expr>:</case>
			<expr_stmt><expr><call><name>ExecBSUpdateTriggers</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>state</name></name></expr></argument>, <argument><expr><name>resultRelInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>CMD_DELETE</name></expr>:</case>
			<expr_stmt><expr><call><name>ExecBSDeleteTriggers</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>state</name></name></expr></argument>, <argument><expr><name>resultRelInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<default>default:</default>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unknown operation"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
	</block_content>}</block></switch>
</block_content>}</block></function>

<comment type="block">/*
 * Return the target rel ResultRelInfo.
 *
 * This relation is the same as :
 * - the relation for which we will fire AFTER STATEMENT triggers.
 * - the relation into whose tuple format all captured transition tuples must
 *   be converted.
 * - the root partitioned table.
 */</comment>
<function><type><specifier>static</specifier> <name>ResultRelInfo</name> <modifier>*</modifier></type>
<name>getTargetResultRelInfo</name><parameter_list>(<parameter><decl><type><name>ModifyTableState</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * Note that if the node modifies a partitioned table, node-&gt;resultRelInfo
	 * points to the first leaf partition, not the root table.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>rootResultRelInfo</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name><name>node</name><operator>-&gt;</operator><name>rootResultRelInfo</name></name></expr>;</return></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<return>return <expr><name><name>node</name><operator>-&gt;</operator><name>resultRelInfo</name></name></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Process AFTER EACH STATEMENT triggers
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>fireASTriggers</name><parameter_list>(<parameter><decl><type><name>ModifyTableState</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ModifyTable</name> <modifier>*</modifier></type><name>plan</name> <init>= <expr><operator>(</operator><name>ModifyTable</name> <operator>*</operator><operator>)</operator> <name><name>node</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>plan</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ResultRelInfo</name> <modifier>*</modifier></type><name>resultRelInfo</name> <init>= <expr><call><name>getTargetResultRelInfo</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<switch>switch <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>operation</name></name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>CMD_INSERT</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><name><name>plan</name><operator>-&gt;</operator><name>onConflictAction</name></name> <operator>==</operator> <name>ONCONFLICT_UPDATE</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ExecASUpdateTriggers</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>state</name></name></expr></argument>,
									 <argument><expr><name>resultRelInfo</name></expr></argument>,
									 <argument><expr><name><name>node</name><operator>-&gt;</operator><name>mt_oc_transition_capture</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><call><name>ExecASInsertTriggers</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>state</name></name></expr></argument>, <argument><expr><name>resultRelInfo</name></expr></argument>,
								 <argument><expr><name><name>node</name><operator>-&gt;</operator><name>mt_transition_capture</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>CMD_UPDATE</name></expr>:</case>
			<expr_stmt><expr><call><name>ExecASUpdateTriggers</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>state</name></name></expr></argument>, <argument><expr><name>resultRelInfo</name></expr></argument>,
								 <argument><expr><name><name>node</name><operator>-&gt;</operator><name>mt_transition_capture</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>CMD_DELETE</name></expr>:</case>
			<expr_stmt><expr><call><name>ExecASDeleteTriggers</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>state</name></name></expr></argument>, <argument><expr><name>resultRelInfo</name></expr></argument>,
								 <argument><expr><name><name>node</name><operator>-&gt;</operator><name>mt_transition_capture</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<default>default:</default>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unknown operation"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
	</block_content>}</block></switch>
</block_content>}</block></function>

<comment type="block">/*
 * Set up the state needed for collecting transition tuples for AFTER
 * triggers.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ExecSetupTransitionCaptureState</name><parameter_list>(<parameter><decl><type><name>ModifyTableState</name> <modifier>*</modifier></type><name>mtstate</name></decl></parameter>, <parameter><decl><type><name>EState</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ModifyTable</name> <modifier>*</modifier></type><name>plan</name> <init>= <expr><operator>(</operator><name>ModifyTable</name> <operator>*</operator><operator>)</operator> <name><name>mtstate</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>plan</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ResultRelInfo</name> <modifier>*</modifier></type><name>targetRelInfo</name> <init>= <expr><call><name>getTargetResultRelInfo</name><argument_list>(<argument><expr><name>mtstate</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/* Check for transition tables on the directly targeted relation. */</comment>
	<expr_stmt><expr><name><name>mtstate</name><operator>-&gt;</operator><name>mt_transition_capture</name></name> <operator>=</operator>
		<call><name>MakeTransitionCaptureState</name><argument_list>(<argument><expr><name><name>targetRelInfo</name><operator>-&gt;</operator><name>ri_TrigDesc</name></name></expr></argument>,
								   <argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name><name>targetRelInfo</name><operator>-&gt;</operator><name>ri_RelationDesc</name></name></expr></argument>)</argument_list></call></expr></argument>,
								   <argument><expr><name><name>mtstate</name><operator>-&gt;</operator><name>operation</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>plan</name><operator>-&gt;</operator><name>operation</name></name> <operator>==</operator> <name>CMD_INSERT</name> <operator>&amp;&amp;</operator>
		<name><name>plan</name><operator>-&gt;</operator><name>onConflictAction</name></name> <operator>==</operator> <name>ONCONFLICT_UPDATE</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>mtstate</name><operator>-&gt;</operator><name>mt_oc_transition_capture</name></name> <operator>=</operator>
			<call><name>MakeTransitionCaptureState</name><argument_list>(<argument><expr><name><name>targetRelInfo</name><operator>-&gt;</operator><name>ri_TrigDesc</name></name></expr></argument>,
									   <argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name><name>targetRelInfo</name><operator>-&gt;</operator><name>ri_RelationDesc</name></name></expr></argument>)</argument_list></call></expr></argument>,
									   <argument><expr><name>CMD_UPDATE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * If we found that we need to collect transition tuples then we may also
	 * need tuple conversion maps for any children that have TupleDescs that
	 * aren't compatible with the tuplestores.  (We can share these maps
	 * between the regular and ON CONFLICT cases.)
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>mtstate</name><operator>-&gt;</operator><name>mt_transition_capture</name></name> <operator>!=</operator> <name>NULL</name> <operator>||</operator>
		<name><name>mtstate</name><operator>-&gt;</operator><name>mt_oc_transition_capture</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ExecSetupChildParentMapForTcs</name><argument_list>(<argument><expr><name>mtstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Install the conversion map for the first plan for UPDATE and DELETE
		 * operations.  It will be advanced each time we switch to the next
		 * plan.  (INSERT operations set it every time, so we need not update
		 * mtstate-&gt;mt_oc_transition_capture here.)
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>mtstate</name><operator>-&gt;</operator><name>mt_transition_capture</name></name> <operator>&amp;&amp;</operator> <name><name>mtstate</name><operator>-&gt;</operator><name>operation</name></name> <operator>!=</operator> <name>CMD_INSERT</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>mtstate</name><operator>-&gt;</operator><name>mt_transition_capture</name><operator>-&gt;</operator><name>tcs_map</name></name> <operator>=</operator>
				<call><name>tupconv_map_for_subplan</name><argument_list>(<argument><expr><name>mtstate</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * ExecPrepareTupleRouting --- prepare for routing one tuple
 *
 * Determine the partition in which the tuple in slot is to be inserted,
 * and modify mtstate and estate to prepare for it.
 *
 * Caller must revert the estate changes after executing the insertion!
 * In mtstate, transition capture changes may also need to be reverted.
 *
 * Returns a slot holding the tuple of the partition rowtype.
 */</comment>
<function><type><specifier>static</specifier> <name>TupleTableSlot</name> <modifier>*</modifier></type>
<name>ExecPrepareTupleRouting</name><parameter_list>(<parameter><decl><type><name>ModifyTableState</name> <modifier>*</modifier></type><name>mtstate</name></decl></parameter>,
						<parameter><decl><type><name>EState</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>,
						<parameter><decl><type><name>PartitionTupleRouting</name> <modifier>*</modifier></type><name>proute</name></decl></parameter>,
						<parameter><decl><type><name>ResultRelInfo</name> <modifier>*</modifier></type><name>targetRelInfo</name></decl></parameter>,
						<parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ModifyTable</name> <modifier>*</modifier></type><name>node</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>partidx</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ResultRelInfo</name> <modifier>*</modifier></type><name>partrel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tuple</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Determine the target partition.  If ExecFindPartition does not find a
	 * partition after all, it doesn't return here; otherwise, the returned
	 * value is to be used as an index into the arrays for the ResultRelInfo
	 * and TupleConversionMap for the partition.
	 */</comment>
	<expr_stmt><expr><name>partidx</name> <operator>=</operator> <call><name>ExecFindPartition</name><argument_list>(<argument><expr><name>targetRelInfo</name></expr></argument>,
								<argument><expr><name><name>proute</name><operator>-&gt;</operator><name>partition_dispatch_info</name></name></expr></argument>,
								<argument><expr><name>slot</name></expr></argument>,
								<argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>partidx</name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>partidx</name> <operator>&lt;</operator> <name><name>proute</name><operator>-&gt;</operator><name>num_partitions</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Get the ResultRelInfo corresponding to the selected partition; if not
	 * yet there, initialize it.
	 */</comment>
	<expr_stmt><expr><name>partrel</name> <operator>=</operator> <name><name>proute</name><operator>-&gt;</operator><name>partitions</name><index>[<expr><name>partidx</name></expr>]</index></name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>partrel</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>partrel</name> <operator>=</operator> <call><name>ExecInitPartitionInfo</name><argument_list>(<argument><expr><name>mtstate</name></expr></argument>, <argument><expr><name>targetRelInfo</name></expr></argument>,
										<argument><expr><name>proute</name></expr></argument>, <argument><expr><name>estate</name></expr></argument>,
										<argument><expr><name>partidx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Check whether the partition is routable if we didn't yet
	 *
	 * Note: an UPDATE of a partition key invokes an INSERT that moves the
	 * tuple to a new partition.  This check would be applied to a subplan
	 * partition of such an UPDATE that is chosen as the partition to route
	 * the tuple to.  The reason we do this check here rather than in
	 * ExecSetupPartitionTupleRouting is to avoid aborting such an UPDATE
	 * unnecessarily due to non-routable subplan partitions that may not be
	 * chosen for update tuple movement after all.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>partrel</name><operator>-&gt;</operator><name>ri_PartitionReadyForRouting</name></name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Verify the partition is a valid target for INSERT. */</comment>
		<expr_stmt><expr><call><name>CheckValidResultRel</name><argument_list>(<argument><expr><name>partrel</name></expr></argument>, <argument><expr><name>CMD_INSERT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Set up information needed for routing tuples to the partition. */</comment>
		<expr_stmt><expr><call><name>ExecInitRoutingInfo</name><argument_list>(<argument><expr><name>mtstate</name></expr></argument>, <argument><expr><name>estate</name></expr></argument>, <argument><expr><name>proute</name></expr></argument>, <argument><expr><name>partrel</name></expr></argument>, <argument><expr><name>partidx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Make it look like we are inserting into the partition.
	 */</comment>
	<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>es_result_relation_info</name></name> <operator>=</operator> <name>partrel</name></expr>;</expr_stmt>

	<comment type="block">/* Get the heap tuple out of the given slot. */</comment>
	<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>ExecMaterializeSlot</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If we're capturing transition tuples, we might need to convert from the
	 * partition rowtype to parent rowtype.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>mtstate</name><operator>-&gt;</operator><name>mt_transition_capture</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>partrel</name><operator>-&gt;</operator><name>ri_TrigDesc</name></name> <operator>&amp;&amp;</operator>
			<name><name>partrel</name><operator>-&gt;</operator><name>ri_TrigDesc</name><operator>-&gt;</operator><name>trig_insert_before_row</name></name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * If there are any BEFORE triggers on the partition, we'll have
			 * to be ready to convert their result back to tuplestore format.
			 */</comment>
			<expr_stmt><expr><name><name>mtstate</name><operator>-&gt;</operator><name>mt_transition_capture</name><operator>-&gt;</operator><name>tcs_original_insert_tuple</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>mtstate</name><operator>-&gt;</operator><name>mt_transition_capture</name><operator>-&gt;</operator><name>tcs_map</name></name> <operator>=</operator>
				<call><name>TupConvMapForLeaf</name><argument_list>(<argument><expr><name>proute</name></expr></argument>, <argument><expr><name>targetRelInfo</name></expr></argument>, <argument><expr><name>partidx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/*
			 * Otherwise, just remember the original unconverted tuple, to
			 * avoid a needless round trip conversion.
			 */</comment>
			<expr_stmt><expr><name><name>mtstate</name><operator>-&gt;</operator><name>mt_transition_capture</name><operator>-&gt;</operator><name>tcs_original_insert_tuple</name></name> <operator>=</operator> <name>tuple</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>mtstate</name><operator>-&gt;</operator><name>mt_transition_capture</name><operator>-&gt;</operator><name>tcs_map</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>mtstate</name><operator>-&gt;</operator><name>mt_oc_transition_capture</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>mtstate</name><operator>-&gt;</operator><name>mt_oc_transition_capture</name><operator>-&gt;</operator><name>tcs_map</name></name> <operator>=</operator>
			<call><name>TupConvMapForLeaf</name><argument_list>(<argument><expr><name>proute</name></expr></argument>, <argument><expr><name>targetRelInfo</name></expr></argument>, <argument><expr><name>partidx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Convert the tuple, if necessary.
	 */</comment>
	<expr_stmt><expr><call><name>ConvertPartitionTupleSlot</name><argument_list>(<argument><expr><name><name>proute</name><operator>-&gt;</operator><name>parent_child_tupconv_maps</name><index>[<expr><name>partidx</name></expr>]</index></name></expr></argument>,
							  <argument><expr><name>tuple</name></expr></argument>,
							  <argument><expr><name><name>proute</name><operator>-&gt;</operator><name>partition_tuple_slot</name></name></expr></argument>,
							  <argument><expr><operator>&amp;</operator><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Initialize information needed to handle ON CONFLICT DO UPDATE. */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>mtstate</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>node</name> <operator>=</operator> <operator>(</operator><name>ModifyTable</name> <operator>*</operator><operator>)</operator> <name><name>mtstate</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>plan</name></name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>onConflictAction</name></name> <operator>==</operator> <name>ONCONFLICT_UPDATE</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>mtstate</name><operator>-&gt;</operator><name>mt_existing</name></name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ExecSetSlotDescriptor</name><argument_list>(<argument><expr><name><name>mtstate</name><operator>-&gt;</operator><name>mt_existing</name></name></expr></argument>,
							  <argument><expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name><name>partrel</name><operator>-&gt;</operator><name>ri_RelationDesc</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>mtstate</name><operator>-&gt;</operator><name>mt_conflproj</name></name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ExecSetSlotDescriptor</name><argument_list>(<argument><expr><name><name>mtstate</name><operator>-&gt;</operator><name>mt_conflproj</name></name></expr></argument>,
							  <argument><expr><name><name>partrel</name><operator>-&gt;</operator><name>ri_onConflict</name><operator>-&gt;</operator><name>oc_ProjTupdesc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>slot</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Initialize the child-to-root tuple conversion map array for UPDATE subplans.
 *
 * This map array is required to convert the tuple from the subplan result rel
 * to the target table descriptor. This requirement arises for two independent
 * scenarios:
 * 1. For update-tuple-routing.
 * 2. For capturing tuples in transition tables.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ExecSetupChildParentMapForSubplan</name><parameter_list>(<parameter><decl><type><name>ModifyTableState</name> <modifier>*</modifier></type><name>mtstate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ResultRelInfo</name> <modifier>*</modifier></type><name>targetRelInfo</name> <init>= <expr><call><name>getTargetResultRelInfo</name><argument_list>(<argument><expr><name>mtstate</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ResultRelInfo</name> <modifier>*</modifier></type><name>resultRelInfos</name> <init>= <expr><name><name>mtstate</name><operator>-&gt;</operator><name>resultRelInfo</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleDesc</name></type>	<name>outdesc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>numResultRelInfos</name> <init>= <expr><name><name>mtstate</name><operator>-&gt;</operator><name>mt_nplans</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * First check if there is already a per-subplan array allocated. Even if
	 * there is already a per-leaf map array, we won't require a per-subplan
	 * one, since we will use the subplan offset array to convert the subplan
	 * index to per-leaf index.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>mtstate</name><operator>-&gt;</operator><name>mt_per_subplan_tupconv_maps</name></name> <operator>||</operator>
		<operator>(</operator><name><name>mtstate</name><operator>-&gt;</operator><name>mt_partition_tuple_routing</name></name> <operator>&amp;&amp;</operator>
		 <name><name>mtstate</name><operator>-&gt;</operator><name>mt_partition_tuple_routing</name><operator>-&gt;</operator><name>child_parent_tupconv_maps</name></name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Build array of conversion maps from each child's TupleDesc to the one
	 * used in the target relation.  The map pointers may be NULL when no
	 * conversion is necessary, which is hopefully a common case.
	 */</comment>

	<comment type="block">/* Get tuple descriptor of the target rel. */</comment>
	<expr_stmt><expr><name>outdesc</name> <operator>=</operator> <call><name>RelationGetDescr</name><argument_list>(<argument><expr><name><name>targetRelInfo</name><operator>-&gt;</operator><name>ri_RelationDesc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>mtstate</name><operator>-&gt;</operator><name>mt_per_subplan_tupconv_maps</name></name> <operator>=</operator> <operator>(</operator><name>TupleConversionMap</name> <operator>*</operator><operator>*</operator><operator>)</operator>
		<call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>TupleConversionMap</name> <operator>*</operator></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>numResultRelInfos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>numResultRelInfos</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><name><name>mtstate</name><operator>-&gt;</operator><name>mt_per_subplan_tupconv_maps</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator>
			<call><name>convert_tuples_by_name</name><argument_list>(<argument><expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name><name>resultRelInfos</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>ri_RelationDesc</name></expr></argument>)</argument_list></call></expr></argument>,
								   <argument><expr><name>outdesc</name></expr></argument>,
								   <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"could not convert row type"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>
</block_content>}</block></function>

<comment type="block">/*
 * Initialize the child-to-root tuple conversion map array required for
 * capturing transition tuples.
 *
 * The map array can be indexed either by subplan index or by leaf-partition
 * index.  For transition tables, we need a subplan-indexed access to the map,
 * and where tuple-routing is present, we also require a leaf-indexed access.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ExecSetupChildParentMapForTcs</name><parameter_list>(<parameter><decl><type><name>ModifyTableState</name> <modifier>*</modifier></type><name>mtstate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PartitionTupleRouting</name> <modifier>*</modifier></type><name>proute</name> <init>= <expr><name><name>mtstate</name><operator>-&gt;</operator><name>mt_partition_tuple_routing</name></name></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * If partition tuple routing is set up, we will require partition-indexed
	 * access. In that case, create the map array indexed by partition; we
	 * will still be able to access the maps using a subplan index by
	 * converting the subplan index to a partition index using
	 * subplan_partition_offsets. If tuple routing is not set up, it means we
	 * don't require partition-indexed access. In that case, create just a
	 * subplan-indexed map.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>proute</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * If a partition-indexed map array is to be created, the subplan map
		 * array has to be NULL.  If the subplan map array is already created,
		 * we won't be able to access the map using a partition index.
		 */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>mtstate</name><operator>-&gt;</operator><name>mt_per_subplan_tupconv_maps</name></name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>ExecSetupChildParentMapForLeaf</name><argument_list>(<argument><expr><name>proute</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ExecSetupChildParentMapForSubplan</name><argument_list>(<argument><expr><name>mtstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * For a given subplan index, get the tuple conversion map.
 */</comment>
<function><type><specifier>static</specifier> <name>TupleConversionMap</name> <modifier>*</modifier></type>
<name>tupconv_map_for_subplan</name><parameter_list>(<parameter><decl><type><name>ModifyTableState</name> <modifier>*</modifier></type><name>mtstate</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>whichplan</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * If a partition-index tuple conversion map array is allocated, we need
	 * to first get the index into the partition array. Exactly *one* of the
	 * two arrays is allocated. This is because if there is a partition array
	 * required, we don't require subplan-indexed array since we can translate
	 * subplan index into partition index. And, we create a subplan-indexed
	 * array *only* if partition-indexed array is not required.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>mtstate</name><operator>-&gt;</operator><name>mt_per_subplan_tupconv_maps</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>leaf_index</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>PartitionTupleRouting</name> <modifier>*</modifier></type><name>proute</name> <init>= <expr><name><name>mtstate</name><operator>-&gt;</operator><name>mt_partition_tuple_routing</name></name></expr></init></decl>;</decl_stmt>

		<comment type="block">/*
		 * If subplan-indexed array is NULL, things should have been arranged
		 * to convert the subplan index to partition index.
		 */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>proute</name> <operator>&amp;&amp;</operator> <name><name>proute</name><operator>-&gt;</operator><name>subplan_partition_offsets</name></name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator>
			   <name>whichplan</name> <operator>&lt;</operator> <name><name>proute</name><operator>-&gt;</operator><name>num_subplan_partition_offsets</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>leaf_index</name> <operator>=</operator> <name><name>proute</name><operator>-&gt;</operator><name>subplan_partition_offsets</name><index>[<expr><name>whichplan</name></expr>]</index></name></expr>;</expr_stmt>

		<return>return <expr><call><name>TupConvMapForLeaf</name><argument_list>(<argument><expr><name>proute</name></expr></argument>, <argument><expr><call><name>getTargetResultRelInfo</name><argument_list>(<argument><expr><name>mtstate</name></expr></argument>)</argument_list></call></expr></argument>,
								 <argument><expr><name>leaf_index</name></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>whichplan</name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>whichplan</name> <operator>&lt;</operator> <name><name>mtstate</name><operator>-&gt;</operator><name>mt_nplans</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name><name>mtstate</name><operator>-&gt;</operator><name>mt_per_subplan_tupconv_maps</name><index>[<expr><name>whichplan</name></expr>]</index></name></expr>;</return>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/* ----------------------------------------------------------------
 *	   ExecModifyTable
 *
 *		Perform table modifications as required, and return RETURNING results
 *		if needed.
 * ----------------------------------------------------------------
 */</comment>
<function><type><specifier>static</specifier> <name>TupleTableSlot</name> <modifier>*</modifier></type>
<name>ExecModifyTable</name><parameter_list>(<parameter><decl><type><name>PlanState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ModifyTableState</name> <modifier>*</modifier></type><name>node</name> <init>= <expr><call><name>castNode</name><argument_list>(<argument><expr><name>ModifyTableState</name></expr></argument>, <argument><expr><name>pstate</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PartitionTupleRouting</name> <modifier>*</modifier></type><name>proute</name> <init>= <expr><name><name>node</name><operator>-&gt;</operator><name>mt_partition_tuple_routing</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>EState</name>	   <modifier>*</modifier></type><name>estate</name> <init>= <expr><name><name>node</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>state</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CmdType</name></type>		<name>operation</name> <init>= <expr><name><name>node</name><operator>-&gt;</operator><name>operation</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ResultRelInfo</name> <modifier>*</modifier></type><name>saved_resultRelInfo</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ResultRelInfo</name> <modifier>*</modifier></type><name>resultRelInfo</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PlanState</name>  <modifier>*</modifier></type><name>subplanstate</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>JunkFilter</name> <modifier>*</modifier></type><name>junkfilter</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>planSlot</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ItemPointer</name></type> <name>tupleid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ItemPointerData</name></type> <name>tuple_ctid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTupleData</name></type> <name>oldtupdata</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>oldtuple</name></decl>;</decl_stmt>
	<comment type="block">/* POLAR px */</comment>
	<decl_stmt><decl><type><name>AttrNumber</name></type>  <name>action_attno</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>action</name></decl>;</decl_stmt>
	<comment type="block">/* POLAR end */</comment>


	<expr_stmt><expr><call><name>CHECK_FOR_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * This should NOT get called during EvalPlanQual; we should have passed a
	 * subplan tree to EvalPlanQual, instead.  Use a runtime test not just
	 * Assert because this condition is easy to miss in testing.  (Note:
	 * although ModifyTable should not get executed within an EvalPlanQual
	 * operation, we do have to allow it to be initialized and shut down in
	 * case it is within a CTE subplan.  Hence this test must be here, not in
	 * ExecInitModifyTable.)
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>estate</name><operator>-&gt;</operator><name>es_epqTuple</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"ModifyTable should not be called during EvalPlanQual"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * If we've already completed processing, don't try to do more.  We need
	 * this test because ExecPostprocessPlan might call us an extra time, and
	 * our subplan's nodes aren't necessarily robust against being called
	 * extra times.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>mt_done</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * On first call, fire BEFORE STATEMENT triggers before proceeding.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>fireBSTriggers</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>fireBSTriggers</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>fireBSTriggers</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Preload local variables */</comment>
	<expr_stmt><expr><name>resultRelInfo</name> <operator>=</operator> <name><name>node</name><operator>-&gt;</operator><name>resultRelInfo</name></name> <operator>+</operator> <name><name>node</name><operator>-&gt;</operator><name>mt_whichplan</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>subplanstate</name> <operator>=</operator> <name><name>node</name><operator>-&gt;</operator><name>mt_plans</name><index>[<expr><name><name>node</name><operator>-&gt;</operator><name>mt_whichplan</name></name></expr>]</index></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>junkfilter</name> <operator>=</operator> <name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_junkFilter</name></name></expr>;</expr_stmt>
	<comment type="block">/* POLAR px */</comment>
	<expr_stmt><expr><name>action_attno</name> <operator>=</operator> <name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_action_attno</name></name></expr>;</expr_stmt>
	<comment type="block">/* POLAR end */</comment>

	<comment type="block">/*
	 * es_result_relation_info must point to the currently active result
	 * relation while we are within this ModifyTable node.  Even though
	 * ModifyTable nodes can't be nested statically, they can be nested
	 * dynamically (since our subplan could include a reference to a modifying
	 * CTE).  So we have to save and restore the caller's value.
	 */</comment>
	<expr_stmt><expr><name>saved_resultRelInfo</name> <operator>=</operator> <name><name>estate</name><operator>-&gt;</operator><name>es_result_relation_info</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>es_result_relation_info</name></name> <operator>=</operator> <name>resultRelInfo</name></expr>;</expr_stmt>

	<comment type="block">/* POLAR: delay dml if necessary, for once */</comment>
	<if_stmt><if>if <condition>(<expr><name>polar_delay_dml_option</name> <operator>==</operator> <name>POLAR_DELAY_DML_ONCE</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>polar_delay_dml_wait</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Fetch rows from subplan(s), and execute the required table modification
	 * for each row.
	 */</comment>
	<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
	<block>{<block_content>
		<comment type="block">/* POLAR: delay dml if necessary, for multiple tuple */</comment>
		<if_stmt><if>if <condition>(<expr><name>polar_delay_dml_option</name> <operator>==</operator> <name>POLAR_DELAY_DML_MULTI</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>polar_delay_dml_wait</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * Reset the per-output-tuple exprcontext.  This is needed because
		 * triggers expect to use that context as workspace.  It's a bit ugly
		 * to do this below the top level of the plan, however.  We might need
		 * to rethink this later.
		 */</comment>
		<expr_stmt><expr><call><name>ResetPerTupleExprContext</name><argument_list>(<argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>planSlot</name> <operator>=</operator> <call><name>ExecProcNode</name><argument_list>(<argument><expr><name>subplanstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>TupIsNull</name><argument_list>(<argument><expr><name>planSlot</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* advance to next subplan if any */</comment>
			<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>mt_whichplan</name></name><operator>++</operator></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>mt_whichplan</name></name> <operator>&lt;</operator> <name><name>node</name><operator>-&gt;</operator><name>mt_nplans</name></name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>resultRelInfo</name><operator>++</operator></expr>;</expr_stmt>
				<expr_stmt><expr><name>subplanstate</name> <operator>=</operator> <name><name>node</name><operator>-&gt;</operator><name>mt_plans</name><index>[<expr><name><name>node</name><operator>-&gt;</operator><name>mt_whichplan</name></name></expr>]</index></name></expr>;</expr_stmt>
				<expr_stmt><expr><name>junkfilter</name> <operator>=</operator> <name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_junkFilter</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>es_result_relation_info</name></name> <operator>=</operator> <name>resultRelInfo</name></expr>;</expr_stmt>
				<comment type="block">/* POLAR px */</comment>
				<expr_stmt><expr><name>action_attno</name> <operator>=</operator> <name><name>estate</name><operator>-&gt;</operator><name>es_result_relation_info</name><operator>-&gt;</operator><name>ri_action_attno</name></name></expr>;</expr_stmt>
				<comment type="block">/* POLAR end */</comment>
				<expr_stmt><expr><call><name>EvalPlanQualSetPlan</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>node</name><operator>-&gt;</operator><name>mt_epqstate</name></name></expr></argument>, <argument><expr><name><name>subplanstate</name><operator>-&gt;</operator><name>plan</name></name></expr></argument>,
									<argument><expr><name><name>node</name><operator>-&gt;</operator><name>mt_arowmarks</name><index>[<expr><name><name>node</name><operator>-&gt;</operator><name>mt_whichplan</name></name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<comment type="block">/* Prepare to convert transition tuples from this child. */</comment>
				<if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>mt_transition_capture</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>mt_transition_capture</name><operator>-&gt;</operator><name>tcs_map</name></name> <operator>=</operator>
						<call><name>tupconv_map_for_subplan</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>mt_whichplan</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
				<if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>mt_oc_transition_capture</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>mt_oc_transition_capture</name><operator>-&gt;</operator><name>tcs_map</name></name> <operator>=</operator>
						<call><name>tupconv_map_for_subplan</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>mt_whichplan</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
				<continue>continue;</continue>
			</block_content>}</block></if>
			<else>else<block type="pseudo"><block_content>
				<break>break;</break></block_content></block></else></if_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * If resultRelInfo-&gt;ri_usesFdwDirectModify is true, all we need to do
		 * here is compute the RETURNING expressions.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_usesFdwDirectModify</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_projectReturning</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * A scan slot containing the data that was actually inserted,
			 * updated or deleted has already been made available to
			 * ExecProcessReturning by IterateDirectModify, so no need to
			 * provide it here.
			 */</comment>
			<expr_stmt><expr><name>slot</name> <operator>=</operator> <call><name>ExecProcessReturning</name><argument_list>(<argument><expr><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_projectReturning</name></name></expr></argument>,
										<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_RelationDesc</name></name></expr></argument>)</argument_list></call></expr></argument>,
										<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>planSlot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>es_result_relation_info</name></name> <operator>=</operator> <name>saved_resultRelInfo</name></expr>;</expr_stmt>
			<return>return <expr><name>slot</name></expr>;</return>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>EvalPlanQualSetSlot</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>node</name><operator>-&gt;</operator><name>mt_epqstate</name></name></expr></argument>, <argument><expr><name>planSlot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>slot</name> <operator>=</operator> <name>planSlot</name></expr>;</expr_stmt>

		<comment type="block">/* POLAR px */</comment>
		<expr_stmt><expr><name>action</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
		<comment type="block">/* POLAR end */</comment>

		<expr_stmt><expr><name>tupleid</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>oldtuple</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>junkfilter</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * extract the 'ctid' or 'wholerow' junk attribute.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name>operation</name> <operator>==</operator> <name>CMD_UPDATE</name> <operator>||</operator> <name>operation</name> <operator>==</operator> <name>CMD_DELETE</name></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>char</name></type>		<name>relkind</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>Datum</name></type>		<name>datum</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>bool</name></type>		<name>isNull</name></decl>;</decl_stmt>

				<expr_stmt><expr><name>relkind</name> <operator>=</operator> <name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_RelationDesc</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name>relkind</name> <operator>==</operator> <name>RELKIND_RELATION</name> <operator>||</operator> <name>relkind</name> <operator>==</operator> <name>RELKIND_MATVIEW</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name>datum</name> <operator>=</operator> <call><name>ExecGetJunkAttribute</name><argument_list>(<argument><expr><name>slot</name></expr></argument>,
												 <argument><expr><name><name>junkfilter</name><operator>-&gt;</operator><name>jf_junkAttNo</name></name></expr></argument>,
												 <argument><expr><operator>&amp;</operator><name>isNull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<comment type="block">/* shouldn't ever get a null result... */</comment>
					<if_stmt><if>if <condition>(<expr><name>isNull</name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"ctid is NULL"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

					<expr_stmt><expr><name>tupleid</name> <operator>=</operator> <operator>(</operator><name>ItemPointer</name><operator>)</operator> <call><name>DatumGetPointer</name><argument_list>(<argument><expr><name>datum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>tuple_ctid</name> <operator>=</operator> <operator>*</operator><name>tupleid</name></expr>;</expr_stmt>	<comment type="block">/* be sure we don't free ctid!! */</comment>
					<expr_stmt><expr><name>tupleid</name> <operator>=</operator> <operator>&amp;</operator><name>tuple_ctid</name></expr>;</expr_stmt>
				</block_content>}</block></if>

				<comment type="block">/*
				 * Use the wholerow attribute, when available, to reconstruct
				 * the old relation tuple.
				 *
				 * Foreign table updates have a wholerow attribute when the
				 * relation has a row-level trigger.  Note that the wholerow
				 * attribute does not carry system columns.  Foreign table
				 * triggers miss seeing those, except that we know enough here
				 * to set t_tableOid.  Quite separately from this, the FDW may
				 * fetch its own junk attrs to identify the row.
				 *
				 * Other relevant relkinds, currently limited to views, always
				 * have a wholerow attribute.
				 */</comment>
				<if type="elseif">else if <condition>(<expr><call><name>AttributeNumberIsValid</name><argument_list>(<argument><expr><name><name>junkfilter</name><operator>-&gt;</operator><name>jf_junkAttNo</name></name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name>datum</name> <operator>=</operator> <call><name>ExecGetJunkAttribute</name><argument_list>(<argument><expr><name>slot</name></expr></argument>,
												 <argument><expr><name><name>junkfilter</name><operator>-&gt;</operator><name>jf_junkAttNo</name></name></expr></argument>,
												 <argument><expr><operator>&amp;</operator><name>isNull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<comment type="block">/* shouldn't ever get a null result... */</comment>
					<if_stmt><if>if <condition>(<expr><name>isNull</name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"wholerow is NULL"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

					<expr_stmt><expr><name><name>oldtupdata</name><operator>.</operator><name>t_data</name></name> <operator>=</operator> <call><name>DatumGetHeapTupleHeader</name><argument_list>(<argument><expr><name>datum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>oldtupdata</name><operator>.</operator><name>t_len</name></name> <operator>=</operator>
						<call><name>HeapTupleHeaderGetDatumLength</name><argument_list>(<argument><expr><name><name>oldtupdata</name><operator>.</operator><name>t_data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>ItemPointerSetInvalid</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>oldtupdata</name><operator>.</operator><name>t_self</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<comment type="block">/* Historically, view triggers see invalid t_tableOid. */</comment>
					<expr_stmt><expr><name><name>oldtupdata</name><operator>.</operator><name>t_tableOid</name></name> <operator>=</operator>
						<ternary><condition><expr><operator>(</operator><name>relkind</name> <operator>==</operator> <name>RELKIND_VIEW</name><operator>)</operator></expr> ?</condition><then> <expr><name>InvalidOid</name></expr> </then><else>:
						<expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_RelationDesc</name></name></expr></argument>)</argument_list></call></expr></else></ternary></expr>;</expr_stmt>

					<expr_stmt><expr><name>oldtuple</name> <operator>=</operator> <operator>&amp;</operator><name>oldtupdata</name></expr>;</expr_stmt>
				</block_content>}</block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>relkind</name> <operator>==</operator> <name>RELKIND_FOREIGN_TABLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

				<if_stmt><if>if <condition>(<expr><name>px_is_executing</name> <operator>&amp;&amp;</operator> <call><name>AttributeNumberIsValid</name><argument_list>(<argument><expr><name>action_attno</name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name>datum</name> <operator>=</operator> <call><name>ExecGetJunkAttribute</name><argument_list>(<argument><expr><name>slot</name></expr></argument>,
												 <argument><expr><name>action_attno</name></expr></argument>,
												 <argument><expr><operator>&amp;</operator><name>isNull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<comment type="block">/* shouldn't ever get a null result... */</comment>
					<if_stmt><if>if <condition>(<expr><name>isNull</name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"action_attno is NULL"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

					<expr_stmt><expr><name>action</name> <operator>=</operator> <call><name>DatumGetInt32</name><argument_list>(<argument><expr><name>datum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/*
			 * apply the junkfilter if needed.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name>operation</name> <operator>!=</operator> <name>CMD_DELETE</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>slot</name> <operator>=</operator> <call><name>ExecFilterJunk</name><argument_list>(<argument><expr><name>junkfilter</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<switch>switch <condition>(<expr><name>operation</name></expr>)</condition>
		<block>{<block_content>
			<case>case <expr><name>CMD_INSERT</name></expr>:</case>
				<comment type="block">/* Prepare for tuple routing if needed. */</comment>
				<if_stmt><if>if <condition>(<expr><name>proute</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>slot</name> <operator>=</operator> <call><name>ExecPrepareTupleRouting</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>estate</name></expr></argument>, <argument><expr><name>proute</name></expr></argument>,
												   <argument><expr><name>resultRelInfo</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<expr_stmt><expr><name>slot</name> <operator>=</operator> <call><name>ExecInsert</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>, <argument><expr><name>planSlot</name></expr></argument>,
								  <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name><name>estate</name><operator>-&gt;</operator><name>es_result_relation_info</name></name></expr></argument>,
								  <argument><expr><name>estate</name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>canSetTag</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument> <comment type="block">/* isSplitUpdate */</comment>)</argument_list></call></expr>;</expr_stmt>
				<comment type="block">/* Revert ExecPrepareTupleRouting's state change. */</comment>
				<if_stmt><if>if <condition>(<expr><name>proute</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>es_result_relation_info</name></name> <operator>=</operator> <name>resultRelInfo</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<break>break;</break>
			<case>case <expr><name>CMD_UPDATE</name></expr>:</case>
				<comment type="block">/* POLAR px */</comment>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><name>px_is_executing</name></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/* normal non-split UPDATE */</comment>
					<expr_stmt><expr><name>slot</name> <operator>=</operator> <call><name>ExecUpdate</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>tupleid</name></expr></argument>, <argument><expr><name>oldtuple</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>, <argument><expr><name>planSlot</name></expr></argument>,
									  <argument><expr><operator>&amp;</operator><name><name>node</name><operator>-&gt;</operator><name>mt_epqstate</name></name></expr></argument>, <argument><expr><name>estate</name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>canSetTag</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if>
				<if type="elseif">else if <condition>(<expr><name>DML_INSERT</name> <operator>==</operator> <name>action</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name>slot</name> <operator>=</operator> <call><name>ExecInsert</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>, <argument><expr><name>planSlot</name></expr></argument>,
										<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name><name>estate</name><operator>-&gt;</operator><name>es_result_relation_info</name></name></expr></argument>,
										<argument><expr><name>estate</name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>canSetTag</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument> <comment type="block">/* isSplitUpdate */</comment>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if>
				<else>else <comment type="block">/* DML_DELETE */</comment>
				<block>{<block_content>
					<expr_stmt><expr><name>slot</name> <operator>=</operator> <call><name>ExecDelete</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>tupleid</name></expr></argument>, <argument><expr><name>oldtuple</name></expr></argument>, <argument><expr><name>planSlot</name></expr></argument>,
									  <argument><expr><operator>&amp;</operator><name><name>node</name><operator>-&gt;</operator><name>mt_epqstate</name></name></expr></argument>, <argument><expr><name>estate</name></expr></argument>,
									  <argument><expr><name>false</name></expr></argument> <comment type="block">/* Process Returning */</comment>,
									  <argument><expr><name>false</name></expr></argument> <comment type="block">/* canSetTag */</comment>,
									  <argument><expr><name>false</name></expr></argument> <comment type="block">/* changingPart */</comment> ,
									  <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>true</name></expr></argument> <comment type="block">/* SplitUpdate */</comment>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></else></if_stmt>
				<comment type="block">/* POLAR end */</comment>
				<break>break;</break>
			<case>case <expr><name>CMD_DELETE</name></expr>:</case>
				<expr_stmt><expr><name>slot</name> <operator>=</operator> <call><name>ExecDelete</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>tupleid</name></expr></argument>, <argument><expr><name>oldtuple</name></expr></argument>, <argument><expr><name>planSlot</name></expr></argument>,
								  <argument><expr><operator>&amp;</operator><name><name>node</name><operator>-&gt;</operator><name>mt_epqstate</name></name></expr></argument>, <argument><expr><name>estate</name></expr></argument>,
								  <argument><expr><name>true</name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>canSetTag</name></name></expr></argument>,
								  <argument><expr><name>false</name></expr></argument> <comment type="block">/* changingPart */</comment> , <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>false</name></expr></argument> <comment type="block">/* SplitUpdate */</comment>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<default>default:</default>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unknown operation"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
		</block_content>}</block></switch>

		<comment type="block">/*
		 * If we got a RETURNING result, return it to caller.  We'll continue
		 * the work on next call.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>slot</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>es_result_relation_info</name></name> <operator>=</operator> <name>saved_resultRelInfo</name></expr>;</expr_stmt>
			<return>return <expr><name>slot</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>

	<comment type="block">/* Restore es_result_relation_info before exiting */</comment>
	<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>es_result_relation_info</name></name> <operator>=</operator> <name>saved_resultRelInfo</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * We're done, but fire AFTER STATEMENT triggers before exiting.
	 */</comment>
	<expr_stmt><expr><call><name>fireASTriggers</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>mt_done</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

	<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* ----------------------------------------------------------------
 *		ExecInitModifyTable
 * ----------------------------------------------------------------
 */</comment>
<function><type><name>ModifyTableState</name> <modifier>*</modifier></type>
<name>ExecInitModifyTable</name><parameter_list>(<parameter><decl><type><name>ModifyTable</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>EState</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>eflags</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ModifyTableState</name> <modifier>*</modifier></type><name>mtstate</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CmdType</name></type>		<name>operation</name> <init>= <expr><name><name>node</name><operator>-&gt;</operator><name>operation</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>nplans</name> <init>= <expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>plans</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ResultRelInfo</name> <modifier>*</modifier></type><name>saved_resultRelInfo</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ResultRelInfo</name> <modifier>*</modifier></type><name>resultRelInfo</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Plan</name>	   <modifier>*</modifier></type><name>subplan</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>rel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>update_tuple_routing_needed</name> <init>= <expr><name><name>node</name><operator>-&gt;</operator><name>partColsUpdated</name></name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* check for unsupported flags */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><operator>(</operator><name>eflags</name> <operator>&amp;</operator> <operator>(</operator><name>EXEC_FLAG_BACKWARD</name> <operator>|</operator> <name>EXEC_FLAG_MARK</name><operator>)</operator><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * create state structure
	 */</comment>
	<expr_stmt><expr><name>mtstate</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>ModifyTableState</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>mtstate</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>plan</name></name> <operator>=</operator> <operator>(</operator><name>Plan</name> <operator>*</operator><operator>)</operator> <name>node</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>mtstate</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>state</name></name> <operator>=</operator> <name>estate</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>mtstate</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>ExecProcNode</name></name> <operator>=</operator> <name>ExecModifyTable</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>mtstate</name><operator>-&gt;</operator><name>operation</name></name> <operator>=</operator> <name>operation</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>mtstate</name><operator>-&gt;</operator><name>canSetTag</name></name> <operator>=</operator> <name><name>node</name><operator>-&gt;</operator><name>canSetTag</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>mtstate</name><operator>-&gt;</operator><name>mt_done</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>mtstate</name><operator>-&gt;</operator><name>mt_plans</name></name> <operator>=</operator> <operator>(</operator><name>PlanState</name> <operator>*</operator><operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>PlanState</name> <operator>*</operator></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>nplans</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>mtstate</name><operator>-&gt;</operator><name>resultRelInfo</name></name> <operator>=</operator> <name><name>estate</name><operator>-&gt;</operator><name>es_result_relations</name></name> <operator>+</operator> <name><name>node</name><operator>-&gt;</operator><name>resultRelIndex</name></name></expr>;</expr_stmt>

	<comment type="block">/* If modifying a partitioned table, initialize the root table info */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>rootResultRelIndex</name></name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>mtstate</name><operator>-&gt;</operator><name>rootResultRelInfo</name></name> <operator>=</operator> <name><name>estate</name><operator>-&gt;</operator><name>es_root_result_relations</name></name> <operator>+</operator>
			<name><name>node</name><operator>-&gt;</operator><name>rootResultRelIndex</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name><name>mtstate</name><operator>-&gt;</operator><name>mt_arowmarks</name></name> <operator>=</operator> <operator>(</operator><name>List</name> <operator>*</operator><operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>List</name> <operator>*</operator></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>nplans</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>mtstate</name><operator>-&gt;</operator><name>mt_nplans</name></name> <operator>=</operator> <name>nplans</name></expr>;</expr_stmt>

	<comment type="block">/* set up epqstate with dummy subplan data for the moment */</comment>
	<expr_stmt><expr><call><name>EvalPlanQualInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>mtstate</name><operator>-&gt;</operator><name>mt_epqstate</name></name></expr></argument>, <argument><expr><name>estate</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NIL</name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>epqParam</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>mtstate</name><operator>-&gt;</operator><name>fireBSTriggers</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

	<comment type="block">/* POLAR px */</comment>
	<expr_stmt><expr><name><name>mtstate</name><operator>-&gt;</operator><name>mt_isSplitUpdates</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>px_is_executing</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>mtstate</name><operator>-&gt;</operator><name>mt_isSplitUpdates</name></name> <operator>=</operator> <operator>(</operator><name>bool</name> <operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><name>nplans</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>isSplitUpdates</name></name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>isSplitUpdates</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>nplans</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"ModifyTable node is missing is-split-update information"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<expr_stmt><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>node-&gt;isSplitUpdates</argument>)</argument_list></macro>
				<expr_stmt><expr><name><name>mtstate</name><operator>-&gt;</operator><name>mt_isSplitUpdates</name><index>[<expr><name>i</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>bool</name><operator>)</operator> <call><name>lfirst_int</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<for>for<control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nplans</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control>
			<block>{<block_content>
				<expr_stmt><expr><name><name>mtstate</name><operator>-&gt;</operator><name>mt_isSplitUpdates</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			</block_content>}</block></for>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* POLAR end */</comment>

	<comment type="block">/*
	 * call ExecInitNode on each of the plans to be executed and save the
	 * results into the array "mt_plans".  This is also a convenient place to
	 * verify that the proposed target relations are valid and open their
	 * indexes for insertion of new index entries.  Note we *must* set
	 * estate-&gt;es_result_relation_info correctly while we initialize each
	 * sub-plan; ExecContextForcesOids depends on that!
	 */</comment>
	<expr_stmt><expr><name>saved_resultRelInfo</name> <operator>=</operator> <name><name>estate</name><operator>-&gt;</operator><name>es_result_relation_info</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><name>resultRelInfo</name> <operator>=</operator> <name><name>mtstate</name><operator>-&gt;</operator><name>resultRelInfo</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>node-&gt;plans</argument>)</argument_list></macro>
	<block>{<block_content>
		<expr_stmt><expr><name>subplan</name> <operator>=</operator> <operator>(</operator><name>Plan</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Initialize the usesFdwDirectModify flag */</comment>
		<expr_stmt><expr><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_usesFdwDirectModify</name></name> <operator>=</operator> <call><name>bms_is_member</name><argument_list>(<argument><expr><name>i</name></expr></argument>,
															  <argument><expr><name><name>node</name><operator>-&gt;</operator><name>fdwDirectModifyPlans</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Verify result relation is a valid target for the current operation
		 */</comment>
		<expr_stmt><expr><call><name>CheckValidResultRel</name><argument_list>(<argument><expr><name>resultRelInfo</name></expr></argument>, <argument><expr><name>operation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * If there are indices on the result relation, open them and save
		 * descriptors in the result relation info, so that we can add new
		 * index entries for the tuples we add/update.  We need not do this
		 * for a DELETE, however, since deletion doesn't affect indexes. Also,
		 * inside an EvalPlanQual operation, the indexes might be open
		 * already, since we share the resultrel state with the original
		 * query.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_RelationDesc</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relhasindex</name></name> <operator>&amp;&amp;</operator>
			<name>operation</name> <operator>!=</operator> <name>CMD_DELETE</name> <operator>&amp;&amp;</operator>
			<name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_IndexRelationDescs</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ExecOpenIndices</name><argument_list>(<argument><expr><name>resultRelInfo</name></expr></argument>,
							<argument><expr><name><name>node</name><operator>-&gt;</operator><name>onConflictAction</name></name> <operator>!=</operator> <name>ONCONFLICT_NONE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * If this is an UPDATE and a BEFORE UPDATE trigger is present, the
		 * trigger itself might modify the partition-key values. So arrange
		 * for tuple routing.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_TrigDesc</name></name> <operator>&amp;&amp;</operator>
			<name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_TrigDesc</name><operator>-&gt;</operator><name>trig_update_before_row</name></name> <operator>&amp;&amp;</operator>
			<name>operation</name> <operator>==</operator> <name>CMD_UPDATE</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>update_tuple_routing_needed</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/* Now init the plan for this result rel */</comment>
		<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>es_result_relation_info</name></name> <operator>=</operator> <name>resultRelInfo</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>mtstate</name><operator>-&gt;</operator><name>mt_plans</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>ExecInitNode</name><argument_list>(<argument><expr><name>subplan</name></expr></argument>, <argument><expr><name>estate</name></expr></argument>, <argument><expr><name>eflags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Also let FDWs init themselves for foreign-table result rels */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_usesFdwDirectModify</name></name> <operator>&amp;&amp;</operator>
			<name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_FdwRoutine</name></name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator>
			<name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_FdwRoutine</name><operator>-&gt;</operator><name>BeginForeignModify</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>fdw_private</name> <init>= <expr><operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator> <call><name>list_nth</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>fdwPrivLists</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><call><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_FdwRoutine</name><operator>-&gt;</operator><name>BeginForeignModify</name></name><argument_list>(<argument><expr><name>mtstate</name></expr></argument>,
															 <argument><expr><name>resultRelInfo</name></expr></argument>,
															 <argument><expr><name>fdw_private</name></expr></argument>,
															 <argument><expr><name>i</name></expr></argument>,
															 <argument><expr><name>eflags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name>resultRelInfo</name><operator>++</operator></expr>;</expr_stmt>
		<expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block>

	<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>es_result_relation_info</name></name> <operator>=</operator> <name>saved_resultRelInfo</name></expr>;</expr_stmt>

	<comment type="block">/* Get the target relation */</comment>
	<expr_stmt><expr><name>rel</name> <operator>=</operator> <operator>(</operator><call><name>getTargetResultRelInfo</name><argument_list>(<argument><expr><name>mtstate</name></expr></argument>)</argument_list></call><operator>)</operator><operator>-&gt;</operator><name>ri_RelationDesc</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * If it's not a partitioned table after all, UPDATE tuple routing should
	 * not be attempted.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>!=</operator> <name>RELKIND_PARTITIONED_TABLE</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>update_tuple_routing_needed</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Build state for tuple routing if it's an INSERT or if it's an UPDATE of
	 * partition key.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_PARTITIONED_TABLE</name> <operator>&amp;&amp;</operator>
		<operator>(</operator><name>operation</name> <operator>==</operator> <name>CMD_INSERT</name> <operator>||</operator> <name>update_tuple_routing_needed</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>mtstate</name><operator>-&gt;</operator><name>mt_partition_tuple_routing</name></name> <operator>=</operator>
			<call><name>ExecSetupPartitionTupleRouting</name><argument_list>(<argument><expr><name>mtstate</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Build state for collecting transition tuples.  This requires having a
	 * valid trigger query context, so skip it in explain-only mode.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>eflags</name> <operator>&amp;</operator> <name>EXEC_FLAG_EXPLAIN_ONLY</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ExecSetupTransitionCaptureState</name><argument_list>(<argument><expr><name>mtstate</name></expr></argument>, <argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Construct mapping from each of the per-subplan partition attnos to the
	 * root attno.  This is required when during update row movement the tuple
	 * descriptor of a source partition does not match the root partitioned
	 * table descriptor.  In such a case we need to convert tuples to the root
	 * tuple descriptor, because the search for destination partition starts
	 * from the root.  Skip this setup if it's not a partition key update.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>update_tuple_routing_needed</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ExecSetupChildParentMapForSubplan</name><argument_list>(<argument><expr><name>mtstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Initialize any WITH CHECK OPTION constraints if needed.
	 */</comment>
	<expr_stmt><expr><name>resultRelInfo</name> <operator>=</operator> <name><name>mtstate</name><operator>-&gt;</operator><name>resultRelInfo</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>node-&gt;withCheckOptionLists</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>wcoList</name> <init>= <expr><operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>wcoExprs</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>ll</name></decl>;</decl_stmt>

		<macro><name>foreach</name><argument_list>(<argument>ll</argument>, <argument>wcoList</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>WithCheckOption</name> <modifier>*</modifier></type><name>wco</name> <init>= <expr><operator>(</operator><name>WithCheckOption</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>ll</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>ExprState</name>  <modifier>*</modifier></type><name>wcoExpr</name> <init>= <expr><call><name>ExecInitQual</name><argument_list>(<argument><expr><operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator> <name><name>wco</name><operator>-&gt;</operator><name>qual</name></name></expr></argument>,
											   <argument><expr><operator>&amp;</operator><name><name>mtstate</name><operator>-&gt;</operator><name>ps</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><name>wcoExprs</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>wcoExprs</name></expr></argument>, <argument><expr><name>wcoExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>

		<expr_stmt><expr><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_WithCheckOptions</name></name> <operator>=</operator> <name>wcoList</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_WithCheckOptionExprs</name></name> <operator>=</operator> <name>wcoExprs</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>resultRelInfo</name><operator>++</operator></expr>;</expr_stmt>
		<expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block>

	<comment type="block">/*
	 * Initialize RETURNING projections if needed.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>returningLists</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ExprContext</name> <modifier>*</modifier></type><name>econtext</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * Initialize result tuple slot and assign its rowtype using the first
		 * RETURNING list.  We assume the rest will look the same.
		 */</comment>
		<expr_stmt><expr><name><name>mtstate</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>plan</name><operator>-&gt;</operator><name>targetlist</name></name> <operator>=</operator> <operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator> <call><name>linitial</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>returningLists</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Set up a slot for the output of the RETURNING projection(s) */</comment>
		<expr_stmt><expr><call><name>ExecInitResultTupleSlotTL</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>mtstate</name><operator>-&gt;</operator><name>ps</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>slot</name> <operator>=</operator> <name><name>mtstate</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>ps_ResultTupleSlot</name></name></expr>;</expr_stmt>

		<comment type="block">/* Need an econtext too */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>mtstate</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>ps_ExprContext</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ExecAssignExprContext</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>mtstate</name><operator>-&gt;</operator><name>ps</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>econtext</name> <operator>=</operator> <name><name>mtstate</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>ps_ExprContext</name></name></expr>;</expr_stmt>

		<comment type="block">/*
		 * Build a projection for each result rel.
		 */</comment>
		<expr_stmt><expr><name>resultRelInfo</name> <operator>=</operator> <name><name>mtstate</name><operator>-&gt;</operator><name>resultRelInfo</name></name></expr>;</expr_stmt>
		<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>node-&gt;returningLists</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>rlist</name> <init>= <expr><operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_returningList</name></name> <operator>=</operator> <name>rlist</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_projectReturning</name></name> <operator>=</operator>
				<call><name>ExecBuildProjectionInfo</name><argument_list>(<argument><expr><name>rlist</name></expr></argument>, <argument><expr><name>econtext</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>mtstate</name><operator>-&gt;</operator><name>ps</name></name></expr></argument>,
										<argument><expr><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_RelationDesc</name><operator>-&gt;</operator><name>rd_att</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>resultRelInfo</name><operator>++</operator></expr>;</expr_stmt>
		</block_content>}</block>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/*
		 * We still must construct a dummy result tuple type, because InitPlan
		 * expects one (maybe should change that?).
		 */</comment>
		<expr_stmt><expr><name><name>mtstate</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>plan</name><operator>-&gt;</operator><name>targetlist</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ExecInitResultTupleSlotTL</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>mtstate</name><operator>-&gt;</operator><name>ps</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>mtstate</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>ps_ExprContext</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/* Set the list of arbiter indexes if needed for ON CONFLICT */</comment>
	<expr_stmt><expr><name>resultRelInfo</name> <operator>=</operator> <name><name>mtstate</name><operator>-&gt;</operator><name>resultRelInfo</name></name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>onConflictAction</name></name> <operator>!=</operator> <name>ONCONFLICT_NONE</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_onConflictArbiterIndexes</name></name> <operator>=</operator> <name><name>node</name><operator>-&gt;</operator><name>arbiterIndexes</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * If needed, Initialize target list, projection and qual for ON CONFLICT
	 * DO UPDATE.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>onConflictAction</name></name> <operator>==</operator> <name>ONCONFLICT_UPDATE</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>OnConflictSetState</name> <modifier>*</modifier></type><name>onconfl</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>OnConflictSetState</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ExprContext</name> <modifier>*</modifier></type><name>econtext</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>TupleDesc</name></type>	<name>relationDesc</name></decl>;</decl_stmt>

		<comment type="block">/* insert may only have one plan, inheritance is not expanded */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>nplans</name> <operator>==</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* already exists if created by RETURNING processing above */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>mtstate</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>ps_ExprContext</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ExecAssignExprContext</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>mtstate</name><operator>-&gt;</operator><name>ps</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>econtext</name> <operator>=</operator> <name><name>mtstate</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>ps_ExprContext</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>relationDesc</name> <operator>=</operator> <name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_RelationDesc</name><operator>-&gt;</operator><name>rd_att</name></name></expr>;</expr_stmt>

		<comment type="block">/*
		 * Initialize slot for the existing tuple.  If we'll be performing
		 * tuple routing, the tuple descriptor to use for this will be
		 * determined based on which relation the update is actually applied
		 * to, so we don't set its tuple descriptor here.
		 */</comment>
		<expr_stmt><expr><name><name>mtstate</name><operator>-&gt;</operator><name>mt_existing</name></name> <operator>=</operator>
			<call><name>ExecInitExtraTupleSlot</name><argument_list>(<argument><expr><name><name>mtstate</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>state</name></name></expr></argument>,
								   <argument><expr><ternary><condition><expr><name><name>mtstate</name><operator>-&gt;</operator><name>mt_partition_tuple_routing</name></name></expr> ?</condition><then>
								   <expr><name>NULL</name></expr> </then><else>: <expr><name>relationDesc</name></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* carried forward solely for the benefit of explain */</comment>
		<expr_stmt><expr><name><name>mtstate</name><operator>-&gt;</operator><name>mt_excludedtlist</name></name> <operator>=</operator> <name><name>node</name><operator>-&gt;</operator><name>exclRelTlist</name></name></expr>;</expr_stmt>

		<comment type="block">/* create state for DO UPDATE SET operation */</comment>
		<expr_stmt><expr><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_onConflict</name></name> <operator>=</operator> <name>onconfl</name></expr>;</expr_stmt>

		<comment type="block">/*
		 * Create the tuple slot for the UPDATE SET projection.
		 *
		 * Just like mt_existing above, we leave it without a tuple descriptor
		 * in the case of partitioning tuple routing, so that it can be
		 * changed by ExecPrepareTupleRouting.  In that case, we still save
		 * the tupdesc in the parent's state: it can be reused by partitions
		 * with an identical descriptor to the parent.
		 */</comment>
		<expr_stmt><expr><name><name>mtstate</name><operator>-&gt;</operator><name>mt_conflproj</name></name> <operator>=</operator>
			<call><name>ExecInitExtraTupleSlot</name><argument_list>(<argument><expr><name><name>mtstate</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>state</name></name></expr></argument>,
								   <argument><expr><ternary><condition><expr><name><name>mtstate</name><operator>-&gt;</operator><name>mt_partition_tuple_routing</name></name></expr> ?</condition><then>
								   <expr><name>NULL</name></expr> </then><else>: <expr><name>relationDesc</name></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>onconfl</name><operator>-&gt;</operator><name>oc_ProjTupdesc</name></name> <operator>=</operator> <name>relationDesc</name></expr>;</expr_stmt>

		<comment type="block">/*
		 * The onConflictSet tlist should already have been adjusted to emit
		 * the table's exact column list.  It could also contain resjunk
		 * columns, which should be evaluated but not included in the
		 * projection result.
		 */</comment>
		<expr_stmt><expr><call><name>ExecCheckPlanOutput</name><argument_list>(<argument><expr><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_RelationDesc</name></name></expr></argument>,
							<argument><expr><name><name>node</name><operator>-&gt;</operator><name>onConflictSet</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* build UPDATE SET projection state */</comment>
		<expr_stmt><expr><name><name>onconfl</name><operator>-&gt;</operator><name>oc_ProjInfo</name></name> <operator>=</operator>
			<call><name>ExecBuildProjectionInfoExt</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>onConflictSet</name></name></expr></argument>, <argument><expr><name>econtext</name></expr></argument>,
									   <argument><expr><name><name>mtstate</name><operator>-&gt;</operator><name>mt_conflproj</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
									   <argument><expr><operator>&amp;</operator><name><name>mtstate</name><operator>-&gt;</operator><name>ps</name></name></expr></argument>,
									   <argument><expr><name>relationDesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* initialize state to evaluate the WHERE clause, if any */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>onConflictWhere</name></name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>ExprState</name>  <modifier>*</modifier></type><name>qualexpr</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>qualexpr</name> <operator>=</operator> <call><name>ExecInitQual</name><argument_list>(<argument><expr><operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator> <name><name>node</name><operator>-&gt;</operator><name>onConflictWhere</name></name></expr></argument>,
									<argument><expr><operator>&amp;</operator><name><name>mtstate</name><operator>-&gt;</operator><name>ps</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>onconfl</name><operator>-&gt;</operator><name>oc_WhereClause</name></name> <operator>=</operator> <name>qualexpr</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * If we have any secondary relations in an UPDATE or DELETE, they need to
	 * be treated like non-locked relations in SELECT FOR UPDATE, ie, the
	 * EvalPlanQual mechanism needs to be told about them.  Locate the
	 * relevant ExecRowMarks.
	 */</comment>
	<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>node-&gt;rowMarks</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>PlanRowMark</name> <modifier>*</modifier></type><name>rc</name> <init>= <expr><call><name>lfirst_node</name><argument_list>(<argument><expr><name>PlanRowMark</name></expr></argument>, <argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ExecRowMark</name> <modifier>*</modifier></type><name>erm</name></decl>;</decl_stmt>

		<comment type="block">/* ignore "parent" rowmarks; they are irrelevant at runtime */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>rc</name><operator>-&gt;</operator><name>isParent</name></name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<comment type="block">/* find ExecRowMark (same for all subplans) */</comment>
		<expr_stmt><expr><name>erm</name> <operator>=</operator> <call><name>ExecFindRowMark</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name><name>rc</name><operator>-&gt;</operator><name>rti</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* build ExecAuxRowMark for each subplan */</comment>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nplans</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>ExecAuxRowMark</name> <modifier>*</modifier></type><name>aerm</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>subplan</name> <operator>=</operator> <name><name>mtstate</name><operator>-&gt;</operator><name>mt_plans</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>plan</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>aerm</name> <operator>=</operator> <call><name>ExecBuildAuxRowMark</name><argument_list>(<argument><expr><name>erm</name></expr></argument>, <argument><expr><name><name>subplan</name><operator>-&gt;</operator><name>targetlist</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>mtstate</name><operator>-&gt;</operator><name>mt_arowmarks</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>mtstate</name><operator>-&gt;</operator><name>mt_arowmarks</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>aerm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></for>
	</block_content>}</block>

	<comment type="block">/* select first subplan */</comment>
	<expr_stmt><expr><name><name>mtstate</name><operator>-&gt;</operator><name>mt_whichplan</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>subplan</name> <operator>=</operator> <operator>(</operator><name>Plan</name> <operator>*</operator><operator>)</operator> <call><name>linitial</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>plans</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>EvalPlanQualSetPlan</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>mtstate</name><operator>-&gt;</operator><name>mt_epqstate</name></name></expr></argument>, <argument><expr><name>subplan</name></expr></argument>,
						<argument><expr><name><name>mtstate</name><operator>-&gt;</operator><name>mt_arowmarks</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Initialize the junk filter(s) if needed.  INSERT queries need a filter
	 * if there are any junk attrs in the tlist.  UPDATE and DELETE always
	 * need a filter, since there's always at least one junk attribute present
	 * --- no need to look first.  Typically, this will be a 'ctid' or
	 * 'wholerow' attribute, but in the case of a foreign data wrapper it
	 * might be a set of junk attributes sufficient to identify the remote
	 * row.
	 *
	 * If there are multiple result relations, each one needs its own junk
	 * filter.  Note multiple rels are only possible for UPDATE/DELETE, so we
	 * can't be fooled by some needing a filter and some not.
	 *
	 * This section of code is also a convenient place to verify that the
	 * output of an INSERT or UPDATE matches the target table(s).
	 */</comment>
	<block>{<block_content>
		<decl_stmt><decl><type><name>bool</name></type>		<name>junk_filter_needed</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

		<switch>switch <condition>(<expr><name>operation</name></expr>)</condition>
		<block>{<block_content>
			<case>case <expr><name>CMD_INSERT</name></expr>:</case>
				<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>subplan-&gt;targetlist</argument>)</argument_list></macro>
				<block>{<block_content>
					<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>tle</name> <init>= <expr><operator>(</operator><name>TargetEntry</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

					<if_stmt><if>if <condition>(<expr><name><name>tle</name><operator>-&gt;</operator><name>resjunk</name></name></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><name>junk_filter_needed</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
						<break>break;</break>
					</block_content>}</block></if></if_stmt>
				</block_content>}</block>
				<break>break;</break>
			<case>case <expr><name>CMD_UPDATE</name></expr>:</case>
			<case>case <expr><name>CMD_DELETE</name></expr>:</case>
				<expr_stmt><expr><name>junk_filter_needed</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<break>break;</break>
			<default>default:</default>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unknown operation"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
		</block_content>}</block></switch>

		<if_stmt><if>if <condition>(<expr><name>junk_filter_needed</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>resultRelInfo</name> <operator>=</operator> <name><name>mtstate</name><operator>-&gt;</operator><name>resultRelInfo</name></name></expr>;</expr_stmt>
			<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nplans</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
			<block>{<block_content>
				<decl_stmt><decl><type><name>JunkFilter</name> <modifier>*</modifier></type><name>j</name></decl>;</decl_stmt>

				<expr_stmt><expr><name>subplan</name> <operator>=</operator> <name><name>mtstate</name><operator>-&gt;</operator><name>mt_plans</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>plan</name></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name>operation</name> <operator>==</operator> <name>CMD_INSERT</name> <operator>||</operator> <name>operation</name> <operator>==</operator> <name>CMD_UPDATE</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ExecCheckPlanOutput</name><argument_list>(<argument><expr><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_RelationDesc</name></name></expr></argument>,
										<argument><expr><name><name>subplan</name><operator>-&gt;</operator><name>targetlist</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

				<expr_stmt><expr><name>j</name> <operator>=</operator> <call><name>ExecInitJunkFilter</name><argument_list>(<argument><expr><name><name>subplan</name><operator>-&gt;</operator><name>targetlist</name></name></expr></argument>,
									   <argument><expr><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_RelationDesc</name><operator>-&gt;</operator><name>rd_att</name><operator>-&gt;</operator><name>tdhasoid</name></name></expr></argument>,
									   <argument><expr><call><name>ExecInitExtraTupleSlot</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<if_stmt><if>if <condition>(<expr><name>operation</name> <operator>==</operator> <name>CMD_UPDATE</name> <operator>||</operator> <name>operation</name> <operator>==</operator> <name>CMD_DELETE</name></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/* For UPDATE/DELETE, find the appropriate junk attr now */</comment>
					<decl_stmt><decl><type><name>char</name></type>		<name>relkind</name></decl>;</decl_stmt>

					<expr_stmt><expr><name>relkind</name> <operator>=</operator> <name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_RelationDesc</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name></expr>;</expr_stmt>
					<if_stmt><if>if <condition>(<expr><name>relkind</name> <operator>==</operator> <name>RELKIND_RELATION</name> <operator>||</operator>
						<name>relkind</name> <operator>==</operator> <name>RELKIND_MATVIEW</name> <operator>||</operator>
						<name>relkind</name> <operator>==</operator> <name>RELKIND_PARTITIONED_TABLE</name></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><name><name>j</name><operator>-&gt;</operator><name>jf_junkAttNo</name></name> <operator>=</operator> <call><name>ExecFindJunkAttribute</name><argument_list>(<argument><expr><name>j</name></expr></argument>, <argument><expr><literal type="string">"ctid"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>AttributeNumberIsValid</name><argument_list>(<argument><expr><name><name>j</name><operator>-&gt;</operator><name>jf_junkAttNo</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
							<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"could not find junk ctid column"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

						<comment type="block">/* POLAR px */</comment>
						<if_stmt><if>if <condition>(<expr><name>px_is_executing</name></expr>)</condition>
						<block>{<block_content>
							<if_stmt><if>if <condition>(<expr><name>operation</name> <operator>==</operator> <name>CMD_UPDATE</name></expr>)</condition>
							<block>{<block_content>
								<if_stmt><if>if <condition>(<expr><name><name>mtstate</name><operator>-&gt;</operator><name>mt_isSplitUpdates</name></name> <operator>&amp;&amp;</operator> <name><name>mtstate</name><operator>-&gt;</operator><name>mt_isSplitUpdates</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition>
								<block>{<block_content>
									<expr_stmt><expr><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_action_attno</name></name> <operator>=</operator> <call><name>ExecFindJunkAttribute</name><argument_list>(<argument><expr><name>j</name></expr></argument>, <argument><expr><literal type="string">"DMLAction"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
									<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>AttributeNumberIsValid</name><argument_list>(<argument><expr><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_action_attno</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
										<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"could not find junk action column"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>									
								</block_content>}</block></if>
								<else>else
								<block>{<block_content>
									<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"parallel update could not find mt_isSplitUpdates"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
								</block_content>}</block></else></if_stmt>
							</block_content>}</block></if></if_stmt>
						</block_content>}</block></if></if_stmt>
						<comment type="block">/* POLAR px */</comment>
					</block_content>}</block></if>
					<if type="elseif">else if <condition>(<expr><name>relkind</name> <operator>==</operator> <name>RELKIND_FOREIGN_TABLE</name></expr>)</condition>
					<block>{<block_content>
						<comment type="block">/*
						 * When there is a row-level trigger, there should be
						 * a wholerow attribute.
						 */</comment>
						<expr_stmt><expr><name><name>j</name><operator>-&gt;</operator><name>jf_junkAttNo</name></name> <operator>=</operator> <call><name>ExecFindJunkAttribute</name><argument_list>(<argument><expr><name>j</name></expr></argument>, <argument><expr><literal type="string">"wholerow"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block></if>
					<else>else
					<block>{<block_content>
						<expr_stmt><expr><name><name>j</name><operator>-&gt;</operator><name>jf_junkAttNo</name></name> <operator>=</operator> <call><name>ExecFindJunkAttribute</name><argument_list>(<argument><expr><name>j</name></expr></argument>, <argument><expr><literal type="string">"wholerow"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>AttributeNumberIsValid</name><argument_list>(<argument><expr><name><name>j</name><operator>-&gt;</operator><name>jf_junkAttNo</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
							<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"could not find junk wholerow column"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
					</block_content>}</block></else></if_stmt>
				</block_content>}</block></if></if_stmt>

				<expr_stmt><expr><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_junkFilter</name></name> <operator>=</operator> <name>j</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>resultRelInfo</name><operator>++</operator></expr>;</expr_stmt>
			</block_content>}</block></for>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>operation</name> <operator>==</operator> <name>CMD_INSERT</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ExecCheckPlanOutput</name><argument_list>(<argument><expr><name><name>mtstate</name><operator>-&gt;</operator><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_RelationDesc</name></name></expr></argument>,
									<argument><expr><name><name>subplan</name><operator>-&gt;</operator><name>targetlist</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block>

	<comment type="block">/*
	 * Set up a tuple table slot for use for trigger output tuples. In a plan
	 * containing multiple ModifyTable nodes, all can share one such slot, so
	 * we keep it in the estate.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>estate</name><operator>-&gt;</operator><name>es_trig_tuple_slot</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>es_trig_tuple_slot</name></name> <operator>=</operator> <call><name>ExecInitExtraTupleSlot</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Lastly, if this is not the primary (canSetTag) ModifyTable node, add it
	 * to estate-&gt;es_auxmodifytables so that it will be run to completion by
	 * ExecPostprocessPlan.  (It'd actually work fine to add the primary
	 * ModifyTable node too, but there's no need.)  Note the use of lcons not
	 * lappend: we need later-initialized ModifyTable nodes to be shut down
	 * before earlier ones.  This ensures that we don't throw away RETURNING
	 * rows that need to be seen by a later CTE subplan.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>mtstate</name><operator>-&gt;</operator><name>canSetTag</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>es_auxmodifytables</name></name> <operator>=</operator> <call><name>lcons</name><argument_list>(<argument><expr><name>mtstate</name></expr></argument>,
										   <argument><expr><name><name>estate</name><operator>-&gt;</operator><name>es_auxmodifytables</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>mtstate</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* ----------------------------------------------------------------
 *		ExecEndModifyTable
 *
 *		Shuts down the plan.
 *
 *		Returns nothing of interest.
 * ----------------------------------------------------------------
 */</comment>
<function><type><name>void</name></type>
<name>ExecEndModifyTable</name><parameter_list>(<parameter><decl><type><name>ModifyTableState</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Allow any FDWs to shut down
	 */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>node</name><operator>-&gt;</operator><name>mt_nplans</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ResultRelInfo</name> <modifier>*</modifier></type><name>resultRelInfo</name> <init>= <expr><name><name>node</name><operator>-&gt;</operator><name>resultRelInfo</name></name> <operator>+</operator> <name>i</name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_usesFdwDirectModify</name></name> <operator>&amp;&amp;</operator>
			<name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_FdwRoutine</name></name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator>
			<name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_FdwRoutine</name><operator>-&gt;</operator><name>EndForeignModify</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_FdwRoutine</name><operator>-&gt;</operator><name>EndForeignModify</name></name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>state</name></name></expr></argument>,
														   <argument><expr><name>resultRelInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></for>

	<comment type="block">/* Close all the partitioned tables, leaf partitions, and their indices */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>mt_partition_tuple_routing</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ExecCleanupTupleRouting</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>mt_partition_tuple_routing</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Free the exprcontext
	 */</comment>
	<expr_stmt><expr><call><name>ExecFreeExprContext</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>node</name><operator>-&gt;</operator><name>ps</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * clean out the tuple table
	 */</comment>
	<expr_stmt><expr><call><name>ExecClearTuple</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>ps_ResultTupleSlot</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Terminate EPQ execution if active
	 */</comment>
	<expr_stmt><expr><call><name>EvalPlanQualEnd</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>node</name><operator>-&gt;</operator><name>mt_epqstate</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * shut down subplans
	 */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>node</name><operator>-&gt;</operator><name>mt_nplans</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ExecEndNode</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>mt_plans</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>ExecReScanModifyTable</name><parameter_list>(<parameter><decl><type><name>ModifyTableState</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * Currently, we don't need to support rescan on ModifyTable nodes. The
	 * semantics of that would be a bit debatable anyway.
	 */</comment>
	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"ExecReScanModifyTable is not implemented"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>ExecSquelchModifyTable</name><parameter_list>(<parameter><decl><type><name>ModifyTableState</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * ModifyTable nodes must run to completion when asked to Squelch so
	 * that we don't risk losing modifications which should be performed
	 * regardless of any LIMIT's or other forms for projections which could
	 * end up causing a squelch to happen.
	 */</comment>
	<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>ExecModifyTable</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>node</name><operator>-&gt;</operator><name>ps</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>result</name></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>
	</block_content>}</block></for>
</block_content>}</block></function>
</unit>
