<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/PolarDB-for-PostgreSQL/src/backend/executor/execParallel.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * execParallel.c
 *	  Support routines for parallel execution.
 *
 * Portions Copyright (c) 1996-2018, PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, Regents of the University of California
 *
 * This file contains routines that are intended to support setting up,
 * using, and tearing down a ParallelContext from within the PostgreSQL
 * executor.  The ParallelContext machinery will handle starting the
 * workers and ensuring that their state generally matches that of the
 * leader; see src/backend/access/transam/README.parallel for details.
 * However, we must save and restore relevant executor state, such as
 * any ParamListInfo associated with the query, buffer usage info, and
 * the actual plan to be passed down to the worker.
 *
 * IDENTIFICATION
 *	  src/backend/executor/execParallel.c
 *
 *-------------------------------------------------------------------------
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/execParallel.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/executor.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/nodeAppend.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/nodeBitmapHeapscan.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/nodeCustom.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/nodeForeignscan.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/nodeHash.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/nodeHashjoin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/nodeIndexscan.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/nodeIndexonlyscan.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/nodeSeqscan.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/nodeSort.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/nodeSubplan.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/tqueue.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jit/jit.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/nodeFuncs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/planmain.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/planner.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/spin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"tcop/tcopprot.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/datum.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/dsa.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/lsyscache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/memutils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/snapmgr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pgstat.h"</cpp:file></cpp:include>

<comment type="block">/*
 * Magic numbers for parallel executor communication.  We use constants
 * greater than any 32-bit integer here so that values &lt; 2^32 can be used
 * by individual parallel nodes to store their own state.
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PARALLEL_KEY_EXECUTOR_FIXED</name></cpp:macro>		<cpp:value>UINT64CONST(0xE000000000000001)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PARALLEL_KEY_PLANNEDSTMT</name></cpp:macro>		<cpp:value>UINT64CONST(0xE000000000000002)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PARALLEL_KEY_PARAMLISTINFO</name></cpp:macro>		<cpp:value>UINT64CONST(0xE000000000000003)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PARALLEL_KEY_BUFFER_USAGE</name></cpp:macro>		<cpp:value>UINT64CONST(0xE000000000000004)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PARALLEL_KEY_TUPLE_QUEUE</name></cpp:macro>		<cpp:value>UINT64CONST(0xE000000000000005)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PARALLEL_KEY_INSTRUMENTATION</name></cpp:macro>	<cpp:value>UINT64CONST(0xE000000000000006)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PARALLEL_KEY_DSA</name></cpp:macro>				<cpp:value>UINT64CONST(0xE000000000000007)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PARALLEL_KEY_QUERY_TEXT</name></cpp:macro>		<cpp:value>UINT64CONST(0xE000000000000008)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PARALLEL_KEY_JIT_INSTRUMENTATION</name></cpp:macro> <cpp:value>UINT64CONST(0xE000000000000009)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PARALLEL_TUPLE_QUEUE_SIZE</name></cpp:macro>		<cpp:value>65536</cpp:value></cpp:define>

<comment type="block">/*
 * Fixed-size random stuff that we need to pass to parallel workers.
 */</comment>
<typedef>typedef <type><struct>struct <name>FixedParallelExecutorState</name>
<block>{
	<decl_stmt><decl><type><name>int64</name></type>		<name>tuples_needed</name></decl>;</decl_stmt>	<comment type="block">/* tuple bound, see ExecSetTupleBound */</comment>
	<decl_stmt><decl><type><name>dsa_pointer</name></type> <name>param_exec</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>eflags</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>jit_flags</name></decl>;</decl_stmt>
}</block></struct></type> <name>FixedParallelExecutorState</name>;</typedef>

<comment type="block">/*
 * DSM structure for accumulating per-PlanState instrumentation.
 *
 * instrument_options: Same meaning here as in instrument.c.
 *
 * instrument_offset: Offset, relative to the start of this structure,
 * of the first Instrumentation object.  This will depend on the length of
 * the plan_node_id array.
 *
 * num_workers: Number of workers.
 *
 * num_plan_nodes: Number of plan nodes.
 *
 * plan_node_id: Array of plan nodes for which we are gathering instrumentation
 * from parallel workers.  The length of this array is given by num_plan_nodes.
 */</comment>
<struct>struct <name>SharedExecutorInstrumentation</name>
<block>{
	<decl_stmt><decl><type><name>int</name></type>			<name>instrument_options</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>instrument_offset</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>num_workers</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>num_plan_nodes</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name><name>plan_node_id</name><index>[<expr><name>FLEXIBLE_ARRAY_MEMBER</name></expr>]</index></name></decl>;</decl_stmt>
	<comment type="block">/* array of num_plan_nodes * num_workers Instrumentation objects follows */</comment>
}</block>;</struct>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GetInstrumentationArray</name><parameter_list>(<parameter><type><name>sei</name></type></parameter>)</parameter_list></cpp:macro> \
	<cpp:value>(AssertVariableIsOfTypeMacro(sei, SharedExecutorInstrumentation *), \
	 (Instrumentation *) (((char *) sei) + sei-&gt;instrument_offset))</cpp:value></cpp:define>

<comment type="block">/* Context object for ExecParallelEstimate. */</comment>
<typedef>typedef <type><struct>struct <name>ExecParallelEstimateContext</name>
<block>{
	<decl_stmt><decl><type><name>ParallelContext</name> <modifier>*</modifier></type><name>pcxt</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>nnodes</name></decl>;</decl_stmt>
}</block></struct></type> <name>ExecParallelEstimateContext</name>;</typedef>

<comment type="block">/* Context object for ExecParallelInitializeDSM. */</comment>
<typedef>typedef <type><struct>struct <name>ExecParallelInitializeDSMContext</name>
<block>{
	<decl_stmt><decl><type><name>ParallelContext</name> <modifier>*</modifier></type><name>pcxt</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SharedExecutorInstrumentation</name> <modifier>*</modifier></type><name>instrumentation</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>nnodes</name></decl>;</decl_stmt>
}</block></struct></type> <name>ExecParallelInitializeDSMContext</name>;</typedef>

<comment type="block">/* Helper functions that run in the parallel leader. */</comment>
<function_decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>ExecSerializePlan</name><parameter_list>(<parameter><decl><type><name>Plan</name> <modifier>*</modifier></type><name>plan</name></decl></parameter>, <parameter><decl><type><name>EState</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>ExecParallelEstimate</name><parameter_list>(<parameter><decl><type><name>PlanState</name> <modifier>*</modifier></type><name>node</name></decl></parameter>,
					 <parameter><decl><type><name>ExecParallelEstimateContext</name> <modifier>*</modifier></type><name>e</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>ExecParallelInitializeDSM</name><parameter_list>(<parameter><decl><type><name>PlanState</name> <modifier>*</modifier></type><name>node</name></decl></parameter>,
						  <parameter><decl><type><name>ExecParallelInitializeDSMContext</name> <modifier>*</modifier></type><name>d</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>shm_mq_handle</name> <modifier>*</modifier><modifier>*</modifier></type><name>ExecParallelSetupTupleQueues</name><parameter_list>(<parameter><decl><type><name>ParallelContext</name> <modifier>*</modifier></type><name>pcxt</name></decl></parameter>,
							 <parameter><decl><type><name>bool</name></type> <name>reinitialize</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>ExecParallelReInitializeDSM</name><parameter_list>(<parameter><decl><type><name>PlanState</name> <modifier>*</modifier></type><name>planstate</name></decl></parameter>,
							<parameter><decl><type><name>ParallelContext</name> <modifier>*</modifier></type><name>pcxt</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>ExecParallelRetrieveInstrumentation</name><parameter_list>(<parameter><decl><type><name>PlanState</name> <modifier>*</modifier></type><name>planstate</name></decl></parameter>,
									<parameter><decl><type><name>SharedExecutorInstrumentation</name> <modifier>*</modifier></type><name>instrumentation</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/* Helper function that runs in the parallel worker. */</comment>
<function_decl><type><specifier>static</specifier> <name>DestReceiver</name> <modifier>*</modifier></type><name>ExecParallelGetReceiver</name><parameter_list>(<parameter><decl><type><name>dsm_segment</name> <modifier>*</modifier></type><name>seg</name></decl></parameter>, <parameter><decl><type><name>shm_toc</name> <modifier>*</modifier></type><name>toc</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/*
 * Create a serialized representation of the plan to be sent to each worker.
 */</comment>
<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type>
<name>ExecSerializePlan</name><parameter_list>(<parameter><decl><type><name>Plan</name> <modifier>*</modifier></type><name>plan</name></decl></parameter>, <parameter><decl><type><name>EState</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PlannedStmt</name> <modifier>*</modifier></type><name>pstmt</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

	<comment type="block">/* We can't scribble on the original plan, so make a copy. */</comment>
	<expr_stmt><expr><name>plan</name> <operator>=</operator> <call><name>copyObject</name><argument_list>(<argument><expr><name>plan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * The worker will start its own copy of the executor, and that copy will
	 * insert a junk filter if the toplevel node has any resjunk entries. We
	 * don't want that to happen, because while resjunk columns shouldn't be
	 * sent back to the user, here the tuples are coming back to another
	 * backend which may very well need them.  So mutate the target list
	 * accordingly.  This is sort of a hack; there might be better ways to do
	 * this...
	 */</comment>
	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>plan-&gt;targetlist</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>tle</name> <init>= <expr><call><name>lfirst_node</name><argument_list>(<argument><expr><name>TargetEntry</name></expr></argument>, <argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>tle</name><operator>-&gt;</operator><name>resjunk</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	</block_content>}</block>

	<comment type="block">/*
	 * Create a dummy PlannedStmt.  Most of the fields don't need to be valid
	 * for our purposes, but the worker will need at least a minimal
	 * PlannedStmt to start the executor.
	 */</comment>
	<expr_stmt><expr><name>pstmt</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>PlannedStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pstmt</name><operator>-&gt;</operator><name>commandType</name></name> <operator>=</operator> <name>CMD_SELECT</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pstmt</name><operator>-&gt;</operator><name>queryId</name></name> <operator>=</operator> <call><name>UINT64CONST</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pstmt</name><operator>-&gt;</operator><name>hasReturning</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pstmt</name><operator>-&gt;</operator><name>hasModifyingCTE</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pstmt</name><operator>-&gt;</operator><name>canSetTag</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pstmt</name><operator>-&gt;</operator><name>transientPlan</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pstmt</name><operator>-&gt;</operator><name>dependsOnRole</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pstmt</name><operator>-&gt;</operator><name>parallelModeNeeded</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pstmt</name><operator>-&gt;</operator><name>planTree</name></name> <operator>=</operator> <name>plan</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pstmt</name><operator>-&gt;</operator><name>rtable</name></name> <operator>=</operator> <name><name>estate</name><operator>-&gt;</operator><name>es_range_table</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pstmt</name><operator>-&gt;</operator><name>resultRelations</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pstmt</name><operator>-&gt;</operator><name>nonleafResultRelations</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Transfer only parallel-safe subplans, leaving a NULL "hole" in the list
	 * for unsafe ones (so that the list indexes of the safe ones are
	 * preserved).  This positively ensures that the worker won't try to run,
	 * or even do ExecInitNode on, an unsafe subplan.  That's important to
	 * protect, eg, non-parallel-aware FDWs from getting into trouble.
	 */</comment>
	<expr_stmt><expr><name><name>pstmt</name><operator>-&gt;</operator><name>subplans</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>estate-&gt;es_plannedstmt-&gt;subplans</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Plan</name>	   <modifier>*</modifier></type><name>subplan</name> <init>= <expr><operator>(</operator><name>Plan</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>subplan</name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>subplan</name><operator>-&gt;</operator><name>parallel_safe</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>subplan</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name><name>pstmt</name><operator>-&gt;</operator><name>subplans</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>pstmt</name><operator>-&gt;</operator><name>subplans</name></name></expr></argument>, <argument><expr><name>subplan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<expr_stmt><expr><name><name>pstmt</name><operator>-&gt;</operator><name>rewindPlanIDs</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pstmt</name><operator>-&gt;</operator><name>rowMarks</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pstmt</name><operator>-&gt;</operator><name>relationOids</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pstmt</name><operator>-&gt;</operator><name>invalItems</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>	<comment type="block">/* workers can't replan anyway... */</comment>
	<expr_stmt><expr><name><name>pstmt</name><operator>-&gt;</operator><name>paramExecTypes</name></name> <operator>=</operator> <name><name>estate</name><operator>-&gt;</operator><name>es_plannedstmt</name><operator>-&gt;</operator><name>paramExecTypes</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pstmt</name><operator>-&gt;</operator><name>utilityStmt</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pstmt</name><operator>-&gt;</operator><name>stmt_location</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pstmt</name><operator>-&gt;</operator><name>stmt_len</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>

	<comment type="block">/* Return serialized copy of our dummy PlannedStmt. */</comment>
	<return>return <expr><call><name>nodeToString</name><argument_list>(<argument><expr><name>pstmt</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Parallel-aware plan nodes (and occasionally others) may need some state
 * which is shared across all parallel workers.  Before we size the DSM, give
 * them a chance to call shm_toc_estimate_chunk or shm_toc_estimate_keys on
 * &amp;pcxt-&gt;estimator.
 *
 * While we're at it, count the number of PlanState nodes in the tree, so
 * we know how many Instrumentation structures we need.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>ExecParallelEstimate</name><parameter_list>(<parameter><decl><type><name>PlanState</name> <modifier>*</modifier></type><name>planstate</name></decl></parameter>, <parameter><decl><type><name>ExecParallelEstimateContext</name> <modifier>*</modifier></type><name>e</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>planstate</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* Count this node. */</comment>
	<expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>nnodes</name></name><operator>++</operator></expr>;</expr_stmt>

	<switch>switch <condition>(<expr><call><name>nodeTag</name><argument_list>(<argument><expr><name>planstate</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>T_SeqScanState</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><name><name>planstate</name><operator>-&gt;</operator><name>plan</name><operator>-&gt;</operator><name>parallel_aware</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ExecSeqScanEstimate</name><argument_list>(<argument><expr><operator>(</operator><name>SeqScanState</name> <operator>*</operator><operator>)</operator> <name>planstate</name></expr></argument>,
									<argument><expr><name><name>e</name><operator>-&gt;</operator><name>pcxt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<break>break;</break>
		<case>case <expr><name>T_IndexScanState</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><name><name>planstate</name><operator>-&gt;</operator><name>plan</name><operator>-&gt;</operator><name>parallel_aware</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ExecIndexScanEstimate</name><argument_list>(<argument><expr><operator>(</operator><name>IndexScanState</name> <operator>*</operator><operator>)</operator> <name>planstate</name></expr></argument>,
									  <argument><expr><name><name>e</name><operator>-&gt;</operator><name>pcxt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<break>break;</break>
		<case>case <expr><name>T_IndexOnlyScanState</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><name><name>planstate</name><operator>-&gt;</operator><name>plan</name><operator>-&gt;</operator><name>parallel_aware</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ExecIndexOnlyScanEstimate</name><argument_list>(<argument><expr><operator>(</operator><name>IndexOnlyScanState</name> <operator>*</operator><operator>)</operator> <name>planstate</name></expr></argument>,
										  <argument><expr><name><name>e</name><operator>-&gt;</operator><name>pcxt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<break>break;</break>
		<case>case <expr><name>T_ForeignScanState</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><name><name>planstate</name><operator>-&gt;</operator><name>plan</name><operator>-&gt;</operator><name>parallel_aware</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ExecForeignScanEstimate</name><argument_list>(<argument><expr><operator>(</operator><name>ForeignScanState</name> <operator>*</operator><operator>)</operator> <name>planstate</name></expr></argument>,
										<argument><expr><name><name>e</name><operator>-&gt;</operator><name>pcxt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<break>break;</break>
		<case>case <expr><name>T_AppendState</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><name><name>planstate</name><operator>-&gt;</operator><name>plan</name><operator>-&gt;</operator><name>parallel_aware</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ExecAppendEstimate</name><argument_list>(<argument><expr><operator>(</operator><name>AppendState</name> <operator>*</operator><operator>)</operator> <name>planstate</name></expr></argument>,
								   <argument><expr><name><name>e</name><operator>-&gt;</operator><name>pcxt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<break>break;</break>
		<case>case <expr><name>T_CustomScanState</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><name><name>planstate</name><operator>-&gt;</operator><name>plan</name><operator>-&gt;</operator><name>parallel_aware</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ExecCustomScanEstimate</name><argument_list>(<argument><expr><operator>(</operator><name>CustomScanState</name> <operator>*</operator><operator>)</operator> <name>planstate</name></expr></argument>,
									   <argument><expr><name><name>e</name><operator>-&gt;</operator><name>pcxt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<break>break;</break>
		<case>case <expr><name>T_BitmapHeapScanState</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><name><name>planstate</name><operator>-&gt;</operator><name>plan</name><operator>-&gt;</operator><name>parallel_aware</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ExecBitmapHeapEstimate</name><argument_list>(<argument><expr><operator>(</operator><name>BitmapHeapScanState</name> <operator>*</operator><operator>)</operator> <name>planstate</name></expr></argument>,
									   <argument><expr><name><name>e</name><operator>-&gt;</operator><name>pcxt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<break>break;</break>
		<case>case <expr><name>T_HashJoinState</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><name><name>planstate</name><operator>-&gt;</operator><name>plan</name><operator>-&gt;</operator><name>parallel_aware</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ExecHashJoinEstimate</name><argument_list>(<argument><expr><operator>(</operator><name>HashJoinState</name> <operator>*</operator><operator>)</operator> <name>planstate</name></expr></argument>,
									 <argument><expr><name><name>e</name><operator>-&gt;</operator><name>pcxt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<break>break;</break>
		<case>case <expr><name>T_HashState</name></expr>:</case>
			<comment type="block">/* even when not parallel-aware, for EXPLAIN ANALYZE */</comment>
			<expr_stmt><expr><call><name>ExecHashEstimate</name><argument_list>(<argument><expr><operator>(</operator><name>HashState</name> <operator>*</operator><operator>)</operator> <name>planstate</name></expr></argument>, <argument><expr><name><name>e</name><operator>-&gt;</operator><name>pcxt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_SortState</name></expr>:</case>
			<comment type="block">/* even when not parallel-aware, for EXPLAIN ANALYZE */</comment>
			<expr_stmt><expr><call><name>ExecSortEstimate</name><argument_list>(<argument><expr><operator>(</operator><name>SortState</name> <operator>*</operator><operator>)</operator> <name>planstate</name></expr></argument>, <argument><expr><name><name>e</name><operator>-&gt;</operator><name>pcxt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<default>default:</default>
			<break>break;</break>
	</block_content>}</block></switch>

	<return>return <expr><call><name>planstate_tree_walker</name><argument_list>(<argument><expr><name>planstate</name></expr></argument>, <argument><expr><name>ExecParallelEstimate</name></expr></argument>, <argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Estimate the amount of space required to serialize the indicated parameters.
 */</comment>
<function><type><specifier>static</specifier> <name>Size</name></type>
<name>EstimateParamExecSpace</name><parameter_list>(<parameter><decl><type><name>EState</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>, <parameter><decl><type><name>Bitmapset</name> <modifier>*</modifier></type><name>params</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>paramid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Size</name></type>		<name>sz</name> <init>= <expr><sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>paramid</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
	<while>while <condition>(<expr><operator>(</operator><name>paramid</name> <operator>=</operator> <call><name>bms_next_member</name><argument_list>(<argument><expr><name>params</name></expr></argument>, <argument><expr><name>paramid</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>typeOid</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int16</name></type>		<name>typLen</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>typByVal</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ParamExecData</name> <modifier>*</modifier></type><name>prm</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>prm</name> <operator>=</operator> <operator>&amp;</operator><operator>(</operator><name><name>estate</name><operator>-&gt;</operator><name>es_param_exec_vals</name><index>[<expr><name>paramid</name></expr>]</index></name><operator>)</operator></expr>;</expr_stmt>
		<expr_stmt><expr><name>typeOid</name> <operator>=</operator> <call><name>list_nth_oid</name><argument_list>(<argument><expr><name><name>estate</name><operator>-&gt;</operator><name>es_plannedstmt</name><operator>-&gt;</operator><name>paramExecTypes</name></name></expr></argument>,
							   <argument><expr><name>paramid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>sz</name> <operator>=</operator> <call><name>add_size</name><argument_list>(<argument><expr><name>sz</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* space for paramid */</comment>

		<comment type="block">/* space for datum/isnull */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>typeOid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>get_typlenbyval</name><argument_list>(<argument><expr><name>typeOid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>typLen</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>typByVal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/* If no type OID, assume by-value, like copyParamList does. */</comment>
			<expr_stmt><expr><name>typLen</name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Datum</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
			<expr_stmt><expr><name>typByVal</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
		<expr_stmt><expr><name>sz</name> <operator>=</operator> <call><name>add_size</name><argument_list>(<argument><expr><name>sz</name></expr></argument>,
					  <argument><expr><call><name>datumEstimateSpace</name><argument_list>(<argument><expr><name><name>prm</name><operator>-&gt;</operator><name>value</name></name></expr></argument>, <argument><expr><name><name>prm</name><operator>-&gt;</operator><name>isnull</name></name></expr></argument>,
										 <argument><expr><name>typByVal</name></expr></argument>, <argument><expr><name>typLen</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></while>
	<return>return <expr><name>sz</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Serialize specified PARAM_EXEC parameters.
 *
 * We write the number of parameters first, as a 4-byte integer, and then
 * write details for each parameter in turn.  The details for each parameter
 * consist of a 4-byte paramid (location of param in execution time internal
 * parameter array) and then the datum as serialized by datumSerialize().
 */</comment>
<function><type><specifier>static</specifier> <name>dsa_pointer</name></type>
<name>SerializeParamExecParams</name><parameter_list>(<parameter><decl><type><name>EState</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>, <parameter><decl><type><name>Bitmapset</name> <modifier>*</modifier></type><name>params</name></decl></parameter>, <parameter><decl><type><name>dsa_area</name> <modifier>*</modifier></type><name>area</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Size</name></type>		<name>size</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>nparams</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>paramid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ParamExecData</name> <modifier>*</modifier></type><name>prm</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>dsa_pointer</name></type> <name>handle</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>start_address</name></decl>;</decl_stmt>

	<comment type="block">/* Allocate enough space for the current parameter values. */</comment>
	<expr_stmt><expr><name>size</name> <operator>=</operator> <call><name>EstimateParamExecSpace</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name>params</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>handle</name> <operator>=</operator> <call><name>dsa_allocate</name><argument_list>(<argument><expr><name>area</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>start_address</name> <operator>=</operator> <call><name>dsa_get_address</name><argument_list>(<argument><expr><name>area</name></expr></argument>, <argument><expr><name>handle</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* First write the number of parameters as a 4-byte integer. */</comment>
	<expr_stmt><expr><name>nparams</name> <operator>=</operator> <call><name>bms_num_members</name><argument_list>(<argument><expr><name>params</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>start_address</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nparams</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>start_address</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>

	<comment type="block">/* Write details for each parameter in turn. */</comment>
	<expr_stmt><expr><name>paramid</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
	<while>while <condition>(<expr><operator>(</operator><name>paramid</name> <operator>=</operator> <call><name>bms_next_member</name><argument_list>(<argument><expr><name>params</name></expr></argument>, <argument><expr><name>paramid</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>typeOid</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int16</name></type>		<name>typLen</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>typByVal</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>prm</name> <operator>=</operator> <operator>&amp;</operator><operator>(</operator><name><name>estate</name><operator>-&gt;</operator><name>es_param_exec_vals</name><index>[<expr><name>paramid</name></expr>]</index></name><operator>)</operator></expr>;</expr_stmt>
		<expr_stmt><expr><name>typeOid</name> <operator>=</operator> <call><name>list_nth_oid</name><argument_list>(<argument><expr><name><name>estate</name><operator>-&gt;</operator><name>es_plannedstmt</name><operator>-&gt;</operator><name>paramExecTypes</name></name></expr></argument>,
							   <argument><expr><name>paramid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Write paramid. */</comment>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>start_address</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>paramid</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>start_address</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>

		<comment type="block">/* Write datum/isnull */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>typeOid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>get_typlenbyval</name><argument_list>(<argument><expr><name>typeOid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>typLen</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>typByVal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/* If no type OID, assume by-value, like copyParamList does. */</comment>
			<expr_stmt><expr><name>typLen</name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Datum</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
			<expr_stmt><expr><name>typByVal</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
		<expr_stmt><expr><call><name>datumSerialize</name><argument_list>(<argument><expr><name><name>prm</name><operator>-&gt;</operator><name>value</name></name></expr></argument>, <argument><expr><name><name>prm</name><operator>-&gt;</operator><name>isnull</name></name></expr></argument>, <argument><expr><name>typByVal</name></expr></argument>, <argument><expr><name>typLen</name></expr></argument>,
					   <argument><expr><operator>&amp;</operator><name>start_address</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></while>

	<return>return <expr><name>handle</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Restore specified PARAM_EXEC parameters.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>RestoreParamExecParams</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>start_address</name></decl></parameter>, <parameter><decl><type><name>EState</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>nparams</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>paramid</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>nparams</name></expr></argument>, <argument><expr><name>start_address</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>start_address</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nparams</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ParamExecData</name> <modifier>*</modifier></type><name>prm</name></decl>;</decl_stmt>

		<comment type="block">/* Read paramid */</comment>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>paramid</name></expr></argument>, <argument><expr><name>start_address</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>start_address</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
		<expr_stmt><expr><name>prm</name> <operator>=</operator> <operator>&amp;</operator><operator>(</operator><name><name>estate</name><operator>-&gt;</operator><name>es_param_exec_vals</name><index>[<expr><name>paramid</name></expr>]</index></name><operator>)</operator></expr>;</expr_stmt>

		<comment type="block">/* Read datum/isnull. */</comment>
		<expr_stmt><expr><name><name>prm</name><operator>-&gt;</operator><name>value</name></name> <operator>=</operator> <call><name>datumRestore</name><argument_list>(<argument><expr><operator>&amp;</operator><name>start_address</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>prm</name><operator>-&gt;</operator><name>isnull</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>prm</name><operator>-&gt;</operator><name>execPlan</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	</block_content>}</block></for>
</block_content>}</block></function>

<comment type="block">/*
 * Initialize the dynamic shared memory segment that will be used to control
 * parallel execution.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>ExecParallelInitializeDSM</name><parameter_list>(<parameter><decl><type><name>PlanState</name> <modifier>*</modifier></type><name>planstate</name></decl></parameter>,
						  <parameter><decl><type><name>ExecParallelInitializeDSMContext</name> <modifier>*</modifier></type><name>d</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>planstate</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* If instrumentation is enabled, initialize slot for this node. */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>d</name><operator>-&gt;</operator><name>instrumentation</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>d</name><operator>-&gt;</operator><name>instrumentation</name><operator>-&gt;</operator><name>plan_node_id</name><index>[<expr><name><name>d</name><operator>-&gt;</operator><name>nnodes</name></name></expr>]</index></name> <operator>=</operator>
			<name><name>planstate</name><operator>-&gt;</operator><name>plan</name><operator>-&gt;</operator><name>plan_node_id</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Count this node. */</comment>
	<expr_stmt><expr><name><name>d</name><operator>-&gt;</operator><name>nnodes</name></name><operator>++</operator></expr>;</expr_stmt>

	<comment type="block">/*
	 * Call initializers for DSM-using plan nodes.
	 *
	 * Most plan nodes won't do anything here, but plan nodes that allocated
	 * DSM may need to initialize shared state in the DSM before parallel
	 * workers are launched.  They can allocate the space they previously
	 * estimated using shm_toc_allocate, and add the keys they previously
	 * estimated using shm_toc_insert, in each case targeting pcxt-&gt;toc.
	 */</comment>
	<switch>switch <condition>(<expr><call><name>nodeTag</name><argument_list>(<argument><expr><name>planstate</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>T_SeqScanState</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><name><name>planstate</name><operator>-&gt;</operator><name>plan</name><operator>-&gt;</operator><name>parallel_aware</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ExecSeqScanInitializeDSM</name><argument_list>(<argument><expr><operator>(</operator><name>SeqScanState</name> <operator>*</operator><operator>)</operator> <name>planstate</name></expr></argument>,
										 <argument><expr><name><name>d</name><operator>-&gt;</operator><name>pcxt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<break>break;</break>
		<case>case <expr><name>T_IndexScanState</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><name><name>planstate</name><operator>-&gt;</operator><name>plan</name><operator>-&gt;</operator><name>parallel_aware</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ExecIndexScanInitializeDSM</name><argument_list>(<argument><expr><operator>(</operator><name>IndexScanState</name> <operator>*</operator><operator>)</operator> <name>planstate</name></expr></argument>,
										   <argument><expr><name><name>d</name><operator>-&gt;</operator><name>pcxt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<break>break;</break>
		<case>case <expr><name>T_IndexOnlyScanState</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><name><name>planstate</name><operator>-&gt;</operator><name>plan</name><operator>-&gt;</operator><name>parallel_aware</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ExecIndexOnlyScanInitializeDSM</name><argument_list>(<argument><expr><operator>(</operator><name>IndexOnlyScanState</name> <operator>*</operator><operator>)</operator> <name>planstate</name></expr></argument>,
											   <argument><expr><name><name>d</name><operator>-&gt;</operator><name>pcxt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<break>break;</break>
		<case>case <expr><name>T_ForeignScanState</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><name><name>planstate</name><operator>-&gt;</operator><name>plan</name><operator>-&gt;</operator><name>parallel_aware</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ExecForeignScanInitializeDSM</name><argument_list>(<argument><expr><operator>(</operator><name>ForeignScanState</name> <operator>*</operator><operator>)</operator> <name>planstate</name></expr></argument>,
											 <argument><expr><name><name>d</name><operator>-&gt;</operator><name>pcxt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<break>break;</break>
		<case>case <expr><name>T_AppendState</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><name><name>planstate</name><operator>-&gt;</operator><name>plan</name><operator>-&gt;</operator><name>parallel_aware</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ExecAppendInitializeDSM</name><argument_list>(<argument><expr><operator>(</operator><name>AppendState</name> <operator>*</operator><operator>)</operator> <name>planstate</name></expr></argument>,
										<argument><expr><name><name>d</name><operator>-&gt;</operator><name>pcxt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<break>break;</break>
		<case>case <expr><name>T_CustomScanState</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><name><name>planstate</name><operator>-&gt;</operator><name>plan</name><operator>-&gt;</operator><name>parallel_aware</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ExecCustomScanInitializeDSM</name><argument_list>(<argument><expr><operator>(</operator><name>CustomScanState</name> <operator>*</operator><operator>)</operator> <name>planstate</name></expr></argument>,
											<argument><expr><name><name>d</name><operator>-&gt;</operator><name>pcxt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<break>break;</break>
		<case>case <expr><name>T_BitmapHeapScanState</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><name><name>planstate</name><operator>-&gt;</operator><name>plan</name><operator>-&gt;</operator><name>parallel_aware</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ExecBitmapHeapInitializeDSM</name><argument_list>(<argument><expr><operator>(</operator><name>BitmapHeapScanState</name> <operator>*</operator><operator>)</operator> <name>planstate</name></expr></argument>,
											<argument><expr><name><name>d</name><operator>-&gt;</operator><name>pcxt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<break>break;</break>
		<case>case <expr><name>T_HashJoinState</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><name><name>planstate</name><operator>-&gt;</operator><name>plan</name><operator>-&gt;</operator><name>parallel_aware</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ExecHashJoinInitializeDSM</name><argument_list>(<argument><expr><operator>(</operator><name>HashJoinState</name> <operator>*</operator><operator>)</operator> <name>planstate</name></expr></argument>,
										  <argument><expr><name><name>d</name><operator>-&gt;</operator><name>pcxt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<break>break;</break>
		<case>case <expr><name>T_HashState</name></expr>:</case>
			<comment type="block">/* even when not parallel-aware, for EXPLAIN ANALYZE */</comment>
			<expr_stmt><expr><call><name>ExecHashInitializeDSM</name><argument_list>(<argument><expr><operator>(</operator><name>HashState</name> <operator>*</operator><operator>)</operator> <name>planstate</name></expr></argument>, <argument><expr><name><name>d</name><operator>-&gt;</operator><name>pcxt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_SortState</name></expr>:</case>
			<comment type="block">/* even when not parallel-aware, for EXPLAIN ANALYZE */</comment>
			<expr_stmt><expr><call><name>ExecSortInitializeDSM</name><argument_list>(<argument><expr><operator>(</operator><name>SortState</name> <operator>*</operator><operator>)</operator> <name>planstate</name></expr></argument>, <argument><expr><name><name>d</name><operator>-&gt;</operator><name>pcxt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<default>default:</default>
			<break>break;</break>
	</block_content>}</block></switch>

	<return>return <expr><call><name>planstate_tree_walker</name><argument_list>(<argument><expr><name>planstate</name></expr></argument>, <argument><expr><name>ExecParallelInitializeDSM</name></expr></argument>, <argument><expr><name>d</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * It sets up the response queues for backend workers to return tuples
 * to the main backend and start the workers.
 */</comment>
<function><type><specifier>static</specifier> <name>shm_mq_handle</name> <modifier>*</modifier><modifier>*</modifier></type>
<name>ExecParallelSetupTupleQueues</name><parameter_list>(<parameter><decl><type><name>ParallelContext</name> <modifier>*</modifier></type><name>pcxt</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>reinitialize</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>shm_mq_handle</name> <modifier>*</modifier><modifier>*</modifier></type><name>responseq</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>tqueuespace</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<comment type="block">/* Skip this if no workers. */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>pcxt</name><operator>-&gt;</operator><name>nworkers</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* Allocate memory for shared memory queue handles. */</comment>
	<expr_stmt><expr><name>responseq</name> <operator>=</operator> <operator>(</operator><name>shm_mq_handle</name> <operator>*</operator><operator>*</operator><operator>)</operator>
		<call><name>palloc</name><argument_list>(<argument><expr><name><name>pcxt</name><operator>-&gt;</operator><name>nworkers</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>shm_mq_handle</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If not reinitializing, allocate space from the DSM for the queues;
	 * otherwise, find the already allocated space.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>reinitialize</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>tqueuespace</name> <operator>=</operator>
			<call><name>shm_toc_allocate</name><argument_list>(<argument><expr><name><name>pcxt</name><operator>-&gt;</operator><name>toc</name></name></expr></argument>,
							 <argument><expr><call><name>mul_size</name><argument_list>(<argument><expr><name>PARALLEL_TUPLE_QUEUE_SIZE</name></expr></argument>,
									  <argument><expr><name><name>pcxt</name><operator>-&gt;</operator><name>nworkers</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>tqueuespace</name> <operator>=</operator> <call><name>shm_toc_lookup</name><argument_list>(<argument><expr><name><name>pcxt</name><operator>-&gt;</operator><name>toc</name></name></expr></argument>, <argument><expr><name>PARALLEL_KEY_TUPLE_QUEUE</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/* Create the queues, and become the receiver for each. */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>pcxt</name><operator>-&gt;</operator><name>nworkers</name></name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>shm_mq</name>	   <modifier>*</modifier></type><name>mq</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>mq</name> <operator>=</operator> <call><name>shm_mq_create</name><argument_list>(<argument><expr><name>tqueuespace</name> <operator>+</operator>
						   <operator>(</operator><operator>(</operator><name>Size</name><operator>)</operator> <name>i</name><operator>)</operator> <operator>*</operator> <name>PARALLEL_TUPLE_QUEUE_SIZE</name></expr></argument>,
						   <argument><expr><operator>(</operator><name>Size</name><operator>)</operator> <name>PARALLEL_TUPLE_QUEUE_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>shm_mq_set_receiver</name><argument_list>(<argument><expr><name>mq</name></expr></argument>, <argument><expr><name>MyProc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>responseq</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>shm_mq_attach</name><argument_list>(<argument><expr><name>mq</name></expr></argument>, <argument><expr><name><name>pcxt</name><operator>-&gt;</operator><name>seg</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<comment type="block">/* Add array of queues to shm_toc, so others can find it. */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>reinitialize</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>shm_toc_insert</name><argument_list>(<argument><expr><name><name>pcxt</name><operator>-&gt;</operator><name>toc</name></name></expr></argument>, <argument><expr><name>PARALLEL_KEY_TUPLE_QUEUE</name></expr></argument>, <argument><expr><name>tqueuespace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Return array of handles. */</comment>
	<return>return <expr><name>responseq</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Sets up the required infrastructure for backend workers to perform
 * execution and return results to the main backend.
 */</comment>
<function><type><name>ParallelExecutorInfo</name> <modifier>*</modifier></type>
<name>ExecInitParallelPlan</name><parameter_list>(<parameter><decl><type><name>PlanState</name> <modifier>*</modifier></type><name>planstate</name></decl></parameter>, <parameter><decl><type><name>EState</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>,
					 <parameter><decl><type><name>Bitmapset</name> <modifier>*</modifier></type><name>sendParams</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nworkers</name></decl></parameter>,
					 <parameter><decl><type><name>int64</name></type> <name>tuples_needed</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ParallelExecutorInfo</name> <modifier>*</modifier></type><name>pei</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ParallelContext</name> <modifier>*</modifier></type><name>pcxt</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ExecParallelEstimateContext</name></type> <name>e</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ExecParallelInitializeDSMContext</name></type> <name>d</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>FixedParallelExecutorState</name> <modifier>*</modifier></type><name>fpes</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>pstmt_data</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>pstmt_space</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>paramlistinfo_space</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BufferUsage</name> <modifier>*</modifier></type><name>bufusage_space</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SharedExecutorInstrumentation</name> <modifier>*</modifier></type><name>instrumentation</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SharedJitInstrumentation</name> <modifier>*</modifier></type><name>jit_instrumentation</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>pstmt_len</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>paramlistinfo_len</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>instrumentation_len</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>jit_instrumentation_len</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>instrument_offset</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Size</name></type>		<name>dsa_minsize</name> <init>= <expr><call><name>dsa_minimum_size</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>query_string</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>query_len</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Force any initplan outputs that we're going to pass to workers to be
	 * evaluated, if they weren't already.
	 *
	 * For simplicity, we use the EState's per-output-tuple ExprContext here.
	 * That risks intra-query memory leakage, since we might pass through here
	 * many times before that ExprContext gets reset; but ExecSetParamPlan
	 * doesn't normally leak any memory in the context (see its comments), so
	 * it doesn't seem worth complicating this function's API to pass it a
	 * shorter-lived ExprContext.  This might need to change someday.
	 */</comment>
	<expr_stmt><expr><call><name>ExecSetParamPlanMulti</name><argument_list>(<argument><expr><name>sendParams</name></expr></argument>, <argument><expr><call><name>GetPerTupleExprContext</name><argument_list>(<argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Allocate object for return value. */</comment>
	<expr_stmt><expr><name>pei</name> <operator>=</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ParallelExecutorInfo</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pei</name><operator>-&gt;</operator><name>finished</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pei</name><operator>-&gt;</operator><name>planstate</name></name> <operator>=</operator> <name>planstate</name></expr>;</expr_stmt>

	<comment type="block">/* Fix up and serialize plan to be sent to workers. */</comment>
	<expr_stmt><expr><name>pstmt_data</name> <operator>=</operator> <call><name>ExecSerializePlan</name><argument_list>(<argument><expr><name><name>planstate</name><operator>-&gt;</operator><name>plan</name></name></expr></argument>, <argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Create a parallel context. */</comment>
	<expr_stmt><expr><name>pcxt</name> <operator>=</operator> <call><name>CreateParallelContext</name><argument_list>(<argument><expr><literal type="string">"postgres"</literal></expr></argument>, <argument><expr><literal type="string">"ParallelQueryMain"</literal></expr></argument>, <argument><expr><name>nworkers</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pei</name><operator>-&gt;</operator><name>pcxt</name></name> <operator>=</operator> <name>pcxt</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Before telling the parallel context to create a dynamic shared memory
	 * segment, we need to figure out how big it should be.  Estimate space
	 * for the various things we need to store.
	 */</comment>

	<comment type="block">/* Estimate space for fixed-size state. */</comment>
	<expr_stmt><expr><call><name>shm_toc_estimate_chunk</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pcxt</name><operator>-&gt;</operator><name>estimator</name></name></expr></argument>,
						   <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>FixedParallelExecutorState</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>shm_toc_estimate_keys</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pcxt</name><operator>-&gt;</operator><name>estimator</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Estimate space for query text. */</comment>
	<expr_stmt><expr><name>query_len</name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name><name>estate</name><operator>-&gt;</operator><name>es_sourceText</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>shm_toc_estimate_chunk</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pcxt</name><operator>-&gt;</operator><name>estimator</name></name></expr></argument>, <argument><expr><name>query_len</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>shm_toc_estimate_keys</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pcxt</name><operator>-&gt;</operator><name>estimator</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Estimate space for serialized PlannedStmt. */</comment>
	<expr_stmt><expr><name>pstmt_len</name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>pstmt_data</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>shm_toc_estimate_chunk</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pcxt</name><operator>-&gt;</operator><name>estimator</name></name></expr></argument>, <argument><expr><name>pstmt_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>shm_toc_estimate_keys</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pcxt</name><operator>-&gt;</operator><name>estimator</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Estimate space for serialized ParamListInfo. */</comment>
	<expr_stmt><expr><name>paramlistinfo_len</name> <operator>=</operator> <call><name>EstimateParamListSpace</name><argument_list>(<argument><expr><name><name>estate</name><operator>-&gt;</operator><name>es_param_list_info</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>shm_toc_estimate_chunk</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pcxt</name><operator>-&gt;</operator><name>estimator</name></name></expr></argument>, <argument><expr><name>paramlistinfo_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>shm_toc_estimate_keys</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pcxt</name><operator>-&gt;</operator><name>estimator</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Estimate space for BufferUsage.
	 *
	 * If EXPLAIN is not in use and there are no extensions loaded that care,
	 * we could skip this.  But we have no way of knowing whether anyone's
	 * looking at pgBufferUsage, so do it unconditionally.
	 */</comment>
	<expr_stmt><expr><call><name>shm_toc_estimate_chunk</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pcxt</name><operator>-&gt;</operator><name>estimator</name></name></expr></argument>,
						   <argument><expr><call><name>mul_size</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>BufferUsage</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name><name>pcxt</name><operator>-&gt;</operator><name>nworkers</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>shm_toc_estimate_keys</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pcxt</name><operator>-&gt;</operator><name>estimator</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Estimate space for tuple queues. */</comment>
	<expr_stmt><expr><call><name>shm_toc_estimate_chunk</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pcxt</name><operator>-&gt;</operator><name>estimator</name></name></expr></argument>,
						   <argument><expr><call><name>mul_size</name><argument_list>(<argument><expr><name>PARALLEL_TUPLE_QUEUE_SIZE</name></expr></argument>, <argument><expr><name><name>pcxt</name><operator>-&gt;</operator><name>nworkers</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>shm_toc_estimate_keys</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pcxt</name><operator>-&gt;</operator><name>estimator</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Give parallel-aware nodes a chance to add to the estimates, and get a
	 * count of how many PlanState nodes there are.
	 */</comment>
	<expr_stmt><expr><name><name>e</name><operator>.</operator><name>pcxt</name></name> <operator>=</operator> <name>pcxt</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>e</name><operator>.</operator><name>nnodes</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ExecParallelEstimate</name><argument_list>(<argument><expr><name>planstate</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Estimate space for instrumentation, if required. */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>estate</name><operator>-&gt;</operator><name>es_instrument</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>instrumentation_len</name> <operator>=</operator>
			<call><name>offsetof</name><argument_list>(<argument><expr><name>SharedExecutorInstrumentation</name></expr></argument>, <argument><expr><name>plan_node_id</name></expr></argument>)</argument_list></call> <operator>+</operator>
			<sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>e</name><operator>.</operator><name>nnodes</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>instrumentation_len</name> <operator>=</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><name>instrumentation_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>instrument_offset</name> <operator>=</operator> <name>instrumentation_len</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>instrumentation_len</name> <operator>+=</operator>
			<call><name>mul_size</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Instrumentation</name></expr></argument>)</argument_list></sizeof></expr></argument>,
					 <argument><expr><call><name>mul_size</name><argument_list>(<argument><expr><name><name>e</name><operator>.</operator><name>nnodes</name></name></expr></argument>, <argument><expr><name>nworkers</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>shm_toc_estimate_chunk</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pcxt</name><operator>-&gt;</operator><name>estimator</name></name></expr></argument>, <argument><expr><name>instrumentation_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>shm_toc_estimate_keys</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pcxt</name><operator>-&gt;</operator><name>estimator</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Estimate space for JIT instrumentation, if required. */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>estate</name><operator>-&gt;</operator><name>es_jit_flags</name></name> <operator>!=</operator> <name>PGJIT_NONE</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>jit_instrumentation_len</name> <operator>=</operator>
				<call><name>offsetof</name><argument_list>(<argument><expr><name>SharedJitInstrumentation</name></expr></argument>, <argument><expr><name>jit_instr</name></expr></argument>)</argument_list></call> <operator>+</operator>
				<sizeof>sizeof<argument_list>(<argument><expr><name>JitInstrumentation</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>nworkers</name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>shm_toc_estimate_chunk</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pcxt</name><operator>-&gt;</operator><name>estimator</name></name></expr></argument>, <argument><expr><name>jit_instrumentation_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>shm_toc_estimate_keys</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pcxt</name><operator>-&gt;</operator><name>estimator</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Estimate space for DSA area. */</comment>
	<expr_stmt><expr><call><name>shm_toc_estimate_chunk</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pcxt</name><operator>-&gt;</operator><name>estimator</name></name></expr></argument>, <argument><expr><name>dsa_minsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>shm_toc_estimate_keys</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pcxt</name><operator>-&gt;</operator><name>estimator</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Everyone's had a chance to ask for space, so now create the DSM. */</comment>
	<expr_stmt><expr><call><name>InitializeParallelDSM</name><argument_list>(<argument><expr><name>pcxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * OK, now we have a dynamic shared memory segment, and it should be big
	 * enough to store all of the data we estimated we would want to put into
	 * it, plus whatever general stuff (not specifically executor-related) the
	 * ParallelContext itself needs to store there.  None of the space we
	 * asked for has been allocated or initialized yet, though, so do that.
	 */</comment>

	<comment type="block">/* Store fixed-size state. */</comment>
	<expr_stmt><expr><name>fpes</name> <operator>=</operator> <call><name>shm_toc_allocate</name><argument_list>(<argument><expr><name><name>pcxt</name><operator>-&gt;</operator><name>toc</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>FixedParallelExecutorState</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fpes</name><operator>-&gt;</operator><name>tuples_needed</name></name> <operator>=</operator> <name>tuples_needed</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fpes</name><operator>-&gt;</operator><name>param_exec</name></name> <operator>=</operator> <name>InvalidDsaPointer</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fpes</name><operator>-&gt;</operator><name>eflags</name></name> <operator>=</operator> <name><name>estate</name><operator>-&gt;</operator><name>es_top_eflags</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fpes</name><operator>-&gt;</operator><name>jit_flags</name></name> <operator>=</operator> <name><name>estate</name><operator>-&gt;</operator><name>es_jit_flags</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>shm_toc_insert</name><argument_list>(<argument><expr><name><name>pcxt</name><operator>-&gt;</operator><name>toc</name></name></expr></argument>, <argument><expr><name>PARALLEL_KEY_EXECUTOR_FIXED</name></expr></argument>, <argument><expr><name>fpes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Store query string */</comment>
	<expr_stmt><expr><name>query_string</name> <operator>=</operator> <call><name>shm_toc_allocate</name><argument_list>(<argument><expr><name><name>pcxt</name><operator>-&gt;</operator><name>toc</name></name></expr></argument>, <argument><expr><name>query_len</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>query_string</name></expr></argument>, <argument><expr><name><name>estate</name><operator>-&gt;</operator><name>es_sourceText</name></name></expr></argument>, <argument><expr><name>query_len</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>shm_toc_insert</name><argument_list>(<argument><expr><name><name>pcxt</name><operator>-&gt;</operator><name>toc</name></name></expr></argument>, <argument><expr><name>PARALLEL_KEY_QUERY_TEXT</name></expr></argument>, <argument><expr><name>query_string</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Store serialized PlannedStmt. */</comment>
	<expr_stmt><expr><name>pstmt_space</name> <operator>=</operator> <call><name>shm_toc_allocate</name><argument_list>(<argument><expr><name><name>pcxt</name><operator>-&gt;</operator><name>toc</name></name></expr></argument>, <argument><expr><name>pstmt_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>pstmt_space</name></expr></argument>, <argument><expr><name>pstmt_data</name></expr></argument>, <argument><expr><name>pstmt_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>shm_toc_insert</name><argument_list>(<argument><expr><name><name>pcxt</name><operator>-&gt;</operator><name>toc</name></name></expr></argument>, <argument><expr><name>PARALLEL_KEY_PLANNEDSTMT</name></expr></argument>, <argument><expr><name>pstmt_space</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Store serialized ParamListInfo. */</comment>
	<expr_stmt><expr><name>paramlistinfo_space</name> <operator>=</operator> <call><name>shm_toc_allocate</name><argument_list>(<argument><expr><name><name>pcxt</name><operator>-&gt;</operator><name>toc</name></name></expr></argument>, <argument><expr><name>paramlistinfo_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>shm_toc_insert</name><argument_list>(<argument><expr><name><name>pcxt</name><operator>-&gt;</operator><name>toc</name></name></expr></argument>, <argument><expr><name>PARALLEL_KEY_PARAMLISTINFO</name></expr></argument>, <argument><expr><name>paramlistinfo_space</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SerializeParamList</name><argument_list>(<argument><expr><name><name>estate</name><operator>-&gt;</operator><name>es_param_list_info</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>paramlistinfo_space</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Allocate space for each worker's BufferUsage; no need to initialize. */</comment>
	<expr_stmt><expr><name>bufusage_space</name> <operator>=</operator> <call><name>shm_toc_allocate</name><argument_list>(<argument><expr><name><name>pcxt</name><operator>-&gt;</operator><name>toc</name></name></expr></argument>,
									  <argument><expr><call><name>mul_size</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>BufferUsage</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name><name>pcxt</name><operator>-&gt;</operator><name>nworkers</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>shm_toc_insert</name><argument_list>(<argument><expr><name><name>pcxt</name><operator>-&gt;</operator><name>toc</name></name></expr></argument>, <argument><expr><name>PARALLEL_KEY_BUFFER_USAGE</name></expr></argument>, <argument><expr><name>bufusage_space</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pei</name><operator>-&gt;</operator><name>buffer_usage</name></name> <operator>=</operator> <name>bufusage_space</name></expr>;</expr_stmt>

	<comment type="block">/* Set up the tuple queues that the workers will write into. */</comment>
	<expr_stmt><expr><name><name>pei</name><operator>-&gt;</operator><name>tqueue</name></name> <operator>=</operator> <call><name>ExecParallelSetupTupleQueues</name><argument_list>(<argument><expr><name>pcxt</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* We don't need the TupleQueueReaders yet, though. */</comment>
	<expr_stmt><expr><name><name>pei</name><operator>-&gt;</operator><name>reader</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * If instrumentation options were supplied, allocate space for the data.
	 * It only gets partially initialized here; the rest happens during
	 * ExecParallelInitializeDSM.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>estate</name><operator>-&gt;</operator><name>es_instrument</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Instrumentation</name> <modifier>*</modifier></type><name>instrument</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>instrumentation</name> <operator>=</operator> <call><name>shm_toc_allocate</name><argument_list>(<argument><expr><name><name>pcxt</name><operator>-&gt;</operator><name>toc</name></name></expr></argument>, <argument><expr><name>instrumentation_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>instrumentation</name><operator>-&gt;</operator><name>instrument_options</name></name> <operator>=</operator> <name><name>estate</name><operator>-&gt;</operator><name>es_instrument</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>instrumentation</name><operator>-&gt;</operator><name>instrument_offset</name></name> <operator>=</operator> <name>instrument_offset</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>instrumentation</name><operator>-&gt;</operator><name>num_workers</name></name> <operator>=</operator> <name>nworkers</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>instrumentation</name><operator>-&gt;</operator><name>num_plan_nodes</name></name> <operator>=</operator> <name><name>e</name><operator>.</operator><name>nnodes</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>instrument</name> <operator>=</operator> <call><name>GetInstrumentationArray</name><argument_list>(<argument><expr><name>instrumentation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nworkers</name> <operator>*</operator> <name><name>e</name><operator>.</operator><name>nnodes</name></name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>InstrInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>instrument</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>estate</name><operator>-&gt;</operator><name>es_instrument</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
		<expr_stmt><expr><call><name>shm_toc_insert</name><argument_list>(<argument><expr><name><name>pcxt</name><operator>-&gt;</operator><name>toc</name></name></expr></argument>, <argument><expr><name>PARALLEL_KEY_INSTRUMENTATION</name></expr></argument>,
					   <argument><expr><name>instrumentation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>pei</name><operator>-&gt;</operator><name>instrumentation</name></name> <operator>=</operator> <name>instrumentation</name></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>estate</name><operator>-&gt;</operator><name>es_jit_flags</name></name> <operator>!=</operator> <name>PGJIT_NONE</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>jit_instrumentation</name> <operator>=</operator> <call><name>shm_toc_allocate</name><argument_list>(<argument><expr><name><name>pcxt</name><operator>-&gt;</operator><name>toc</name></name></expr></argument>,
												   <argument><expr><name>jit_instrumentation_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>jit_instrumentation</name><operator>-&gt;</operator><name>num_workers</name></name> <operator>=</operator> <name>nworkers</name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name><name>jit_instrumentation</name><operator>-&gt;</operator><name>jit_instr</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
				   <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>JitInstrumentation</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>nworkers</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>shm_toc_insert</name><argument_list>(<argument><expr><name><name>pcxt</name><operator>-&gt;</operator><name>toc</name></name></expr></argument>, <argument><expr><name>PARALLEL_KEY_JIT_INSTRUMENTATION</name></expr></argument>,
						   <argument><expr><name>jit_instrumentation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>pei</name><operator>-&gt;</operator><name>jit_instrumentation</name></name> <operator>=</operator> <name>jit_instrumentation</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Create a DSA area that can be used by the leader and all workers.
	 * (However, if we failed to create a DSM and are using private memory
	 * instead, then skip this.)
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>pcxt</name><operator>-&gt;</operator><name>seg</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>area_space</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>area_space</name> <operator>=</operator> <call><name>shm_toc_allocate</name><argument_list>(<argument><expr><name><name>pcxt</name><operator>-&gt;</operator><name>toc</name></name></expr></argument>, <argument><expr><name>dsa_minsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>shm_toc_insert</name><argument_list>(<argument><expr><name><name>pcxt</name><operator>-&gt;</operator><name>toc</name></name></expr></argument>, <argument><expr><name>PARALLEL_KEY_DSA</name></expr></argument>, <argument><expr><name>area_space</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>pei</name><operator>-&gt;</operator><name>area</name></name> <operator>=</operator> <call><name>dsa_create_in_place</name><argument_list>(<argument><expr><name>area_space</name></expr></argument>, <argument><expr><name>dsa_minsize</name></expr></argument>,
										<argument><expr><name>LWTRANCHE_PARALLEL_QUERY_DSA</name></expr></argument>,
										<argument><expr><name><name>pcxt</name><operator>-&gt;</operator><name>seg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Serialize parameters, if any, using DSA storage.  We don't dare use
		 * the main parallel query DSM for this because we might relaunch
		 * workers after the values have changed (and thus the amount of
		 * storage required has changed).
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>bms_is_empty</name><argument_list>(<argument><expr><name>sendParams</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>pei</name><operator>-&gt;</operator><name>param_exec</name></name> <operator>=</operator> <call><name>SerializeParamExecParams</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name>sendParams</name></expr></argument>,
													   <argument><expr><name><name>pei</name><operator>-&gt;</operator><name>area</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>fpes</name><operator>-&gt;</operator><name>param_exec</name></name> <operator>=</operator> <name><name>pei</name><operator>-&gt;</operator><name>param_exec</name></name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Give parallel-aware nodes a chance to initialize their shared data.
	 * This also initializes the elements of instrumentation-&gt;ps_instrument,
	 * if it exists.
	 */</comment>
	<expr_stmt><expr><name><name>d</name><operator>.</operator><name>pcxt</name></name> <operator>=</operator> <name>pcxt</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>d</name><operator>.</operator><name>instrumentation</name></name> <operator>=</operator> <name>instrumentation</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>d</name><operator>.</operator><name>nnodes</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<comment type="block">/* Install our DSA area while initializing the plan. */</comment>
	<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>es_query_dsa</name></name> <operator>=</operator> <name><name>pei</name><operator>-&gt;</operator><name>area</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ExecParallelInitializeDSM</name><argument_list>(<argument><expr><name>planstate</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>d</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>es_query_dsa</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Make sure that the world hasn't shifted under our feet.  This could
	 * probably just be an Assert(), but let's be conservative for now.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>e</name><operator>.</operator><name>nnodes</name></name> <operator>!=</operator> <name><name>d</name><operator>.</operator><name>nnodes</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"inconsistent count of PlanState nodes"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* OK, we're ready to rock and roll. */</comment>
	<return>return <expr><name>pei</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Set up tuple queue readers to read the results of a parallel subplan.
 *
 * This is separate from ExecInitParallelPlan() because we can launch the
 * worker processes and let them start doing something before we do this.
 */</comment>
<function><type><name>void</name></type>
<name>ExecParallelCreateReaders</name><parameter_list>(<parameter><decl><type><name>ParallelExecutorInfo</name> <modifier>*</modifier></type><name>pei</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>nworkers</name> <init>= <expr><name><name>pei</name><operator>-&gt;</operator><name>pcxt</name><operator>-&gt;</operator><name>nworkers_launched</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>pei</name><operator>-&gt;</operator><name>reader</name></name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>nworkers</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>pei</name><operator>-&gt;</operator><name>reader</name></name> <operator>=</operator> <operator>(</operator><name>TupleQueueReader</name> <operator>*</operator><operator>*</operator><operator>)</operator>
			<call><name>palloc</name><argument_list>(<argument><expr><name>nworkers</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>TupleQueueReader</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nworkers</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<expr_stmt><expr><call><name>shm_mq_set_handle</name><argument_list>(<argument><expr><name><name>pei</name><operator>-&gt;</operator><name>tqueue</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,
							  <argument><expr><name><name>pei</name><operator>-&gt;</operator><name>pcxt</name><operator>-&gt;</operator><name>worker</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>bgwhandle</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>pei</name><operator>-&gt;</operator><name>reader</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>CreateTupleQueueReader</name><argument_list>(<argument><expr><name><name>pei</name><operator>-&gt;</operator><name>tqueue</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></for>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Re-initialize the parallel executor shared memory state before launching
 * a fresh batch of workers.
 */</comment>
<function><type><name>void</name></type>
<name>ExecParallelReinitialize</name><parameter_list>(<parameter><decl><type><name>PlanState</name> <modifier>*</modifier></type><name>planstate</name></decl></parameter>,
						 <parameter><decl><type><name>ParallelExecutorInfo</name> <modifier>*</modifier></type><name>pei</name></decl></parameter>,
						 <parameter><decl><type><name>Bitmapset</name> <modifier>*</modifier></type><name>sendParams</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>EState</name>	   <modifier>*</modifier></type><name>estate</name> <init>= <expr><name><name>planstate</name><operator>-&gt;</operator><name>state</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>FixedParallelExecutorState</name> <modifier>*</modifier></type><name>fpes</name></decl>;</decl_stmt>

	<comment type="block">/* Old workers must already be shut down */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>pei</name><operator>-&gt;</operator><name>finished</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Force any initplan outputs that we're going to pass to workers to be
	 * evaluated, if they weren't already (see comments in
	 * ExecInitParallelPlan).
	 */</comment>
	<expr_stmt><expr><call><name>ExecSetParamPlanMulti</name><argument_list>(<argument><expr><name>sendParams</name></expr></argument>, <argument><expr><call><name>GetPerTupleExprContext</name><argument_list>(<argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ReinitializeParallelDSM</name><argument_list>(<argument><expr><name><name>pei</name><operator>-&gt;</operator><name>pcxt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pei</name><operator>-&gt;</operator><name>tqueue</name></name> <operator>=</operator> <call><name>ExecParallelSetupTupleQueues</name><argument_list>(<argument><expr><name><name>pei</name><operator>-&gt;</operator><name>pcxt</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pei</name><operator>-&gt;</operator><name>reader</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pei</name><operator>-&gt;</operator><name>finished</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>fpes</name> <operator>=</operator> <call><name>shm_toc_lookup</name><argument_list>(<argument><expr><name><name>pei</name><operator>-&gt;</operator><name>pcxt</name><operator>-&gt;</operator><name>toc</name></name></expr></argument>, <argument><expr><name>PARALLEL_KEY_EXECUTOR_FIXED</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Free any serialized parameters from the last round. */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>DsaPointerIsValid</name><argument_list>(<argument><expr><name><name>fpes</name><operator>-&gt;</operator><name>param_exec</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>dsa_free</name><argument_list>(<argument><expr><name><name>pei</name><operator>-&gt;</operator><name>area</name></name></expr></argument>, <argument><expr><name><name>fpes</name><operator>-&gt;</operator><name>param_exec</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>fpes</name><operator>-&gt;</operator><name>param_exec</name></name> <operator>=</operator> <name>InvalidDsaPointer</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Serialize current parameter values if required. */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>bms_is_empty</name><argument_list>(<argument><expr><name>sendParams</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>pei</name><operator>-&gt;</operator><name>param_exec</name></name> <operator>=</operator> <call><name>SerializeParamExecParams</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name>sendParams</name></expr></argument>,
												   <argument><expr><name><name>pei</name><operator>-&gt;</operator><name>area</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>fpes</name><operator>-&gt;</operator><name>param_exec</name></name> <operator>=</operator> <name><name>pei</name><operator>-&gt;</operator><name>param_exec</name></name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Traverse plan tree and let each child node reset associated state. */</comment>
	<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>es_query_dsa</name></name> <operator>=</operator> <name><name>pei</name><operator>-&gt;</operator><name>area</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ExecParallelReInitializeDSM</name><argument_list>(<argument><expr><name>planstate</name></expr></argument>, <argument><expr><name><name>pei</name><operator>-&gt;</operator><name>pcxt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>es_query_dsa</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Traverse plan tree to reinitialize per-node dynamic shared memory state
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>ExecParallelReInitializeDSM</name><parameter_list>(<parameter><decl><type><name>PlanState</name> <modifier>*</modifier></type><name>planstate</name></decl></parameter>,
							<parameter><decl><type><name>ParallelContext</name> <modifier>*</modifier></type><name>pcxt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>planstate</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Call reinitializers for DSM-using plan nodes.
	 */</comment>
	<switch>switch <condition>(<expr><call><name>nodeTag</name><argument_list>(<argument><expr><name>planstate</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>T_SeqScanState</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><name><name>planstate</name><operator>-&gt;</operator><name>plan</name><operator>-&gt;</operator><name>parallel_aware</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ExecSeqScanReInitializeDSM</name><argument_list>(<argument><expr><operator>(</operator><name>SeqScanState</name> <operator>*</operator><operator>)</operator> <name>planstate</name></expr></argument>,
										   <argument><expr><name>pcxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<break>break;</break>
		<case>case <expr><name>T_IndexScanState</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><name><name>planstate</name><operator>-&gt;</operator><name>plan</name><operator>-&gt;</operator><name>parallel_aware</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ExecIndexScanReInitializeDSM</name><argument_list>(<argument><expr><operator>(</operator><name>IndexScanState</name> <operator>*</operator><operator>)</operator> <name>planstate</name></expr></argument>,
											 <argument><expr><name>pcxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<break>break;</break>
		<case>case <expr><name>T_IndexOnlyScanState</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><name><name>planstate</name><operator>-&gt;</operator><name>plan</name><operator>-&gt;</operator><name>parallel_aware</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ExecIndexOnlyScanReInitializeDSM</name><argument_list>(<argument><expr><operator>(</operator><name>IndexOnlyScanState</name> <operator>*</operator><operator>)</operator> <name>planstate</name></expr></argument>,
												 <argument><expr><name>pcxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<break>break;</break>
		<case>case <expr><name>T_ForeignScanState</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><name><name>planstate</name><operator>-&gt;</operator><name>plan</name><operator>-&gt;</operator><name>parallel_aware</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ExecForeignScanReInitializeDSM</name><argument_list>(<argument><expr><operator>(</operator><name>ForeignScanState</name> <operator>*</operator><operator>)</operator> <name>planstate</name></expr></argument>,
											   <argument><expr><name>pcxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<break>break;</break>
		<case>case <expr><name>T_AppendState</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><name><name>planstate</name><operator>-&gt;</operator><name>plan</name><operator>-&gt;</operator><name>parallel_aware</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ExecAppendReInitializeDSM</name><argument_list>(<argument><expr><operator>(</operator><name>AppendState</name> <operator>*</operator><operator>)</operator> <name>planstate</name></expr></argument>, <argument><expr><name>pcxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<break>break;</break>
		<case>case <expr><name>T_CustomScanState</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><name><name>planstate</name><operator>-&gt;</operator><name>plan</name><operator>-&gt;</operator><name>parallel_aware</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ExecCustomScanReInitializeDSM</name><argument_list>(<argument><expr><operator>(</operator><name>CustomScanState</name> <operator>*</operator><operator>)</operator> <name>planstate</name></expr></argument>,
											  <argument><expr><name>pcxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<break>break;</break>
		<case>case <expr><name>T_BitmapHeapScanState</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><name><name>planstate</name><operator>-&gt;</operator><name>plan</name><operator>-&gt;</operator><name>parallel_aware</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ExecBitmapHeapReInitializeDSM</name><argument_list>(<argument><expr><operator>(</operator><name>BitmapHeapScanState</name> <operator>*</operator><operator>)</operator> <name>planstate</name></expr></argument>,
											  <argument><expr><name>pcxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<break>break;</break>
		<case>case <expr><name>T_HashJoinState</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><name><name>planstate</name><operator>-&gt;</operator><name>plan</name><operator>-&gt;</operator><name>parallel_aware</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ExecHashJoinReInitializeDSM</name><argument_list>(<argument><expr><operator>(</operator><name>HashJoinState</name> <operator>*</operator><operator>)</operator> <name>planstate</name></expr></argument>,
											<argument><expr><name>pcxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<break>break;</break>
		<case>case <expr><name>T_HashState</name></expr>:</case>
		<case>case <expr><name>T_SortState</name></expr>:</case>
			<comment type="block">/* these nodes have DSM state, but no reinitialization is required */</comment>
			<break>break;</break>

		<default>default:</default>
			<break>break;</break>
	</block_content>}</block></switch>

	<return>return <expr><call><name>planstate_tree_walker</name><argument_list>(<argument><expr><name>planstate</name></expr></argument>, <argument><expr><name>ExecParallelReInitializeDSM</name></expr></argument>, <argument><expr><name>pcxt</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Copy instrumentation information about this node and its descendants from
 * dynamic shared memory.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>ExecParallelRetrieveInstrumentation</name><parameter_list>(<parameter><decl><type><name>PlanState</name> <modifier>*</modifier></type><name>planstate</name></decl></parameter>,
									<parameter><decl><type><name>SharedExecutorInstrumentation</name> <modifier>*</modifier></type><name>instrumentation</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Instrumentation</name> <modifier>*</modifier></type><name>instrument</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>n</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>ibytes</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>plan_node_id</name> <init>= <expr><name><name>planstate</name><operator>-&gt;</operator><name>plan</name><operator>-&gt;</operator><name>plan_node_id</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcontext</name></decl>;</decl_stmt>

	<comment type="block">/* Find the instrumentation for this node. */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>instrumentation</name><operator>-&gt;</operator><name>num_plan_nodes</name></name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control><block type="pseudo"><block_content>
		<if_stmt><if>if <condition>(<expr><name><name>instrumentation</name><operator>-&gt;</operator><name>plan_node_id</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <name>plan_node_id</name></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt></block_content></block></for>
	<if_stmt><if>if <condition>(<expr><name>i</name> <operator>&gt;=</operator> <name><name>instrumentation</name><operator>-&gt;</operator><name>num_plan_nodes</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"plan node %d not found"</literal></expr></argument>, <argument><expr><name>plan_node_id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Accumulate the statistics from all workers. */</comment>
	<expr_stmt><expr><name>instrument</name> <operator>=</operator> <call><name>GetInstrumentationArray</name><argument_list>(<argument><expr><name>instrumentation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>instrument</name> <operator>+=</operator> <name>i</name> <operator>*</operator> <name><name>instrumentation</name><operator>-&gt;</operator><name>num_workers</name></name></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>n</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>n</name> <operator>&lt;</operator> <name><name>instrumentation</name><operator>-&gt;</operator><name>num_workers</name></name></expr>;</condition> <incr><expr><operator>++</operator><name>n</name></expr></incr>)</control><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>InstrAggNode</name><argument_list>(<argument><expr><name><name>planstate</name><operator>-&gt;</operator><name>instrument</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>instrument</name><index>[<expr><name>n</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>

	<comment type="block">/*
	 * Also store the per-worker detail.
	 *
	 * Worker instrumentation should be allocated in the same context as the
	 * regular instrumentation information, which is the per-query context.
	 * Switch into per-query memory context.
	 */</comment>
	<expr_stmt><expr><name>oldcontext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>planstate</name><operator>-&gt;</operator><name>state</name><operator>-&gt;</operator><name>es_query_cxt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>ibytes</name> <operator>=</operator> <call><name>mul_size</name><argument_list>(<argument><expr><name><name>instrumentation</name><operator>-&gt;</operator><name>num_workers</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Instrumentation</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>planstate</name><operator>-&gt;</operator><name>worker_instrument</name></name> <operator>=</operator>
		<call><name>palloc</name><argument_list>(<argument><expr><name>ibytes</name> <operator>+</operator> <call><name>offsetof</name><argument_list>(<argument><expr><name>WorkerInstrumentation</name></expr></argument>, <argument><expr><name>instrument</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>planstate</name><operator>-&gt;</operator><name>worker_instrument</name><operator>-&gt;</operator><name>num_workers</name></name> <operator>=</operator> <name><name>instrumentation</name><operator>-&gt;</operator><name>num_workers</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>planstate</name><operator>-&gt;</operator><name>worker_instrument</name><operator>-&gt;</operator><name>instrument</name></name></expr></argument>, <argument><expr><name>instrument</name></expr></argument>, <argument><expr><name>ibytes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Perform any node-type-specific work that needs to be done. */</comment>
	<switch>switch <condition>(<expr><call><name>nodeTag</name><argument_list>(<argument><expr><name>planstate</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>T_SortState</name></expr>:</case>
			<expr_stmt><expr><call><name>ExecSortRetrieveInstrumentation</name><argument_list>(<argument><expr><operator>(</operator><name>SortState</name> <operator>*</operator><operator>)</operator> <name>planstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_HashState</name></expr>:</case>
			<expr_stmt><expr><call><name>ExecHashRetrieveInstrumentation</name><argument_list>(<argument><expr><operator>(</operator><name>HashState</name> <operator>*</operator><operator>)</operator> <name>planstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<default>default:</default>
			<break>break;</break>
	</block_content>}</block></switch>

	<return>return <expr><call><name>planstate_tree_walker</name><argument_list>(<argument><expr><name>planstate</name></expr></argument>, <argument><expr><name>ExecParallelRetrieveInstrumentation</name></expr></argument>,
								 <argument><expr><name>instrumentation</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Add up the workers' JIT instrumentation from dynamic shared memory.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ExecParallelRetrieveJitInstrumentation</name><parameter_list>(<parameter><decl><type><name>PlanState</name> <modifier>*</modifier></type><name>planstate</name></decl></parameter>,
									   <parameter><decl><type><name>SharedJitInstrumentation</name> <modifier>*</modifier></type><name>shared_jit</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>JitInstrumentation</name> <modifier>*</modifier></type><name>combined</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>ibytes</name></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>int</name></type>			<name>n</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Accumulate worker JIT instrumentation into the combined JIT
	 * instrumentation, allocating it if required.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>planstate</name><operator>-&gt;</operator><name>state</name><operator>-&gt;</operator><name>es_jit_worker_instr</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>planstate</name><operator>-&gt;</operator><name>state</name><operator>-&gt;</operator><name>es_jit_worker_instr</name></name> <operator>=</operator>
			<call><name>MemoryContextAllocZero</name><argument_list>(<argument><expr><name><name>planstate</name><operator>-&gt;</operator><name>state</name><operator>-&gt;</operator><name>es_query_cxt</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>JitInstrumentation</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>combined</name> <operator>=</operator> <name><name>planstate</name><operator>-&gt;</operator><name>state</name><operator>-&gt;</operator><name>es_jit_worker_instr</name></name></expr>;</expr_stmt>

	<comment type="block">/* Accumulate all the workers' instrumentations. */</comment>
	<for>for <control>(<init><expr><name>n</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>n</name> <operator>&lt;</operator> <name><name>shared_jit</name><operator>-&gt;</operator><name>num_workers</name></name></expr>;</condition> <incr><expr><operator>++</operator><name>n</name></expr></incr>)</control><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>InstrJitAgg</name><argument_list>(<argument><expr><name>combined</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>shared_jit</name><operator>-&gt;</operator><name>jit_instr</name><index>[<expr><name>n</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>

	<comment type="block">/*
	 * Store the per-worker detail.
	 *
	 * Similar to ExecParallelRetrieveInstrumentation(), allocate the
	 * instrumentation in per-query context.
	 */</comment>
	<expr_stmt><expr><name>ibytes</name> <operator>=</operator> <call><name>offsetof</name><argument_list>(<argument><expr><name>SharedJitInstrumentation</name></expr></argument>, <argument><expr><name>jit_instr</name></expr></argument>)</argument_list></call>
			 <operator>+</operator> <call><name>mul_size</name><argument_list>(<argument><expr><name><name>shared_jit</name><operator>-&gt;</operator><name>num_workers</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>JitInstrumentation</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>planstate</name><operator>-&gt;</operator><name>worker_jit_instrument</name></name> <operator>=</operator>
		<call><name>MemoryContextAlloc</name><argument_list>(<argument><expr><name><name>planstate</name><operator>-&gt;</operator><name>state</name><operator>-&gt;</operator><name>es_query_cxt</name></name></expr></argument>, <argument><expr><name>ibytes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>planstate</name><operator>-&gt;</operator><name>worker_jit_instrument</name></name></expr></argument>, <argument><expr><name>shared_jit</name></expr></argument>, <argument><expr><name>ibytes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Finish parallel execution.  We wait for parallel workers to finish, and
 * accumulate their buffer usage.
 */</comment>
<function><type><name>void</name></type>
<name>ExecParallelFinish</name><parameter_list>(<parameter><decl><type><name>ParallelExecutorInfo</name> <modifier>*</modifier></type><name>pei</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>nworkers</name> <init>= <expr><name><name>pei</name><operator>-&gt;</operator><name>pcxt</name><operator>-&gt;</operator><name>nworkers_launched</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<comment type="block">/* Make this be a no-op if called twice in a row. */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>pei</name><operator>-&gt;</operator><name>finished</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Detach from tuple queues ASAP, so that any still-active workers will
	 * notice that no further results are wanted.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>pei</name><operator>-&gt;</operator><name>tqueue</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nworkers</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>shm_mq_detach</name><argument_list>(<argument><expr><name><name>pei</name><operator>-&gt;</operator><name>tqueue</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>pei</name><operator>-&gt;</operator><name>tqueue</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>pei</name><operator>-&gt;</operator><name>tqueue</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * While we're waiting for the workers to finish, let's get rid of the
	 * tuple queue readers.  (Any other local cleanup could be done here too.)
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>pei</name><operator>-&gt;</operator><name>reader</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nworkers</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>DestroyTupleQueueReader</name><argument_list>(<argument><expr><name><name>pei</name><operator>-&gt;</operator><name>reader</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>pei</name><operator>-&gt;</operator><name>reader</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>pei</name><operator>-&gt;</operator><name>reader</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Now wait for the workers to finish. */</comment>
	<expr_stmt><expr><call><name>WaitForParallelWorkersToFinish</name><argument_list>(<argument><expr><name><name>pei</name><operator>-&gt;</operator><name>pcxt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Next, accumulate buffer usage.  (This must wait for the workers to
	 * finish, or we might get incomplete data.)
	 */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nworkers</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>InstrAccumParallelQuery</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pei</name><operator>-&gt;</operator><name>buffer_usage</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>

	<expr_stmt><expr><name><name>pei</name><operator>-&gt;</operator><name>finished</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Accumulate instrumentation, and then clean up whatever ParallelExecutorInfo
 * resources still exist after ExecParallelFinish.  We separate these
 * routines because someone might want to examine the contents of the DSM
 * after ExecParallelFinish and before calling this routine.
 */</comment>
<function><type><name>void</name></type>
<name>ExecParallelCleanup</name><parameter_list>(<parameter><decl><type><name>ParallelExecutorInfo</name> <modifier>*</modifier></type><name>pei</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* Accumulate instrumentation, if any. */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>pei</name><operator>-&gt;</operator><name>instrumentation</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ExecParallelRetrieveInstrumentation</name><argument_list>(<argument><expr><name><name>pei</name><operator>-&gt;</operator><name>planstate</name></name></expr></argument>,
											<argument><expr><name><name>pei</name><operator>-&gt;</operator><name>instrumentation</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Accumulate JIT instrumentation, if any. */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>pei</name><operator>-&gt;</operator><name>jit_instrumentation</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ExecParallelRetrieveJitInstrumentation</name><argument_list>(<argument><expr><name><name>pei</name><operator>-&gt;</operator><name>planstate</name></name></expr></argument>,
											<argument><expr><name><name>pei</name><operator>-&gt;</operator><name>jit_instrumentation</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Free any serialized parameters. */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>DsaPointerIsValid</name><argument_list>(<argument><expr><name><name>pei</name><operator>-&gt;</operator><name>param_exec</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>dsa_free</name><argument_list>(<argument><expr><name><name>pei</name><operator>-&gt;</operator><name>area</name></name></expr></argument>, <argument><expr><name><name>pei</name><operator>-&gt;</operator><name>param_exec</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>pei</name><operator>-&gt;</operator><name>param_exec</name></name> <operator>=</operator> <name>InvalidDsaPointer</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>pei</name><operator>-&gt;</operator><name>area</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>dsa_detach</name><argument_list>(<argument><expr><name><name>pei</name><operator>-&gt;</operator><name>area</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>pei</name><operator>-&gt;</operator><name>area</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>pei</name><operator>-&gt;</operator><name>pcxt</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>DestroyParallelContext</name><argument_list>(<argument><expr><name><name>pei</name><operator>-&gt;</operator><name>pcxt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>pei</name><operator>-&gt;</operator><name>pcxt</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>pei</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Create a DestReceiver to write tuples we produce to the shm_mq designated
 * for that purpose.
 */</comment>
<function><type><specifier>static</specifier> <name>DestReceiver</name> <modifier>*</modifier></type>
<name>ExecParallelGetReceiver</name><parameter_list>(<parameter><decl><type><name>dsm_segment</name> <modifier>*</modifier></type><name>seg</name></decl></parameter>, <parameter><decl><type><name>shm_toc</name> <modifier>*</modifier></type><name>toc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>mqspace</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>shm_mq</name>	   <modifier>*</modifier></type><name>mq</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>mqspace</name> <operator>=</operator> <call><name>shm_toc_lookup</name><argument_list>(<argument><expr><name>toc</name></expr></argument>, <argument><expr><name>PARALLEL_KEY_TUPLE_QUEUE</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>mqspace</name> <operator>+=</operator> <name>ParallelWorkerNumber</name> <operator>*</operator> <name>PARALLEL_TUPLE_QUEUE_SIZE</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>mq</name> <operator>=</operator> <operator>(</operator><name>shm_mq</name> <operator>*</operator><operator>)</operator> <name>mqspace</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>shm_mq_set_sender</name><argument_list>(<argument><expr><name>mq</name></expr></argument>, <argument><expr><name>MyProc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><call><name>CreateTupleQueueDestReceiver</name><argument_list>(<argument><expr><call><name>shm_mq_attach</name><argument_list>(<argument><expr><name>mq</name></expr></argument>, <argument><expr><name>seg</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Create a QueryDesc for the PlannedStmt we are to execute, and return it.
 */</comment>
<function><type><specifier>static</specifier> <name>QueryDesc</name> <modifier>*</modifier></type>
<name>ExecParallelGetQueryDesc</name><parameter_list>(<parameter><decl><type><name>shm_toc</name> <modifier>*</modifier></type><name>toc</name></decl></parameter>, <parameter><decl><type><name>DestReceiver</name> <modifier>*</modifier></type><name>receiver</name></decl></parameter>,
						 <parameter><decl><type><name>int</name></type> <name>instrument_options</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>pstmtspace</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>paramspace</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PlannedStmt</name> <modifier>*</modifier></type><name>pstmt</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ParamListInfo</name></type> <name>paramLI</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>queryString</name></decl>;</decl_stmt>

	<comment type="block">/* Get the query string from shared memory */</comment>
	<expr_stmt><expr><name>queryString</name> <operator>=</operator> <call><name>shm_toc_lookup</name><argument_list>(<argument><expr><name>toc</name></expr></argument>, <argument><expr><name>PARALLEL_KEY_QUERY_TEXT</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Reconstruct leader-supplied PlannedStmt. */</comment>
	<expr_stmt><expr><name>pstmtspace</name> <operator>=</operator> <call><name>shm_toc_lookup</name><argument_list>(<argument><expr><name>toc</name></expr></argument>, <argument><expr><name>PARALLEL_KEY_PLANNEDSTMT</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>pstmt</name> <operator>=</operator> <operator>(</operator><name>PlannedStmt</name> <operator>*</operator><operator>)</operator> <call><name>stringToNode</name><argument_list>(<argument><expr><name>pstmtspace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Reconstruct ParamListInfo. */</comment>
	<expr_stmt><expr><name>paramspace</name> <operator>=</operator> <call><name>shm_toc_lookup</name><argument_list>(<argument><expr><name>toc</name></expr></argument>, <argument><expr><name>PARALLEL_KEY_PARAMLISTINFO</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>paramLI</name> <operator>=</operator> <call><name>RestoreParamList</name><argument_list>(<argument><expr><operator>&amp;</operator><name>paramspace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Create a QueryDesc for the query. */</comment>
	<return>return <expr><call><name>CreateQueryDesc</name><argument_list>(<argument><expr><name>pstmt</name></expr></argument>,
						   <argument><expr><name>queryString</name></expr></argument>,
						   <argument><expr><call><name>GetActiveSnapshot</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>InvalidSnapshot</name></expr></argument>,
						   <argument><expr><name>receiver</name></expr></argument>, <argument><expr><name>paramLI</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>instrument_options</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Copy instrumentation information from this node and its descendants into
 * dynamic shared memory, so that the parallel leader can retrieve it.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>ExecParallelReportInstrumentation</name><parameter_list>(<parameter><decl><type><name>PlanState</name> <modifier>*</modifier></type><name>planstate</name></decl></parameter>,
								  <parameter><decl><type><name>SharedExecutorInstrumentation</name> <modifier>*</modifier></type><name>instrumentation</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>plan_node_id</name> <init>= <expr><name><name>planstate</name><operator>-&gt;</operator><name>plan</name><operator>-&gt;</operator><name>plan_node_id</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Instrumentation</name> <modifier>*</modifier></type><name>instrument</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>InstrEndLoop</name><argument_list>(<argument><expr><name><name>planstate</name><operator>-&gt;</operator><name>instrument</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If we shuffled the plan_node_id values in ps_instrument into sorted
	 * order, we could use binary search here.  This might matter someday if
	 * we're pushing down sufficiently large plan trees.  For now, do it the
	 * slow, dumb way.
	 */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>instrumentation</name><operator>-&gt;</operator><name>num_plan_nodes</name></name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control><block type="pseudo"><block_content>
		<if_stmt><if>if <condition>(<expr><name><name>instrumentation</name><operator>-&gt;</operator><name>plan_node_id</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <name>plan_node_id</name></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt></block_content></block></for>
	<if_stmt><if>if <condition>(<expr><name>i</name> <operator>&gt;=</operator> <name><name>instrumentation</name><operator>-&gt;</operator><name>num_plan_nodes</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"plan node %d not found"</literal></expr></argument>, <argument><expr><name>plan_node_id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Add our statistics to the per-node, per-worker totals.  It's possible
	 * that this could happen more than once if we relaunched workers.
	 */</comment>
	<expr_stmt><expr><name>instrument</name> <operator>=</operator> <call><name>GetInstrumentationArray</name><argument_list>(<argument><expr><name>instrumentation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>instrument</name> <operator>+=</operator> <name>i</name> <operator>*</operator> <name><name>instrumentation</name><operator>-&gt;</operator><name>num_workers</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>IsParallelWorker</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>ParallelWorkerNumber</name> <operator>&lt;</operator> <name><name>instrumentation</name><operator>-&gt;</operator><name>num_workers</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>InstrAggNode</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>instrument</name><index>[<expr><name>ParallelWorkerNumber</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>planstate</name><operator>-&gt;</operator><name>instrument</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><call><name>planstate_tree_walker</name><argument_list>(<argument><expr><name>planstate</name></expr></argument>, <argument><expr><name>ExecParallelReportInstrumentation</name></expr></argument>,
								 <argument><expr><name>instrumentation</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Initialize the PlanState and its descendants with the information
 * retrieved from shared memory.  This has to be done once the PlanState
 * is allocated and initialized by executor; that is, after ExecutorStart().
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>ExecParallelInitializeWorker</name><parameter_list>(<parameter><decl><type><name>PlanState</name> <modifier>*</modifier></type><name>planstate</name></decl></parameter>, <parameter><decl><type><name>ParallelWorkerContext</name> <modifier>*</modifier></type><name>pwcxt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>planstate</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<switch>switch <condition>(<expr><call><name>nodeTag</name><argument_list>(<argument><expr><name>planstate</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>T_SeqScanState</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><name><name>planstate</name><operator>-&gt;</operator><name>plan</name><operator>-&gt;</operator><name>parallel_aware</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ExecSeqScanInitializeWorker</name><argument_list>(<argument><expr><operator>(</operator><name>SeqScanState</name> <operator>*</operator><operator>)</operator> <name>planstate</name></expr></argument>, <argument><expr><name>pwcxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<break>break;</break>
		<case>case <expr><name>T_IndexScanState</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><name><name>planstate</name><operator>-&gt;</operator><name>plan</name><operator>-&gt;</operator><name>parallel_aware</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ExecIndexScanInitializeWorker</name><argument_list>(<argument><expr><operator>(</operator><name>IndexScanState</name> <operator>*</operator><operator>)</operator> <name>planstate</name></expr></argument>,
											  <argument><expr><name>pwcxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<break>break;</break>
		<case>case <expr><name>T_IndexOnlyScanState</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><name><name>planstate</name><operator>-&gt;</operator><name>plan</name><operator>-&gt;</operator><name>parallel_aware</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ExecIndexOnlyScanInitializeWorker</name><argument_list>(<argument><expr><operator>(</operator><name>IndexOnlyScanState</name> <operator>*</operator><operator>)</operator> <name>planstate</name></expr></argument>,
												  <argument><expr><name>pwcxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<break>break;</break>
		<case>case <expr><name>T_ForeignScanState</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><name><name>planstate</name><operator>-&gt;</operator><name>plan</name><operator>-&gt;</operator><name>parallel_aware</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ExecForeignScanInitializeWorker</name><argument_list>(<argument><expr><operator>(</operator><name>ForeignScanState</name> <operator>*</operator><operator>)</operator> <name>planstate</name></expr></argument>,
												<argument><expr><name>pwcxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<break>break;</break>
		<case>case <expr><name>T_AppendState</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><name><name>planstate</name><operator>-&gt;</operator><name>plan</name><operator>-&gt;</operator><name>parallel_aware</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ExecAppendInitializeWorker</name><argument_list>(<argument><expr><operator>(</operator><name>AppendState</name> <operator>*</operator><operator>)</operator> <name>planstate</name></expr></argument>, <argument><expr><name>pwcxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<break>break;</break>
		<case>case <expr><name>T_CustomScanState</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><name><name>planstate</name><operator>-&gt;</operator><name>plan</name><operator>-&gt;</operator><name>parallel_aware</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ExecCustomScanInitializeWorker</name><argument_list>(<argument><expr><operator>(</operator><name>CustomScanState</name> <operator>*</operator><operator>)</operator> <name>planstate</name></expr></argument>,
											   <argument><expr><name>pwcxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<break>break;</break>
		<case>case <expr><name>T_BitmapHeapScanState</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><name><name>planstate</name><operator>-&gt;</operator><name>plan</name><operator>-&gt;</operator><name>parallel_aware</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ExecBitmapHeapInitializeWorker</name><argument_list>(<argument><expr><operator>(</operator><name>BitmapHeapScanState</name> <operator>*</operator><operator>)</operator> <name>planstate</name></expr></argument>,
											   <argument><expr><name>pwcxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<break>break;</break>
		<case>case <expr><name>T_HashJoinState</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><name><name>planstate</name><operator>-&gt;</operator><name>plan</name><operator>-&gt;</operator><name>parallel_aware</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ExecHashJoinInitializeWorker</name><argument_list>(<argument><expr><operator>(</operator><name>HashJoinState</name> <operator>*</operator><operator>)</operator> <name>planstate</name></expr></argument>,
											 <argument><expr><name>pwcxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<break>break;</break>
		<case>case <expr><name>T_HashState</name></expr>:</case>
			<comment type="block">/* even when not parallel-aware, for EXPLAIN ANALYZE */</comment>
			<expr_stmt><expr><call><name>ExecHashInitializeWorker</name><argument_list>(<argument><expr><operator>(</operator><name>HashState</name> <operator>*</operator><operator>)</operator> <name>planstate</name></expr></argument>, <argument><expr><name>pwcxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_SortState</name></expr>:</case>
			<comment type="block">/* even when not parallel-aware, for EXPLAIN ANALYZE */</comment>
			<expr_stmt><expr><call><name>ExecSortInitializeWorker</name><argument_list>(<argument><expr><operator>(</operator><name>SortState</name> <operator>*</operator><operator>)</operator> <name>planstate</name></expr></argument>, <argument><expr><name>pwcxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<default>default:</default>
			<break>break;</break>
	</block_content>}</block></switch>

	<return>return <expr><call><name>planstate_tree_walker</name><argument_list>(<argument><expr><name>planstate</name></expr></argument>, <argument><expr><name>ExecParallelInitializeWorker</name></expr></argument>,
								 <argument><expr><name>pwcxt</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Main entrypoint for parallel query worker processes.
 *
 * We reach this function from ParallelWorkerMain, so the setup necessary to
 * create a sensible parallel environment has already been done;
 * ParallelWorkerMain worries about stuff like the transaction state, combo
 * CID mappings, and GUC values, so we don't need to deal with any of that
 * here.
 *
 * Our job is to deal with concerns specific to the executor.  The parallel
 * group leader will have stored a serialized PlannedStmt, and it's our job
 * to execute that plan and write the resulting tuples to the appropriate
 * tuple queue.  Various bits of supporting information that we need in order
 * to do this are also stored in the dsm_segment and can be accessed through
 * the shm_toc.
 */</comment>
<function><type><name>void</name></type>
<name>ParallelQueryMain</name><parameter_list>(<parameter><decl><type><name>dsm_segment</name> <modifier>*</modifier></type><name>seg</name></decl></parameter>, <parameter><decl><type><name>shm_toc</name> <modifier>*</modifier></type><name>toc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>FixedParallelExecutorState</name> <modifier>*</modifier></type><name>fpes</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BufferUsage</name> <modifier>*</modifier></type><name>buffer_usage</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>DestReceiver</name> <modifier>*</modifier></type><name>receiver</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>QueryDesc</name>  <modifier>*</modifier></type><name>queryDesc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SharedExecutorInstrumentation</name> <modifier>*</modifier></type><name>instrumentation</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SharedJitInstrumentation</name> <modifier>*</modifier></type><name>jit_instrumentation</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>instrument_options</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>void</name>	   <modifier>*</modifier></type><name>area_space</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>dsa_area</name>   <modifier>*</modifier></type><name>area</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ParallelWorkerContext</name></type> <name>pwcxt</name></decl>;</decl_stmt>

	<comment type="block">/* Get fixed-size state. */</comment>
	<expr_stmt><expr><name>fpes</name> <operator>=</operator> <call><name>shm_toc_lookup</name><argument_list>(<argument><expr><name>toc</name></expr></argument>, <argument><expr><name>PARALLEL_KEY_EXECUTOR_FIXED</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Set up DestReceiver, SharedExecutorInstrumentation, and QueryDesc. */</comment>
	<expr_stmt><expr><name>receiver</name> <operator>=</operator> <call><name>ExecParallelGetReceiver</name><argument_list>(<argument><expr><name>seg</name></expr></argument>, <argument><expr><name>toc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>instrumentation</name> <operator>=</operator> <call><name>shm_toc_lookup</name><argument_list>(<argument><expr><name>toc</name></expr></argument>, <argument><expr><name>PARALLEL_KEY_INSTRUMENTATION</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>instrumentation</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>instrument_options</name> <operator>=</operator> <name><name>instrumentation</name><operator>-&gt;</operator><name>instrument_options</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>jit_instrumentation</name> <operator>=</operator> <call><name>shm_toc_lookup</name><argument_list>(<argument><expr><name>toc</name></expr></argument>, <argument><expr><name>PARALLEL_KEY_JIT_INSTRUMENTATION</name></expr></argument>,
										 <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>queryDesc</name> <operator>=</operator> <call><name>ExecParallelGetQueryDesc</name><argument_list>(<argument><expr><name>toc</name></expr></argument>, <argument><expr><name>receiver</name></expr></argument>, <argument><expr><name>instrument_options</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Setting debug_query_string for individual workers */</comment>
	<expr_stmt><expr><name>debug_query_string</name> <operator>=</operator> <name><name>queryDesc</name><operator>-&gt;</operator><name>sourceText</name></name></expr>;</expr_stmt>

	<comment type="block">/* Report workers' query for monitoring purposes */</comment>
	<expr_stmt><expr><call><name>pgstat_report_activity</name><argument_list>(<argument><expr><name>STATE_RUNNING</name></expr></argument>, <argument><expr><name>debug_query_string</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Attach to the dynamic shared memory area. */</comment>
	<expr_stmt><expr><name>area_space</name> <operator>=</operator> <call><name>shm_toc_lookup</name><argument_list>(<argument><expr><name>toc</name></expr></argument>, <argument><expr><name>PARALLEL_KEY_DSA</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>area</name> <operator>=</operator> <call><name>dsa_attach_in_place</name><argument_list>(<argument><expr><name>area_space</name></expr></argument>, <argument><expr><name>seg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Start up the executor */</comment>
	<expr_stmt><expr><name><name>queryDesc</name><operator>-&gt;</operator><name>plannedstmt</name><operator>-&gt;</operator><name>jitFlags</name></name> <operator>=</operator> <name><name>fpes</name><operator>-&gt;</operator><name>jit_flags</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ExecutorStart</name><argument_list>(<argument><expr><name>queryDesc</name></expr></argument>, <argument><expr><name><name>fpes</name><operator>-&gt;</operator><name>eflags</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Special executor initialization steps for parallel workers */</comment>
	<expr_stmt><expr><name><name>queryDesc</name><operator>-&gt;</operator><name>planstate</name><operator>-&gt;</operator><name>state</name><operator>-&gt;</operator><name>es_query_dsa</name></name> <operator>=</operator> <name>area</name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>DsaPointerIsValid</name><argument_list>(<argument><expr><name><name>fpes</name><operator>-&gt;</operator><name>param_exec</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>paramexec_space</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>paramexec_space</name> <operator>=</operator> <call><name>dsa_get_address</name><argument_list>(<argument><expr><name>area</name></expr></argument>, <argument><expr><name><name>fpes</name><operator>-&gt;</operator><name>param_exec</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>RestoreParamExecParams</name><argument_list>(<argument><expr><name>paramexec_space</name></expr></argument>, <argument><expr><name><name>queryDesc</name><operator>-&gt;</operator><name>estate</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name><name>pwcxt</name><operator>.</operator><name>toc</name></name> <operator>=</operator> <name>toc</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pwcxt</name><operator>.</operator><name>seg</name></name> <operator>=</operator> <name>seg</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ExecParallelInitializeWorker</name><argument_list>(<argument><expr><name><name>queryDesc</name><operator>-&gt;</operator><name>planstate</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pwcxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Pass down any tuple bound */</comment>
	<expr_stmt><expr><call><name>ExecSetTupleBound</name><argument_list>(<argument><expr><name><name>fpes</name><operator>-&gt;</operator><name>tuples_needed</name></name></expr></argument>, <argument><expr><name><name>queryDesc</name><operator>-&gt;</operator><name>planstate</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Prepare to track buffer usage during query execution.
	 *
	 * We do this after starting up the executor to match what happens in the
	 * leader, which also doesn't count buffer accesses that occur during
	 * executor startup.
	 */</comment>
	<expr_stmt><expr><call><name>InstrStartParallelQuery</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Run the plan.  If we specified a tuple bound, be careful not to demand
	 * more tuples than that.
	 */</comment>
	<expr_stmt><expr><call><name>ExecutorRun</name><argument_list>(<argument><expr><name>queryDesc</name></expr></argument>,
				<argument><expr><name>ForwardScanDirection</name></expr></argument>,
				<argument><expr><ternary><condition><expr><name><name>fpes</name><operator>-&gt;</operator><name>tuples_needed</name></name> <operator>&lt;</operator> <literal type="number">0</literal></expr> ?</condition><then> <expr><operator>(</operator><name>int64</name><operator>)</operator> <literal type="number">0</literal></expr> </then><else>: <expr><name><name>fpes</name><operator>-&gt;</operator><name>tuples_needed</name></name></expr></else></ternary></expr></argument>,
				<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Shut down the executor */</comment>
	<expr_stmt><expr><call><name>ExecutorFinish</name><argument_list>(<argument><expr><name>queryDesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Report buffer usage during parallel execution. */</comment>
	<expr_stmt><expr><name>buffer_usage</name> <operator>=</operator> <call><name>shm_toc_lookup</name><argument_list>(<argument><expr><name>toc</name></expr></argument>, <argument><expr><name>PARALLEL_KEY_BUFFER_USAGE</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>InstrEndParallelQuery</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>buffer_usage</name><index>[<expr><name>ParallelWorkerNumber</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Report instrumentation data if any instrumentation options are set. */</comment>
	<if_stmt><if>if <condition>(<expr><name>instrumentation</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ExecParallelReportInstrumentation</name><argument_list>(<argument><expr><name><name>queryDesc</name><operator>-&gt;</operator><name>planstate</name></name></expr></argument>,
										  <argument><expr><name>instrumentation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Report JIT instrumentation data if any */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>queryDesc</name><operator>-&gt;</operator><name>estate</name><operator>-&gt;</operator><name>es_jit</name></name> <operator>&amp;&amp;</operator> <name>jit_instrumentation</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>ParallelWorkerNumber</name> <operator>&lt;</operator> <name><name>jit_instrumentation</name><operator>-&gt;</operator><name>num_workers</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>jit_instrumentation</name><operator>-&gt;</operator><name>jit_instr</name><index>[<expr><name>ParallelWorkerNumber</name></expr>]</index></name> <operator>=</operator>
			<name><name>queryDesc</name><operator>-&gt;</operator><name>estate</name><operator>-&gt;</operator><name>es_jit</name><operator>-&gt;</operator><name>instr</name></name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Must do this after capturing instrumentation. */</comment>
	<expr_stmt><expr><call><name>ExecutorEnd</name><argument_list>(<argument><expr><name>queryDesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Cleanup. */</comment>
	<expr_stmt><expr><call><name>dsa_detach</name><argument_list>(<argument><expr><name>area</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>FreeQueryDesc</name><argument_list>(<argument><expr><name>queryDesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name><name>receiver</name><operator>-&gt;</operator><name>rDestroy</name></name><argument_list>(<argument><expr><name>receiver</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
</unit>
