<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/PolarDB-for-PostgreSQL/src/backend/executor/execMain.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * execMain.c
 *	  top level executor interface routines
 *
 * INTERFACE ROUTINES
 *	ExecutorStart()
 *	ExecutorRun()
 *	ExecutorFinish()
 *	ExecutorEnd()
 *
 *	These four procedures are the external interface to the executor.
 *	In each case, the query descriptor is required as an argument.
 *
 *	ExecutorStart must be called at the beginning of execution of any
 *	query plan and ExecutorEnd must always be called at the end of
 *	execution of a plan (unless it is aborted due to error).
 *
 *	ExecutorRun accepts direction and count arguments that specify whether
 *	the plan is to be executed forwards, backwards, and for how many tuples.
 *	In some cases ExecutorRun may be called multiple times to process all
 *	the tuples for a plan.  It is also acceptable to stop short of executing
 *	the whole plan (but only if it is a SELECT).
 *
 *	ExecutorFinish must be called after the final ExecutorRun call and
 *	before ExecutorEnd.  This can be omitted only in case of EXPLAIN,
 *	which should also omit ExecutorRun.
 *
 * Portions Copyright (c) 1996-2018, PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, Regents of the University of California
 *
 *
 * IDENTIFICATION
 *	  src/backend/executor/execMain.c
 *
 *-------------------------------------------------------------------------
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/htup_details.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/sysattr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/transam.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/xact.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/namespace.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_publication.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/matview.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/trigger.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/execdebug.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/nodeSubplan.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"foreign/fdwapi.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jit/jit.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"mb/pg_wchar.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/clauses.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parsetree.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"rewrite/rewriteManip.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/bufmgr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/lmgr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"tcop/utility.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/acl.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/lsyscache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/memutils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/partcache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/rls.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/ruleutils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/snapmgr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/tqual.h"</cpp:file></cpp:include>

<comment type="block">/* POLAR px */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/tablespace.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/execUtils_px.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/planner.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/ipc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"px/ml_ipc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"px/px_disp_query.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"px/px_llize.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"px/px_motion.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"px/px_timeout.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"px/px_util.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"px/px_vars.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"px/px_explain.h"</cpp:file></cpp:include>
<comment type="block">/* POLAR end */</comment>

<comment type="block">/* Hooks for plugins to get control in ExecutorStart/Run/Finish/End */</comment>
<decl_stmt><decl><type><name>ExecutorStart_hook_type</name></type> <name>ExecutorStart_hook</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ExecutorRun_hook_type</name></type> <name>ExecutorRun_hook</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ExecutorFinish_hook_type</name></type> <name>ExecutorFinish_hook</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ExecutorEnd_hook_type</name></type> <name>ExecutorEnd_hook</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<comment type="block">/* Hook for plugin to get control in ExecCheckRTPerms() */</comment>
<decl_stmt><decl><type><name>ExecutorCheckPerms_hook_type</name></type> <name>ExecutorCheckPerms_hook</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<comment type="block">/* POLAR px */</comment>
<decl_stmt><decl><type><name>ExecProcNode_hook_type</name></type> <name>ExecProcNode_hook</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ExecEndNode_hook_type</name></type> <name>ExecEndNode_hook</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<comment type="block">/* decls for local routines only used within this module */</comment>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>InitPlan</name><parameter_list>(<parameter><decl><type><name>QueryDesc</name> <modifier>*</modifier></type><name>queryDesc</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>eflags</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>CheckValidRowMarkRel</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>RowMarkType</name></type> <name>markType</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ExecPostprocessPlan</name><parameter_list>(<parameter><decl><type><name>EState</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ExecEndPlan</name><parameter_list>(<parameter><decl><type><name>PlanState</name> <modifier>*</modifier></type><name>planstate</name></decl></parameter>, <parameter><decl><type><name>EState</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ExecutePlan</name><parameter_list>(<parameter><decl><type><name>EState</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>, <parameter><decl><type><name>PlanState</name> <modifier>*</modifier></type><name>planstate</name></decl></parameter>,
			<parameter><decl><type><name>bool</name></type> <name>use_parallel_mode</name></decl></parameter>,
			<parameter><decl><type><name>CmdType</name></type> <name>operation</name></decl></parameter>,
			<parameter><decl><type><name>bool</name></type> <name>sendTuples</name></decl></parameter>,
			<parameter><decl><type><name>uint64</name></type> <name>numberTuples</name></decl></parameter>,
			<parameter><decl><type><name>ScanDirection</name></type> <name>direction</name></decl></parameter>,
			<parameter><decl><type><name>DestReceiver</name> <modifier>*</modifier></type><name>dest</name></decl></parameter>,
			<parameter><decl><type><name>bool</name></type> <name>execute_once</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>ExecCheckRTEPerms</name><parameter_list>(<parameter><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>ExecCheckRTEPermsModified</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relOid</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>userid</name></decl></parameter>,
						  <parameter><decl><type><name>Bitmapset</name> <modifier>*</modifier></type><name>modifiedCols</name></decl></parameter>,
						  <parameter><decl><type><name>AclMode</name></type> <name>requiredPerms</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ExecCheckXactReadOnly</name><parameter_list>(<parameter><decl><type><name>PlannedStmt</name> <modifier>*</modifier></type><name>plannedstmt</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>ExecBuildSlotValueDescription</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>reloid</name></decl></parameter>,
							  <parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl></parameter>,
							  <parameter><decl><type><name>TupleDesc</name></type> <name>tupdesc</name></decl></parameter>,
							  <parameter><decl><type><name>Bitmapset</name> <modifier>*</modifier></type><name>modifiedCols</name></decl></parameter>,
							  <parameter><decl><type><name>int</name></type> <name>maxfieldlen</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>EvalPlanQualStart</name><parameter_list>(<parameter><decl><type><name>EPQState</name> <modifier>*</modifier></type><name>epqstate</name></decl></parameter>, <parameter><decl><type><name>EState</name> <modifier>*</modifier></type><name>parentestate</name></decl></parameter>,
				  <parameter><decl><type><name>Plan</name> <modifier>*</modifier></type><name>planTree</name></decl></parameter>)</parameter_list>;</function_decl>


<comment type="block">/* POLAR px */</comment>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>standard_ExecutorStart_PX</name><parameter_list>(<parameter><decl><type><name>QueryDesc</name> <modifier>*</modifier></type><name>queryDesc</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>eflags</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>standard_ExecutorStart_NonPX</name><parameter_list>(<parameter><decl><type><name>QueryDesc</name> <modifier>*</modifier></type><name>queryDesc</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>eflags</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>standard_ExecutorRun_PX</name><parameter_list>(<parameter><decl><type><name>QueryDesc</name> <modifier>*</modifier></type><name>queryDesc</name></decl></parameter>,
					 <parameter><decl><type><name>ScanDirection</name></type> <name>direction</name></decl></parameter>, <parameter><decl><type><name>uint64</name></type> <name>count</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>standard_ExecutorRun_NonPX</name><parameter_list>(<parameter><decl><type><name>QueryDesc</name> <modifier>*</modifier></type><name>queryDesc</name></decl></parameter>,
					 <parameter><decl><type><name>ScanDirection</name></type> <name>direction</name></decl></parameter>, <parameter><decl><type><name>uint64</name></type> <name>count</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>execute_once</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>standard_ExecutorEnd_PX</name><parameter_list>(<parameter><decl><type><name>QueryDesc</name> <modifier>*</modifier></type><name>queryDesc</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/*
 * Note that GetUpdatedColumns() also exists in commands/trigger.c.  There does
 * not appear to be any good header to put it into, given the structures that
 * it uses, so we let them be duplicated.  Be sure to update both if one needs
 * to be changed, however.
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GetInsertedColumns</name><parameter_list>(<parameter><type><name>relinfo</name></type></parameter>, <parameter><type><name>estate</name></type></parameter>)</parameter_list></cpp:macro> \
	<cpp:value>(rt_fetch((relinfo)-&gt;ri_RangeTableIndex, (estate)-&gt;es_range_table)-&gt;insertedCols)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GetUpdatedColumns</name><parameter_list>(<parameter><type><name>relinfo</name></type></parameter>, <parameter><type><name>estate</name></type></parameter>)</parameter_list></cpp:macro> \
	<cpp:value>(rt_fetch((relinfo)-&gt;ri_RangeTableIndex, (estate)-&gt;es_range_table)-&gt;updatedCols)</cpp:value></cpp:define>

<comment type="block">/* end of local decls */</comment>


<comment type="block">/* ----------------------------------------------------------------
 *		ExecutorStart
 *
 *		This routine must be called at the beginning of any execution of any
 *		query plan
 *
 * Takes a QueryDesc previously created by CreateQueryDesc (which is separate
 * only because some places use QueryDescs for utility commands).  The tupDesc
 * field of the QueryDesc is filled in to describe the tuples that will be
 * returned, and the internal fields (estate and planstate) are set up.
 *
 * eflags contains flag bits as described in executor.h.
 *
 * NB: the CurrentMemoryContext when this is called will become the parent
 * of the per-query context used for this Executor invocation.
 *
 * We provide a function hook variable that lets loadable plugins
 * get control when ExecutorStart is called.  Such a plugin would
 * normally call standard_ExecutorStart().
 *
 * ----------------------------------------------------------------
 */</comment>
<function><type><name>void</name></type>
<name>ExecutorStart</name><parameter_list>(<parameter><decl><type><name>QueryDesc</name> <modifier>*</modifier></type><name>queryDesc</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>eflags</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>ExecutorStart_hook</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call>(<modifier>*</modifier><name>ExecutorStart_hook</name>) <argument_list>(<argument><expr><name>queryDesc</name></expr></argument>, <argument><expr><name>eflags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>standard_ExecutorStart</name><argument_list>(<argument><expr><name>queryDesc</name></expr></argument>, <argument><expr><name>eflags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/* POLAR px */</comment>
<function><type><name>void</name></type>
<name>standard_ExecutorStart</name><parameter_list>(<parameter><decl><type><name>QueryDesc</name> <modifier>*</modifier></type><name>queryDesc</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>eflags</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type> <name>old_px_is_executing</name> <init>= <expr><name>px_is_executing</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>px_role</name> <operator>!=</operator> <name>PX_ROLE_PX</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>sql_trace_id</name><operator>.</operator><name>seq</name></name> <operator>=</operator> <operator>(</operator><name>uint16</name><operator>)</operator><call><name>pg_atomic_add_fetch_u32</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ProcGlobal</name><operator>-&gt;</operator><name>sqlRequestCounter</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>SET_PX_EXECUTION_STATUS</name><argument_list>(<argument><expr><call><name>should_px_executor</name><argument_list>(<argument><expr><name>queryDesc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>px_is_executing</name></expr>)</condition>
	<block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>FAULT_INJECTOR</name></cpp:ifdef>
	<expr_stmt><expr><call><name>INJECT_PX_HANG_FOR_SECOND</name><argument_list>(<argument><expr><literal type="string">"px_wait_lock_timeout"</literal></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>, <argument><expr><literal type="string">"test_table"</literal></expr></argument>, <argument><expr><literal type="number">10</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
		<expr_stmt><expr><call><name>standard_ExecutorStart_PX</name><argument_list>(<argument><expr><name>queryDesc</name></expr></argument>, <argument><expr><name>eflags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>standard_ExecutorStart_NonPX</name><argument_list>(<argument><expr><name>queryDesc</name></expr></argument>, <argument><expr><name>eflags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<expr_stmt><expr><call><name>SET_PX_EXECUTION_STATUS</name><argument_list>(<argument><expr><name>old_px_is_executing</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return;</return>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>standard_ExecutorStart_NonPX</name><parameter_list>(<parameter><decl><type><name>QueryDesc</name> <modifier>*</modifier></type><name>queryDesc</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>eflags</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>EState</name>	   <modifier>*</modifier></type><name>estate</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcontext</name></decl>;</decl_stmt>

	<comment type="block">/* sanity checks: queryDesc must not be started already */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>queryDesc</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>queryDesc</name><operator>-&gt;</operator><name>estate</name></name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If the transaction is read-only, we need to check if any writes are
	 * planned to non-temporary tables.  EXPLAIN is considered read-only.
	 *
	 * Don't allow writes in parallel mode.  Supporting UPDATE and DELETE
	 * would require (a) storing the combocid hash in shared memory, rather
	 * than synchronizing it just once at the start of parallelism, and (b) an
	 * alternative to heap_update()'s reliance on xmax for mutual exclusion.
	 * INSERT may have no such troubles, but we forbid it to simplify the
	 * checks.
	 *
	 * We have lower-level defenses in CommandCounterIncrement and elsewhere
	 * against performing unsafe operations in parallel mode, but this gives a
	 * more user-friendly error message.
	 */</comment>

	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>XactReadOnly</name> <operator>||</operator> <call><name>IsInParallelMode</name><argument_list>()</argument_list></call> <operator>||</operator>
		<operator>(</operator><operator>!</operator><name><name>MyProc</name><operator>-&gt;</operator><name>issuper</name></name> <operator>&amp;&amp;</operator> <name>polar_force_trans_ro_non_sup</name><operator>)</operator><operator>)</operator> <operator>&amp;&amp;</operator>
		<operator>!</operator><operator>(</operator><name>eflags</name> <operator>&amp;</operator> <name>EXEC_FLAG_EXPLAIN_ONLY</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ExecCheckXactReadOnly</name><argument_list>(<argument><expr><name><name>queryDesc</name><operator>-&gt;</operator><name>plannedstmt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Build EState, switch into per-query memory context for startup.
	 */</comment>
	<expr_stmt><expr><name>estate</name> <operator>=</operator> <call><name>CreateExecutorState</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>queryDesc</name><operator>-&gt;</operator><name>estate</name></name> <operator>=</operator> <name>estate</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>oldcontext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>estate</name><operator>-&gt;</operator><name>es_query_cxt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Fill in external parameters, if any, from queryDesc; and allocate
	 * workspace for internal parameters
	 */</comment>
	<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>es_param_list_info</name></name> <operator>=</operator> <name><name>queryDesc</name><operator>-&gt;</operator><name>params</name></name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>queryDesc</name><operator>-&gt;</operator><name>plannedstmt</name><operator>-&gt;</operator><name>paramExecTypes</name></name> <operator>!=</operator> <name>NIL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>nParamExec</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>nParamExec</name> <operator>=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>queryDesc</name><operator>-&gt;</operator><name>plannedstmt</name><operator>-&gt;</operator><name>paramExecTypes</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>es_param_exec_vals</name></name> <operator>=</operator> <operator>(</operator><name>ParamExecData</name> <operator>*</operator><operator>)</operator>
			<call><name>palloc0</name><argument_list>(<argument><expr><name>nParamExec</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ParamExecData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>es_sourceText</name></name> <operator>=</operator> <name><name>queryDesc</name><operator>-&gt;</operator><name>sourceText</name></name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Fill in the query environment, if any, from queryDesc.
	 */</comment>
	<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>es_queryEnv</name></name> <operator>=</operator> <name><name>queryDesc</name><operator>-&gt;</operator><name>queryEnv</name></name></expr>;</expr_stmt>

	<comment type="block">/*
	 * If non-read-only query, set the command ID to mark output tuples with
	 */</comment>
	<switch>switch <condition>(<expr><name><name>queryDesc</name><operator>-&gt;</operator><name>operation</name></name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>CMD_SELECT</name></expr>:</case>

			<comment type="block">/*
			 * SELECT FOR [KEY] UPDATE/SHARE and modifying CTEs need to mark
			 * tuples
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>queryDesc</name><operator>-&gt;</operator><name>plannedstmt</name><operator>-&gt;</operator><name>rowMarks</name></name> <operator>!=</operator> <name>NIL</name> <operator>||</operator>
				<name><name>queryDesc</name><operator>-&gt;</operator><name>plannedstmt</name><operator>-&gt;</operator><name>hasModifyingCTE</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>es_output_cid</name></name> <operator>=</operator> <call><name>GetCurrentCommandId</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<comment type="block">/*
			 * A SELECT without modifying CTEs can't possibly queue triggers,
			 * so force skip-triggers mode. This is just a marginal efficiency
			 * hack, since AfterTriggerBeginQuery/AfterTriggerEndQuery aren't
			 * all that expensive, but we might as well do it.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>queryDesc</name><operator>-&gt;</operator><name>plannedstmt</name><operator>-&gt;</operator><name>hasModifyingCTE</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>eflags</name> <operator>|=</operator> <name>EXEC_FLAG_SKIP_TRIGGERS</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<break>break;</break>

		<case>case <expr><name>CMD_INSERT</name></expr>:</case>
		<case>case <expr><name>CMD_DELETE</name></expr>:</case>
		<case>case <expr><name>CMD_UPDATE</name></expr>:</case>
			<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>es_output_cid</name></name> <operator>=</operator> <call><name>GetCurrentCommandId</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<default>default:</default>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized operation code: %d"</literal></expr></argument>,
				 <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name><name>queryDesc</name><operator>-&gt;</operator><name>operation</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
	</block_content>}</block></switch>

	<comment type="block">/*
	 * Copy other important information into the EState
	 */</comment>
	<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>es_snapshot</name></name> <operator>=</operator> <call><name>RegisterSnapshot</name><argument_list>(<argument><expr><name><name>queryDesc</name><operator>-&gt;</operator><name>snapshot</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>es_crosscheck_snapshot</name></name> <operator>=</operator> <call><name>RegisterSnapshot</name><argument_list>(<argument><expr><name><name>queryDesc</name><operator>-&gt;</operator><name>crosscheck_snapshot</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>es_top_eflags</name></name> <operator>=</operator> <name>eflags</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>es_instrument</name></name> <operator>=</operator> <name><name>queryDesc</name><operator>-&gt;</operator><name>instrument_options</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>es_jit_flags</name></name> <operator>=</operator> <name><name>queryDesc</name><operator>-&gt;</operator><name>plannedstmt</name><operator>-&gt;</operator><name>jitFlags</name></name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Set up an AFTER-trigger statement context, unless told not to, or
	 * unless it's EXPLAIN-only mode (when ExecutorFinish won't be called).
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>eflags</name> <operator>&amp;</operator> <operator>(</operator><name>EXEC_FLAG_SKIP_TRIGGERS</name> <operator>|</operator> <name>EXEC_FLAG_EXPLAIN_ONLY</name><operator>)</operator><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>AfterTriggerBeginQuery</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Initialize the plan state tree
	 */</comment>
	<expr_stmt><expr><call><name>InitPlan</name><argument_list>(<argument><expr><name>queryDesc</name></expr></argument>, <argument><expr><name>eflags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* ----------------------------------------------------------------
 *		ExecutorRun
 *
 *		This is the main routine of the executor module. It accepts
 *		the query descriptor from the traffic cop and executes the
 *		query plan.
 *
 *		ExecutorStart must have been called already.
 *
 *		If direction is NoMovementScanDirection then nothing is done
 *		except to start up/shut down the destination.  Otherwise,
 *		we retrieve up to 'count' tuples in the specified direction.
 *
 *		Note: count = 0 is interpreted as no portal limit, i.e., run to
 *		completion.  Also note that the count limit is only applied to
 *		retrieved tuples, not for instance to those inserted/updated/deleted
 *		by a ModifyTable plan node.
 *
 *		There is no return value, but output tuples (if any) are sent to
 *		the destination receiver specified in the QueryDesc; and the number
 *		of tuples processed at the top level can be found in
 *		estate-&gt;es_processed.
 *
 *		We provide a function hook variable that lets loadable plugins
 *		get control when ExecutorRun is called.  Such a plugin would
 *		normally call standard_ExecutorRun().
 *
 * ----------------------------------------------------------------
 */</comment>
<function><type><name>void</name></type>
<name>ExecutorRun</name><parameter_list>(<parameter><decl><type><name>QueryDesc</name> <modifier>*</modifier></type><name>queryDesc</name></decl></parameter>,
			<parameter><decl><type><name>ScanDirection</name></type> <name>direction</name></decl></parameter>, <parameter><decl><type><name>uint64</name></type> <name>count</name></decl></parameter>,
			<parameter><decl><type><name>bool</name></type> <name>execute_once</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>ExecutorRun_hook</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call>(<modifier>*</modifier><name>ExecutorRun_hook</name>) <argument_list>(<argument><expr><name>queryDesc</name></expr></argument>, <argument><expr><name>direction</name></expr></argument>, <argument><expr><name>count</name></expr></argument>, <argument><expr><name>execute_once</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>standard_ExecutorRun</name><argument_list>(<argument><expr><name>queryDesc</name></expr></argument>, <argument><expr><name>direction</name></expr></argument>, <argument><expr><name>count</name></expr></argument>, <argument><expr><name>execute_once</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>standard_ExecutorRun</name><parameter_list>(<parameter><decl><type><name>QueryDesc</name> <modifier>*</modifier></type><name>queryDesc</name></decl></parameter>,
					 <parameter><decl><type><name>ScanDirection</name></type> <name>direction</name></decl></parameter>, <parameter><decl><type><name>uint64</name></type> <name>count</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>execute_once</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type> <name>old_px_is_executing</name> <init>= <expr><name>px_is_executing</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>SET_PX_EXECUTION_STATUS</name><argument_list>(<argument><expr><call><name>should_px_executor</name><argument_list>(<argument><expr><name>queryDesc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>px_is_executing</name></expr>)</condition>
	<block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>FAULT_INJECTOR</name></cpp:ifdef>
	<expr_stmt><expr><call><name>INJECT_PX_HANG_FOR_SECOND</name><argument_list>(<argument><expr><literal type="string">"px_wait_lock_timeout"</literal></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>, <argument><expr><literal type="string">"test_table"</literal></expr></argument>, <argument><expr><literal type="number">10</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
		<expr_stmt><expr><call><name>standard_ExecutorRun_PX</name><argument_list>(<argument><expr><name>queryDesc</name></expr></argument>, <argument><expr><name>direction</name></expr></argument>, <argument><expr><name>count</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>standard_ExecutorRun_NonPX</name><argument_list>(<argument><expr><name>queryDesc</name></expr></argument>, <argument><expr><name>direction</name></expr></argument>, <argument><expr><name>count</name></expr></argument>, <argument><expr><name>execute_once</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<expr_stmt><expr><call><name>SET_PX_EXECUTION_STATUS</name><argument_list>(<argument><expr><name>old_px_is_executing</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return;</return>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>standard_ExecutorRun_NonPX</name><parameter_list>(<parameter><decl><type><name>QueryDesc</name> <modifier>*</modifier></type><name>queryDesc</name></decl></parameter>, <parameter><decl><type><name>ScanDirection</name></type> <name>direction</name></decl></parameter>, 
							<parameter><decl><type><name>uint64</name></type> <name>count</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>execute_once</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>EState</name>	   <modifier>*</modifier></type><name>estate</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CmdType</name></type>		<name>operation</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>DestReceiver</name> <modifier>*</modifier></type><name>dest</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>sendTuples</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcontext</name></decl>;</decl_stmt>

	<comment type="block">/* sanity checks */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>queryDesc</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>estate</name> <operator>=</operator> <name><name>queryDesc</name><operator>-&gt;</operator><name>estate</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>estate</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><operator>(</operator><name><name>estate</name><operator>-&gt;</operator><name>es_top_eflags</name></name> <operator>&amp;</operator> <name>EXEC_FLAG_EXPLAIN_ONLY</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Switch into per-query memory context
	 */</comment>
	<expr_stmt><expr><name>oldcontext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>estate</name><operator>-&gt;</operator><name>es_query_cxt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Allow instrumentation of Executor overall runtime */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>queryDesc</name><operator>-&gt;</operator><name>totaltime</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>InstrStartNode</name><argument_list>(<argument><expr><name><name>queryDesc</name><operator>-&gt;</operator><name>totaltime</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * extract information from the query descriptor and the query feature.
	 */</comment>
	<expr_stmt><expr><name>operation</name> <operator>=</operator> <name><name>queryDesc</name><operator>-&gt;</operator><name>operation</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>dest</name> <operator>=</operator> <name><name>queryDesc</name><operator>-&gt;</operator><name>dest</name></name></expr>;</expr_stmt>

	<comment type="block">/*
	 * startup tuple receiver, if we will be emitting tuples
	 */</comment>
	<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>es_processed</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>es_lastoid</name></name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>sendTuples</name> <operator>=</operator> <operator>(</operator><name>operation</name> <operator>==</operator> <name>CMD_SELECT</name> <operator>||</operator>
				  <name><name>queryDesc</name><operator>-&gt;</operator><name>plannedstmt</name><operator>-&gt;</operator><name>hasReturning</name></name><operator>)</operator></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>sendTuples</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name><name>dest</name><operator>-&gt;</operator><name>rStartup</name></name><argument_list>(<argument><expr><name>dest</name></expr></argument>, <argument><expr><name>operation</name></expr></argument>, <argument><expr><name><name>queryDesc</name><operator>-&gt;</operator><name>tupDesc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * run plan
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ScanDirectionIsNoMovement</name><argument_list>(<argument><expr><name>direction</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>execute_once</name> <operator>&amp;&amp;</operator> <name><name>queryDesc</name><operator>-&gt;</operator><name>already_executed</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"can't re-execute query flagged for single execution"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name><name>queryDesc</name><operator>-&gt;</operator><name>already_executed</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>ExecutePlan</name><argument_list>(<argument><expr><name>estate</name></expr></argument>,
					<argument><expr><name><name>queryDesc</name><operator>-&gt;</operator><name>planstate</name></name></expr></argument>,
					<argument><expr><name><name>queryDesc</name><operator>-&gt;</operator><name>plannedstmt</name><operator>-&gt;</operator><name>parallelModeNeeded</name></name></expr></argument>,
					<argument><expr><name>operation</name></expr></argument>,
					<argument><expr><name>sendTuples</name></expr></argument>,
					<argument><expr><name>count</name></expr></argument>,
					<argument><expr><name>direction</name></expr></argument>,
					<argument><expr><name>dest</name></expr></argument>,
					<argument><expr><name>execute_once</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * shutdown tuple receiver, if we started it
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>sendTuples</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name><name>dest</name><operator>-&gt;</operator><name>rShutdown</name></name><argument_list>(<argument><expr><name>dest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>queryDesc</name><operator>-&gt;</operator><name>totaltime</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>InstrStopNode</name><argument_list>(<argument><expr><name><name>queryDesc</name><operator>-&gt;</operator><name>totaltime</name></name></expr></argument>, <argument><expr><name><name>estate</name><operator>-&gt;</operator><name>es_processed</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/* ----------------------------------------------------------------
 *		ExecutorFinish
 *
 *		This routine must be called after the last ExecutorRun call.
 *		It performs cleanup such as firing AFTER triggers.  It is
 *		separate from ExecutorEnd because EXPLAIN ANALYZE needs to
 *		include these actions in the total runtime.
 *
 *		We provide a function hook variable that lets loadable plugins
 *		get control when ExecutorFinish is called.  Such a plugin would
 *		normally call standard_ExecutorFinish().
 *
 * ----------------------------------------------------------------
 */</comment>
<function><type><name>void</name></type>
<name>ExecutorFinish</name><parameter_list>(<parameter><decl><type><name>QueryDesc</name> <modifier>*</modifier></type><name>queryDesc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>ExecutorFinish_hook</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call>(<modifier>*</modifier><name>ExecutorFinish_hook</name>) <argument_list>(<argument><expr><name>queryDesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>standard_ExecutorFinish</name><argument_list>(<argument><expr><name>queryDesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>standard_ExecutorFinish</name><parameter_list>(<parameter><decl><type><name>QueryDesc</name> <modifier>*</modifier></type><name>queryDesc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>EState</name>	   <modifier>*</modifier></type><name>estate</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcontext</name></decl>;</decl_stmt>

	<comment type="block">/* sanity checks */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>queryDesc</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>estate</name> <operator>=</operator> <name><name>queryDesc</name><operator>-&gt;</operator><name>estate</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>estate</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><operator>(</operator><name><name>estate</name><operator>-&gt;</operator><name>es_top_eflags</name></name> <operator>&amp;</operator> <name>EXEC_FLAG_EXPLAIN_ONLY</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* This should be run once and only once per Executor instance */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name><name>estate</name><operator>-&gt;</operator><name>es_finished</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Switch into per-query memory context */</comment>
	<expr_stmt><expr><name>oldcontext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>estate</name><operator>-&gt;</operator><name>es_query_cxt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Allow instrumentation of Executor overall runtime */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>queryDesc</name><operator>-&gt;</operator><name>totaltime</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>InstrStartNode</name><argument_list>(<argument><expr><name><name>queryDesc</name><operator>-&gt;</operator><name>totaltime</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Run ModifyTable nodes to completion */</comment>
	<expr_stmt><expr><call><name>ExecPostprocessPlan</name><argument_list>(<argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Execute queued AFTER triggers, unless told not to */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name><name>estate</name><operator>-&gt;</operator><name>es_top_eflags</name></name> <operator>&amp;</operator> <name>EXEC_FLAG_SKIP_TRIGGERS</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>AfterTriggerEndQuery</name><argument_list>(<argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>queryDesc</name><operator>-&gt;</operator><name>totaltime</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>InstrStopNode</name><argument_list>(<argument><expr><name><name>queryDesc</name><operator>-&gt;</operator><name>totaltime</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>es_finished</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* ----------------------------------------------------------------
 *		ExecutorEnd
 *
 *		This routine must be called at the end of execution of any
 *		query plan
 *
 *		We provide a function hook variable that lets loadable plugins
 *		get control when ExecutorEnd is called.  Such a plugin would
 *		normally call standard_ExecutorEnd().
 *
 * ----------------------------------------------------------------
 */</comment>
<function><type><name>void</name></type>
<name>ExecutorEnd</name><parameter_list>(<parameter><decl><type><name>QueryDesc</name> <modifier>*</modifier></type><name>queryDesc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>ExecutorEnd_hook</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call>(<modifier>*</modifier><name>ExecutorEnd_hook</name>) <argument_list>(<argument><expr><name>queryDesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>standard_ExecutorEnd</name><argument_list>(<argument><expr><name>queryDesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>standard_ExecutorEnd</name><parameter_list>(<parameter><decl><type><name>QueryDesc</name> <modifier>*</modifier></type><name>queryDesc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>EState</name>	   <modifier>*</modifier></type><name>estate</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcontext</name></decl>;</decl_stmt>

	<comment type="block">/* sanity checks */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>queryDesc</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>estate</name> <operator>=</operator> <name><name>queryDesc</name><operator>-&gt;</operator><name>estate</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>estate</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Check that ExecutorFinish was called, unless in EXPLAIN-only mode. This
	 * Assert is needed because ExecutorFinish is new as of 9.1, and callers
	 * might forget to call it.
	 */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>estate</name><operator>-&gt;</operator><name>es_finished</name></name> <operator>||</operator>
		   <operator>(</operator><name><name>estate</name><operator>-&gt;</operator><name>es_top_eflags</name></name> <operator>&amp;</operator> <name>EXEC_FLAG_EXPLAIN_ONLY</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>should_px_executor</name><argument_list>(<argument><expr><name>queryDesc</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><call><name>standard_ExecutorEnd_PX</name><argument_list>(<argument><expr><name>queryDesc</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Switch into per-query memory context to run ExecEndPlan
	 */</comment>
	<expr_stmt><expr><name>oldcontext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>estate</name><operator>-&gt;</operator><name>es_query_cxt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ExecEndPlan</name><argument_list>(<argument><expr><name><name>queryDesc</name><operator>-&gt;</operator><name>planstate</name></name></expr></argument>, <argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* do away with our snapshots */</comment>
	<expr_stmt><expr><call><name>UnregisterSnapshot</name><argument_list>(<argument><expr><name><name>estate</name><operator>-&gt;</operator><name>es_snapshot</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>UnregisterSnapshot</name><argument_list>(<argument><expr><name><name>estate</name><operator>-&gt;</operator><name>es_crosscheck_snapshot</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Must switch out of context before destroying it
	 */</comment>
	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* POLAR px */</comment>
	<expr_stmt><expr><name><name>queryDesc</name><operator>-&gt;</operator><name>es_processed</name></name> <operator>=</operator> <name><name>estate</name><operator>-&gt;</operator><name>es_processed</name></name></expr>;</expr_stmt>
	<comment type="block">/* POLAR end */</comment>

	<comment type="block">/*
	 * Release EState and per-query memory context.  This should release
	 * everything the executor has allocated.
	 */</comment>
	<expr_stmt><expr><call><name>FreeExecutorState</name><argument_list>(<argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Reset queryDesc fields that no longer point to anything */</comment>
	<expr_stmt><expr><name><name>queryDesc</name><operator>-&gt;</operator><name>tupDesc</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>queryDesc</name><operator>-&gt;</operator><name>estate</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>queryDesc</name><operator>-&gt;</operator><name>planstate</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>queryDesc</name><operator>-&gt;</operator><name>totaltime</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* ----------------------------------------------------------------
 *		ExecutorRewind
 *
 *		This routine may be called on an open queryDesc to rewind it
 *		to the start.
 * ----------------------------------------------------------------
 */</comment>
<function><type><name>void</name></type>
<name>ExecutorRewind</name><parameter_list>(<parameter><decl><type><name>QueryDesc</name> <modifier>*</modifier></type><name>queryDesc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>EState</name>	   <modifier>*</modifier></type><name>estate</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcontext</name></decl>;</decl_stmt>

	<comment type="block">/* sanity checks */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>queryDesc</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>estate</name> <operator>=</operator> <name><name>queryDesc</name><operator>-&gt;</operator><name>estate</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>estate</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* It's probably not sensible to rescan updating queries */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>queryDesc</name><operator>-&gt;</operator><name>operation</name></name> <operator>==</operator> <name>CMD_SELECT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Switch into per-query memory context
	 */</comment>
	<expr_stmt><expr><name>oldcontext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>estate</name><operator>-&gt;</operator><name>es_query_cxt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * rescan plan
	 */</comment>
	<expr_stmt><expr><call><name>ExecReScan</name><argument_list>(<argument><expr><name><name>queryDesc</name><operator>-&gt;</operator><name>planstate</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * ExecCheckRTPerms
 *		Check access permissions for all relations listed in a range table.
 *
 * Returns true if permissions are adequate.  Otherwise, throws an appropriate
 * error if ereport_on_violation is true, or simply returns false otherwise.
 *
 * Note that this does NOT address row level security policies (aka: RLS).  If
 * rows will be returned to the user as a result of this permission check
 * passing, then RLS also needs to be consulted (and check_enable_rls()).
 *
 * See rewrite/rowsecurity.c.
 */</comment>
<function><type><name>bool</name></type>
<name>ExecCheckRTPerms</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>rangeTable</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>ereport_on_violation</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>result</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>

	<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>rangeTable</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name> <init>= <expr><operator>(</operator><name>RangeTblEntry</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>ExecCheckRTEPerms</name><argument_list>(<argument><expr><name>rte</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>result</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>==</operator> <name>RTE_RELATION</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>ereport_on_violation</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>aclcheck_error</name><argument_list>(<argument><expr><name>ACLCHECK_NO_PRIV</name></expr></argument>, <argument><expr><call><name>get_relkind_objtype</name><argument_list>(<argument><expr><call><name>get_rel_relkind</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
							   <argument><expr><call><name>get_rel_name</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<return>return <expr><name>false</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>

	<if_stmt><if>if <condition>(<expr><name>ExecutorCheckPerms_hook</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <call>(<modifier>*</modifier><name>ExecutorCheckPerms_hook</name>) <argument_list>(<argument><expr><name>rangeTable</name></expr></argument>,
											 <argument><expr><name>ereport_on_violation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * ExecCheckRTEPerms
 *		Check access permissions for a single RTE.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>ExecCheckRTEPerms</name><parameter_list>(<parameter><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>AclMode</name></type>		<name>requiredPerms</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AclMode</name></type>		<name>relPerms</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AclMode</name></type>		<name>remainingPerms</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>relOid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>userid</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Only plain-relation RTEs need to be checked here.  Function RTEs are
	 * checked when the function is prepared for execution.  Join, subquery,
	 * and special RTEs need no checks.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>rte</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>!=</operator> <name>RTE_RELATION</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * No work if requiredPerms is empty.
	 */</comment>
	<expr_stmt><expr><name>requiredPerms</name> <operator>=</operator> <name><name>rte</name><operator>-&gt;</operator><name>requiredPerms</name></name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>requiredPerms</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>relOid</name> <operator>=</operator> <name><name>rte</name><operator>-&gt;</operator><name>relid</name></name></expr>;</expr_stmt>

	<comment type="block">/*
	 * userid to check as: current user unless we have a setuid indication.
	 *
	 * Note: GetUserId() is presently fast enough that there's no harm in
	 * calling it separately for each RTE.  If that stops being true, we could
	 * call it once in ExecCheckRTPerms and pass the userid down from there.
	 * But for now, no need for the extra clutter.
	 */</comment>
	<expr_stmt><expr><name>userid</name> <operator>=</operator> <ternary><condition><expr><name><name>rte</name><operator>-&gt;</operator><name>checkAsUser</name></name></expr> ?</condition><then> <expr><name><name>rte</name><operator>-&gt;</operator><name>checkAsUser</name></name></expr> </then><else>: <expr><call><name>GetUserId</name><argument_list>()</argument_list></call></expr></else></ternary></expr>;</expr_stmt>

	<comment type="block">/*
	 * We must have *all* the requiredPerms bits, but some of the bits can be
	 * satisfied from column-level rather than relation-level permissions.
	 * First, remove any bits that are satisfied by relation permissions.
	 */</comment>
	<expr_stmt><expr><name>relPerms</name> <operator>=</operator> <call><name>pg_class_aclmask</name><argument_list>(<argument><expr><name>relOid</name></expr></argument>, <argument><expr><name>userid</name></expr></argument>, <argument><expr><name>requiredPerms</name></expr></argument>, <argument><expr><name>ACLMASK_ALL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>remainingPerms</name> <operator>=</operator> <name>requiredPerms</name> <operator>&amp;</operator> <operator>~</operator><name>relPerms</name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>remainingPerms</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>col</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

		<comment type="block">/*
		 * If we lack any permissions that exist only as relation permissions,
		 * we can fail straight away.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>remainingPerms</name> <operator>&amp;</operator> <operator>~</operator><operator>(</operator><name>ACL_SELECT</name> <operator>|</operator> <name>ACL_INSERT</name> <operator>|</operator> <name>ACL_UPDATE</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * Check to see if we have the needed privileges at column level.
		 *
		 * Note: failures just report a table-level error; it would be nicer
		 * to report a column-level error if we have some but not all of the
		 * column privileges.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>remainingPerms</name> <operator>&amp;</operator> <name>ACL_SELECT</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * When the query doesn't explicitly reference any columns (for
			 * example, SELECT COUNT(*) FROM table), allow the query if we
			 * have SELECT on any column of the rel, as per SQL spec.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>bms_is_empty</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>selectedCols</name></name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><call><name>pg_attribute_aclcheck_all</name><argument_list>(<argument><expr><name>relOid</name></expr></argument>, <argument><expr><name>userid</name></expr></argument>, <argument><expr><name>ACL_SELECT</name></expr></argument>,
											  <argument><expr><name>ACLMASK_ANY</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>ACLCHECK_OK</name></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
			</block_content>}</block></if></if_stmt>

			<while>while <condition>(<expr><operator>(</operator><name>col</name> <operator>=</operator> <call><name>bms_next_member</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>selectedCols</name></name></expr></argument>, <argument><expr><name>col</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* bit #s are offset by FirstLowInvalidHeapAttributeNumber */</comment>
				<decl_stmt><decl><type><name>AttrNumber</name></type>	<name>attno</name> <init>= <expr><name>col</name> <operator>+</operator> <name>FirstLowInvalidHeapAttributeNumber</name></expr></init></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><name>attno</name> <operator>==</operator> <name>InvalidAttrNumber</name></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/* Whole-row reference, must have priv on all cols */</comment>
					<if_stmt><if>if <condition>(<expr><call><name>pg_attribute_aclcheck_all</name><argument_list>(<argument><expr><name>relOid</name></expr></argument>, <argument><expr><name>userid</name></expr></argument>, <argument><expr><name>ACL_SELECT</name></expr></argument>,
												  <argument><expr><name>ACLMASK_ALL</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>ACLCHECK_OK</name></expr>)</condition><block type="pseudo"><block_content>
						<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
				</block_content>}</block></if>
				<else>else
				<block>{<block_content>
					<if_stmt><if>if <condition>(<expr><call><name>pg_attribute_aclcheck</name><argument_list>(<argument><expr><name>relOid</name></expr></argument>, <argument><expr><name>attno</name></expr></argument>, <argument><expr><name>userid</name></expr></argument>,
											  <argument><expr><name>ACL_SELECT</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>ACLCHECK_OK</name></expr>)</condition><block type="pseudo"><block_content>
						<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
				</block_content>}</block></else></if_stmt>
			</block_content>}</block></while>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * Basically the same for the mod columns, for both INSERT and UPDATE
		 * privilege as specified by remainingPerms.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>remainingPerms</name> <operator>&amp;</operator> <name>ACL_INSERT</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>ExecCheckRTEPermsModified</name><argument_list>(<argument><expr><name>relOid</name></expr></argument>,
																	  <argument><expr><name>userid</name></expr></argument>,
																	  <argument><expr><name><name>rte</name><operator>-&gt;</operator><name>insertedCols</name></name></expr></argument>,
																	  <argument><expr><name>ACL_INSERT</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>remainingPerms</name> <operator>&amp;</operator> <name>ACL_UPDATE</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>ExecCheckRTEPermsModified</name><argument_list>(<argument><expr><name>relOid</name></expr></argument>,
																	  <argument><expr><name>userid</name></expr></argument>,
																	  <argument><expr><name><name>rte</name><operator>-&gt;</operator><name>updatedCols</name></name></expr></argument>,
																	  <argument><expr><name>ACL_UPDATE</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * ExecCheckRTEPermsModified
 *		Check INSERT or UPDATE access permissions for a single RTE (these
 *		are processed uniformly).
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>ExecCheckRTEPermsModified</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relOid</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>userid</name></decl></parameter>, <parameter><decl><type><name>Bitmapset</name> <modifier>*</modifier></type><name>modifiedCols</name></decl></parameter>,
						  <parameter><decl><type><name>AclMode</name></type> <name>requiredPerms</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>col</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * When the query doesn't explicitly update any columns, allow the query
	 * if we have permission on any column of the rel.  This is to handle
	 * SELECT FOR UPDATE as well as possible corner cases in UPDATE.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>bms_is_empty</name><argument_list>(<argument><expr><name>modifiedCols</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>pg_attribute_aclcheck_all</name><argument_list>(<argument><expr><name>relOid</name></expr></argument>, <argument><expr><name>userid</name></expr></argument>, <argument><expr><name>requiredPerms</name></expr></argument>,
									  <argument><expr><name>ACLMASK_ANY</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>ACLCHECK_OK</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<while>while <condition>(<expr><operator>(</operator><name>col</name> <operator>=</operator> <call><name>bms_next_member</name><argument_list>(<argument><expr><name>modifiedCols</name></expr></argument>, <argument><expr><name>col</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* bit #s are offset by FirstLowInvalidHeapAttributeNumber */</comment>
		<decl_stmt><decl><type><name>AttrNumber</name></type>	<name>attno</name> <init>= <expr><name>col</name> <operator>+</operator> <name>FirstLowInvalidHeapAttributeNumber</name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>attno</name> <operator>==</operator> <name>InvalidAttrNumber</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* whole-row reference can't happen here */</comment>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"whole-row update is not implemented"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><call><name>pg_attribute_aclcheck</name><argument_list>(<argument><expr><name>relOid</name></expr></argument>, <argument><expr><name>attno</name></expr></argument>, <argument><expr><name>userid</name></expr></argument>,
									  <argument><expr><name>requiredPerms</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>ACLCHECK_OK</name></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></while>
	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Check that the query does not imply any writes to non-temp tables;
 * unless we're in parallel mode, in which case don't even allow writes
 * to temp tables.
 *
 * Note: in a Hot Standby this would need to reject writes to temp
 * tables just as we do in parallel mode; but an HS standby can't have created
 * any temp tables in the first place, so no need to check that.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ExecCheckXactReadOnly</name><parameter_list>(<parameter><decl><type><name>PlannedStmt</name> <modifier>*</modifier></type><name>plannedstmt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Fail if write permissions are requested in parallel mode for table
	 * (temp or non-temp), otherwise fail for any non-temp table.
	 */</comment>
	<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>plannedstmt-&gt;rtable</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name> <init>= <expr><operator>(</operator><name>RangeTblEntry</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>rte</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>!=</operator> <name>RTE_RELATION</name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>rte</name><operator>-&gt;</operator><name>requiredPerms</name></name> <operator>&amp;</operator> <operator>(</operator><operator>~</operator><name>ACL_SELECT</name><operator>)</operator><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>isTempNamespace</name><argument_list>(<argument><expr><call><name>get_rel_namespace</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>PreventCommandIfReadOnly</name><argument_list>(<argument><expr><call><name>CreateCommandTag</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>plannedstmt</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<if_stmt><if>if <condition>(<expr><name><name>plannedstmt</name><operator>-&gt;</operator><name>commandType</name></name> <operator>!=</operator> <name>CMD_SELECT</name> <operator>||</operator> <name><name>plannedstmt</name><operator>-&gt;</operator><name>hasModifyingCTE</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PreventCommandIfParallelMode</name><argument_list>(<argument><expr><call><name>CreateCommandTag</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>plannedstmt</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>


<comment type="block">/* ----------------------------------------------------------------
 *		InitPlan
 *
 *		Initializes the query plan: open files, allocate storage
 *		and start up the rule manager
 * ----------------------------------------------------------------
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>InitPlan</name><parameter_list>(<parameter><decl><type><name>QueryDesc</name> <modifier>*</modifier></type><name>queryDesc</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>eflags</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>CmdType</name></type>		<name>operation</name> <init>= <expr><name><name>queryDesc</name><operator>-&gt;</operator><name>operation</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PlannedStmt</name> <modifier>*</modifier></type><name>plannedstmt</name> <init>= <expr><name><name>queryDesc</name><operator>-&gt;</operator><name>plannedstmt</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Plan</name>	   <modifier>*</modifier></type><name>plan</name> <init>= <expr><name><name>plannedstmt</name><operator>-&gt;</operator><name>planTree</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>rangeTable</name> <init>= <expr><name><name>plannedstmt</name><operator>-&gt;</operator><name>rtable</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>EState</name>	   <modifier>*</modifier></type><name>estate</name> <init>= <expr><name><name>queryDesc</name><operator>-&gt;</operator><name>estate</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PlanState</name>  <modifier>*</modifier></type><name>planstate</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleDesc</name></type>	<name>tupType</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<comment type="block">/* POLAR px */</comment>
	<decl_stmt><decl><type><name>Plan</name>		<modifier>*</modifier></type><name>start_plan_node</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>use_px</name> <init>= <expr><call><name>should_px_executor</name><argument_list>(<argument><expr><name>queryDesc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>px_role</name> <operator>==</operator> <name>PX_ROLE_PX</name> <operator>&amp;&amp;</operator>
		<name>px_is_executing</name> <operator>&amp;&amp;</operator>
		<name>px_enable_check_csn</name> <operator>&amp;&amp;</operator>
		<name>polar_csn_enable</name> <operator>&amp;&amp;</operator>
		<operator>(</operator><name>NULL</name> <operator>==</operator> <name>queryDesc</name> <operator>||</operator>
		 <name>NULL</name> <operator>==</operator> <name><name>queryDesc</name><operator>-&gt;</operator><name>snapshot</name></name> <operator>||</operator> 
		 <operator>!</operator><name><name>queryDesc</name><operator>-&gt;</operator><name>snapshot</name><operator>-&gt;</operator><name>polar_csn_xid_snapshot</name></name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"it is not allowed when px/csn enabled, but polar_csn_xid_snapshot disabled"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Do permissions checks
	 */</comment>
	<expr_stmt><expr><call><name>ExecCheckRTPerms</name><argument_list>(<argument><expr><name>rangeTable</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * initialize the node's execution state
	 */</comment>
	<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>es_range_table</name></name> <operator>=</operator> <name>rangeTable</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>es_plannedstmt</name></name> <operator>=</operator> <name>plannedstmt</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * initialize result relation stuff, and open/lock the result rels.
	 *
	 * We must do this before initializing the plan tree, else we might try to
	 * do a lock upgrade if a result rel is also a source rel.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>plannedstmt</name><operator>-&gt;</operator><name>resultRelations</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>resultRelations</name> <init>= <expr><name><name>plannedstmt</name><operator>-&gt;</operator><name>resultRelations</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>numResultRelations</name> <init>= <expr><call><name>list_length</name><argument_list>(<argument><expr><name>resultRelations</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ResultRelInfo</name> <modifier>*</modifier></type><name>resultRelInfos</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ResultRelInfo</name> <modifier>*</modifier></type><name>resultRelInfo</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>resultRelInfos</name> <operator>=</operator> <operator>(</operator><name>ResultRelInfo</name> <operator>*</operator><operator>)</operator>
			<call><name>palloc</name><argument_list>(<argument><expr><name>numResultRelations</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ResultRelInfo</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>resultRelInfo</name> <operator>=</operator> <name>resultRelInfos</name></expr>;</expr_stmt>
		<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>resultRelations</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Index</name></type>		<name>resultRelationIndex</name> <init>= <expr><call><name>lfirst_int</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Oid</name></type>			<name>resultRelationOid</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Relation</name></type>	<name>resultRelation</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>resultRelationOid</name> <operator>=</operator> <call><name>getrelid</name><argument_list>(<argument><expr><name>resultRelationIndex</name></expr></argument>, <argument><expr><name>rangeTable</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>resultRelation</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name>resultRelationOid</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>InitResultRelInfo</name><argument_list>(<argument><expr><name>resultRelInfo</name></expr></argument>,
							  <argument><expr><name>resultRelation</name></expr></argument>,
							  <argument><expr><name>resultRelationIndex</name></expr></argument>,
							  <argument><expr><name>NULL</name></expr></argument>,
							  <argument><expr><name><name>estate</name><operator>-&gt;</operator><name>es_instrument</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>resultRelInfo</name><operator>++</operator></expr>;</expr_stmt>
		</block_content>}</block>
		<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>es_result_relations</name></name> <operator>=</operator> <name>resultRelInfos</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>es_num_result_relations</name></name> <operator>=</operator> <name>numResultRelations</name></expr>;</expr_stmt>
		<comment type="block">/* es_result_relation_info is NULL except when within ModifyTable */</comment>
		<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>es_result_relation_info</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

		<comment type="block">/*
		 * In the partitioned result relation case, lock the non-leaf result
		 * relations too.  A subset of these are the roots of respective
		 * partitioned tables, for which we also allocate ResultRelInfos.
		 */</comment>
		<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>es_root_result_relations</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>es_num_root_result_relations</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>plannedstmt</name><operator>-&gt;</operator><name>nonleafResultRelations</name></name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>int</name></type>			<name>num_roots</name> <init>= <expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>plannedstmt</name><operator>-&gt;</operator><name>rootResultRelations</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<comment type="block">/*
			 * Firstly, build ResultRelInfos for all the partitioned table
			 * roots, because we will need them to fire the statement-level
			 * triggers, if any.
			 */</comment>
			<expr_stmt><expr><name>resultRelInfos</name> <operator>=</operator> <operator>(</operator><name>ResultRelInfo</name> <operator>*</operator><operator>)</operator>
				<call><name>palloc</name><argument_list>(<argument><expr><name>num_roots</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ResultRelInfo</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>resultRelInfo</name> <operator>=</operator> <name>resultRelInfos</name></expr>;</expr_stmt>
			<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>plannedstmt-&gt;rootResultRelations</argument>)</argument_list></macro>
			<block>{<block_content>
				<decl_stmt><decl><type><name>Index</name></type>		<name>resultRelIndex</name> <init>= <expr><call><name>lfirst_int</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>Oid</name></type>			<name>resultRelOid</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>Relation</name></type>	<name>resultRelDesc</name></decl>;</decl_stmt>

				<expr_stmt><expr><name>resultRelOid</name> <operator>=</operator> <call><name>getrelid</name><argument_list>(<argument><expr><name>resultRelIndex</name></expr></argument>, <argument><expr><name>rangeTable</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>resultRelDesc</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name>resultRelOid</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>InitResultRelInfo</name><argument_list>(<argument><expr><name>resultRelInfo</name></expr></argument>,
								  <argument><expr><name>resultRelDesc</name></expr></argument>,
								  <argument><expr><call><name>lfirst_int</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></argument>,
								  <argument><expr><name>NULL</name></expr></argument>,
								  <argument><expr><name><name>estate</name><operator>-&gt;</operator><name>es_instrument</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>resultRelInfo</name><operator>++</operator></expr>;</expr_stmt>
			</block_content>}</block>

			<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>es_root_result_relations</name></name> <operator>=</operator> <name>resultRelInfos</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>es_num_root_result_relations</name></name> <operator>=</operator> <name>num_roots</name></expr>;</expr_stmt>

			<comment type="block">/* Simply lock the rest of them. */</comment>
			<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>plannedstmt-&gt;nonleafResultRelations</argument>)</argument_list></macro>
			<block>{<block_content>
				<decl_stmt><decl><type><name>Index</name></type>		<name>resultRelIndex</name> <init>= <expr><call><name>lfirst_int</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

				<comment type="block">/* We locked the roots above. */</comment>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>list_member_int</name><argument_list>(<argument><expr><name><name>plannedstmt</name><operator>-&gt;</operator><name>rootResultRelations</name></name></expr></argument>,
									 <argument><expr><name>resultRelIndex</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>LockRelationOid</name><argument_list>(<argument><expr><call><name>getrelid</name><argument_list>(<argument><expr><name>resultRelIndex</name></expr></argument>, <argument><expr><name>rangeTable</name></expr></argument>)</argument_list></call></expr></argument>,
									<argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/*
		 * if no result relation, then set state appropriately
		 */</comment>
		<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>es_result_relations</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>es_num_result_relations</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>es_result_relation_info</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>es_root_result_relations</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>es_num_root_result_relations</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/*
	 * Similarly, we have to lock relations selected FOR [KEY] UPDATE/SHARE
	 * before we initialize the plan tree, else we'd be risking lock upgrades.
	 * While we are at it, build the ExecRowMark list.  Any partitioned child
	 * tables are ignored here (because isParent=true) and will be locked by
	 * the first Append or MergeAppend node that references them.  (Note that
	 * the RowMarks corresponding to partitioned child tables are present in
	 * the same list as the rest, i.e., plannedstmt-&gt;rowMarks.)
	 */</comment>
	<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>es_rowMarks</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>plannedstmt-&gt;rowMarks</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>PlanRowMark</name> <modifier>*</modifier></type><name>rc</name> <init>= <expr><operator>(</operator><name>PlanRowMark</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>relid</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Relation</name></type>	<name>relation</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ExecRowMark</name> <modifier>*</modifier></type><name>erm</name></decl>;</decl_stmt>

		<comment type="block">/* ignore "parent" rowmarks; they are irrelevant at runtime */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>rc</name><operator>-&gt;</operator><name>isParent</name></name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<comment type="block">/* get relation's OID (will produce InvalidOid if subquery) */</comment>
		<expr_stmt><expr><name>relid</name> <operator>=</operator> <call><name>getrelid</name><argument_list>(<argument><expr><name><name>rc</name><operator>-&gt;</operator><name>rti</name></name></expr></argument>, <argument><expr><name>rangeTable</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * If you change the conditions under which rel locks are acquired
		 * here, be sure to adjust ExecOpenScanRelation to match.
		 */</comment>
		<switch>switch <condition>(<expr><name><name>rc</name><operator>-&gt;</operator><name>markType</name></name></expr>)</condition>
		<block>{<block_content>
			<case>case <expr><name>ROW_MARK_EXCLUSIVE</name></expr>:</case>
			<case>case <expr><name>ROW_MARK_NOKEYEXCLUSIVE</name></expr>:</case>
			<case>case <expr><name>ROW_MARK_SHARE</name></expr>:</case>
			<case>case <expr><name>ROW_MARK_KEYSHARE</name></expr>:</case>
				<expr_stmt><expr><name>relation</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name>relid</name></expr></argument>, <argument><expr><name>RowShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>ROW_MARK_REFERENCE</name></expr>:</case>
				<expr_stmt><expr><name>relation</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name>relid</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>ROW_MARK_COPY</name></expr>:</case>
				<comment type="block">/* no physical table access is required */</comment>
				<expr_stmt><expr><name>relation</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
				<break>break;</break>
			<default>default:</default>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized markType: %d"</literal></expr></argument>, <argument><expr><name><name>rc</name><operator>-&gt;</operator><name>markType</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>relation</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>	<comment type="block">/* keep compiler quiet */</comment>
				<break>break;</break>
		</block_content>}</block></switch>

		<comment type="block">/* Check that relation is a legal target for marking */</comment>
		<if_stmt><if>if <condition>(<expr><name>relation</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>CheckValidRowMarkRel</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><name><name>rc</name><operator>-&gt;</operator><name>markType</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>erm</name> <operator>=</operator> <operator>(</operator><name>ExecRowMark</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ExecRowMark</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>erm</name><operator>-&gt;</operator><name>relation</name></name> <operator>=</operator> <name>relation</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>erm</name><operator>-&gt;</operator><name>relid</name></name> <operator>=</operator> <name>relid</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>erm</name><operator>-&gt;</operator><name>rti</name></name> <operator>=</operator> <name><name>rc</name><operator>-&gt;</operator><name>rti</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>erm</name><operator>-&gt;</operator><name>prti</name></name> <operator>=</operator> <name><name>rc</name><operator>-&gt;</operator><name>prti</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>erm</name><operator>-&gt;</operator><name>rowmarkId</name></name> <operator>=</operator> <name><name>rc</name><operator>-&gt;</operator><name>rowmarkId</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>erm</name><operator>-&gt;</operator><name>markType</name></name> <operator>=</operator> <name><name>rc</name><operator>-&gt;</operator><name>markType</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>erm</name><operator>-&gt;</operator><name>strength</name></name> <operator>=</operator> <name><name>rc</name><operator>-&gt;</operator><name>strength</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>erm</name><operator>-&gt;</operator><name>waitPolicy</name></name> <operator>=</operator> <name><name>rc</name><operator>-&gt;</operator><name>waitPolicy</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>erm</name><operator>-&gt;</operator><name>ermActive</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ItemPointerSetInvalid</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>erm</name><operator>-&gt;</operator><name>curCtid</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>erm</name><operator>-&gt;</operator><name>ermExtra</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>es_rowMarks</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>estate</name><operator>-&gt;</operator><name>es_rowMarks</name></name></expr></argument>, <argument><expr><name>erm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<comment type="block">/*
	 * Initialize the executor's tuple table to empty.
	 */</comment>
	<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>es_tupleTable</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>es_trig_tuple_slot</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>es_trig_oldtup_slot</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>es_trig_newtup_slot</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<comment type="block">/* mark EvalPlanQual not active */</comment>
	<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>es_epqTuple</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>es_epqTupleSet</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>es_epqScanDone</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Initialize private state information for each SubPlan.  We must do this
	 * before running ExecInitNode on the main query tree, since
	 * ExecInitSubPlan expects to be able to find these entries.
	 */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>estate</name><operator>-&gt;</operator><name>es_subplanstates</name></name> <operator>==</operator> <name>NIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* POLAR px */</comment>
	<if_stmt><if>if <condition>(<expr><name>use_px</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>start_plan_node</name> <operator>=</operator> <name><name>plannedstmt</name><operator>-&gt;</operator><name>planTree</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>currentSliceId</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<comment type="block">/*
		* If eliminateAliens is true then we extract the local Motion node
		* and subplans for our current slice. This enables us to call ExecInitNode
		* for only a subset of the plan tree.
		*/</comment>
		<if_stmt><if>if <condition>(<expr><name><name>estate</name><operator>-&gt;</operator><name>eliminateAliens</name></name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Motion</name> <modifier>*</modifier></type><name>m</name> <init>= <expr><call><name>findSenderMotion</name><argument_list>(<argument><expr><name>plannedstmt</name></expr></argument>, <argument><expr><call><name>LocallyExecutingSliceIndex</name><argument_list>(<argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<comment type="block">/*
			* We may not have any motion in the current slice, e.g., in insert query
			* the root may not have any motion.
			*/</comment>
			<if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>!=</operator> <name>m</name></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>ExecSlice</name> <modifier>*</modifier></type><name>sendSlice</name> <init>= <expr><operator>&amp;</operator><name><name>estate</name><operator>-&gt;</operator><name>es_sliceTable</name><operator>-&gt;</operator><name>slices</name><index>[<expr><name><name>m</name><operator>-&gt;</operator><name>motionID</name></name></expr>]</index></name></expr></init></decl>;</decl_stmt>
				<expr_stmt><expr><name>start_plan_node</name> <operator>=</operator> <operator>(</operator><name>Plan</name> <operator>*</operator><operator>)</operator> <name>m</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>currentSliceId</name></name> <operator>=</operator> <name><name>sendSlice</name><operator>-&gt;</operator><name>parentIndex</name></name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>						<comment type="block">/* subplan indices count from 1 */</comment>
	<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>plannedstmt-&gt;subplans</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Plan</name>	   <modifier>*</modifier></type><name>subplan</name> <init>= <expr><operator>(</operator><name>Plan</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>PlanState</name>  <modifier>*</modifier></type><name>subplanstate</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>sp_eflags</name></decl>;</decl_stmt>

		<comment type="block">/* POLAR px */</comment>
		<decl_stmt><decl><type><name>int</name></type>			<name>save_currentSliceId</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * A subplan will never need to do BACKWARD scan nor MARK/RESTORE. If
		 * it is a parameterless subplan (not initplan), we suggest that it be
		 * prepared to handle REWIND efficiently; otherwise there is no need.
		 */</comment>
		<expr_stmt><expr><name>sp_eflags</name> <operator>=</operator> <name>eflags</name>
			<operator>&amp;</operator> <operator>(</operator><name>EXEC_FLAG_EXPLAIN_ONLY</name> <operator>|</operator> <name>EXEC_FLAG_WITH_NO_DATA</name><operator>)</operator></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>bms_is_member</name><argument_list>(<argument><expr><name>i</name></expr></argument>, <argument><expr><name><name>plannedstmt</name><operator>-&gt;</operator><name>rewindPlanIDs</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>sp_eflags</name> <operator>|=</operator> <name>EXEC_FLAG_REWIND</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/* POLAR px */</comment>
		<expr_stmt><expr><name>save_currentSliceId</name> <operator>=</operator> <name><name>estate</name><operator>-&gt;</operator><name>currentSliceId</name></name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>use_px</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>currentSliceId</name></name> <operator>=</operator> <name><name>estate</name><operator>-&gt;</operator><name>es_plannedstmt</name><operator>-&gt;</operator><name>subplan_sliceIds</name><index>[<expr><name>i</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
			<expr_stmt><expr><name>sp_eflags</name> <operator>|=</operator> <name>EXEC_FLAG_REWIND</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name>subplanstate</name> <operator>=</operator> <call><name>ExecInitNode</name><argument_list>(<argument><expr><name>subplan</name></expr></argument>, <argument><expr><name>estate</name></expr></argument>, <argument><expr><name>sp_eflags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* POLAR px */</comment>
		<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>currentSliceId</name></name> <operator>=</operator> <name>save_currentSliceId</name></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>es_subplanstates</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>estate</name><operator>-&gt;</operator><name>es_subplanstates</name></name></expr></argument>,
										   <argument><expr><name>subplanstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block>

	<comment type="block">/* POLAR px */</comment>
	<if_stmt><if>if <condition>(<expr><name>use_px</name> <operator>&amp;&amp;</operator> <name>px_role</name> <operator>==</operator> <name>PX_ROLE_PX</name> <operator>&amp;&amp;</operator> <name>px_is_executing</name> <operator>&amp;&amp;</operator> <name><name>queryDesc</name><operator>-&gt;</operator><name>ddesc</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ExtractParamsFromInitPlans</name><argument_list>(<argument><expr><name>plannedstmt</name></expr></argument>, <argument><expr><name><name>plannedstmt</name><operator>-&gt;</operator><name>planTree</name></name></expr></argument>, <argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Initialize the private state information for all the nodes in the query
	 * tree.  This opens files, allocates storage and leaves us ready to start
	 * processing tuples.
	 */</comment>
	<expr_stmt><expr><name>planstate</name> <operator>=</operator> <call><name>ExecInitNode</name><argument_list>(<argument><expr><operator>(</operator><ternary><condition><expr><name>use_px</name></expr> ?</condition><then> <expr><name>start_plan_node</name></expr> </then><else>: <expr><name>plan</name></expr></else></ternary><operator>)</operator></expr></argument>, <argument><expr><name>estate</name></expr></argument>, <argument><expr><name>eflags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Get the tuple descriptor describing the type of tuples to return.
	 */</comment>
	<expr_stmt><expr><name>tupType</name> <operator>=</operator> <call><name>ExecGetResultType</name><argument_list>(<argument><expr><name>planstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Initialize the junk filter if needed.  SELECT queries need a filter if
	 * there are any junk attrs in the top-level tlist.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>operation</name> <operator>==</operator> <name>CMD_SELECT</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>bool</name></type>		<name>junk_filter_needed</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>tlist</name></decl>;</decl_stmt>

		<macro><name>foreach</name><argument_list>(<argument>tlist</argument>, <argument>plan-&gt;targetlist</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>tle</name> <init>= <expr><operator>(</operator><name>TargetEntry</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>tlist</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>tle</name><operator>-&gt;</operator><name>resjunk</name></name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>junk_filter_needed</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block>

		<if_stmt><if>if <condition>(<expr><name>junk_filter_needed</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>JunkFilter</name> <modifier>*</modifier></type><name>j</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>j</name> <operator>=</operator> <call><name>ExecInitJunkFilter</name><argument_list>(<argument><expr><name><name>planstate</name><operator>-&gt;</operator><name>plan</name><operator>-&gt;</operator><name>targetlist</name></name></expr></argument>,
								   <argument><expr><name><name>tupType</name><operator>-&gt;</operator><name>tdhasoid</name></name></expr></argument>,
								   <argument><expr><call><name>ExecInitExtraTupleSlot</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>es_junkFilter</name></name> <operator>=</operator> <name>j</name></expr>;</expr_stmt>

			<comment type="block">/* Want to return the cleaned tuple type */</comment>
			<expr_stmt><expr><name>tupType</name> <operator>=</operator> <name><name>j</name><operator>-&gt;</operator><name>jf_cleanTupType</name></name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name><name>queryDesc</name><operator>-&gt;</operator><name>tupDesc</name></name> <operator>=</operator> <name>tupType</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>queryDesc</name><operator>-&gt;</operator><name>planstate</name></name> <operator>=</operator> <name>planstate</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Check that a proposed result relation is a legal target for the operation
 *
 * Generally the parser and/or planner should have noticed any such mistake
 * already, but let's make sure.
 *
 * Note: when changing this function, you probably also need to look at
 * CheckValidRowMarkRel.
 */</comment>
<function><type><name>void</name></type>
<name>CheckValidResultRel</name><parameter_list>(<parameter><decl><type><name>ResultRelInfo</name> <modifier>*</modifier></type><name>resultRelInfo</name></decl></parameter>, <parameter><decl><type><name>CmdType</name></type> <name>operation</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>resultRel</name> <init>= <expr><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_RelationDesc</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TriggerDesc</name> <modifier>*</modifier></type><name>trigDesc</name> <init>= <expr><name><name>resultRel</name><operator>-&gt;</operator><name>trigdesc</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>FdwRoutine</name> <modifier>*</modifier></type><name>fdwroutine</name></decl>;</decl_stmt>

	<switch>switch <condition>(<expr><name><name>resultRel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>RELKIND_RELATION</name></expr>:</case>
		<case>case <expr><name>RELKIND_PARTITIONED_TABLE</name></expr>:</case>
			<expr_stmt><expr><call><name>CheckCmdReplicaIdentity</name><argument_list>(<argument><expr><name>resultRel</name></expr></argument>, <argument><expr><name>operation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>RELKIND_SEQUENCE</name></expr>:</case>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WRONG_OBJECT_TYPE</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot change sequence \"%s\""</literal></expr></argument>,
							<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>resultRel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>RELKIND_TOASTVALUE</name></expr>:</case>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WRONG_OBJECT_TYPE</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot change TOAST relation \"%s\""</literal></expr></argument>,
							<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>resultRel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>RELKIND_VIEW</name></expr>:</case>

			<comment type="block">/*
			 * Okay only if there's a suitable INSTEAD OF trigger.  Messages
			 * here should match rewriteHandler.c's rewriteTargetView and
			 * RewriteQuery, except that we omit errdetail because we haven't
			 * got the information handy (and given that we really shouldn't
			 * get here anyway, it's not worth great exertion to get).
			 */</comment>
			<switch>switch <condition>(<expr><name>operation</name></expr>)</condition>
			<block>{<block_content>
				<case>case <expr><name>CMD_INSERT</name></expr>:</case>
					<if_stmt><if>if <condition>(<expr><operator>!</operator><name>trigDesc</name> <operator>||</operator> <operator>!</operator><name><name>trigDesc</name><operator>-&gt;</operator><name>trig_insert_instead_row</name></name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
								<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE</name></expr></argument>)</argument_list></call><operator>,</operator>
								 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot insert into view \"%s\""</literal></expr></argument>,
										<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>resultRel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
								 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"To enable inserting into the view, provide an INSTEAD OF INSERT trigger or an unconditional ON INSERT DO INSTEAD rule."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
					<break>break;</break>
				<case>case <expr><name>CMD_UPDATE</name></expr>:</case>
					<if_stmt><if>if <condition>(<expr><operator>!</operator><name>trigDesc</name> <operator>||</operator> <operator>!</operator><name><name>trigDesc</name><operator>-&gt;</operator><name>trig_update_instead_row</name></name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
								<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE</name></expr></argument>)</argument_list></call><operator>,</operator>
								 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot update view \"%s\""</literal></expr></argument>,
										<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>resultRel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
								 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"To enable updating the view, provide an INSTEAD OF UPDATE trigger or an unconditional ON UPDATE DO INSTEAD rule."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
					<break>break;</break>
				<case>case <expr><name>CMD_DELETE</name></expr>:</case>
					<if_stmt><if>if <condition>(<expr><operator>!</operator><name>trigDesc</name> <operator>||</operator> <operator>!</operator><name><name>trigDesc</name><operator>-&gt;</operator><name>trig_delete_instead_row</name></name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
								<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE</name></expr></argument>)</argument_list></call><operator>,</operator>
								 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot delete from view \"%s\""</literal></expr></argument>,
										<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>resultRel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
								 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"To enable deleting from the view, provide an INSTEAD OF DELETE trigger or an unconditional ON DELETE DO INSTEAD rule."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
					<break>break;</break>
				<default>default:</default>
					<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized CmdType: %d"</literal></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name>operation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<break>break;</break>
			</block_content>}</block></switch>
			<break>break;</break>
		<case>case <expr><name>RELKIND_MATVIEW</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>MatViewIncrementalMaintenanceIsEnabled</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WRONG_OBJECT_TYPE</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot change materialized view \"%s\""</literal></expr></argument>,
								<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>resultRel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<break>break;</break>
		<case>case <expr><name>RELKIND_FOREIGN_TABLE</name></expr>:</case>
			<comment type="block">/* Okay only if the FDW supports it */</comment>
			<expr_stmt><expr><name>fdwroutine</name> <operator>=</operator> <name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_FdwRoutine</name></name></expr>;</expr_stmt>
			<switch>switch <condition>(<expr><name>operation</name></expr>)</condition>
			<block>{<block_content>
				<case>case <expr><name>CMD_INSERT</name></expr>:</case>
					<if_stmt><if>if <condition>(<expr><name><name>fdwroutine</name><operator>-&gt;</operator><name>ExecForeignInsert</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
								<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
								 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot insert into foreign table \"%s\""</literal></expr></argument>,
										<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>resultRel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
					<if_stmt><if>if <condition>(<expr><name><name>fdwroutine</name><operator>-&gt;</operator><name>IsForeignRelUpdatable</name></name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator>
						<operator>(</operator><call><name><name>fdwroutine</name><operator>-&gt;</operator><name>IsForeignRelUpdatable</name></name><argument_list>(<argument><expr><name>resultRel</name></expr></argument>)</argument_list></call> <operator>&amp;</operator> <operator>(</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <name>CMD_INSERT</name><operator>)</operator><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
								<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE</name></expr></argument>)</argument_list></call><operator>,</operator>
								 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"foreign table \"%s\" does not allow inserts"</literal></expr></argument>,
										<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>resultRel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
					<break>break;</break>
				<case>case <expr><name>CMD_UPDATE</name></expr>:</case>
					<if_stmt><if>if <condition>(<expr><name><name>fdwroutine</name><operator>-&gt;</operator><name>ExecForeignUpdate</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
								<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
								 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot update foreign table \"%s\""</literal></expr></argument>,
										<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>resultRel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
					<if_stmt><if>if <condition>(<expr><name><name>fdwroutine</name><operator>-&gt;</operator><name>IsForeignRelUpdatable</name></name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator>
						<operator>(</operator><call><name><name>fdwroutine</name><operator>-&gt;</operator><name>IsForeignRelUpdatable</name></name><argument_list>(<argument><expr><name>resultRel</name></expr></argument>)</argument_list></call> <operator>&amp;</operator> <operator>(</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <name>CMD_UPDATE</name><operator>)</operator><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
								<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE</name></expr></argument>)</argument_list></call><operator>,</operator>
								 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"foreign table \"%s\" does not allow updates"</literal></expr></argument>,
										<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>resultRel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
					<break>break;</break>
				<case>case <expr><name>CMD_DELETE</name></expr>:</case>
					<if_stmt><if>if <condition>(<expr><name><name>fdwroutine</name><operator>-&gt;</operator><name>ExecForeignDelete</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
								<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
								 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot delete from foreign table \"%s\""</literal></expr></argument>,
										<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>resultRel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
					<if_stmt><if>if <condition>(<expr><name><name>fdwroutine</name><operator>-&gt;</operator><name>IsForeignRelUpdatable</name></name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator>
						<operator>(</operator><call><name><name>fdwroutine</name><operator>-&gt;</operator><name>IsForeignRelUpdatable</name></name><argument_list>(<argument><expr><name>resultRel</name></expr></argument>)</argument_list></call> <operator>&amp;</operator> <operator>(</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <name>CMD_DELETE</name><operator>)</operator><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
								<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE</name></expr></argument>)</argument_list></call><operator>,</operator>
								 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"foreign table \"%s\" does not allow deletes"</literal></expr></argument>,
										<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>resultRel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
					<break>break;</break>
				<default>default:</default>
					<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized CmdType: %d"</literal></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name>operation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<break>break;</break>
			</block_content>}</block></switch>
			<break>break;</break>
		<default>default:</default>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WRONG_OBJECT_TYPE</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot change relation \"%s\""</literal></expr></argument>,
							<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>resultRel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
	</block_content>}</block></switch>
</block_content>}</block></function>

<comment type="block">/*
 * Check that a proposed rowmark target relation is a legal target
 *
 * In most cases parser and/or planner should have noticed this already, but
 * they don't cover all cases.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>CheckValidRowMarkRel</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>RowMarkType</name></type> <name>markType</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>FdwRoutine</name> <modifier>*</modifier></type><name>fdwroutine</name></decl>;</decl_stmt>

	<switch>switch <condition>(<expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>RELKIND_RELATION</name></expr>:</case>
		<case>case <expr><name>RELKIND_PARTITIONED_TABLE</name></expr>:</case>
			<comment type="block">/* OK */</comment>
			<break>break;</break>
		<case>case <expr><name>RELKIND_SEQUENCE</name></expr>:</case>
			<comment type="block">/* Must disallow this because we don't vacuum sequences */</comment>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WRONG_OBJECT_TYPE</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot lock rows in sequence \"%s\""</literal></expr></argument>,
							<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>RELKIND_TOASTVALUE</name></expr>:</case>
			<comment type="block">/* We could allow this, but there seems no good reason to */</comment>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WRONG_OBJECT_TYPE</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot lock rows in TOAST relation \"%s\""</literal></expr></argument>,
							<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>RELKIND_VIEW</name></expr>:</case>
			<comment type="block">/* Should not get here; planner should have expanded the view */</comment>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WRONG_OBJECT_TYPE</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot lock rows in view \"%s\""</literal></expr></argument>,
							<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>RELKIND_MATVIEW</name></expr>:</case>
			<comment type="block">/* Allow referencing a matview, but not actual locking clauses */</comment>
			<if_stmt><if>if <condition>(<expr><name>markType</name> <operator>!=</operator> <name>ROW_MARK_REFERENCE</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WRONG_OBJECT_TYPE</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot lock rows in materialized view \"%s\""</literal></expr></argument>,
								<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<break>break;</break>
		<case>case <expr><name>RELKIND_FOREIGN_TABLE</name></expr>:</case>
			<comment type="block">/* Okay only if the FDW supports it */</comment>
			<expr_stmt><expr><name>fdwroutine</name> <operator>=</operator> <call><name>GetFdwRoutineForRelation</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>fdwroutine</name><operator>-&gt;</operator><name>RefetchForeignRow</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot lock rows in foreign table \"%s\""</literal></expr></argument>,
								<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<break>break;</break>
		<default>default:</default>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WRONG_OBJECT_TYPE</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot lock rows in relation \"%s\""</literal></expr></argument>,
							<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
	</block_content>}</block></switch>
</block_content>}</block></function>

<comment type="block">/*
 * Initialize ResultRelInfo data for one result relation
 *
 * Caution: before Postgres 9.1, this function included the relkind checking
 * that's now in CheckValidResultRel, and it also did ExecOpenIndices if
 * appropriate.  Be sure callers cover those needs.
 */</comment>
<function><type><name>void</name></type>
<name>InitResultRelInfo</name><parameter_list>(<parameter><decl><type><name>ResultRelInfo</name> <modifier>*</modifier></type><name>resultRelInfo</name></decl></parameter>,
				  <parameter><decl><type><name>Relation</name></type> <name>resultRelationDesc</name></decl></parameter>,
				  <parameter><decl><type><name>Index</name></type> <name>resultRelationIndex</name></decl></parameter>,
				  <parameter><decl><type><name>Relation</name></type> <name>partition_root</name></decl></parameter>,
				  <parameter><decl><type><name>int</name></type> <name>instrument_options</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>partition_check</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><name>resultRelInfo</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ResultRelInfo</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>resultRelInfo</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name>T_ResultRelInfo</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_RangeTableIndex</name></name> <operator>=</operator> <name>resultRelationIndex</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_RelationDesc</name></name> <operator>=</operator> <name>resultRelationDesc</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_NumIndices</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_IndexRelationDescs</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_IndexRelationInfo</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<comment type="block">/* make a copy so as not to depend on relcache info not changing... */</comment>
	<expr_stmt><expr><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_TrigDesc</name></name> <operator>=</operator> <call><name>CopyTriggerDesc</name><argument_list>(<argument><expr><name><name>resultRelationDesc</name><operator>-&gt;</operator><name>trigdesc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_TrigDesc</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>n</name> <init>= <expr><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_TrigDesc</name><operator>-&gt;</operator><name>numtriggers</name></name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_TrigFunctions</name></name> <operator>=</operator> <operator>(</operator><name>FmgrInfo</name> <operator>*</operator><operator>)</operator>
			<call><name>palloc0</name><argument_list>(<argument><expr><name>n</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>FmgrInfo</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_TrigWhenExprs</name></name> <operator>=</operator> <operator>(</operator><name>ExprState</name> <operator>*</operator><operator>*</operator><operator>)</operator>
			<call><name>palloc0</name><argument_list>(<argument><expr><name>n</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ExprState</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>instrument_options</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_TrigInstrument</name></name> <operator>=</operator> <call><name>InstrAlloc</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr><name>instrument_options</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_TrigFunctions</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_TrigWhenExprs</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_TrigInstrument</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>resultRelationDesc</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_FOREIGN_TABLE</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_FdwRoutine</name></name> <operator>=</operator> <call><name>GetFdwRoutineForRelation</name><argument_list>(<argument><expr><name>resultRelationDesc</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_FdwRoutine</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/* The following fields are set later if needed */</comment>
	<expr_stmt><expr><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_FdwState</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_usesFdwDirectModify</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_ConstraintExprs</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_junkFilter</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_projectReturning</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_onConflictArbiterIndexes</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_onConflict</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<comment type="block">/* POLAR px */</comment>
	<expr_stmt><expr><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_action_attno</name></name> <operator>=</operator> <name>InvalidAttrNumber</name></expr>;</expr_stmt>	
	<comment type="block">/* POLAR px */</comment>

	<comment type="block">/*
	 * Partition constraint, which also includes the partition constraint of
	 * all the ancestors that are partitions.  Note that it will be checked
	 * even in the case of tuple-routing where this table is the target leaf
	 * partition, if there any BR triggers defined on the table.  Although
	 * tuple-routing implicitly preserves the partition constraint of the
	 * target partition for a given row, the BR triggers may change the row
	 * such that the constraint is no longer satisfied, which we must fail for
	 * by checking it explicitly.
	 *
	 * If this is a partitioned table, the partition constraint (if any) of a
	 * given row will be checked just before performing tuple-routing.
	 */</comment>
	<expr_stmt><expr><name>partition_check</name> <operator>=</operator> <call><name>RelationGetPartitionQual</name><argument_list>(<argument><expr><name>resultRelationDesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_PartitionCheck</name></name> <operator>=</operator> <name>partition_check</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_PartitionRoot</name></name> <operator>=</operator> <name>partition_root</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_PartitionReadyForRouting</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 *		ExecGetTriggerResultRel
 *
 * Get a ResultRelInfo for a trigger target relation.  Most of the time,
 * triggers are fired on one of the result relations of the query, and so
 * we can just return a member of the es_result_relations array, the
 * es_root_result_relations array (if any), or the es_leaf_result_relations
 * list (if any).  (Note: in self-join situations there might be multiple
 * members with the same OID; if so it doesn't matter which one we pick.)
 * However, it is sometimes necessary to fire triggers on other relations;
 * this happens mainly when an RI update trigger queues additional triggers
 * on other relations, which will be processed in the context of the outer
 * query.  For efficiency's sake, we want to have a ResultRelInfo for those
 * triggers too; that can avoid repeated re-opening of the relation.  (It
 * also provides a way for EXPLAIN ANALYZE to report the runtimes of such
 * triggers.)  So we make additional ResultRelInfo's as needed, and save them
 * in es_trig_target_relations.
 */</comment>
<function><type><name>ResultRelInfo</name> <modifier>*</modifier></type>
<name>ExecGetTriggerResultRel</name><parameter_list>(<parameter><decl><type><name>EState</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>relid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ResultRelInfo</name> <modifier>*</modifier></type><name>rInfo</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>nr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>rel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcontext</name></decl>;</decl_stmt>

	<comment type="block">/* First, search through the query result relations */</comment>
	<expr_stmt><expr><name>rInfo</name> <operator>=</operator> <name><name>estate</name><operator>-&gt;</operator><name>es_result_relations</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>nr</name> <operator>=</operator> <name><name>estate</name><operator>-&gt;</operator><name>es_num_result_relations</name></name></expr>;</expr_stmt>
	<while>while <condition>(<expr><name>nr</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name><name>rInfo</name><operator>-&gt;</operator><name>ri_RelationDesc</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <name>relid</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>rInfo</name></expr>;</return></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>rInfo</name><operator>++</operator></expr>;</expr_stmt>
		<expr_stmt><expr><name>nr</name><operator>--</operator></expr>;</expr_stmt>
	</block_content>}</block></while>
	<comment type="block">/* Second, search through the root result relations, if any */</comment>
	<expr_stmt><expr><name>rInfo</name> <operator>=</operator> <name><name>estate</name><operator>-&gt;</operator><name>es_root_result_relations</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>nr</name> <operator>=</operator> <name><name>estate</name><operator>-&gt;</operator><name>es_num_root_result_relations</name></name></expr>;</expr_stmt>
	<while>while <condition>(<expr><name>nr</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name><name>rInfo</name><operator>-&gt;</operator><name>ri_RelationDesc</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <name>relid</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>rInfo</name></expr>;</return></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>rInfo</name><operator>++</operator></expr>;</expr_stmt>
		<expr_stmt><expr><name>nr</name><operator>--</operator></expr>;</expr_stmt>
	</block_content>}</block></while>

	<comment type="block">/*
	 * Third, search through the result relations that were created during
	 * tuple routing, if any.
	 */</comment>
	<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>estate-&gt;es_tuple_routing_result_relations</argument>)</argument_list></macro>
	<block>{<block_content>
		<expr_stmt><expr><name>rInfo</name> <operator>=</operator> <operator>(</operator><name>ResultRelInfo</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name><name>rInfo</name><operator>-&gt;</operator><name>ri_RelationDesc</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <name>relid</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>rInfo</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block>
	<comment type="block">/* Nope, but maybe we already made an extra ResultRelInfo for it */</comment>
	<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>estate-&gt;es_trig_target_relations</argument>)</argument_list></macro>
	<block>{<block_content>
		<expr_stmt><expr><name>rInfo</name> <operator>=</operator> <operator>(</operator><name>ResultRelInfo</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name><name>rInfo</name><operator>-&gt;</operator><name>ri_RelationDesc</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <name>relid</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>rInfo</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block>
	<comment type="block">/* Nope, so we need a new one */</comment>

	<comment type="block">/*
	 * Open the target relation's relcache entry.  We assume that an
	 * appropriate lock is still held by the backend from whenever the trigger
	 * event got queued, so we need take no new lock here.  Also, we need not
	 * recheck the relkind, so no need for CheckValidResultRel.
	 */</comment>
	<expr_stmt><expr><name>rel</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name>relid</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Make the new entry in the right context.
	 */</comment>
	<expr_stmt><expr><name>oldcontext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>estate</name><operator>-&gt;</operator><name>es_query_cxt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>rInfo</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>ResultRelInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>InitResultRelInfo</name><argument_list>(<argument><expr><name>rInfo</name></expr></argument>,
					  <argument><expr><name>rel</name></expr></argument>,
					  <argument><expr><literal type="number">0</literal></expr></argument>,		<comment type="block">/* dummy rangetable index */</comment>
					  <argument><expr><name>NULL</name></expr></argument>,
					  <argument><expr><name><name>estate</name><operator>-&gt;</operator><name>es_instrument</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>es_trig_target_relations</name></name> <operator>=</operator>
		<call><name>lappend</name><argument_list>(<argument><expr><name><name>estate</name><operator>-&gt;</operator><name>es_trig_target_relations</name></name></expr></argument>, <argument><expr><name>rInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Currently, we don't need any index information in ResultRelInfos used
	 * only for triggers, so no need to call ExecOpenIndices.
	 */</comment>

	<return>return <expr><name>rInfo</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Close any relations that have been opened by ExecGetTriggerResultRel().
 */</comment>
<function><type><name>void</name></type>
<name>ExecCleanUpTriggerState</name><parameter_list>(<parameter><decl><type><name>EState</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>

	<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>estate-&gt;es_trig_target_relations</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ResultRelInfo</name> <modifier>*</modifier></type><name>resultRelInfo</name> <init>= <expr><operator>(</operator><name>ResultRelInfo</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/* Close indices and then the relation itself */</comment>
		<expr_stmt><expr><call><name>ExecCloseIndices</name><argument_list>(<argument><expr><name>resultRelInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_RelationDesc</name></name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
</block_content>}</block></function>

<comment type="block">/*
 *		ExecContextForcesOids
 *
 * This is pretty grotty: when doing INSERT, UPDATE, or CREATE TABLE AS,
 * we need to ensure that result tuples have space for an OID iff they are
 * going to be stored into a relation that has OIDs.  In other contexts
 * we are free to choose whether to leave space for OIDs in result tuples
 * (we generally don't want to, but we do if a physical-tlist optimization
 * is possible).  This routine checks the plan context and returns true if the
 * choice is forced, false if the choice is not forced.  In the true case,
 * *hasoids is set to the required value.
 *
 * One reason this is ugly is that all plan nodes in the plan tree will emit
 * tuples with space for an OID, though we really only need the topmost node
 * to do so.  However, node types like Sort don't project new tuples but just
 * return their inputs, and in those cases the requirement propagates down
 * to the input node.  Eventually we might make this code smart enough to
 * recognize how far down the requirement really goes, but for now we just
 * make all plan nodes do the same thing if the top level forces the choice.
 *
 * We assume that if we are generating tuples for INSERT or UPDATE,
 * estate-&gt;es_result_relation_info is already set up to describe the target
 * relation.  Note that in an UPDATE that spans an inheritance tree, some of
 * the target relations may have OIDs and some not.  We have to make the
 * decisions on a per-relation basis as we initialize each of the subplans of
 * the ModifyTable node, so ModifyTable has to set es_result_relation_info
 * while initializing each subplan.
 *
 * CREATE TABLE AS is even uglier, because we don't have the target relation's
 * descriptor available when this code runs; we have to look aside at the
 * flags passed to ExecutorStart().
 */</comment>
<function><type><name>bool</name></type>
<name>ExecContextForcesOids</name><parameter_list>(<parameter><decl><type><name>PlanState</name> <modifier>*</modifier></type><name>planstate</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>hasoids</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ResultRelInfo</name> <modifier>*</modifier></type><name>ri</name> <init>= <expr><name><name>planstate</name><operator>-&gt;</operator><name>state</name><operator>-&gt;</operator><name>es_result_relation_info</name></name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>ri</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Relation</name></type>	<name>rel</name> <init>= <expr><name><name>ri</name><operator>-&gt;</operator><name>ri_RelationDesc</name></name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>rel</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><operator>*</operator><name>hasoids</name> <operator>=</operator> <name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relhasoids</name></name></expr>;</expr_stmt>
			<return>return <expr><name>true</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>planstate</name><operator>-&gt;</operator><name>state</name><operator>-&gt;</operator><name>es_top_eflags</name></name> <operator>&amp;</operator> <name>EXEC_FLAG_WITH_OIDS</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><operator>*</operator><name>hasoids</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>planstate</name><operator>-&gt;</operator><name>state</name><operator>-&gt;</operator><name>es_top_eflags</name></name> <operator>&amp;</operator> <name>EXEC_FLAG_WITHOUT_OIDS</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><operator>*</operator><name>hasoids</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* ----------------------------------------------------------------
 *		ExecPostprocessPlan
 *
 *		Give plan nodes a final chance to execute before shutdown
 * ----------------------------------------------------------------
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ExecPostprocessPlan</name><parameter_list>(<parameter><decl><type><name>EState</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Make sure nodes run forward.
	 */</comment>
	<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>es_direction</name></name> <operator>=</operator> <name>ForwardScanDirection</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Run any secondary ModifyTable nodes to completion, in case the main
	 * query did not fetch all rows from them.  (We do this to ensure that
	 * such nodes have predictable results.)
	 */</comment>
	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>estate-&gt;es_auxmodifytables</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>PlanState</name>  <modifier>*</modifier></type><name>ps</name> <init>= <expr><operator>(</operator><name>PlanState</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl>;</decl_stmt>

			<comment type="block">/* Reset the per-output-tuple exprcontext each time */</comment>
			<expr_stmt><expr><call><name>ResetPerTupleExprContext</name><argument_list>(<argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name>slot</name> <operator>=</operator> <call><name>ExecProcNode</name><argument_list>(<argument><expr><name>ps</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>TupIsNull</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<break>break;</break></block_content></block></if></if_stmt>
		</block_content>}</block></for>
	</block_content>}</block>
</block_content>}</block></function>

<comment type="block">/* ----------------------------------------------------------------
 *		ExecEndPlan
 *
 *		Cleans up the query plan -- closes files and frees up storage
 *
 * NOTE: we are no longer very worried about freeing storage per se
 * in this code; FreeExecutorState should be guaranteed to release all
 * memory that needs to be released.  What we are worried about doing
 * is closing relations and dropping buffer pins.  Thus, for example,
 * tuple tables must be cleared or dropped to ensure pins are released.
 * ----------------------------------------------------------------
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ExecEndPlan</name><parameter_list>(<parameter><decl><type><name>PlanState</name> <modifier>*</modifier></type><name>planstate</name></decl></parameter>, <parameter><decl><type><name>EState</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ResultRelInfo</name> <modifier>*</modifier></type><name>resultRelInfo</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * shut down the node-type-specific query processing
	 */</comment>
	<expr_stmt><expr><call><name>ExecEndNode</name><argument_list>(<argument><expr><name>planstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * for subplans too
	 */</comment>
	<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>estate-&gt;es_subplanstates</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>PlanState</name>  <modifier>*</modifier></type><name>subplanstate</name> <init>= <expr><operator>(</operator><name>PlanState</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>ExecEndNode</name><argument_list>(<argument><expr><name>subplanstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<comment type="block">/*
	 * destroy the executor's tuple table.  Actually we only care about
	 * releasing buffer pins and tupdesc refcounts; there's no need to pfree
	 * the TupleTableSlots, since the containing memory context is about to go
	 * away anyway.
	 */</comment>
	<expr_stmt><expr><call><name>ExecResetTupleTable</name><argument_list>(<argument><expr><name><name>estate</name><operator>-&gt;</operator><name>es_tupleTable</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * close the result relation(s) if any, but hold locks until xact commit.
	 */</comment>
	<expr_stmt><expr><name>resultRelInfo</name> <operator>=</operator> <name><name>estate</name><operator>-&gt;</operator><name>es_result_relations</name></name></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name><name>estate</name><operator>-&gt;</operator><name>es_num_result_relations</name></name></expr>;</init> <condition><expr><name>i</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><name>i</name><operator>--</operator></expr></incr>)</control>
	<block>{<block_content>
		<comment type="block">/* Close indices and then the relation itself */</comment>
		<expr_stmt><expr><call><name>ExecCloseIndices</name><argument_list>(<argument><expr><name>resultRelInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_RelationDesc</name></name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>resultRelInfo</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block></for>

	<comment type="block">/* Close the root target relation(s). */</comment>
	<expr_stmt><expr><name>resultRelInfo</name> <operator>=</operator> <name><name>estate</name><operator>-&gt;</operator><name>es_root_result_relations</name></name></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name><name>estate</name><operator>-&gt;</operator><name>es_num_root_result_relations</name></name></expr>;</init> <condition><expr><name>i</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><name>i</name><operator>--</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_RelationDesc</name></name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>resultRelInfo</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block></for>

	<comment type="block">/* likewise close any trigger target relations */</comment>
	<expr_stmt><expr><call><name>ExecCleanUpTriggerState</name><argument_list>(<argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * close any relations selected FOR [KEY] UPDATE/SHARE, again keeping
	 * locks
	 */</comment>
	<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>estate-&gt;es_rowMarks</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ExecRowMark</name> <modifier>*</modifier></type><name>erm</name> <init>= <expr><operator>(</operator><name>ExecRowMark</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>erm</name><operator>-&gt;</operator><name>relation</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name><name>erm</name><operator>-&gt;</operator><name>relation</name></name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block>
</block_content>}</block></function>

<comment type="block">/* ----------------------------------------------------------------
 *		ExecutePlan
 *
 *		Processes the query plan until we have retrieved 'numberTuples' tuples,
 *		moving in the specified direction.
 *
 *		Runs to completion if numberTuples is 0
 *
 * Note: the ctid attribute is a 'junk' attribute that is removed before the
 * user can see it
 * ----------------------------------------------------------------
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ExecutePlan</name><parameter_list>(<parameter><decl><type><name>EState</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>,
			<parameter><decl><type><name>PlanState</name> <modifier>*</modifier></type><name>planstate</name></decl></parameter>,
			<parameter><decl><type><name>bool</name></type> <name>use_parallel_mode</name></decl></parameter>,
			<parameter><decl><type><name>CmdType</name></type> <name>operation</name></decl></parameter>,
			<parameter><decl><type><name>bool</name></type> <name>sendTuples</name></decl></parameter>,
			<parameter><decl><type><name>uint64</name></type> <name>numberTuples</name></decl></parameter>,
			<parameter><decl><type><name>ScanDirection</name></type> <name>direction</name></decl></parameter>,
			<parameter><decl><type><name>DestReceiver</name> <modifier>*</modifier></type><name>dest</name></decl></parameter>,
			<parameter><decl><type><name>bool</name></type> <name>execute_once</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint64</name></type>		<name>current_tuple_count</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * initialize local variables
	 */</comment>
	<expr_stmt><expr><name>current_tuple_count</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<comment type="block">/*
	 * Set the direction.
	 */</comment>
	<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>es_direction</name></name> <operator>=</operator> <name>direction</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * If the plan might potentially be executed multiple times, we must force
	 * it to run without parallelism, because we might exit early.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>execute_once</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>use_parallel_mode</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>es_use_parallel_mode</name></name> <operator>=</operator> <name>use_parallel_mode</name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>use_parallel_mode</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>EnterParallelMode</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Loop until we've processed the proper number of tuples from the plan.
	 */</comment>
	<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
	<block>{<block_content>
		<comment type="block">/* Reset the per-output-tuple exprcontext */</comment>
		<expr_stmt><expr><call><name>ResetPerTupleExprContext</name><argument_list>(<argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Execute the plan and obtain a tuple
		 */</comment>
		<expr_stmt><expr><name>slot</name> <operator>=</operator> <call><name>ExecProcNode</name><argument_list>(<argument><expr><name>planstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * if the tuple is null, then we assume there is nothing more to
		 * process so we just end the loop...
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>TupIsNull</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * If we have a junk filter, then project a new tuple with the junk
		 * removed.
		 *
		 * Store this new "clean" tuple in the junkfilter's resultSlot.
		 * (Formerly, we stored it back over the "dirty" tuple, which is WRONG
		 * because that tuple slot has the wrong descriptor.)
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>estate</name><operator>-&gt;</operator><name>es_junkFilter</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>slot</name> <operator>=</operator> <call><name>ExecFilterJunk</name><argument_list>(<argument><expr><name><name>estate</name><operator>-&gt;</operator><name>es_junkFilter</name></name></expr></argument>, <argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * If we are supposed to send the tuple somewhere, do so. (In
		 * practice, this is probably always the case at this point.)
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>sendTuples</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * If we are not able to send the tuple, we assume the destination
			 * has closed and no more tuples can be sent. If that's the case,
			 * end the loop.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>dest</name><operator>-&gt;</operator><name>receiveSlot</name></name><argument_list>(<argument><expr><name>slot</name></expr></argument>, <argument><expr><name>dest</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<break>break;</break></block_content></block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * Count tuples processed, if this is a SELECT.  (For other operation
		 * types, the ModifyTable plan node must count the appropriate
		 * events.)
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>operation</name> <operator>==</operator> <name>CMD_SELECT</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><operator>(</operator><name><name>estate</name><operator>-&gt;</operator><name>es_processed</name></name><operator>)</operator><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * check our tuple count.. if we've processed the proper number then
		 * quit, else loop again and process more tuples.  Zero numberTuples
		 * means no limit.
		 */</comment>
		<expr_stmt><expr><name>current_tuple_count</name><operator>++</operator></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>numberTuples</name> <operator>&amp;&amp;</operator> <name>numberTuples</name> <operator>==</operator> <name>current_tuple_count</name></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>
	</block_content>}</block></for>

	<comment type="block">/*
	 * If we know we won't need to back up, we can release resources at this
	 * point.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name><name>estate</name><operator>-&gt;</operator><name>es_top_eflags</name></name> <operator>&amp;</operator> <name>EXEC_FLAG_BACKWARD</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>ExecShutdownNode</name><argument_list>(<argument><expr><name>planstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>use_parallel_mode</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ExitParallelMode</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * ExecRelCheck --- check that tuple meets constraints for result relation
 *
 * Returns NULL if OK, else name of failed check constraint
 */</comment>
<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>
<name>ExecRelCheck</name><parameter_list>(<parameter><decl><type><name>ResultRelInfo</name> <modifier>*</modifier></type><name>resultRelInfo</name></decl></parameter>,
			 <parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl></parameter>, <parameter><decl><type><name>EState</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>rel</name> <init>= <expr><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_RelationDesc</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>ncheck</name> <init>= <expr><name><name>rel</name><operator>-&gt;</operator><name>rd_att</name><operator>-&gt;</operator><name>constr</name><operator>-&gt;</operator><name>num_check</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ConstrCheck</name> <modifier>*</modifier></type><name>check</name> <init>= <expr><name><name>rel</name><operator>-&gt;</operator><name>rd_att</name><operator>-&gt;</operator><name>constr</name><operator>-&gt;</operator><name>check</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ExprContext</name> <modifier>*</modifier></type><name>econtext</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldContext</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * If first time through for this result relation, build expression
	 * nodetrees for rel's constraint expressions.  Keep them in the per-query
	 * memory context so they'll survive throughout the query.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_ConstraintExprs</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>oldContext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>estate</name><operator>-&gt;</operator><name>es_query_cxt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_ConstraintExprs</name></name> <operator>=</operator>
			<operator>(</operator><name>ExprState</name> <operator>*</operator><operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>ncheck</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ExprState</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>ncheck</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Expr</name>	   <modifier>*</modifier></type><name>checkconstr</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>checkconstr</name> <operator>=</operator> <call><name>stringToNode</name><argument_list>(<argument><expr><name><name>check</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>ccbin</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_ConstraintExprs</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator>
				<call><name>ExecPrepareExpr</name><argument_list>(<argument><expr><name>checkconstr</name></expr></argument>, <argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></for>
		<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * We will use the EState's per-tuple context for evaluating constraint
	 * expressions (creating it if it's not already there).
	 */</comment>
	<expr_stmt><expr><name>econtext</name> <operator>=</operator> <call><name>GetPerTupleExprContext</name><argument_list>(<argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Arrange for econtext's scan tuple to be the tuple under test */</comment>
	<expr_stmt><expr><name><name>econtext</name><operator>-&gt;</operator><name>ecxt_scantuple</name></name> <operator>=</operator> <name>slot</name></expr>;</expr_stmt>

	<comment type="block">/* And evaluate the constraints */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>ncheck</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ExprState</name>  <modifier>*</modifier></type><name>checkconstr</name> <init>= <expr><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_ConstraintExprs</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

		<comment type="block">/*
		 * NOTE: SQL specifies that a NULL result from a constraint expression
		 * is not to be treated as a failure.  Therefore, use ExecCheck not
		 * ExecQual.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ExecCheck</name><argument_list>(<argument><expr><name>checkconstr</name></expr></argument>, <argument><expr><name>econtext</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name><name>check</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>ccname</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></for>

	<comment type="block">/* NULL result means no error */</comment>
	<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * ExecPartitionCheck --- check that tuple meets the partition constraint.
 *
 * Returns true if it meets the partition constraint.  If the constraint
 * fails and we're asked to emit to error, do so and don't return; otherwise
 * return false.
 */</comment>
<function><type><name>bool</name></type>
<name>ExecPartitionCheck</name><parameter_list>(<parameter><decl><type><name>ResultRelInfo</name> <modifier>*</modifier></type><name>resultRelInfo</name></decl></parameter>, <parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl></parameter>,
				   <parameter><decl><type><name>EState</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>emitError</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ExprContext</name> <modifier>*</modifier></type><name>econtext</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>success</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * If first time through, build expression state tree for the partition
	 * check expression.  Keep it in the per-query memory context so they'll
	 * survive throughout the query.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_PartitionCheckExpr</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>qual</name> <init>= <expr><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_PartitionCheck</name></name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_PartitionCheckExpr</name></name> <operator>=</operator> <call><name>ExecPrepareCheck</name><argument_list>(<argument><expr><name>qual</name></expr></argument>, <argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * We will use the EState's per-tuple context for evaluating constraint
	 * expressions (creating it if it's not already there).
	 */</comment>
	<expr_stmt><expr><name>econtext</name> <operator>=</operator> <call><name>GetPerTupleExprContext</name><argument_list>(<argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Arrange for econtext's scan tuple to be the tuple under test */</comment>
	<expr_stmt><expr><name><name>econtext</name><operator>-&gt;</operator><name>ecxt_scantuple</name></name> <operator>=</operator> <name>slot</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * As in case of the catalogued constraints, we treat a NULL result as
	 * success here, not a failure.
	 */</comment>
	<expr_stmt><expr><name>success</name> <operator>=</operator> <call><name>ExecCheck</name><argument_list>(<argument><expr><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_PartitionCheckExpr</name></name></expr></argument>, <argument><expr><name>econtext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* if asked to emit error, don't actually return on failure */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>success</name> <operator>&amp;&amp;</operator> <name>emitError</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ExecPartitionCheckEmitError</name><argument_list>(<argument><expr><name>resultRelInfo</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>, <argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>success</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * ExecPartitionCheckEmitError - Form and emit an error message after a failed
 * partition constraint check.
 */</comment>
<function><type><name>void</name></type>
<name>ExecPartitionCheckEmitError</name><parameter_list>(<parameter><decl><type><name>ResultRelInfo</name> <modifier>*</modifier></type><name>resultRelInfo</name></decl></parameter>,
							<parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl></parameter>,
							<parameter><decl><type><name>EState</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>rel</name> <init>= <expr><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_RelationDesc</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>orig_rel</name> <init>= <expr><name>rel</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleDesc</name></type>	<name>tupdesc</name> <init>= <expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>val_desc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Bitmapset</name>  <modifier>*</modifier></type><name>modifiedCols</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Bitmapset</name>  <modifier>*</modifier></type><name>insertedCols</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Bitmapset</name>  <modifier>*</modifier></type><name>updatedCols</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Need to first convert the tuple to the root partitioned table's row
	 * type. For details, check similar comments in ExecConstraints().
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_PartitionRoot</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tuple</name> <init>= <expr><call><name>ExecFetchSlotTuple</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>TupleDesc</name></type>	<name>old_tupdesc</name> <init>= <expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>TupleConversionMap</name> <modifier>*</modifier></type><name>map</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>rel</name> <operator>=</operator> <name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_PartitionRoot</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>tupdesc</name> <operator>=</operator> <call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* a reverse map */</comment>
		<expr_stmt><expr><name>map</name> <operator>=</operator> <call><name>convert_tuples_by_name</name><argument_list>(<argument><expr><name>old_tupdesc</name></expr></argument>, <argument><expr><name>tupdesc</name></expr></argument>,
									 <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"could not convert row type"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>map</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>do_convert_tuple</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>, <argument><expr><name>map</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* one off slot for building error message */</comment>
			<expr_stmt><expr><name>slot</name> <operator>=</operator> <call><name>MakeTupleTableSlot</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>ExecStoreTuple</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>, <argument><expr><name>InvalidBuffer</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>insertedCols</name> <operator>=</operator> <call><name>GetInsertedColumns</name><argument_list>(<argument><expr><name>resultRelInfo</name></expr></argument>, <argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>updatedCols</name> <operator>=</operator> <call><name>GetUpdatedColumns</name><argument_list>(<argument><expr><name>resultRelInfo</name></expr></argument>, <argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>modifiedCols</name> <operator>=</operator> <call><name>bms_union</name><argument_list>(<argument><expr><name>insertedCols</name></expr></argument>, <argument><expr><name>updatedCols</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>val_desc</name> <operator>=</operator> <call><name>ExecBuildSlotValueDescription</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>,
											 <argument><expr><name>slot</name></expr></argument>,
											 <argument><expr><name>tupdesc</name></expr></argument>,
											 <argument><expr><name>modifiedCols</name></expr></argument>,
											 <argument><expr><literal type="number">64</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
			<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_CHECK_VIOLATION</name></expr></argument>)</argument_list></call><operator>,</operator>
			 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"new row for relation \"%s\" violates partition constraint"</literal></expr></argument>,
					<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>orig_rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
			 <ternary><condition><expr><name>val_desc</name></expr> ?</condition><then> <expr><call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Failing row contains %s."</literal></expr></argument>, <argument><expr><name>val_desc</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * ExecConstraints - check constraints of the tuple in 'slot'
 *
 * This checks the traditional NOT NULL and check constraints.
 *
 * The partition constraint is *NOT* checked.
 *
 * Note: 'slot' contains the tuple to check the constraints of, which may
 * have been converted from the original input tuple after tuple routing.
 * 'resultRelInfo' is the final result relation, after tuple routing.
 */</comment>
<function><type><name>void</name></type>
<name>ExecConstraints</name><parameter_list>(<parameter><decl><type><name>ResultRelInfo</name> <modifier>*</modifier></type><name>resultRelInfo</name></decl></parameter>,
				<parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl></parameter>, <parameter><decl><type><name>EState</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>rel</name> <init>= <expr><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_RelationDesc</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleDesc</name></type>	<name>tupdesc</name> <init>= <expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleConstr</name> <modifier>*</modifier></type><name>constr</name> <init>= <expr><name><name>tupdesc</name><operator>-&gt;</operator><name>constr</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Bitmapset</name>  <modifier>*</modifier></type><name>modifiedCols</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Bitmapset</name>  <modifier>*</modifier></type><name>insertedCols</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Bitmapset</name>  <modifier>*</modifier></type><name>updatedCols</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>constr</name> <operator>||</operator> <name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_PartitionCheck</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>constr</name> <operator>&amp;&amp;</operator> <name><name>constr</name><operator>-&gt;</operator><name>has_not_null</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>natts</name> <init>= <expr><name><name>tupdesc</name><operator>-&gt;</operator><name>natts</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>attrChk</name></decl>;</decl_stmt>

		<for>for <control>(<init><expr><name>attrChk</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>attrChk</name> <operator>&lt;=</operator> <name>natts</name></expr>;</condition> <incr><expr><name>attrChk</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>att</name> <init>= <expr><call><name>TupleDescAttr</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><name>attrChk</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>att</name><operator>-&gt;</operator><name>attnotnull</name></name> <operator>&amp;&amp;</operator> <call><name>slot_attisnull</name><argument_list>(<argument><expr><name>slot</name></expr></argument>, <argument><expr><name>attrChk</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>val_desc</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>Relation</name></type>	<name>orig_rel</name> <init>= <expr><name>rel</name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>TupleDesc</name></type>	<name>orig_tupdesc</name> <init>= <expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

				<comment type="block">/*
				 * If the tuple has been routed, it's been converted to the
				 * partition's rowtype, which might differ from the root
				 * table's.  We must convert it back to the root table's
				 * rowtype so that val_desc shown error message matches the
				 * input tuple.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_PartitionRoot</name></name></expr>)</condition>
				<block>{<block_content>
					<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tuple</name> <init>= <expr><call><name>ExecFetchSlotTuple</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>TupleConversionMap</name> <modifier>*</modifier></type><name>map</name></decl>;</decl_stmt>

					<expr_stmt><expr><name>rel</name> <operator>=</operator> <name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_PartitionRoot</name></name></expr>;</expr_stmt>
					<expr_stmt><expr><name>tupdesc</name> <operator>=</operator> <call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<comment type="block">/* a reverse map */</comment>
					<expr_stmt><expr><name>map</name> <operator>=</operator> <call><name>convert_tuples_by_name</name><argument_list>(<argument><expr><name>orig_tupdesc</name></expr></argument>, <argument><expr><name>tupdesc</name></expr></argument>,
												 <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"could not convert row type"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<if_stmt><if>if <condition>(<expr><name>map</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>do_convert_tuple</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>, <argument><expr><name>map</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<comment type="block">/* one off slot for building error message */</comment>
						<expr_stmt><expr><name>slot</name> <operator>=</operator> <call><name>MakeTupleTableSlot</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><call><name>ExecStoreTuple</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>, <argument><expr><name>InvalidBuffer</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block></if></if_stmt>
				</block_content>}</block></if></if_stmt>

				<expr_stmt><expr><name>insertedCols</name> <operator>=</operator> <call><name>GetInsertedColumns</name><argument_list>(<argument><expr><name>resultRelInfo</name></expr></argument>, <argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>updatedCols</name> <operator>=</operator> <call><name>GetUpdatedColumns</name><argument_list>(<argument><expr><name>resultRelInfo</name></expr></argument>, <argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>modifiedCols</name> <operator>=</operator> <call><name>bms_union</name><argument_list>(<argument><expr><name>insertedCols</name></expr></argument>, <argument><expr><name>updatedCols</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>val_desc</name> <operator>=</operator> <call><name>ExecBuildSlotValueDescription</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>,
														 <argument><expr><name>slot</name></expr></argument>,
														 <argument><expr><name>tupdesc</name></expr></argument>,
														 <argument><expr><name>modifiedCols</name></expr></argument>,
														 <argument><expr><literal type="number">64</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_NOT_NULL_VIOLATION</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"null value in column \"%s\" violates not-null constraint"</literal></expr></argument>,
								<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>att</name><operator>-&gt;</operator><name>attname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
						 <ternary><condition><expr><name>val_desc</name></expr> ?</condition><then> <expr><call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Failing row contains %s."</literal></expr></argument>, <argument><expr><name>val_desc</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>,</operator>
						 <call><name>errtablecol</name><argument_list>(<argument><expr><name>orig_rel</name></expr></argument>, <argument><expr><name>attrChk</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></for>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>constr</name> <operator>&amp;&amp;</operator> <name><name>constr</name><operator>-&gt;</operator><name>num_check</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>failed</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><operator>(</operator><name>failed</name> <operator>=</operator> <call><name>ExecRelCheck</name><argument_list>(<argument><expr><name>resultRelInfo</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>, <argument><expr><name>estate</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>val_desc</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Relation</name></type>	<name>orig_rel</name> <init>= <expr><name>rel</name></expr></init></decl>;</decl_stmt>

			<comment type="block">/* See the comment above. */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_PartitionRoot</name></name></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tuple</name> <init>= <expr><call><name>ExecFetchSlotTuple</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>TupleDesc</name></type>	<name>old_tupdesc</name> <init>= <expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>TupleConversionMap</name> <modifier>*</modifier></type><name>map</name></decl>;</decl_stmt>

				<expr_stmt><expr><name>rel</name> <operator>=</operator> <name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_PartitionRoot</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><name>tupdesc</name> <operator>=</operator> <call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<comment type="block">/* a reverse map */</comment>
				<expr_stmt><expr><name>map</name> <operator>=</operator> <call><name>convert_tuples_by_name</name><argument_list>(<argument><expr><name>old_tupdesc</name></expr></argument>, <argument><expr><name>tupdesc</name></expr></argument>,
											 <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"could not convert row type"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name>map</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>do_convert_tuple</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>, <argument><expr><name>map</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<comment type="block">/* one off slot for building error message */</comment>
					<expr_stmt><expr><name>slot</name> <operator>=</operator> <call><name>MakeTupleTableSlot</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>ExecStoreTuple</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>, <argument><expr><name>InvalidBuffer</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></if></if_stmt>

			<expr_stmt><expr><name>insertedCols</name> <operator>=</operator> <call><name>GetInsertedColumns</name><argument_list>(<argument><expr><name>resultRelInfo</name></expr></argument>, <argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>updatedCols</name> <operator>=</operator> <call><name>GetUpdatedColumns</name><argument_list>(<argument><expr><name>resultRelInfo</name></expr></argument>, <argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>modifiedCols</name> <operator>=</operator> <call><name>bms_union</name><argument_list>(<argument><expr><name>insertedCols</name></expr></argument>, <argument><expr><name>updatedCols</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>val_desc</name> <operator>=</operator> <call><name>ExecBuildSlotValueDescription</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>,
													 <argument><expr><name>slot</name></expr></argument>,
													 <argument><expr><name>tupdesc</name></expr></argument>,
													 <argument><expr><name>modifiedCols</name></expr></argument>,
													 <argument><expr><literal type="number">64</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_CHECK_VIOLATION</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"new row for relation \"%s\" violates check constraint \"%s\""</literal></expr></argument>,
							<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>orig_rel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>failed</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <ternary><condition><expr><name>val_desc</name></expr> ?</condition><then> <expr><call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Failing row contains %s."</literal></expr></argument>, <argument><expr><name>val_desc</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>,</operator>
					 <call><name>errtableconstraint</name><argument_list>(<argument><expr><name>orig_rel</name></expr></argument>, <argument><expr><name>failed</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * ExecWithCheckOptions -- check that tuple satisfies any WITH CHECK OPTIONs
 * of the specified kind.
 *
 * Note that this needs to be called multiple times to ensure that all kinds of
 * WITH CHECK OPTIONs are handled (both those from views which have the WITH
 * CHECK OPTION set and from row level security policies).  See ExecInsert()
 * and ExecUpdate().
 */</comment>
<function><type><name>void</name></type>
<name>ExecWithCheckOptions</name><parameter_list>(<parameter><decl><type><name>WCOKind</name></type> <name>kind</name></decl></parameter>, <parameter><decl><type><name>ResultRelInfo</name> <modifier>*</modifier></type><name>resultRelInfo</name></decl></parameter>,
					 <parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl></parameter>, <parameter><decl><type><name>EState</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>rel</name> <init>= <expr><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_RelationDesc</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleDesc</name></type>	<name>tupdesc</name> <init>= <expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ExprContext</name> <modifier>*</modifier></type><name>econtext</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l1</name></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name>l2</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * We will use the EState's per-tuple context for evaluating constraint
	 * expressions (creating it if it's not already there).
	 */</comment>
	<expr_stmt><expr><name>econtext</name> <operator>=</operator> <call><name>GetPerTupleExprContext</name><argument_list>(<argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Arrange for econtext's scan tuple to be the tuple under test */</comment>
	<expr_stmt><expr><name><name>econtext</name><operator>-&gt;</operator><name>ecxt_scantuple</name></name> <operator>=</operator> <name>slot</name></expr>;</expr_stmt>

	<comment type="block">/* Check each of the constraints */</comment>
	<macro><name>forboth</name><argument_list>(<argument>l1</argument>, <argument>resultRelInfo-&gt;ri_WithCheckOptions</argument>,
			<argument>l2</argument>, <argument>resultRelInfo-&gt;ri_WithCheckOptionExprs</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>WithCheckOption</name> <modifier>*</modifier></type><name>wco</name> <init>= <expr><operator>(</operator><name>WithCheckOption</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l1</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ExprState</name>  <modifier>*</modifier></type><name>wcoExpr</name> <init>= <expr><operator>(</operator><name>ExprState</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l2</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/*
		 * Skip any WCOs which are not the kind we are looking for at this
		 * time.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>wco</name><operator>-&gt;</operator><name>kind</name></name> <operator>!=</operator> <name>kind</name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * WITH CHECK OPTION checks are intended to ensure that the new tuple
		 * is visible (in the case of a view) or that it passes the
		 * 'with-check' policy (in the case of row security). If the qual
		 * evaluates to NULL or FALSE, then the new tuple won't be included in
		 * the view or doesn't pass the 'with-check' policy for the table.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ExecQual</name><argument_list>(<argument><expr><name>wcoExpr</name></expr></argument>, <argument><expr><name>econtext</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>val_desc</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Bitmapset</name>  <modifier>*</modifier></type><name>modifiedCols</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Bitmapset</name>  <modifier>*</modifier></type><name>insertedCols</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Bitmapset</name>  <modifier>*</modifier></type><name>updatedCols</name></decl>;</decl_stmt>

			<switch>switch <condition>(<expr><name><name>wco</name><operator>-&gt;</operator><name>kind</name></name></expr>)</condition>
			<block>{<block_content>
					<comment type="block">/*
					 * For WITH CHECK OPTIONs coming from views, we might be
					 * able to provide the details on the row, depending on
					 * the permissions on the relation (that is, if the user
					 * could view it directly anyway).  For RLS violations, we
					 * don't include the data since we don't know if the user
					 * should be able to view the tuple as that depends on the
					 * USING policy.
					 */</comment>
				<case>case <expr><name>WCO_VIEW_CHECK</name></expr>:</case>
					<comment type="block">/* See the comment in ExecConstraints(). */</comment>
					<if_stmt><if>if <condition>(<expr><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_PartitionRoot</name></name></expr>)</condition>
					<block>{<block_content>
						<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tuple</name> <init>= <expr><call><name>ExecFetchSlotTuple</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
						<decl_stmt><decl><type><name>TupleDesc</name></type>	<name>old_tupdesc</name> <init>= <expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
						<decl_stmt><decl><type><name>TupleConversionMap</name> <modifier>*</modifier></type><name>map</name></decl>;</decl_stmt>

						<expr_stmt><expr><name>rel</name> <operator>=</operator> <name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_PartitionRoot</name></name></expr>;</expr_stmt>
						<expr_stmt><expr><name>tupdesc</name> <operator>=</operator> <call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<comment type="block">/* a reverse map */</comment>
						<expr_stmt><expr><name>map</name> <operator>=</operator> <call><name>convert_tuples_by_name</name><argument_list>(<argument><expr><name>old_tupdesc</name></expr></argument>, <argument><expr><name>tupdesc</name></expr></argument>,
													 <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"could not convert row type"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<if_stmt><if>if <condition>(<expr><name>map</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
						<block>{<block_content>
							<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>do_convert_tuple</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>, <argument><expr><name>map</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							<comment type="block">/* one off slot for building error message */</comment>
							<expr_stmt><expr><name>slot</name> <operator>=</operator> <call><name>MakeTupleTableSlot</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							<expr_stmt><expr><call><name>ExecStoreTuple</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>, <argument><expr><name>InvalidBuffer</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						</block_content>}</block></if></if_stmt>
					</block_content>}</block></if></if_stmt>

					<expr_stmt><expr><name>insertedCols</name> <operator>=</operator> <call><name>GetInsertedColumns</name><argument_list>(<argument><expr><name>resultRelInfo</name></expr></argument>, <argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>updatedCols</name> <operator>=</operator> <call><name>GetUpdatedColumns</name><argument_list>(<argument><expr><name>resultRelInfo</name></expr></argument>, <argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>modifiedCols</name> <operator>=</operator> <call><name>bms_union</name><argument_list>(<argument><expr><name>insertedCols</name></expr></argument>, <argument><expr><name>updatedCols</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>val_desc</name> <operator>=</operator> <call><name>ExecBuildSlotValueDescription</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>,
															 <argument><expr><name>slot</name></expr></argument>,
															 <argument><expr><name>tupdesc</name></expr></argument>,
															 <argument><expr><name>modifiedCols</name></expr></argument>,
															 <argument><expr><literal type="number">64</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WITH_CHECK_OPTION_VIOLATION</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"new row violates check option for view \"%s\""</literal></expr></argument>,
									<argument><expr><name><name>wco</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>)</argument_list></call><operator>,</operator>
							 <ternary><condition><expr><name>val_desc</name></expr> ?</condition><then> <expr><call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Failing row contains %s."</literal></expr></argument>,
												  <argument><expr><name>val_desc</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<break>break;</break>
				<case>case <expr><name>WCO_RLS_INSERT_CHECK</name></expr>:</case>
				<case>case <expr><name>WCO_RLS_UPDATE_CHECK</name></expr>:</case>
					<if_stmt><if>if <condition>(<expr><name><name>wco</name><operator>-&gt;</operator><name>polname</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
								<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INSUFFICIENT_PRIVILEGE</name></expr></argument>)</argument_list></call><operator>,</operator>
								 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"new row violates row-level security policy \"%s\" for table \"%s\""</literal></expr></argument>,
										<argument><expr><name><name>wco</name><operator>-&gt;</operator><name>polname</name></name></expr></argument>, <argument><expr><name><name>wco</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
					<else>else<block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
								<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INSUFFICIENT_PRIVILEGE</name></expr></argument>)</argument_list></call><operator>,</operator>
								 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"new row violates row-level security policy for table \"%s\""</literal></expr></argument>,
										<argument><expr><name><name>wco</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
					<break>break;</break>
				<case>case <expr><name>WCO_RLS_CONFLICT_CHECK</name></expr>:</case>
					<if_stmt><if>if <condition>(<expr><name><name>wco</name><operator>-&gt;</operator><name>polname</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
								<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INSUFFICIENT_PRIVILEGE</name></expr></argument>)</argument_list></call><operator>,</operator>
								 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"new row violates row-level security policy \"%s\" (USING expression) for table \"%s\""</literal></expr></argument>,
										<argument><expr><name><name>wco</name><operator>-&gt;</operator><name>polname</name></name></expr></argument>, <argument><expr><name><name>wco</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
					<else>else<block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
								<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INSUFFICIENT_PRIVILEGE</name></expr></argument>)</argument_list></call><operator>,</operator>
								 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"new row violates row-level security policy (USING expression) for table \"%s\""</literal></expr></argument>,
										<argument><expr><name><name>wco</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
					<break>break;</break>
				<default>default:</default>
					<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized WCO kind: %u"</literal></expr></argument>, <argument><expr><name><name>wco</name><operator>-&gt;</operator><name>kind</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<break>break;</break>
			</block_content>}</block></switch>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>
</block_content>}</block></function>

<comment type="block">/*
 * ExecBuildSlotValueDescription -- construct a string representing a tuple
 *
 * This is intentionally very similar to BuildIndexValueDescription, but
 * unlike that function, we truncate long field values (to at most maxfieldlen
 * bytes).  That seems necessary here since heap field values could be very
 * long, whereas index entries typically aren't so wide.
 *
 * Also, unlike the case with index entries, we need to be prepared to ignore
 * dropped columns.  We used to use the slot's tuple descriptor to decode the
 * data, but the slot's descriptor doesn't identify dropped columns, so we
 * now need to be passed the relation's descriptor.
 *
 * Note that, like BuildIndexValueDescription, if the user does not have
 * permission to view any of the columns involved, a NULL is returned.  Unlike
 * BuildIndexValueDescription, if the user has access to view a subset of the
 * column involved, that subset will be returned with a key identifying which
 * columns they are.
 */</comment>
<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type>
<name>ExecBuildSlotValueDescription</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>reloid</name></decl></parameter>,
							  <parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl></parameter>,
							  <parameter><decl><type><name>TupleDesc</name></type> <name>tupdesc</name></decl></parameter>,
							  <parameter><decl><type><name>Bitmapset</name> <modifier>*</modifier></type><name>modifiedCols</name></decl></parameter>,
							  <parameter><decl><type><name>int</name></type> <name>maxfieldlen</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>StringInfoData</name></type> <name>buf</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>StringInfoData</name></type> <name>collist</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>write_comma</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>write_comma_collist</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AclResult</name></type>	<name>aclresult</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>table_perm</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>any_perm</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * Check if RLS is enabled and should be active for the relation; if so,
	 * then don't return anything.  Otherwise, go through normal permission
	 * checks.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>check_enable_rls</name><argument_list>(<argument><expr><name>reloid</name></expr></argument>, <argument><expr><name>InvalidOid</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>RLS_ENABLED</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>initStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="char">'('</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Check if the user has permissions to see the row.  Table-level SELECT
	 * allows access to all columns.  If the user does not have table-level
	 * SELECT then we check each column and include those the user has SELECT
	 * rights on.  Additionally, we always include columns the user provided
	 * data for.
	 */</comment>
	<expr_stmt><expr><name>aclresult</name> <operator>=</operator> <call><name>pg_class_aclcheck</name><argument_list>(<argument><expr><name>reloid</name></expr></argument>, <argument><expr><call><name>GetUserId</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>ACL_SELECT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>aclresult</name> <operator>!=</operator> <name>ACLCHECK_OK</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Set up the buffer for the column list */</comment>
		<expr_stmt><expr><call><name>initStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>collist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><operator>&amp;</operator><name>collist</name></expr></argument>, <argument><expr><literal type="char">'('</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>table_perm</name> <operator>=</operator> <name>any_perm</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/* Make sure the tuple is fully deconstructed */</comment>
	<expr_stmt><expr><call><name>slot_getallattrs</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>tupdesc</name><operator>-&gt;</operator><name>natts</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>bool</name></type>		<name>column_perm</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>val</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>vallen</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>att</name> <init>= <expr><call><name>TupleDescAttr</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/* ignore dropped columns */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>att</name><operator>-&gt;</operator><name>attisdropped</name></name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>table_perm</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * No table-level SELECT, so need to make sure they either have
			 * SELECT rights on the column or that they have provided the data
			 * for the column.  If not, omit this column from the error
			 * message.
			 */</comment>
			<expr_stmt><expr><name>aclresult</name> <operator>=</operator> <call><name>pg_attribute_aclcheck</name><argument_list>(<argument><expr><name>reloid</name></expr></argument>, <argument><expr><name><name>att</name><operator>-&gt;</operator><name>attnum</name></name></expr></argument>,
											  <argument><expr><call><name>GetUserId</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>ACL_SELECT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><call><name>bms_is_member</name><argument_list>(<argument><expr><name><name>att</name><operator>-&gt;</operator><name>attnum</name></name> <operator>-</operator> <name>FirstLowInvalidHeapAttributeNumber</name></expr></argument>,
							  <argument><expr><name>modifiedCols</name></expr></argument>)</argument_list></call> <operator>||</operator> <name>aclresult</name> <operator>==</operator> <name>ACLCHECK_OK</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>column_perm</name> <operator>=</operator> <name>any_perm</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

				<if_stmt><if>if <condition>(<expr><name>write_comma_collist</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>collist</name></expr></argument>, <argument><expr><literal type="string">", "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><name>write_comma_collist</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

				<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>collist</name></expr></argument>, <argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>att</name><operator>-&gt;</operator><name>attname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>table_perm</name> <operator>||</operator> <name>column_perm</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name><name>slot</name><operator>-&gt;</operator><name>tts_isnull</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>val</name> <operator>=</operator> <literal type="string">"null"</literal></expr>;</expr_stmt></block_content></block></if>
			<else>else
			<block>{<block_content>
				<decl_stmt><decl><type><name>Oid</name></type>			<name>foutoid</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>bool</name></type>		<name>typisvarlena</name></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>getTypeOutputInfo</name><argument_list>(<argument><expr><name><name>att</name><operator>-&gt;</operator><name>atttypid</name></name></expr></argument>,
								  <argument><expr><operator>&amp;</operator><name>foutoid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>typisvarlena</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>val</name> <operator>=</operator> <call><name>OidOutputFunctionCall</name><argument_list>(<argument><expr><name>foutoid</name></expr></argument>, <argument><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_values</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>

			<if_stmt><if>if <condition>(<expr><name>write_comma</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">", "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name>write_comma</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

			<comment type="block">/* truncate if needed */</comment>
			<expr_stmt><expr><name>vallen</name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>vallen</name> <operator>&lt;=</operator> <name>maxfieldlen</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else
			<block>{<block_content>
				<expr_stmt><expr><name>vallen</name> <operator>=</operator> <call><name>pg_mbcliplen</name><argument_list>(<argument><expr><name>val</name></expr></argument>, <argument><expr><name>vallen</name></expr></argument>, <argument><expr><name>maxfieldlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>appendBinaryStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name>val</name></expr></argument>, <argument><expr><name>vallen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"..."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>

	<comment type="block">/* If we end up with zero columns being returned, then return NULL. */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>any_perm</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="char">')'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>table_perm</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>collist</name></expr></argument>, <argument><expr><literal type="string">") = "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>collist</name></expr></argument>, <argument><expr><name><name>buf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<return>return <expr><name><name>collist</name><operator>.</operator><name>data</name></name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name><name>buf</name><operator>.</operator><name>data</name></name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * ExecUpdateLockMode -- find the appropriate UPDATE tuple lock mode for a
 * given ResultRelInfo
 */</comment>
<function><type><name>LockTupleMode</name></type>
<name>ExecUpdateLockMode</name><parameter_list>(<parameter><decl><type><name>EState</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>, <parameter><decl><type><name>ResultRelInfo</name> <modifier>*</modifier></type><name>relinfo</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Bitmapset</name>  <modifier>*</modifier></type><name>keyCols</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Bitmapset</name>  <modifier>*</modifier></type><name>updatedCols</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Compute lock mode to use.  If columns that are part of the key have not
	 * been modified, then we can use a weaker lock, allowing for better
	 * concurrency.
	 */</comment>
	<expr_stmt><expr><name>updatedCols</name> <operator>=</operator> <call><name>GetUpdatedColumns</name><argument_list>(<argument><expr><name>relinfo</name></expr></argument>, <argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>keyCols</name> <operator>=</operator> <call><name>RelationGetIndexAttrBitmap</name><argument_list>(<argument><expr><name><name>relinfo</name><operator>-&gt;</operator><name>ri_RelationDesc</name></name></expr></argument>,
										 <argument><expr><name>INDEX_ATTR_BITMAP_KEY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>bms_overlap</name><argument_list>(<argument><expr><name>keyCols</name></expr></argument>, <argument><expr><name>updatedCols</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>LockTupleExclusive</name></expr>;</return></block_content></block></if></if_stmt>

	<return>return <expr><name>LockTupleNoKeyExclusive</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * ExecFindRowMark -- find the ExecRowMark struct for given rangetable index
 *
 * If no such struct, either return NULL or throw error depending on missing_ok
 */</comment>
<function><type><name>ExecRowMark</name> <modifier>*</modifier></type>
<name>ExecFindRowMark</name><parameter_list>(<parameter><decl><type><name>EState</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>, <parameter><decl><type><name>Index</name></type> <name>rti</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>missing_ok</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>estate-&gt;es_rowMarks</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ExecRowMark</name> <modifier>*</modifier></type><name>erm</name> <init>= <expr><operator>(</operator><name>ExecRowMark</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>erm</name><operator>-&gt;</operator><name>rti</name></name> <operator>==</operator> <name>rti</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>erm</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>missing_ok</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"failed to find ExecRowMark for rangetable index %u"</literal></expr></argument>, <argument><expr><name>rti</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * ExecBuildAuxRowMark -- create an ExecAuxRowMark struct
 *
 * Inputs are the underlying ExecRowMark struct and the targetlist of the
 * input plan node (not planstate node!).  We need the latter to find out
 * the column numbers of the resjunk columns.
 */</comment>
<function><type><name>ExecAuxRowMark</name> <modifier>*</modifier></type>
<name>ExecBuildAuxRowMark</name><parameter_list>(<parameter><decl><type><name>ExecRowMark</name> <modifier>*</modifier></type><name>erm</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>targetlist</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ExecAuxRowMark</name> <modifier>*</modifier></type><name>aerm</name> <init>= <expr><operator>(</operator><name>ExecAuxRowMark</name> <operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ExecAuxRowMark</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>resname</name><index>[<expr><literal type="number">32</literal></expr>]</index></name></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>aerm</name><operator>-&gt;</operator><name>rowmark</name></name> <operator>=</operator> <name>erm</name></expr>;</expr_stmt>

	<comment type="block">/* Look up the resjunk columns associated with this rowmark */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>erm</name><operator>-&gt;</operator><name>markType</name></name> <operator>!=</operator> <name>ROW_MARK_COPY</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* need ctid for all methods other than COPY */</comment>
		<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>resname</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>resname</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"ctid%u"</literal></expr></argument>, <argument><expr><name><name>erm</name><operator>-&gt;</operator><name>rowmarkId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>aerm</name><operator>-&gt;</operator><name>ctidAttNo</name></name> <operator>=</operator> <call><name>ExecFindJunkAttributeInTlist</name><argument_list>(<argument><expr><name>targetlist</name></expr></argument>,
													   <argument><expr><name>resname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>AttributeNumberIsValid</name><argument_list>(<argument><expr><name><name>aerm</name><operator>-&gt;</operator><name>ctidAttNo</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"could not find junk %s column"</literal></expr></argument>, <argument><expr><name>resname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* need wholerow if COPY */</comment>
		<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>resname</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>resname</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"wholerow%u"</literal></expr></argument>, <argument><expr><name><name>erm</name><operator>-&gt;</operator><name>rowmarkId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>aerm</name><operator>-&gt;</operator><name>wholeAttNo</name></name> <operator>=</operator> <call><name>ExecFindJunkAttributeInTlist</name><argument_list>(<argument><expr><name>targetlist</name></expr></argument>,
														<argument><expr><name>resname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>AttributeNumberIsValid</name><argument_list>(<argument><expr><name><name>aerm</name><operator>-&gt;</operator><name>wholeAttNo</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"could not find junk %s column"</literal></expr></argument>, <argument><expr><name>resname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/* if child rel, need tableoid */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>erm</name><operator>-&gt;</operator><name>rti</name></name> <operator>!=</operator> <name><name>erm</name><operator>-&gt;</operator><name>prti</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>resname</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>resname</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"tableoid%u"</literal></expr></argument>, <argument><expr><name><name>erm</name><operator>-&gt;</operator><name>rowmarkId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>aerm</name><operator>-&gt;</operator><name>toidAttNo</name></name> <operator>=</operator> <call><name>ExecFindJunkAttributeInTlist</name><argument_list>(<argument><expr><name>targetlist</name></expr></argument>,
													   <argument><expr><name>resname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>AttributeNumberIsValid</name><argument_list>(<argument><expr><name><name>aerm</name><operator>-&gt;</operator><name>toidAttNo</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"could not find junk %s column"</literal></expr></argument>, <argument><expr><name>resname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>aerm</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * EvalPlanQual logic --- recheck modified tuple(s) to see if we want to
 * process the updated version under READ COMMITTED rules.
 *
 * See backend/executor/README for some info about how this works.
 */</comment>


<comment type="block">/*
 * Check a modified tuple to see if we want to process its updated version
 * under READ COMMITTED rules.
 *
 *	estate - outer executor state data
 *	epqstate - state for EvalPlanQual rechecking
 *	relation - table containing tuple
 *	rti - rangetable index of table containing tuple
 *	lockmode - requested tuple lock mode
 *	*tid - t_ctid from the outdated tuple (ie, next updated version)
 *	priorXmax - t_xmax from the outdated tuple
 *
 * *tid is also an output parameter: it's modified to hold the TID of the
 * latest version of the tuple (note this may be changed even on failure)
 *
 * Returns a slot containing the new candidate update/delete tuple, or
 * NULL if we determine we shouldn't process the row.
 *
 * Note: properly, lockmode should be declared as enum LockTupleMode,
 * but we use "int" to avoid having to include heapam.h in executor.h.
 */</comment>
<function><type><name>TupleTableSlot</name> <modifier>*</modifier></type>
<name>EvalPlanQual</name><parameter_list>(<parameter><decl><type><name>EState</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>, <parameter><decl><type><name>EPQState</name> <modifier>*</modifier></type><name>epqstate</name></decl></parameter>,
			 <parameter><decl><type><name>Relation</name></type> <name>relation</name></decl></parameter>, <parameter><decl><type><name>Index</name></type> <name>rti</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>lockmode</name></decl></parameter>,
			 <parameter><decl><type><name>ItemPointer</name></type> <name>tid</name></decl></parameter>, <parameter><decl><type><name>TransactionId</name></type> <name>priorXmax</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>copyTuple</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>rti</name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Get and lock the updated version of the row; if fail, return NULL.
	 */</comment>
	<expr_stmt><expr><name>copyTuple</name> <operator>=</operator> <call><name>EvalPlanQualFetch</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name>relation</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>, <argument><expr><name>LockWaitBlock</name></expr></argument>,
								  <argument><expr><name>tid</name></expr></argument>, <argument><expr><name>priorXmax</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>copyTuple</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * For UPDATE/DELETE we have to return tid of actual row we're executing
	 * PQ for.
	 */</comment>
	<expr_stmt><expr><operator>*</operator><name>tid</name> <operator>=</operator> <name><name>copyTuple</name><operator>-&gt;</operator><name>t_self</name></name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Need to run a recheck subquery.  Initialize or reinitialize EPQ state.
	 */</comment>
	<expr_stmt><expr><call><name>EvalPlanQualBegin</name><argument_list>(<argument><expr><name>epqstate</name></expr></argument>, <argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Free old test tuple, if any, and store new tuple where relation's scan
	 * node will see it
	 */</comment>
	<expr_stmt><expr><call><name>EvalPlanQualSetTuple</name><argument_list>(<argument><expr><name>epqstate</name></expr></argument>, <argument><expr><name>rti</name></expr></argument>, <argument><expr><name>copyTuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Fetch any non-locked source rows
	 */</comment>
	<expr_stmt><expr><call><name>EvalPlanQualFetchRowMarks</name><argument_list>(<argument><expr><name>epqstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Run the EPQ query.  We assume it will return at most one tuple.
	 */</comment>
	<expr_stmt><expr><name>slot</name> <operator>=</operator> <call><name>EvalPlanQualNext</name><argument_list>(<argument><expr><name>epqstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If we got a tuple, force the slot to materialize the tuple so that it
	 * is not dependent on any local state in the EPQ query (in particular,
	 * it's highly likely that the slot contains references to any pass-by-ref
	 * datums that may be present in copyTuple).  As with the next step, this
	 * is to guard against early re-use of the EPQ query.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>TupIsNull</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>ExecMaterializeSlot</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Clear out the test tuple.  This is needed in case the EPQ query is
	 * re-used to test a tuple for a different relation.  (Not clear that can
	 * really happen, but let's be safe.)
	 */</comment>
	<expr_stmt><expr><call><name>EvalPlanQualSetTuple</name><argument_list>(<argument><expr><name>epqstate</name></expr></argument>, <argument><expr><name>rti</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>slot</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Fetch a copy of the newest version of an outdated tuple
 *
 *	estate - executor state data
 *	relation - table containing tuple
 *	lockmode - requested tuple lock mode
 *	wait_policy - requested lock wait policy
 *	*tid - t_ctid from the outdated tuple (ie, next updated version)
 *	priorXmax - t_xmax from the outdated tuple
 *
 * Returns a palloc'd copy of the newest tuple version, or NULL if we find
 * that there is no newest version (ie, the row was deleted not updated).
 * We also return NULL if the tuple is locked and the wait policy is to skip
 * such tuples.
 *
 * If successful, we have locked the newest tuple version, so caller does not
 * need to worry about it changing anymore.
 *
 * Note: properly, lockmode should be declared as enum LockTupleMode,
 * but we use "int" to avoid having to include heapam.h in executor.h.
 */</comment>
<function><type><name>HeapTuple</name></type>
<name>EvalPlanQualFetch</name><parameter_list>(<parameter><decl><type><name>EState</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>relation</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>lockmode</name></decl></parameter>,
				  <parameter><decl><type><name>LockWaitPolicy</name></type> <name>wait_policy</name></decl></parameter>,
				  <parameter><decl><type><name>ItemPointer</name></type> <name>tid</name></decl></parameter>, <parameter><decl><type><name>TransactionId</name></type> <name>priorXmax</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>copyTuple</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTupleData</name></type> <name>tuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SnapshotData</name></type> <name>SnapshotDirty</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * fetch target tuple
	 *
	 * Loop here to deal with updated or busy tuples
	 */</comment>
	<expr_stmt><expr><call><name>InitDirtySnapshot</name><argument_list>(<argument><expr><name>SnapshotDirty</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>tuple</name><operator>.</operator><name>t_self</name></name> <operator>=</operator> <operator>*</operator><name>tid</name></expr>;</expr_stmt>
	<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Buffer</name></type>		<name>buffer</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>heap_fetch</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>SnapshotDirty</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tuple</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>HTSU_Result</name></type> <name>test</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>HeapUpdateFailureData</name></type> <name>hufd</name></decl>;</decl_stmt>

			<comment type="block">/*
			 * If xmin isn't what we're expecting, the slot must have been
			 * recycled and reused for an unrelated tuple.  This implies that
			 * the latest version of the row was deleted, so we need do
			 * nothing.  (Should be safe to examine xmin without getting
			 * buffer's content lock.  We assume reading a TransactionId to be
			 * atomic, and Xmin never changes in an existing tuple, except to
			 * invalid or frozen, and neither of those can match priorXmax.)
			 */</comment>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>TransactionIdEquals</name><argument_list>(<argument><expr><call><name>HeapTupleHeaderGetXmin</name><argument_list>(<argument><expr><name><name>tuple</name><operator>.</operator><name>t_data</name></name></expr></argument>)</argument_list></call></expr></argument>,
									 <argument><expr><name>priorXmax</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>ReleaseBuffer</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr><name>NULL</name></expr>;</return>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/* otherwise xmin should not be dirty... */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>TransactionIdIsValid</name><argument_list>(<argument><expr><name><name>SnapshotDirty</name><operator>.</operator><name>xmin</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"t_xmin is uncommitted in tuple to be updated"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<comment type="block">/*
			 * If tuple is being updated by other transaction then we have to
			 * wait for its commit/abort, or die trying.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>TransactionIdIsValid</name><argument_list>(<argument><expr><name><name>SnapshotDirty</name><operator>.</operator><name>xmax</name></name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>ReleaseBuffer</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<switch>switch <condition>(<expr><name>wait_policy</name></expr>)</condition>
				<block>{<block_content>
					<case>case <expr><name>LockWaitBlock</name></expr>:</case>
						<expr_stmt><expr><call><name>XactLockTableWait</name><argument_list>(<argument><expr><name><name>SnapshotDirty</name><operator>.</operator><name>xmax</name></name></expr></argument>,
										  <argument><expr><name>relation</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>tuple</name><operator>.</operator><name>t_self</name></name></expr></argument>,
										  <argument><expr><name>XLTW_FetchUpdated</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<break>break;</break>
					<case>case <expr><name>LockWaitSkip</name></expr>:</case>
						<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ConditionalXactLockTableWait</name><argument_list>(<argument><expr><name><name>SnapshotDirty</name><operator>.</operator><name>xmax</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
							<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>	<comment type="block">/* skip instead of waiting */</comment>
						<break>break;</break>
					<case>case <expr><name>LockWaitError</name></expr>:</case>
						<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ConditionalXactLockTableWait</name><argument_list>(<argument><expr><name><name>SnapshotDirty</name><operator>.</operator><name>xmax</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
							<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
									<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_LOCK_NOT_AVAILABLE</name></expr></argument>)</argument_list></call><operator>,</operator>
									 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not obtain lock on row in relation \"%s\""</literal></expr></argument>,
											<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
						<break>break;</break>
				</block_content>}</block></switch>
				<continue>continue;</continue>		<comment type="block">/* loop back to repeat heap_fetch */</comment>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/*
			 * If tuple was inserted by our own transaction, we have to check
			 * cmin against es_output_cid: cmin &gt;= current CID means our
			 * command cannot see the tuple, so we should ignore it. Otherwise
			 * heap_lock_tuple() will throw an error, and so would any later
			 * attempt to update or delete the tuple.  (We need not check cmax
			 * because HeapTupleSatisfiesDirty will consider a tuple deleted
			 * by our transaction dead, regardless of cmax.) We just checked
			 * that priorXmax == xmin, so we can test that variable instead of
			 * doing HeapTupleHeaderGetXmin again.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>TransactionIdIsCurrentTransactionId</name><argument_list>(<argument><expr><name>priorXmax</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
				<call><name>HeapTupleHeaderGetCmin</name><argument_list>(<argument><expr><name><name>tuple</name><operator>.</operator><name>t_data</name></name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <name><name>estate</name><operator>-&gt;</operator><name>es_output_cid</name></name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>ReleaseBuffer</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr><name>NULL</name></expr>;</return>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/*
			 * This is a live tuple, so now try to lock it.
			 */</comment>
			<expr_stmt><expr><name>test</name> <operator>=</operator> <call><name>heap_lock_tuple</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tuple</name></expr></argument>,
								   <argument><expr><name><name>estate</name><operator>-&gt;</operator><name>es_output_cid</name></name></expr></argument>,
								   <argument><expr><name>lockmode</name></expr></argument>, <argument><expr><name>wait_policy</name></expr></argument>,
								   <argument><expr><name>false</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>hufd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* We now have two pins on the buffer, get rid of one */</comment>
			<expr_stmt><expr><call><name>ReleaseBuffer</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<switch>switch <condition>(<expr><name>test</name></expr>)</condition>
			<block>{<block_content>
				<case>case <expr><name>HeapTupleSelfUpdated</name></expr>:</case>

					<comment type="block">/*
					 * The target tuple was already updated or deleted by the
					 * current command, or by a later command in the current
					 * transaction.  We *must* ignore the tuple in the former
					 * case, so as to avoid the "Halloween problem" of
					 * repeated update attempts.  In the latter case it might
					 * be sensible to fetch the updated tuple instead, but
					 * doing so would require changing heap_update and
					 * heap_delete to not complain about updating "invisible"
					 * tuples, which seems pretty scary (heap_lock_tuple will
					 * not complain, but few callers expect
					 * HeapTupleInvisible, and we're not one of them).  So for
					 * now, treat the tuple as deleted and do not process.
					 */</comment>
					<expr_stmt><expr><call><name>ReleaseBuffer</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<return>return <expr><name>NULL</name></expr>;</return>

				<case>case <expr><name>HeapTupleMayBeUpdated</name></expr>:</case>
					<comment type="block">/* successfully locked */</comment>
					<break>break;</break>

				<case>case <expr><name>HeapTupleUpdated</name></expr>:</case>
					<expr_stmt><expr><call><name>ReleaseBuffer</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<if_stmt><if>if <condition>(<expr><call><name>IsolationUsesXactSnapshot</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
								<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_T_R_SERIALIZATION_FAILURE</name></expr></argument>)</argument_list></call><operator>,</operator>
								 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not serialize access due to concurrent update"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
					<if_stmt><if>if <condition>(<expr><call><name>ItemPointerIndicatesMovedPartitions</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>hufd</name><operator>.</operator><name>ctid</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
								<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_T_R_SERIALIZATION_FAILURE</name></expr></argument>)</argument_list></call><operator>,</operator>
								 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"tuple to be locked was already moved to another partition due to concurrent update"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

					<comment type="block">/* Should not encounter speculative tuple on recheck */</comment>
					<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>HeapTupleHeaderIsSpeculative</name><argument_list>(<argument><expr><name><name>tuple</name><operator>.</operator><name>t_data</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ItemPointerEquals</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>hufd</name><operator>.</operator><name>ctid</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>tuple</name><operator>.</operator><name>t_self</name></name></expr></argument>)</argument_list></call></expr>)</condition>
					<block>{<block_content>
						<comment type="block">/* it was updated, so look at the updated version */</comment>
						<expr_stmt><expr><name><name>tuple</name><operator>.</operator><name>t_self</name></name> <operator>=</operator> <name><name>hufd</name><operator>.</operator><name>ctid</name></name></expr>;</expr_stmt>
						<comment type="block">/* updated row should have xmin matching this xmax */</comment>
						<expr_stmt><expr><name>priorXmax</name> <operator>=</operator> <name><name>hufd</name><operator>.</operator><name>xmax</name></name></expr>;</expr_stmt>
						<continue>continue;</continue>
					</block_content>}</block></if></if_stmt>
					<comment type="block">/* tuple was deleted, so give up */</comment>
					<return>return <expr><name>NULL</name></expr>;</return>

				<case>case <expr><name>HeapTupleWouldBlock</name></expr>:</case>
					<expr_stmt><expr><call><name>ReleaseBuffer</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<return>return <expr><name>NULL</name></expr>;</return>

				<case>case <expr><name>HeapTupleInvisible</name></expr>:</case>
					<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"attempted to lock invisible tuple"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<break>break;</break>

				<default>default:</default>
					<expr_stmt><expr><call><name>ReleaseBuffer</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized heap_lock_tuple status: %u"</literal></expr></argument>,
						 <argument><expr><name>test</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<return>return <expr><name>NULL</name></expr>;</return>	<comment type="block">/* keep compiler quiet */</comment>
			</block_content>}</block></switch>

			<comment type="block">/*
			 * We got tuple - now copy it for use by recheck query.
			 */</comment>
			<expr_stmt><expr><name>copyTuple</name> <operator>=</operator> <call><name>heap_copytuple</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>ReleaseBuffer</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * If the referenced slot was actually empty, the latest version of
		 * the row must have been deleted, so we need do nothing.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>tuple</name><operator>.</operator><name>t_data</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ReleaseBuffer</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>NULL</name></expr>;</return>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * As above, if xmin isn't what we're expecting, do nothing.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>TransactionIdEquals</name><argument_list>(<argument><expr><call><name>HeapTupleHeaderGetXmin</name><argument_list>(<argument><expr><name><name>tuple</name><operator>.</operator><name>t_data</name></name></expr></argument>)</argument_list></call></expr></argument>,
								 <argument><expr><name>priorXmax</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ReleaseBuffer</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>NULL</name></expr>;</return>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * If we get here, the tuple was found but failed SnapshotDirty.
		 * Assuming the xmin is either a committed xact or our own xact (as it
		 * certainly should be if we're trying to modify the tuple), this must
		 * mean that the row was updated or deleted by either a committed xact
		 * or our own xact.  If it was deleted, we can ignore it; if it was
		 * updated then chain up to the next version and repeat the whole
		 * process.
		 *
		 * As above, it should be safe to examine xmax and t_ctid without the
		 * buffer content lock, because they can't be changing.
		 */</comment>

		<comment type="block">/* check whether next version would be in a different partition */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>HeapTupleHeaderIndicatesMovedPartitions</name><argument_list>(<argument><expr><name><name>tuple</name><operator>.</operator><name>t_data</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_T_R_SERIALIZATION_FAILURE</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"tuple to be locked was already moved to another partition due to concurrent update"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/* check whether tuple has been deleted */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>ItemPointerEquals</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>tuple</name><operator>.</operator><name>t_self</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>tuple</name><operator>.</operator><name>t_data</name><operator>-&gt;</operator><name>t_ctid</name></name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* deleted, so forget about it */</comment>
			<expr_stmt><expr><call><name>ReleaseBuffer</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>NULL</name></expr>;</return>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* updated, so look at the updated row */</comment>
		<expr_stmt><expr><name><name>tuple</name><operator>.</operator><name>t_self</name></name> <operator>=</operator> <name><name>tuple</name><operator>.</operator><name>t_data</name><operator>-&gt;</operator><name>t_ctid</name></name></expr>;</expr_stmt>
		<comment type="block">/* updated row should have xmin matching this xmax */</comment>
		<expr_stmt><expr><name>priorXmax</name> <operator>=</operator> <call><name>HeapTupleHeaderGetUpdateXid</name><argument_list>(<argument><expr><name><name>tuple</name><operator>.</operator><name>t_data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ReleaseBuffer</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* loop back to fetch next in chain */</comment>
	</block_content>}</block></for>

	<comment type="block">/*
	 * Return the copied tuple
	 */</comment>
	<return>return <expr><name>copyTuple</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * EvalPlanQualInit -- initialize during creation of a plan state node
 * that might need to invoke EPQ processing.
 *
 * Note: subplan/auxrowmarks can be NULL/NIL if they will be set later
 * with EvalPlanQualSetPlan.
 */</comment>
<function><type><name>void</name></type>
<name>EvalPlanQualInit</name><parameter_list>(<parameter><decl><type><name>EPQState</name> <modifier>*</modifier></type><name>epqstate</name></decl></parameter>, <parameter><decl><type><name>EState</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>,
				 <parameter><decl><type><name>Plan</name> <modifier>*</modifier></type><name>subplan</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>auxrowmarks</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>epqParam</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* Mark the EPQ state inactive */</comment>
	<expr_stmt><expr><name><name>epqstate</name><operator>-&gt;</operator><name>estate</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>epqstate</name><operator>-&gt;</operator><name>planstate</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>epqstate</name><operator>-&gt;</operator><name>origslot</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<comment type="block">/* ... and remember data that EvalPlanQualBegin will need */</comment>
	<expr_stmt><expr><name><name>epqstate</name><operator>-&gt;</operator><name>plan</name></name> <operator>=</operator> <name>subplan</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>epqstate</name><operator>-&gt;</operator><name>arowMarks</name></name> <operator>=</operator> <name>auxrowmarks</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>epqstate</name><operator>-&gt;</operator><name>epqParam</name></name> <operator>=</operator> <name>epqParam</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * EvalPlanQualSetPlan -- set or change subplan of an EPQState.
 *
 * We need this so that ModifyTable can deal with multiple subplans.
 */</comment>
<function><type><name>void</name></type>
<name>EvalPlanQualSetPlan</name><parameter_list>(<parameter><decl><type><name>EPQState</name> <modifier>*</modifier></type><name>epqstate</name></decl></parameter>, <parameter><decl><type><name>Plan</name> <modifier>*</modifier></type><name>subplan</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>auxrowmarks</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* If we have a live EPQ query, shut it down */</comment>
	<expr_stmt><expr><call><name>EvalPlanQualEnd</name><argument_list>(<argument><expr><name>epqstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* And set/change the plan pointer */</comment>
	<expr_stmt><expr><name><name>epqstate</name><operator>-&gt;</operator><name>plan</name></name> <operator>=</operator> <name>subplan</name></expr>;</expr_stmt>
	<comment type="block">/* The rowmarks depend on the plan, too */</comment>
	<expr_stmt><expr><name><name>epqstate</name><operator>-&gt;</operator><name>arowMarks</name></name> <operator>=</operator> <name>auxrowmarks</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Install one test tuple into EPQ state, or clear test tuple if tuple == NULL
 *
 * NB: passed tuple must be palloc'd; it may get freed later
 */</comment>
<function><type><name>void</name></type>
<name>EvalPlanQualSetTuple</name><parameter_list>(<parameter><decl><type><name>EPQState</name> <modifier>*</modifier></type><name>epqstate</name></decl></parameter>, <parameter><decl><type><name>Index</name></type> <name>rti</name></decl></parameter>, <parameter><decl><type><name>HeapTuple</name></type> <name>tuple</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>EState</name>	   <modifier>*</modifier></type><name>estate</name> <init>= <expr><name><name>epqstate</name><operator>-&gt;</operator><name>estate</name></name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>rti</name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * free old test tuple, if any, and store new tuple where relation's scan
	 * node will see it
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>estate</name><operator>-&gt;</operator><name>es_epqTuple</name><index>[<expr><name>rti</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>heap_freetuple</name><argument_list>(<argument><expr><name><name>estate</name><operator>-&gt;</operator><name>es_epqTuple</name><index>[<expr><name>rti</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>es_epqTuple</name><index>[<expr><name>rti</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>tuple</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>es_epqTupleSet</name><index>[<expr><name>rti</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Fetch back the current test tuple (if any) for the specified RTI
 */</comment>
<function><type><name>HeapTuple</name></type>
<name>EvalPlanQualGetTuple</name><parameter_list>(<parameter><decl><type><name>EPQState</name> <modifier>*</modifier></type><name>epqstate</name></decl></parameter>, <parameter><decl><type><name>Index</name></type> <name>rti</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>EState</name>	   <modifier>*</modifier></type><name>estate</name> <init>= <expr><name><name>epqstate</name><operator>-&gt;</operator><name>estate</name></name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>rti</name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name><name>estate</name><operator>-&gt;</operator><name>es_epqTuple</name><index>[<expr><name>rti</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Fetch the current row values for any non-locked relations that need
 * to be scanned by an EvalPlanQual operation.  origslot must have been set
 * to contain the current result row (top-level row) that we need to recheck.
 */</comment>
<function><type><name>void</name></type>
<name>EvalPlanQualFetchRowMarks</name><parameter_list>(<parameter><decl><type><name>EPQState</name> <modifier>*</modifier></type><name>epqstate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>epqstate</name><operator>-&gt;</operator><name>origslot</name></name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>epqstate-&gt;arowMarks</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ExecAuxRowMark</name> <modifier>*</modifier></type><name>aerm</name> <init>= <expr><operator>(</operator><name>ExecAuxRowMark</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ExecRowMark</name> <modifier>*</modifier></type><name>erm</name> <init>= <expr><name><name>aerm</name><operator>-&gt;</operator><name>rowmark</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Datum</name></type>		<name>datum</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>isNull</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>HeapTupleData</name></type> <name>tuple</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>RowMarkRequiresRowShareLock</name><argument_list>(<argument><expr><name><name>erm</name><operator>-&gt;</operator><name>markType</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"EvalPlanQual doesn't support locking rowmarks"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/* clear any leftover test tuple for this rel */</comment>
		<expr_stmt><expr><call><name>EvalPlanQualSetTuple</name><argument_list>(<argument><expr><name>epqstate</name></expr></argument>, <argument><expr><name><name>erm</name><operator>-&gt;</operator><name>rti</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* if child rel, must check whether it produced this row */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>erm</name><operator>-&gt;</operator><name>rti</name></name> <operator>!=</operator> <name><name>erm</name><operator>-&gt;</operator><name>prti</name></name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Oid</name></type>			<name>tableoid</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>datum</name> <operator>=</operator> <call><name>ExecGetJunkAttribute</name><argument_list>(<argument><expr><name><name>epqstate</name><operator>-&gt;</operator><name>origslot</name></name></expr></argument>,
										 <argument><expr><name><name>aerm</name><operator>-&gt;</operator><name>toidAttNo</name></name></expr></argument>,
										 <argument><expr><operator>&amp;</operator><name>isNull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* non-locked rels could be on the inside of outer joins */</comment>
			<if_stmt><if>if <condition>(<expr><name>isNull</name></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>
			<expr_stmt><expr><name>tableoid</name> <operator>=</operator> <call><name>DatumGetObjectId</name><argument_list>(<argument><expr><name>datum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>erm</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>tableoid</name> <operator>!=</operator> <name><name>erm</name><operator>-&gt;</operator><name>relid</name></name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* this child is inactive right now */</comment>
				<continue>continue;</continue>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>erm</name><operator>-&gt;</operator><name>markType</name></name> <operator>==</operator> <name>ROW_MARK_REFERENCE</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>copyTuple</name></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>erm</name><operator>-&gt;</operator><name>relation</name></name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* fetch the tuple's ctid */</comment>
			<expr_stmt><expr><name>datum</name> <operator>=</operator> <call><name>ExecGetJunkAttribute</name><argument_list>(<argument><expr><name><name>epqstate</name><operator>-&gt;</operator><name>origslot</name></name></expr></argument>,
										 <argument><expr><name><name>aerm</name><operator>-&gt;</operator><name>ctidAttNo</name></name></expr></argument>,
										 <argument><expr><operator>&amp;</operator><name>isNull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* non-locked rels could be on the inside of outer joins */</comment>
			<if_stmt><if>if <condition>(<expr><name>isNull</name></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>

			<comment type="block">/* fetch requests on foreign tables must be passed to their FDW */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>erm</name><operator>-&gt;</operator><name>relation</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_FOREIGN_TABLE</name></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>FdwRoutine</name> <modifier>*</modifier></type><name>fdwroutine</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>bool</name></type>		<name>updated</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><name>fdwroutine</name> <operator>=</operator> <call><name>GetFdwRoutineForRelation</name><argument_list>(<argument><expr><name><name>erm</name><operator>-&gt;</operator><name>relation</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<comment type="block">/* this should have been checked already, but let's be safe */</comment>
				<if_stmt><if>if <condition>(<expr><name><name>fdwroutine</name><operator>-&gt;</operator><name>RefetchForeignRow</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot lock rows in foreign table \"%s\""</literal></expr></argument>,
									<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name><name>erm</name><operator>-&gt;</operator><name>relation</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<expr_stmt><expr><name>copyTuple</name> <operator>=</operator> <call><name><name>fdwroutine</name><operator>-&gt;</operator><name>RefetchForeignRow</name></name><argument_list>(<argument><expr><name><name>epqstate</name><operator>-&gt;</operator><name>estate</name></name></expr></argument>,
														  <argument><expr><name>erm</name></expr></argument>,
														  <argument><expr><name>datum</name></expr></argument>,
														  <argument><expr><operator>&amp;</operator><name>updated</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name>copyTuple</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"failed to fetch tuple for EvalPlanQual recheck"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

				<comment type="block">/*
				 * Ideally we'd insist on updated == false here, but that
				 * assumes that FDWs can track that exactly, which they might
				 * not be able to.  So just ignore the flag.
				 */</comment>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<comment type="block">/* ordinary table, fetch the tuple */</comment>
				<decl_stmt><decl><type><name>Buffer</name></type>		<name>buffer</name></decl>;</decl_stmt>

				<expr_stmt><expr><name><name>tuple</name><operator>.</operator><name>t_self</name></name> <operator>=</operator> <operator>*</operator><operator>(</operator><operator>(</operator><name>ItemPointer</name><operator>)</operator> <call><name>DatumGetPointer</name><argument_list>(<argument><expr><name>datum</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>heap_fetch</name><argument_list>(<argument><expr><name><name>erm</name><operator>-&gt;</operator><name>relation</name></name></expr></argument>, <argument><expr><name>SnapshotAny</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tuple</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>,
								<argument><expr><name>false</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"failed to fetch tuple for EvalPlanQual recheck"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

				<comment type="block">/* successful, copy tuple */</comment>
				<expr_stmt><expr><name>copyTuple</name> <operator>=</operator> <call><name>heap_copytuple</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>ReleaseBuffer</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>

			<comment type="block">/* store tuple */</comment>
			<expr_stmt><expr><call><name>EvalPlanQualSetTuple</name><argument_list>(<argument><expr><name>epqstate</name></expr></argument>, <argument><expr><name><name>erm</name><operator>-&gt;</operator><name>rti</name></name></expr></argument>, <argument><expr><name>copyTuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<decl_stmt><decl><type><name>HeapTupleHeader</name></type> <name>td</name></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>erm</name><operator>-&gt;</operator><name>markType</name></name> <operator>==</operator> <name>ROW_MARK_COPY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* fetch the whole-row Var for the relation */</comment>
			<expr_stmt><expr><name>datum</name> <operator>=</operator> <call><name>ExecGetJunkAttribute</name><argument_list>(<argument><expr><name><name>epqstate</name><operator>-&gt;</operator><name>origslot</name></name></expr></argument>,
										 <argument><expr><name><name>aerm</name><operator>-&gt;</operator><name>wholeAttNo</name></name></expr></argument>,
										 <argument><expr><operator>&amp;</operator><name>isNull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* non-locked rels could be on the inside of outer joins */</comment>
			<if_stmt><if>if <condition>(<expr><name>isNull</name></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>
			<expr_stmt><expr><name>td</name> <operator>=</operator> <call><name>DatumGetHeapTupleHeader</name><argument_list>(<argument><expr><name>datum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* build a temporary HeapTuple control structure */</comment>
			<expr_stmt><expr><name><name>tuple</name><operator>.</operator><name>t_len</name></name> <operator>=</operator> <call><name>HeapTupleHeaderGetDatumLength</name><argument_list>(<argument><expr><name>td</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>tuple</name><operator>.</operator><name>t_data</name></name> <operator>=</operator> <name>td</name></expr>;</expr_stmt>
			<comment type="block">/* relation might be a foreign table, if so provide tableoid */</comment>
			<expr_stmt><expr><name><name>tuple</name><operator>.</operator><name>t_tableOid</name></name> <operator>=</operator> <name><name>erm</name><operator>-&gt;</operator><name>relid</name></name></expr>;</expr_stmt>
			<comment type="block">/* also copy t_ctid in case there's valid data there */</comment>
			<expr_stmt><expr><name><name>tuple</name><operator>.</operator><name>t_self</name></name> <operator>=</operator> <name><name>td</name><operator>-&gt;</operator><name>t_ctid</name></name></expr>;</expr_stmt>

			<comment type="block">/* copy and store tuple */</comment>
			<expr_stmt><expr><call><name>EvalPlanQualSetTuple</name><argument_list>(<argument><expr><name>epqstate</name></expr></argument>, <argument><expr><name><name>erm</name><operator>-&gt;</operator><name>rti</name></name></expr></argument>,
								 <argument><expr><call><name>heap_copytuple</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tuple</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block>
</block_content>}</block></function>

<comment type="block">/*
 * Fetch the next row (if any) from EvalPlanQual testing
 *
 * (In practice, there should never be more than one row...)
 */</comment>
<function><type><name>TupleTableSlot</name> <modifier>*</modifier></type>
<name>EvalPlanQualNext</name><parameter_list>(<parameter><decl><type><name>EPQState</name> <modifier>*</modifier></type><name>epqstate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcontext</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>oldcontext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>epqstate</name><operator>-&gt;</operator><name>estate</name><operator>-&gt;</operator><name>es_query_cxt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>slot</name> <operator>=</operator> <call><name>ExecProcNode</name><argument_list>(<argument><expr><name><name>epqstate</name><operator>-&gt;</operator><name>planstate</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>slot</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Initialize or reset an EvalPlanQual state tree
 */</comment>
<function><type><name>void</name></type>
<name>EvalPlanQualBegin</name><parameter_list>(<parameter><decl><type><name>EPQState</name> <modifier>*</modifier></type><name>epqstate</name></decl></parameter>, <parameter><decl><type><name>EState</name> <modifier>*</modifier></type><name>parentestate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>EState</name>	   <modifier>*</modifier></type><name>estate</name> <init>= <expr><name><name>epqstate</name><operator>-&gt;</operator><name>estate</name></name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>estate</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* First time through, so create a child EState */</comment>
		<expr_stmt><expr><call><name>EvalPlanQualStart</name><argument_list>(<argument><expr><name>epqstate</name></expr></argument>, <argument><expr><name>parentestate</name></expr></argument>, <argument><expr><name><name>epqstate</name><operator>-&gt;</operator><name>plan</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/*
		 * We already have a suitable child EPQ tree, so just reset it.
		 */</comment>
		<decl_stmt><decl><type><name>int</name></type>			<name>rtsize</name> <init>= <expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>parentestate</name><operator>-&gt;</operator><name>es_range_table</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>PlanState</name>  <modifier>*</modifier></type><name>planstate</name> <init>= <expr><name><name>epqstate</name><operator>-&gt;</operator><name>planstate</name></name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><name><name>estate</name><operator>-&gt;</operator><name>es_epqScanDone</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>rtsize</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Recopy current values of parent parameters */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>parentestate</name><operator>-&gt;</operator><name>es_plannedstmt</name><operator>-&gt;</operator><name>paramExecTypes</name></name> <operator>!=</operator> <name>NIL</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

			<comment type="block">/*
			 * Force evaluation of any InitPlan outputs that could be needed
			 * by the subplan, just in case they got reset since
			 * EvalPlanQualStart (see comments therein).
			 */</comment>
			<expr_stmt><expr><call><name>ExecSetParamPlanMulti</name><argument_list>(<argument><expr><name><name>planstate</name><operator>-&gt;</operator><name>plan</name><operator>-&gt;</operator><name>extParam</name></name></expr></argument>,
								  <argument><expr><call><name>GetPerTupleExprContext</name><argument_list>(<argument><expr><name>parentestate</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name>i</name> <operator>=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>parentestate</name><operator>-&gt;</operator><name>es_plannedstmt</name><operator>-&gt;</operator><name>paramExecTypes</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<while>while <condition>(<expr><operator>--</operator><name>i</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* copy value if any, but not execPlan link */</comment>
				<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>es_param_exec_vals</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>value</name> <operator>=</operator>
					<name><name>parentestate</name><operator>-&gt;</operator><name>es_param_exec_vals</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>value</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>es_param_exec_vals</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>isnull</name> <operator>=</operator>
					<name><name>parentestate</name><operator>-&gt;</operator><name>es_param_exec_vals</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>isnull</name></expr>;</expr_stmt>
			</block_content>}</block></while>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * Mark child plan tree as needing rescan at all scan nodes.  The
		 * first ExecProcNode will take care of actually doing the rescan.
		 */</comment>
		<expr_stmt><expr><name><name>planstate</name><operator>-&gt;</operator><name>chgParam</name></name> <operator>=</operator> <call><name>bms_add_member</name><argument_list>(<argument><expr><name><name>planstate</name><operator>-&gt;</operator><name>chgParam</name></name></expr></argument>,
											 <argument><expr><name><name>epqstate</name><operator>-&gt;</operator><name>epqParam</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Start execution of an EvalPlanQual plan tree.
 *
 * This is a cut-down version of ExecutorStart(): we copy some state from
 * the top-level estate rather than initializing it fresh.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>EvalPlanQualStart</name><parameter_list>(<parameter><decl><type><name>EPQState</name> <modifier>*</modifier></type><name>epqstate</name></decl></parameter>, <parameter><decl><type><name>EState</name> <modifier>*</modifier></type><name>parentestate</name></decl></parameter>, <parameter><decl><type><name>Plan</name> <modifier>*</modifier></type><name>planTree</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>EState</name>	   <modifier>*</modifier></type><name>estate</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>rtsize</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcontext</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>rtsize</name> <operator>=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>parentestate</name><operator>-&gt;</operator><name>es_range_table</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>epqstate</name><operator>-&gt;</operator><name>estate</name></name> <operator>=</operator> <name>estate</name> <operator>=</operator> <call><name>CreateExecutorState</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>oldcontext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>estate</name><operator>-&gt;</operator><name>es_query_cxt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Child EPQ EStates share the parent's copy of unchanging state such as
	 * the snapshot, rangetable, result-rel info, and external Param info.
	 * They need their own copies of local state, including a tuple table,
	 * es_param_exec_vals, etc.
	 *
	 * The ResultRelInfo array management is trickier than it looks.  We
	 * create fresh arrays for the child but copy all the content from the
	 * parent.  This is because it's okay for the child to share any
	 * per-relation state the parent has already created --- but if the child
	 * sets up any ResultRelInfo fields, such as its own junkfilter, that
	 * state must *not* propagate back to the parent.  (For one thing, the
	 * pointed-to data is in a memory context that won't last long enough.)
	 */</comment>
	<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>es_direction</name></name> <operator>=</operator> <name>ForwardScanDirection</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>es_snapshot</name></name> <operator>=</operator> <name><name>parentestate</name><operator>-&gt;</operator><name>es_snapshot</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>es_crosscheck_snapshot</name></name> <operator>=</operator> <name><name>parentestate</name><operator>-&gt;</operator><name>es_crosscheck_snapshot</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>es_range_table</name></name> <operator>=</operator> <name><name>parentestate</name><operator>-&gt;</operator><name>es_range_table</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>es_queryEnv</name></name> <operator>=</operator> <name><name>parentestate</name><operator>-&gt;</operator><name>es_queryEnv</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>es_plannedstmt</name></name> <operator>=</operator> <name><name>parentestate</name><operator>-&gt;</operator><name>es_plannedstmt</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>es_junkFilter</name></name> <operator>=</operator> <name><name>parentestate</name><operator>-&gt;</operator><name>es_junkFilter</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>es_output_cid</name></name> <operator>=</operator> <name><name>parentestate</name><operator>-&gt;</operator><name>es_output_cid</name></name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>parentestate</name><operator>-&gt;</operator><name>es_num_result_relations</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>numResultRelations</name> <init>= <expr><name><name>parentestate</name><operator>-&gt;</operator><name>es_num_result_relations</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>numRootResultRels</name> <init>= <expr><name><name>parentestate</name><operator>-&gt;</operator><name>es_num_root_result_relations</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ResultRelInfo</name> <modifier>*</modifier></type><name>resultRelInfos</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>resultRelInfos</name> <operator>=</operator> <operator>(</operator><name>ResultRelInfo</name> <operator>*</operator><operator>)</operator>
			<call><name>palloc</name><argument_list>(<argument><expr><name>numResultRelations</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ResultRelInfo</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>resultRelInfos</name></expr></argument>, <argument><expr><name><name>parentestate</name><operator>-&gt;</operator><name>es_result_relations</name></name></expr></argument>,
			   <argument><expr><name>numResultRelations</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ResultRelInfo</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>es_result_relations</name></name> <operator>=</operator> <name>resultRelInfos</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>es_num_result_relations</name></name> <operator>=</operator> <name>numResultRelations</name></expr>;</expr_stmt>

		<comment type="block">/* Also transfer partitioned root result relations. */</comment>
		<if_stmt><if>if <condition>(<expr><name>numRootResultRels</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>resultRelInfos</name> <operator>=</operator> <operator>(</operator><name>ResultRelInfo</name> <operator>*</operator><operator>)</operator>
				<call><name>palloc</name><argument_list>(<argument><expr><name>numRootResultRels</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ResultRelInfo</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>resultRelInfos</name></expr></argument>, <argument><expr><name><name>parentestate</name><operator>-&gt;</operator><name>es_root_result_relations</name></name></expr></argument>,
				   <argument><expr><name>numRootResultRels</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ResultRelInfo</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>es_root_result_relations</name></name> <operator>=</operator> <name>resultRelInfos</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>es_num_root_result_relations</name></name> <operator>=</operator> <name>numRootResultRels</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* es_result_relation_info must NOT be copied */</comment>
	<comment type="block">/* es_trig_target_relations must NOT be copied */</comment>
	<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>es_rowMarks</name></name> <operator>=</operator> <name><name>parentestate</name><operator>-&gt;</operator><name>es_rowMarks</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>es_top_eflags</name></name> <operator>=</operator> <name><name>parentestate</name><operator>-&gt;</operator><name>es_top_eflags</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>es_instrument</name></name> <operator>=</operator> <name><name>parentestate</name><operator>-&gt;</operator><name>es_instrument</name></name></expr>;</expr_stmt>
	<comment type="block">/* es_auxmodifytables must NOT be copied */</comment>

	<comment type="block">/*
	 * The external param list is simply shared from parent.  The internal
	 * param workspace has to be local state, but we copy the initial values
	 * from the parent, so as to have access to any param values that were
	 * already set from other parts of the parent's plan tree.
	 */</comment>
	<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>es_param_list_info</name></name> <operator>=</operator> <name><name>parentestate</name><operator>-&gt;</operator><name>es_param_list_info</name></name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>parentestate</name><operator>-&gt;</operator><name>es_plannedstmt</name><operator>-&gt;</operator><name>paramExecTypes</name></name> <operator>!=</operator> <name>NIL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * Force evaluation of any InitPlan outputs that could be needed by
		 * the subplan.  (With more complexity, maybe we could postpone this
		 * till the subplan actually demands them, but it doesn't seem worth
		 * the trouble; this is a corner case already, since usually the
		 * InitPlans would have been evaluated before reaching EvalPlanQual.)
		 *
		 * This will not touch output params of InitPlans that occur somewhere
		 * within the subplan tree, only those that are attached to the
		 * ModifyTable node or above it and are referenced within the subplan.
		 * That's OK though, because the planner would only attach such
		 * InitPlans to a lower-level SubqueryScan node, and EPQ execution
		 * will not descend into a SubqueryScan.
		 *
		 * The EState's per-output-tuple econtext is sufficiently short-lived
		 * for this, since it should get reset before there is any chance of
		 * doing EvalPlanQual again.
		 */</comment>
		<expr_stmt><expr><call><name>ExecSetParamPlanMulti</name><argument_list>(<argument><expr><name><name>planTree</name><operator>-&gt;</operator><name>extParam</name></name></expr></argument>,
							  <argument><expr><call><name>GetPerTupleExprContext</name><argument_list>(<argument><expr><name>parentestate</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* now make the internal param workspace ... */</comment>
		<expr_stmt><expr><name>i</name> <operator>=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>parentestate</name><operator>-&gt;</operator><name>es_plannedstmt</name><operator>-&gt;</operator><name>paramExecTypes</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>es_param_exec_vals</name></name> <operator>=</operator> <operator>(</operator><name>ParamExecData</name> <operator>*</operator><operator>)</operator>
			<call><name>palloc0</name><argument_list>(<argument><expr><name>i</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ParamExecData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* ... and copy down all values, whether really needed or not */</comment>
		<while>while <condition>(<expr><operator>--</operator><name>i</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* copy value if any, but not execPlan link */</comment>
			<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>es_param_exec_vals</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>value</name> <operator>=</operator>
				<name><name>parentestate</name><operator>-&gt;</operator><name>es_param_exec_vals</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>value</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>es_param_exec_vals</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>isnull</name> <operator>=</operator>
				<name><name>parentestate</name><operator>-&gt;</operator><name>es_param_exec_vals</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>isnull</name></expr>;</expr_stmt>
		</block_content>}</block></while>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Each EState must have its own es_epqScanDone state, but if we have
	 * nested EPQ checks they should share es_epqTuple arrays.  This allows
	 * sub-rechecks to inherit the values being examined by an outer recheck.
	 */</comment>
	<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>es_epqScanDone</name></name> <operator>=</operator> <operator>(</operator><name>bool</name> <operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><name>rtsize</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>parentestate</name><operator>-&gt;</operator><name>es_epqTuple</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>es_epqTuple</name></name> <operator>=</operator> <name><name>parentestate</name><operator>-&gt;</operator><name>es_epqTuple</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>es_epqTupleSet</name></name> <operator>=</operator> <name><name>parentestate</name><operator>-&gt;</operator><name>es_epqTupleSet</name></name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>es_epqTuple</name></name> <operator>=</operator> <operator>(</operator><name>HeapTuple</name> <operator>*</operator><operator>)</operator>
			<call><name>palloc0</name><argument_list>(<argument><expr><name>rtsize</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>HeapTuple</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>es_epqTupleSet</name></name> <operator>=</operator> <operator>(</operator><name>bool</name> <operator>*</operator><operator>)</operator>
			<call><name>palloc0</name><argument_list>(<argument><expr><name>rtsize</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/*
	 * Each estate also has its own tuple table.
	 */</comment>
	<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>es_tupleTable</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Initialize private state information for each SubPlan.  We must do this
	 * before running ExecInitNode on the main query tree, since
	 * ExecInitSubPlan expects to be able to find these entries. Some of the
	 * SubPlans might not be used in the part of the plan tree we intend to
	 * run, but since it's not easy to tell which, we just initialize them
	 * all.
	 */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>estate</name><operator>-&gt;</operator><name>es_subplanstates</name></name> <operator>==</operator> <name>NIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>parentestate-&gt;es_plannedstmt-&gt;subplans</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Plan</name>	   <modifier>*</modifier></type><name>subplan</name> <init>= <expr><operator>(</operator><name>Plan</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>PlanState</name>  <modifier>*</modifier></type><name>subplanstate</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>subplanstate</name> <operator>=</operator> <call><name>ExecInitNode</name><argument_list>(<argument><expr><name>subplan</name></expr></argument>, <argument><expr><name>estate</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>es_subplanstates</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>estate</name><operator>-&gt;</operator><name>es_subplanstates</name></name></expr></argument>,
										   <argument><expr><name>subplanstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<comment type="block">/*
	 * Initialize the private state information for all the nodes in the part
	 * of the plan tree we need to run.  This opens files, allocates storage
	 * and leaves us ready to start processing tuples.
	 */</comment>
	<expr_stmt><expr><name><name>epqstate</name><operator>-&gt;</operator><name>planstate</name></name> <operator>=</operator> <call><name>ExecInitNode</name><argument_list>(<argument><expr><name>planTree</name></expr></argument>, <argument><expr><name>estate</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * EvalPlanQualEnd -- shut down at termination of parent plan state node,
 * or if we are done with the current EPQ child.
 *
 * This is a cut-down version of ExecutorEnd(); basically we want to do most
 * of the normal cleanup, but *not* close result relations (which we are
 * just sharing from the outer query).  We do, however, have to close any
 * trigger target relations that got opened, since those are not shared.
 * (There probably shouldn't be any of the latter, but just in case...)
 */</comment>
<function><type><name>void</name></type>
<name>EvalPlanQualEnd</name><parameter_list>(<parameter><decl><type><name>EPQState</name> <modifier>*</modifier></type><name>epqstate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>EState</name>	   <modifier>*</modifier></type><name>estate</name> <init>= <expr><name><name>epqstate</name><operator>-&gt;</operator><name>estate</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcontext</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>estate</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>					<comment type="block">/* idle, so nothing to do */</comment>

	<expr_stmt><expr><name>oldcontext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>estate</name><operator>-&gt;</operator><name>es_query_cxt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ExecEndNode</name><argument_list>(<argument><expr><name><name>epqstate</name><operator>-&gt;</operator><name>planstate</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>estate-&gt;es_subplanstates</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>PlanState</name>  <modifier>*</modifier></type><name>subplanstate</name> <init>= <expr><operator>(</operator><name>PlanState</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>ExecEndNode</name><argument_list>(<argument><expr><name>subplanstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<comment type="block">/* throw away the per-estate tuple table */</comment>
	<expr_stmt><expr><call><name>ExecResetTupleTable</name><argument_list>(<argument><expr><name><name>estate</name><operator>-&gt;</operator><name>es_tupleTable</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* close any trigger target relations attached to this EState */</comment>
	<expr_stmt><expr><call><name>ExecCleanUpTriggerState</name><argument_list>(<argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>FreeExecutorState</name><argument_list>(<argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Mark EPQState idle */</comment>
	<expr_stmt><expr><name><name>epqstate</name><operator>-&gt;</operator><name>estate</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>epqstate</name><operator>-&gt;</operator><name>planstate</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>epqstate</name><operator>-&gt;</operator><name>origslot</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * POLAR px
 * 1. standard_ExecutorStart_PX
 * 2. standard_ExecutorRun_PX
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"execMain_px.c"</cpp:file></cpp:include>
</unit>
