<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/PolarDB-for-PostgreSQL/src/backend/executor/nodeBitmapHeapscan.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * nodeBitmapHeapscan.c
 *	  Routines to support bitmapped scans of relations
 *
 * NOTE: it is critical that this plan type only be used with MVCC-compliant
 * snapshots (ie, regular snapshots, not SnapshotAny or one of the other
 * special snapshots).  The reason is that since index and heap scans are
 * decoupled, there can be no assurance that the index tuple prompting a
 * visit to a particular heap TID still exists when the visit is made.
 * Therefore the tuple might not exist anymore either (which is OK because
 * heap_fetch will cope) --- but worse, the tuple slot could have been
 * re-used for a newer tuple.  With an MVCC snapshot the newer tuple is
 * certain to fail the time qual and so it will not be mistakenly returned,
 * but with anything else we might return a tuple that doesn't meet the
 * required index qual conditions.
 *
 *
 * Portions Copyright (c) 1996-2018, PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, Regents of the University of California
 *
 *
 * IDENTIFICATION
 *	  src/backend/executor/nodeBitmapHeapscan.c
 *
 *-------------------------------------------------------------------------
 */</comment>
<comment type="block">/*
 * INTERFACE ROUTINES
 *		ExecBitmapHeapScan			scans a relation using bitmap info
 *		ExecBitmapHeapNext			workhorse for above
 *		ExecInitBitmapHeapScan		creates and initializes state info.
 *		ExecReScanBitmapHeapScan	prepares to rescan the plan.
 *		ExecEndBitmapHeapScan		releases all storage.
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;math.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/relscan.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/transam.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/visibilitymap.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/execdebug.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/nodeBitmapHeapscan.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pgstat.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/bufmgr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/predicate.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/memutils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/rel.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/spccache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/snapmgr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/tqual.h"</cpp:file></cpp:include>


<function_decl><type><specifier>static</specifier> <name>TupleTableSlot</name> <modifier>*</modifier></type><name>BitmapHeapNext</name><parameter_list>(<parameter><decl><type><name>BitmapHeapScanState</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>bitgetpage</name><parameter_list>(<parameter><decl><type><name>HeapScanDesc</name></type> <name>scan</name></decl></parameter>, <parameter><decl><type><name>TBMIterateResult</name> <modifier>*</modifier></type><name>tbmres</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type> <name>BitmapDoneInitializingSharedState</name><parameter_list>(
								  <parameter><decl><type><name>ParallelBitmapHeapState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type> <name>BitmapAdjustPrefetchIterator</name><parameter_list>(<parameter><decl><type><name>BitmapHeapScanState</name> <modifier>*</modifier></type><name>node</name></decl></parameter>,
							 <parameter><decl><type><name>TBMIterateResult</name> <modifier>*</modifier></type><name>tbmres</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type> <name>BitmapAdjustPrefetchTarget</name><parameter_list>(<parameter><decl><type><name>BitmapHeapScanState</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type> <name>BitmapPrefetch</name><parameter_list>(<parameter><decl><type><name>BitmapHeapScanState</name> <modifier>*</modifier></type><name>node</name></decl></parameter>,
			   <parameter><decl><type><name>HeapScanDesc</name></type> <name>scan</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>BitmapShouldInitializeSharedState</name><parameter_list>(
								  <parameter><decl><type><name>ParallelBitmapHeapState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/* ----------------------------------------------------------------
 *		BitmapHeapNext
 *
 *		Retrieve next tuple from the BitmapHeapScan node's currentRelation
 * ----------------------------------------------------------------
 */</comment>
<function><type><specifier>static</specifier> <name>TupleTableSlot</name> <modifier>*</modifier></type>
<name>BitmapHeapNext</name><parameter_list>(<parameter><decl><type><name>BitmapHeapScanState</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ExprContext</name> <modifier>*</modifier></type><name>econtext</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapScanDesc</name></type> <name>scan</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TIDBitmap</name>  <modifier>*</modifier></type><name>tbm</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TBMIterator</name> <modifier>*</modifier></type><name>tbmiterator</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TBMSharedIterator</name> <modifier>*</modifier></type><name>shared_tbmiterator</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TBMIterateResult</name> <modifier>*</modifier></type><name>tbmres</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OffsetNumber</name></type> <name>targoffset</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ParallelBitmapHeapState</name> <modifier>*</modifier></type><name>pstate</name> <init>= <expr><name><name>node</name><operator>-&gt;</operator><name>pstate</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>dsa_area</name>   <modifier>*</modifier></type><name>dsa</name> <init>= <expr><name><name>node</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ps</name><operator>.</operator><name>state</name><operator>-&gt;</operator><name>es_query_dsa</name></name></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * extract necessary information from index scan node
	 */</comment>
	<expr_stmt><expr><name>econtext</name> <operator>=</operator> <name><name>node</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ps</name><operator>.</operator><name>ps_ExprContext</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>slot</name> <operator>=</operator> <name><name>node</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ss_ScanTupleSlot</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>scan</name> <operator>=</operator> <name><name>node</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ss_currentScanDesc</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>tbm</name> <operator>=</operator> <name><name>node</name><operator>-&gt;</operator><name>tbm</name></name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>pstate</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>tbmiterator</name> <operator>=</operator> <name><name>node</name><operator>-&gt;</operator><name>tbmiterator</name></name></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>shared_tbmiterator</name> <operator>=</operator> <name><name>node</name><operator>-&gt;</operator><name>shared_tbmiterator</name></name></expr>;</expr_stmt></block_content></block></else></if_stmt>
	<expr_stmt><expr><name>tbmres</name> <operator>=</operator> <name><name>node</name><operator>-&gt;</operator><name>tbmres</name></name></expr>;</expr_stmt>

	<comment type="block">/*
	 * If we haven't yet performed the underlying index scan, do it, and begin
	 * the iteration over the bitmap.
	 *
	 * For prefetching, we use *two* iterators, one for the pages we are
	 * actually scanning and another that runs ahead of the first for
	 * prefetching.  node-&gt;prefetch_pages tracks exactly how many pages ahead
	 * the prefetch iterator is.  Also, node-&gt;prefetch_target tracks the
	 * desired prefetch distance, which starts small and increases up to the
	 * node-&gt;prefetch_maximum.  This is to avoid doing a lot of prefetching in
	 * a scan that stops after a few tuples because of a LIMIT.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>node</name><operator>-&gt;</operator><name>initialized</name></name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>pstate</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>tbm</name> <operator>=</operator> <operator>(</operator><name>TIDBitmap</name> <operator>*</operator><operator>)</operator> <call><name>MultiExecProcNode</name><argument_list>(<argument><expr><call><name>outerPlanState</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>tbm</name> <operator>||</operator> <operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name>tbm</name></expr></argument>, <argument><expr><name>TIDBitmap</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized result from subplan"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>tbm</name></name> <operator>=</operator> <name>tbm</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>tbmiterator</name></name> <operator>=</operator> <name>tbmiterator</name> <operator>=</operator> <call><name>tbm_begin_iterate</name><argument_list>(<argument><expr><name>tbm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>tbmres</name></name> <operator>=</operator> <name>tbmres</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_PREFETCH</name></cpp:ifdef>
			<if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>prefetch_maximum</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>prefetch_iterator</name></name> <operator>=</operator> <call><name>tbm_begin_iterate</name><argument_list>(<argument><expr><name>tbm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>prefetch_pages</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>prefetch_target</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>							<comment type="block">/* USE_PREFETCH */</comment>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/*
			 * The leader will immediately come out of the function, but
			 * others will be blocked until leader populates the TBM and wakes
			 * them up.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>BitmapShouldInitializeSharedState</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>tbm</name> <operator>=</operator> <operator>(</operator><name>TIDBitmap</name> <operator>*</operator><operator>)</operator> <call><name>MultiExecProcNode</name><argument_list>(<argument><expr><call><name>outerPlanState</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><name>tbm</name> <operator>||</operator> <operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name>tbm</name></expr></argument>, <argument><expr><name>TIDBitmap</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized result from subplan"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

				<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>tbm</name></name> <operator>=</operator> <name>tbm</name></expr>;</expr_stmt>

				<comment type="block">/*
				 * Prepare to iterate over the TBM. This will return the
				 * dsa_pointer of the iterator state which will be used by
				 * multiple processes to iterate jointly.
				 */</comment>
				<expr_stmt><expr><name><name>pstate</name><operator>-&gt;</operator><name>tbmiterator</name></name> <operator>=</operator> <call><name>tbm_prepare_shared_iterate</name><argument_list>(<argument><expr><name>tbm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_PREFETCH</name></cpp:ifdef>
				<if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>prefetch_maximum</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name><name>pstate</name><operator>-&gt;</operator><name>prefetch_iterator</name></name> <operator>=</operator>
						<call><name>tbm_prepare_shared_iterate</name><argument_list>(<argument><expr><name>tbm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<comment type="block">/*
					 * We don't need the mutex here as we haven't yet woke up
					 * others.
					 */</comment>
					<expr_stmt><expr><name><name>pstate</name><operator>-&gt;</operator><name>prefetch_pages</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>pstate</name><operator>-&gt;</operator><name>prefetch_target</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

				<comment type="block">/* We have initialized the shared state so wake up others. */</comment>
				<expr_stmt><expr><call><name>BitmapDoneInitializingSharedState</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/* Allocate a private iterator and attach the shared state to it */</comment>
			<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>shared_tbmiterator</name></name> <operator>=</operator> <name>shared_tbmiterator</name> <operator>=</operator>
				<call><name>tbm_attach_shared_iterate</name><argument_list>(<argument><expr><name>dsa</name></expr></argument>, <argument><expr><name><name>pstate</name><operator>-&gt;</operator><name>tbmiterator</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>tbmres</name></name> <operator>=</operator> <name>tbmres</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_PREFETCH</name></cpp:ifdef>
			<if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>prefetch_maximum</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>shared_prefetch_iterator</name></name> <operator>=</operator>
					<call><name>tbm_attach_shared_iterate</name><argument_list>(<argument><expr><name>dsa</name></expr></argument>, <argument><expr><name><name>pstate</name><operator>-&gt;</operator><name>prefetch_iterator</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>							<comment type="block">/* USE_PREFETCH */</comment>
		</block_content>}</block></else></if_stmt>
		<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>initialized</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Page</name></type>		<name>dp</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ItemId</name></type>		<name>lp</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>CHECK_FOR_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Get next page of results if needed
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>tbmres</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>pstate</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>tbmres</name></name> <operator>=</operator> <name>tbmres</name> <operator>=</operator> <call><name>tbm_iterate</name><argument_list>(<argument><expr><name>tbmiterator</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>tbmres</name></name> <operator>=</operator> <name>tbmres</name> <operator>=</operator> <call><name>tbm_shared_iterate</name><argument_list>(<argument><expr><name>shared_tbmiterator</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
			<if_stmt><if>if <condition>(<expr><name>tbmres</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* no more entries in the bitmap */</comment>
				<break>break;</break>
			</block_content>}</block></if></if_stmt>

			<expr_stmt><expr><call><name>BitmapAdjustPrefetchIterator</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>tbmres</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * Ignore any claimed entries past what we think is the end of the
			 * relation.  (This is probably not necessary given that we got at
			 * least AccessShareLock on the table before performing any of the
			 * indexscans, but let's be safe.)
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>tbmres</name><operator>-&gt;</operator><name>blockno</name></name> <operator>&gt;=</operator> <name><name>scan</name><operator>-&gt;</operator><name>rs_nblocks</name></name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>tbmres</name></name> <operator>=</operator> <name>tbmres</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
				<continue>continue;</continue>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/*
			 * We can skip fetching the heap page if we don't need any fields
			 * from the heap, and the bitmap entries don't need rechecking,
			 * and all tuples on the page are visible to our transaction.
			 */</comment>
			<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>skip_fetch</name></name> <operator>=</operator> <operator>(</operator><name><name>node</name><operator>-&gt;</operator><name>can_skip_fetch</name></name> <operator>&amp;&amp;</operator>
								<operator>!</operator><name><name>tbmres</name><operator>-&gt;</operator><name>recheck</name></name> <operator>&amp;&amp;</operator>
								<call><name>VM_ALL_VISIBLE</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ss_currentRelation</name></name></expr></argument>,
											   <argument><expr><name><name>tbmres</name><operator>-&gt;</operator><name>blockno</name></name></expr></argument>,
											   <argument><expr><operator>&amp;</operator><name><name>node</name><operator>-&gt;</operator><name>vmbuffer</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</expr_stmt>
			<comment type="block">/* POLAR px : do not scan other's page/tuples */</comment>
			<if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>==</operator> <name><name>scan</name><operator>-&gt;</operator><name>px_scan</name></name></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>skip_fetch</name></name></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/*
					* The number of tuples on this page is put into
					* scan-&gt;rs_ntuples; note we don't fill scan-&gt;rs_vistuples.
					*/</comment>
					<expr_stmt><expr><name><name>scan</name><operator>-&gt;</operator><name>rs_ntuples</name></name> <operator>=</operator> <name><name>tbmres</name><operator>-&gt;</operator><name>ntuples</name></name></expr>;</expr_stmt>
				</block_content>}</block></if>
				<else>else
				<block>{<block_content>
					<comment type="block">/*
				 	* Fetch the current heap page and identify candidate tuples.
				 	*/</comment>
					<expr_stmt><expr><call><name>bitgetpage</name><argument_list>(<argument><expr><name>scan</name></expr></argument>, <argument><expr><name>tbmres</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></else></if_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<decl_stmt><decl><type><name>BlockNumber</name></type> <name>unitno</name> <init>= <expr><call><name>PXSCAN_BlockNum2UnitNum</name><argument_list>(<argument><expr><name><name>tbmres</name><operator>-&gt;</operator><name>blockno</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<if_stmt><if>if <condition>(<expr><operator>(</operator><name>unitno</name> <operator>%</operator> <name><name>scan</name><operator>-&gt;</operator><name>px_scan</name><operator>-&gt;</operator><name>pxs_total_workers</name></name><operator>)</operator> <operator>!=</operator> <name><name>scan</name><operator>-&gt;</operator><name>px_scan</name><operator>-&gt;</operator><name>pxs_worker_id</name></name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name><name>scan</name><operator>-&gt;</operator><name>rs_ntuples</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
				</block_content>}</block></if>
				<else>else
				<block>{<block_content>
					<if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>skip_fetch</name></name></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><name><name>scan</name><operator>-&gt;</operator><name>rs_ntuples</name></name> <operator>=</operator> <name><name>tbmres</name><operator>-&gt;</operator><name>ntuples</name></name></expr>;</expr_stmt>
					</block_content>}</block></if>
					<else>else
					<block>{<block_content>
						<expr_stmt><expr><call><name>bitgetpage</name><argument_list>(<argument><expr><name>scan</name></expr></argument>, <argument><expr><name>tbmres</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block></else></if_stmt>	
				</block_content>}</block></else></if_stmt>
			</block_content>}</block></else></if_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>tbmres</name><operator>-&gt;</operator><name>ntuples</name></name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>exact_pages</name></name><operator>++</operator></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>lossy_pages</name></name><operator>++</operator></expr>;</expr_stmt></block_content></block></else></if_stmt>

			<comment type="block">/*
			 * Set rs_cindex to first slot to examine
			 */</comment>
			<expr_stmt><expr><name><name>scan</name><operator>-&gt;</operator><name>rs_cindex</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

			<comment type="block">/* Adjust the prefetch target */</comment>
			<expr_stmt><expr><call><name>BitmapAdjustPrefetchTarget</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/*
			 * Continuing in previously obtained page; advance rs_cindex
			 */</comment>
			<expr_stmt><expr><name><name>scan</name><operator>-&gt;</operator><name>rs_cindex</name></name><operator>++</operator></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_PREFETCH</name></cpp:ifdef>

			<comment type="block">/*
			 * Try to prefetch at least a few pages even before we get to the
			 * second page if we don't stop reading after the first tuple.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>pstate</name></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>prefetch_target</name></name> <operator>&lt;</operator> <name><name>node</name><operator>-&gt;</operator><name>prefetch_maximum</name></name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>prefetch_target</name></name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block></if>
			<if type="elseif">else if <condition>(<expr><name><name>pstate</name><operator>-&gt;</operator><name>prefetch_target</name></name> <operator>&lt;</operator> <name><name>node</name><operator>-&gt;</operator><name>prefetch_maximum</name></name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* take spinlock while updating shared state */</comment>
				<expr_stmt><expr><call><name>SpinLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pstate</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name><name>pstate</name><operator>-&gt;</operator><name>prefetch_target</name></name> <operator>&lt;</operator> <name><name>node</name><operator>-&gt;</operator><name>prefetch_maximum</name></name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name><name>pstate</name><operator>-&gt;</operator><name>prefetch_target</name></name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<expr_stmt><expr><call><name>SpinLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pstate</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>							<comment type="block">/* USE_PREFETCH */</comment>
		</block_content>}</block></else></if_stmt>

		<comment type="block">/*
		 * Out of range?  If so, nothing more to look at on this page
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>scan</name><operator>-&gt;</operator><name>rs_cindex</name></name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator> <name><name>scan</name><operator>-&gt;</operator><name>rs_cindex</name></name> <operator>&gt;=</operator> <name><name>scan</name><operator>-&gt;</operator><name>rs_ntuples</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>tbmres</name></name> <operator>=</operator> <name>tbmres</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * We issue prefetch requests *after* fetching the current page to try
		 * to avoid having prefetching interfere with the main I/O. Also, this
		 * should happen only when we have determined there is still something
		 * to do on the current page, else we may uselessly prefetch the same
		 * page we are just about to request for real.
		 */</comment>
		<expr_stmt><expr><call><name>BitmapPrefetch</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>skip_fetch</name></name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * If we don't have to fetch the tuple, just return nulls.
			 */</comment>
			<expr_stmt><expr><call><name>ExecStoreAllNullTuple</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/*
			 * Okay to fetch the tuple.
			 */</comment>
			<expr_stmt><expr><name>targoffset</name> <operator>=</operator> <name><name>scan</name><operator>-&gt;</operator><name>rs_vistuples</name><index>[<expr><name><name>scan</name><operator>-&gt;</operator><name>rs_cindex</name></name></expr>]</index></name></expr>;</expr_stmt>
			<expr_stmt><expr><name>dp</name> <operator>=</operator> <operator>(</operator><name>Page</name><operator>)</operator> <call><name>BufferGetPage</name><argument_list>(<argument><expr><name><name>scan</name><operator>-&gt;</operator><name>rs_cbuf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>lp</name> <operator>=</operator> <call><name>PageGetItemId</name><argument_list>(<argument><expr><name>dp</name></expr></argument>, <argument><expr><name>targoffset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>ItemIdIsNormal</name><argument_list>(<argument><expr><name>lp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name><name>scan</name><operator>-&gt;</operator><name>rs_ctup</name><operator>.</operator><name>t_data</name></name> <operator>=</operator> <operator>(</operator><name>HeapTupleHeader</name><operator>)</operator> <call><name>PageGetItem</name><argument_list>(<argument><expr><operator>(</operator><name>Page</name><operator>)</operator> <name>dp</name></expr></argument>, <argument><expr><name>lp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>scan</name><operator>-&gt;</operator><name>rs_ctup</name><operator>.</operator><name>t_len</name></name> <operator>=</operator> <call><name>ItemIdGetLength</name><argument_list>(<argument><expr><name>lp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>scan</name><operator>-&gt;</operator><name>rs_ctup</name><operator>.</operator><name>t_tableOid</name></name> <operator>=</operator> <name><name>scan</name><operator>-&gt;</operator><name>rs_rd</name><operator>-&gt;</operator><name>rd_id</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>ItemPointerSet</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>scan</name><operator>-&gt;</operator><name>rs_ctup</name><operator>.</operator><name>t_self</name></name></expr></argument>, <argument><expr><name><name>tbmres</name><operator>-&gt;</operator><name>blockno</name></name></expr></argument>, <argument><expr><name>targoffset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>pgstat_count_heap_fetch</name><argument_list>(<argument><expr><name><name>scan</name><operator>-&gt;</operator><name>rs_rd</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * Set up the result slot to point to this tuple.  Note that the
			 * slot acquires a pin on the buffer.
			 */</comment>
			<expr_stmt><expr><call><name>ExecStoreTuple</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>scan</name><operator>-&gt;</operator><name>rs_ctup</name></name></expr></argument>,
						   <argument><expr><name>slot</name></expr></argument>,
						   <argument><expr><name><name>scan</name><operator>-&gt;</operator><name>rs_cbuf</name></name></expr></argument>,
						   <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * If we are using lossy info, we have to recheck the qual
			 * conditions at every tuple.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>tbmres</name><operator>-&gt;</operator><name>recheck</name></name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name><name>econtext</name><operator>-&gt;</operator><name>ecxt_scantuple</name></name> <operator>=</operator> <name>slot</name></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ExecQualAndReset</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>bitmapqualorig</name></name></expr></argument>, <argument><expr><name>econtext</name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/* Fails recheck, so drop it and loop back for another */</comment>
					<expr_stmt><expr><call><name>InstrCountFiltered2</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>ExecClearTuple</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<continue>continue;</continue>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></else></if_stmt>

		<comment type="block">/* OK to return this tuple */</comment>
		<return>return <expr><name>slot</name></expr>;</return>
	</block_content>}</block></for>

	<comment type="block">/*
	 * if we get here it means we are at the end of the scan..
	 */</comment>
	<return>return <expr><call><name>ExecClearTuple</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * bitgetpage - subroutine for BitmapHeapNext()
 *
 * This routine reads and pins the specified page of the relation, then
 * builds an array indicating which tuples on the page are both potentially
 * interesting according to the bitmap, and visible according to the snapshot.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>bitgetpage</name><parameter_list>(<parameter><decl><type><name>HeapScanDesc</name></type> <name>scan</name></decl></parameter>, <parameter><decl><type><name>TBMIterateResult</name> <modifier>*</modifier></type><name>tbmres</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>BlockNumber</name></type> <name>page</name> <init>= <expr><name><name>tbmres</name><operator>-&gt;</operator><name>blockno</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Buffer</name></type>		<name>buffer</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Snapshot</name></type>	<name>snapshot</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>ntup</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Acquire pin on the target heap page, trading in any pin we held before.
	 */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>page</name> <operator>&lt;</operator> <name><name>scan</name><operator>-&gt;</operator><name>rs_nblocks</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>scan</name><operator>-&gt;</operator><name>rs_cbuf</name></name> <operator>=</operator> <call><name>ReleaseAndReadBuffer</name><argument_list>(<argument><expr><name><name>scan</name><operator>-&gt;</operator><name>rs_cbuf</name></name></expr></argument>,
										 <argument><expr><name><name>scan</name><operator>-&gt;</operator><name>rs_rd</name></name></expr></argument>,
										 <argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>buffer</name> <operator>=</operator> <name><name>scan</name><operator>-&gt;</operator><name>rs_cbuf</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>snapshot</name> <operator>=</operator> <name><name>scan</name><operator>-&gt;</operator><name>rs_snapshot</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><name>ntup</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<comment type="block">/*
	 * Prune and repair fragmentation for the whole page, if possible.
	 */</comment>
	<expr_stmt><expr><call><name>heap_page_prune_opt</name><argument_list>(<argument><expr><name><name>scan</name><operator>-&gt;</operator><name>rs_rd</name></name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * We must hold share lock on the buffer content while examining tuple
	 * visibility.  Afterwards, however, the tuples we have found to be
	 * visible are guaranteed good as long as we hold the buffer pin.
	 */</comment>
	<expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>BUFFER_LOCK_SHARE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * We need two separate strategies for lossy and non-lossy cases.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>tbmres</name><operator>-&gt;</operator><name>ntuples</name></name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Bitmap is non-lossy, so we just look through the offsets listed in
		 * tbmres; but we have to follow any HOT chain starting at each such
		 * offset.
		 */</comment>
		<decl_stmt><decl><type><name>int</name></type>			<name>curslot</name></decl>;</decl_stmt>

		<for>for <control>(<init><expr><name>curslot</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>curslot</name> <operator>&lt;</operator> <name><name>tbmres</name><operator>-&gt;</operator><name>ntuples</name></name></expr>;</condition> <incr><expr><name>curslot</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>OffsetNumber</name></type> <name>offnum</name> <init>= <expr><name><name>tbmres</name><operator>-&gt;</operator><name>offsets</name><index>[<expr><name>curslot</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>ItemPointerData</name></type> <name>tid</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>HeapTupleData</name></type> <name>heapTuple</name></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>ItemPointerSet</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tid</name></expr></argument>, <argument><expr><name>page</name></expr></argument>, <argument><expr><name>offnum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><call><name>heap_hot_search_buffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tid</name></expr></argument>, <argument><expr><name><name>scan</name><operator>-&gt;</operator><name>rs_rd</name></name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>snapshot</name></expr></argument>,
									   <argument><expr><operator>&amp;</operator><name>heapTuple</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>scan</name><operator>-&gt;</operator><name>rs_vistuples</name><index>[<expr><name>ntup</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <call><name>ItemPointerGetOffsetNumber</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></for>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/*
		 * Bitmap is lossy, so we must examine each item pointer on the page.
		 * But we can ignore HOT chains, since we'll check each tuple anyway.
		 */</comment>
		<decl_stmt><decl><type><name>Page</name></type>		<name>dp</name> <init>= <expr><operator>(</operator><name>Page</name><operator>)</operator> <call><name>BufferGetPage</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>OffsetNumber</name></type> <name>maxoff</name> <init>= <expr><call><name>PageGetMaxOffsetNumber</name><argument_list>(<argument><expr><name>dp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>OffsetNumber</name></type> <name>offnum</name></decl>;</decl_stmt>

		<for>for <control>(<init><expr><name>offnum</name> <operator>=</operator> <name>FirstOffsetNumber</name></expr>;</init> <condition><expr><name>offnum</name> <operator>&lt;=</operator> <name>maxoff</name></expr>;</condition> <incr><expr><name>offnum</name> <operator>=</operator> <call><name>OffsetNumberNext</name><argument_list>(<argument><expr><name>offnum</name></expr></argument>)</argument_list></call></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>ItemId</name></type>		<name>lp</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>HeapTupleData</name></type> <name>loctup</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>bool</name></type>		<name>valid</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>lp</name> <operator>=</operator> <call><name>PageGetItemId</name><argument_list>(<argument><expr><name>dp</name></expr></argument>, <argument><expr><name>offnum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ItemIdIsNormal</name><argument_list>(<argument><expr><name>lp</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>
			<expr_stmt><expr><name><name>loctup</name><operator>.</operator><name>t_data</name></name> <operator>=</operator> <operator>(</operator><name>HeapTupleHeader</name><operator>)</operator> <call><name>PageGetItem</name><argument_list>(<argument><expr><operator>(</operator><name>Page</name><operator>)</operator> <name>dp</name></expr></argument>, <argument><expr><name>lp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>loctup</name><operator>.</operator><name>t_len</name></name> <operator>=</operator> <call><name>ItemIdGetLength</name><argument_list>(<argument><expr><name>lp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>loctup</name><operator>.</operator><name>t_tableOid</name></name> <operator>=</operator> <name><name>scan</name><operator>-&gt;</operator><name>rs_rd</name><operator>-&gt;</operator><name>rd_id</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>ItemPointerSet</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>loctup</name><operator>.</operator><name>t_self</name></name></expr></argument>, <argument><expr><name>page</name></expr></argument>, <argument><expr><name>offnum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>valid</name> <operator>=</operator> <call><name>HeapTupleSatisfiesVisibility</name><argument_list>(<argument><expr><operator>&amp;</operator><name>loctup</name></expr></argument>, <argument><expr><name>snapshot</name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>valid</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name><name>scan</name><operator>-&gt;</operator><name>rs_vistuples</name><index>[<expr><name>ntup</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>offnum</name></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>PredicateLockTuple</name><argument_list>(<argument><expr><name><name>scan</name><operator>-&gt;</operator><name>rs_rd</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>loctup</name></expr></argument>, <argument><expr><name>snapshot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			<expr_stmt><expr><call><name>CheckForSerializableConflictOut</name><argument_list>(<argument><expr><name>valid</name></expr></argument>, <argument><expr><name><name>scan</name><operator>-&gt;</operator><name>rs_rd</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>loctup</name></expr></argument>,
											<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>snapshot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></for>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>BUFFER_LOCK_UNLOCK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>ntup</name> <operator>&lt;=</operator> <name>MaxHeapTuplesPerPage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>scan</name><operator>-&gt;</operator><name>rs_ntuples</name></name> <operator>=</operator> <name>ntup</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 *	BitmapDoneInitializingSharedState - Shared state is initialized
 *
 *	By this time the leader has already populated the TBM and initialized the
 *	shared state so wake up other processes.
 */</comment>
<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type>
<name>BitmapDoneInitializingSharedState</name><parameter_list>(<parameter><decl><type><name>ParallelBitmapHeapState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>SpinLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pstate</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pstate</name><operator>-&gt;</operator><name>state</name></name> <operator>=</operator> <name>BM_FINISHED</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SpinLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pstate</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ConditionVariableBroadcast</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pstate</name><operator>-&gt;</operator><name>cv</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 *	BitmapAdjustPrefetchIterator - Adjust the prefetch iterator
 */</comment>
<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type>
<name>BitmapAdjustPrefetchIterator</name><parameter_list>(<parameter><decl><type><name>BitmapHeapScanState</name> <modifier>*</modifier></type><name>node</name></decl></parameter>,
							 <parameter><decl><type><name>TBMIterateResult</name> <modifier>*</modifier></type><name>tbmres</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_PREFETCH</name></cpp:ifdef>
	<decl_stmt><decl><type><name>ParallelBitmapHeapState</name> <modifier>*</modifier></type><name>pstate</name> <init>= <expr><name><name>node</name><operator>-&gt;</operator><name>pstate</name></name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>pstate</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>TBMIterator</name> <modifier>*</modifier></type><name>prefetch_iterator</name> <init>= <expr><name><name>node</name><operator>-&gt;</operator><name>prefetch_iterator</name></name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>prefetch_pages</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* The main iterator has closed the distance by one page */</comment>
			<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>prefetch_pages</name></name><operator>--</operator></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name>prefetch_iterator</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Do not let the prefetch iterator get behind the main one */</comment>
			<decl_stmt><decl><type><name>TBMIterateResult</name> <modifier>*</modifier></type><name>tbmpre</name> <init>= <expr><call><name>tbm_iterate</name><argument_list>(<argument><expr><name>prefetch_iterator</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name>tbmpre</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name><name>tbmpre</name><operator>-&gt;</operator><name>blockno</name></name> <operator>!=</operator> <name><name>tbmres</name><operator>-&gt;</operator><name>blockno</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"prefetch and main iterators are out of sync"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>prefetch_maximum</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>TBMSharedIterator</name> <modifier>*</modifier></type><name>prefetch_iterator</name> <init>= <expr><name><name>node</name><operator>-&gt;</operator><name>shared_prefetch_iterator</name></name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>SpinLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pstate</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>pstate</name><operator>-&gt;</operator><name>prefetch_pages</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>pstate</name><operator>-&gt;</operator><name>prefetch_pages</name></name><operator>--</operator></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>SpinLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pstate</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/* Release the mutex before iterating */</comment>
			<expr_stmt><expr><call><name>SpinLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pstate</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * In case of shared mode, we can not ensure that the current
			 * blockno of the main iterator and that of the prefetch iterator
			 * are same.  It's possible that whatever blockno we are
			 * prefetching will be processed by another process.  Therefore,
			 * we don't validate the blockno here as we do in non-parallel
			 * case.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name>prefetch_iterator</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>tbm_shared_iterate</name><argument_list>(<argument><expr><name>prefetch_iterator</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>							<comment type="block">/* USE_PREFETCH */</comment>
</block_content>}</block></function>

<comment type="block">/*
 * BitmapAdjustPrefetchTarget - Adjust the prefetch target
 *
 * Increase prefetch target if it's not yet at the max.  Note that
 * we will increase it to zero after fetching the very first
 * page/tuple, then to one after the second tuple is fetched, then
 * it doubles as later pages are fetched.
 */</comment>
<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type>
<name>BitmapAdjustPrefetchTarget</name><parameter_list>(<parameter><decl><type><name>BitmapHeapScanState</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_PREFETCH</name></cpp:ifdef>
	<decl_stmt><decl><type><name>ParallelBitmapHeapState</name> <modifier>*</modifier></type><name>pstate</name> <init>= <expr><name><name>node</name><operator>-&gt;</operator><name>pstate</name></name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>pstate</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>prefetch_target</name></name> <operator>&gt;=</operator> <name><name>node</name><operator>-&gt;</operator><name>prefetch_maximum</name></name></expr>)</condition><block type="pseudo"><block_content>
			 <comment type="block">/* don't increase any further */</comment> <empty_stmt>;</empty_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>prefetch_target</name></name> <operator>&gt;=</operator> <name><name>node</name><operator>-&gt;</operator><name>prefetch_maximum</name></name> <operator>/</operator> <literal type="number">2</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>prefetch_target</name></name> <operator>=</operator> <name><name>node</name><operator>-&gt;</operator><name>prefetch_maximum</name></name></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>prefetch_target</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>prefetch_target</name></name> <operator>*=</operator> <literal type="number">2</literal></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>prefetch_target</name></name><operator>++</operator></expr>;</expr_stmt></block_content></block></else></if_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Do an unlocked check first to save spinlock acquisitions. */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>pstate</name><operator>-&gt;</operator><name>prefetch_target</name></name> <operator>&lt;</operator> <name><name>node</name><operator>-&gt;</operator><name>prefetch_maximum</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>SpinLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pstate</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>pstate</name><operator>-&gt;</operator><name>prefetch_target</name></name> <operator>&gt;=</operator> <name><name>node</name><operator>-&gt;</operator><name>prefetch_maximum</name></name></expr>)</condition><block type="pseudo"><block_content>
			 <comment type="block">/* don't increase any further */</comment> <empty_stmt>;</empty_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><name><name>pstate</name><operator>-&gt;</operator><name>prefetch_target</name></name> <operator>&gt;=</operator> <name><name>node</name><operator>-&gt;</operator><name>prefetch_maximum</name></name> <operator>/</operator> <literal type="number">2</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>pstate</name><operator>-&gt;</operator><name>prefetch_target</name></name> <operator>=</operator> <name><name>node</name><operator>-&gt;</operator><name>prefetch_maximum</name></name></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><name><name>pstate</name><operator>-&gt;</operator><name>prefetch_target</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>pstate</name><operator>-&gt;</operator><name>prefetch_target</name></name> <operator>*=</operator> <literal type="number">2</literal></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>pstate</name><operator>-&gt;</operator><name>prefetch_target</name></name><operator>++</operator></expr>;</expr_stmt></block_content></block></else></if_stmt>
		<expr_stmt><expr><call><name>SpinLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pstate</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>							<comment type="block">/* USE_PREFETCH */</comment>
</block_content>}</block></function>

<comment type="block">/*
 * BitmapPrefetch - Prefetch, if prefetch_pages are behind prefetch_target
 */</comment>
<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type>
<name>BitmapPrefetch</name><parameter_list>(<parameter><decl><type><name>BitmapHeapScanState</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>HeapScanDesc</name></type> <name>scan</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_PREFETCH</name></cpp:ifdef>
	<decl_stmt><decl><type><name>ParallelBitmapHeapState</name> <modifier>*</modifier></type><name>pstate</name> <init>= <expr><name><name>node</name><operator>-&gt;</operator><name>pstate</name></name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>pstate</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>TBMIterator</name> <modifier>*</modifier></type><name>prefetch_iterator</name> <init>= <expr><name><name>node</name><operator>-&gt;</operator><name>prefetch_iterator</name></name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>prefetch_iterator</name></expr>)</condition>
		<block>{<block_content>
			<while>while <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>prefetch_pages</name></name> <operator>&lt;</operator> <name><name>node</name><operator>-&gt;</operator><name>prefetch_target</name></name></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>TBMIterateResult</name> <modifier>*</modifier></type><name>tbmpre</name> <init>= <expr><call><name>tbm_iterate</name><argument_list>(<argument><expr><name>prefetch_iterator</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>bool</name></type>		<name>skip_fetch</name></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><name>tbmpre</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/* No more pages to prefetch */</comment>
					<expr_stmt><expr><call><name>tbm_end_iterate</name><argument_list>(<argument><expr><name>prefetch_iterator</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>prefetch_iterator</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
					<break>break;</break>
				</block_content>}</block></if></if_stmt>
				<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>prefetch_pages</name></name><operator>++</operator></expr>;</expr_stmt>

				<comment type="block">/*
				 * If we expect not to have to actually read this heap page,
				 * skip this prefetch call, but continue to run the prefetch
				 * logic normally.  (Would it be better not to increment
				 * prefetch_pages?)
				 *
				 * This depends on the assumption that the index AM will
				 * report the same recheck flag for this future heap page as
				 * it did for the current heap page; which is not a certainty
				 * but is true in many cases.
				 */</comment>
				<expr_stmt><expr><name>skip_fetch</name> <operator>=</operator> <operator>(</operator><name><name>node</name><operator>-&gt;</operator><name>can_skip_fetch</name></name> <operator>&amp;&amp;</operator>
							  <operator>(</operator><ternary><condition><expr><name><name>node</name><operator>-&gt;</operator><name>tbmres</name></name></expr> ?</condition><then> <expr><operator>!</operator><name><name>node</name><operator>-&gt;</operator><name>tbmres</name><operator>-&gt;</operator><name>recheck</name></name></expr> </then><else>: <expr><name>false</name></expr></else></ternary><operator>)</operator> <operator>&amp;&amp;</operator>
							  <call><name>VM_ALL_VISIBLE</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ss_currentRelation</name></name></expr></argument>,
											 <argument><expr><name><name>tbmpre</name><operator>-&gt;</operator><name>blockno</name></name></expr></argument>,
											 <argument><expr><operator>&amp;</operator><name><name>node</name><operator>-&gt;</operator><name>pvmbuffer</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</expr_stmt>

				<if_stmt><if>if <condition>(<expr><operator>!</operator><name>skip_fetch</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>PrefetchBuffer</name><argument_list>(<argument><expr><name><name>scan</name><operator>-&gt;</operator><name>rs_rd</name></name></expr></argument>, <argument><expr><name>MAIN_FORKNUM</name></expr></argument>, <argument><expr><name><name>tbmpre</name><operator>-&gt;</operator><name>blockno</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block></while>
		</block_content>}</block></if></if_stmt>

		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>pstate</name><operator>-&gt;</operator><name>prefetch_pages</name></name> <operator>&lt;</operator> <name><name>pstate</name><operator>-&gt;</operator><name>prefetch_target</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>TBMSharedIterator</name> <modifier>*</modifier></type><name>prefetch_iterator</name> <init>= <expr><name><name>node</name><operator>-&gt;</operator><name>shared_prefetch_iterator</name></name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>prefetch_iterator</name></expr>)</condition>
		<block>{<block_content>
			<while>while <condition>(<expr><literal type="number">1</literal></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>TBMIterateResult</name> <modifier>*</modifier></type><name>tbmpre</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>bool</name></type>		<name>do_prefetch</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>bool</name></type>		<name>skip_fetch</name></decl>;</decl_stmt>

				<comment type="block">/*
				 * Recheck under the mutex. If some other process has already
				 * done enough prefetching then we need not to do anything.
				 */</comment>
				<expr_stmt><expr><call><name>SpinLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pstate</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name><name>pstate</name><operator>-&gt;</operator><name>prefetch_pages</name></name> <operator>&lt;</operator> <name><name>pstate</name><operator>-&gt;</operator><name>prefetch_target</name></name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name><name>pstate</name><operator>-&gt;</operator><name>prefetch_pages</name></name><operator>++</operator></expr>;</expr_stmt>
					<expr_stmt><expr><name>do_prefetch</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
				<expr_stmt><expr><call><name>SpinLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pstate</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<if_stmt><if>if <condition>(<expr><operator>!</operator><name>do_prefetch</name></expr>)</condition><block type="pseudo"><block_content>
					<return>return;</return></block_content></block></if></if_stmt>

				<expr_stmt><expr><name>tbmpre</name> <operator>=</operator> <call><name>tbm_shared_iterate</name><argument_list>(<argument><expr><name>prefetch_iterator</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name>tbmpre</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/* No more pages to prefetch */</comment>
					<expr_stmt><expr><call><name>tbm_end_shared_iterate</name><argument_list>(<argument><expr><name>prefetch_iterator</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>shared_prefetch_iterator</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
					<break>break;</break>
				</block_content>}</block></if></if_stmt>

				<comment type="block">/* As above, skip prefetch if we expect not to need page */</comment>
				<expr_stmt><expr><name>skip_fetch</name> <operator>=</operator> <operator>(</operator><name><name>node</name><operator>-&gt;</operator><name>can_skip_fetch</name></name> <operator>&amp;&amp;</operator>
							  <operator>(</operator><ternary><condition><expr><name><name>node</name><operator>-&gt;</operator><name>tbmres</name></name></expr> ?</condition><then> <expr><operator>!</operator><name><name>node</name><operator>-&gt;</operator><name>tbmres</name><operator>-&gt;</operator><name>recheck</name></name></expr> </then><else>: <expr><name>false</name></expr></else></ternary><operator>)</operator> <operator>&amp;&amp;</operator>
							  <call><name>VM_ALL_VISIBLE</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ss_currentRelation</name></name></expr></argument>,
											 <argument><expr><name><name>tbmpre</name><operator>-&gt;</operator><name>blockno</name></name></expr></argument>,
											 <argument><expr><operator>&amp;</operator><name><name>node</name><operator>-&gt;</operator><name>pvmbuffer</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</expr_stmt>

				<if_stmt><if>if <condition>(<expr><operator>!</operator><name>skip_fetch</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>PrefetchBuffer</name><argument_list>(<argument><expr><name><name>scan</name><operator>-&gt;</operator><name>rs_rd</name></name></expr></argument>, <argument><expr><name>MAIN_FORKNUM</name></expr></argument>, <argument><expr><name><name>tbmpre</name><operator>-&gt;</operator><name>blockno</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block></while>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>							<comment type="block">/* USE_PREFETCH */</comment>
</block_content>}</block></function>

<comment type="block">/*
 * BitmapHeapRecheck -- access method routine to recheck a tuple in EvalPlanQual
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>BitmapHeapRecheck</name><parameter_list>(<parameter><decl><type><name>BitmapHeapScanState</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ExprContext</name> <modifier>*</modifier></type><name>econtext</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * extract necessary information from index scan node
	 */</comment>
	<expr_stmt><expr><name>econtext</name> <operator>=</operator> <name><name>node</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ps</name><operator>.</operator><name>ps_ExprContext</name></name></expr>;</expr_stmt>

	<comment type="block">/* Does the tuple meet the original qual conditions? */</comment>
	<expr_stmt><expr><name><name>econtext</name><operator>-&gt;</operator><name>ecxt_scantuple</name></name> <operator>=</operator> <name>slot</name></expr>;</expr_stmt>
	<return>return <expr><call><name>ExecQualAndReset</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>bitmapqualorig</name></name></expr></argument>, <argument><expr><name>econtext</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* ----------------------------------------------------------------
 *		ExecBitmapHeapScan(node)
 * ----------------------------------------------------------------
 */</comment>
<function><type><specifier>static</specifier> <name>TupleTableSlot</name> <modifier>*</modifier></type>
<name>ExecBitmapHeapScan</name><parameter_list>(<parameter><decl><type><name>PlanState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>BitmapHeapScanState</name> <modifier>*</modifier></type><name>node</name> <init>= <expr><call><name>castNode</name><argument_list>(<argument><expr><name>BitmapHeapScanState</name></expr></argument>, <argument><expr><name>pstate</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<return>return <expr><call><name>ExecScan</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>node</name><operator>-&gt;</operator><name>ss</name></name></expr></argument>,
					<argument><expr><operator>(</operator><name>ExecScanAccessMtd</name><operator>)</operator> <name>BitmapHeapNext</name></expr></argument>,
					<argument><expr><operator>(</operator><name>ExecScanRecheckMtd</name><operator>)</operator> <name>BitmapHeapRecheck</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* ----------------------------------------------------------------
 *		ExecReScanBitmapHeapScan(node)
 * ----------------------------------------------------------------
 */</comment>
<function><type><name>void</name></type>
<name>ExecReScanBitmapHeapScan</name><parameter_list>(<parameter><decl><type><name>BitmapHeapScanState</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PlanState</name>  <modifier>*</modifier></type><name>outerPlan</name> <init>= <expr><call><name>outerPlanState</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/* rescan to release any page pin */</comment>
	<expr_stmt><expr><call><name>heap_rescan</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ss_currentScanDesc</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* release bitmaps and buffers if any */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>tbmiterator</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>tbm_end_iterate</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>tbmiterator</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>prefetch_iterator</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>tbm_end_iterate</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>prefetch_iterator</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>shared_tbmiterator</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>tbm_end_shared_iterate</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>shared_tbmiterator</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>shared_prefetch_iterator</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>tbm_end_shared_iterate</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>shared_prefetch_iterator</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>tbm</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>tbm_free</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>tbm</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>vmbuffer</name></name> <operator>!=</operator> <name>InvalidBuffer</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ReleaseBuffer</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>vmbuffer</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>pvmbuffer</name></name> <operator>!=</operator> <name>InvalidBuffer</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ReleaseBuffer</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>pvmbuffer</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>tbm</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>tbmiterator</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>tbmres</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>prefetch_iterator</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>initialized</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>shared_tbmiterator</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>shared_prefetch_iterator</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>vmbuffer</name></name> <operator>=</operator> <name>InvalidBuffer</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>pvmbuffer</name></name> <operator>=</operator> <name>InvalidBuffer</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ExecScanReScan</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>node</name><operator>-&gt;</operator><name>ss</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * if chgParam of subnode is not null then plan will be re-scanned by
	 * first ExecProcNode.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>outerPlan</name><operator>-&gt;</operator><name>chgParam</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ExecReScan</name><argument_list>(<argument><expr><name>outerPlan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/* ----------------------------------------------------------------
 *		ExecEndBitmapHeapScan
 * ----------------------------------------------------------------
 */</comment>
<function><type><name>void</name></type>
<name>ExecEndBitmapHeapScan</name><parameter_list>(<parameter><decl><type><name>BitmapHeapScanState</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>relation</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapScanDesc</name></type> <name>scanDesc</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * extract information from the node
	 */</comment>
	<expr_stmt><expr><name>relation</name> <operator>=</operator> <name><name>node</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ss_currentRelation</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>scanDesc</name> <operator>=</operator> <name><name>node</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ss_currentScanDesc</name></name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Free the exprcontext
	 */</comment>
	<expr_stmt><expr><call><name>ExecFreeExprContext</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>node</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ps</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * clear out tuple table slots
	 */</comment>
	<expr_stmt><expr><call><name>ExecClearTuple</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ps</name><operator>.</operator><name>ps_ResultTupleSlot</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ExecClearTuple</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ss_ScanTupleSlot</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * close down subplans
	 */</comment>
	<expr_stmt><expr><call><name>ExecEndNode</name><argument_list>(<argument><expr><call><name>outerPlanState</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * release bitmaps and buffers if any
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>tbmiterator</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>tbm_end_iterate</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>tbmiterator</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>prefetch_iterator</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>tbm_end_iterate</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>prefetch_iterator</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>tbm</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>tbm_free</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>tbm</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>shared_tbmiterator</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>tbm_end_shared_iterate</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>shared_tbmiterator</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>shared_prefetch_iterator</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>tbm_end_shared_iterate</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>shared_prefetch_iterator</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>vmbuffer</name></name> <operator>!=</operator> <name>InvalidBuffer</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ReleaseBuffer</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>vmbuffer</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>pvmbuffer</name></name> <operator>!=</operator> <name>InvalidBuffer</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ReleaseBuffer</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>pvmbuffer</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * close heap scan
	 */</comment>
	<expr_stmt><expr><call><name>heap_endscan</name><argument_list>(<argument><expr><name>scanDesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * close the heap relation.
	 */</comment>
	<expr_stmt><expr><call><name>ExecCloseScanRelation</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* ----------------------------------------------------------------
 *		ExecInitBitmapHeapScan
 *
 *		Initializes the scan's state information.
 * ----------------------------------------------------------------
 */</comment>
<function><type><name>BitmapHeapScanState</name> <modifier>*</modifier></type>
<name>ExecInitBitmapHeapScan</name><parameter_list>(<parameter><decl><type><name>BitmapHeapScan</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>EState</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>eflags</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>BitmapHeapScanState</name> <modifier>*</modifier></type><name>scanstate</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>currentRelation</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>io_concurrency</name></decl>;</decl_stmt>

	<comment type="block">/* check for unsupported flags */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><operator>(</operator><name>eflags</name> <operator>&amp;</operator> <operator>(</operator><name>EXEC_FLAG_BACKWARD</name> <operator>|</operator> <name>EXEC_FLAG_MARK</name><operator>)</operator><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Assert caller didn't ask for an unsafe snapshot --- see comments at
	 * head of file.
	 */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>IsMVCCSnapshot</name><argument_list>(<argument><expr><name><name>estate</name><operator>-&gt;</operator><name>es_snapshot</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * create state structure
	 */</comment>
	<expr_stmt><expr><name>scanstate</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>BitmapHeapScanState</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>scanstate</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ps</name><operator>.</operator><name>plan</name></name> <operator>=</operator> <operator>(</operator><name>Plan</name> <operator>*</operator><operator>)</operator> <name>node</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>scanstate</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ps</name><operator>.</operator><name>state</name></name> <operator>=</operator> <name>estate</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>scanstate</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ps</name><operator>.</operator><name>ExecProcNode</name></name> <operator>=</operator> <name>ExecBitmapHeapScan</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>scanstate</name><operator>-&gt;</operator><name>tbm</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>scanstate</name><operator>-&gt;</operator><name>tbmiterator</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>scanstate</name><operator>-&gt;</operator><name>tbmres</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>scanstate</name><operator>-&gt;</operator><name>skip_fetch</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>scanstate</name><operator>-&gt;</operator><name>vmbuffer</name></name> <operator>=</operator> <name>InvalidBuffer</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>scanstate</name><operator>-&gt;</operator><name>pvmbuffer</name></name> <operator>=</operator> <name>InvalidBuffer</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>scanstate</name><operator>-&gt;</operator><name>exact_pages</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>scanstate</name><operator>-&gt;</operator><name>lossy_pages</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>scanstate</name><operator>-&gt;</operator><name>prefetch_iterator</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>scanstate</name><operator>-&gt;</operator><name>prefetch_pages</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>scanstate</name><operator>-&gt;</operator><name>prefetch_target</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<comment type="block">/* may be updated below */</comment>
	<expr_stmt><expr><name><name>scanstate</name><operator>-&gt;</operator><name>prefetch_maximum</name></name> <operator>=</operator> <name>target_prefetch_pages</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>scanstate</name><operator>-&gt;</operator><name>pscan_len</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>scanstate</name><operator>-&gt;</operator><name>initialized</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>scanstate</name><operator>-&gt;</operator><name>shared_tbmiterator</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>scanstate</name><operator>-&gt;</operator><name>shared_prefetch_iterator</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>scanstate</name><operator>-&gt;</operator><name>pstate</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * We can potentially skip fetching heap pages if we do not need any
	 * columns of the table, either for checking non-indexable quals or for
	 * returning data.  This test is a bit simplistic, as it checks the
	 * stronger condition that there's no qual or return tlist at all.  But in
	 * most cases it's probably not worth working harder than that.
	 */</comment>
	<expr_stmt><expr><name><name>scanstate</name><operator>-&gt;</operator><name>can_skip_fetch</name></name> <operator>=</operator> <operator>(</operator><name><name>node</name><operator>-&gt;</operator><name>scan</name><operator>.</operator><name>plan</name><operator>.</operator><name>qual</name></name> <operator>==</operator> <name>NIL</name> <operator>&amp;&amp;</operator>
								 <name><name>node</name><operator>-&gt;</operator><name>scan</name><operator>.</operator><name>plan</name><operator>.</operator><name>targetlist</name></name> <operator>==</operator> <name>NIL</name><operator>)</operator></expr>;</expr_stmt>

	<comment type="block">/*
	 * Miscellaneous initialization
	 *
	 * create expression context for node
	 */</comment>
	<expr_stmt><expr><call><name>ExecAssignExprContext</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>scanstate</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ps</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * open the base relation and acquire appropriate lock on it.
	 */</comment>
	<expr_stmt><expr><name>currentRelation</name> <operator>=</operator> <call><name>ExecOpenScanRelation</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>scan</name><operator>.</operator><name>scanrelid</name></name></expr></argument>, <argument><expr><name>eflags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * initialize child nodes
	 *
	 * We do this after ExecOpenScanRelation because the child nodes will open
	 * indexscans on our relation's indexes, and we want to be sure we have
	 * acquired a lock on the relation first.
	 */</comment>
	<expr_stmt><expr><call><name>outerPlanState</name><argument_list>(<argument><expr><name>scanstate</name></expr></argument>)</argument_list></call> <operator>=</operator> <call><name>ExecInitNode</name><argument_list>(<argument><expr><call><name>outerPlan</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>estate</name></expr></argument>, <argument><expr><name>eflags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * get the scan type from the relation descriptor.
	 */</comment>
	<expr_stmt><expr><call><name>ExecInitScanTupleSlot</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>scanstate</name><operator>-&gt;</operator><name>ss</name></name></expr></argument>,
						  <argument><expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>currentRelation</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>


	<comment type="block">/*
	 * Initialize result slot, type and projection.
	 */</comment>
	<expr_stmt><expr><call><name>ExecInitResultTupleSlotTL</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>scanstate</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ps</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ExecAssignScanProjectionInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>scanstate</name><operator>-&gt;</operator><name>ss</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * initialize child expressions
	 */</comment>
	<expr_stmt><expr><name><name>scanstate</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ps</name><operator>.</operator><name>qual</name></name> <operator>=</operator>
		<call><name>ExecInitQual</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>scan</name><operator>.</operator><name>plan</name><operator>.</operator><name>qual</name></name></expr></argument>, <argument><expr><operator>(</operator><name>PlanState</name> <operator>*</operator><operator>)</operator> <name>scanstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>scanstate</name><operator>-&gt;</operator><name>bitmapqualorig</name></name> <operator>=</operator>
		<call><name>ExecInitQual</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>bitmapqualorig</name></name></expr></argument>, <argument><expr><operator>(</operator><name>PlanState</name> <operator>*</operator><operator>)</operator> <name>scanstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Determine the maximum for prefetch_target.  If the tablespace has a
	 * specific IO concurrency set, use that to compute the corresponding
	 * maximum value; otherwise, we already initialized to the value computed
	 * by the GUC machinery.
	 */</comment>
	<expr_stmt><expr><name>io_concurrency</name> <operator>=</operator>
		<call><name>get_tablespace_io_concurrency</name><argument_list>(<argument><expr><name><name>currentRelation</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>reltablespace</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>io_concurrency</name> <operator>!=</operator> <name>effective_io_concurrency</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>double</name></type>		<name>maximum</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>ComputeIoConcurrency</name><argument_list>(<argument><expr><name>io_concurrency</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>maximum</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>scanstate</name><operator>-&gt;</operator><name>prefetch_maximum</name></name> <operator>=</operator> <call><name>rint</name><argument_list>(<argument><expr><name>maximum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name><name>scanstate</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ss_currentRelation</name></name> <operator>=</operator> <name>currentRelation</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Even though we aren't going to do a conventional seqscan, it is useful
	 * to create a HeapScanDesc --- most of the fields in it are usable.
	 */</comment>
	<comment type="block">/* POLAR px */</comment>
	<if_stmt><if>if <condition>(<expr><name>px_role</name> <operator>==</operator> <name>PX_ROLE_PX</name> <operator>&amp;&amp;</operator>
		<name>px_is_executing</name> <operator>&amp;&amp;</operator>
		<name><name>scanstate</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ps</name><operator>.</operator><name>plan</name><operator>-&gt;</operator><name>px_scan_partial</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>scanstate</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ss_currentScanDesc</name></name> <operator>=</operator> <call><name>heap_beginscan_bm_px</name><argument_list>(<argument><expr><name>currentRelation</name></expr></argument>,
														 <argument><expr><name><name>estate</name><operator>-&gt;</operator><name>es_snapshot</name></name></expr></argument>,
														 <argument><expr><literal type="number">0</literal></expr></argument>,
														 <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name><name>scanstate</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ss_currentScanDesc</name></name> <operator>=</operator> <call><name>heap_beginscan_bm</name><argument_list>(<argument><expr><name>currentRelation</name></expr></argument>,
														 <argument><expr><name><name>estate</name><operator>-&gt;</operator><name>es_snapshot</name></name></expr></argument>,
														 <argument><expr><literal type="number">0</literal></expr></argument>,
														 <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
	<comment type="block">/* POLAR end */</comment>
	

	<comment type="block">/*
	 * all done.
	 */</comment>
	<return>return <expr><name>scanstate</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*----------------
 *		BitmapShouldInitializeSharedState
 *
 *		The first process to come here and see the state to the BM_INITIAL
 *		will become the leader for the parallel bitmap scan and will be
 *		responsible for populating the TIDBitmap.  The other processes will
 *		be blocked by the condition variable until the leader wakes them up.
 * ---------------
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>BitmapShouldInitializeSharedState</name><parameter_list>(<parameter><decl><type><name>ParallelBitmapHeapState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>SharedBitmapState</name></type> <name>state</name></decl>;</decl_stmt>

	<while>while <condition>(<expr><literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>SpinLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pstate</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>state</name> <operator>=</operator> <name><name>pstate</name><operator>-&gt;</operator><name>state</name></name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>pstate</name><operator>-&gt;</operator><name>state</name></name> <operator>==</operator> <name>BM_INITIAL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>pstate</name><operator>-&gt;</operator><name>state</name></name> <operator>=</operator> <name>BM_INPROGRESS</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>SpinLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pstate</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Exit if bitmap is done, or if we're the leader. */</comment>
		<if_stmt><if>if <condition>(<expr><name>state</name> <operator>!=</operator> <name>BM_INPROGRESS</name></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>

		<comment type="block">/* Wait for the leader to wake us up. */</comment>
		<expr_stmt><expr><call><name>ConditionVariableSleep</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pstate</name><operator>-&gt;</operator><name>cv</name></name></expr></argument>, <argument><expr><name>WAIT_EVENT_PARALLEL_BITMAP_SCAN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></while>

	<expr_stmt><expr><call><name>ConditionVariableCancelSleep</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><operator>(</operator><name>state</name> <operator>==</operator> <name>BM_INITIAL</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* ----------------------------------------------------------------
 *		ExecBitmapHeapEstimate
 *
 *		Compute the amount of space we'll need in the parallel
 *		query DSM, and inform pcxt-&gt;estimator about our needs.
 * ----------------------------------------------------------------
 */</comment>
<function><type><name>void</name></type>
<name>ExecBitmapHeapEstimate</name><parameter_list>(<parameter><decl><type><name>BitmapHeapScanState</name> <modifier>*</modifier></type><name>node</name></decl></parameter>,
					   <parameter><decl><type><name>ParallelContext</name> <modifier>*</modifier></type><name>pcxt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>EState</name>	   <modifier>*</modifier></type><name>estate</name> <init>= <expr><name><name>node</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ps</name><operator>.</operator><name>state</name></name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>pscan_len</name></name> <operator>=</operator> <call><name>add_size</name><argument_list>(<argument><expr><call><name>offsetof</name><argument_list>(<argument><expr><name>ParallelBitmapHeapState</name></expr></argument>,
										<argument><expr><name>phs_snapshot_data</name></expr></argument>)</argument_list></call></expr></argument>,
							   <argument><expr><call><name>EstimateSnapshotSpace</name><argument_list>(<argument><expr><name><name>estate</name><operator>-&gt;</operator><name>es_snapshot</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>shm_toc_estimate_chunk</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pcxt</name><operator>-&gt;</operator><name>estimator</name></name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>pscan_len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>shm_toc_estimate_keys</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pcxt</name><operator>-&gt;</operator><name>estimator</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* ----------------------------------------------------------------
 *		ExecBitmapHeapInitializeDSM
 *
 *		Set up a parallel bitmap heap scan descriptor.
 * ----------------------------------------------------------------
 */</comment>
<function><type><name>void</name></type>
<name>ExecBitmapHeapInitializeDSM</name><parameter_list>(<parameter><decl><type><name>BitmapHeapScanState</name> <modifier>*</modifier></type><name>node</name></decl></parameter>,
							<parameter><decl><type><name>ParallelContext</name> <modifier>*</modifier></type><name>pcxt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ParallelBitmapHeapState</name> <modifier>*</modifier></type><name>pstate</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>EState</name>	   <modifier>*</modifier></type><name>estate</name> <init>= <expr><name><name>node</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ps</name><operator>.</operator><name>state</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>dsa_area</name>   <modifier>*</modifier></type><name>dsa</name> <init>= <expr><name><name>node</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ps</name><operator>.</operator><name>state</name><operator>-&gt;</operator><name>es_query_dsa</name></name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* If there's no DSA, there are no workers; initialize nothing. */</comment>
	<if_stmt><if>if <condition>(<expr><name>dsa</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>pstate</name> <operator>=</operator> <call><name>shm_toc_allocate</name><argument_list>(<argument><expr><name><name>pcxt</name><operator>-&gt;</operator><name>toc</name></name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>pscan_len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>pstate</name><operator>-&gt;</operator><name>tbmiterator</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pstate</name><operator>-&gt;</operator><name>prefetch_iterator</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<comment type="block">/* Initialize the mutex */</comment>
	<expr_stmt><expr><call><name>SpinLockInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pstate</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pstate</name><operator>-&gt;</operator><name>prefetch_pages</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pstate</name><operator>-&gt;</operator><name>prefetch_target</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pstate</name><operator>-&gt;</operator><name>state</name></name> <operator>=</operator> <name>BM_INITIAL</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ConditionVariableInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pstate</name><operator>-&gt;</operator><name>cv</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SerializeSnapshot</name><argument_list>(<argument><expr><name><name>estate</name><operator>-&gt;</operator><name>es_snapshot</name></name></expr></argument>, <argument><expr><name><name>pstate</name><operator>-&gt;</operator><name>phs_snapshot_data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>shm_toc_insert</name><argument_list>(<argument><expr><name><name>pcxt</name><operator>-&gt;</operator><name>toc</name></name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ps</name><operator>.</operator><name>plan</name><operator>-&gt;</operator><name>plan_node_id</name></name></expr></argument>, <argument><expr><name>pstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>pstate</name></name> <operator>=</operator> <name>pstate</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* ----------------------------------------------------------------
 *		ExecBitmapHeapReInitializeDSM
 *
 *		Reset shared state before beginning a fresh scan.
 * ----------------------------------------------------------------
 */</comment>
<function><type><name>void</name></type>
<name>ExecBitmapHeapReInitializeDSM</name><parameter_list>(<parameter><decl><type><name>BitmapHeapScanState</name> <modifier>*</modifier></type><name>node</name></decl></parameter>,
							  <parameter><decl><type><name>ParallelContext</name> <modifier>*</modifier></type><name>pcxt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ParallelBitmapHeapState</name> <modifier>*</modifier></type><name>pstate</name> <init>= <expr><name><name>node</name><operator>-&gt;</operator><name>pstate</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>dsa_area</name>   <modifier>*</modifier></type><name>dsa</name> <init>= <expr><name><name>node</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ps</name><operator>.</operator><name>state</name><operator>-&gt;</operator><name>es_query_dsa</name></name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* If there's no DSA, there are no workers; do nothing. */</comment>
	<if_stmt><if>if <condition>(<expr><name>dsa</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name><name>pstate</name><operator>-&gt;</operator><name>state</name></name> <operator>=</operator> <name>BM_INITIAL</name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>DsaPointerIsValid</name><argument_list>(<argument><expr><name><name>pstate</name><operator>-&gt;</operator><name>tbmiterator</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>tbm_free_shared_area</name><argument_list>(<argument><expr><name>dsa</name></expr></argument>, <argument><expr><name><name>pstate</name><operator>-&gt;</operator><name>tbmiterator</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>DsaPointerIsValid</name><argument_list>(<argument><expr><name><name>pstate</name><operator>-&gt;</operator><name>prefetch_iterator</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>tbm_free_shared_area</name><argument_list>(<argument><expr><name>dsa</name></expr></argument>, <argument><expr><name><name>pstate</name><operator>-&gt;</operator><name>prefetch_iterator</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name><name>pstate</name><operator>-&gt;</operator><name>tbmiterator</name></name> <operator>=</operator> <name>InvalidDsaPointer</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pstate</name><operator>-&gt;</operator><name>prefetch_iterator</name></name> <operator>=</operator> <name>InvalidDsaPointer</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* ----------------------------------------------------------------
 *		ExecBitmapHeapInitializeWorker
 *
 *		Copy relevant information from TOC into planstate.
 * ----------------------------------------------------------------
 */</comment>
<function><type><name>void</name></type>
<name>ExecBitmapHeapInitializeWorker</name><parameter_list>(<parameter><decl><type><name>BitmapHeapScanState</name> <modifier>*</modifier></type><name>node</name></decl></parameter>,
							   <parameter><decl><type><name>ParallelWorkerContext</name> <modifier>*</modifier></type><name>pwcxt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ParallelBitmapHeapState</name> <modifier>*</modifier></type><name>pstate</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Snapshot</name></type>	<name>snapshot</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ps</name><operator>.</operator><name>state</name><operator>-&gt;</operator><name>es_query_dsa</name></name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>pstate</name> <operator>=</operator> <call><name>shm_toc_lookup</name><argument_list>(<argument><expr><name><name>pwcxt</name><operator>-&gt;</operator><name>toc</name></name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ps</name><operator>.</operator><name>plan</name><operator>-&gt;</operator><name>plan_node_id</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>pstate</name></name> <operator>=</operator> <name>pstate</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>snapshot</name> <operator>=</operator> <call><name>RestoreSnapshot</name><argument_list>(<argument><expr><name><name>pstate</name><operator>-&gt;</operator><name>phs_snapshot_data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>heap_update_snapshot</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ss_currentScanDesc</name></name></expr></argument>, <argument><expr><name>snapshot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
</unit>
