<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/PolarDB-for-PostgreSQL/src/backend/executor/execMain_px.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * execMain_px.c
 *	  Standard execution function for PolarDB PX.
 *
 * Copyright (c) 2020, Alibaba Group Holding Limited
 * 
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * IDENTIFICATION
 *	  src/backend/executor/execMain_px.c
 *
 *-------------------------------------------------------------------------
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/ps_status.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"px/px_disp.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"px/px_adaptive_paging.h"</cpp:file></cpp:include>

<comment type="block">/* ----------------------------------------------------------------
 *		POLAR px functions
 * ----------------------------------------------------------------
 */</comment>

<function><type><name>bool</name></type>
<name>should_px_executor</name><parameter_list>(<parameter><decl><type><name>QueryDesc</name> <modifier>*</modifier></type><name>queryDesc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
		<return>return <expr><name>queryDesc</name> <operator>&amp;&amp;</operator>
				<name><name>queryDesc</name><operator>-&gt;</operator><name>plannedstmt</name></name> <operator>&amp;&amp;</operator>
				<name>PLANGEN_PX</name> <operator>==</operator> <name><name>queryDesc</name><operator>-&gt;</operator><name>plannedstmt</name><operator>-&gt;</operator><name>planGen</name></name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>standard_ExecutorStart_PX</name><parameter_list>(<parameter><decl><type><name>QueryDesc</name> <modifier>*</modifier></type><name>queryDesc</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>eflags</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>EState</name>	   <modifier>*</modifier></type><name>estate</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcontext</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>shouldDispatch</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PxExecIdentity</name></type> <name>exec_identity</name></decl>;</decl_stmt>

	<comment type="block">/* sanity checks: queryDesc must not be started already */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>queryDesc</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>queryDesc</name><operator>-&gt;</operator><name>estate</name></name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>px_role</name> <operator>==</operator> <name>PX_ROLE_QC</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IS_PX_SETUP_DONE</name><argument_list>()</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>polar_cluster_map</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name><name>polar_cluster_map</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'\0'</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"enable px, but px cluster map not initialized"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><call><name>px_setup</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>on_proc_exit</name><argument_list>(<argument><expr><name>px_cleanup</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IS_PX_ADPS_SETUP_DONE</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>pxdisp_createPqThread</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * If the transaction is read-only, we need to check if any writes are
	 * planned to non-temporary tables.  EXPLAIN is considered read-only.
	 *
	 * Don't allow writes in parallel mode.  Supporting UPDATE and DELETE
	 * would require (a) storing the combocid hash in shared memory, rather
	 * than synchronizing it just once at the start of parallelism, and (b) an
	 * alternative to heap_update()'s reliance on xmax for mutual exclusion.
	 * INSERT may have no such troubles, but we forbid it to simplify the
	 * checks.
	 *
	 * We have lower-level defenses in CommandCounterIncrement and elsewhere
	 * against performing unsafe operations in parallel mode, but this gives a
	 * more user-friendly error message.
	 */</comment>

	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>XactReadOnly</name> <operator>||</operator> <call><name>IsInParallelMode</name><argument_list>()</argument_list></call> <operator>||</operator>
		<operator>(</operator><operator>!</operator><name><name>MyProc</name><operator>-&gt;</operator><name>issuper</name></name> <operator>&amp;&amp;</operator> <name>polar_force_trans_ro_non_sup</name><operator>)</operator><operator>)</operator> <operator>&amp;&amp;</operator>
		<operator>!</operator><operator>(</operator><name>eflags</name> <operator>&amp;</operator> <name>EXEC_FLAG_EXPLAIN_ONLY</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ExecCheckXactReadOnly</name><argument_list>(<argument><expr><name><name>queryDesc</name><operator>-&gt;</operator><name>plannedstmt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Build EState, switch into per-query memory context for startup.
	 */</comment>
	<expr_stmt><expr><name>estate</name> <operator>=</operator> <call><name>CreateExecutorState</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>queryDesc</name><operator>-&gt;</operator><name>estate</name></name> <operator>=</operator> <name>estate</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>oldcontext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>estate</name><operator>-&gt;</operator><name>es_query_cxt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Fill in external parameters, if any, from queryDesc; and allocate
	 * workspace for internal parameters
	 */</comment>
	<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>es_param_list_info</name></name> <operator>=</operator> <name><name>queryDesc</name><operator>-&gt;</operator><name>params</name></name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>queryDesc</name><operator>-&gt;</operator><name>plannedstmt</name><operator>-&gt;</operator><name>nParamExec</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>nParamExec</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>nParamExec</name> <operator>=</operator> <name><name>queryDesc</name><operator>-&gt;</operator><name>plannedstmt</name><operator>-&gt;</operator><name>nParamExec</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>es_param_exec_vals</name></name> <operator>=</operator> <operator>(</operator><name>ParamExecData</name> <operator>*</operator><operator>)</operator>
			<call><name>palloc0</name><argument_list>(<argument><expr><name>nParamExec</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ParamExecData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>es_sourceText</name></name> <operator>=</operator> <name><name>queryDesc</name><operator>-&gt;</operator><name>sourceText</name></name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Fill in the query environment, if any, from queryDesc.
	 */</comment>
	<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>es_queryEnv</name></name> <operator>=</operator> <name><name>queryDesc</name><operator>-&gt;</operator><name>queryEnv</name></name></expr>;</expr_stmt>

	<comment type="block">/*
	 * If non-read-only query, set the command ID to mark output tuples with
	 */</comment>
	<switch>switch <condition>(<expr><name><name>queryDesc</name><operator>-&gt;</operator><name>operation</name></name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>CMD_SELECT</name></expr>:</case>

			<comment type="block">/*
			 * SELECT FOR [KEY] UPDATE/SHARE and modifying CTEs need to mark
			 * tuples
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>queryDesc</name><operator>-&gt;</operator><name>plannedstmt</name><operator>-&gt;</operator><name>rowMarks</name></name> <operator>!=</operator> <name>NIL</name> <operator>||</operator>
				<name><name>queryDesc</name><operator>-&gt;</operator><name>plannedstmt</name><operator>-&gt;</operator><name>hasModifyingCTE</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>es_output_cid</name></name> <operator>=</operator> <call><name>GetCurrentCommandId</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<comment type="block">/*
			 * A SELECT without modifying CTEs can't possibly queue triggers,
			 * so force skip-triggers mode. This is just a marginal efficiency
			 * hack, since AfterTriggerBeginQuery/AfterTriggerEndQuery aren't
			 * all that expensive, but we might as well do it.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>queryDesc</name><operator>-&gt;</operator><name>plannedstmt</name><operator>-&gt;</operator><name>hasModifyingCTE</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>eflags</name> <operator>|=</operator> <name>EXEC_FLAG_SKIP_TRIGGERS</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<break>break;</break>

		<case>case <expr><name>CMD_INSERT</name></expr>:</case>
		<case>case <expr><name>CMD_DELETE</name></expr>:</case>
		<case>case <expr><name>CMD_UPDATE</name></expr>:</case>
			<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>es_output_cid</name></name> <operator>=</operator> <call><name>GetCurrentCommandId</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<default>default:</default>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized operation code: %d"</literal></expr></argument>,
				 <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name><name>queryDesc</name><operator>-&gt;</operator><name>operation</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
	</block_content>}</block></switch>

	<comment type="block">/*
	 * Copy other important information into the EState
	 */</comment>
	<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>es_snapshot</name></name> <operator>=</operator> <call><name>RegisterSnapshot</name><argument_list>(<argument><expr><name><name>queryDesc</name><operator>-&gt;</operator><name>snapshot</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>es_crosscheck_snapshot</name></name> <operator>=</operator> <call><name>RegisterSnapshot</name><argument_list>(<argument><expr><name><name>queryDesc</name><operator>-&gt;</operator><name>crosscheck_snapshot</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>es_top_eflags</name></name> <operator>=</operator> <name>eflags</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>es_instrument</name></name> <operator>=</operator> <name><name>queryDesc</name><operator>-&gt;</operator><name>instrument_options</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>es_jit_flags</name></name> <operator>=</operator> <name><name>queryDesc</name><operator>-&gt;</operator><name>plannedstmt</name><operator>-&gt;</operator><name>jitFlags</name></name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Shared input info is needed when ROLE_EXECUTE or sequential plan
	 */</comment>
	<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>es_sharenode</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Handling of the Slice table depends on context.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>px_role</name> <operator>==</operator> <name>PX_ROLE_QC</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Set up the slice table. */</comment>
		<decl_stmt><decl><type><name>SliceTable</name> <modifier>*</modifier></type><name>sliceTable</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>sliceTable</name> <operator>=</operator> <call><name>InitSliceTable</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name><name>queryDesc</name><operator>-&gt;</operator><name>plannedstmt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>es_sliceTable</name></name> <operator>=</operator> <name>sliceTable</name></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>sliceTable</name><operator>-&gt;</operator><name>slices</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>gangType</name> <operator>!=</operator> <name>GANGTYPE_UNALLOCATED</name> <operator>||</operator>
			<name><name>sliceTable</name><operator>-&gt;</operator><name>hasMotions</name></name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name><name>queryDesc</name><operator>-&gt;</operator><name>ddesc</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name><name>queryDesc</name><operator>-&gt;</operator><name>ddesc</name></name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>QueryDispatchDesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt><empty_stmt>;</empty_stmt>
				<expr_stmt><expr><name><name>queryDesc</name><operator>-&gt;</operator><name>ddesc</name><operator>-&gt;</operator><name>useChangedAOOpts</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/* Pass EXPLAIN ANALYZE flag to qExecs. */</comment>
			<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>es_sliceTable</name><operator>-&gt;</operator><name>instrument_options</name></name> <operator>=</operator> <name><name>queryDesc</name><operator>-&gt;</operator><name>instrument_options</name></name></expr>;</expr_stmt>

			<comment type="block">/* set our global sliceid variable for elog. */</comment>
			<expr_stmt><expr><name>currentSliceId</name> <operator>=</operator> <call><name>LocallyExecutingSliceIndex</name><argument_list>(<argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* InitPlan() will acquire locks by walking the entire plan
			 * tree -- we'd like to avoid acquiring the locks until
			 * *after* we've set up the interconnect */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>estate</name><operator>-&gt;</operator><name>es_sliceTable</name><operator>-&gt;</operator><name>hasMotions</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>motionlayer_context</name></name> <operator>=</operator> <call><name>createMotionLayerState</name><argument_list>(<argument><expr><name><name>queryDesc</name><operator>-&gt;</operator><name>plannedstmt</name><operator>-&gt;</operator><name>numSlices</name></name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<expr_stmt><expr><name>shouldDispatch</name> <operator>=</operator> <operator>!</operator><operator>(</operator><name>eflags</name> <operator>&amp;</operator> <name>EXEC_FLAG_EXPLAIN_ONLY</name><operator>)</operator></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/* QC-only query, no dispatching required */</comment>
			<expr_stmt><expr><name>shouldDispatch</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
		<comment type="block">/* update the ps status */</comment>
		<expr_stmt><expr><call><name>set_ps_display</name><argument_list>(<argument><expr><call><name>CreateCommandTag</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name><operator>*</operator><operator>)</operator><name><name>queryDesc</name><operator>-&gt;</operator><name>plannedstmt</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>px_role</name> <operator>==</operator> <name>PX_ROLE_PX</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>QueryDispatchDesc</name> <modifier>*</modifier></type><name>ddesc</name> <init>= <expr><name><name>queryDesc</name><operator>-&gt;</operator><name>ddesc</name></name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>shouldDispatch</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

		<comment type="block">/* qDisp should have sent us a slice table via POLARPX */</comment>
		<if_stmt><if>if <condition>(<expr><name>ddesc</name> <operator>&amp;&amp;</operator> <name><name>ddesc</name><operator>-&gt;</operator><name>sliceTable</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>SliceTable</name> <modifier>*</modifier></type><name>sliceTable</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>ExecSlice</name>  <modifier>*</modifier></type><name>slice</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>sliceTable</name> <operator>=</operator> <name><name>ddesc</name><operator>-&gt;</operator><name>sliceTable</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>IsA</name><argument_list>(<argument><expr><name>sliceTable</name></expr></argument>, <argument><expr><name>SliceTable</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>slice</name> <operator>=</operator> <operator>&amp;</operator><name><name>sliceTable</name><operator>-&gt;</operator><name>slices</name><index>[<expr><name><name>sliceTable</name><operator>-&gt;</operator><name>localSlice</name></name></expr>]</index></name></expr>;</expr_stmt>

			<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>es_sliceTable</name></name> <operator>=</operator> <name>sliceTable</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>es_cursorPositions</name></name> <operator>=</operator> <name><name>ddesc</name><operator>-&gt;</operator><name>cursorPositions</name></name></expr>;</expr_stmt>

			<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>currentSliceId</name></name> <operator>=</operator> <name><name>slice</name><operator>-&gt;</operator><name>rootIndex</name></name></expr>;</expr_stmt>

			<comment type="block">/* set our global sliceid variable for elog. */</comment>
			<expr_stmt><expr><name>currentSliceId</name> <operator>=</operator> <call><name>LocallyExecutingSliceIndex</name><argument_list>(<argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* Should we collect statistics for EXPLAIN ANALYZE? */</comment>
			<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>es_instrument</name></name> <operator>=</operator> <name><name>sliceTable</name><operator>-&gt;</operator><name>instrument_options</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>queryDesc</name><operator>-&gt;</operator><name>instrument_options</name></name> <operator>=</operator> <name><name>sliceTable</name><operator>-&gt;</operator><name>instrument_options</name></name></expr>;</expr_stmt>

			<comment type="block">/* InitPlan() will acquire locks by walking the entire plan
			 * tree -- we'd like to avoid acquiring the locks until
			 * *after* we've set up the interconnect */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>estate</name><operator>-&gt;</operator><name>es_sliceTable</name><operator>-&gt;</operator><name>hasMotions</name></name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>motionlayer_context</name></name> <operator>=</operator> <call><name>createMotionLayerState</name><argument_list>(<argument><expr><name><name>queryDesc</name><operator>-&gt;</operator><name>plannedstmt</name><operator>-&gt;</operator><name>numSlices</name></name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><call><name>PG_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<block>{<block_content>
					<comment type="block">/*
					 * Initialize the motion layer for this query.
					 */</comment>
					<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name><name>estate</name><operator>-&gt;</operator><name>interconnect_context</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>SetupInterconnect</name><argument_list>(<argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>UpdateMotionExpectedReceivers</name><argument_list>(<argument><expr><name><name>estate</name><operator>-&gt;</operator><name>motionlayer_context</name></name></expr></argument>, <argument><expr><name><name>estate</name><operator>-&gt;</operator><name>es_sliceTable</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>estate</name><operator>-&gt;</operator><name>interconnect_context</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block>
				<expr_stmt><expr><call><name>PG_CATCH</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<block>{<block_content>
					<expr_stmt><expr><call><name>ExecutorCleanup_PX</name><argument_list>(<argument><expr><name>queryDesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>PG_RE_THROW</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block>
				<expr_stmt><expr><call><name>PG_END_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/* local query in PX. */</comment>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>shouldDispatch</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/*
	 * We don't eliminate aliens if we don't have an PX plan
	 * or we are executing on master.
	 */</comment>
	<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>eliminateAliens</name></name> <operator>=</operator> <operator>(</operator><name>px_execute_pruned_plan</name> <operator>&amp;&amp;</operator> 
								<name><name>estate</name><operator>-&gt;</operator><name>es_sliceTable</name></name> <operator>&amp;&amp;</operator> 
								<name><name>estate</name><operator>-&gt;</operator><name>es_sliceTable</name><operator>-&gt;</operator><name>hasMotions</name></name> <operator>&amp;&amp;</operator> 
								<name>px_role</name> <operator>!=</operator> <name>PX_ROLE_QC</name><operator>)</operator></expr>;</expr_stmt>

	<comment type="block">/*
	 * Assign a Motion Node to every Plan Node. This makes it
	 * easy to identify which slice any Node belongs to
	 */</comment>
	<expr_stmt><expr><call><name>AssignParentMotionToPlanNodes</name><argument_list>(<argument><expr><name><name>queryDesc</name><operator>-&gt;</operator><name>plannedstmt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* If the interconnect has been set up; we need to catch any
	 * errors to shut it down -- so we have to wrap InitPlan in a PG_TRY() block. */</comment>
	<expr_stmt><expr><call><name>PG_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<block>{<block_content>
		<comment type="block">/*
		 * Initialize the plan state tree
		 */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>CurrentMemoryContext</name> <operator>==</operator> <name><name>estate</name><operator>-&gt;</operator><name>es_query_cxt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>InitPlan</name><argument_list>(<argument><expr><name>queryDesc</name></expr></argument>, <argument><expr><name>eflags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>queryDesc</name><operator>-&gt;</operator><name>planstate</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>debug_print_slice_table</name> <operator>&amp;&amp;</operator> <name>px_role</name> <operator>==</operator> <name>PX_ROLE_QC</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog_node_display</name><argument_list>(<argument><expr><name>DEBUG3</name></expr></argument>, <argument><expr><literal type="string">"slice table"</literal></expr></argument>, <argument><expr><name><name>estate</name><operator>-&gt;</operator><name>es_sliceTable</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * If we're running as a PX and there's a slice table in our queryDesc,
		 * then we need to finish the EState setup we prepared for back in
		 * PxExecQuery.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>px_role</name> <operator>==</operator> <name>PX_ROLE_PX</name> <operator>&amp;&amp;</operator> <name><name>estate</name><operator>-&gt;</operator><name>es_sliceTable</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<function_decl><type><name>MotionState</name> <modifier>*</modifier><name>motionstate</name></type> <name>pg_attribute_unused</name><parameter_list>()</parameter_list> <init>= <expr><name>NULL</name></expr></init>;</function_decl>

			<comment type="block">/*
			 * Note that, at this point on a PX, the estate is setup (based on the
			 * slice table transmitted from the QC) so that fields
			 * es_sliceTable, cur_root_idx and es_cur_slice_idx are correct for
			 * the PX.
			 *
			 * If responsible for a non-root slice, arrange to enter the plan at the
			 * slice's sending Motion node rather than at the top.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>LocallyExecutingSliceIndex</name><argument_list>(<argument><expr><name>estate</name></expr></argument>)</argument_list></call> <operator>!=</operator> <call><name>RootSliceIndex</name><argument_list>(<argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>motionstate</name> <operator>=</operator> <call><name>getMotionState</name><argument_list>(<argument><expr><name><name>queryDesc</name><operator>-&gt;</operator><name>planstate</name></name></expr></argument>, <argument><expr><call><name>LocallyExecutingSliceIndex</name><argument_list>(<argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>motionstate</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <call><name>IsA</name><argument_list>(<argument><expr><name>motionstate</name></expr></argument>, <argument><expr><name>MotionState</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><name>debug_print_slice_table</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>elog_node_display</name><argument_list>(<argument><expr><name>DEBUG3</name></expr></argument>, <argument><expr><literal type="string">"slice table"</literal></expr></argument>, <argument><expr><name><name>estate</name><operator>-&gt;</operator><name>es_sliceTable</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><name>px_interconnect_log</name>  <operator>&gt;=</operator> <name>PXVARS_VERBOSITY_DEBUG</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>, <argument><expr><literal type="string">"seg%d executing slice%d under root slice%d"</literal></expr></argument>,
					 <argument><expr><name><name>PxIdentity</name><operator>.</operator><name>workerid</name></name></expr></argument>,
					 <argument><expr><call><name>LocallyExecutingSliceIndex</name><argument_list>(<argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr></argument>,
					 <argument><expr><call><name>RootSliceIndex</name><argument_list>(<argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * if in dispatch mode, time to serialize plan and query
		 * trees, and fire off px_exec command to each of the pxxecs
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>shouldDispatch</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			* POLAR px: wal lsn in QC, send it to PXs to make PXs
			* see the data replayed.
			*/</comment>
			<expr_stmt><expr><name>px_sql_wal_lsn</name> <operator>=</operator> <call><name>polar_px_max_valid_lsn</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>queryDesc</name><operator>-&gt;</operator><name>ddesc</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name><name>queryDesc</name><operator>-&gt;</operator><name>ddesc</name><operator>-&gt;</operator><name>sliceTable</name></name> <operator>=</operator> <name><name>estate</name><operator>-&gt;</operator><name>es_sliceTable</name></name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/*
			 * First, see whether we need to pre-execute any initPlan subplans.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>queryDesc</name><operator>-&gt;</operator><name>plannedstmt</name><operator>-&gt;</operator><name>nParamExec</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>ParamListInfoData</name> <modifier>*</modifier></type><name>pli</name> <init>= <expr><name><name>queryDesc</name><operator>-&gt;</operator><name>params</name></name></expr></init></decl>;</decl_stmt>

				<comment type="block">/*
				 * First, use paramFetch to fetch any "lazy" parameters, so that
				 * they are dispatched along with the queries. The PX nodes cannot
				 * call the callback function on their own.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><name>pli</name> <operator>&amp;&amp;</operator> <name><name>pli</name><operator>-&gt;</operator><name>paramFetch</name></name></expr>)</condition>
				<block>{<block_content>
					<decl_stmt><decl><type><name>ParamExternData</name></type> <name>prmdata</name></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>int</name></type>			<name>iparam</name></decl>;</decl_stmt>

					<for>for <control>(<init><expr><name>iparam</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>iparam</name> <operator>&lt;</operator> <name><name>queryDesc</name><operator>-&gt;</operator><name>params</name><operator>-&gt;</operator><name>numParams</name></name></expr>;</condition> <incr><expr><name>iparam</name><operator>++</operator></expr></incr>)</control>
					<block>{<block_content>
						<decl_stmt><decl><type><name>ParamExternData</name> <modifier>*</modifier></type><name>prm</name> <init>= <expr><operator>&amp;</operator><name><name>pli</name><operator>-&gt;</operator><name>params</name><index>[<expr><name>iparam</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

						<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>prm</name><operator>-&gt;</operator><name>ptype</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
							<expr_stmt><expr><call>(<modifier>*</modifier><name><name>pli</name><operator>-&gt;</operator><name>paramFetch</name></name>) <argument_list>(<argument><expr><name>pli</name></expr></argument>, <argument><expr><name>iparam</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>prmdata</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
					</block_content>}</block></for>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/*
			 * This call returns after launching the threads that send the
			 * plan to the appropriate segdbs.  It does not wait for them to
			 * finish unless an error is detected before all slices have been
			 * dispatched.
			 *
			 * Main plan is parallel, send plan to it.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>estate</name><operator>-&gt;</operator><name>es_sliceTable</name><operator>-&gt;</operator><name>slices</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>gangType</name> <operator>!=</operator> <name>GANGTYPE_UNALLOCATED</name> <operator>||</operator>
				<name><name>estate</name><operator>-&gt;</operator><name>es_sliceTable</name><operator>-&gt;</operator><name>slices</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>children</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>PxDispatchPlan</name><argument_list>(<argument><expr><name>queryDesc</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * Get executor identity (who does the executor serve). we can assume
		 * Forward scan direction for now just for retrieving the identity.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>eflags</name> <operator>&amp;</operator> <name>EXEC_FLAG_EXPLAIN_ONLY</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>exec_identity</name> <operator>=</operator> <call><name>getPxExecIdentity</name><argument_list>(<argument><expr><name>queryDesc</name></expr></argument>, <argument><expr><name>ForwardScanDirection</name></expr></argument>, <argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>exec_identity</name> <operator>=</operator> <name>PX_IGNORE</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<comment type="block">/*
		 * If we have no slice to execute in this process, mark currentSliceId as
		 * invalid.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>exec_identity</name> <operator>==</operator> <name>PX_IGNORE</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>currentSliceId</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name>currentSliceId</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_ASSERT_CHECKING</name></cpp:ifdef>
		<comment type="block">/* non-root on PX */</comment>
		<if_stmt><if>if <condition>(<expr><name>exec_identity</name> <operator>==</operator> <name>PX_NON_ROOT_ON_PX</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>MotionState</name> <modifier>*</modifier></type><name>motionState</name> <init>= <expr><call><name>getMotionState</name><argument_list>(<argument><expr><name><name>queryDesc</name><operator>-&gt;</operator><name>planstate</name></name></expr></argument>, <argument><expr><call><name>LocallyExecutingSliceIndex</name><argument_list>(<argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>motionState</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>IsA</name><argument_list>(<argument><expr><name><name>motionState</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>plan</name></name></expr></argument>, <argument><expr><name>Motion</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
		if <condition>(<expr><name>exec_identity</name> <operator>==</operator> <name>PX_ROOT_SLICE</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Run a root slice. */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>queryDesc</name><operator>-&gt;</operator><name>planstate</name></name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator>
				<name><name>estate</name><operator>-&gt;</operator><name>es_sliceTable</name></name> <operator>&amp;&amp;</operator>
				<name><name>estate</name><operator>-&gt;</operator><name>es_sliceTable</name><operator>-&gt;</operator><name>slices</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>gangType</name> <operator>==</operator> <name>GANGTYPE_UNALLOCATED</name> <operator>&amp;&amp;</operator>
				<name><name>estate</name><operator>-&gt;</operator><name>es_sliceTable</name><operator>-&gt;</operator><name>slices</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>children</name> <operator>&amp;&amp;</operator>
				<operator>!</operator><name><name>estate</name><operator>-&gt;</operator><name>es_interconnect_is_setup</name></name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name><name>estate</name><operator>-&gt;</operator><name>interconnect_context</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>SetupInterconnect</name><argument_list>(<argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>estate</name><operator>-&gt;</operator><name>interconnect_context</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>UpdateMotionExpectedReceivers</name><argument_list>(<argument><expr><name><name>estate</name><operator>-&gt;</operator><name>motionlayer_context</name></name></expr></argument>, <argument><expr><name><name>estate</name><operator>-&gt;</operator><name>es_sliceTable</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name>exec_identity</name> <operator>!=</operator> <name>PX_IGNORE</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* should never happen */</comment>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><literal type="string">"unsupported POLAR px strategy"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if<condition>(<expr><name><name>estate</name><operator>-&gt;</operator><name>es_interconnect_is_setup</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>estate</name><operator>-&gt;</operator><name>interconnect_context</name></name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	</block_content>}</block>
	<expr_stmt><expr><call><name>PG_CATCH</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ExecutorCleanup_PX</name><argument_list>(<argument><expr><name>queryDesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>PG_RE_THROW</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
	<expr_stmt><expr><call><name>PG_END_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>DEBUG1</name> <operator>&gt;=</operator> <name>log_min_messages</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name></type>		<name><name>msec_str</name><index>[<expr><literal type="number">32</literal></expr>]</index></name></decl>;</decl_stmt>
		<switch>switch <condition>(<expr><call><name>check_log_duration</name><argument_list>(<argument><expr><name>msec_str</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<case>case <expr><literal type="number">1</literal></expr>:</case>
			<case>case <expr><literal type="number">2</literal></expr>:</case>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"duration to ExecutorStart end: %s ms"</literal></expr></argument>, <argument><expr><name>msec_str</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
		</block_content>}</block></switch>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Set up an AFTER-trigger statement context, unless told not to, or
	 * unless it's EXPLAIN-only mode (when ExecutorFinish won't be called).
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>eflags</name> <operator>&amp;</operator> <operator>(</operator><name>EXEC_FLAG_SKIP_TRIGGERS</name> <operator>|</operator> <name>EXEC_FLAG_EXPLAIN_ONLY</name><operator>)</operator><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>AfterTriggerBeginQuery</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>void</name></type>
<name>standard_ExecutorRun_PX</name><parameter_list>(<parameter><decl><type><name>QueryDesc</name> <modifier>*</modifier></type><name>queryDesc</name></decl></parameter>,
					 <parameter><decl><type><name>ScanDirection</name></type> <name>direction</name></decl></parameter>, <parameter><decl><type><name>uint64</name></type> <name>count</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>EState</name>	   <modifier>*</modifier></type><name>estate</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CmdType</name></type>		<name>operation</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>DestReceiver</name> <modifier>*</modifier></type><name>dest</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>sendTuples</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcontext</name></decl>;</decl_stmt>
	<comment type="block">/*
	 * NOTE: Any local vars that are set in the PG_TRY block and examined in the
	 * PG_CATCH block should be declared 'volatile'. (setjmp shenanigans)
	 */</comment>
	<decl_stmt><decl><type><name>ExecSlice</name>  <modifier>*</modifier></type><name>currentSlice</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PxExecIdentity</name></type>		<name>exec_identity</name></decl>;</decl_stmt>

	<comment type="block">/* sanity checks */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>queryDesc</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>estate</name> <operator>=</operator> <name><name>queryDesc</name><operator>-&gt;</operator><name>estate</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>estate</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><operator>(</operator><name><name>estate</name><operator>-&gt;</operator><name>es_top_eflags</name></name> <operator>&amp;</operator> <name>EXEC_FLAG_EXPLAIN_ONLY</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Switch into per-query memory context
	 */</comment>
	<expr_stmt><expr><name>oldcontext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>estate</name><operator>-&gt;</operator><name>es_query_cxt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Allow instrumentation of Executor overall runtime */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>queryDesc</name><operator>-&gt;</operator><name>totaltime</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>InstrStartNode</name><argument_list>(<argument><expr><name><name>queryDesc</name><operator>-&gt;</operator><name>totaltime</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><name>currentSlice</name> <operator>=</operator> <call><name>getCurrentSlice</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><call><name>LocallyExecutingSliceIndex</name><argument_list>(<argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>currentSlice</name></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>px_role</name> <operator>==</operator> <name>PX_ROLE_PX</name> <operator>||</operator>
            <call><name>sliceRunsOnQC</name><argument_list>(<argument><expr><name>currentSlice</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>currentSliceId</name> <operator>=</operator> <name><name>currentSlice</name><operator>-&gt;</operator><name>sliceIndex</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * extract information from the query descriptor and the query feature.
	 */</comment>
	<expr_stmt><expr><name>operation</name> <operator>=</operator> <name><name>queryDesc</name><operator>-&gt;</operator><name>operation</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>dest</name> <operator>=</operator> <name><name>queryDesc</name><operator>-&gt;</operator><name>dest</name></name></expr>;</expr_stmt>

	<comment type="block">/*
	 * startup tuple receiver, if we will be emitting tuples
	 */</comment>
	<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>es_processed</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>es_lastoid</name></name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>sendTuples</name> <operator>=</operator> <operator>(</operator><name><name>queryDesc</name><operator>-&gt;</operator><name>tupDesc</name></name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator>
				  <operator>(</operator><name>operation</name> <operator>==</operator> <name>CMD_SELECT</name> <operator>||</operator>
				   <name><name>queryDesc</name><operator>-&gt;</operator><name>plannedstmt</name><operator>-&gt;</operator><name>hasReturning</name></name><operator>)</operator><operator>)</operator></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>sendTuples</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call>(<modifier>*</modifier><name><name>dest</name><operator>-&gt;</operator><name>rStartup</name></name>) <argument_list>(<argument><expr><name>dest</name></expr></argument>, <argument><expr><name>operation</name></expr></argument>, <argument><expr><name><name>queryDesc</name><operator>-&gt;</operator><name>tupDesc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Need a try/catch block here so that if an ereport is called from
	 * within ExecutePlan, we can clean up by calling PxCheckDispatchResult.
	 * This cleans up the asynchronous commands running through the threads launched from
	 * PxDispatchCommand.
	 */</comment>
	<expr_stmt><expr><call><name>PG_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<block>{<block_content>
		<comment type="block">/*
		 * Run the plan locally.  There are three ways;
		 *
		 * 1. Do nothing
		 * 2. Run a root slice
		 * 3. Run a non-root slice on a PX.
		 *
		 * Here we decide what is our identity -- root slice, non-root
		 * on PX or other (in which case we do nothing), and then run
		 * the plan if required. For more information see
		 * getPxExecIdentity() in execUtils.
		 */</comment>
		<expr_stmt><expr><name>exec_identity</name> <operator>=</operator> <call><name>getPxExecIdentity</name><argument_list>(<argument><expr><name>queryDesc</name></expr></argument>, <argument><expr><name>direction</name></expr></argument>, <argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>exec_identity</name> <operator>==</operator> <name>PX_IGNORE</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* do nothing */</comment>
			<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>es_got_eos</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name>exec_identity</name> <operator>==</operator> <name>PX_NON_ROOT_ON_PX</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * Run a non-root slice on a PX.
			 *
			 * Since the top Plan node is a (Sending) Motion, run the plan
			 * forward to completion. The plan won't return tuples locally
			 * (tuples go out over the interconnect), so the destination is
			 * uninteresting.  The command type should be SELECT, however, to
			 * avoid other sorts of DML processing..
			 *
			 * This is the center of slice plan activity -- here we arrange to
			 * blunder into the middle of the plan rather than entering at the
			 * root.
			 */</comment>

			<decl_stmt><decl><type><name>MotionState</name> <modifier>*</modifier></type><name>motionState</name> <init>= <expr><call><name>getMotionState</name><argument_list>(<argument><expr><name><name>queryDesc</name><operator>-&gt;</operator><name>planstate</name></name></expr></argument>, <argument><expr><call><name>LocallyExecutingSliceIndex</name><argument_list>(<argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>motionState</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>ExecutePlan</name><argument_list>(<argument><expr><name>estate</name></expr></argument>,
						<argument><expr><operator>(</operator><name>PlanState</name> <operator>*</operator><operator>)</operator> <name>motionState</name></expr></argument>,
						<argument><expr><name><name>queryDesc</name><operator>-&gt;</operator><name>plannedstmt</name><operator>-&gt;</operator><name>parallelModeNeeded</name></name></expr></argument>,
						<argument><expr><name>CMD_SELECT</name></expr></argument>,
						<argument><expr><name>sendTuples</name></expr></argument>,
						<argument><expr><literal type="number">0</literal></expr></argument>,
						<argument><expr><name>ForwardScanDirection</name></expr></argument>,
						<argument><expr><name>dest</name></expr></argument>,
						<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name>exec_identity</name> <operator>==</operator> <name>PX_ROOT_SLICE</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * Run a root slice
			 * It corresponds to the "normal" path through the executor
			 * in that we enter the plan at the top and count on the
			 * motion nodes at the fringe of the top slice to return
			 * without ever calling nodes below them.
			 */</comment>
			<expr_stmt><expr><call><name>ExecutePlan</name><argument_list>(<argument><expr><name>estate</name></expr></argument>,
						<argument><expr><name><name>queryDesc</name><operator>-&gt;</operator><name>planstate</name></name></expr></argument>,
						<argument><expr><name><name>queryDesc</name><operator>-&gt;</operator><name>plannedstmt</name><operator>-&gt;</operator><name>parallelModeNeeded</name></name></expr></argument>,
						<argument><expr><name>operation</name></expr></argument>,
						<argument><expr><name>sendTuples</name></expr></argument>,
						<argument><expr><name>count</name></expr></argument>,
						<argument><expr><name>direction</name></expr></argument>,
						<argument><expr><name>dest</name></expr></argument>,
						<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/* should never happen */</comment>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><literal type="string">"undefined POLAR px strategy"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
    </block_content>}</block>
	<expr_stmt><expr><call><name>PG_CATCH</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<block>{<block_content>
        <comment type="block">/* POLAR px : If EXPLAIN ANALYZE, let px try to return stats to qc. */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>estate</name><operator>-&gt;</operator><name>es_sliceTable</name></name> <operator>&amp;&amp;</operator>
            <name><name>estate</name><operator>-&gt;</operator><name>es_sliceTable</name><operator>-&gt;</operator><name>instrument_options</name></name> <operator>&amp;&amp;</operator>
            <operator>(</operator><name><name>estate</name><operator>-&gt;</operator><name>es_sliceTable</name><operator>-&gt;</operator><name>instrument_options</name></name> <operator>&amp;</operator> <name>INSTRUMENT_PX</name><operator>)</operator> <operator>&amp;&amp;</operator>
            <name>px_role</name> <operator>==</operator> <name>PX_ROLE_PX</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>PG_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <block>{<block_content>
                <expr_stmt><expr><call><name>pxexplain_sendExecStats</name><argument_list>(<argument><expr><name>queryDesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
            </block_content>}</block>
            <expr_stmt><expr><call><name>PG_CATCH</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <block>{<block_content>
                <comment type="block">/* Close down interconnect etc. */</comment>
				<expr_stmt><expr><call><name>ExecutorCleanup_PX</name><argument_list>(<argument><expr><name>queryDesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		        <expr_stmt><expr><call><name>PG_RE_THROW</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block>
            <expr_stmt><expr><call><name>PG_END_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
		<comment type="block">/* Close down interconnect etc. */</comment>
		<expr_stmt><expr><call><name>ExecutorCleanup_PX</name><argument_list>(<argument><expr><name>queryDesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>PG_RE_THROW</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* POLAR end */</comment>
	</block_content>}</block>
	<expr_stmt><expr><call><name>PG_END_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * shutdown tuple receiver, if we started it
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>sendTuples</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call>(<modifier>*</modifier><name><name>dest</name><operator>-&gt;</operator><name>rShutdown</name></name>) <argument_list>(<argument><expr><name>dest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>queryDesc</name><operator>-&gt;</operator><name>totaltime</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>InstrStopNode</name><argument_list>(<argument><expr><name><name>queryDesc</name><operator>-&gt;</operator><name>totaltime</name></name></expr></argument>, <argument><expr><name><name>estate</name><operator>-&gt;</operator><name>es_processed</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<function><type><name>void</name></type>
<name>standard_ExecutorEnd_PX</name><parameter_list>(<parameter><decl><type><name>QueryDesc</name> <modifier>*</modifier></type><name>queryDesc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>EState</name>	   <modifier>*</modifier></type><name>estate</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcontext</name></decl>;</decl_stmt>

	<comment type="block">/* sanity checks */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>queryDesc</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>estate</name> <operator>=</operator> <name><name>queryDesc</name><operator>-&gt;</operator><name>estate</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>estate</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Check that ExecutorFinish was called, unless in EXPLAIN-only mode. This
	 * Assert is needed because ExecutorFinish is new as of 9.1, and callers
	 * might forget to call it.
	 */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>estate</name><operator>-&gt;</operator><name>es_finished</name></name> <operator>||</operator>
		   <operator>(</operator><name><name>estate</name><operator>-&gt;</operator><name>es_top_eflags</name></name> <operator>&amp;</operator> <name>EXEC_FLAG_EXPLAIN_ONLY</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Switch into per-query memory context to run ExecEndPlan
	 */</comment>
	<expr_stmt><expr><name>oldcontext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>estate</name><operator>-&gt;</operator><name>es_query_cxt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<block>{<block_content>
		<comment type="block">/*
		 *  POLAR px : If EXPLAIN ANALYZE, px returns stats to qc now.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>estate</name><operator>-&gt;</operator><name>es_sliceTable</name></name> <operator>&amp;&amp;</operator>
			<name><name>estate</name><operator>-&gt;</operator><name>es_sliceTable</name><operator>-&gt;</operator><name>instrument_options</name></name> <operator>&amp;&amp;</operator>
			<operator>(</operator><name><name>estate</name><operator>-&gt;</operator><name>es_sliceTable</name><operator>-&gt;</operator><name>instrument_options</name></name> <operator>&amp;</operator> <name>INSTRUMENT_PX</name><operator>)</operator> <operator>&amp;&amp;</operator>
			<name>px_role</name> <operator>==</operator> <name>PX_ROLE_PX</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>pxexplain_sendExecStats</name><argument_list>(<argument><expr><name>queryDesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * if needed, collect mpp dispatch results and tear down
		 * all mpp specific resources (e.g. interconnect).
		 */</comment>
		<expr_stmt><expr><call><name>PG_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ExecutorFinishup_PX</name><argument_list>(<argument><expr><name>queryDesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>
		<expr_stmt><expr><call><name>PG_CATCH</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<block>{<block_content>
			<comment type="block">/*
			 * we got an error. do all the necessary cleanup.
			 */</comment>
			<expr_stmt><expr><call><name>ExecutorCleanup_PX</name><argument_list>(<argument><expr><name>queryDesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * Remove our own query's motion layer.
			 */</comment>
			<expr_stmt><expr><call><name>RemoveMotionLayer</name><argument_list>(<argument><expr><name><name>estate</name><operator>-&gt;</operator><name>motionlayer_context</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * Release EState and per-query memory context.
			 */</comment>
			<expr_stmt><expr><call><name>FreeExecutorState</name><argument_list>(<argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>PG_RE_THROW</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>
		<expr_stmt><expr><call><name>PG_END_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* POLAR end */</comment>
	</block_content>}</block>

	<expr_stmt><expr><call><name>ExecEndPlan</name><argument_list>(<argument><expr><name><name>queryDesc</name><operator>-&gt;</operator><name>planstate</name></name></expr></argument>, <argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Remove our own query's motion layer.
	 */</comment>
	<expr_stmt><expr><call><name>RemoveMotionLayer</name><argument_list>(<argument><expr><name><name>estate</name><operator>-&gt;</operator><name>motionlayer_context</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* do away with our snapshots */</comment>
	<expr_stmt><expr><call><name>UnregisterSnapshot</name><argument_list>(<argument><expr><name><name>estate</name><operator>-&gt;</operator><name>es_snapshot</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>UnregisterSnapshot</name><argument_list>(<argument><expr><name><name>estate</name><operator>-&gt;</operator><name>es_crosscheck_snapshot</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Must switch out of context before destroying it
	 */</comment>
	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* POLAR px */</comment>
	<expr_stmt><expr><name><name>queryDesc</name><operator>-&gt;</operator><name>es_processed</name></name> <operator>=</operator> <name><name>estate</name><operator>-&gt;</operator><name>es_processed</name></name></expr>;</expr_stmt>
	<comment type="block">/* POLAR end */</comment>

	<comment type="block">/*
	 * Release EState and per-query memory context.  This should release
	 * everything the executor has allocated.
	 */</comment>
	<expr_stmt><expr><call><name>FreeExecutorState</name><argument_list>(<argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Reset queryDesc fields that no longer point to anything */</comment>
	<expr_stmt><expr><name><name>queryDesc</name><operator>-&gt;</operator><name>tupDesc</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>queryDesc</name><operator>-&gt;</operator><name>estate</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>queryDesc</name><operator>-&gt;</operator><name>planstate</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>queryDesc</name><operator>-&gt;</operator><name>totaltime</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
</block_content>}</block></function>
</unit>
