<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/PolarDB-for-PostgreSQL/src/backend/executor/execUtils_px.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * execUtils_px.c
 *	  Miscellaneous executor utility routines for PX.
 *
 * Portions Copyright (c) 2021, Alibaba Group Holding Limited
 * Portions Copyright (c) 2005-2008, Greenplum inc
 * Portions Copyright (c) 2012-Present VMware, Inc. or its affiliates.
 * Portions Copyright (c) 1996-2019, PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, Regents of the University of California
 *
 *
 * IDENTIFICATION
 *	  src/backend/executor/execUtils_px.c
 *
 *-------------------------------------------------------------------------
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/executor.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/execUtils_px.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/px_walkers.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/guc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"px/px_llize.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"px/px_util.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"px/px_vars.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"px/px_disp_query.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"px/px_dispatchresult.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"px/ml_ipc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"px/px_motion.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"px/px_sreh.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/lsyscache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/catalog.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/builtins.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/functions.h"</cpp:file></cpp:include>

<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>PrimaryWriterSliceIndex</name><parameter_list>(<parameter><decl><type><name>EState</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>)</parameter_list>;</function_decl>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PSW_IGNORE_INITPLAN</name></cpp:macro>    <cpp:value>0x01</cpp:value></cpp:define>
<function_decl><type><specifier>static</specifier> <name>PxVisitOpt</name></type> <name>planstate_walk_node_extended</name><parameter_list>(<parameter><decl><type><name>PlanState</name> <modifier>*</modifier></type><name>planstate</name></decl></parameter>,
												<parameter><function_decl><type><name>PxVisitOpt</name></type> (<modifier>*</modifier><name>walker</name>) <parameter_list>(<parameter><decl><type><name>PlanState</name> <modifier>*</modifier></type><name>planstate</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list></function_decl></parameter>,
												<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>context</name></decl></parameter>,
												<parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>PxVisitOpt</name></type> <name>planstate_walk_array</name><parameter_list>(<parameter><decl><type><name>PlanState</name> <modifier>*</modifier><modifier>*</modifier></type><name>planstates</name></decl></parameter>,
										<parameter><decl><type><name>int</name></type> <name>nplanstate</name></decl></parameter>,
										<parameter><function_decl><type><name>PxVisitOpt</name></type> (<modifier>*</modifier><name>walker</name>) <parameter_list>(<parameter><decl><type><name>PlanState</name> <modifier>*</modifier></type><name>planstate</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list></function_decl></parameter>,
										<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>context</name></decl></parameter>,
										<parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>PxVisitOpt</name></type> <name>planstate_walk_kids</name><parameter_list>(<parameter><decl><type><name>PlanState</name> <modifier>*</modifier></type><name>planstate</name></decl></parameter>,
									   <parameter><function_decl><type><name>PxVisitOpt</name></type> (<modifier>*</modifier><name>walker</name>) <parameter_list>(<parameter><decl><type><name>PlanState</name> <modifier>*</modifier></type><name>planstate</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list></function_decl></parameter>,
									   <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>context</name></decl></parameter>,
									   <parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>)</parameter_list>;</function_decl>


<comment type="block">/* ---------------------- POLAR px -----------------------*/</comment>

<typedef>typedef <type><struct>struct <name>MotionAssignerContext</name>
<block>{
	<decl_stmt><decl><type><name>plan_tree_base_prefix</name></type> <name>base</name></decl>;</decl_stmt> <comment type="block">/* Required prefix for plan_tree_walker/mutator */</comment>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>motStack</name></decl>;</decl_stmt> <comment type="block">/* Motion Stack */</comment>
}</block></struct></type> <name>MotionAssignerContext</name>;</typedef>



<comment type="block">/*
 * POLAR px
 * Walker for search SplitUpdate Node
*/</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>SplitSearchWalker</name><parameter_list>(<parameter><decl><type><name>Plan</name> <modifier>*</modifier></type><name>node</name></decl></parameter>,<parameter><decl><type><name>void</name><modifier>*</modifier></type> <name>ctx</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>node</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
		
	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>SplitUpdate</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
	<return>return <expr><call><name>plan_tree_walker</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name><operator>*</operator><operator>)</operator><name>node</name></expr></argument>, <argument><expr><name>SplitSearchWalker</name></expr></argument>, <argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * POLAR px
 * Walker to set plan-&gt;motionNode for every Plan node to its corresponding parent
 * motion node.
 *
 * This function maintains a stack of motion nodes. When we encounter a motion node
 * we push it on to the stack, walk its subtree, and then pop it off the stack.
 * When we encounter any plan node (motion nodes included) we assign its plan-&gt;motionNode
 * to the top of the stack.
 *
 * NOTE: Motion nodes will have their motionNode value set to the previous motion node
 * we encountered while walking the subtree.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>MotionAssignerWalker</name><parameter_list>(<parameter><decl><type><name>Plan</name> <modifier>*</modifier></type><name>node</name></decl></parameter>,
				  <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>MotionAssignerContext</name> <modifier>*</modifier></type><name>ctx</name></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>node</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>ctx</name> <operator>=</operator> <operator>(</operator><name>MotionAssignerContext</name> <operator>*</operator><operator>)</operator> <name>context</name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>is_plan_node</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name><operator>*</operator><operator>)</operator><name>node</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Plan</name> <modifier>*</modifier></type><name>plan</name> <init>= <expr><operator>(</operator><name>Plan</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
		<comment type="block">/*
		 * TODO: For cached plan we may be assigning multiple times.
		 * The eventual goal is to relocate it to planner. For now,
		 * ignore already assigned nodes.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>!=</operator> <name><name>plan</name><operator>-&gt;</operator><name>motionNode</name></name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
		<expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>motionNode</name></name> <operator>=</operator> <ternary><condition><expr><name><name>ctx</name><operator>-&gt;</operator><name>motStack</name></name> <operator>!=</operator> <name>NIL</name></expr> ?</condition><then> <expr><operator>(</operator><name>Plan</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><call><name>list_head</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>motStack</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> </then><else>: <expr><name>NULL</name></expr></else></ternary></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Subplans get dynamic motion assignment as they can be executed from
	 * arbitrary expressions. So, we don't assign any motion to these nodes.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>SubPlan</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>Motion</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>motStack</name></name> <operator>=</operator> <call><name>lcons</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>motStack</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>plan_tree_walker</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator><name>node</name></expr></argument>, <argument><expr><name>MotionAssignerWalker</name></expr></argument>, <argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>motStack</name></name> <operator>=</operator> <call><name>list_delete_first</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>motStack</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Continue walking */</comment>
	<return>return <expr><call><name>plan_tree_walker</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name><operator>*</operator><operator>)</operator><name>node</name></expr></argument>, <argument><expr><name>MotionAssignerWalker</name></expr></argument>, <argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * POLAR px
 * Assign every node in plannedstmt-&gt;planTree its corresponding
 * parent Motion Node if it has one
 *
 * NOTE: Some plans may not be rooted by a motion on the segment so
 * this function does not guarantee that every node will have a non-NULL
 * motionNode value.
 */</comment>
<function><type><name>void</name></type> <name>AssignParentMotionToPlanNodes</name><parameter_list>(<parameter><decl><type><name>PlannedStmt</name> <modifier>*</modifier></type><name>plannedstmt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>MotionAssignerContext</name></type> <name>ctx</name></decl>;</decl_stmt>
	<expr_stmt><expr><name><name>ctx</name><operator>.</operator><name>base</name><operator>.</operator><name>node</name></name> <operator>=</operator> <operator>(</operator><name>Node</name><operator>*</operator><operator>)</operator><name>plannedstmt</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ctx</name><operator>.</operator><name>motStack</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>MotionAssignerWalker</name><argument_list>(<argument><expr><name><name>plannedstmt</name><operator>-&gt;</operator><name>planTree</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* The entire motion stack should have been unwounded */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>ctx</name><operator>.</operator><name>motStack</name></name> <operator>==</operator> <name>NIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block" format="doxygen">/**
 * Provide index of locally executing slice
 */</comment>
<function><type><name>int</name></type> <name>LocallyExecutingSliceIndex</name><parameter_list>(<parameter><decl><type><name>EState</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><operator>(</operator><ternary><condition><expr><operator>!</operator><name><name>estate</name><operator>-&gt;</operator><name>es_sliceTable</name></name></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><name><name>estate</name><operator>-&gt;</operator><name>es_sliceTable</name><operator>-&gt;</operator><name>localSlice</name></name></expr></else></ternary><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>FillSliceGangInfo</name><parameter_list>(<parameter><decl><type><name>ExecSlice</name> <modifier>*</modifier></type><name>slice</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>numsegments</name></decl></parameter>, <parameter><decl><type><name>DirectDispatchInfo</name> <modifier>*</modifier></type><name>dd</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>k</name></decl>;</decl_stmt>

	<switch>switch <condition>(<expr><name><name>slice</name><operator>-&gt;</operator><name>gangType</name></name></expr>)</condition>
	<block>{<block_content>
	<case>case <expr><name>GANGTYPE_UNALLOCATED</name></expr>:</case>
		<comment type="block">/*
		 * It's either the root slice or an InitPlan slice that runs in
		 * the QC process, or really unused slice.
		 */</comment>
		<expr_stmt><expr><name><name>slice</name><operator>-&gt;</operator><name>planNumSegments</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
		<break>break;</break>
	<case>case <expr><name>GANGTYPE_PRIMARY_WRITER</name></expr>:</case>
		<comment type="line">// Write Segments are same as Read Currently</comment>
		<expr_stmt><expr><name><name>slice</name><operator>-&gt;</operator><name>planNumSegments</name></name> <operator>=</operator> <name>numsegments</name></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>slice</name><operator>-&gt;</operator><name>segments</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>

		<for>for<control>(<init><expr><name>k</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init><condition><expr><name>k</name> <operator>&lt;</operator> <name>numsegments</name></expr>;</condition> <incr><expr><name>k</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>slice</name><operator>-&gt;</operator><name>segments</name></name> <operator>=</operator> <call><name>lappend_int</name><argument_list>(<argument><expr><name><name>slice</name><operator>-&gt;</operator><name>segments</name></name></expr></argument>,<argument><expr><name>RW_SEGMENT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
		<break>break;</break>
	<case>case <expr><name>GANGTYPE_PRIMARY_READER</name></expr>:</case>
		<expr_stmt><expr><name><name>slice</name><operator>-&gt;</operator><name>planNumSegments</name></name> <operator>=</operator> <name>numsegments</name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>dd</name><operator>-&gt;</operator><name>isDirectDispatch</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>slice</name><operator>-&gt;</operator><name>segments</name></name> <operator>=</operator> <call><name>list_copy</name><argument_list>(<argument><expr><name><name>dd</name><operator>-&gt;</operator><name>contentIds</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
			<expr_stmt><expr><name><name>slice</name><operator>-&gt;</operator><name>segments</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
			<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>numsegments</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>slice</name><operator>-&gt;</operator><name>segments</name></name> <operator>=</operator> <call><name>lappend_int</name><argument_list>(<argument><expr><name><name>slice</name><operator>-&gt;</operator><name>segments</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
		</block_content>}</block></else></if_stmt>
		<break>break;</break>
	<case>case <expr><name>GANGTYPE_ENTRYDB_READER</name></expr>:</case>
		<expr_stmt><expr><name><name>slice</name><operator>-&gt;</operator><name>planNumSegments</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>slice</name><operator>-&gt;</operator><name>segments</name></name> <operator>=</operator> <call><name>list_make1_int</name><argument_list>(<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<break>break;</break>
	<case>case <expr><name>GANGTYPE_SINGLETON_READER</name></expr>:</case>
		<expr_stmt><expr><name><name>slice</name><operator>-&gt;</operator><name>planNumSegments</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>slice</name><operator>-&gt;</operator><name>segments</name></name> <operator>=</operator> <call><name>list_make1_int</name><argument_list>(<argument><expr><name>px_session_id</name> <operator>%</operator> <name>numsegments</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<break>break;</break>
	<default>default:</default>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unexpected gang type"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></switch>
</block_content>}</block></function>

<comment type="block">/*
 * POLAR px
 * Create the executor slice table.
 *
 * The planner constructed a slice table, in plannedstmt-&gt;slices. Turn that
 * into an "executor slice table", with slightly more information. The gangs
 * to execute the slices will be set up later.
 */</comment>
<function><type><name>SliceTable</name> <modifier>*</modifier></type>
<name>InitSliceTable</name><parameter_list>(<parameter><decl><type><name>EState</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>, <parameter><decl><type><name>PlannedStmt</name> <modifier>*</modifier></type><name>plannedstmt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>SliceTable</name> <modifier>*</modifier></type><name>table</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>numSlices</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcontext</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>numSlices</name> <operator>=</operator> <name><name>plannedstmt</name><operator>-&gt;</operator><name>numSlices</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>numSlices</name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>px_max_slices</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>numSlices</name> <operator>&gt;</operator> <name>px_max_slices</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_PROGRAM_LIMIT_EXCEEDED</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"at most %d slices are allowed in a query, current number: %d"</literal></expr></argument>,
						<argument><expr><name>px_max_slices</name></expr></argument>, <argument><expr><name>numSlices</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"rewrite your query or adjust GUC px_max_slices"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>oldcontext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>estate</name><operator>-&gt;</operator><name>es_query_cxt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>table</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>SliceTable</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>table</name><operator>-&gt;</operator><name>instrument_options</name></name> <operator>=</operator> <name>INSTRUMENT_NONE</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>table</name><operator>-&gt;</operator><name>hasMotions</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Initialize the executor slice table.
	 *
	 * We have most of the information in the planner slice table. In addition to that,
	 * we set up the parent-child relationships.
	 */</comment>
	<expr_stmt><expr><name><name>table</name><operator>-&gt;</operator><name>slices</name></name> <operator>=</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ExecSlice</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>numSlices</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>numSlices</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ExecSlice</name>  <modifier>*</modifier></type><name>currExecSlice</name> <init>= <expr><operator>&amp;</operator><name><name>table</name><operator>-&gt;</operator><name>slices</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>PlanSlice</name>  <modifier>*</modifier></type><name>currPlanSlice</name> <init>= <expr><operator>&amp;</operator><name><name>plannedstmt</name><operator>-&gt;</operator><name>slices</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>parentIndex</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>rootIndex</name></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>currExecSlice</name><operator>-&gt;</operator><name>sliceIndex</name></name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>currExecSlice</name><operator>-&gt;</operator><name>planNumSegments</name></name> <operator>=</operator> <name><name>currPlanSlice</name><operator>-&gt;</operator><name>numsegments</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>currExecSlice</name><operator>-&gt;</operator><name>segments</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>currExecSlice</name><operator>-&gt;</operator><name>primaryGang</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>currExecSlice</name><operator>-&gt;</operator><name>primaryProcesses</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>

		<expr_stmt><expr><name>parentIndex</name> <operator>=</operator> <name><name>currPlanSlice</name><operator>-&gt;</operator><name>parentIndex</name></name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>parentIndex</name> <operator>&lt;</operator> <operator>-</operator><literal type="number">1</literal> <operator>||</operator> <name>parentIndex</name> <operator>&gt;=</operator> <name>numSlices</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"invalid parent slice index %d"</literal></expr></argument>, <argument><expr><name><name>currPlanSlice</name><operator>-&gt;</operator><name>parentIndex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>parentIndex</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>ExecSlice</name> <modifier>*</modifier></type><name>parentExecSlice</name> <init>= <expr><operator>&amp;</operator><name><name>table</name><operator>-&gt;</operator><name>slices</name><index>[<expr><name>parentIndex</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int</name></type>			<name>counter</name></decl>;</decl_stmt>

			<comment type="block">/* Sending slice is a child of recv slice */</comment>
			<expr_stmt><expr><name><name>parentExecSlice</name><operator>-&gt;</operator><name>children</name></name> <operator>=</operator> <call><name>lappend_int</name><argument_list>(<argument><expr><name><name>parentExecSlice</name><operator>-&gt;</operator><name>children</name></name></expr></argument>, <argument><expr><name><name>currPlanSlice</name><operator>-&gt;</operator><name>sliceIndex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* Find the root slice */</comment>
			<expr_stmt><expr><name>rootIndex</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>counter</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			<while>while <condition>(<expr><name><name>plannedstmt</name><operator>-&gt;</operator><name>slices</name><index>[<expr><name>rootIndex</name></expr>]</index></name><operator>.</operator><name>parentIndex</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>rootIndex</name> <operator>=</operator> <name><name>plannedstmt</name><operator>-&gt;</operator><name>slices</name><index>[<expr><name>rootIndex</name></expr>]</index></name><operator>.</operator><name>parentIndex</name></expr>;</expr_stmt>

				<if_stmt><if>if <condition>(<expr><name>counter</name><operator>++</operator> <operator>&gt;</operator> <name>numSlices</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"circular parent-child relationship in slice table"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block></while>
			<expr_stmt><expr><name><name>table</name><operator>-&gt;</operator><name>hasMotions</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>rootIndex</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<comment type="block">/* find root of this slice. All the parents should be initialized already */</comment>

		<expr_stmt><expr><name><name>currExecSlice</name><operator>-&gt;</operator><name>parentIndex</name></name> <operator>=</operator> <name>parentIndex</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>currExecSlice</name><operator>-&gt;</operator><name>rootIndex</name></name> <operator>=</operator> <name>rootIndex</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>currExecSlice</name><operator>-&gt;</operator><name>gangType</name></name> <operator>=</operator> <name><name>currPlanSlice</name><operator>-&gt;</operator><name>gangType</name></name></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>FillSliceGangInfo</name><argument_list>(<argument><expr><name>currExecSlice</name></expr></argument>, <argument><expr><name><name>currPlanSlice</name><operator>-&gt;</operator><name>numsegments</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>currPlanSlice</name><operator>-&gt;</operator><name>directDispatch</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>
	<expr_stmt><expr><name><name>table</name><operator>-&gt;</operator><name>numSlices</name></name> <operator>=</operator> <name>numSlices</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>table</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>bool</name></type>
<name>HasMotion</name><parameter_list>(<parameter><decl><type><name>PlannedStmt</name> <modifier>*</modifier></type><name>plannedstmt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>plannedstmt</name><operator>-&gt;</operator><name>numSlices</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>plannedstmt</name><operator>-&gt;</operator><name>slices</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>parentIndex</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></for>
	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>
<typedef>typedef <type><struct>struct <name>SplitFinderContext</name>
<block>{
	<decl_stmt><decl><type><name>plan_tree_base_prefix</name></type> <name>base</name></decl>;</decl_stmt> <comment type="block">/* Required prefix for plan_tree_walker/mutator */</comment>
}</block></struct></type> <name>SplitFinderContext</name>;</typedef>


<function><type><name>bool</name></type> <name>HasSplit</name><parameter_list>(<parameter><decl><type><name>PlannedStmt</name> <modifier>*</modifier></type><name>plannedstmt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>SplitFinderContext</name></type> <name>ctx</name></decl>;</decl_stmt>
	<expr_stmt><expr><name><name>ctx</name><operator>.</operator><name>base</name><operator>.</operator><name>node</name></name> <operator>=</operator> <operator>(</operator><name>Node</name><operator>*</operator><operator>)</operator><name>plannedstmt</name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>plannedstmt</name> <operator>||</operator> <name>CMD_UPDATE</name> <operator>!=</operator> <name><name>plannedstmt</name><operator>-&gt;</operator><name>commandType</name></name> <operator>||</operator> <operator>!</operator><name>polar_enable_px</name> <operator>||</operator> <operator>!</operator><name>px_enable_update</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
	<return>return <expr><call><name>SplitSearchWalker</name><argument_list>(<argument><expr><name><name>plannedstmt</name><operator>-&gt;</operator><name>planTree</name></name></expr></argument>,<argument><expr><operator>&amp;</operator><name>ctx</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * POLAR px: A forgiving slice table indexer that returns the indexed Slice* or NULL
 */</comment>
<function><type><name>ExecSlice</name> <modifier>*</modifier></type>
<name>getCurrentSlice</name><parameter_list>(<parameter><decl><type><name>EState</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>sliceIndex</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>SliceTable</name> <modifier>*</modifier></type><name>sliceTable</name> <init>= <expr><name><name>estate</name><operator>-&gt;</operator><name>es_sliceTable</name></name></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>sliceTable</name> <operator>&amp;&amp;</operator>
		<name>sliceIndex</name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
		<name>sliceIndex</name> <operator>&lt;</operator> <name><name>sliceTable</name><operator>-&gt;</operator><name>numSlices</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><operator>&amp;</operator><name><name>sliceTable</name><operator>-&gt;</operator><name>slices</name><index>[<expr><name>sliceIndex</name></expr>]</index></name></expr>;</return></block_content></block></if></if_stmt>

    <return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * POLAR px
 * Should the slice run on the QC
 * N.B. Not the same as !sliceRunsOnPX(slice), when slice is NULL.
 */</comment>
<function><type><name>bool</name></type>
<name>sliceRunsOnQC</name><parameter_list>(<parameter><decl><type><name>ExecSlice</name> <modifier>*</modifier></type><name>slice</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><operator>(</operator><name>slice</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name><name>slice</name><operator>-&gt;</operator><name>gangType</name></name> <operator>==</operator> <name>GANGTYPE_UNALLOCATED</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * Should the slice run on a PX
 * N.B. Not the same as !sliceRunsOnQC(slice), when slice is NULL.
 */</comment>
<function><type><name>bool</name></type>
<name>sliceRunsOnPX</name><parameter_list>(<parameter><decl><type><name>ExecSlice</name> <modifier>*</modifier></type><name>slice</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><operator>(</operator><name>slice</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name><name>slice</name><operator>-&gt;</operator><name>gangType</name></name> <operator>!=</operator> <name>GANGTYPE_UNALLOCATED</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
 * Calculate the number of sending processes that should in be a slice.
 */</comment>
<function><type><name>int</name></type>
<name>sliceCalculateNumSendingProcesses</name><parameter_list>(<parameter><decl><type><name>ExecSlice</name> <modifier>*</modifier></type><name>slice</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<switch>switch<condition>(<expr><name><name>slice</name><operator>-&gt;</operator><name>gangType</name></name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>GANGTYPE_UNALLOCATED</name></expr>:</case>
			<return>return <expr><literal type="number">0</literal></expr>;</return> <comment type="block">/* does not send */</comment>

		<case>case <expr><name>GANGTYPE_ENTRYDB_READER</name></expr>:</case>
			<return>return <expr><literal type="number">1</literal></expr>;</return> <comment type="block">/* on master */</comment>

		<case>case <expr><name>GANGTYPE_SINGLETON_READER</name></expr>:</case>
			<return>return <expr><literal type="number">1</literal></expr>;</return> <comment type="block">/* on segment */</comment>

		<case>case <expr><name>GANGTYPE_PRIMARY_WRITER</name></expr>:</case>
		<case>case <expr><name>GANGTYPE_PRIMARY_READER</name></expr>:</case>
			<return>return <expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>slice</name><operator>-&gt;</operator><name>segments</name></name></expr></argument>)</argument_list></call></expr>;</return>

		<default>default:</default>
			<expr_stmt><expr><call><name>Insist</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
	</block_content>}</block></switch>
</block_content>}</block></function>

<comment type="block">/* Forward declarations */</comment>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>InventorySliceTree</name><parameter_list>(<parameter><decl><type><name>PxDispatcherState</name> <modifier>*</modifier></type><name>ds</name></decl></parameter>, <parameter><decl><type><name>SliceTable</name> <modifier>*</modifier></type><name>sliceTable</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>sliceIndex</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/*
 * AssignWriterGangFirst() - Try to assign writer gang first.
 *
 * For the gang allocation, our current implementation required the first
 * allocated gang must be the writer gang.
 * This has several reasons:
 * - For lock holding, Because of our MPP structure, we assign a LockHolder
 *   for each segment when executing a query. lockHolder is the gang member that
 *   should hold and manage locks for this transaction. On the QEs, it should
 *   normally be the Writer gang member. More details please refer to
 *   lockHolderProcPtr in lock.c.
 * - For SharedSnapshot among session's gang processes on a particular segment.
 *   During initPostgres(), reader QE will try to lookup the shared slot written
 *   by writer QE. More details please reger to sharedsnapshot.c.
 *
 * Normally, the writer slice will be assign writer gang first when iterate the
 * slice table. But this is not true for writable CTE (with only one writer gang).
 * For below statement:
 *
 * WITH updated AS (update tbl set rank = 6 where id = 5 returning rank)
 * select * from tbl where rank in (select rank from updated);
 *                                           QUERY PLAN
 * ----------------------------------------------------------------------------------------------
 *  Gather Motion 3:1  (slice1; segments: 3)
 *    -&gt;  Seq Scan on tbl
 *          Filter: (hashed SubPlan 1)
 *          SubPlan 1
 *            -&gt;  Broadcast Motion 1:3  (slice2; segments: 1)
 *                  -&gt;  Update on tbl
 *                        -&gt;  Seq Scan on tbl
 *                              Filter: (id = 5)
 *  Slice 0: Dispatcher; root 0; parent -1; gang size 0
 *  Slice 1: Reader; root 0; parent 0; gang size 3
 *  Slice 2: Primary Writer; root 0; parent 1; gang size 1
 *
 * If we sill assign writer gang to Slice 1 here, the writer process will execute
 * on reader gang. So, find the writer slice and assign writer gang first.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>AssignWriterGangFirst</name><parameter_list>(<parameter><decl><type><name>PxDispatcherState</name> <modifier>*</modifier></type><name>ds</name></decl></parameter>, <parameter><decl><type><name>SliceTable</name> <modifier>*</modifier></type><name>sliceTable</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>sliceIndex</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ExecSlice</name>	   <modifier>*</modifier></type><name>slice</name> <init>= <expr><operator>&amp;</operator><name><name>sliceTable</name><operator>-&gt;</operator><name>slices</name><index>[<expr><name>sliceIndex</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>slice</name><operator>-&gt;</operator><name>gangType</name></name> <operator>==</operator> <name>GANGTYPE_PRIMARY_WRITER</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>slice</name><operator>-&gt;</operator><name>primaryGang</name></name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>slice</name><operator>-&gt;</operator><name>segments</name></name> <operator>!=</operator> <name>NIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>slice</name><operator>-&gt;</operator><name>primaryGang</name></name> <operator>=</operator> <call><name>AllocateGang</name><argument_list>(<argument><expr><name>ds</name></expr></argument>, <argument><expr><name><name>slice</name><operator>-&gt;</operator><name>gangType</name></name></expr></argument>, <argument><expr><name><name>slice</name><operator>-&gt;</operator><name>segments</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>setupPxProcessList</name><argument_list>(<argument><expr><name>slice</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>cell</name></decl>;</decl_stmt>
		<macro><name>foreach</name><argument_list>(<argument>cell</argument>, <argument>slice-&gt;children</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>int</name></type>			<name>childIndex</name> <init>= <expr><call><name>lfirst_int</name><argument_list>(<argument><expr><name>cell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<if_stmt><if>if <condition>(<expr><call><name>AssignWriterGangFirst</name><argument_list>(<argument><expr><name>ds</name></expr></argument>, <argument><expr><name>sliceTable</name></expr></argument>, <argument><expr><name>childIndex</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
		</block_content>}</block>
	</block_content>}</block></else></if_stmt>
	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * POLAR px
 * Function AssignGangs runs on the QC and finishes construction of the
 * global slice table for a plan by assigning gangs allocated by the
 * executor factory to the slices of the slice table.
 *
 * On entry, the executor slice table (at queryDesc-&gt;estate-&gt;es_sliceTable)
 * has been initialized and has correct (by InitSliceTable function)
 *
 * Gang assignment involves taking an inventory of the requirements of
 * each slice tree in the slice table, asking the executor factory to
 * allocate a minimal set of gangs that can satisfy any of the slice trees,
 * and associating the allocated gangs with slices in the slice table.
 *
 * On successful exit, the PXProcess lists (primaryProcesses, mirrorProcesses)
 * and the Gang pointers (primaryGang, mirrorGang) are set correctly in each
 * slice in the slice table.
 */</comment>
<function><type><name>void</name></type>
<name>AssignGangs</name><parameter_list>(<parameter><decl><type><name>PxDispatcherState</name> <modifier>*</modifier></type><name>ds</name></decl></parameter>, <parameter><decl><type><name>QueryDesc</name> <modifier>*</modifier></type><name>queryDesc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>SliceTable</name>	<modifier>*</modifier></type><name>sliceTable</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>EState</name>		<modifier>*</modifier></type><name>estate</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>rootIdx</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>estate</name> <operator>=</operator> <name><name>queryDesc</name><operator>-&gt;</operator><name>estate</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>sliceTable</name> <operator>=</operator> <name><name>estate</name><operator>-&gt;</operator><name>es_sliceTable</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>rootIdx</name> <operator>=</operator> <call><name>RootSliceIndex</name><argument_list>(<argument><expr><name><name>queryDesc</name><operator>-&gt;</operator><name>estate</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* cleanup processMap because initPlan and main Plan share the same slice table */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>sliceTable</name><operator>-&gt;</operator><name>numSlices</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>sliceTable</name><operator>-&gt;</operator><name>slices</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>processesMap</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></for>

	<comment type="block">/* POLAR px */</comment>
	<expr_stmt><expr><call><name>AssignWriterGangFirst</name><argument_list>(<argument><expr><name>ds</name></expr></argument>, <argument><expr><name>sliceTable</name></expr></argument>, <argument><expr><name>rootIdx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* POALR end */</comment>
	<expr_stmt><expr><call><name>InventorySliceTree</name><argument_list>(<argument><expr><name>ds</name></expr></argument>, <argument><expr><name>sliceTable</name></expr></argument>, <argument><expr><name>rootIdx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Helper for AssignGangs takes a simple inventory of the gangs required
 * by a slice tree.  Recursive.  Closely coupled with AssignGangs.	Not
 * generally useful.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>InventorySliceTree</name><parameter_list>(<parameter><decl><type><name>PxDispatcherState</name> <modifier>*</modifier></type><name>ds</name></decl></parameter>, <parameter><decl><type><name>SliceTable</name> <modifier>*</modifier></type><name>sliceTable</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>sliceIndex</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ExecSlice</name> <modifier>*</modifier></type><name>slice</name> <init>= <expr><operator>&amp;</operator><name><name>sliceTable</name><operator>-&gt;</operator><name>slices</name><index>[<expr><name>sliceIndex</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>cell</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>slice</name><operator>-&gt;</operator><name>gangType</name></name> <operator>==</operator> <name>GANGTYPE_UNALLOCATED</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>slice</name><operator>-&gt;</operator><name>primaryGang</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>slice</name><operator>-&gt;</operator><name>primaryProcesses</name></name> <operator>=</operator> <call><name>getPxProcessesForQC</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><operator>!</operator><name><name>slice</name><operator>-&gt;</operator><name>primaryGang</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>slice</name><operator>-&gt;</operator><name>segments</name></name> <operator>!=</operator> <name>NIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>slice</name><operator>-&gt;</operator><name>primaryGang</name></name> <operator>=</operator> <call><name>AllocateGang</name><argument_list>(<argument><expr><name>ds</name></expr></argument>, <argument><expr><name><name>slice</name><operator>-&gt;</operator><name>gangType</name></name></expr></argument>, <argument><expr><name><name>slice</name><operator>-&gt;</operator><name>segments</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>setupPxProcessList</name><argument_list>(<argument><expr><name>slice</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<macro><name>foreach</name><argument_list>(<argument>cell</argument>, <argument>slice-&gt;children</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>childIndex</name> <init>= <expr><call><name>lfirst_int</name><argument_list>(<argument><expr><name>cell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>InventorySliceTree</name><argument_list>(<argument><expr><name>ds</name></expr></argument>, <argument><expr><name>sliceTable</name></expr></argument>, <argument><expr><name>childIndex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
</block_content>}</block></function>

<comment type="block">/*
 * Choose the execution identity (who does this executor serve?).
 * There are types:
 *
 * 1. No-Op (ignore) -- this occurs when the specified direction is
 *	 NoMovementScanDirection or when px_role is PX_ROLE_QC
 *	 and the current slice belongs to a PX.
 *
 * 2. Executor serves a Root Slice -- this occurs when px_role is
 *   PX_ROLE_UTILITY or the current slice is a root.  It corresponds
 *   to the "normal" path through the executor in that we enter the plan
 *   at the top and count on the motion nodes at the fringe of the top
 *   slice to return without ever calling nodes below them.
 *
 * 3. Executor serves a Non-Root Slice on a PX -- this occurs when
 *   px_role is PX_ROLE_PX and the current slice is not a root
 *   slice. It corresponds to a PX running a slice with a motion node on
 *	 top.  The call, thus, returns no tuples (since they all go out
 *	 on the interconnect to the receiver version of the motion node),
 *	 but it does execute the indicated slice down to any fringe
 *	 motion nodes (as in case 2).
 */</comment>
<function><type><name>PxExecIdentity</name></type>
<name>getPxExecIdentity</name><parameter_list>(<parameter><decl><type><name>QueryDesc</name> <modifier>*</modifier></type><name>queryDesc</name></decl></parameter>,
				  <parameter><decl><type><name>ScanDirection</name></type> <name>direction</name></decl></parameter>,
				  <parameter><decl><type><name>EState</name>	   <modifier>*</modifier></type><name>estate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ExecSlice</name> <modifier>*</modifier></type><name>currentSlice</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>currentSlice</name> <operator>=</operator> <call><name>getCurrentSlice</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><call><name>LocallyExecutingSliceIndex</name><argument_list>(<argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>currentSlice</name></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>px_role</name> <operator>==</operator> <name>PX_ROLE_PX</name> <operator>||</operator>
            <call><name>sliceRunsOnQC</name><argument_list>(<argument><expr><name>currentSlice</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>currentSliceId</name> <operator>=</operator> <name><name>currentSlice</name><operator>-&gt;</operator><name>sliceIndex</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

	<comment type="block">/* select the strategy */</comment>
	<if_stmt><if>if <condition>(<expr><name>direction</name> <operator>==</operator> <name>NoMovementScanDirection</name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>PX_IGNORE</name></expr>;</return>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>px_role</name> <operator>==</operator> <name>PX_ROLE_QC</name> <operator>&amp;&amp;</operator> <call><name>sliceRunsOnPX</name><argument_list>(<argument><expr><name>currentSlice</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>PX_IGNORE</name></expr>;</return>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>px_role</name> <operator>==</operator> <name>PX_ROLE_PX</name> <operator>&amp;&amp;</operator> <call><name>LocallyExecutingSliceIndex</name><argument_list>(<argument><expr><name>estate</name></expr></argument>)</argument_list></call> <operator>!=</operator> <call><name>RootSliceIndex</name><argument_list>(<argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>PX_NON_ROOT_ON_PX</name></expr>;</return>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<return>return <expr><name>PX_ROOT_SLICE</name></expr>;</return>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * End the gp-specific part of the executor.
 *
 * In here we collect the dispatch results if there are any, tear
 * down the interconnect if it is set-up.
 */</comment>
<function><type><name>void</name></type>
<name>ExecutorFinishup_PX</name><parameter_list>(<parameter><decl><type><name>QueryDesc</name> <modifier>*</modifier></type><name>queryDesc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>EState</name>	   <modifier>*</modifier></type><name>estate</name></decl>;</decl_stmt>

	<comment type="block">/* caller must have switched into per-query memory context already */</comment>
	<expr_stmt><expr><name>estate</name> <operator>=</operator> <name><name>queryDesc</name><operator>-&gt;</operator><name>estate</name></name></expr>;</expr_stmt>

     <comment type="block">/* Teardown the Interconnect */</comment>
     <if_stmt><if>if <condition>(<expr><name><name>estate</name><operator>-&gt;</operator><name>es_interconnect_is_setup</name></name></expr>)</condition>
     <block>{<block_content>
		<expr_stmt><expr><call><name>TeardownInterconnect</name><argument_list>(<argument><expr><name><name>estate</name><operator>-&gt;</operator><name>interconnect_context</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>interconnect_context</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>es_interconnect_is_setup</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
     </block_content>}</block></if></if_stmt>
	<comment type="block">/*
	 * If QC, wait for PXs to finish and check their results.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>estate</name><operator>-&gt;</operator><name>dispatcherState</name></name> <operator>&amp;&amp;</operator> <name><name>estate</name><operator>-&gt;</operator><name>dispatcherState</name><operator>-&gt;</operator><name>primaryResults</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>PxDispatchResults</name> <modifier>*</modifier></type><name>pr</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>PxDispatcherState</name> <modifier>*</modifier></type><name>ds</name> <init>= <expr><name><name>estate</name><operator>-&gt;</operator><name>dispatcherState</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>DispatchWaitMode</name></type> <name>waitMode</name> <init>= <expr><name>DISPATCH_WAIT_NONE</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ErrorData</name> <modifier>*</modifier></type><name>pxError</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type> <name>primaryWriterSliceIndex</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * If we are finishing a query before all the tuples of the query
		 * plan were fetched we must call ExecSquelchNode before checking
		 * the dispatch results in order to tell the nodes below we no longer
		 * need any more tuples.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>estate</name><operator>-&gt;</operator><name>es_got_eos</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ExecSquelchNode</name><argument_list>(<argument><expr><name><name>queryDesc</name><operator>-&gt;</operator><name>planstate</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * Wait for completion of all PXs.  We send a "graceful" query
		 * finish, not cancel signal.  Since the query has succeeded,
		 * don't confuse PXs by sending erroneous message.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>estate</name><operator>-&gt;</operator><name>cancelUnfinished</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>waitMode</name> <operator>=</operator> <name>DISPATCH_WAIT_FINISH</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>pxdisp_checkDispatchResult</name><argument_list>(<argument><expr><name>ds</name></expr></argument>, <argument><expr><name>waitMode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>pr</name> <operator>=</operator> <call><name>pxdisp_getDispatchResults</name><argument_list>(<argument><expr><name>ds</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pxError</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>pxError</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>pxdisp_finishPqThread</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>dispatcherState</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>FlushErrorState</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>ReThrowError</name><argument_list>(<argument><expr><name>pxError</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* If top slice was delegated to PXs, get num of rows processed. */</comment>
		<expr_stmt><expr><name>primaryWriterSliceIndex</name> <operator>=</operator> <call><name>PrimaryWriterSliceIndex</name><argument_list>(<argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<block>{<block_content>
			<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>es_processed</name></name> <operator>+=</operator>
				<call><name>pxdisp_sumCmdTuples</name><argument_list>(<argument><expr><name>pr</name></expr></argument>, <argument><expr><name>primaryWriterSliceIndex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>es_lastoid</name></name> <operator>=</operator>
				<call><name>pxdisp_maxLastOid</name><argument_list>(<argument><expr><name>pr</name></expr></argument>, <argument><expr><name>primaryWriterSliceIndex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>

		<comment type="block">/* sum up rejected rows if any (single row error handling only) */</comment>
		<expr_stmt><expr><call><name>pxdisp_sumRejectedRows</name><argument_list>(<argument><expr><name>pr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Check and free the results of all gangs. If any PX had an
		 * error, report it and exit to our error handler via PG_THROW.
		 * NB: This call doesn't wait, because we already waited above.
		 */</comment>
		<expr_stmt><expr><call><name>pxdisp_finishPqThread</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>dispatcherState</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pxdisp_destroyDispatcherState</name><argument_list>(<argument><expr><name>ds</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Cleanup the gp-specific parts of the query executor.
 *
 * Will normally be called after an error from within a CATCH block.
 */</comment>
<function><type><name>void</name></type> <name>ExecutorCleanup_PX</name><parameter_list>(<parameter><decl><type><name>QueryDesc</name> <modifier>*</modifier></type><name>queryDesc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PxDispatcherState</name> <modifier>*</modifier></type><name>ds</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>EState</name>	   <modifier>*</modifier></type><name>estate</name></decl>;</decl_stmt>

	<comment type="block">/* caller must have switched into per-query memory context already */</comment>
	<expr_stmt><expr><name>estate</name> <operator>=</operator> <name><name>queryDesc</name><operator>-&gt;</operator><name>estate</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>ds</name> <operator>=</operator> <name><name>estate</name><operator>-&gt;</operator><name>dispatcherState</name></name></expr>;</expr_stmt>

    <comment type="block">/* Clean up the interconnect. */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>estate</name><operator>-&gt;</operator><name>es_interconnect_is_setup</name></name></expr>)</condition>
    <block>{<block_content>
		<expr_stmt><expr><call><name>TeardownInterconnect</name><argument_list>(<argument><expr><name><name>estate</name><operator>-&gt;</operator><name>interconnect_context</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>es_interconnect_is_setup</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
	<comment type="block">/*
	 * Request any commands still executing on qExecs to stop.
	 * Wait for them to finish and clean up the dispatching structures.
	 * Replace current error info with PX error info if more interesting.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>ds</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>PxDispatchHandleError</name><argument_list>(<argument><expr><name>ds</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>pxdisp_finishPqThread</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>dispatcherState</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pxdisp_destroyDispatcherState</name><argument_list>(<argument><expr><name>ds</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
 * Methods to find motionstate object within a planstate tree given a motion id (which is the same as slice index)
 */</comment>
<typedef>typedef <type><struct>struct <name>MotionStateFinderContext</name>
<block>{
	<decl_stmt><decl><type><name>int</name></type> <name>motionId</name></decl>;</decl_stmt> <comment type="block">/* Input */</comment>
	<decl_stmt><decl><type><name>MotionState</name> <modifier>*</modifier></type><name>motionState</name></decl>;</decl_stmt> <comment type="block">/* Output */</comment>
}</block></struct></type> <name>MotionStateFinderContext</name>;</typedef>

<comment type="block" format="doxygen">/**
 * Walker method that finds motion state node within a planstate tree.
 */</comment>
<function><type><specifier>static</specifier> <name>PxVisitOpt</name></type>
<name>MotionStateFinderWalker</name><parameter_list>(<parameter><decl><type><name>PlanState</name> <modifier>*</modifier></type><name>node</name></decl></parameter>,
				  <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>MotionStateFinderContext</name> <modifier>*</modifier></type><name>ctx</name> <init>= <expr><operator>(</operator><name>MotionStateFinderContext</name> <operator>*</operator><operator>)</operator> <name>context</name></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>MotionState</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>MotionState</name> <modifier>*</modifier></type><name>ms</name> <init>= <expr><operator>(</operator><name>MotionState</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Motion</name> <modifier>*</modifier></type><name>m</name> <init>= <expr><operator>(</operator><name>Motion</name> <operator>*</operator><operator>)</operator> <name><name>ms</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>plan</name></name></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>m</name><operator>-&gt;</operator><name>motionID</name></name> <operator>==</operator> <name><name>ctx</name><operator>-&gt;</operator><name>motionId</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>motionState</name></name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>motionState</name></name> <operator>=</operator> <name>ms</name></expr>;</expr_stmt>
			<return>return <expr><name>PxVisit_Skip</name></expr>;</return>	<comment type="block">/* don't visit subtree */</comment>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Continue walking */</comment>
	<return>return <expr><name>PxVisit_Walk</name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
 * Given a slice index, find the motionstate that corresponds to this slice index. This will iterate over the planstate tree
 * to get the right node.
 */</comment>
<function><type><name>MotionState</name> <modifier>*</modifier></type>
<name>getMotionState</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>PlanState</name></name> <modifier>*</modifier></type><name>ps</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>sliceIndex</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>MotionStateFinderContext</name></type> <name>ctx</name></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>ps</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>sliceIndex</name> <operator>&gt;</operator> <operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>ctx</name><operator>.</operator><name>motionId</name></name> <operator>=</operator> <name>sliceIndex</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ctx</name><operator>.</operator><name>motionState</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>planstate_walk_node</name><argument_list>(<argument><expr><name>ps</name></expr></argument>, <argument><expr><name>MotionStateFinderWalker</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>ctx</name><operator>.</operator><name>motionState</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"could not find MotionState for slice %d in executor tree"</literal></expr></argument>, <argument><expr><name>sliceIndex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name><name>ctx</name><operator>.</operator><name>motionState</name></name></expr>;</return>
</block_content>}</block></function>

<typedef>typedef <type><struct>struct <name>MotionFinderContext</name>
<block>{
	<decl_stmt><decl><type><name>plan_tree_base_prefix</name></type> <name>base</name></decl>;</decl_stmt> <comment type="block">/* Required prefix for plan_tree_walker/mutator */</comment>
	<decl_stmt><decl><type><name>int</name></type> <name>motionId</name></decl>;</decl_stmt> <comment type="block">/* Input */</comment>
	<decl_stmt><decl><type><name>Motion</name> <modifier>*</modifier></type><name>motion</name></decl>;</decl_stmt> <comment type="block">/* Output */</comment>
}</block></struct></type> <name>MotionFinderContext</name>;</typedef>

<comment type="block">/*
 * Walker to find a motion node that matches a particular motionID
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>MotionFinderWalker</name><parameter_list>(<parameter><decl><type><name>Plan</name> <modifier>*</modifier></type><name>node</name></decl></parameter>,
				  <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>MotionFinderContext</name> <modifier>*</modifier></type><name>ctx</name> <init>= <expr><operator>(</operator><name>MotionFinderContext</name> <operator>*</operator><operator>)</operator> <name>context</name></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>node</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>Motion</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Motion</name> <modifier>*</modifier></type><name>m</name> <init>= <expr><operator>(</operator><name>Motion</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>m</name><operator>-&gt;</operator><name>motionID</name></name> <operator>==</operator> <name><name>ctx</name><operator>-&gt;</operator><name>motionId</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>motion</name></name> <operator>=</operator> <name>m</name></expr>;</expr_stmt>
			<return>return <expr><name>true</name></expr>;</return>	<comment type="block">/* found our node; no more visit */</comment>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Continue walking */</comment>
	<return>return <expr><call><name>plan_tree_walker</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name><operator>*</operator><operator>)</operator><name>node</name></expr></argument>, <argument><expr><name>MotionFinderWalker</name></expr></argument>, <argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Given the Plan and a Slice index, find the motion node that is the root of the slice's subtree.
 */</comment>
<function><type><name>Motion</name> <modifier>*</modifier></type><name>findSenderMotion</name><parameter_list>(<parameter><decl><type><name>PlannedStmt</name> <modifier>*</modifier></type><name>plannedstmt</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>sliceIndex</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Plan</name> <modifier>*</modifier></type><name>planTree</name> <init>= <expr><name><name>plannedstmt</name><operator>-&gt;</operator><name>planTree</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MotionFinderContext</name></type> <name>ctx</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>sliceIndex</name> <operator>&gt;</operator> <operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>ctx</name><operator>.</operator><name>base</name><operator>.</operator><name>node</name></name> <operator>=</operator> <operator>(</operator><name>Node</name><operator>*</operator><operator>)</operator><name>plannedstmt</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ctx</name><operator>.</operator><name>motionId</name></name> <operator>=</operator> <name>sliceIndex</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ctx</name><operator>.</operator><name>motion</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>MotionFinderWalker</name><argument_list>(<argument><expr><name>planTree</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name><name>ctx</name><operator>.</operator><name>motion</name></name></expr>;</return>
</block_content>}</block></function>

<typedef>typedef <type><struct>struct <name>ParamExtractorContext</name>
<block>{
	<decl_stmt><decl><type><name>plan_tree_base_prefix</name></type> <name>base</name></decl>;</decl_stmt> <comment type="block">/* Required prefix for plan_tree_walker/mutator */</comment>
	<decl_stmt><decl><type><name>EState</name> <modifier>*</modifier></type><name>estate</name></decl>;</decl_stmt>
}</block></struct></type> <name>ParamExtractorContext</name>;</typedef>

<comment type="block">/*
 * Given a subplan determine if it is an initPlan (subplan-&gt;is_initplan) then copy its params
 * from estate-&gt; es_param_list_info to estate-&gt;es_param_exec_vals.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>ExtractSubPlanParam</name><parameter_list>(<parameter><decl><type><name>SubPlan</name> <modifier>*</modifier></type><name>subplan</name></decl></parameter>, <parameter><decl><type><name>EState</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * If this plan is un-correlated or undirect correlated one and want to
	 * set params for parent plan then mark parameters as needing evaluation.
	 *
	 * Note that in the case of un-correlated subqueries we don't care about
	 * setting parent-&gt;chgParam here: indices take care about it, for others -
	 * it doesn't matter...
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>subplan</name><operator>-&gt;</operator><name>setParam</name></name> <operator>!=</operator> <name>NIL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lst</name></decl>;</decl_stmt>

		<macro><name>foreach</name><argument_list>(<argument>lst</argument>, <argument>subplan-&gt;setParam</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>int</name></type>			<name>paramid</name> <init>= <expr><call><name>lfirst_int</name><argument_list>(<argument><expr><name>lst</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>ParamExecData</name> <modifier>*</modifier></type><name>prmExec</name> <init>= <expr><operator>&amp;</operator><operator>(</operator><name><name>estate</name><operator>-&gt;</operator><name>es_param_exec_vals</name><index>[<expr><name>paramid</name></expr>]</index></name><operator>)</operator></expr></init></decl>;</decl_stmt>

			<comment type="block" format="doxygen">/**
			 * Has this parameter been already
			 * evaluated as part of preprocess_initplan()? If so,
			 * we shouldn't re-evaluate it. If it has been evaluated,
			 * we will simply substitute the actual value from
			 * the external parameters.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>subplan</name><operator>-&gt;</operator><name>is_initplan</name></name></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>ParamListInfo</name></type> <name>paramInfo</name> <init>= <expr><name><name>estate</name><operator>-&gt;</operator><name>es_param_list_info</name></name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>ParamExternData</name> <modifier>*</modifier></type><name>prmExt</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>int</name></type> <name>extParamIndex</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>paramInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>paramInfo</name><operator>-&gt;</operator><name>numParams</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/*
				 * To locate the value of this pre-evaluated parameter, we need to find
				 * its location in the external parameter list.
				 */</comment>
				<expr_stmt><expr><name>extParamIndex</name> <operator>=</operator> <name><name>paramInfo</name><operator>-&gt;</operator><name>numParams</name></name> <operator>-</operator> <name><name>estate</name><operator>-&gt;</operator><name>es_plannedstmt</name><operator>-&gt;</operator><name>nParamExec</name></name> <operator>+</operator> <name>paramid</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>prmExt</name> <operator>=</operator> <operator>&amp;</operator><name><name>paramInfo</name><operator>-&gt;</operator><name>params</name><index>[<expr><name>extParamIndex</name></expr>]</index></name></expr>;</expr_stmt>

				<comment type="block">/* Make sure the types are valid */</comment>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>prmExt</name><operator>-&gt;</operator><name>ptype</name></name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name><name>prmExec</name><operator>-&gt;</operator><name>execPlan</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>prmExec</name><operator>-&gt;</operator><name>isnull</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>prmExec</name><operator>-&gt;</operator><name>value</name></name> <operator>=</operator> <operator>(</operator><name>Datum</name><operator>)</operator> <literal type="number">0</literal></expr>;</expr_stmt>
				</block_content>}</block></if>
				<else>else
				<block>{<block_content>
					<comment type="block" format="doxygen">/** Hurray! Copy value from external parameter and don't bother setting up execPlan. */</comment>
					<expr_stmt><expr><name><name>prmExec</name><operator>-&gt;</operator><name>execPlan</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>prmExec</name><operator>-&gt;</operator><name>isnull</name></name> <operator>=</operator> <name><name>prmExt</name><operator>-&gt;</operator><name>isnull</name></name></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>prmExec</name><operator>-&gt;</operator><name>value</name></name> <operator>=</operator> <name><name>prmExt</name><operator>-&gt;</operator><name>value</name></name></expr>;</expr_stmt>
				</block_content>}</block></else></if_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Walker to extract all the precomputer InitPlan params in a plan tree.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>ParamExtractorWalker</name><parameter_list>(<parameter><decl><type><name>Plan</name> <modifier>*</modifier></type><name>node</name></decl></parameter>,
				  <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ParamExtractorContext</name> <modifier>*</modifier></type><name>ctx</name> <init>= <expr><operator>(</operator><name>ParamExtractorContext</name> <operator>*</operator><operator>)</operator> <name>context</name></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Assuming InitPlan always runs on the master */</comment>
	<if_stmt><if>if <condition>(<expr><name>node</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>false</name></expr>;</return>	<comment type="block">/* don't visit subtree */</comment>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>SubPlan</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>SubPlan</name> <modifier>*</modifier></type><name>sub_plan</name> <init>= <expr><operator>(</operator><name>SubPlan</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>ExtractSubPlanParam</name><argument_list>(<argument><expr><name>sub_plan</name></expr></argument>, <argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>estate</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Continue walking */</comment>
	<return>return <expr><call><name>plan_tree_walker</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name><operator>*</operator><operator>)</operator><name>node</name></expr></argument>, <argument><expr><name>ParamExtractorWalker</name></expr></argument>, <argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Find and extract all the InitPlan setParams in a root node's subtree.
 */</comment>
<function><type><name>void</name></type>
<name>ExtractParamsFromInitPlans</name><parameter_list>(<parameter><decl><type><name>PlannedStmt</name> <modifier>*</modifier></type><name>plannedstmt</name></decl></parameter>, <parameter><decl><type><name>Plan</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>EState</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ParamExtractorContext</name></type> <name>ctx</name></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>ctx</name><operator>.</operator><name>base</name><operator>.</operator><name>node</name></name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>plannedstmt</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ctx</name><operator>.</operator><name>estate</name></name> <operator>=</operator> <name>estate</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>px_role</name> <operator>==</operator> <name>PX_ROLE_PX</name> <operator>&amp;&amp;</operator> <name>px_is_executing</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ParamExtractorWalker</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>



<comment type="block" format="doxygen">/**
 * Provide index of slice being executed on the primary writer gang
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>PrimaryWriterSliceIndex</name><parameter_list>(<parameter><decl><type><name>EState</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>estate</name><operator>-&gt;</operator><name>es_sliceTable</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>estate</name><operator>-&gt;</operator><name>es_sliceTable</name><operator>-&gt;</operator><name>numSlices</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ExecSlice</name>  <modifier>*</modifier></type><name>slice</name> <init>= <expr><operator>&amp;</operator><name><name>estate</name><operator>-&gt;</operator><name>es_sliceTable</name><operator>-&gt;</operator><name>slices</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>slice</name><operator>-&gt;</operator><name>gangType</name></name> <operator>==</operator> <name>GANGTYPE_PRIMARY_WRITER</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name><name>slice</name><operator>-&gt;</operator><name>sliceIndex</name></name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></for>

	<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
 * Provide root slice of locally executing slice.
 */</comment>
<function><type><name>int</name></type>
<name>RootSliceIndex</name><parameter_list>(<parameter><decl><type><name>EState</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>result</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>estate</name><operator>-&gt;</operator><name>es_sliceTable</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ExecSlice</name> <modifier>*</modifier></type><name>localSlice</name> <init>= <expr><operator>&amp;</operator><name><name>estate</name><operator>-&gt;</operator><name>es_sliceTable</name><operator>-&gt;</operator><name>slices</name><index>[<expr><call><name>LocallyExecutingSliceIndex</name><argument_list>(<argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr>]</index></name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>result</name> <operator>=</operator> <name><name>localSlice</name><operator>-&gt;</operator><name>rootIndex</name></name></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>result</name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>estate</name><operator>-&gt;</operator><name>es_sliceTable</name><operator>-&gt;</operator><name>numSlices</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>ExecAssignResultType</name><parameter_list>(<parameter><decl><type><name>PlanState</name> <modifier>*</modifier></type><name>planstate</name></decl></parameter>, <parameter><decl><type><name>TupleDesc</name></type> <name>tupDesc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name> <init>= <expr><name><name>planstate</name><operator>-&gt;</operator><name>ps_ResultTupleSlot</name></name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>ExecSetSlotDescriptor</name><argument_list>(<argument><expr><name>slot</name></expr></argument>, <argument><expr><name>tupDesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>ExecAssignResultTypeFromTL</name><parameter_list>(<parameter><decl><type><name>PlanState</name> <modifier>*</modifier></type><name>planstate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type>		<name>hasoid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleDesc</name></type>	<name>tupDesc</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>ExecContextForcesOids</name><argument_list>(<argument><expr><name>planstate</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>hasoid</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* context forces OID choice; hasoid is now set correctly */</comment>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* given free choice, don't leave space for OIDs in result tuples */</comment>
		<expr_stmt><expr><name>hasoid</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/*
	 * ExecTypeFromTL needs the parse-time representation of the tlist, not a
	 * list of ExprStates.  This is good because some plan nodes don't bother
	 * to set up planstate-&gt;targetlist ...
	 */</comment>
	<expr_stmt><expr><name>tupDesc</name> <operator>=</operator> <call><name>ExecTypeFromTL</name><argument_list>(<argument><expr><name><name>planstate</name><operator>-&gt;</operator><name>plan</name><operator>-&gt;</operator><name>targetlist</name></name></expr></argument>, <argument><expr><name>hasoid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ExecAssignResultType</name><argument_list>(<argument><expr><name>planstate</name></expr></argument>, <argument><expr><name>tupDesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/* -----------------------------------------------------------------------
 *						POLAR px
 *				PlanState Tree Walking Functions
 * -----------------------------------------------------------------------
 *
 * planstate_walk_node
 *	  Calls a 'walker' function for the given PlanState node; or returns
 *	  PxVisit_Walk if 'planstate' is NULL.
 *
 *	  If 'walker' returns PxVisit_Walk, then this function calls
 *	  planstate_walk_kids() to visit the node's children, and returns
 *	  the result.
 *
 *	  If 'walker' returns PxVisit_Skip, then this function immediately
 *	  returns PxVisit_Walk and does not visit the node's children.
 *
 *	  If 'walker' returns PxVisit_Stop or another value, then this function
 *	  immediately returns that value and does not visit the node's children.
 *
 * planstate_walk_array
 *	  Calls planstate_walk_node() for each non-NULL PlanState ptr in
 *	  the given array of pointers to PlanState objects.
 *
 *	  Quits if the result of planstate_walk_node() is PxVisit_Stop or another
 *	  value other than PxVisit_Walk, and returns that result without visiting
 *	  any more nodes.
 *
 *	  Returns PxVisit_Walk if 'planstates' is NULL, or if all of the
 *	  subtrees return PxVisit_Walk.
 *
 *	  Note that this function never returns PxVisit_Skip to its caller.
 *	  Only the caller's 'walker' function can return PxVisit_Skip.
 *
 * planstate_walk_list
 *	  Calls planstate_walk_node() for each PlanState node in the given List.
 *
 *	  Quits if the result of planstate_walk_node() is PxVisit_Stop or another
 *	  value other than PxVisit_Walk, and returns that result without visiting
 *	  any more nodes.
 *
 *	  Returns PxVisit_Walk if all of the subtrees return PxVisit_Walk, or
 *	  if the list is empty.
 *
 *	  Note that this function never returns PxVisit_Skip to its caller.
 *	  Only the caller's 'walker' function can return PxVisit_Skip.
 *
 * planstate_walk_kids
 *	  Calls planstate_walk_node() for each child of the given PlanState node.
 *
 *	  Quits if the result of planstate_walk_node() is PxVisit_Stop or another
 *	  value other than PxVisit_Walk, and returns that result without visiting
 *	  any more nodes.
 *
 *	  Returns PxVisit_Walk if the given planstate node ptr is NULL, or if
 *	  all of the children return PxVisit_Walk, or if there are no children.
 *
 *	  Note that this function never returns PxVisit_Skip to its caller.
 *	  Only the 'walker' can return PxVisit_Skip.
 *
 * NB: All PxVisitOpt values other than PxVisit_Walk or PxVisit_Skip are
 * treated as equivalent to PxVisit_Stop.  Thus the walker can break out
 * of a traversal and at the same time return a smidgen of information to the
 * caller, perhaps to indicate the reason for termination.  For convenience,
 * a couple of alternative stopping codes are predefined for walkers to use at
 * their discretion: PxVisit_Failure and PxVisit_Success.
 *
 * NB: We do not visit the left subtree of a NestLoopState node (NJ) whose
 * 'shared_outer' flag is set.  This occurs when the NJ is the left child of
 * an AdaptiveNestLoopState (AJ); the AJ's right child is a HashJoinState (HJ);
 * and both the NJ and HJ point to the same left subtree.  This way we avoid
 * visiting the common subtree twice when descending through the AJ node.
 * The caller's walker function can handle the NJ as a special case to
 * override this behavior if there is a need to always visit both subtrees.
 *
 * NB: Use PSW_* flags to skip walking certain parts of the planstate tree.
 * -----------------------------------------------------------------------
 */</comment>

<comment type="block" format="doxygen">/**
 * Version of walker that uses no flags.
 */</comment>
<function><type><name>PxVisitOpt</name></type>
<name>planstate_walk_node</name><parameter_list>(<parameter><decl><type><name>PlanState</name> <modifier>*</modifier></type><name>planstate</name></decl></parameter>,
				 <parameter><function_decl><type><name>PxVisitOpt</name></type> (<modifier>*</modifier><name>walker</name>) <parameter_list>(<parameter><decl><type><name>PlanState</name> <modifier>*</modifier></type><name>planstate</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list></function_decl></parameter>,
					<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>planstate_walk_node_extended</name><argument_list>(<argument><expr><name>planstate</name></expr></argument>, <argument><expr><name>walker</name></expr></argument>, <argument><expr><name>context</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
 * Workhorse walker that uses flags.
 */</comment>
<function><type><name>PxVisitOpt</name></type>
<name>planstate_walk_node_extended</name><parameter_list>(<parameter><decl><type><name>PlanState</name> <modifier>*</modifier></type><name>planstate</name></decl></parameter>,
				 <parameter><function_decl><type><name>PxVisitOpt</name></type> (<modifier>*</modifier><name>walker</name>) <parameter_list>(<parameter><decl><type><name>PlanState</name> <modifier>*</modifier></type><name>planstate</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list></function_decl></parameter>,
							 <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>context</name></decl></parameter>,
							 <parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PxVisitOpt</name></type> <name>whatnext</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>planstate</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>whatnext</name> <operator>=</operator> <name>PxVisit_Walk</name></expr>;</expr_stmt></block_content></block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name>whatnext</name> <operator>=</operator> <call><name>walker</name><argument_list>(<argument><expr><name>planstate</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>whatnext</name> <operator>==</operator> <name>PxVisit_Walk</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>whatnext</name> <operator>=</operator> <call><name>planstate_walk_kids</name><argument_list>(<argument><expr><name>planstate</name></expr></argument>, <argument><expr><name>walker</name></expr></argument>, <argument><expr><name>context</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><name>whatnext</name> <operator>==</operator> <name>PxVisit_Skip</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>whatnext</name> <operator>=</operator> <name>PxVisit_Walk</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></else></if_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>whatnext</name> <operator>!=</operator> <name>PxVisit_Skip</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>whatnext</name></expr>;</return>
</block_content>}</block></function>	<comment type="block">/* planstate_walk_node */</comment>

<function><type><name>PxVisitOpt</name></type>
<name>planstate_walk_array</name><parameter_list>(<parameter><decl><type><name>PlanState</name> <modifier>*</modifier><modifier>*</modifier></type><name>planstates</name></decl></parameter>,
					 <parameter><decl><type><name>int</name></type> <name>nplanstate</name></decl></parameter>,
				 <parameter><function_decl><type><name>PxVisitOpt</name></type> (<modifier>*</modifier><name>walker</name>) <parameter_list>(<parameter><decl><type><name>PlanState</name> <modifier>*</modifier></type><name>planstate</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list></function_decl></parameter>,
					 <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>context</name></decl></parameter>,
					 <parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PxVisitOpt</name></type> <name>whatnext</name> <init>= <expr><name>PxVisit_Walk</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>planstates</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>PxVisit_Walk</name></expr>;</return></block_content></block></if></if_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nplanstate</name> <operator>&amp;&amp;</operator> <name>whatnext</name> <operator>==</operator> <name>PxVisit_Walk</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
		<expr_stmt><expr><name>whatnext</name> <operator>=</operator> <call><name>planstate_walk_node_extended</name><argument_list>(<argument><expr><name><name>planstates</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>walker</name></expr></argument>, <argument><expr><name>context</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>

	<return>return <expr><name>whatnext</name></expr>;</return>
</block_content>}</block></function>	<comment type="block">/* planstate_walk_array */</comment>

<function><type><name>PxVisitOpt</name></type>
<name>planstate_walk_kids</name><parameter_list>(<parameter><decl><type><name>PlanState</name> <modifier>*</modifier></type><name>planstate</name></decl></parameter>,
				 <parameter><function_decl><type><name>PxVisitOpt</name></type> (<modifier>*</modifier><name>walker</name>) <parameter_list>(<parameter><decl><type><name>PlanState</name> <modifier>*</modifier></type><name>planstate</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list></function_decl></parameter>,
					<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>context</name></decl></parameter>,
					<parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PxVisitOpt</name></type> <name>v</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>planstate</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>PxVisit_Walk</name></expr>;</return></block_content></block></if></if_stmt>

	<switch>switch <condition>(<expr><call><name>nodeTag</name><argument_list>(<argument><expr><name>planstate</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>T_NestLoopState</name></expr>:</case>
			<block>{<block_content>
				<expr_stmt><expr><name>v</name> <operator>=</operator> <call><name>planstate_walk_node_extended</name><argument_list>(<argument><expr><name><name>planstate</name><operator>-&gt;</operator><name>lefttree</name></name></expr></argument>, <argument><expr><name>walker</name></expr></argument>, <argument><expr><name>context</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/* Right subtree */</comment>
				<if_stmt><if>if <condition>(<expr><name>v</name> <operator>==</operator> <name>PxVisit_Walk</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>v</name> <operator>=</operator> <call><name>planstate_walk_node_extended</name><argument_list>(<argument><expr><name><name>planstate</name><operator>-&gt;</operator><name>righttree</name></name></expr></argument>, <argument><expr><name>walker</name></expr></argument>, <argument><expr><name>context</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<break>break;</break>
			</block_content>}</block>

		<case>case <expr><name>T_AppendState</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>AppendState</name> <modifier>*</modifier></type><name>as</name> <init>= <expr><operator>(</operator><name>AppendState</name> <operator>*</operator><operator>)</operator> <name>planstate</name></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><name>v</name> <operator>=</operator> <call><name>planstate_walk_array</name><argument_list>(<argument><expr><name><name>as</name><operator>-&gt;</operator><name>appendplans</name></name></expr></argument>, <argument><expr><name><name>as</name><operator>-&gt;</operator><name>as_nplans</name></name></expr></argument>, <argument><expr><name>walker</name></expr></argument>, <argument><expr><name>context</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name><name>planstate</name><operator>-&gt;</operator><name>lefttree</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>planstate</name><operator>-&gt;</operator><name>righttree</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block>

		<case>case <expr><name>T_MergeAppendState</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>MergeAppendState</name> <modifier>*</modifier></type><name>ms</name> <init>= <expr><operator>(</operator><name>MergeAppendState</name> <operator>*</operator><operator>)</operator> <name>planstate</name></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><name>v</name> <operator>=</operator> <call><name>planstate_walk_array</name><argument_list>(<argument><expr><name><name>ms</name><operator>-&gt;</operator><name>mergeplans</name></name></expr></argument>, <argument><expr><name><name>ms</name><operator>-&gt;</operator><name>ms_nplans</name></name></expr></argument>, <argument><expr><name>walker</name></expr></argument>, <argument><expr><name>context</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name><name>planstate</name><operator>-&gt;</operator><name>lefttree</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>planstate</name><operator>-&gt;</operator><name>righttree</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block>

		<case>case <expr><name>T_ModifyTableState</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>ModifyTableState</name> <modifier>*</modifier></type><name>mts</name> <init>= <expr><operator>(</operator><name>ModifyTableState</name> <operator>*</operator><operator>)</operator> <name>planstate</name></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><name>v</name> <operator>=</operator> <call><name>planstate_walk_array</name><argument_list>(<argument><expr><name><name>mts</name><operator>-&gt;</operator><name>mt_plans</name></name></expr></argument>, <argument><expr><name><name>mts</name><operator>-&gt;</operator><name>mt_nplans</name></name></expr></argument>, <argument><expr><name>walker</name></expr></argument>, <argument><expr><name>context</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name><name>planstate</name><operator>-&gt;</operator><name>lefttree</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>planstate</name><operator>-&gt;</operator><name>righttree</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block>

		<comment type="block">/* POLAR px */</comment>
		<case>case <expr><name>T_SequenceState</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>SequenceState</name> <modifier>*</modifier></type><name>ss</name> <init>= <expr><operator>(</operator><name>SequenceState</name> <operator>*</operator><operator>)</operator> <name>planstate</name></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><name>v</name> <operator>=</operator> <call><name>planstate_walk_array</name><argument_list>(<argument><expr><name><name>ss</name><operator>-&gt;</operator><name>subplans</name></name></expr></argument>, <argument><expr><name><name>ss</name><operator>-&gt;</operator><name>numSubplans</name></name></expr></argument>, <argument><expr><name>walker</name></expr></argument>, <argument><expr><name>context</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name><name>planstate</name><operator>-&gt;</operator><name>lefttree</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>planstate</name><operator>-&gt;</operator><name>righttree</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block>

		<case>case <expr><name>T_BitmapAndState</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>BitmapAndState</name> <modifier>*</modifier></type><name>bas</name> <init>= <expr><operator>(</operator><name>BitmapAndState</name> <operator>*</operator><operator>)</operator> <name>planstate</name></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><name>v</name> <operator>=</operator> <call><name>planstate_walk_array</name><argument_list>(<argument><expr><name><name>bas</name><operator>-&gt;</operator><name>bitmapplans</name></name></expr></argument>, <argument><expr><name><name>bas</name><operator>-&gt;</operator><name>nplans</name></name></expr></argument>, <argument><expr><name>walker</name></expr></argument>, <argument><expr><name>context</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name><name>planstate</name><operator>-&gt;</operator><name>lefttree</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>planstate</name><operator>-&gt;</operator><name>righttree</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block>
		<case>case <expr><name>T_BitmapOrState</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>BitmapOrState</name> <modifier>*</modifier></type><name>bos</name> <init>= <expr><operator>(</operator><name>BitmapOrState</name> <operator>*</operator><operator>)</operator> <name>planstate</name></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><name>v</name> <operator>=</operator> <call><name>planstate_walk_array</name><argument_list>(<argument><expr><name><name>bos</name><operator>-&gt;</operator><name>bitmapplans</name></name></expr></argument>, <argument><expr><name><name>bos</name><operator>-&gt;</operator><name>nplans</name></name></expr></argument>, <argument><expr><name>walker</name></expr></argument>, <argument><expr><name>context</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name><name>planstate</name><operator>-&gt;</operator><name>lefttree</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>planstate</name><operator>-&gt;</operator><name>righttree</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block>

		<case>case <expr><name>T_SubqueryScanState</name></expr>:</case>
			<expr_stmt><expr><name>v</name> <operator>=</operator> <call><name>planstate_walk_node_extended</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>SubqueryScanState</name> <operator>*</operator><operator>)</operator> <name>planstate</name><operator>)</operator><operator>-&gt;</operator><name>subplan</name></expr></argument>, <argument><expr><name>walker</name></expr></argument>, <argument><expr><name>context</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name><name>planstate</name><operator>-&gt;</operator><name>lefttree</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>planstate</name><operator>-&gt;</operator><name>righttree</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<default>default:</default>
			<comment type="block">/* Left subtree */</comment>
			<expr_stmt><expr><name>v</name> <operator>=</operator> <call><name>planstate_walk_node_extended</name><argument_list>(<argument><expr><name><name>planstate</name><operator>-&gt;</operator><name>lefttree</name></name></expr></argument>, <argument><expr><name>walker</name></expr></argument>, <argument><expr><name>context</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* Right subtree */</comment>
			<if_stmt><if>if <condition>(<expr><name>v</name> <operator>==</operator> <name>PxVisit_Walk</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>v</name> <operator>=</operator> <call><name>planstate_walk_node_extended</name><argument_list>(<argument><expr><name><name>planstate</name><operator>-&gt;</operator><name>righttree</name></name></expr></argument>, <argument><expr><name>walker</name></expr></argument>, <argument><expr><name>context</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<break>break;</break>
	</block_content>}</block></switch>

	<comment type="block">/* Init plan subtree */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>PSW_IGNORE_INITPLAN</name><operator>)</operator>
		<operator>&amp;&amp;</operator> <operator>(</operator><name>v</name> <operator>==</operator> <name>PxVisit_Walk</name><operator>)</operator></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>PxVisitOpt</name></type> <name>v1</name> <init>= <expr><name>v</name></expr></init></decl>;</decl_stmt>

		<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>planstate-&gt;initPlan</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>SubPlanState</name> <modifier>*</modifier></type><name>sps</name> <init>= <expr><operator>(</operator><name>SubPlanState</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>PlanState</name>  <modifier>*</modifier></type><name>ips</name> <init>= <expr><name><name>sps</name><operator>-&gt;</operator><name>planstate</name></name></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>ips</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>v1</name> <operator>==</operator> <name>PxVisit_Walk</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>v1</name> <operator>=</operator> <call><name>planstate_walk_node_extended</name><argument_list>(<argument><expr><name>ips</name></expr></argument>, <argument><expr><name>walker</name></expr></argument>, <argument><expr><name>context</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Sub plan subtree */</comment>
	<if_stmt><if>if <condition>(<expr><name>v</name> <operator>==</operator> <name>PxVisit_Walk</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>PxVisitOpt</name></type> <name>v1</name> <init>= <expr><name>v</name></expr></init></decl>;</decl_stmt>

		<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>planstate-&gt;subPlan</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>SubPlanState</name> <modifier>*</modifier></type><name>sps</name> <init>= <expr><operator>(</operator><name>SubPlanState</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>PlanState</name>  <modifier>*</modifier></type><name>ips</name> <init>= <expr><name><name>sps</name><operator>-&gt;</operator><name>planstate</name></name></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>ips</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"subplan has no planstate"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><name>v1</name> <operator>==</operator> <name>PxVisit_Walk</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>v1</name> <operator>=</operator> <call><name>planstate_walk_node_extended</name><argument_list>(<argument><expr><name>ips</name></expr></argument>, <argument><expr><name>walker</name></expr></argument>, <argument><expr><name>context</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block>

	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>v</name></expr>;</return>
</block_content>}</block></function>	<comment type="block">/* planstate_walk_kids */</comment>

<comment type="block">/* ---------------------- POLAR px -----------------------*/</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>querytree_safe_for_px_walker</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>expr</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>context</name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>expr</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block" format="doxygen">/**
		 * Do not end recursion just because we have reached one leaf node.
		 */</comment>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<switch>switch<condition>(<expr><call><name>nodeTag</name><argument_list>(<argument><expr><name>expr</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>T_Query</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>Query</name> <modifier>*</modifier></type><name>q</name> <init>= <expr><operator>(</operator><name>Query</name> <operator>*</operator><operator>)</operator> <name>expr</name></expr></init></decl>;</decl_stmt>

				<comment type="block">/* POLAR px: allow_segment_DML should be guc param */</comment>
				<decl_stmt><decl><type><name>bool</name></type> <name>allow_segment_DML</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type> <name>f</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><operator>!</operator><name>allow_segment_DML</name> <operator>&amp;&amp;</operator>
					<operator>(</operator><name><name>q</name><operator>-&gt;</operator><name>commandType</name></name> <operator>!=</operator> <name>CMD_SELECT</name>
					 <operator>||</operator> <operator>(</operator><name><name>q</name><operator>-&gt;</operator><name>utilityStmt</name></name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator>
					     <call><name>IsA</name><argument_list>(<argument><expr><name><name>q</name><operator>-&gt;</operator><name>utilityStmt</name></name></expr></argument>, <argument><expr><name>CreateTableAsStmt</name></expr></argument>)</argument_list></call><operator>)</operator>
					 <operator>||</operator> <name><name>q</name><operator>-&gt;</operator><name>resultRelation</name></name> <operator>&gt;</operator> <literal type="number">0</literal><operator>)</operator></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"function cannot execute on a PX slice because it issues a non-SELECT statement"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>

				<macro><name>foreach</name><argument_list>(<argument>f</argument>,<argument>q-&gt;rtable</argument>)</argument_list></macro>
				<block>{<block_content>
					<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name> <init>= <expr><operator>(</operator><name>RangeTblEntry</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>f</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

					<if_stmt><if>if <condition>(<expr><name><name>rte</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>==</operator> <name>RTE_RELATION</name></expr>)</condition>
					<block>{<block_content>
						<decl_stmt><decl><type><name>Oid</name></type> <name>namespaceId</name></decl>;</decl_stmt>
						<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>relid</name></name> <operator>!=</operator> <name>InvalidOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

						<expr_stmt><expr><name>namespaceId</name> <operator>=</operator> <call><name>get_rel_namespace</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

						<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>namespaceId</name> <operator>!=</operator> <name>InvalidOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

						<if_stmt><if>if <condition>(<expr><operator>!</operator><name>px_enable_spi_read_all_namespaces</name> <operator>&amp;&amp;</operator>
						 	<operator>(</operator><operator>!</operator><operator>(</operator><call><name>IsSystemNamespace</name><argument_list>(<argument><expr><name>namespaceId</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>IsToastNamespace</name><argument_list>(<argument><expr><name>namespaceId</name></expr></argument>)</argument_list></call><operator>)</operator><operator>)</operator></expr>
						 )</condition>
						<block>{<block_content>
							<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
									<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
									 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"function cannot execute on a PX slice because it accesses relation \"%s.%s\""</literal></expr></argument>,
											<argument><expr><call><name>quote_identifier</name><argument_list>(<argument><expr><call><name>get_namespace_name</name><argument_list>(<argument><expr><name>namespaceId</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
											<argument><expr><call><name>quote_identifier</name><argument_list>(<argument><expr><call><name>get_rel_name</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						</block_content>}</block></if></if_stmt>
					</block_content>}</block></if></if_stmt>
				</block_content>}</block>
				<expr_stmt><expr><call><name>query_tree_walker</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><name>querytree_safe_for_px_walker</name></expr></argument>, <argument><expr><name>context</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block>
		<default>default:</default>
			<break>break;</break>
	</block_content>}</block></switch>

	<return>return <expr><call><name>expression_tree_walker</name><argument_list>(<argument><expr><name>expr</name></expr></argument>, <argument><expr><name>querytree_safe_for_px_walker</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
 * POLAR px
 * This function determines if the query tree is safe to be planned and
 * executed on a PX. The checks it performs are:
 * 1. The query cannot access any non-catalog relation except it's a replicated table.
 * 2. The query must be select only.
 * In case of a problem, the method spits out an error.
 */</comment>
<function><type><name>void</name></type>
<name>querytree_safe_for_px</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>querytree_safe_for_px_walker</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * POLAR px
 * polar_fake_outer_params
 *   helper function to fake the nestloop's nestParams
 *   so that prefetch inner or prefetch joinqual will
 *   not encounter NULL pointer reference issue. It is
 *   only invoked in ExecNestLoop and ExecPrefetchJoinQual
 *   when the join is a nestloop join.
 */</comment>
<function><type><name>void</name></type>
<name>polar_fake_outer_params</name><parameter_list>(<parameter><decl><type><name>JoinState</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ExprContext</name>    <modifier>*</modifier></type><name>econtext</name> <init>= <expr><name><name>node</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>ps_ExprContext</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PlanState</name>      <modifier>*</modifier></type><name>inner</name> <init>= <expr><call><name>innerPlanState</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>outerTupleSlot</name> <init>= <expr><name><name>econtext</name><operator>-&gt;</operator><name>ecxt_outertuple</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>NestLoop</name>       <modifier>*</modifier></type><name>nl</name> <init>= <expr><operator>(</operator><name>NestLoop</name> <operator>*</operator><operator>)</operator> <operator>(</operator><name><name>node</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>plan</name></name><operator>)</operator></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>       <modifier>*</modifier></type><name>lc</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* only nestloop contains nestParams */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>IsA</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>plan</name></name></expr></argument>, <argument><expr><name>NestLoop</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* econtext-&gt;ecxt_outertuple must have been set fakely. */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>outerTupleSlot</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/*
	 * fetch the values of any outer Vars that must be passed to the
	 * inner scan, and store them in the appropriate PARAM_EXEC slots.
	 */</comment>
	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>nl-&gt;nestParams</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>NestLoopParam</name> <modifier>*</modifier></type><name>nlp</name> <init>= <expr><operator>(</operator><name>NestLoopParam</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>paramno</name> <init>= <expr><name><name>nlp</name><operator>-&gt;</operator><name>paramno</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ParamExecData</name> <modifier>*</modifier></type><name>prm</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>prm</name> <operator>=</operator> <operator>&amp;</operator><operator>(</operator><name><name>econtext</name><operator>-&gt;</operator><name>ecxt_param_exec_vals</name><index>[<expr><name>paramno</name></expr>]</index></name><operator>)</operator></expr>;</expr_stmt>
		<comment type="block">/* Param value should be an OUTER_VAR var */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>IsA</name><argument_list>(<argument><expr><name><name>nlp</name><operator>-&gt;</operator><name>paramval</name></name></expr></argument>, <argument><expr><name>Var</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>nlp</name><operator>-&gt;</operator><name>paramval</name><operator>-&gt;</operator><name>varno</name></name> <operator>==</operator> <name>OUTER_VAR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>nlp</name><operator>-&gt;</operator><name>paramval</name><operator>-&gt;</operator><name>varattno</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>prm</name><operator>-&gt;</operator><name>value</name></name> <operator>=</operator> <call><name>slot_getattr</name><argument_list>(<argument><expr><name>outerTupleSlot</name></expr></argument>,
								  <argument><expr><name><name>nlp</name><operator>-&gt;</operator><name>paramval</name><operator>-&gt;</operator><name>varattno</name></name></expr></argument>,
								  <argument><expr><operator>&amp;</operator><operator>(</operator><name><name>prm</name><operator>-&gt;</operator><name>isnull</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* Flag parameter value as changed */</comment>
		<expr_stmt><expr><name><name>inner</name><operator>-&gt;</operator><name>chgParam</name></name> <operator>=</operator> <call><name>bms_add_member</name><argument_list>(<argument><expr><name><name>inner</name><operator>-&gt;</operator><name>chgParam</name></name></expr></argument>,
										 <argument><expr><name>paramno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
</block_content>}</block></function>
</unit>
