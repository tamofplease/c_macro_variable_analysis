<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/PolarDB-for-PostgreSQL/src/backend/polar_flashback/polar_flashback_log_reader.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * polar_flashback_log_reader.c
 *
 *
 * Portions Copyright (c) 1996-2018, PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, Regents of the University of California
 * Portions Copyright (c) 2021, Alibaba Group Holding limited
 *
 * IDENTIFICATION
 *    src/backend/polar_flashback/polar_flashback_log_reader.c
 *
 *-------------------------------------------------------------------------
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/xlog.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pgstat.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"polar_flashback/polar_flashback_log_file.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"polar_flashback/polar_flashback_log_mem.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"polar_flashback/polar_flashback_log_reader.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/memutils.h"</cpp:file></cpp:include>

<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type>  <name>read_file</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>uint64</name></type> <name>read_segno</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>uint32</name></type> <name>read_off</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>uint32</name></type> <name>read_len</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<comment type="block">/* size of the buffer allocated for error message. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MAX_ERRORMSG_LEN</name></cpp:macro> <cpp:value>1000</cpp:value></cpp:define>
<comment type="block">/* load the flashback log switch ptrs */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>load_switch_ptrs</name><parameter_list>(<parameter><type><name>dir</name></type></parameter>, <parameter><type><name>ptrs</name></type></parameter>)</parameter_list></cpp:macro> \
	<cpp:value>(ptrs != NIL? ptrs : polar_read_flog_history_file(dir))</cpp:value></cpp:define>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>report_invalid_flog_record</name><parameter_list>(<parameter><decl><type><name>flog_reader_state</name> <modifier>*</modifier></type><name>state</name></decl></parameter>,
									   <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>fmt</name></decl></parameter>, <parameter><decl><type><modifier>...</modifier></type></decl></parameter>)</parameter_list> pg_attribute_printf<parameter_list>(</parameter_list>2<operator>,</operator> 3</function_decl>)<empty_stmt>;</empty_stmt>

<comment type="block">/*
 * Allocate readRecordBuf to fit a record of at least the given length.
 * Returns true if successful, false if out of memory.
 *
 * readRecordBufSize is set to the new buffer size.
 *
 * To avoid useless small increases, round its size to a multiple of
 * POLAR_FLASHBACK_LOG_BLCKSZ, and make sure it's at least 3*Max(BLCKSZ, POLAR_FLASHBACK_LOG_BLCKSZ) to start
 * with.  (That is enough for all "normal" records, but very large commit or
 * abort records might need more space.)
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>allocate_flog_read_buf</name><parameter_list>(<parameter><decl><type><name>flog_reader_state</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>uint32</name></type> <name>rec_len</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>uint32</name></type>      <name>new_size</name> <init>= <expr><name>rec_len</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>new_size</name> <operator>+=</operator> <name>POLAR_FLOG_BLCKSZ</name> <operator>-</operator> <operator>(</operator><name>new_size</name> <operator>%</operator> <name>POLAR_FLOG_BLCKSZ</name><operator>)</operator></expr>;</expr_stmt>
	<expr_stmt><expr><name>new_size</name> <operator>=</operator> <call><name>Max</name><argument_list>(<argument><expr><name>new_size</name></expr></argument>, <argument><expr><literal type="number">3</literal> <operator>*</operator> <call><name>Max</name><argument_list>(<argument><expr><name>BLCKSZ</name></expr></argument>, <argument><expr><name>POLAR_FLOG_BLCKSZ</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>read_record_buf</name></name></expr>)</condition><block type="pseudo"><block_content>
		<comment type="block">/*no cover line*/</comment>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>read_record_buf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>read_record_buf</name></name> <operator>=</operator>
		<operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>polar_palloc_extended_in_crit</name><argument_list>(<argument><expr><name>new_size</name></expr></argument>, <argument><expr><name>MCXT_ALLOC_NO_OOM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>read_record_buf</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*no cover begin*/</comment>
		<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>read_record_buf_size</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<return>return <expr><name>false</name></expr>;</return>
		<comment type="block">/*no cover end*/</comment>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>read_record_buf_size</name></name> <operator>=</operator> <name>new_size</name></expr>;</expr_stmt>
	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Invalidate the flashback_log_reader's read state to force a re-read.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>flog_inval_read_state</name><parameter_list>(<parameter><decl><type><name>flog_reader_state</name> <modifier>*</modifier></type><name>state</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>read_seg_no</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>read_off</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>read_len</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Construct a string in state-&gt;errormsg_buf explaining what's wrong with
 * the current record being read.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>report_invalid_flog_record</name><parameter_list>(<parameter><decl><type><name>flog_reader_state</name> <modifier>*</modifier></type><name>state</name></decl></parameter>,
						   <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>fmt</name></decl></parameter>, <parameter><decl><type><modifier>...</modifier></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>va_list</name></type>     <name>args</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>fmt</name> <operator>=</operator> <call><name>_</name><argument_list>(<argument><expr><name>fmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>va_start</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><name>fmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>vsnprintf</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>errormsg_buf</name></name></expr></argument>, <argument><expr><name>MAX_ERRORMSG_LEN</name></expr></argument>, <argument><expr><name>fmt</name></expr></argument>, <argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>va_end</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* POLAR: Is the flashback log point a switch point whose prev_lsn is wrong. */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>is_flog_ptr_switch</name><parameter_list>(<parameter><decl><type><name>polar_flog_rec_ptr</name></type> <name>ptr</name></decl></parameter>, <parameter><decl><type><name>polar_flog_rec_ptr</name></type> <name>prev_ptr</name></decl></parameter>, <parameter><decl><type><name>flog_reader_state</name> <modifier>*</modifier></type><name>reader</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>cell</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>ptr</name> <operator>&gt;=</operator> <name>FLOG_LONG_PHD_SIZE</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>ptr</name> <operator>-=</operator> <name>FLOG_LONG_PHD_SIZE</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Check first */</comment>
	<if_stmt><if>if <condition>(<expr><name>ptr</name> <operator>%</operator> <name>POLAR_FLOG_SEG_SIZE</name> <operator>!=</operator> <literal type="number">0</literal> <operator>||</operator>
			<operator>!</operator><call><name>FLOG_REC_PTR_IS_INVAILD</name><argument_list>(<argument><expr><name>prev_ptr</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* Check strictly */</comment>
	<expr_stmt><expr><name><name>reader</name><operator>-&gt;</operator><name>switch_ptrs</name></name> <operator>=</operator> <call><name>load_switch_ptrs</name><argument_list>(<argument><expr><name><name>reader</name><operator>-&gt;</operator><name>flog_buf_ctl</name><operator>-&gt;</operator><name>dir</name></name></expr></argument>, <argument><expr><name><name>reader</name><operator>-&gt;</operator><name>switch_ptrs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<macro><name>foreach</name> <argument_list>(<argument>cell</argument>, <argument>reader-&gt;switch_ptrs</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>flog_history_entry</name> <modifier>*</modifier></type><name>tle</name> <init>= <expr><operator>(</operator><name>flog_history_entry</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>cell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>tle</name><operator>-&gt;</operator><name>next_ptr</name></name> <operator>==</operator> <name>ptr</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block>

	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Validate an flashback log record header.
 *
 * This is just a convenience subroutine to avoid duplicated code in
 * polar_read_flashback_log_record.  It's not intended for use from anywhere else.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>valid_flog_rec_header</name><parameter_list>(<parameter><decl><type><name>flog_reader_state</name> <modifier>*</modifier></type><name>state</name></decl></parameter>,
					  <parameter><decl><type><name>polar_flog_rec_ptr</name></type> <name>ptr</name></decl></parameter>, <parameter><decl><type><name>polar_flog_rec_ptr</name></type> <name>prev_ptr</name></decl></parameter>,
					  <parameter><decl><type><name>flog_record</name> <modifier>*</modifier></type><name>record</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>rand_access</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name><name>record</name><operator>-&gt;</operator><name>xl_tot_len</name></name> <operator>&lt;</operator> <name>FLOG_REC_HEADER_SIZE</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*no cover begin*/</comment>
		<expr_stmt><expr><call><name>report_invalid_flog_record</name><argument_list>(<argument><expr><name>state</name></expr></argument>,
								   <argument><expr><literal type="string">"invalid flashback log record length at %X/%X: wanted larger than or equal to %u, "</literal>
								   <literal type="string">"got %u"</literal></expr></argument>, <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator><operator>(</operator><name>ptr</name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr></argument>, <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <name>ptr</name></expr></argument>,
								   <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <name>FLOG_REC_HEADER_SIZE</name></expr></argument>, <argument><expr><name><name>record</name><operator>-&gt;</operator><name>xl_tot_len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>false</name></expr>;</return>
		<comment type="block">/*no cover end*/</comment>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>rand_access</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * We can't exactly verify the prev-link, but surely it should be less
		 * than the record's own address.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>record</name><operator>-&gt;</operator><name>xl_prev</name></name> <operator>&gt;=</operator> <name>ptr</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*no cover begin*/</comment>
			<expr_stmt><expr><call><name>report_invalid_flog_record</name><argument_list>(<argument><expr><name>state</name></expr></argument>,
									   <argument><expr><literal type="string">"flashback log record with incorrect prev-link %X/%X at %X/%X"</literal></expr></argument>,
									   <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator><operator>(</operator><name><name>record</name><operator>-&gt;</operator><name>xl_prev</name></name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr></argument>,
									   <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <name><name>record</name><operator>-&gt;</operator><name>xl_prev</name></name></expr></argument>,
									   <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator><operator>(</operator><name>ptr</name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr></argument>, <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <name>ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>false</name></expr>;</return>
			<comment type="block">/*no cover end*/</comment>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/*
		 * Record's prev-link should exactly match our previous location. This
		 * check guards against torn flashback log pages where a stale but valid-looking
		 * flashback log record starts on a sector boundary.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>record</name><operator>-&gt;</operator><name>xl_prev</name></name> <operator>!=</operator> <name>prev_ptr</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><call><name>is_flog_ptr_switch</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr><name><name>record</name><operator>-&gt;</operator><name>xl_prev</name></name></expr></argument>, <argument><expr><name>state</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

			<comment type="block">/*no cover begin*/</comment>
			<expr_stmt><expr><call><name>report_invalid_flog_record</name><argument_list>(<argument><expr><name>state</name></expr></argument>,
									   <argument><expr><literal type="string">"flashback log record with incorrect prev-link %X/%X at %X/%X"</literal></expr></argument>,
									   <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator><operator>(</operator><name><name>record</name><operator>-&gt;</operator><name>xl_prev</name></name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr></argument>,
									   <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <name><name>record</name><operator>-&gt;</operator><name>xl_prev</name></name></expr></argument>,
									   <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator><operator>(</operator><name>ptr</name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr></argument>, <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <name>ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>false</name></expr>;</return>
			<comment type="block">/*no cover end*/</comment>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></else></if_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Validate a flsahback log page header.
 *
 * Check if 'phdr' is valid as the header of the flashback log page at position
 * 'recptr'.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>flog_page_header_validate</name><parameter_list>(<parameter><decl><type><name>flog_reader_state</name> <modifier>*</modifier></type><name>state</name></decl></parameter>,
						  <parameter><decl><type><name>polar_flog_rec_ptr</name></type> <name>recptr</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>phdr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>polar_flog_rec_ptr</name></type>  <name>recaddr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint64</name></type>  <name>segno</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name></type>       <name>offset</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>flog_page_header</name></type> <name>hdr</name> <init>= <expr><operator>(</operator><name>flog_page_header</name><operator>)</operator> <name>phdr</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>(</operator><name>recptr</name> <operator>%</operator> <name>POLAR_FLOG_BLCKSZ</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>segno</name> <operator>=</operator> <call><name>flog_ptr_to_seg</name><argument_list>(<argument><expr><name>recptr</name></expr></argument>, <argument><expr><name><name>state</name><operator>-&gt;</operator><name>segment_size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>offset</name> <operator>=</operator> <call><name>FLOG_SEGMENT_OFFSET</name><argument_list>(<argument><expr><name>recptr</name></expr></argument>, <argument><expr><name><name>state</name><operator>-&gt;</operator><name>segment_size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>flog_seg_offset_to_ptr</name><argument_list>(<argument><expr><name>segno</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>, <argument><expr><name><name>state</name><operator>-&gt;</operator><name>segment_size</name></name></expr></argument>, <argument><expr><name>recaddr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>hdr</name><operator>-&gt;</operator><name>xlp_magic</name></name> <operator>!=</operator> <name>FLOG_PAGE_MAGIC</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*no cover begin*/</comment>
		<decl_stmt><decl><type><name>char</name></type>        <name><name>fname</name><index>[<expr><name>FLOG_MAX_FNAME_LEN</name></expr>]</index></name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>get_flog_fname</name><argument_list>(<argument><expr><name>fname</name></expr></argument>, <argument><expr><name>segno</name></expr></argument>, <argument><expr><name><name>state</name><operator>-&gt;</operator><name>segment_size</name></name></expr></argument>, <argument><expr><name>FLOG_DEFAULT_TIMELINE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>report_invalid_flog_record</name><argument_list>(<argument><expr><name>state</name></expr></argument>,
								   <argument><expr><literal type="string">"invalid magic number %04X in flashback log segment %s, offset %u"</literal></expr></argument>,
								   <argument><expr><name><name>hdr</name><operator>-&gt;</operator><name>xlp_magic</name></name></expr></argument>,
								   <argument><expr><name>fname</name></expr></argument>,
								   <argument><expr><name>offset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>false</name></expr>;</return>
		<comment type="block">/*no cover end*/</comment>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>hdr</name><operator>-&gt;</operator><name>xlp_version</name></name> <operator>&lt;</operator> <name>FLOG_PAGE_VERSION</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*no cover begin*/</comment>
		<decl_stmt><decl><type><name>char</name></type>        <name><name>fname</name><index>[<expr><name>FLOG_MAX_FNAME_LEN</name></expr>]</index></name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>get_flog_fname</name><argument_list>(<argument><expr><name>fname</name></expr></argument>, <argument><expr><name>segno</name></expr></argument>, <argument><expr><name><name>state</name><operator>-&gt;</operator><name>segment_size</name></name></expr></argument>, <argument><expr><name>FLOG_DEFAULT_TIMELINE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>report_invalid_flog_record</name><argument_list>(<argument><expr><name>state</name></expr></argument>,
								   <argument><expr><literal type="string">"invalid version %04X in flashback log segment %s, offset %u"</literal></expr></argument>,
								   <argument><expr><name><name>hdr</name><operator>-&gt;</operator><name>xlp_version</name></name></expr></argument>,
								   <argument><expr><name>fname</name></expr></argument>,
								   <argument><expr><name>offset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>false</name></expr>;</return>
		<comment type="block">/*no cover end*/</comment>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>hdr</name><operator>-&gt;</operator><name>xlp_info</name></name> <operator>&amp;</operator> <operator>~</operator><name>FLOG_ALL_FLAGS</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*no cover begin*/</comment>
		<decl_stmt><decl><type><name>char</name></type>        <name><name>fname</name><index>[<expr><name>FLOG_MAX_FNAME_LEN</name></expr>]</index></name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>get_flog_fname</name><argument_list>(<argument><expr><name>fname</name></expr></argument>, <argument><expr><name>segno</name></expr></argument>, <argument><expr><name><name>state</name><operator>-&gt;</operator><name>segment_size</name></name></expr></argument>, <argument><expr><name>FLOG_DEFAULT_TIMELINE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>report_invalid_flog_record</name><argument_list>(<argument><expr><name>state</name></expr></argument>,
								   <argument><expr><literal type="string">"invalid info bits %04X in flashback log segment %s, offset %u"</literal></expr></argument>,
								   <argument><expr><name><name>hdr</name><operator>-&gt;</operator><name>xlp_info</name></name></expr></argument>,
								   <argument><expr><name>fname</name></expr></argument>,
								   <argument><expr><name>offset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>false</name></expr>;</return>
		<comment type="block">/*no cover end*/</comment>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>hdr</name><operator>-&gt;</operator><name>xlp_info</name></name> <operator>&amp;</operator> <name>FLOG_LONG_PAGE_HEADER</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>polar_long_page_header</name></type> <name>longhdr</name> <init>= <expr><operator>(</operator><name>polar_long_page_header</name><operator>)</operator> <name>hdr</name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>system_identifier</name></name> <operator>&amp;&amp;</operator>
				<name><name>longhdr</name><operator>-&gt;</operator><name>xlp_sysid</name></name> <operator>!=</operator> <name><name>state</name><operator>-&gt;</operator><name>system_identifier</name></name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*no cover begin*/</comment>
			<decl_stmt><decl><type><name>char</name></type>        <name><name>fhdrident_str</name><index>[<expr><literal type="number">32</literal></expr>]</index></name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>char</name></type>        <name><name>sysident_str</name><index>[<expr><literal type="number">32</literal></expr>]</index></name></decl>;</decl_stmt>

			<comment type="block">/*
			 * Format sysids separately to keep platform-dependent format code
			 * out of the translatable message string.
			 */</comment>
			<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>fhdrident_str</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>fhdrident_str</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>UINT64_FORMAT</name></expr></argument>,
					 <argument><expr><name><name>longhdr</name><operator>-&gt;</operator><name>xlp_sysid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>sysident_str</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>sysident_str</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>UINT64_FORMAT</name></expr></argument>,
					 <argument><expr><name><name>state</name><operator>-&gt;</operator><name>system_identifier</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>report_invalid_flog_record</name><argument_list>(<argument><expr><name>state</name></expr></argument>,
									   <argument><expr><literal type="string">"flashback log file is from different database system: "</literal>
									   <literal type="string">"flashback log file database system identifier is %s, "</literal>
									   <literal type="string">"pg_control database system identifier is %s"</literal></expr></argument>,
									   <argument><expr><name>fhdrident_str</name></expr></argument>, <argument><expr><name>sysident_str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>false</name></expr>;</return>
			<comment type="block">/*no cover end*/</comment>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name><name>longhdr</name><operator>-&gt;</operator><name>xlp_seg_size</name></name> <operator>!=</operator> <name><name>state</name><operator>-&gt;</operator><name>segment_size</name></name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*no cover begin*/</comment>
			<expr_stmt><expr><call><name>report_invalid_flog_record</name><argument_list>(<argument><expr><name>state</name></expr></argument>,
									   <argument><expr><literal type="string">"flashback log file is from different database system: "</literal>
									   <literal type="string">"incorrect segment size in page header"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>false</name></expr>;</return>
			<comment type="block">/*no cover end*/</comment>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name><name>longhdr</name><operator>-&gt;</operator><name>xlp_blcksz</name></name> <operator>!=</operator> <name>POLAR_FLOG_BLCKSZ</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*no cover begin*/</comment>
			<expr_stmt><expr><call><name>report_invalid_flog_record</name><argument_list>(<argument><expr><name>state</name></expr></argument>,
									   <argument><expr><literal type="string">"flashback log file is from different database system: "</literal>
									   <literal type="string">"incorrect POLAR_FLASHBACK_LOG_BLCKSZ in page header"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>false</name></expr>;</return>
			<comment type="block">/*no cover end*/</comment>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>offset</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*no cover begin*/</comment>
		<decl_stmt><decl><type><name>char</name></type>        <name><name>fname</name><index>[<expr><name>FLOG_MAX_FNAME_LEN</name></expr>]</index></name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>get_flog_fname</name><argument_list>(<argument><expr><name>fname</name></expr></argument>, <argument><expr><name>segno</name></expr></argument>, <argument><expr><name><name>state</name><operator>-&gt;</operator><name>segment_size</name></name></expr></argument>, <argument><expr><name>FLOG_DEFAULT_TIMELINE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* hmm, first page of file doesn't have a long header? */</comment>
		<expr_stmt><expr><call><name>report_invalid_flog_record</name><argument_list>(<argument><expr><name>state</name></expr></argument>,
								   <argument><expr><literal type="string">"invalid info bits %04X in flashback log segment %s, offset %u"</literal></expr></argument>,
								   <argument><expr><name><name>hdr</name><operator>-&gt;</operator><name>xlp_info</name></name></expr></argument>,
								   <argument><expr><name>fname</name></expr></argument>,
								   <argument><expr><name>offset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>false</name></expr>;</return>
		<comment type="block">/*no cover end*/</comment>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Check that the address on the page agrees with what we expected. This
	 * check typically fails when an old flashback log segment is recycled,
	 * and hasn't yet been overwritten with new data yet.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>hdr</name><operator>-&gt;</operator><name>xlp_pageaddr</name></name> <operator>!=</operator> <name>recaddr</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*no cover begin*/</comment>
		<decl_stmt><decl><type><name>char</name></type>        <name><name>fname</name><index>[<expr><name>FLOG_MAX_FNAME_LEN</name></expr>]</index></name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>get_flog_fname</name><argument_list>(<argument><expr><name>fname</name></expr></argument>, <argument><expr><name>segno</name></expr></argument>, <argument><expr><name><name>state</name><operator>-&gt;</operator><name>segment_size</name></name></expr></argument>, <argument><expr><name>FLOG_DEFAULT_TIMELINE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>report_invalid_flog_record</name><argument_list>(<argument><expr><name>state</name></expr></argument>,
								   <argument><expr><literal type="string">"unexpected pageaddr %X/%X in flashback log segment %s, offset %u"</literal></expr></argument>,
								   <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator><operator>(</operator><name><name>hdr</name><operator>-&gt;</operator><name>xlp_pageaddr</name></name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr></argument>, <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <name><name>hdr</name><operator>-&gt;</operator><name>xlp_pageaddr</name></name></expr></argument>,
								   <argument><expr><name>fname</name></expr></argument>,
								   <argument><expr><name>offset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>false</name></expr>;</return>
		<comment type="block">/*no cover end*/</comment>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>latest_page_ptr</name></name> <operator>=</operator> <name>recptr</name></expr>;</expr_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Read a single flashback log page including at least [page_ptr, req_len] of valid data
 * via the read_page() callback.
 *
 * Returns -1 if the required page cannot be read for some reason; errormsg_buf
 * is set in that case (unless the error occurs in the read_page callback).
 *
 * We fetch the page from a reader-local cache if we know we have the required
 * data and if there hasn't been any error since caching the data.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>read_flog_page_internal</name><parameter_list>(<parameter><decl><type><name>flog_reader_state</name> <modifier>*</modifier></type><name>state</name></decl></parameter>,
						<parameter><decl><type><name>polar_flog_rec_ptr</name></type> <name>page_ptr</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>req_len</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>         <name>read_len</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32</name></type>      <name>target_pageoff</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint64</name></type>      <name>target_segno</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>flog_page_header</name></type> <name>hdr</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>(</operator><name>page_ptr</name> <operator>%</operator> <name>POLAR_FLOG_BLCKSZ</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>target_segno</name> <operator>=</operator> <call><name>flog_ptr_to_seg</name><argument_list>(<argument><expr><name>page_ptr</name></expr></argument>, <argument><expr><name><name>state</name><operator>-&gt;</operator><name>segment_size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>target_pageoff</name> <operator>=</operator> <call><name>FLOG_SEGMENT_OFFSET</name><argument_list>(<argument><expr><name>page_ptr</name></expr></argument>, <argument><expr><name><name>state</name><operator>-&gt;</operator><name>segment_size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* check whether we have all the requested data already */</comment>
	<if_stmt><if>if <condition>(<expr><name>target_segno</name> <operator>==</operator> <name><name>state</name><operator>-&gt;</operator><name>read_seg_no</name></name> <operator>&amp;&amp;</operator> <name>target_pageoff</name> <operator>==</operator> <name><name>state</name><operator>-&gt;</operator><name>read_off</name></name> <operator>&amp;&amp;</operator>
			<name>req_len</name> <operator>&lt;</operator> <name><name>state</name><operator>-&gt;</operator><name>read_len</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name><name>state</name><operator>-&gt;</operator><name>read_len</name></name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Data is not in our buffer.
	 *
	 * Every time we actually read the page, even if we looked at parts of it
	 * before, we need to do verification as the read_page callback might now
	 * be rereading data from a different source.
	 *
	 * Whenever switching to a new segment, we read the first page of the
	 * file and validate its header, even if that's not where the target
	 * record is.  This is so that we can check the additional identification
	 * info that is present in the first page's "long" header.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>target_segno</name> <operator>!=</operator> <name><name>state</name><operator>-&gt;</operator><name>read_seg_no</name></name> <operator>&amp;&amp;</operator> <name>target_pageoff</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>polar_flog_rec_ptr</name></type>  <name>targetSegmentPtr</name> <init>= <expr><name>page_ptr</name> <operator>-</operator> <name>target_pageoff</name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>read_len</name> <operator>=</operator> <call><name><name>state</name><operator>-&gt;</operator><name>read_page</name></name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>targetSegmentPtr</name></expr></argument>, <argument><expr><name>POLAR_FLOG_BLCKSZ</name></expr></argument>,
									<argument><expr><name><name>state</name><operator>-&gt;</operator><name>curr_rec_ptr</name></name></expr></argument>, <argument><expr><name><name>state</name><operator>-&gt;</operator><name>read_buf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>read_len</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<comment type="block">/*no cover line*/</comment>
			<goto>goto <name>err</name>;</goto></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>flog_page_header_validate</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>targetSegmentPtr</name></expr></argument>,
									   <argument><expr><name><name>state</name><operator>-&gt;</operator><name>read_buf</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<comment type="block">/*no cover line*/</comment>
			<goto>goto <name>err</name>;</goto></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * First, read the requested data length, but at least a short page header
	 * so that we can validate it.
	 */</comment>
	<expr_stmt><expr><name>read_len</name> <operator>=</operator> <call><name><name>state</name><operator>-&gt;</operator><name>read_page</name></name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>page_ptr</name></expr></argument>, <argument><expr><call><name>Max</name><argument_list>(<argument><expr><name>req_len</name></expr></argument>, <argument><expr><name>FLOG_SHORT_PHD_SIZE</name></expr></argument>)</argument_list></call></expr></argument>,
								<argument><expr><name><name>state</name><operator>-&gt;</operator><name>curr_rec_ptr</name></name></expr></argument>, <argument><expr><name><name>state</name><operator>-&gt;</operator><name>read_buf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>read_len</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<goto>goto <name>err</name>;</goto></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>read_len</name> <operator>&lt;=</operator> <name>POLAR_FLOG_BLCKSZ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Do we have enough data to check the header length? */</comment>
	<if_stmt><if>if <condition>(<expr><name>read_len</name> <operator>&lt;=</operator> <name>FLOG_SHORT_PHD_SIZE</name></expr>)</condition><block type="pseudo"><block_content>
		<goto>goto <name>err</name>;</goto></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>read_len</name> <operator>&gt;=</operator> <name>req_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>hdr</name> <operator>=</operator> <operator>(</operator><name>flog_page_header</name><operator>)</operator> <name><name>state</name><operator>-&gt;</operator><name>read_buf</name></name></expr>;</expr_stmt>

	<comment type="block">/* still not enough */</comment>
	<if_stmt><if>if <condition>(<expr><name>read_len</name> <operator>&lt;</operator> <call><name>FLOG_PAGE_HEADER_SIZE</name><argument_list>(<argument><expr><name>hdr</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>read_len</name> <operator>=</operator> <call><name><name>state</name><operator>-&gt;</operator><name>read_page</name></name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>page_ptr</name></expr></argument>, <argument><expr><call><name>FLOG_PAGE_HEADER_SIZE</name><argument_list>(<argument><expr><name>hdr</name></expr></argument>)</argument_list></call></expr></argument>,
									<argument><expr><name><name>state</name><operator>-&gt;</operator><name>curr_rec_ptr</name></name></expr></argument>, <argument><expr><name><name>state</name><operator>-&gt;</operator><name>read_buf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>read_len</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<goto>goto <name>err</name>;</goto></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Now that we know we have the full header, validate it.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>flog_page_header_validate</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>page_ptr</name></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>hdr</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<goto>goto <name>err</name>;</goto></block_content></block></if></if_stmt>

	<comment type="block">/* update read state information */</comment>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>read_seg_no</name></name> <operator>=</operator> <name>target_segno</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>read_off</name></name> <operator>=</operator> <name>target_pageoff</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>read_len</name></name> <operator>=</operator> <name>read_len</name></expr>;</expr_stmt>

	<return>return <expr><name>read_len</name></expr>;</return>

<label><name>err</name>:</label>
	<expr_stmt><expr><call><name>flog_inval_read_state</name><argument_list>(<argument><expr><name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * CRC-check an flashback log record.  We do not believe the contents of an
 * flashback log record (other than to the minimal extent of computing
 * the amount of data to read in) until we've checked the CRCs.
 *
 * We assume all of the record (that is, xl_tot_len bytes) has been read
 * into memory at *record.  Also, polar_flashback_log_page_header_validate()
 * has accepted the record's header, which means in particular that
 * xl_tot_len is at least FLASHBACK_LOG_REC_SIZE.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>flog_record_validate</name><parameter_list>(<parameter><decl><type><name>flog_reader_state</name> <modifier>*</modifier></type><name>state</name></decl></parameter>,
					 <parameter><decl><type><name>flog_record</name> <modifier>*</modifier></type><name>record</name></decl></parameter>, <parameter><decl><type><name>polar_flog_rec_ptr</name></type> <name>recptr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>pg_crc32c</name></type>   <name>crc</name></decl>;</decl_stmt>

	<comment type="block">/* Calculate the CRC */</comment>
	<expr_stmt><expr><call><name>INIT_CRC32C</name><argument_list>(<argument><expr><name>crc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMP_CRC32C</name><argument_list>(<argument><expr><name>crc</name></expr></argument>, <argument><expr><operator>(</operator><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>record</name><operator>)</operator> <operator>+</operator> <name>FLOG_REC_HEADER_SIZE</name></expr></argument>,
				<argument><expr><name><name>record</name><operator>-&gt;</operator><name>xl_tot_len</name></name> <operator>-</operator> <name>FLOG_REC_HEADER_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* include the record header last */</comment>
	<expr_stmt><expr><call><name>COMP_CRC32C</name><argument_list>(<argument><expr><name>crc</name></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>record</name></expr></argument>, <argument><expr><call><name>offsetof</name><argument_list>(<argument><expr><name>flog_record</name></expr></argument>, <argument><expr><name>xl_crc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>FIN_CRC32C</name><argument_list>(<argument><expr><name>crc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>EQ_CRC32C</name><argument_list>(<argument><expr><name><name>record</name><operator>-&gt;</operator><name>xl_crc</name></name></expr></argument>, <argument><expr><name>crc</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*no cover begin*/</comment>
		<expr_stmt><expr><call><name>report_invalid_flog_record</name><argument_list>(<argument><expr><name>state</name></expr></argument>,
								   <argument><expr><literal type="string">"incorrect data crc in flashback log "</literal>
								   <literal type="string">"record at %X/%X"</literal></expr></argument>,
								   <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator><operator>(</operator><name>recptr</name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr></argument>, <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <name>recptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>false</name></expr>;</return>
		<comment type="block">/*no cover end*/</comment>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Attempt to read an flashback log record.
 *
 * If RecPtr is valid, try to read a record at that position.  Otherwise
 * try to read a record just after the last one previously read.
 *
 * If the read_page callback fails to read the requested data, NULL is
 * returned.  The callback is expected to have reported the error; errormsg
 * is set to NULL.
 *
 * If the reading fails for some other reason, NULL is also returned, and
 * *errormsg is set to a string with details of the failure.
 *
 * The returned pointer (or *errormsg) points to an internal buffer that's
 * valid until the next call to polar_read_flashback_log_record.
 */</comment>
<function><type><name>flog_record</name> <modifier>*</modifier></type>
<name>polar_read_flog_record</name><parameter_list>(<parameter><decl><type><name>flog_reader_state</name> <modifier>*</modifier></type><name>state</name></decl></parameter>,
					   <parameter><decl><type><name>polar_flog_rec_ptr</name></type> <name>rec_ptr</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>errormsg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>flog_record</name> <modifier>*</modifier></type><name>record</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>polar_flog_rec_ptr</name></type>  <name>target_page_ptr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32</name></type>      <name>len</name></decl>,
				<decl><type ref="prev"/><name>total_len</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32</name></type>      <name>target_rec_off</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32</name></type>      <name>page_header_size</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>        <name>got_header</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>         <name>read_off</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32</name></type>      <name>got_len</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>rand_access</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>polar_flog_rec_ptr</name></type> <name>next_ptr</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>errormsg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* reset error state */</comment>
	<expr_stmt><expr><operator>*</operator><name>errormsg</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>errormsg_buf</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>

	<comment type="block">/* reset in_switch_region */</comment>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>in_switch_region</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>FLOG_REC_PTR_IS_INVAILD</name><argument_list>(<argument><expr><name>rec_ptr</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* No explicit start point; read the record after the one we just read */</comment>
		<expr_stmt><expr><name>rec_ptr</name> <operator>=</operator> <name><name>state</name><operator>-&gt;</operator><name>end_rec_ptr</name></name></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>FLOG_REC_PTR_IS_INVAILD</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>read_rec_ptr</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>rand_access</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * rec_ptr is pointing to end+1 of the previous flashback log record.  If we're
		 * at a page boundary, no more records can fit on the current page. We
		 * must skip over the page header, but we can't do that until we've
		 * read in the page, since the header size is variable.
		 */</comment>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/*
		 * Caller supplied a position to start at.
		 *
		 * In this case, the passed-in record pointer should already be
		 * pointing to a valid record starting position.
		 */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>FLOG_REC_PTR_IS_VAILD</name><argument_list>(<argument><expr><name>rec_ptr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>rand_access</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>curr_rec_ptr</name></name> <operator>=</operator> <name>rec_ptr</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>target_page_ptr</name> <operator>=</operator> <name>rec_ptr</name> <operator>-</operator> <operator>(</operator><name>rec_ptr</name> <operator>%</operator> <name>POLAR_FLOG_BLCKSZ</name><operator>)</operator></expr>;</expr_stmt>
	<expr_stmt><expr><name>target_rec_off</name> <operator>=</operator> <name>rec_ptr</name> <operator>%</operator> <name>POLAR_FLOG_BLCKSZ</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Read the page containing the record into state-&gt;readBuf. Request enough
	 * byte to cover the whole record header, or at least the part of it that
	 * fits on the same page.
	 */</comment>
	<expr_stmt><expr><name>read_off</name> <operator>=</operator> <call><name>read_flog_page_internal</name><argument_list>(<argument><expr><name>state</name></expr></argument>,
									   <argument><expr><name>target_page_ptr</name></expr></argument>,
									   <argument><expr><call><name>Min</name><argument_list>(<argument><expr><name>target_rec_off</name> <operator>+</operator> <name>FLOG_REC_HEADER_SIZE</name></expr></argument>, <argument><expr><name>POLAR_FLOG_BLCKSZ</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>read_off</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<goto>goto <name>err</name>;</goto></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>got_len</name> <operator>=</operator> <name>read_off</name> <operator>-</operator> <name>target_rec_off</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * ReadPageInternal always returns at least the page header, so we can
	 * examine it now.
	 */</comment>
	<expr_stmt><expr><name>page_header_size</name> <operator>=</operator> <call><name>FLOG_PAGE_HEADER_SIZE</name><argument_list>(<argument><expr><operator>(</operator><name>flog_page_header</name><operator>)</operator> <name><name>state</name><operator>-&gt;</operator><name>read_buf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>target_rec_off</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * At page start, so skip over page header.
		 */</comment>
		<expr_stmt><expr><name>rec_ptr</name> <operator>+=</operator> <name>page_header_size</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>target_rec_off</name> <operator>=</operator> <name>page_header_size</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>target_rec_off</name> <operator>&lt;</operator> <name>page_header_size</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*no cover begin*/</comment>
		<expr_stmt><expr><call><name>report_invalid_flog_record</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><literal type="string">"invalid flashback log record offset at %X/%X"</literal></expr></argument>,
								   <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator><operator>(</operator><name>rec_ptr</name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr></argument>, <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <name>rec_ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<goto>goto <name>err</name>;</goto>
		<comment type="block">/*no cover end*/</comment>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Can't read flashback log from contrecord ptr */</comment>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><operator>(</operator><operator>(</operator><name>flog_page_header</name><operator>)</operator> <name><name>state</name><operator>-&gt;</operator><name>read_buf</name></name><operator>)</operator><operator>-&gt;</operator><name>xlp_info</name> <operator>&amp;</operator> <name>FLOG_FIRST_IS_CONTRECORD</name><operator>)</operator> <operator>&amp;&amp;</operator>
			<name>target_rec_off</name> <operator>==</operator> <name>page_header_size</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*no cover begin*/</comment>
		<expr_stmt><expr><call><name>report_invalid_flog_record</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><literal type="string">"contrecord flashback log is requested by %X/%X"</literal></expr></argument>,
								   <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator><operator>(</operator><name>rec_ptr</name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr></argument>, <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <name>rec_ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<goto>goto <name>err</name>;</goto>
		<comment type="block">/*no cover end*/</comment>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* ReadPageInternal has verified the page header */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>page_header_size</name> <operator>&lt;=</operator> <name>read_off</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Read the record length.
	 *
	 * NB: Even though we use an polar_flashback_log_record pointer here, the whole record
	 * header might not fit on this page. xl_tot_len is the first field of the
	 * struct, so it must be on this page (the records are MAXALIGNed), but we
	 * cannot access any other fields until we've verified that we got the
	 * whole header.
	 */</comment>
	<expr_stmt><expr><name>record</name> <operator>=</operator> <operator>(</operator><name>flog_record</name> <operator>*</operator><operator>)</operator><operator>(</operator><name><name>state</name><operator>-&gt;</operator><name>read_buf</name></name> <operator>+</operator> <name>rec_ptr</name> <operator>%</operator> <name>POLAR_FLOG_BLCKSZ</name><operator>)</operator></expr>;</expr_stmt>
	<expr_stmt><expr><name>total_len</name> <operator>=</operator> <name><name>record</name><operator>-&gt;</operator><name>xl_tot_len</name></name></expr>;</expr_stmt>

	<comment type="block">/*
	 * If the whole record header is on this page, validate it immediately.
	 * Otherwise do just a basic sanity check on xl_tot_len, and validate the
	 * rest of the header after reading it from the next page.  The xl_tot_len
	 * check is necessary here to ensure that we enter the "Need to reassemble
	 * record" code path below; otherwise we might fail to apply
	 * polar_valid_flashback_log_rec_header at all.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>target_rec_off</name> <operator>&lt;=</operator> <name>POLAR_FLOG_BLCKSZ</name> <operator>-</operator> <name>FLOG_REC_HEADER_SIZE</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*no cover begin*/</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>valid_flog_rec_header</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>rec_ptr</name></expr></argument>, <argument><expr><name><name>state</name><operator>-&gt;</operator><name>read_rec_ptr</name></name></expr></argument>,
								   <argument><expr><name>record</name></expr></argument>, <argument><expr><name>rand_access</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<goto>goto <name>err</name>;</goto></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>got_header</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<comment type="block">/*no cover end*/</comment>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* XXX: more validation should be done here */</comment>
		<if_stmt><if>if <condition>(<expr><name>total_len</name> <operator>&lt;</operator> <name>FLOG_REC_HEADER_SIZE</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*no cover begin*/</comment>
			<expr_stmt><expr><call><name>report_invalid_flog_record</name><argument_list>(<argument><expr><name>state</name></expr></argument>,
									   <argument><expr><literal type="string">"invalid flashback log record length at %X/%X: wanted %u, got %u"</literal></expr></argument>,
									   <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator><operator>(</operator><name>rec_ptr</name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr></argument>, <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <name>rec_ptr</name></expr></argument>,
									   <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <name>FLOG_REC_HEADER_SIZE</name></expr></argument>, <argument><expr><name>total_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<goto>goto <name>err</name>;</goto>
			<comment type="block">/*no cover end*/</comment>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name>got_header</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/*
	 * Enlarge readRecordBuf as needed.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>total_len</name> <operator>&gt;</operator> <name><name>state</name><operator>-&gt;</operator><name>read_record_buf_size</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>allocate_flog_read_buf</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>total_len</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*no cover begin*/</comment>
		<comment type="block">/* We treat this as a "bogus data" condition */</comment>
		<expr_stmt><expr><call><name>report_invalid_flog_record</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><literal type="string">"record length %u at %X/%X too long"</literal></expr></argument>,
								   <argument><expr><name>total_len</name></expr></argument>,
								   <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator><operator>(</operator><name>rec_ptr</name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr></argument>, <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <name>rec_ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<goto>goto <name>err</name>;</goto>
		<comment type="block">/*no cover end*/</comment>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>len</name> <operator>=</operator> <name>POLAR_FLOG_BLCKSZ</name> <operator>-</operator> <name>rec_ptr</name> <operator>%</operator> <name>POLAR_FLOG_BLCKSZ</name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>total_len</name> <operator>&gt;</operator> <name>len</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Need to reassemble record */</comment>
		<decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>contdata</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>flog_page_header</name></type> <name>page_header</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>buffer</name></decl>;</decl_stmt>

		<comment type="block">/* Copy the first fragment of the record from the first page. */</comment>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>read_record_buf</name></name></expr></argument>,
			   <argument><expr><name><name>state</name><operator>-&gt;</operator><name>read_buf</name></name> <operator>+</operator> <name>rec_ptr</name> <operator>%</operator> <name>POLAR_FLOG_BLCKSZ</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>buffer</name> <operator>=</operator> <name><name>state</name><operator>-&gt;</operator><name>read_record_buf</name></name> <operator>+</operator> <name>len</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>got_len</name> <operator>=</operator> <name>len</name></expr>;</expr_stmt>

		<do>do
		<block>{<block_content>
			<comment type="block">/* Calculate pointer to beginning of next page */</comment>
			<expr_stmt><expr><name>target_page_ptr</name> <operator>+=</operator> <name>POLAR_FLOG_BLCKSZ</name></expr>;</expr_stmt>

			<comment type="block">/* Wait for the next page to become available */</comment>
			<expr_stmt><expr><name>read_off</name> <operator>=</operator> <call><name>read_flog_page_internal</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>target_page_ptr</name></expr></argument>,
											   <argument><expr><call><name>Min</name><argument_list>(<argument><expr><name>total_len</name> <operator>-</operator> <name>got_len</name> <operator>+</operator> <name>FLOG_SHORT_PHD_SIZE</name></expr></argument>,
												   <argument><expr><name>POLAR_FLOG_BLCKSZ</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name>read_off</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<goto>goto <name>err</name>;</goto></block_content></block></if></if_stmt>

			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>FLOG_SHORT_PHD_SIZE</name> <operator>&lt;=</operator> <name>read_off</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* Check that the continuation on next page looks valid */</comment>
			<expr_stmt><expr><name>page_header</name> <operator>=</operator> <operator>(</operator><name>flog_page_header</name><operator>)</operator> <name><name>state</name><operator>-&gt;</operator><name>read_buf</name></name></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name><name>page_header</name><operator>-&gt;</operator><name>xlp_info</name></name> <operator>&amp;</operator> <name>FLOG_FIRST_IS_CONTRECORD</name><operator>)</operator></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/*no cover begin*/</comment>
				<expr_stmt><expr><call><name>report_invalid_flog_record</name><argument_list>(<argument><expr><name>state</name></expr></argument>,
										   <argument><expr><literal type="string">"there is no contrecord flag at flashback log %X/%X"</literal></expr></argument>,
										   <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator><operator>(</operator><name>rec_ptr</name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr></argument>, <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <name>rec_ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<goto>goto <name>err</name>;</goto>
				<comment type="block">/*no cover end*/</comment>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/*
			 * Cross-check that xlp_rem_len agrees with how much of the record
			 * we expect there to be left.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>page_header</name><operator>-&gt;</operator><name>xlp_rem_len</name></name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
					<name>total_len</name> <operator>!=</operator> <operator>(</operator><name><name>page_header</name><operator>-&gt;</operator><name>xlp_rem_len</name></name> <operator>+</operator> <name>got_len</name><operator>)</operator></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/*no cover begin*/</comment>
				<expr_stmt><expr><call><name>report_invalid_flog_record</name><argument_list>(<argument><expr><name>state</name></expr></argument>,
										   <argument><expr><literal type="string">"invalid contrecord length %u at flashback log %X/%X"</literal></expr></argument>,
										   <argument><expr><name><name>page_header</name><operator>-&gt;</operator><name>xlp_rem_len</name></name></expr></argument>,
										   <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator><operator>(</operator><name>rec_ptr</name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr></argument>, <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <name>rec_ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<goto>goto <name>err</name>;</goto>
				<comment type="block">/*no cover end*/</comment>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/* Append the continuation from this page to the buffer */</comment>
			<expr_stmt><expr><name>page_header_size</name> <operator>=</operator> <call><name>FLOG_PAGE_HEADER_SIZE</name><argument_list>(<argument><expr><name>page_header</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name>read_off</name> <operator>&lt;</operator> <name>page_header_size</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>read_off</name> <operator>=</operator> <call><name>read_flog_page_internal</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>target_page_ptr</name></expr></argument>,
												   <argument><expr><name>page_header_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>page_header_size</name> <operator>&lt;=</operator> <name>read_off</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name>contdata</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name><name>state</name><operator>-&gt;</operator><name>read_buf</name></name> <operator>+</operator> <name>page_header_size</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>len</name> <operator>=</operator> <name>POLAR_FLOG_BLCKSZ</name> <operator>-</operator> <name>page_header_size</name></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>page_header</name><operator>-&gt;</operator><name>xlp_rem_len</name></name> <operator>&lt;</operator> <name>len</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>len</name> <operator>=</operator> <name><name>page_header</name><operator>-&gt;</operator><name>xlp_rem_len</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><name>read_off</name> <operator>&lt;</operator> <name>page_header_size</name> <operator>+</operator> <name>len</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>read_off</name> <operator>=</operator> <call><name>read_flog_page_internal</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>target_page_ptr</name></expr></argument>,
												   <argument><expr><name>page_header_size</name> <operator>+</operator> <name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>contdata</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>buffer</name> <operator>+=</operator> <name>len</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>got_len</name> <operator>+=</operator> <name>len</name></expr>;</expr_stmt>

			<comment type="block">/* If we just reassembled the record header, validate it. */</comment>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>got_header</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>record</name> <operator>=</operator> <operator>(</operator><name>flog_record</name> <operator>*</operator><operator>)</operator> <name><name>state</name><operator>-&gt;</operator><name>read_record_buf</name></name></expr>;</expr_stmt>

				<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>valid_flog_rec_header</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>rec_ptr</name></expr></argument>, <argument><expr><name><name>state</name><operator>-&gt;</operator><name>read_rec_ptr</name></name></expr></argument>,
										   <argument><expr><name>record</name></expr></argument>, <argument><expr><name>rand_access</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<goto>goto <name>err</name>;</goto></block_content></block></if></if_stmt>

				<expr_stmt><expr><name>got_header</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block>
		while <condition>(<expr><name>got_len</name> <operator>&lt;</operator> <name>total_len</name></expr>)</condition>;</do>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>got_header</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>record</name> <operator>=</operator> <operator>(</operator><name>flog_record</name> <operator>*</operator><operator>)</operator> <name><name>state</name><operator>-&gt;</operator><name>read_record_buf</name></name></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>flog_record_validate</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>record</name></expr></argument>, <argument><expr><name>rec_ptr</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<goto>goto <name>err</name>;</goto></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>page_header_size</name> <operator>=</operator> <call><name>FLOG_PAGE_HEADER_SIZE</name><argument_list>(<argument><expr><operator>(</operator><name>flog_page_header</name><operator>)</operator> <name><name>state</name><operator>-&gt;</operator><name>read_buf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>read_rec_ptr</name></name> <operator>=</operator> <name>rec_ptr</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>end_rec_ptr</name></name> <operator>=</operator> <name>target_page_ptr</name> <operator>+</operator> <name>page_header_size</name>
							 <operator>+</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><name><name>page_header</name><operator>-&gt;</operator><name>xlp_rem_len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name>read_off</name> <operator>=</operator> <call><name>read_flog_page_internal</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>target_page_ptr</name></expr></argument>,
										   <argument><expr><call><name>Min</name><argument_list>(<argument><expr><name>target_rec_off</name> <operator>+</operator> <name>total_len</name></expr></argument>, <argument><expr><name>POLAR_FLOG_BLCKSZ</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>read_off</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<goto>goto <name>err</name>;</goto></block_content></block></if></if_stmt>

		<comment type="block">/* Record does not cross a page boundary */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>flog_record_validate</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>record</name></expr></argument>, <argument><expr><name>rec_ptr</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<goto>goto <name>err</name>;</goto></block_content></block></if></if_stmt>

		<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>end_rec_ptr</name></name> <operator>=</operator> <name>rec_ptr</name> <operator>+</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><name>total_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>read_rec_ptr</name></name> <operator>=</operator> <name>rec_ptr</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>read_record_buf</name></name></expr></argument>, <argument><expr><name>record</name></expr></argument>, <argument><expr><name>total_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>convert_to_first_valid_ptr</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>end_rec_ptr</name></name></expr></argument>)</argument_list></call> <operator>==</operator>
			<call><name>polar_get_next_flog_ptr</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>read_rec_ptr</name></name></expr></argument>, <argument><expr><name><name>record</name><operator>-&gt;</operator><name>xl_tot_len</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>record</name></expr>;</return>

<label><name>err</name>:</label>

	<comment type="block">/*
	 * Invalidate the read state. We might read from a different source after
	 * failure.
	 */</comment>
	<expr_stmt><expr><call><name>flog_inval_read_state</name><argument_list>(<argument><expr><name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>errormsg_buf</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'\0'</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><operator>*</operator><name>errormsg</name> <operator>=</operator> <name><name>state</name><operator>-&gt;</operator><name>errormsg_buf</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Is the record in the switch region */</comment>
	<expr_stmt><expr><name>next_ptr</name> <operator>=</operator> <name><name>state</name><operator>-&gt;</operator><name>curr_rec_ptr</name></name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>polar_is_flog_rec_ignore</name><argument_list>(<argument><expr><operator>&amp;</operator><name>next_ptr</name></expr></argument>, <argument><expr><name>total_len</name></expr></argument>, <argument><expr><name>state</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>in_switch_region</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>end_rec_ptr</name></name> <operator>=</operator> <name>next_ptr</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Allocate and initialize a new flashback log reader.
 *
 * Returns NULL if the flashback log reader couldn't be allocated.
 * Change the memory context to flashback log read memory context.
 */</comment>
<function><type><name>flog_reader_state</name> <modifier>*</modifier></type>
<name>polar_flog_reader_allocate</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>segment_size</name></decl></parameter>, <parameter><decl><type><name>page_read_callback</name></type> <name>page_read_func</name></decl></parameter>,
						   <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>private_data</name></decl></parameter>, <parameter><decl><type><name>flog_buf_ctl_t</name></type> <name>flog_buf_ctl</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>flog_reader_state</name> <modifier>*</modifier></type><name>state</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>state</name> <operator>=</operator> <operator>(</operator><name>flog_reader_state</name> <operator>*</operator><operator>)</operator>
			<call><name>polar_palloc_extended_in_crit</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>flog_reader_state</name></expr></argument>)</argument_list></sizeof></expr></argument>,
										  <argument><expr><name>MCXT_ALLOC_NO_OOM</name> <operator>|</operator> <name>MCXT_ALLOC_ZERO</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>state</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Permanently allocate readBuf.  We do it this way, rather than just
	 * making a static array, for two reasons: (1) no need to waste the
	 * storage in most instantiations of the backend; (2) a static char array
	 * isn't guaranteed to have any particular alignment, whereas
	 * palloc_extended() will provide MAXALIGN'd storage.
	 */</comment>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>read_buf</name></name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>polar_palloc_extended_in_crit</name><argument_list>(<argument><expr><name>POLAR_FLOG_BLCKSZ</name></expr></argument>,
															 <argument><expr><name>MCXT_ALLOC_NO_OOM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>state</name><operator>-&gt;</operator><name>read_buf</name></name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*no cover begin*/</comment>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
		<comment type="block">/*no cover end*/</comment>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>system_identifier</name></name> <operator>=</operator> <call><name>GetSystemIdentifier</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>segment_size</name></name> <operator>=</operator> <name>segment_size</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>read_page</name></name> <operator>=</operator> <name>page_read_func</name></expr>;</expr_stmt>
	<comment type="block">/* system_identifier initialized to zeroes above */</comment>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>private_data</name></name> <operator>=</operator> <name>private_data</name></expr>;</expr_stmt>
	<comment type="block">/* ReadRecPtr and EndRecPtr initialized to zeroes above */</comment>
	<comment type="block">/* readSegNo, readOff, readLen, readPageTLI initialized to zeroes above */</comment>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>errormsg_buf</name></name> <operator>=</operator> <call><name>polar_palloc_extended_in_crit</name><argument_list>(<argument><expr><name>MAX_ERRORMSG_LEN</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>,
														<argument><expr><name>MCXT_ALLOC_NO_OOM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>state</name><operator>-&gt;</operator><name>errormsg_buf</name></name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*no cover begin*/</comment>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>read_buf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
		<comment type="block">/*no cover end*/</comment>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>errormsg_buf</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>switch_ptrs</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>in_switch_region</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>flog_buf_ctl</name></name> <operator>=</operator> <name>flog_buf_ctl</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Allocate an initial readRecordBuf of minimal size, which can later be
	 * enlarged if necessary.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>allocate_flog_read_buf</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*no cover begin*/</comment>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>errormsg_buf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>read_buf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>list_free_deep</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>switch_ptrs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
		<comment type="block">/*no cover end*/</comment>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>state</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * POLAR: Free the flashback log reader state and switch to old context.
 */</comment>
<function><type><name>void</name></type>
<name>polar_flog_reader_free</name><parameter_list>(<parameter><decl><type><name>flog_reader_state</name> <modifier>*</modifier></type><name>state</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>errormsg_buf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>read_record_buf</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>read_record_buf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>read_buf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>list_free_deep</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>switch_ptrs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Read the flashback log page containing targetRecPtr into readBuf
 * (if not read already). It is just called by polar_flashback_logindex_startup.
 *
 * Returns number of bytes read, if the page is read successfully,
 * or -1 in case of errors.
 *
 * When errors occur, they are ereport'ed in WARNING level.
 *
 */</comment>
<function><type><name>int</name></type>
<name>polar_flog_page_read</name><parameter_list>(<parameter><decl><type><name>flog_reader_state</name> <modifier>*</modifier></type><name>state</name></decl></parameter>,
					 <parameter><decl><type><name>polar_flog_rec_ptr</name></type> <name>target_page_ptr</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>req_len</name></decl></parameter>,
					 <parameter><decl><type><name>polar_flog_rec_ptr</name></type> <name>target_rec_ptr</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>cur_page</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>uint32</name></type>      <name>target_page_off</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint64</name>      <name>target_seg_no</name></type> <name>PG_USED_FOR_ASSERTS_ONLY</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>         <name>polar_read_rc</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>        <name><name>file_name</name><index>[<expr><name>FLOG_MAX_FNAME_LEN</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>polar_flog_rec_ptr</name></type> <name>read_upto</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>flog_buf_ctl</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* Check there is enough data? */</comment>
	<expr_stmt><expr><name>read_upto</name> <operator>=</operator> <call><name>polar_get_flog_write_result</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>flog_buf_ctl</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>target_page_ptr</name> <operator>+</operator> <name>POLAR_FLOG_BLCKSZ</name> <operator>&lt;=</operator> <name>read_upto</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * more than one block available; read only that block, have caller
		 * come back if they need more.
		 */</comment>
		<expr_stmt><expr><name>read_len</name> <operator>=</operator> <name>POLAR_FLOG_BLCKSZ</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>target_page_ptr</name> <operator>+</operator> <name>req_len</name> <operator>&gt;</operator> <name>read_upto</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Not enough data there. Warn when we read log beyond read upto point.
		 * Put the error message to state for caller to check.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>unlikely</name><argument_list>(<argument><expr><name>polar_flashback_log_debug</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>, <argument><expr><literal type="string">"No enough flashback log in disk while read from "</literal>
					<literal type="string">"target page pointer %ld, request length %d and read upto %ld"</literal></expr></argument>,
					<argument><expr><name>target_page_ptr</name></expr></argument>, <argument><expr><name>req_len</name></expr></argument>, <argument><expr><name>read_upto</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>report_invalid_flog_record</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>REC_UNFLUSHED_ERROR_MSG</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<goto>goto <name>next_record_is_invalid</name>;</goto>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* enough bytes available to satisfy the request */</comment>
		<expr_stmt><expr><name>read_len</name> <operator>=</operator> <name>read_upto</name> <operator>-</operator> <name>target_page_ptr</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><name>target_seg_no</name> <operator>=</operator> <call><name>flog_ptr_to_seg</name><argument_list>(<argument><expr><name>target_page_ptr</name></expr></argument>, <argument><expr><name>POLAR_FLOG_SEG_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>target_page_off</name> <operator>=</operator> <call><name>FLOG_SEGMENT_OFFSET</name><argument_list>(<argument><expr><name>target_page_ptr</name></expr></argument>, <argument><expr><name>POLAR_FLOG_SEG_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * See if we need to switch to a new segment because the requested record
	 * is not in the currently open one.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>read_file</name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
			<operator>!</operator><call><name>ptr_in_flog_seg</name><argument_list>(<argument><expr><name>target_page_ptr</name></expr></argument>, <argument><expr><name>read_segno</name></expr></argument>, <argument><expr><name>POLAR_FLOG_SEG_SIZE</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>polar_close</name><argument_list>(<argument><expr><name>read_file</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>read_file</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>read_segno</name> <operator>=</operator> <call><name>flog_ptr_to_seg</name><argument_list>(<argument><expr><name>target_page_ptr</name></expr></argument>, <argument><expr><name>POLAR_FLOG_SEG_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>read_file</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>polar_is_flog_file_exist</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>flog_buf_ctl</name><operator>-&gt;</operator><name>dir</name></name></expr></argument>, <argument><expr><name>target_page_ptr</name></expr></argument>, <argument><expr><name>WARNING</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>read_file</name> <operator>=</operator> <call><name>polar_flog_file_open</name><argument_list>(<argument><expr><name>read_segno</name></expr></argument>, <argument><expr><name><name>state</name><operator>-&gt;</operator><name>flog_buf_ctl</name><operator>-&gt;</operator><name>dir</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/*no cover begin*/</comment>
			<expr_stmt><expr><call><name>get_flog_fname</name><argument_list>(<argument><expr><name>file_name</name></expr></argument>, <argument><expr><name>read_segno</name></expr></argument>,
						   <argument><expr><name>POLAR_FLOG_SEG_SIZE</name></expr></argument>, <argument><expr><name>FLOG_DEFAULT_TIMELINE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>report_invalid_flog_record</name><argument_list>(<argument><expr><name>state</name></expr></argument>,
									   <argument><expr><literal type="string">"Can't find the flashback log segno file %s"</literal></expr></argument>, <argument><expr><name>file_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<goto>goto <name>next_record_is_invalid</name>;</goto>
			<comment type="block">/*no cover end*/</comment>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * At this point, we have the right segment open and if
	 * the requested record is in it.
	 */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>read_file</name> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Read the requested page */</comment>
	<expr_stmt><expr><name>read_off</name> <operator>=</operator> <name>target_page_off</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>pgstat_report_wait_start</name><argument_list>(<argument><expr><name>WAIT_EVENT_FLASHBACK_LOG_READ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>polar_read_rc</name> <operator>=</operator> <call><name>polar_pread</name><argument_list>(<argument><expr><name>read_file</name></expr></argument>, <argument><expr><name>cur_page</name></expr></argument>, <argument><expr><name>POLAR_FLOG_BLCKSZ</name></expr></argument>, <argument><expr><operator>(</operator><name>off_t</name><operator>)</operator> <name>read_off</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>polar_read_rc</name> <operator>!=</operator> <name>POLAR_FLOG_BLCKSZ</name></expr>)</condition>
	<block>{<block_content>

		<decl_stmt><decl><type><name>char</name></type>        <name><name>fname</name><index>[<expr><name>FLOG_MAX_FNAME_LEN</name></expr>]</index></name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>         <name>save_errno</name> <init>= <expr><name>errno</name></expr></init></decl>;</decl_stmt>

		<comment type="block">/*no cover begin*/</comment>
		<expr_stmt><expr><call><name>pgstat_report_wait_end</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>get_flog_fname</name><argument_list>(<argument><expr><name>fname</name></expr></argument>, <argument><expr><name>read_segno</name></expr></argument>, <argument><expr><name>POLAR_FLOG_SEG_SIZE</name></expr></argument>, <argument><expr><name>FLOG_DEFAULT_TIMELINE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>errno</name> <operator>=</operator> <name>save_errno</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not read from flashback log segment %s, offset %u: %m"</literal></expr></argument>,
						<argument><expr><name>fname</name></expr></argument>, <argument><expr><name>read_off</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<goto>goto <name>next_record_is_invalid</name>;</goto>
		<comment type="block">/*no cover end*/</comment>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>pgstat_report_wait_end</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>target_seg_no</name> <operator>==</operator> <name>read_segno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>target_page_off</name> <operator>==</operator> <name>read_off</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>req_len</name> <operator>&lt;=</operator> <name>read_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Check the page header immediately, so that we can retry immediately if
	 * it's not valid. This may seem unnecessary, because polar_flashback_log_read_record()
	 * validates the page header anyway, and would propagate the failure up to
	 * ReadRecord(), which would retry. However, there's a corner case with
	 * continuation records, if a record is split across two pages such that
	 * we would need to read the two pages from different sources.
	 *
	 * Validating the page header is cheap enough that doing it twice
	 * shouldn't be a big deal from a performance point of view.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>flog_page_header_validate</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>target_page_ptr</name></expr></argument>, <argument><expr><name>cur_page</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*no cover line*/</comment>
		<goto>goto <name>next_record_is_invalid</name>;</goto>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>read_len</name></expr>;</return>

<label><name>next_record_is_invalid</name>:</label>

	<if_stmt><if>if <condition>(<expr><name>read_file</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>polar_close</name><argument_list>(<argument><expr><name>read_file</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>read_file</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>read_len</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * POLAR: Check the flashback log record error can be ignore?
 *
 * Change the ptr to next_ptr.
 */</comment>
<function><type><name>bool</name></type>
<name>polar_is_flog_rec_ignore</name><parameter_list>(<parameter><decl><type><name>polar_flog_rec_ptr</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>, <parameter><decl><type><name>uint32</name></type> <name>log_len</name></decl></parameter>, <parameter><decl><type><name>flog_reader_state</name> <modifier>*</modifier></type><name>reader</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>cell</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>polar_flog_rec_ptr</name></type> <name>end_ptr</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>log_len</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>end_ptr</name> <operator>=</operator> <operator>*</operator><name>ptr</name></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>end_ptr</name> <operator>=</operator> <call><name>polar_get_next_flog_ptr</name><argument_list>(<argument><expr><operator>*</operator><name>ptr</name></expr></argument>, <argument><expr><name>log_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<expr_stmt><expr><name><name>reader</name><operator>-&gt;</operator><name>switch_ptrs</name></name> <operator>=</operator> <call><name>load_switch_ptrs</name><argument_list>(<argument><expr><name><name>reader</name><operator>-&gt;</operator><name>flog_buf_ctl</name><operator>-&gt;</operator><name>dir</name></name></expr></argument>, <argument><expr><name><name>reader</name><operator>-&gt;</operator><name>switch_ptrs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<macro><name>foreach</name> <argument_list>(<argument>cell</argument>, <argument>reader-&gt;switch_ptrs</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>flog_history_entry</name> <modifier>*</modifier></type><name>tle</name> <init>= <expr><operator>(</operator><name>flog_history_entry</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>cell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><operator>(</operator><name>end_ptr</name> <operator>&gt;</operator> <name><name>tle</name><operator>-&gt;</operator><name>switch_ptr</name></name> <operator>&amp;&amp;</operator> <operator>*</operator><name>ptr</name> <operator>&lt;</operator> <name><name>tle</name><operator>-&gt;</operator><name>next_ptr</name></name><operator>)</operator> <operator>||</operator>
				<operator>*</operator><name>ptr</name> <operator>==</operator> <name><name>tle</name><operator>-&gt;</operator><name>switch_ptr</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>, <argument><expr><literal type="string">"The flashback log record at %X/%X will be ignore. and switch to "</literal>
				 <literal type="string">"%X/%X"</literal></expr></argument>, <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator><operator>(</operator><operator>*</operator><name>ptr</name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr></argument>, <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator><operator>(</operator><operator>*</operator><name>ptr</name><operator>)</operator></expr></argument>,
				 <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator><operator>(</operator><operator>(</operator><name><name>tle</name><operator>-&gt;</operator><name>next_ptr</name></name> <operator>+</operator> <name>FLOG_LONG_PHD_SIZE</name><operator>)</operator> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr></argument>,
				 <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator><operator>(</operator><name><name>tle</name><operator>-&gt;</operator><name>next_ptr</name></name> <operator>+</operator> <name>FLOG_LONG_PHD_SIZE</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><operator>*</operator><name>ptr</name> <operator>=</operator> <name><name>tle</name><operator>-&gt;</operator><name>next_ptr</name></name> <operator>+</operator> <name>FLOG_LONG_PHD_SIZE</name></expr>;</expr_stmt>
			<return>return <expr><name>true</name></expr>;</return>
		</block_content>}</block></if>
		<comment type="block">/* We have check it in the before */</comment>
		<if type="elseif">else if <condition>(<expr><operator>*</operator><name>ptr</name> <operator>&gt;</operator> <name><name>tle</name><operator>-&gt;</operator><name>next_ptr</name></name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block>

	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>
</unit>
