<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/PolarDB-for-PostgreSQL/src/backend/polar_flashback/polar_flashback_log.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * polar_flashback_log.c
 *
 *
 * Portions Copyright (c) 1996-2018, PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, Regents of the University of California
 * Portions Copyright (c) 2021, Alibaba Group Holding limited
 *
 * IDENTIFICATION
 *    src/backend/polar_flashback/polar_flashback_log.c
 *
 *-------------------------------------------------------------------------
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/xlog.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/xlogdefs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"polar_flashback/polar_flashback_log.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"polar_flashback/polar_flashback_log_file.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"polar_flashback/polar_flashback_log_index.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"polar_flashback/polar_flashback_log_insert.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"polar_flashback/polar_flashback_log_worker.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"polar_flashback/polar_flashback_point.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/buf_internals.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/bufpage.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/bufmgr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/guc.h"</cpp:file></cpp:include>

<comment type="block">/* GUCs */</comment>
<decl_stmt><decl><type><name>bool</name></type> <name>polar_enable_flashback_log</name></decl>;</decl_stmt>
<comment type="block">/* For the logindex */</comment>
<decl_stmt><decl><type><name>int</name></type> <name>polar_flashback_logindex_mem_size</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>polar_flashback_logindex_bloom_blocks</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>polar_flashback_logindex_queue_buffers</name></decl>;</decl_stmt>
<comment type="block">/* For the flashback log buffers */</comment>
<decl_stmt><decl><type><name>int</name></type> <name>polar_flashback_log_buffers</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>polar_flashback_log_insert_locks</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>flog_ctl_t</name></type> <name>flog_instance</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>flog_data_need_remove_all</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><operator>!</operator><name>polar_enable_flashback_log</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>polar_in_replica_mode</name><argument_list>()</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * POLAR: Remove all the flashback relative files contain log files and
 * logindex files. And keep the flashback logindex dir.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>flog_data_remove_all</name><parameter_list>(<parameter><decl><type><name>flog_ctl_t</name></type> <name>instance</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>logindex_snapshot_t</name></type> <name>snapshot</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>flog_buf_ctl_t</name></type> <name>buf_ctl</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>instance</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>snapshot</name> <operator>=</operator> <name><name>instance</name><operator>-&gt;</operator><name>logindex_snapshot</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>buf_ctl</name> <operator>=</operator> <name><name>instance</name><operator>-&gt;</operator><name>buf_ctl</name></name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>polar_flog_index_remove_all</name><argument_list>(<argument><expr><name>snapshot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>polar_flog_remove_all</name><argument_list>(<argument><expr><name>buf_ctl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>Size</name></type>
<name>flog_ctl_size</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>MAXALIGN</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>flog_ctl_data_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * POLAR: Set the flashback log buffer state according the database state.
 *
 * NB: Only startup process will call the function, so it is lock free.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>polar_set_flog_state</name><parameter_list>(<parameter><decl><type><name>flog_ctl_t</name></type> <name>instance</name></decl></parameter>, <parameter><decl><type><name>flashback_state</name></type> <name>state</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><name><name>instance</name><operator>-&gt;</operator><name>state</name></name> <operator>=</operator> <name>state</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pg_write_barrier</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>polar_flog_ctl_init_data</name><parameter_list>(<parameter><decl><type><name>flog_ctl_t</name></type> <name>ctl</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><name>ctl</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>flog_ctl_data_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ctl</name><operator>-&gt;</operator><name>state</name></name> <operator>=</operator> <name>FLOG_INIT</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>flog_ctl_t</name></type>
<name>polar_flog_ctl_init</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>flog_ctl_t</name></type> <name>ctl</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>found</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>ctl</name> <operator>=</operator> <operator>(</operator><name>flog_ctl_t</name><operator>)</operator><call><name>ShmemInitStruct</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><call><name>flog_ctl_size</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>IsUnderPostmaster</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>polar_flog_ctl_init_data</name><argument_list>(<argument><expr><name>ctl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<return>return <expr><name>ctl</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>polar_flog_rec_ptr</name></type>
<name>cal_min_keep_flog_ptr</name><parameter_list>(<parameter><decl><type><name>logindex_snapshot_t</name></type> <name>snapshot</name></decl></parameter>, <parameter><decl><type><name>polar_flog_rec_ptr</name></type> <name>ptr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>polar_flog_rec_ptr</name></type> <name>keep_ptr</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>keep_ptr</name> <operator>=</operator> <call><name>polar_get_flog_index_meta_max_ptr</name><argument_list>(<argument><expr><name>snapshot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>keep_ptr</name> <operator>=</operator> <ternary><condition><expr><name>keep_ptr</name> <operator>&lt;</operator> <name>ptr</name></expr> ?</condition><then> <expr><name>keep_ptr</name></expr> </then><else>: <expr><name>ptr</name></expr></else></ternary></expr>;</expr_stmt>
	<return>return <expr><name>keep_ptr</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * POLAR: Remove the flashback log and logindex after the flashback log record pointer.
 *
 * NB: Must keep the flashback log for flashback logindex.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>polar_remove_flog_data</name><parameter_list>(<parameter><decl><type><name>flog_ctl_t</name></type> <name>instance</name></decl></parameter>, <parameter><decl><type><name>polar_flog_rec_ptr</name></type> <name>ptr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>polar_flog_rec_ptr</name></type> <name>keep_ptr</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>keep_ptr</name> <operator>=</operator> <call><name>cal_min_keep_flog_ptr</name><argument_list>(<argument><expr><name><name>instance</name><operator>-&gt;</operator><name>logindex_snapshot</name></name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>polar_logindex_truncate</name><argument_list>(<argument><expr><name><name>instance</name><operator>-&gt;</operator><name>logindex_snapshot</name></name></expr></argument>, <argument><expr><name>keep_ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>polar_truncate_flog_before</name><argument_list>(<argument><expr><name><name>instance</name><operator>-&gt;</operator><name>buf_ctl</name></name></expr></argument>, <argument><expr><name>keep_ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * POLAR: Flush all the flashback data and update control file.
 *
 * NB: The flashback log must have been flushed before flush the buffer, so we don't
 * need to flush the flashback log in this function. If need flush all the flashback
 * log, we can call polar_flashback_log_flush.
 *
 * We don't need a precise value of flashback log point after checkpoint, but
 * a little larger value. When the database in crash recovery mode, ignore the error
 * flashback log after the value.
 * And we can't find the previous point of the checkpoint end point, but it is
 * fine and can be updated in the shutdown checkpoint.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>polar_flush_flog_data</name><parameter_list>(<parameter><decl><type><name>flog_buf_ctl_t</name></type> <name>ctl</name></decl></parameter>, <parameter><decl><type><name>polar_flog_rec_ptr</name></type> <name>ckp_start</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>shutdown</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>polar_flog_rec_ptr</name></type> <name>ckp_end</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>polar_flog_rec_ptr</name></type> <name>ckp_end_prev</name> <init>= <expr><name>POLAR_INVALID_FLOG_REC_PTR</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>shutdown</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>ckp_end</name> <operator>=</operator>
			<call><name>polar_get_curr_flog_ptr</name><argument_list>(<argument><expr><name>ctl</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ckp_end_prev</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/*
		 * Flush all the flashback log.
		 *
		 * NB: In the RW, this work has been done in buffer flushed to disk
		 * while the buffer isn't always flushed in shutdown restartpoint of standby.
		 */</comment>
		<expr_stmt><expr><call><name>polar_flog_flush</name><argument_list>(<argument><expr><name>ctl</name></expr></argument>, <argument><expr><name>ckp_end</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>polar_set_flog_buf_state</name><argument_list>(<argument><expr><name>ctl</name></expr></argument>, <argument><expr><name>FLOG_BUF_SHUTDOWNED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>ckp_end</name> <operator>=</operator> <call><name>polar_get_flog_write_result</name><argument_list>(<argument><expr><name>ctl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>polar_flashback_log_debug</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"The point of flashback log in the checkpoint end is %X/%X"</literal></expr></argument>,
				<argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <operator>(</operator><name>ckp_end</name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr></argument>, <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <name>ckp_end</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>FLOG_REC_PTR_IS_INVAILD</name><argument_list>(<argument><expr><name>ckp_end</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>polar_flush_fbpoint_info</name><argument_list>(<argument><expr><name>ctl</name></expr></argument>, <argument><expr><name>ckp_start</name></expr></argument>,
								  <argument><expr><name>ckp_end</name></expr></argument>, <argument><expr><name>ckp_end_prev</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>set_buf_flog_state</name><parameter_list>(<parameter><decl><type><name>BufferDesc</name> <modifier>*</modifier></type><name>buf_desc</name></decl></parameter>, <parameter><decl><type><name>uint32</name></type> <name>flog_state</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>uint32</name></type> <name>state</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>state</name> <operator>=</operator> <call><name>polar_lock_redo_state</name><argument_list>(<argument><expr><name>buf_desc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>state</name> <operator>|=</operator> <name>flog_state</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>polar_unlock_redo_state</name><argument_list>(<argument><expr><name>buf_desc</name></expr></argument>, <argument><expr><name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>clean_buf_flog_state</name><parameter_list>(<parameter><decl><type><name>BufferDesc</name> <modifier>*</modifier></type><name>buf_hdr</name></decl></parameter>, <parameter><decl><type><name>uint32</name></type> <name>flog_state</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>uint32</name></type> <name>state</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>state</name> <operator>=</operator> <call><name>polar_lock_redo_state</name><argument_list>(<argument><expr><name>buf_hdr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>state</name> <operator>&amp;=</operator> <operator>~</operator><operator>(</operator><name>flog_state</name><operator>)</operator></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>polar_unlock_redo_state</name><argument_list>(<argument><expr><name>buf_hdr</name></expr></argument>, <argument><expr><name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>bool</name></type>
<name>polar_is_flog_mem_enabled</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><name>polar_enable_flashback_log</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>polar_is_datamax</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>IsBootstrapProcessingMode</name><argument_list>()</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * POLAR: Is the flashback log enabled?
 */</comment>
<function><type><name>bool</name></type>
<name>polar_is_flog_enabled</name><parameter_list>(<parameter><decl><type><name>flog_ctl_t</name></type> <name>instance</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><name>instance</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>polar_in_replica_mode</name><argument_list>()</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>bool</name></type>
<name>polar_is_flog_ready</name><parameter_list>(<parameter><decl><type><name>flog_ctl_t</name></type> <name>instance</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>pg_read_barrier</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name><name>instance</name><operator>-&gt;</operator><name>state</name></name> <operator>==</operator> <name>FLOG_READY</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * POLAR: Is the flashback log startup?
 *
 * The state will larger than FLOG_INIT after call polar_startup_flog.
 * The startup action contain:
 * 1. read the control file and fill the flashback log buf_ctl info.
 * 2. call polar_logindex_snapshot_init to do logindex snapshot init.
 */</comment>
<function><type><name>bool</name></type>
<name>polar_has_flog_startup</name><parameter_list>(<parameter><decl><type><name>flog_ctl_t</name></type> <name>instance</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>pg_read_barrier</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name><name>instance</name><operator>-&gt;</operator><name>state</name></name> <operator>&gt;</operator> <name>FLOG_INIT</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * POLAR: Get the flashback log relative memory internal function.
 */</comment>
<function><type><name>Size</name></type>
<name>polar_flog_shmem_size_internal</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>insert_locks_num</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>log_buffers</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>logindex_mem_size</name></decl></parameter>,
							   <parameter><decl><type><name>int</name></type> <name>logindex_bloom_blocks</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>queue_buffers_MB</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Size</name></type> <name>size</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>size</name> <operator>=</operator> <call><name>add_size</name><argument_list>(<argument><expr><name>size</name></expr></argument>, <argument><expr><call><name>flog_ctl_size</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>size</name> <operator>=</operator> <call><name>add_size</name><argument_list>(<argument><expr><name>size</name></expr></argument>, <argument><expr><call><name>polar_flog_buf_size</name><argument_list>(<argument><expr><name>insert_locks_num</name></expr></argument>, <argument><expr><name>log_buffers</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>size</name> <operator>=</operator> <call><name>add_size</name><argument_list>(<argument><expr><name>size</name></expr></argument>, <argument><expr><call><name>polar_flog_index_shmem_size</name><argument_list>(<argument><expr><name>logindex_mem_size</name></expr></argument>, <argument><expr><name>logindex_bloom_blocks</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>size</name> <operator>=</operator> <call><name>add_size</name><argument_list>(<argument><expr><name>size</name></expr></argument>, <argument><expr><call><name>polar_flog_index_queue_shmem_size</name><argument_list>(<argument><expr><name>queue_buffers_MB</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>size</name> <operator>=</operator> <call><name>add_size</name><argument_list>(<argument><expr><name>size</name></expr></argument>, <argument><expr><call><name>polar_flog_async_list_shmem_size</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>size</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * POLAR: Get the flashback log relative memory.
 */</comment>
<function><type><name>Size</name></type>
<name>polar_flog_shmem_size</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Size</name></type> <name>size</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>polar_enable_flashback_log</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*no cover begin*/</comment>
		<if_stmt><if>if <condition>(<expr><name>polar_flashback_logindex_mem_size</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>, <argument><expr><literal type="string">"Cannot enable flashback log when \"polar_flashback_logindex_mem_size\" is zero."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>polar_logindex_mem_size</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>, <argument><expr><literal type="string">"Cannot enable flashback log when \"polar_logindex_mem_size\" is zero."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/*no cover end*/</comment>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<return>return <expr><name>size</name></expr>;</return></block_content></block></else></if_stmt>

	<return>return <expr><call><name>polar_flog_shmem_size_internal</name><argument_list>(<argument><expr><name>polar_flashback_log_insert_locks</name></expr></argument>,
										  <argument><expr><name>polar_flashback_log_buffers</name></expr></argument>, <argument><expr><name>polar_flashback_logindex_mem_size</name></expr></argument>,
										  <argument><expr><name>polar_flashback_logindex_bloom_blocks</name></expr></argument>, <argument><expr><name>polar_flashback_logindex_queue_buffers</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * POLAR: Initialization of shared memory for flashback log internal function
 */</comment>
<function><type><name>flog_ctl_t</name></type>
<name>polar_flog_shmem_init_internal</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>insert_locks_num</name></decl></parameter>,
							   <parameter><decl><type><name>int</name></type> <name>log_buffers</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>logindex_mem_size</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>logindex_bloom_blocks</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>queue_buffers_MB</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>flog_ctl_t</name></type> <name>ctl</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>ctl</name> <operator>=</operator> <call><name>polar_flog_ctl_init</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ctl</name><operator>-&gt;</operator><name>list_ctl</name></name> <operator>=</operator> <call><name>polar_flog_async_list_init</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ctl</name><operator>-&gt;</operator><name>buf_ctl</name></name> <operator>=</operator> <call><name>polar_flog_buf_init</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>insert_locks_num</name></expr></argument>, <argument><expr><name>log_buffers</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ctl</name><operator>-&gt;</operator><name>logindex_snapshot</name></name> <operator>=</operator> <call><name>polar_flog_index_shmem_init</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>logindex_mem_size</name></expr></argument>,
														 <argument><expr><name>logindex_bloom_blocks</name></expr></argument>, <argument><expr><name><name>ctl</name><operator>-&gt;</operator><name>buf_ctl</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ctl</name><operator>-&gt;</operator><name>queue_ctl</name></name> <operator>=</operator> <call><name>polar_flog_index_queue_shmem_init</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>queue_buffers_MB</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>ctl</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>polar_flog_shmem_init</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><call><name>polar_is_flog_mem_enabled</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>flog_instance</name> <operator>=</operator> <call><name>polar_flog_shmem_init_internal</name><argument_list>(<argument><expr><name>POLAR_FL_DEFAULT_DIR</name></expr></argument>,
													   <argument><expr><name>polar_flashback_log_insert_locks</name></expr></argument>, <argument><expr><name>polar_flashback_log_buffers</name></expr></argument>,
													   <argument><expr><name>polar_flashback_logindex_mem_size</name></expr></argument>, <argument><expr><name>polar_flashback_logindex_bloom_blocks</name></expr></argument>,
													   <argument><expr><name>polar_flashback_logindex_queue_buffers</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * POLAR: Do something after the flashback point is done.
 *
 * 1. Flush the flashback log.
 * 2. remove the old flashback log.
 */</comment>
<function><type><name>void</name></type>
<name>polar_flog_do_fbpoint</name><parameter_list>(<parameter><decl><type><name>flog_ctl_t</name></type> <name>instance</name></decl></parameter>, <parameter><decl><type><name>polar_flog_rec_ptr</name></type> <name>ckp_start</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>shutdown</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>flog_buf_ctl_t</name></type> <name>buf_ctl</name> <init>= <expr><name><name>instance</name><operator>-&gt;</operator><name>buf_ctl</name></name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>polar_flush_flog_data</name><argument_list>(<argument><expr><name>buf_ctl</name></expr></argument>, <argument><expr><name>ckp_start</name></expr></argument>, <argument><expr><name>shutdown</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>polar_remove_flog_data</name><argument_list>(<argument><expr><name>instance</name></expr></argument>, <argument><expr><name>ckp_start</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * POLAR: Is the buffer flashback log enabled?
 *
 * Now we will disable the flashback log for the buffer while repair its
 * partial problem or flashback it.
 */</comment>
<function><type><name>bool</name></type>
<name>polar_is_buf_flog_enabled</name><parameter_list>(<parameter><decl><type><name>flog_ctl_t</name></type> <name>instance</name></decl></parameter>, <parameter><decl><type><name>Buffer</name></type> <name>buf</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>BufferDesc</name> <modifier>*</modifier></type><name>buf_hdr</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>buf_hdr</name> <operator>=</operator> <call><name>GetBufferDescriptor</name><argument_list>(<argument><expr><name>buf</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><call><name>polar_is_flog_enabled</name><argument_list>(<argument><expr><name>flog_instance</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
			<operator>!</operator><call><name>polar_check_buf_flog_state</name><argument_list>(<argument><expr><name>buf_hdr</name></expr></argument>, <argument><expr><name>POLAR_BUF_FLOG_DISABLE</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * POLAR: Is the page need a flashback log.
 *
 * instance: flog_instance.
 * forkno: The forkno of the page, now just MAIN_FORKNUM fork need a flashback log.
 * page: The page
 * is_premanent: is a permanent page?
 * fbpoint_lsn: The WAL redo point of the flashback point, just vaild in insertxlog.
 * redo_lsn: The end+1 to replay, use it in the standby recovery mode or ro online promote.
 */</comment>
<function><type><name>bool</name></type>
<name>polar_is_flog_needed</name><parameter_list>(<parameter><decl><type><name>flog_ctl_t</name></type> <name>flog_ins</name></decl></parameter>, <parameter><decl><type><name>polar_logindex_redo_ctl_t</name></type> <name>redo_ins</name></decl></parameter>,
		<parameter><decl><type><name>ForkNumber</name></type> <name>forkno</name></decl></parameter>, <parameter><decl><type><name>Page</name></type> <name>page</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>is_permanent</name></decl></parameter>,
		<parameter><decl><type><name>XLogRecPtr</name></type> <name>fbpoint_lsn</name></decl></parameter>, <parameter><decl><type><name>XLogRecPtr</name></type> <name>redo_lsn</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>flog_ins</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>is_need_flog</name><argument_list>(<argument><expr><name>forkno</name></expr></argument>)</argument_list></call> <operator>||</operator> <operator>!</operator><name>is_permanent</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>redo_lsn</name> <operator>!=</operator> <name>InvalidXLogRecPtr</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>fbpoint_lsn</name> <operator>==</operator> <name>InvalidXLogRecPtr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>fbpoint_lsn</name> <operator>=</operator> <call><name>polar_get_curr_fbpoint_lsn</name><argument_list>(<argument><expr><name><name>flog_ins</name><operator>-&gt;</operator><name>buf_ctl</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>POLAR_IN_PARALLEL_REPLAY_STANDBY_MODE</name><argument_list>(<argument><expr><name>redo_ins</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>redo_lsn</name> <operator>&lt;=</operator> <name>fbpoint_lsn</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>fbpoint_lsn</name> <operator>=</operator> <call><name>polar_get_prior_fbpoint_lsn</name><argument_list>(<argument><expr><name><name>flog_ins</name><operator>-&gt;</operator><name>buf_ctl</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>redo_lsn</name> <operator>&lt;=</operator> <name>fbpoint_lsn</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return  <expr><call><name>polar_is_page_first_modified</name><argument_list>(<argument><expr><name><name>flog_ins</name><operator>-&gt;</operator><name>buf_ctl</name></name></expr></argument>, <argument><expr><call><name>PageGetLSN</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>fbpoint_lsn</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * POLAR: Insert into flashback log.
 *
 * buf:         The buffer id.
 * is_candidate:Is a candidate or not?
 * is_recovery:	Is in recovery.
 *
 * NB: Now we can get the origin page in memory in the recovery mode, so just insert it
 * to flashback log shared buffer to avoid to read from disk which may cause more time to
 * recovery. In the product mode, just insert into the flashback log async list.
 */</comment>
<function><type><name>void</name></type>
<name>polar_flog_insert</name><parameter_list>(<parameter><decl><type><name>flog_ctl_t</name></type> <name>instance</name></decl></parameter>, <parameter><decl><type><name>Buffer</name></type> <name>buf</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>is_candidate</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>is_recovery</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>BufferIsValid</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Add the buffer to origin buffer in the recovery mode */</comment>
	<if_stmt><if>if <condition>(<expr><name>is_recovery</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>BufferDesc</name> <modifier>*</modifier></type><name>buf_desc</name> <init>= <expr><call><name>GetBufferDescriptor</name><argument_list>(<argument><expr><name>buf</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>polar_add_origin_buf</name><argument_list>(<argument><expr><name><name>instance</name><operator>-&gt;</operator><name>list_ctl</name></name></expr></argument>, <argument><expr><name>buf_desc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>polar_push_buf_to_flog_list</name><argument_list>(<argument><expr><name><name>instance</name><operator>-&gt;</operator><name>list_ctl</name></name></expr></argument>, <argument><expr><name><name>instance</name><operator>-&gt;</operator><name>buf_ctl</name></name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>is_candidate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * POLAR: Check the origin page before the page with a full page image wal record
 * is a empty page.
 *
 * NB: When the page is registered by log_newpage, the origin page before it must be a empty page.
 */</comment>
<function><type><name>void</name></type>
<name>polar_check_fpi_origin_page</name><parameter_list>(<parameter><decl><type><name>RelFileNode</name></type> <name>rnode</name></decl></parameter>, <parameter><decl><type><name>ForkNumber</name></type> <name>forkno</name></decl></parameter>, <parameter><decl><type><name>BlockNumber</name></type> <name>block</name></decl></parameter>, <parameter><decl><type><name>uint8</name></type> <name>xl_info</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>BufferTag</name></type> <name>tag</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PGAlignedBlock</name></type>  <name>page_tmp</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>xl_info</name> <operator>!=</operator> <name>XLOG_FPI_FOR_HINT</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>INIT_BUFFERTAG</name><argument_list>(<argument><expr><name>tag</name></expr></argument>, <argument><expr><name>rnode</name></expr></argument>, <argument><expr><name>forkno</name></expr></argument>, <argument><expr><name>block</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>read_origin_page_from_file</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tag</name></expr></argument>, <argument><expr><name><name>page_tmp</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>PageIsNew</name><argument_list>(<argument><expr><name><name>page_tmp</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>polar_page_is_just_inited</name><argument_list>(<argument><expr><name><name>page_tmp</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<comment type="block">/*no cover line*/</comment>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>PANIC</name></expr></argument>, <argument><expr><literal type="string">"The page [%u, %u, %u], %d, %u has a full page image wal record, "</literal>
					<literal type="string">"but its origin page is not a empty page"</literal></expr></argument>, <argument><expr><name><name>rnode</name><operator>.</operator><name>spcNode</name></name></expr></argument>, <argument><expr><name><name>rnode</name><operator>.</operator><name>dbNode</name></name></expr></argument>, <argument><expr><name><name>rnode</name><operator>.</operator><name>relNode</name></name></expr></argument>,
					<argument><expr><name>forkno</name></expr></argument>, <argument><expr><name>block</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * POLAR: Flush the flashback log record of the buffer.
 *
 * is_invalidate: Is the buffer invalidate?
 *
 * When we drop the relation or database, the buffer is invalidate and its flashback log is
 * unnecessary.
 */</comment>
<function><type><name>void</name></type>
<name>polar_flush_buf_flog_rec</name><parameter_list>(<parameter><decl><type><name>BufferDesc</name> <modifier>*</modifier></type><name>buf_hdr</name></decl></parameter>, <parameter><decl><type><name>flog_ctl_t</name></type> <name>instance</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>is_invalidate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>polar_is_flog_enabled</name><argument_list>(<argument><expr><name>instance</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>polar_insert_buf_flog_rec_sync</name><argument_list>(<argument><expr><name><name>instance</name><operator>-&gt;</operator><name>list_ctl</name></name></expr></argument>, <argument><expr><name><name>instance</name><operator>-&gt;</operator><name>buf_ctl</name></name></expr></argument>,
			<argument><expr><name><name>instance</name><operator>-&gt;</operator><name>queue_ctl</name></name></expr></argument>, <argument><expr><name>buf_hdr</name></expr></argument>, <argument><expr><name>is_invalidate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>polar_flush_buf_flog</name><argument_list>(<argument><expr><name><name>instance</name><operator>-&gt;</operator><name>list_ctl</name></name></expr></argument>, <argument><expr><name><name>instance</name><operator>-&gt;</operator><name>buf_ctl</name></name></expr></argument>, <argument><expr><name>buf_hdr</name></expr></argument>, <argument><expr><name>is_invalidate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * POLAR: startup all about flashback log.
 *
 * state: the database state.
 * instance: the flashback log instance.
 *
 * NB: It just fill some control info. The flashback log
 * buffer recovery and logindex recovery will be
 * done by the flashback log background writer.
 */</comment>
<function><type><name>void</name></type>
<name>polar_startup_flog</name><parameter_list>(<parameter><decl><type><name>CheckPoint</name> <modifier>*</modifier></type><name>checkpoint</name></decl></parameter>, <parameter><decl><type><name>flog_ctl_t</name></type> <name>instance</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>IsUnderPostmaster</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/* Remove all when flashback log is unenable */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>flog_data_need_remove_all</name><argument_list>()</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>flog_data_remove_all</name><argument_list>(<argument><expr><name>instance</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Validate directory and startup the flashback log and flashback logindex in the rw and standby */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>polar_is_flog_enabled</name><argument_list>(<argument><expr><name>instance</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>logindex_snapshot_t</name></type> <name>snapshot</name> <init>= <expr><name><name>instance</name><operator>-&gt;</operator><name>logindex_snapshot</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>flog_buf_ctl_t</name></type> <name>buf_ctl</name> <init>= <expr><name><name>instance</name><operator>-&gt;</operator><name>buf_ctl</name></name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>instance</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>polar_validate_flog_dir</name><argument_list>(<argument><expr><name>buf_ctl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>polar_validate_flog_index_dir</name><argument_list>(<argument><expr><name>snapshot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Remove all the temporary flashback log files */</comment>
		<expr_stmt><expr><call><name>polar_remove_tmp_flog_file</name><argument_list>(<argument><expr><name><name>buf_ctl</name><operator>-&gt;</operator><name>dir</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>polar_startup_flog_buf</name><argument_list>(<argument><expr><name>buf_ctl</name></expr></argument>, <argument><expr><name>checkpoint</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>polar_startup_flog_index</name><argument_list>(<argument><expr><name>snapshot</name></expr></argument>,
								 <argument><expr><call><name>VALID_FLOG_PTR</name><argument_list>(<argument><expr><call><name>polar_get_fbpoint_start_ptr</name><argument_list>(<argument><expr><name>buf_ctl</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>buf_ctl</name><operator>-&gt;</operator><name>buf_state</name></name> <operator>==</operator> <name>FLOG_BUF_READY</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>polar_set_flog_state</name><argument_list>(<argument><expr><name>instance</name></expr></argument>, <argument><expr><name>FLOG_READY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/*
			 * Recover the flashback log buffer, so we can insert flashback log
			 * in the startup process without wait.
			 */</comment>
			<expr_stmt><expr><call><name>polar_recover_flog_buf</name><argument_list>(<argument><expr><name>instance</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>polar_set_flog_state</name><argument_list>(<argument><expr><name>instance</name></expr></argument>, <argument><expr><name>FLOG_STARTUP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * POLAR: Recover the flashback log.
 *
 * Set the flashback log record write result and initalize_upto,
 * insert-&gt;curr_pos.
 *
 * We don't care about the flashback logindex here.
 */</comment>
<function><type><name>void</name></type>
<name>polar_recover_flog_buf</name><parameter_list>(<parameter><decl><type><name>flog_ctl_t</name></type> <name>instance</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>flog_buf_ctl_t</name></type>  <name>buf_ctl</name> <init>= <expr><name><name>instance</name><operator>-&gt;</operator><name>buf_ctl</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>flog_ctl_insert</name> <modifier>*</modifier></type><name>insert</name> <init>= <expr><operator>&amp;</operator><name><name>buf_ctl</name><operator>-&gt;</operator><name>insert</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>polar_flog_rec_ptr</name></type> <name>ckp_end_ptr</name> <init>= <expr><name>POLAR_INVALID_FLOG_REC_PTR</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>polar_flog_rec_ptr</name></type> <name>ptr</name> <init>= <expr><name>POLAR_INVALID_FLOG_REC_PTR</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>polar_flog_rec_ptr</name></type> <name>prev_ptr</name> <init>= <expr><name>POLAR_INVALID_FLOG_REC_PTR</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>polar_flog_rec_ptr</name></type> <name>pos</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>polar_flog_rec_ptr</name></type> <name>prev_pos</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>polar_flog_rec_ptr</name></type> <name>block_end_ptr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint64</name></type>    <name>seg_no</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>flog_buf_state</name></type> <name>state</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>buf_ctl</name><operator>-&gt;</operator><name>ctl_file_lock</name></name></expr></argument>, <argument><expr><name>LW_SHARED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>ckp_end_ptr</name> <operator>=</operator> <name><name>buf_ctl</name><operator>-&gt;</operator><name>fbpoint_info</name><operator>.</operator><name>flog_end_ptr</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>prev_ptr</name> <operator>=</operator> <name><name>buf_ctl</name><operator>-&gt;</operator><name>fbpoint_info</name><operator>.</operator><name>flog_end_ptr_prev</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>seg_no</name> <operator>=</operator> <name><name>buf_ctl</name><operator>-&gt;</operator><name>max_seg_no</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>buf_ctl</name><operator>-&gt;</operator><name>ctl_file_lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>prev_ptr</name> <operator>&lt;=</operator> <name>ckp_end_ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* If there is no flashback log record, just return */</comment>
	<if_stmt><if>if <condition>(<expr><name>seg_no</name> <operator>==</operator> <name>POLAR_INVALID_FLOG_SEGNO</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>polar_set_flog_buf_state</name><argument_list>(<argument><expr><name>buf_ctl</name></expr></argument>, <argument><expr><name>FLOG_BUF_READY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>polar_set_flog_state</name><argument_list>(<argument><expr><name>instance</name></expr></argument>, <argument><expr><name>FLOG_READY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"There is no flashback log data, so just skip the recovery of"</literal>
			 <literal type="string">" the flashback log and logindex"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>state</name> <operator>=</operator> <call><name>polar_get_flog_buf_state</name><argument_list>(<argument><expr><name>buf_ctl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>polar_log_flog_buf_state</name><argument_list>(<argument><expr><name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Note the previous pointer is not correct. Its expected value
	 * is start of a valid flashback log record, but it is a value bigger
	 * than ckp_end_ptr. It is nothing serious, we just process this case
	 * in the reader function.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>state</name> <operator>==</operator> <name>FLOG_BUF_SHUTDOWN_RECOVERY</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>ptr</name> <operator>=</operator> <name>ckp_end_ptr</name></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><name>state</name> <operator>==</operator> <name>FLOG_BUF_CRASH_RECOVERY</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>ptr</name> <operator>=</operator> <operator>(</operator><name>seg_no</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>*</operator> <name>POLAR_FLOG_SEG_SIZE</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>prev_ptr</name> <operator>=</operator> <name>POLAR_INVALID_FLOG_REC_PTR</name></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>ptr</name> <operator>%</operator> <name>POLAR_FLOG_BLCKSZ</name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Write the history and control file */</comment>
		<if_stmt><if>if <condition>(<expr><name>ptr</name> <operator>!=</operator> <name>ckp_end_ptr</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * Must be inside CRIT_SECTION.
			 * The shared memory has been updated already, so we must
			 * write the file successfully.
			 */</comment>
			<expr_stmt><expr><call><name>START_CRIT_SECTION</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>polar_write_flog_history_file</name><argument_list>(<argument><expr><name><name>buf_ctl</name><operator>-&gt;</operator><name>dir</name></name></expr></argument>, <argument><expr><name><name>buf_ctl</name><operator>-&gt;</operator><name>tli</name></name></expr></argument>, <argument><expr><name>ckp_end_ptr</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* Change the flashback log control checkpoint info and write file */</comment>
			<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>buf_ctl</name><operator>-&gt;</operator><name>ctl_file_lock</name></name></expr></argument>, <argument><expr><name>LW_SHARED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>buf_ctl</name><operator>-&gt;</operator><name>fbpoint_info</name><operator>.</operator><name>flog_end_ptr</name></name> <operator>=</operator> <name>ptr</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>buf_ctl</name><operator>-&gt;</operator><name>fbpoint_info</name><operator>.</operator><name>flog_end_ptr_prev</name></name> <operator>=</operator> <name>prev_ptr</name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>buf_ctl</name><operator>-&gt;</operator><name>ctl_file_lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>END_CRIT_SECTION</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"The flashback log will switch from %X/%X to %X/%X"</literal></expr></argument>,
				 <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator><operator>(</operator><name>ckp_end_ptr</name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr></argument>, <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator><name>ckp_end_ptr</name></expr></argument>,
				 <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator><operator>(</operator><name>ptr</name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr></argument>, <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator><name>ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<comment type="block">/*no cover line*/</comment>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>PANIC</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INTERNAL_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"The invalid flashback log buffer recovery state: %u"</literal></expr></argument>, <argument><expr><name>state</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/* Write control file, update the flashback state area */</comment>
	<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>buf_ctl</name><operator>-&gt;</operator><name>ctl_file_lock</name></name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>polar_write_flog_ctl_file</name><argument_list>(<argument><expr><name>buf_ctl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>buf_ctl</name><operator>-&gt;</operator><name>ctl_file_lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * When the buffer is in shutdown recovery mode, copy the
	 * last block to the buffer.
	 *
	 * NB: When it is in crash recovery mode, the ptr % POLAR_FLASHBACK_LOG_BLCKSZ
	 * must be zero.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>ptr</name> <operator>%</operator> <name>POLAR_FLOG_BLCKSZ</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>page</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>         <name>len</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>         <name>first_idx</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>polar_flog_rec_ptr</name></type>  <name>page_begin_ptr</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>page_begin_ptr</name> <operator>=</operator> <name>ptr</name> <operator>-</operator> <operator>(</operator><name>ptr</name> <operator>%</operator> <name>POLAR_FLOG_BLCKSZ</name><operator>)</operator></expr>;</expr_stmt>
		<expr_stmt><expr><name>first_idx</name> <operator>=</operator> <call><name>FLOG_PTR2BUF_IDX</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>buf_ctl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Copy the valid part of the last block, and zero the rest */</comment>
		<expr_stmt><expr><name>page</name> <operator>=</operator> <operator>&amp;</operator><name><name>buf_ctl</name><operator>-&gt;</operator><name>pages</name><index>[<expr><name>first_idx</name> <operator>*</operator> <name>POLAR_FLOG_BLCKSZ</name></expr>]</index></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>len</name> <operator>=</operator> <name>ptr</name> <operator>%</operator> <name>POLAR_FLOG_BLCKSZ</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>polar_flog_read</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>POLAR_FLOG_SEG_SIZE</name></expr></argument>, <argument><expr><name>page_begin_ptr</name></expr></argument>,
						<argument><expr><name>POLAR_FLOG_BLCKSZ</name></expr></argument>, <argument><expr><name><name>buf_ctl</name><operator>-&gt;</operator><name>dir</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><name>page</name> <operator>+</operator> <name>len</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>POLAR_FLOG_BLCKSZ</name> <operator>-</operator> <name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>block_end_ptr</name> <operator>=</operator> <name>page_begin_ptr</name> <operator>+</operator> <name>POLAR_FLOG_BLCKSZ</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>buf_ctl</name><operator>-&gt;</operator><name>blocks</name><index>[<expr><name>first_idx</name></expr>]</index></name> <operator>=</operator> <name>block_end_ptr</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>block_end_ptr</name> <operator>=</operator> <name>ptr</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<expr_stmt><expr><name>pos</name> <operator>=</operator> <call><name>polar_flog_ptr2pos</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/*
	 * The prev_pos may be not right after crash recovery. So we ignore the
	 * check in some cases.
	 */</comment>
	<expr_stmt><expr><name>prev_pos</name> <operator>=</operator> <call><name>polar_flog_ptr2pos</name><argument_list>(<argument><expr><name>prev_ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>SpinLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>buf_ctl</name><operator>-&gt;</operator><name>info_lck</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>buf_ctl</name><operator>-&gt;</operator><name>write_result</name></name> <operator>=</operator> <name>ptr</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>buf_ctl</name><operator>-&gt;</operator><name>initalized_upto</name></name> <operator>=</operator> <name>block_end_ptr</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>buf_ctl</name><operator>-&gt;</operator><name>write_request</name></name> <operator>=</operator> <name>ptr</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SpinLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>buf_ctl</name><operator>-&gt;</operator><name>info_lck</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>SpinLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>insert</name><operator>-&gt;</operator><name>insertpos_lck</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>insert</name><operator>-&gt;</operator><name>curr_pos</name></name> <operator>=</operator> <name>pos</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>insert</name><operator>-&gt;</operator><name>prev_pos</name></name> <operator>=</operator> <name>prev_pos</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SpinLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>insert</name><operator>-&gt;</operator><name>insertpos_lck</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>polar_set_flog_buf_state</name><argument_list>(<argument><expr><name>buf_ctl</name></expr></argument>, <argument><expr><name>FLOG_BUF_READY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>polar_set_flog_min_recover_lsn</name><argument_list>(<argument><expr><name>buf_ctl</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"The flashback log shared buffer is ready now, the current point(position)"</literal>
				 <literal type="string">" is %X/%X(%X/%X), previous point(position) is %X/%X(%X/%X), initalized upto point is"</literal>
				 <literal type="string">" %X/%X"</literal></expr></argument>, <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator><operator>(</operator><name>ptr</name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr></argument>, <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator><operator>(</operator><name>ptr</name><operator>)</operator></expr></argument>, <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator><operator>(</operator><name>pos</name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr></argument>, <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator><operator>(</operator><name>pos</name><operator>)</operator></expr></argument>,
				 <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator><operator>(</operator><name>prev_ptr</name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr></argument>, <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator><operator>(</operator><name>prev_ptr</name><operator>)</operator></expr></argument>,
				 <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator><operator>(</operator><name>prev_pos</name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr></argument>, <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator><operator>(</operator><name>prev_pos</name><operator>)</operator></expr></argument>,
				 <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator><operator>(</operator><name>block_end_ptr</name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr></argument>, <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator><operator>(</operator><name>block_end_ptr</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>polar_flog_pos2endptr</name><argument_list>(<argument><expr><name>pos</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>ptr</name> <operator>||</operator>
		   <call><name>polar_flog_pos2ptr</name><argument_list>(<argument><expr><name>pos</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>polar_flog_pos2endptr</name><argument_list>(<argument><expr><name>prev_pos</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>prev_ptr</name> <operator>||</operator>
		   <call><name>polar_flog_pos2ptr</name><argument_list>(<argument><expr><name>prev_pos</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>prev_ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * POLAR: Set the buffer has been flashback log lost checked.
 */</comment>
<function><type><name>void</name></type>
<name>polar_set_buf_flog_lost_checked</name><parameter_list>(<parameter><decl><type><name>flog_ctl_t</name></type> <name>flog_ins</name></decl></parameter>,
		<parameter><decl><type><name>polar_logindex_redo_ctl_t</name></type> <name>redo_ins</name></decl></parameter>, <parameter><decl><type><name>Buffer</name></type> <name>buffer</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>BufferDesc</name> <modifier>*</modifier></type><name>buf_desc</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>buf_desc</name> <operator>=</operator> <call><name>GetBufferDescriptor</name><argument_list>(<argument><expr><name>buffer</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>polar_is_flog_enabled</name><argument_list>(<argument><expr><name>flog_ins</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
			<call><name>polar_get_bg_redo_state</name><argument_list>(<argument><expr><name>redo_ins</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>POLAR_BG_ONLINE_PROMOTE</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>set_buf_flog_state</name><argument_list>(<argument><expr><name>buf_desc</name></expr></argument>, <argument><expr><name>POLAR_BUF_FLOG_LOST_CHECKED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * POLAR: Mark the buffer lost some flashback log records in the online promote.
 *
 * We can't protect the flashback log to lose nothing in the rw crash,
 * so we must do something to recheck in the online promote.
 * Because the flashback log flush to disk before the page, so the buffer whose
 * page lsn is larger than max page lsn in the disk may lose some flashback log.
 * We think the max page lsn in the disk is the max value of current flashback point lsn
 * and primary consist lsn. The pages whose lsn less than the value must have been
 * flushed to disk already.
 */</comment>
<function><type><name>bool</name></type>
<name>polar_may_buf_lost_flog</name><parameter_list>(<parameter><decl><type><name>flog_ctl_t</name></type> <name>flog_ins</name></decl></parameter>, <parameter><decl><type><name>polar_logindex_redo_ctl_t</name></type> <name>redo_instance</name></decl></parameter>,
		<parameter><decl><type><name>BufferDesc</name> <modifier>*</modifier></type><name>buf_desc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>static</specifier> <name>XLogRecPtr</name></type> <name>max_page_lsn_in_disk</name> <init>= <expr><name>InvalidXLogRecPtr</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>static</specifier> <name>XLogRecPtr</name></type> <name>replay_end_lsn</name> <init>= <expr><name>InvalidXLogRecPtr</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>XLogRecPtr</name></type> <name>page_lsn</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>polar_is_flog_enabled</name><argument_list>(<argument><expr><name>flog_ins</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* Only used by online promote */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>polar_get_bg_redo_state</name><argument_list>(<argument><expr><name>redo_instance</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>POLAR_BG_ONLINE_PROMOTE</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* The buffer have been checked already */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>polar_check_buf_flog_state</name><argument_list>(<argument><expr><name>buf_desc</name></expr></argument>, <argument><expr><name>POLAR_BUF_FLOG_LOST_CHECKED</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>page_lsn</name> <operator>=</operator> <call><name>BufferGetLSN</name><argument_list>(<argument><expr><name>buf_desc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* The max page lsn in the disk is fixed in the online promote */</comment>
	<if_stmt><if>if <condition>(<expr><name>max_page_lsn_in_disk</name> <operator>==</operator> <name>InvalidXLogRecPtr</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>max_page_lsn_in_disk</name> <operator>=</operator> <call><name>Max</name><argument_list>(<argument><expr><call><name>polar_get_local_fbpoint_lsn</name><argument_list>(<argument><expr><name><name>flog_ins</name><operator>-&gt;</operator><name>buf_ctl</name></name></expr></argument>,
				<argument><expr><name>InvalidXLogRecPtr</name></expr></argument>, <argument><expr><name>InvalidXLogRecPtr</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>polar_get_primary_consist_ptr</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>replay_end_lsn</name> <operator>==</operator> <name>InvalidXLogRecPtr</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>replay_end_lsn</name> <operator>=</operator> <call><name>GetXLogReplayRecPtr</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Note this: the page whose lsn is equal to consist_ptr may be not flushed.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>page_lsn</name> <operator>&lt;</operator> <name>max_page_lsn_in_disk</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><name>page_lsn</name> <operator>&lt;=</operator> <name>replay_end_lsn</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>set_buf_flog_state</name><argument_list>(<argument><expr><name>buf_desc</name></expr></argument>, <argument><expr><name>POLAR_BUF_FLOG_LOST_CHECKED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * The flashback log must be flushed before the buffer evicted.
 */</comment>
<function><type><name>void</name></type>
<name>polar_make_true_no_flog</name><parameter_list>(<parameter><decl><type><name>flog_ctl_t</name></type> <name>instance</name></decl></parameter>, <parameter><decl><type><name>BufferDesc</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>polar_is_flog_enabled</name><argument_list>(<argument><expr><name>instance</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>is_buf_in_flog_list</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*no cover line*/</comment>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>PANIC</name></expr></argument>, <argument><expr><literal type="string">"The buffer %d [%u, %u, %u], %u, %u will be evicted "</literal>
			<literal type="string">"but there is flashback log record of it not flushed"</literal></expr></argument>,
			<argument><expr><name><name>buf</name><operator>-&gt;</operator><name>buf_id</name></name></expr></argument>, <argument><expr><name><name>buf</name><operator>-&gt;</operator><name>tag</name><operator>.</operator><name>rnode</name><operator>.</operator><name>spcNode</name></name></expr></argument>, <argument><expr><name><name>buf</name><operator>-&gt;</operator><name>tag</name><operator>.</operator><name>rnode</name><operator>.</operator><name>dbNode</name></name></expr></argument>,
			<argument><expr><name><name>buf</name><operator>-&gt;</operator><name>tag</name><operator>.</operator><name>rnode</name><operator>.</operator><name>relNode</name></name></expr></argument>, <argument><expr><name><name>buf</name><operator>-&gt;</operator><name>tag</name><operator>.</operator><name>forkNum</name></name></expr></argument>, <argument><expr><name><name>buf</name><operator>-&gt;</operator><name>tag</name><operator>.</operator><name>blockNum</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/* Recover the flashback log, now just recover the logindex */</comment>
<function><type><name>void</name></type>
<name>polar_recover_flog</name><parameter_list>(<parameter><decl><type><name>flog_ctl_t</name></type> <name>instance</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>polar_recover_flog_index</name><argument_list>(<argument><expr><name><name>instance</name><operator>-&gt;</operator><name>logindex_snapshot</name></name></expr></argument>, <argument><expr><name><name>instance</name><operator>-&gt;</operator><name>queue_ctl</name></name></expr></argument>, <argument><expr><name><name>instance</name><operator>-&gt;</operator><name>buf_ctl</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>polar_set_flog_state</name><argument_list>(<argument><expr><name>instance</name></expr></argument>, <argument><expr><name>FLOG_READY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
</unit>
